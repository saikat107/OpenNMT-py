public String print ( final long instant ) { throw unsupported () ; }
public String print ( final ReadableInstant instant ) { throw unsupported () ; }
public String print ( final ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
final char c
final char style
final char style
long value
catch ( IllegalArgumentException pe ) { pe . printStackTrace () ; }
try { retDT = new DateTime ( s , DateTimeZone.UTC ) ; } catch ( IllegalArgumentException pe ) { pe . printStackTrace () ; }
final Object f
final Object f
final Object f
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final DateTimeField field
final DateTimeField field
final char c
final Object element
final DateTimeParser parser
final DateTimeParser parser
final DateTimePrinter printer
final DateTimeFormatter formatter
final Chronology chrono
final DateTimeZone zone
GJWeekyearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getRoughMillisPerYear () ) ; iChronology = chronology ; }
try { retDT = new DateTime ( s ) ; } catch ( IllegalArgumentException pe ) {}
DateTime instant
public abstract boolean equals ( Object object ) ;
final long millis
public long add ( long millis , long value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
{ return add ( millis , ( long ) value - get ( millis ) ) ; }
public long add ( long millis , long value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
int digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
int digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
GJMonthOfYearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getRoughMillisPerMonth () ) ; iChronology = chronology ; }
public int getMinimumValue ( long instant ) { return NUMBER_CONSTANT ; }
public int get ( long instant ) { return BuddhistChronology.BE ; }
IllegalArgumentException e
Chronology chrono = new LenientChronology ( ISOChronology . getInstanceUTC () ) ;
{ return add ( millis , ( long ) value - get ( millis ) ) ; }
public long add ( long millis , long value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
if ( zone == null ) { zone = DateTimeZone . getDefault () ; }
IllegalArgumentException pe
return ( getMillis ( readableInstant ) < readableInstant . getMillis ( this ) ) ;
{ Chronology chrono = getChronology () ; return ( chrono != null ? chrono . getDateTimeZone () : null ) ; }
protected AbstractInstant () { super(); }
if ( zone == null ) { zone = DateTimeZone . getDefault () ; }
long value
long value
public String getNameKey ( long instant ) { return iNameKey ; }
{ if ( ! field . isSupported () ) { throw new UnsupportedOperationException ( STRING_CONSTANT + name + CHAR_CONS ) ; } }
text . length () <= sampleLen + NUMBER_CONSTANT
public DurationPrinter toPrinter () { return toFormatter () ; }
if ( value == NUMBER_CONSTANT && iPrintZeroSetting == PRINT_ZERO_RARELY ) { return - NUMBER_CONSTANT ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
String toString ( ) ;
int getMaximumValue ( ) ;
int getMinimumValue ( ) ;
DurationField getLeapDurationField ( ) ;
boolean isSupported ( ) ;
String getName ( ) ;
String toString ( ) ;
boolean isSupported ( ) ;
String getName ( ) ;
{ if ( chrono == iChronology ) { return this ; } return getAverageYearMonthType ( chrono ) ; }
builder . appendDecimal ( field , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return appendSignedDecimal ( iChronoUTC . centuryOfEra () , minDigits , maxDigits ) ; }
{ return appendDecimal ( iChronoUTC . yearOfCentury () , minDigits , maxDigits ) ; }
{ return appendDecimal ( iChronoUTC . yearOfEra () , minDigits , maxDigits ) ; }
{ return appendSignedDecimal ( iChronoUTC . year () , minDigits , maxDigits ) ; }
{ return appendDecimal ( iChronoUTC . monthOfYear () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . weekyear () , minDigits , maxDigits ) ; }
{ return appendDecimal ( iChronoUTC . weekOfWeekyear () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . dayOfYear () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . dayOfMonth () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . dayOfWeek () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . clockhourOfHalfday () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . hourOfHalfday () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . clockhourOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . hourOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . minuteOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . minuteOfHour () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . secondOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . secondOfMinute () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . millisOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . millisOfSecond () , minDigits , NUMBER_CONSTANT ) ; }
ymd = new DateTimeFormatterBuilder ( iChrono ) . append ( yearElement () ) . append ( monthElement () ) . append ( dayOfMonthElement () ) . toFormatter ()
long scaled = fraction * iScalar / iRangeMillis ;
{ saveField ( new SavedField ( field , text , locale ) ) ; }
{ saveField ( new SavedField ( field , value ) ) ; }
sort ( savedFields , count ) ;
( value < NUMBER_CONSTANT ? NUMBER_CONSTANT : ( ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ) )
int digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
int digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . withMillis ( iField . roundHalfEven ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . withMillis ( iField . roundHalfCeiling ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . withMillis ( iField . roundHalfFloor ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . withMillis ( iField . roundCeiling ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . withMillis ( iField . roundFloor ( instant . getMillis () ) ) ; }
return ( DateTime ) instant . withMillis ( iField . set ( instant . getMillis () , value ) ) ;
return ( DateTime ) instant . withMillis ( iField . addWrapped ( instant . getMillis () , value ) ) ;
return ( DateTime ) instant . withMillis ( iField . add ( instant . getMillis () , value ) ) ;
return ( DateTime ) instant . withMillis ( iField . add ( instant . getMillis () , value ) ) ;
{ return instant . withMillis ( addTo ( instant . getMillis () , scalar ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . withMillis ( iField . roundHalfEven ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . withMillis ( iField . roundHalfCeiling ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . withMillis ( iField . roundHalfFloor ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . withMillis ( iField . roundCeiling ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . withMillis ( iField . roundFloor ( instant . getMillis () ) ) ; }
return ( TimeOnly ) instant . withMillis ( iField . set ( instant . getMillis () , value ) ) ;
return ( TimeOnly ) instant . withMillis ( iField . addWrapped ( instant . getMillis () , value ) ) ;
return ( TimeOnly ) instant . withMillis ( iField . add ( instant . getMillis () , value ) ) ;
return ( TimeOnly ) instant . withMillis ( iField . add ( instant . getMillis () , value ) ) ;
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . withMillis ( iField . roundHalfEven ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . withMillis ( iField . roundHalfCeiling ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . withMillis ( iField . roundHalfFloor ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . withMillis ( iField . roundCeiling ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . withMillis ( iField . roundFloor ( instant . getMillis () ) ) ; }
return ( DateOnly ) instant . withMillis ( iField . set ( instant . getMillis () , value ) ) ;
return ( DateOnly ) instant . withMillis ( iField . addWrapped ( instant . getMillis () , value ) ) ;
return ( DateOnly ) instant . withMillis ( iField . add ( instant . getMillis () , value ) ) ;
return ( DateOnly ) instant . withMillis ( iField . add ( instant . getMillis () , value ) ) ;
ImpreciseCutoverField ( DateTimeField julianField , DateTimeField gregorianField ) { this ( julianField , gregorianField , null , false ) ; }
{ this ( julianField , gregorianField , iCutoverInstant , false ) ; }
{ return appendSignedDecimal ( iChronoUTC . weekyear () , minDigits , maxDigits ) ; }
instant = getBase () . getTimeOnlyMillis ( instant ) ;
DateTimeOfYear dtOfYear = getStartOfYear () ;
{ return localToUTC ( getBase () . getDateTimeMillis ( year , monthOfYear , dayOfMonth , millisOfDay ) ) ; }
{ return localToUTC ( getBase () . getTimeOnlyMillis ( hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ) ; }
int newYear = year + FieldUtils . safeToInt ( value ) ;
int wrapped = FieldUtils . getWrappedValue ( year , value , getMinimumValue () , getMaximumValue () ) ;
int newWeekyear = weekyear + FieldUtils . safeToInt ( value ) ;
int wrapped = FieldUtils . getWrappedValue ( weekyear , value , getMinimumValue () , getMaximumValue () ) ;
fields.centuryOfEra = new DividedDateTimeField ( ISOYearOfEraDateTimeField.INSTANCE , STRING_CONSTANT , STRING_CONSTANT , NUMBER_CONSTANT ) ;
{ return DurationType . getMillisType () ; }
{ return DurationType . getAverageYearMonthType () ; }
{ return PRECISE_YEAR_MONTH_TYPE ; }
{ return AVERAGE_YEAR_MONTH_TYPE ; }
{ super(); iChronology = selectChronology ( chronology ) ; iMillis = DateTimeUtils . currentTimeMillis () ; }
{ super(); iChronology = ISOChronology . getInstance ( zone ) ; iMillis = DateTimeUtils . currentTimeMillis () ; }
{ super(); iChronology = ISOChronology . getInstance () ; iMillis = DateTimeUtils . currentTimeMillis () ; }
{ iChronology = selectChronologyUTC ( chronology ) ; iMillis = resetUnsupportedFields ( toLocalTime ( DateTimeUtils . currentTimeMillis () , chronology , iChronology ) ) ; }
return chrono . withZone ( DateTimeZone . getDefault () ) ;
if ( chrono == null ) { zone = DateTimeZone . getDefault () ; } else { zone = chrono . getZone () ; }
if ( zone == null ) { zone = getZone () ; }
if ( zone == null ) { zone = getZone () ; }
if ( zone == null ) { zone = getZone () ; }
DateTimeZone zone = chrono . getZone () ;
private Object readResolve () { return getInstance ( getBase () . getZone () ) ; }
if ( ! UTC . equals ( provider . getZone ( STRING_CONSTANT ) ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
DateTimeZone zone = cProvider . getZone ( id ) ;
DateTimeZone zone = instant . getZone () ;
DateTimeZone zone = chrono . getZone () ;
if ( zone == null ) { zone = getZone () ; }
{ return print ( millisUTC , chrono . getZone () ) ; }
if ( zone == null ) { zone = getZone () ; }
if ( zone == null ) { zone = getZone () ; }
{ printTo ( out , millisUTC , chrono . getZone () ) ; }
{ printTo ( buf , millisUTC , chrono . getZone () ) ; }
private Object writeReplace () { return new Stub ( getZone () ) ; }
getBase () . getZone () == DateTimeZone.UTC
DateTimeZone zone = getZone () ;
if ( chrono != null && chrono . getZone () == zone ) { return chrono ; }
getZone () == DateTimeZone.UTC
DateTimeZone getZone ( ) ;
public Chronology withUTC () { return withZone ( DateTimeZone.UTC ) ; }
sb . append ( getZone () . getID () ) ;
public Chronology withUTC () { return withZone ( DateTimeZone.UTC ) ; }
DateTimeZone baseZone = base . getZone () ;
{ if ( base == null || isMatchingType ( base ) ) { return getMillis () ; } return getMillis ( base , base . getZone () ) ; }
DateTimeZone zone = chronology . getZone () ;
DateTimeZone zone = original . getZone () ;
assertEquals ( msg + STRING_CONSTANT , z , dt . getZone () ) ;
private Object readResolve () { return getInstance ( getBase () . getZone () ) ; }
private Object readResolve () { return getInstance ( getBase () . getZone () ) ; }
assertSame ( zone , BuddhistChronology . getInstance ( zone ) . getZone () ) ;
assertSame ( zone , BuddhistChronology . getInstance () . getZone () ) ;
DateTimeZone getZone ( ) ;
DateTimeZone zone = getZone () ;
DateTimeZone zone = getZone () ;
DateTimeZone zone = getZone () ;
return new MutableDateTime ( getMillis ( base , chronology . getZone () ) , chronology ) ;
return new MutableDateTime ( getMillis ( base , zone ) , getChronology () . withZone ( zone ) ) ;
DateTimeZone zone = getZone () ;
return new DateTime ( getMillis ( base , chronology . getZone () ) , chronology ) ;
return new DateTime ( getMillis ( base , zone ) , getChronology () . withZone ( zone ) ) ;
if ( this instanceof DateTime && getZone () == zone ) { return ( DateTime ) this ; }
public DateTimeZone getZone () { return null ; }
DateTimeZone zone = getZone () ;
private Object readResolve () { return getInstance ( getBase () . getZone () ) ; }
getZone ()
ZonedDurationField zonedField = new ZonedDurationField ( field , getZone () ) ;
DateTimeZone zone = getZone () ;
{ return localToUTC ( getBase () . getDateTimeMillis ( instant + getZone () . getOffset ( instant ) , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ) ; }
getZone () == DateTimeZone.UTC
public RealMatrix copy () { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
suite . addTest ( UnivariateImplTest . suite () ) ;
setInitialCapacity ( initialCapacity ) ;
setInitialCapacity ( initialCapacity ) ;
protected void setUp ( ) throws Exception { da = new ExpandableDoubleArray () ; }
assertTrue ( STRING_CONSTANT , ( ( ExpandableDoubleArray ) da ) . getInternalLength () < ( ( int ) NUMBER_CONSTANT * NUMBER_CONSTANT ) ) ;
protected void setUp ( ) throws Exception { da = new ContractableDoubleArray () ; }
public synchronized void clear () { eDA . clear () ; }
System . arraycopy ( eDA . getElements () , NUMBER_CONSTANT , copiedArray , NUMBER_CONSTANT , eDA . getNumElements () ) ;
protected void tearDown ( ) throws Exception { da = null ; ra = null ; }
i < ( numElements + startIndex )
i < ( numElements + startIndex )
void clear ( ) ;
double [] getElements ( ) ;
if ( index < NUMBER_CONSTANT ) { String msg = STRING_CONSTANT ; throw new ArrayIndexOutOfBoundsException ( msg ) ; }
public int getN () { return eDA . getNumElements () ; }
public abstract int getN ( ) ;
double n = ( double ) u . getN () ;
abstract int getWindowSize ( ) ;
windowSize != Univariate.INFINITE_WINDOW
windowSize != Univariate.INFINITE_WINDOW
windowSize != Univariate.INFINITE_WINDOW
windowSize != Univariate.INFINITE_WINDOW && windowSize < list . size ()
windowSize != Univariate.INFINITE_WINDOW && windowSize < list . size ()
public CertifiedDataTest ( String name ) { super ( name ) ; }
return lower + ( int ) ( rand . nextDouble () * ( upper - lower + NUMBER_CONSTANT ) ) ;
{ double actual = t . inverseCummulativeProbability ( p ) ; assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = t . cummulativeProbability ( x ) ; assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = exp . inverseCummulativeProbability ( p ) ; TestUtils . assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = exp . cummulativeProbability ( x ) ; TestUtils . assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
int getColumnDimension ( ) ;
int getRowDimension ( ) ;
boolean isSingular ( ) ;
boolean isSquare ( ) ;
double getDeterminant ( ) ;
RealMatrix transpose ( ) ;
{ if ( windowSize != Univariate.INFINITE_WINDOW ) { return super . getVariance () ; } return variance < NUMBER_CONSTANT ? NUMBER_CONSTANT : variance ; }
variance = accum / ( double ) ( values.length - NUMBER_CONSTANT ) ;
{ return sum ( values ) / ( double ) values.length ; }
{ return Math . exp ( sumLog ( values ) / ( double ) values.length ) ; }
{ double actual = Gamma . logGamma ( x ) ; TestUtils . assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ if ( n < NUMBER_CONSTANT ) { return Double.NaN ; } return sumYY ; }
{ return geometricMean ( values , NUMBER_CONSTANT , values.length ) ; }
{ return mean . evaluate ( values ) ; }
{ return geoMean . evaluate ( values ) ; }
{ return sumLog . evaluate ( values ) ; }
{ return product . evaluate ( values ) ; }
{ return sumSq . evaluate ( values ) ; }
{ return sum . evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
double getKurtosis ( ) ;
int getWindowSize ( ) ;
void clear ( ) ;
double getSumsq ( ) ;
double getSum ( ) ;
int getN ( ) ;
double getMin ( ) ;
double getMax ( ) ;
double getStandardDeviation ( ) ;
double getVariance ( ) ;
double getMean ( ) ;
{ return sum ( values ) / ( double ) values.length ; }
{ return geometricMean ( values , NUMBER_CONSTANT , values.length ) ; }
{ return sumLog ( values , NUMBER_CONSTANT , values.length ) ; }
{ return product ( values , NUMBER_CONSTANT , values.length ) ; }
{ return sumSq ( values , NUMBER_CONSTANT , values.length ) ; }
{ return sum ( values , NUMBER_CONSTANT , values.length ) ; }
variance = ( n < NUMBER_CONSTANT ) ? NUMBER_CONSTANT : m2 / ( double ) ( n - NUMBER_CONSTANT ) ;
double [] values
{ return Math . exp ( super . evaluate ( values , begin , length ) / ( double ) length ) ; }
public void clear () { super . clear () ; }
public void clear () { value = Double.NaN ; init = true ; }
public void clear () { super . clear () ; lastVar = NUMBER_CONSTANT ; }
public UnivariateImpl () { super(); }
void clear ( ) ;
if ( test ( values , begin , length ) ) { return sum . evaluate ( values ) / ( ( double ) length ) ; }
protected UnivariateRealSolverFactory () {}
for ( int i = begin ; i < l ; i ++ ) { increment ( values [ i ] ) ; }
double root = UnivariateRealSolverUtil . solve ( rootFindingFunction , bracket [ NUMBER_CONSTANT ] , bracket [ NUMBER_CONSTANT ] ) ;
final double d
final double d
final int n
final int n
final int n
final double d
final double d
final double d
final double d
public void setPropertyName ( final String string ) { propertyName = string ; }
final Object o
final double d
final double d
public void setPercentile ( final double p ) { percentile = p ; }
final double [] values
final double d
public void increment ( final double d ) { super . increment ( d ) ; }
final double d
final double d
final double [] values
final double [] values
final double [] values
final double [] values
final double [] values
final double [] values
final double d
public MathException ( final Throwable throwable ) { super ( throwable ) ; }
public MathException ( final String message ) { super ( message ) ; }
public MathConfigurationException ( final Throwable throwable ) { super ( throwable ) ; }
public MathConfigurationException ( final String message ) { super ( message ) ; }
final double d
final double d
if ( expansionFactor < NUMBER_CONSTANT ) { String msg = STRING_CONSTANT ; throw new IllegalArgumentException ( msg ) ; }
{ String msg = STRING_CONSTANT ; throw new ArrayIndexOutOfBoundsException ( msg ) ; }
protected void setUp ( ) throws Exception { super . setUp () ; b = DistributionFactory . newInstance () . createBinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ try { factory . createBinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {} }
{ try { factory . createBinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { fail ( STRING_CONSTANT ) ; } }
{ try { factory . createBinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { fail ( STRING_CONSTANT ) ; } }
{ try { factory . createBinomialDistribution ( NUMBER_CONSTANT , - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {} }
{ try { factory . createBinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { fail ( STRING_CONSTANT ) ; } }
{ try { factory . createBinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { fail ( STRING_CONSTANT ) ; } }
{ try { factory . createBinomialDistribution ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {} }
public DistributionFactoryImpl () { super(); }
public UnivariateRealSolverFactoryImpl () {}
public ConvergenceException ( String message ) { this ( message , null ) ; }
public BeanListUnivariateImpl ( List list ) { this ( list , null ) ; }
{ super(); setPropertyName ( property ) ; }
{ super(); setName ( name ) ; }
public MathConfigurationException ( final Throwable throwable ) { this ( null , throwable ) ; }
public MathConfigurationException ( final String message ) { this ( message , null ) ; }
{ return min . evaluate ( values ) ; }
{ return max . evaluate ( values ) ; }
{ return variance . evaluate ( values ) ; }
{ return mean . evaluate ( values ) ; }
{ return sumLog . evaluate ( values ) ; }
{ return prod . evaluate ( values ) ; }
{ return sumSq . evaluate ( values ) ; }
{ return sum . evaluate ( values ) ; }
DescriptiveStatistics u = new BeanListUnivariateImpl ( patientList ) ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = new ListUnivariateImpl ( list ) ;
DescriptiveStatistics u = new ListUnivariateImpl ( externalList ) ;
DescriptiveStatistics u = new ListUnivariateImpl ( externalList , transformers ) ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = new StorelessDescriptiveStatisticsImpl () ;
DescriptiveStatistics stats = new StorelessDescriptiveStatisticsImpl () ;
return new Complex ( MathUtils . sinh ( a2 ) / d , Math . sin ( b2 ) / d ) ;
return new Complex ( Math . sin ( a2 ) / d , MathUtils . sinh ( b2 ) / d ) ;
public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
{ URL url = getClass () . getResource ( STRING_CONSTANT ) ; vs . setValuesFileURL ( url ) ; }
empiricalDistribution . load ( url ) ;
vs . resetReplayFile () ;
SummaryStatistics u = SummaryStatistics . newInstance () ;
SummaryStatistics u = SummaryStatistics . newInstance () ;
public void clear () { list . clear () ; }
StatisticalSummary sampleStats
public AbstractDescriptiveStatistics ( int window ) { setWindowSize ( window ) ; }
public AbstractDescriptiveStatistics () {}
sampleStats = SummaryStatistics . newInstance () ;
public abstract long getN ( ) ;
SummaryStatistics u = SummaryStatistics . newInstance () ;
SummaryStatistics stats = SummaryStatistics . newInstance () ;
new Complex ( Math . abs ( z . getImaginary () ) / ( NUMBER_CONSTANT * t ) , MathUtils . indicator ( b ) * t )
public double getMean () { return new Mean ( secondMoment ) . getResult () ; }
empiricalDistribution . load ( url ) ;
public void testNext ( ) throws Exception { tstGen ( NUMBER_CONSTANT ) ; tstDoubleGen ( NUMBER_CONSTANT ) ; }
fail ( STRING_CONSTANT ) ;
{ return ( ( Number ) PropertyUtils . getProperty ( o , getPropertyName () ) ) . doubleValue () ; }
return NUMBER_CONSTANT - tDistribution . cumulativeProbability ( - t , t ) ;
return NUMBER_CONSTANT - tDistribution . cumulativeProbability ( - t , t ) ;
return NUMBER_CONSTANT - chiSquaredDistribution . cumulativeProbability ( chiSquare ( expected , observed ) ) ;
{ double actual = h . cumulativeProbability ( x ) ; assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability1 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability0 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability999 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ double actual = chiSquare . inverseCumulativeProbability ( p ) ; assertEquals ( STRING_CONSTANT + p , expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = chiSquare . cumulativeProbability ( x ) ; assertEquals ( STRING_CONSTANT + x , expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = b . cumulativeProbability ( x ) ; assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
public void testcumulativeProbability8 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability1 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability999 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability001 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ double actual = t . inverseCumulativeProbability ( p ) ; assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = t . cumulativeProbability ( x ) ; assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability999 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability999 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ double actual = f . inverseCumulativeProbability ( p ) ; assertEquals ( STRING_CONSTANT + p , expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = f . cumulativeProbability ( x ) ; assertEquals ( STRING_CONSTANT + x , expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = z . inverseCumulativeProbability ( p ) ; assertEquals ( expected , actual , PRECISION ) ; }
assertEquals ( NUMBER_CONSTANT , z . cumulativeProbability ( z . getMean () + z . getStandardDeviation () ) , PRECISION ) ;
assertEquals ( NUMBER_CONSTANT , z . cumulativeProbability ( mu ) , PRECISION ) ;
{ double actual = exp . inverseCumulativeProbability ( p ) ; TestUtils . assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = exp . cumulativeProbability ( x ) ; TestUtils . assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbabilityPositive () { testValue ( Double.NaN , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbabilityOne () { testValue ( Double.POSITIVE_INFINITY , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbabilityZero () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCumulativeProbabilityZero () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability900 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability950 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability975 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability990 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability999 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability100 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability050 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability025 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability010 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCumulativeProbability001 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability900 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability950 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability975 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability990 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability999 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability100 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability050 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability025 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability010 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCumulativeProbability001 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
return getSlopeStdErr () * getTDistribution () . inverseCumulativeProbability ( NUMBER_CONSTANT - alpha / NUMBER_CONSTANT ) ;
double actual = DistributionFactory . newInstance () . createGammaDistribution ( a , b ) . inverseCumulativeProbability ( p ) ;
double actual = DistributionFactory . newInstance () . createGammaDistribution ( a , b ) . cumulativeProbability ( x ) ;
PolynomialFunction f = new PolynomialFunction ( c ) ;
catch ( MathException e ) { fail ( e . getMessage () ) ; }
catch ( MathException e ) { fail ( e . getMessage () ) ; }
{ bp [ row ] [ col ] = bv [ permutation [ row ] ] [ col ] ; }
{ try { luDecompose () ; return false ; } catch ( InvalidMatrixException ex ) { return true ; } }
{ ( new RealMatrixImpl ( testData2 ) ) . luDecompose () ; fail ( STRING_CONSTANT ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( test ( values , begin , length ) ) { return sum . evaluate ( values , begin , length ) / ( ( double ) length ) ; }
catch ( Exception ex ) { ex . printStackTrace () ; }
protected AbstractDescriptiveStatistics () { super(); }
ExpandableDoubleArray eDA3 = newInstance ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
ExpandableDoubleArray eDA2 = newInstance ( NUMBER_CONSTANT ) ;
try { result = freqTable . getCount ( new Character ( v ) ) ; } catch ( ClassCastException ex ) {}
try { result = freqTable . getCount ( new Long ( v ) ) ; } catch ( ClassCastException ex ) {}
try { result = freqTable . getCount ( new Long ( v ) ) ; } catch ( ClassCastException ex ) {}
try { result = freqTable . getCount ( v ) ; } catch ( ClassCastException ex ) {}
TDistribution tDistribution = getDistributionFactory () . createTDistribution ( degreesOfFreedom ) ;
TDistribution tDistribution = getDistributionFactory () . createTDistribution ( n - NUMBER_CONSTANT ) ;
ChiSquaredDistribution chiSquaredDistribution = getDistributionFactory () . createChiSquareDistribution ( df ) ;
ChiSquaredDistribution chiSquaredDistribution = getDistributionFactory () . createChiSquareDistribution ( ( double ) expected.length - NUMBER_CONSTANT ) ;
{ super(); eDA = new ResizableDoubleArray () ; setWindowSize ( window ) ; }
Iterator iter = freqTable . keySet () . iterator () ;
{ freqTable = new TreeMap ( comparator ) ; }
double det = parity ;
public void clear () { super . clear () ; }
if ( moment.n == NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return moment.m2 / ( ( double ) moment.n - NUMBER_CONSTANT ) ; }
{ sumSq += values [ i ] * values [ i ] ; }
{ variance . increment ( d ) ; }
{ variance = new Variance ( m2 ) ; }
catch ( Throwable t ) { return new UnivariateRealSolverFactoryImpl () ; }
catch ( Throwable t ) { return new DistributionFactoryImpl () ; }
catch ( Throwable t ) { return new DescriptiveStatisticsImpl () ; }
long getN ( ) ;
void resetFunctionValueAccuracy ( ) ;
double getFunctionValueAccuracy ( ) ;
void resetRelativeAccuracy ( ) ;
double getRelativeAccuracy ( ) ;
void resetAbsoluteAccuracy ( ) ;
double getAbsoluteAccuracy ( ) ;
int getMaximalIterationCount ( ) ;
{ return Math . exp ( sumOfLogs . evaluate ( values , begin , length ) / ( double ) length ) ; }
{ sumOfLogs . increment ( d ) ; }
{ os += m . getEntry ( i , j ) + STRING_CONSTANT ; }
{ os += m . getEntry ( i , j ) + STRING_CONSTANT ; }
{ return getInstance () . format ( c ) ; }
public InvalidMatrixException ( String message ) { super ( message ) ; }
PoissonDistribution dist = DistributionFactory . newInstance () . createPoissonDistribution ( DEFAULT_TEST_POISSON_PARAMETER ) ;
PoissonDistribution dist = DistributionFactory . newInstance () . createPoissonDistribution ( NUMBER_CONSTANT ) ;
double t = Math . abs ( homoscedasticT ( m1 , m2 , v1 , v2 , n1 , n2 ) ) ;
{ if ( rand == null ) { rand = new JDKRandomGenerator () ; } rand . setSeed ( System . currentTimeMillis () ) ; }
{ if ( rand == null ) { rand = new JDKRandomGenerator () ; } rand . setSeed ( seed ) ; }
RandomGenerator rand = getRan () ;
RandomGenerator rand = getRan () ;
RandomGenerator rand = getRan () ;
RandomGenerator rand = getRan () ;
RandomGenerator rand = getRan () ;
RandomGenerator ran = getRan () ;
public RandomDataTest ( String name ) { super ( name ) ; randomData = new RandomDataImpl () ; }
{ return solve ( MatrixUtils . createBigIdentityMatrix ( this . getRowDimension () ) ) ; }
{ return solve ( MatrixUtils . createRealIdentityMatrix ( this . getRowDimension () ) ) ; }
private MathUtils () { super(); }
x < a || a < NUMBER_CONSTANT
a >= NUMBER_CONSTANT && x > a
float sign = indicator ( x ) ;
double sign = indicator ( x ) ;
if ( numberOfSuccesses > populationSize ) { throw new IllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public AbstractRandomGeneratorTest ( String name ) { super ( name ) ; randomData = new RandomDataImpl ( testGenerator ) ; }
if ( fm * fmin > NUMBER_CONSTANT ) { min = m ; } else { max = m ; }
z = new Complex ( nan , NUMBER_CONSTANT ) ;
double result = Math . sqrt ( getRSquare () ) ;
{ return sumYY - sumXY * sumXY / sumXX ; }
Number number = format . parse ( source , pos ) ;
{ format . format ( value , toAppendTo , pos ) ; }
public FastSineTransformer () { super(); }
public FastCosineTransformer () { super(); }
public FastFourierTransformer () { super(); }
v = Vector3D . multiply ( NUMBER_CONSTANT , v ) ;
v1 = Vector3D . add ( v1 , v2 ) ;
v1 = Vector3D . subtract ( v1 , v2 ) ;
{ return new Rotation ( - q0 , q1 , q2 , q3 , false ) ; }
public int eventOccurred ( double t , double [] y ) { sign = - sign ; return SwitchingFunction.RESET_STATE ; }
return ( largest.cost - smallest.cost ) < threshold ;
RationalNumber newCoeff = a [ i ] . multiply ( lcm ) ;
double [] estimatedMean = sample . getMean () ;
{ d . setElement ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; d . solve ( b , NUMBER_CONSTANT ) ; }
try { while ( true ) { sum = sampler . nextSamplePoint () . y ; } } catch ( ExhaustedSampleException e ) {}
double [] estimatedMean = sample . getMean () ;
{ return ( EstimatedParameter [] ) coefficients . clone () ; }
{ return ( EstimatedParameter [] ) coefficients . clone () ; }
estimator . estimate ( this ) ;
double [] data = mapper . getDataArray () ;
assertTrue ( mapper . getDataArray () . length == size ) ;
WeightedMeasurement m = new MyMeasurement ( NUMBER_CONSTANT , theoretical () + NUMBER_CONSTANT , this ) ;
WeightedMeasurement m = new MyMeasurement ( NUMBER_CONSTANT , theoretical () + NUMBER_CONSTANT , this ) ;
WeightedMeasurement m = new MyMeasurement ( NUMBER_CONSTANT , theoretical () + NUMBER_CONSTANT , this ) ;
return ( TestProblem [] ) problems . toArray ( new TestProblem [ problems . size () ] ) ;
public ScalarSampleStatisticsTest ( String name ) { super ( name ) ; points = null ; }
double [] mean = sample . getMean () ;
public VectorialSampleStatisticsTest ( String name ) { super ( name ) ; points = null ; }
{ return ( double [] ) interpolatedState . clone () ; }
double [] data = mapper . getDataArray () ;
public void tearDown () { fitter = null ; }
public AbstractCurveFitterTest ( String name ) { super ( name ) ; fitter = null ; }
fail ( STRING_CONSTANT + r + STRING_CONSTANT ) ;
{ l . setElement ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; l . solve ( b , NUMBER_CONSTANT ) ; }
p = ( Polynomial.Rational ) p . multiply ( lcm ) ;
{ u . setElement ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; u . solve ( b , NUMBER_CONSTANT ) ; }
double originalCost = original [ NUMBER_CONSTANT ] . cost ;
public SwitchingFunction [] getSwitchingFunctions () { return new SwitchingFunction [ NUMBER_CONSTANT ] ; }
simplex [ i ] . cost > pointCostPair.cost
{ return ( PointCostPair [] ) minima . clone () ; }
{ simplex [ i ] = new PointCostPair ( vertices [ i ] , Double.NaN ) ; }
simplex [ i ] = new PointCostPair ( vertex , Double.NaN ) ;
RandomVectorGenerator rvg = new CorrelatedRandomVectorGenerator ( statistics . getMean () , statistics . getCovarianceMatrix ( null ) , new UniformRandomGenerator ( seed ) ) ;
BilinearPattern pattern
public double [] getArray () { return ( double [] ) internalArray . clone () ; }
return ( largest.cost - smallest.cost ) < threshold ;
assertTrue ( optimum.cost > NUMBER_CONSTANT ) ;
assertTrue ( optimum.cost > NUMBER_CONSTANT ) ;
try { while ( true ) { sum = sampler . nextSamplePoint () . y ; } } catch ( ExhaustedSampleException e ) {}
String name = Integer . toString ( k ) ;
{ throw new MaxIterationsExceededException ( maxIterations ) ; }
throw new ConvergenceException () ;
super ( buildMessage ( pattern , arguments , Locale.US ) ) ;
super ( buildMessage ( pattern , arguments , Locale.US ) ) ;
{ return ( new BigDecimal ( Double . toString ( x ) ) . setScale ( scale , roundingMethod ) ) . doubleValue () ; }
return getSlopeStdErr () * distribution . inverseCumulativeProbability ( NUMBER_CONSTANT - alpha / NUMBER_CONSTANT ) ;
{ this ( p , new NormalDistributionImpl () ) ; }
HypergeometricDistribution dist = new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
setDistribution ( new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new ChiSquaredDistributionImpl ( NUMBER_CONSTANT ) ) ;
setDistribution ( new BinomialDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new BinomialDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new TDistributionImpl ( NUMBER_CONSTANT ) ) ;
PoissonDistribution dist = new PoissonDistributionImpl ( NUMBER_CONSTANT ) ;
PoissonDistribution dist = new PoissonDistributionImpl ( NUMBER_CONSTANT ) ;
PoissonDistribution dist = new PoissonDistributionImpl ( DEFAULT_TEST_POISSON_PARAMETER ) ;
PoissonDistribution dist = new PoissonDistributionImpl ( DEFAULT_TEST_POISSON_PARAMETER ) ;
PoissonDistribution dist = new PoissonDistributionImpl ( NUMBER_CONSTANT ) ;
setDistribution ( new PascalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new PascalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
public void setUp () { super . setUp () ; testStatistic = TestUtils . getTTest () ; }
public void setUp () { super . setUp () ; testStatistic = TestUtils . getChiSquareTest () ; }
{ MathUtils . factorial ( test ) ; }
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
FastFourierTransformer . scaleArray ( x2 , NUMBER_CONSTANT / Math . sqrt ( x2.length ) ) ;
try { new Percentile ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ return ( internalArray.length / ( ( float ) numElements ) ) > contractionCriteria ; }
if ( normProduct == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
DescriptiveStatistics u = createDescriptiveStatistics () ;
DescriptiveStatistics u = createDescriptiveStatistics () ;
DescriptiveStatistics u = createDescriptiveStatistics () ;
DescriptiveStatistics u = createDescriptiveStatistics () ;
DescriptiveStatistics u = createDescriptiveStatistics () ;
DescriptiveStatistics u = createDescriptiveStatistics () ;
DescriptiveStatistics stats = createDescriptiveStatistics () ;
DescriptiveStatistics u = createDescriptiveStatistics () ;
DescriptiveStatistics u = createDescriptiveStatistics () ;
DescriptiveStatistics u = createDescriptiveStatistics () ;
DescriptiveStatistics u = createDescriptiveStatistics () ;
RungeKuttaStepInterpolator rki = ( RungeKuttaStepInterpolator ) prototype . copy () ;
RungeKuttaStepInterpolator rki = ( RungeKuttaStepInterpolator ) prototype . copy () ;
setSafety ( NUMBER_CONSTANT ) ;
setSafety ( NUMBER_CONSTANT ) ;
{ super ( c , a , b , new GillStepInterpolator () , step ) ; }
{ super ( c , a , b , new EulerStepInterpolator () , step ) ; }
{ super ( c , a , b , new MidpointStepInterpolator () , step ) ; }
{ super ( c , a , b , new ThreeEighthesStepInterpolator () , step ) ; }
{ super ( c , a , b , new ClassicalRungeKuttaStepInterpolator () , step ) ; }
public double getCurrentSignedStepsize () { return stepSize ; }
public double getCurrentSignedStepsize () { return stepSize ; }
TestProblemHandler handler = new TestProblemHandler ( pb , integ ) ;
TestProblemHandler handler = new TestProblemHandler ( pb , integ ) ;
TestProblemHandler handler = new TestProblemHandler ( pb , integ ) ;
TestProblemHandler handler = new TestProblemHandler ( pb , integ ) ;
integ . addSwitchingFunction ( stepProblem , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
integ . addSwitchingFunction ( stepProblem , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
integ . addSwitchingFunction ( stepProblem , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ if ( isNaN () ) { return NaN ; } return createComplex ( - real , - imaginary ) ; }
{ if ( isNaN () ) { return NaN ; } return createComplex ( real , - imaginary ) ; }
{ SummaryStatistics stats = new SummaryStatistics () ; binStats . add ( i , stats ) ; }
sampleStats = new SummaryStatistics () ;
sampleStats = new SummaryStatistics () ;
SummaryStatistics u = new SummaryStatistics () ;
SummaryStatistics stats = new SummaryStatistics () ;
SummaryStatistics stats = new SummaryStatistics () ;
DescriptiveStatistics u = new DescriptiveStatistics () ;
SummaryStatistics oneSidedPStats = new SummaryStatistics () ;
sampleStats = new SummaryStatistics () ;
SummaryStatistics oneSidedPStats = new SummaryStatistics () ;
sampleStats = new SummaryStatistics () ;
DescriptiveStatistics u = new DescriptiveStatistics () ;
BufferedReader in = new BufferedReader ( new InputStreamReader ( CertifiedDataTest . class . getResourceAsStream ( resource ) ) ) ;
{ return ( Object [] ) arguments . clone () ; }
Object [] parts
Object [] parts
{ throw new ConvergenceException ( STRING_CONSTANT + STRING_CONSTANT , new Object [] { Integer . toString ( starts ) } ) ; }
return ( largest . getCost () - smallest . getCost () ) < threshold ;
return ( largest . getCost () - smallest . getCost () ) < threshold ;
assertTrue ( optimum . getCost () > NUMBER_CONSTANT ) ;
assertTrue ( optimum . getCost () > NUMBER_CONSTANT ) ;
simplex [ i ] . getCost () > pointCostPair . getCost ()
double originalCost = original [ NUMBER_CONSTANT ] . getCost () ;
{ throw new EstimationException ( STRING_CONSTANT , new Object [] { new Integer ( maxCostEval ) } ) ; }
VectorialCovariance covStat = new VectorialCovariance ( mean.length , true ) ;
VectorialCovariance stat = new VectorialCovariance ( points [ NUMBER_CONSTANT ] . length , true ) ;
VectorialCovariance stat = new VectorialCovariance ( NUMBER_CONSTANT , true ) ;
{ new VectorialCovariance ( NUMBER_CONSTANT , true ) . increment ( new double [ NUMBER_CONSTANT ] ) ; fail ( STRING_CONSTANT ) ; }
VectorialCovariance covStat = new VectorialCovariance ( mean.length , true ) ;
double c = NUMBER_CONSTANT / ( n * ( isBiasCorrected ? ( n - NUMBER_CONSTANT ) : n ) ) ;
VectorialCovariance covStat = new VectorialCovariance ( vertices [ NUMBER_CONSTANT ] . length , true ) ;
{ return ( StorelessUnivariateStatistic [] ) meanImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) geoMeanImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) sumLogImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) maxImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) minImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) sumSqImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) sumImpl . clone () ; }
try { u . setMeanImpl ( new Sum () ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalStateException ex ) {}
incrementJacobianEvaluationsCounter () ;
incrementJacobianEvaluationsCounter () ;
catch ( IllegalArgumentException e ) {}
catch ( IllegalArgumentException e ) {}
Object [] parts
return NUMBER_CONSTANT * distribution . cumulativeProbability ( - t ) ;
return NUMBER_CONSTANT * distribution . cumulativeProbability ( - t ) ;
return NUMBER_CONSTANT * distribution . cumulativeProbability ( - t ) ;
{ switchesHandler . addSwitchingFunction ( function , maxCheckInterval , convergence , maxIterationCount ) ; }
{ functions = new ArrayList < SwitchState > () ; first = null ; initialized = false ; }
{ return steps . get ( index ) . getInterpolatedState () ; }
{ return steps . get ( index ) . getInterpolatedTime () ; }
public ContinuousOutputModel () { steps = new ArrayList < StepInterpolator > () ; reset () ; }
points = new ArrayList < PointModel > () ;
points = new ArrayList < PointModel > () ;
{ switchesHandler . addSwitchingFunction ( function , maxCheckInterval , convergence , maxIterationCount ) ; }
Collection < > c
Collection < double [] > categoryData
Collection < double [] > categoryData
Collection < double [] > categoryData
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList < Object > () ) ;
Collection < double [] > categoryData
Collection < double [] > categoryData
Collection < double [] > categoryData
certifiedValues = new HashMap < String , Double > () ;
List < Object > list
List < Object > list
public ListUnivariateImpl () { this ( new ArrayList < Object > () ) ; }
Collection < > c
{ this . binCount = binCount ; binStats = new ArrayList < SummaryStatistics > () ; }
public EmpiricalDistributionImpl () { binStats = new ArrayList < SummaryStatistics > () ; }
Collection < double [] > categoryData
Collection < double [] > categoryData
Collection < double [] > categoryData
Class < > key
Class < > key
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList < Object > () , transformers ) ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList < Object > () , transformers ) ;
DescriptiveStatistics u = new ListUnivariateImpl ( new ArrayList < Object > () , transformers ) ;
{ return solve ( MatrixUtils . createBigIdentityMatrix ( getRowDimension () ) ) ; }
public BigMatrix copy () { return new BigMatrixImpl ( this . copyOut () , false ) ; }
final int nRows = v.length ;
{ return solve ( MatrixUtils . createRealIdentityMatrix ( getRowDimension () ) ) ; }
{ new Rotation ( u , Vector3D.ZERO ) ; fail ( STRING_CONSTANT ) ; }
{ Vector3D . angle ( Vector3D.ZERO , Vector3D.PLUS_I ) ; fail ( STRING_CONSTANT ) ; }
{ Vector3D.ZERO . normalize () ; fail ( STRING_CONSTANT ) ; }
assertTrue ( Math . abs ( Vector3D.ZERO . getNorm () ) < NUMBER_CONSTANT ) ;
Object [] parts
Object [] arguments = { Double . valueOf ( NUMBER_CONSTANT ) } ;
Object [] arguments = { Double . valueOf ( NUMBER_CONSTANT ) } ;
if ( offset > NUMBER_CONSTANT ) { throw new SwitchException ( STRING_CONSTANT , new Object [] { Double . valueOf ( t ) } ) ; }
return Double . valueOf ( newA ) ;
return Double . valueOf ( newA ) ;
return Double . valueOf ( newA ) ;
return Double . valueOf ( newA ) ;
Object [] arguments = { Integer . valueOf ( NUMBER_CONSTANT ) , Integer . valueOf ( NUMBER_CONSTANT ) } ;
Object [] arguments = { Integer . valueOf ( NUMBER_CONSTANT ) , Integer . valueOf ( NUMBER_CONSTANT ) } ;
Double pi = Double . valueOf ( Math.PI ) ;
assertFalse ( zero . equals ( Double . valueOf ( NUMBER_CONSTANT ) ) ) ;
{ return Double . valueOf ( o . toString () ) . doubleValue () ; }
assertFalse ( STRING_CONSTANT , u . equals ( Double . valueOf ( NUMBER_CONSTANT ) ) ) ;
Object [] arguments = { Integer . valueOf ( NUMBER_CONSTANT ) , Integer . valueOf ( NUMBER_CONSTANT ) } ;
Object [] arguments = { Integer . valueOf ( NUMBER_CONSTANT ) , Integer . valueOf ( NUMBER_CONSTANT ) } ;
new Object [] { Double . valueOf ( NUMBER_CONSTANT ) }
new Object [] { Double . valueOf ( p ) }
{ super ( STRING_CONSTANT , new Object [] { Integer . valueOf ( maxIterations ) } ) ; this . maxIterations = maxIterations ; }
{ super ( STRING_CONSTANT , new Object [] { Double . valueOf ( value ) , Integer . valueOf ( maxIterations ) } ) ; }
list . add ( Double . valueOf ( one ) ) ;
Object [] arguments = { Integer . valueOf ( NUMBER_CONSTANT ) , Integer . valueOf ( NUMBER_CONSTANT ) } ;
Object [] arguments = { Integer . valueOf ( NUMBER_CONSTANT ) , Integer . valueOf ( NUMBER_CONSTANT ) } ;
assertFalse ( STRING_CONSTANT , u . equals ( Double . valueOf ( NUMBER_CONSTANT ) ) ) ;
assertFalse ( u . equals ( Double . valueOf ( NUMBER_CONSTANT ) ) ) ;
dynaBean . set ( propertyName , Double . valueOf ( v ) ) ;
{ throw new EstimationException ( STRING_CONSTANT , new Object [] { Integer . valueOf ( rows ) , Integer . valueOf ( cols ) } ) ; }
{ return getCumPct ( Long . valueOf ( v ) ) ; }
{ return getCumPct ( Long . valueOf ( v ) ) ; }
{ return getCumFreq ( Long . valueOf ( v ) ) ; }
{ return getCumFreq ( Long . valueOf ( v ) ) ; }
{ return getPct ( Long . valueOf ( v ) ) ; }
{ return getPct ( Long . valueOf ( v ) ) ; }
{ return getCount ( Long . valueOf ( v ) ) ; }
{ return getCount ( Long . valueOf ( v ) ) ; }
{ addValue ( Long . valueOf ( v . longValue () ) ) ; }
Double value = Double . valueOf ( valueString ) ;
Integer input = Integer . valueOf ( NUMBER_CONSTANT ) ;
Double input = Double . valueOf ( expected ) ;
{ throw new EstimationException ( STRING_CONSTANT , new Object [] { Integer . valueOf ( m ) , Integer . valueOf ( p ) } ) ; }
{ throw new EstimationException ( STRING_CONSTANT , new Object [] { Integer . valueOf ( maxCostEval ) } ) ; }
double delta = ( max - min ) / ( Double . valueOf ( binCount ) ) . doubleValue () ;
{ val = Double . valueOf ( str ) . doubleValue () ; sampleStats . addValue ( val ) ; }
super ( STRING_CONSTANT , new Object [] { Integer . valueOf ( dimension1 ) , Integer . valueOf ( dimension2 ) } ) ;
{ super ( STRING_CONSTANT , new Object [] { Double . valueOf ( argument ) } ) ; this . argument = argument ; }
{ ret = Double . valueOf ( value ) ; pos . setIndex ( endIndex ) ; }
markNameProcessed ( nameNode . getQualifiedName () ) ;
{ if ( isNameProcessed ( nameNode . getQualifiedName () ) ) { return RemovalType.REMOVE_ALL ; } jsdocNode . setJSDocInfo ( getAllTypeJSDoc () ) ; return RemovalType.REMOVE_RHS ; }
NodeTraversal . traverseRootsEs6 ( compiler , new RemoveCode ( compiler ) , externs , root ) ;
export . getFirstChild () . getToken () == Token.EXPORT_SPECS
n . getToken ()
Preconditions . checkArgument ( source == null || Token.FUNCTION == source . getToken () ) ;
Preconditions . checkArgument ( source == null || Token.FUNCTION == source . getToken () ) ;
parent . getToken ()
n . getToken ()
while ( moveIt . hasNext () ) { actualTokens . add ( moveIt . next () . getToken () ) ; }
Token secondArgumentType = secondArgument . getToken () ;
assertThat ( cont . getToken () ) . isSameAs ( Token.CONTINUE ) ;
assertThat ( breakStm . getToken () ) . isSameAs ( Token.BREAK ) ;
value . getToken ()
n . getToken ()
parent . getToken ()
rootNameNode . getToken ()
parent . getToken ()
n . getToken ()
changed = changed || finalValue . getToken () != info.initialValue . getToken () || ! finalValue . isEquivalentTo ( info.initialValue ) ;
Token type = n . getToken () ;
{ switch ( n . getFirstChild () . getToken () ) { case HOOK : case AND : case OR : return true ; default: break; } }
{ switch ( n . getToken () ) { case BREAK : case CONTINUE : case RETURN : case THROW : return true ; default: return false ; } }
blockChild . getToken ()
n . getToken ()
subtree . getToken ()
n . getToken ()
if ( typeExprNode . getToken () == Token.QMARK && ! typeExprNode . hasChildren () ) { return true ; }
n . getToken ()
n . getToken ()
{ Preconditions . checkState ( sourceName != null ) ; Preconditions . checkState ( n . getToken () == type , n ) ; }
n . getToken ()
n . getToken ()
node . getToken ()
n . getToken ()
input . getToken ()
n . getParent () . getToken ()
n . getToken ()
n . getToken ()
int parentPrecedence = NodeUtil . precedence ( n . getToken () ) ;
node . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
notChild . getToken ()
n . getToken ()
node . getToken ()
Preconditions . checkArgument ( node . isNew () , STRING_CONSTANT , node . getToken () ) ;
Preconditions . checkArgument ( node . isCall () , STRING_CONSTANT , node . getToken () ) ;
Preconditions . checkArgument ( node . isHook () , STRING_CONSTANT , node . getToken () ) ;
Preconditions . checkArgument ( ( node . isAnd () ) || ( node . isOr () ) , STRING_CONSTANT , node . getToken () ) ;
Preconditions . checkArgument ( hook . isHook () , STRING_CONSTANT , hook . getToken () ) ;
Preconditions . checkArgument ( ( original . isAnd () ) || ( original . isOr () ) , STRING_CONSTANT , original . getToken () ) ;
Token parentType = parent . getToken () ;
{ if ( typeNode . getToken () == Token.BANG ) { typeNode = typeNode . getFirstChild () ; } return typeNode ; }
rhs . getToken ()
Token type = current . getToken () ;
{ assertEquals ( Token.FUNCTION , function . getToken () ) ; assertEquals ( name , NodeUtil . getName ( function ) ) ; }
switch ( n . getParent () . getToken () ) { case VAR : case CATCH : names . add ( n . getString () ) ; break; default: break; }
Token type = n . getToken () ;
switch ( c . getToken () ) { case FUNCTION : case AND : case OR : case HOOK : return true ; default: break; }
cArg . getToken ()
Token type = parent . getToken () ;
Token declarationType = declarationNode . getToken () ;
{ newNode = IR . declaration ( newLHS , newRHS , parent . getToken () ) ; }
{ newNode = IR . declaration ( newLHS , newRHS , parent . getToken () ) ; }
n . getToken ()
n . getToken ()
n . getToken ()
Token parentType = parent . getToken () ;
c . getToken ()
last . getToken ()
n . getToken ()
n . getToken ()
n . getParent () . getToken ()
n . getToken ()
{ @ Override public boolean apply ( Node n ) { return type == n . getToken () ; } }
Token exprKind = expr . getToken () ;
expr . getToken ()
insideQualifiedName || propAccessNode . getParent () . getToken () != Token.ASSIGN
expr . getToken ()
lvalue . getToken ()
Token tokenType = expr . getToken () ;
{ warnInvalidOperand ( expr , expr . getToken () , STRING_CONSTANT , lhsType + STRING_CONSTANT + rhsType ) ; }
if ( ! commonTypes . isNumberScalarOrObj ( pair.type ) ) { warnInvalidOperand ( child , expr . getToken () , JSType.NUMBER , pair.type ) ; }
Token exprKind = expr . getToken () ;
{ warnings . add ( JSError . make ( expr , UNKNOWN_EXPR_TYPE , expr . getToken () . toString () ) ) ; }
dn . getValue () . getToken ()
if ( ! propName . isString () ) { throw new IllegalStateException ( STRING_CONSTANT + propName . getToken () ) ; }
if ( ! propName . isString () ) { throw new IllegalStateException ( STRING_CONSTANT + propName . getToken () ) ; }
assertEquals ( Token.STRING , n . getToken () ) ;
{ assertEquals ( Token.STRING , n . getToken () ) ; visited . append ( n . getString () ) ; }
parent . getToken ()
Token nodeType = input . getToken () ;
n . getToken ()
{ switch ( n . getToken () ) { case CALL : visitCall ( t , n ) ; break; default: break; } }
Node decl = IR . declaration ( cls.name . cloneTree () , cls.constructor.value , exprRoot . getToken () ) . srcref ( exprRoot ) ;
parent . getToken ()
! registerFunc . isValidNodeType ( valueNode . getToken () )
! registerFunc . isValidNodeType ( value . getToken () )
this . getToken ()
this . getToken ()
this . getToken ()
this . getToken ()
return enclosingNode != null && enclosingNode . getToken () != Token.FUNCTION ;
n . getToken ()
{ switch ( n . getToken () ) { case AND : case OR : case HOOK : return true ; default: return false ; } }
lhs . getToken ()
Token parentType = parent . getToken () ;
{ switch ( n . getToken () ) { case HOOK : case AND : case OR : return true ; default: return false ; } }
expr . getToken ()
n . getToken ()
node . getToken ()
node . getToken ()
n . getToken ()
n . getToken ()
assertEquals ( Token.NEW , callsiteNode . getToken () ) ;
assertEquals ( Token.CALL , callsiteNode . getToken () ) ;
assertEquals ( Token.CALL , callsiteNode . getToken () ) ;
n . getToken ()
Token type = n . getToken () ;
n . getToken ()
n . getToken ()
n . getToken ()
expr . getRoot () . getToken ()
n . getToken ()
int expectedArity = Token . arity ( n . getToken () ) ;
switch ( n . getToken () ) { case NAME : validateName ( n ) ; break; case GETPROP : validateGetProp ( n ) ; break; default: break; }
catch ( UnsupportedOperationException e ) { violation ( STRING_CONSTANT + n . getToken () , n ) ; }
{ validateChildCount ( n , NUMBER_CONSTANT ) ; validateNameDeclarationHelper ( n . getToken () , n ) ; }
{ if ( NodeUtil . isNameDeclaration ( n ) ) { validateNameDeclarationHelper ( n . getToken () , n ) ; } else { validateOptionalExpression ( n ) ; } }
if ( body . getToken () == Token.BLOCK ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
n . getFirstChild () . getToken () == Token.EXPORT_SPECS
secondChild . getToken ()
Token type = nextNode . getToken () ;
n . getToken ()
n . getToken ()
n . getToken ()
c . getToken ()
left . getToken ()
TernaryValue result = evaluateComparison ( n . getToken () , left , right , shouldUseTypes ) ;
Node result = performArithmeticOp ( n . getToken () , left , right ) ;
Token type = n . getToken () ;
n . getToken ()
argumentNode . getToken ()
n . getToken ()
n . getToken ()
subtree . getToken ()
subtree . getToken ()
n . getToken ()
n . getToken ()
declType = variable . getToken () ;
n . getToken ()
n . getToken ()
parent . getToken ()
n . getToken ()
n . getToken ()
arg . getToken () != desiredType
val . getToken ()
n . getToken ()
n . getToken ()
switch ( n . getToken () ) { case GETPROP : return n . getLastChild () . getString () ; case MEMBER_FUNCTION_DEF : return n . getString () ; default: break; }
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
if ( node . getToken () == type ) { matchingNodes . add ( node ) ; }
n . getToken ()
Token type = ancestor . getToken () ;
return parent != null && parent . getToken () == Token.EXPONENT && parent . getFirstChild () == n ;
{ return NodeUtil . precedence ( n . getToken () ) < minPrecedence ; }
{ switch ( n . getToken () ) { case LET : case CONST : case FUNCTION : case CLASS : case DO : return true ; default: return false ; } }
while ( firstNonOperator . getToken () == op ) { firstNonOperator = firstNonOperator . getFirstChild () ; }
n . getToken ()
Token parentType = useParent . getToken () ;
Token nodeType = n . getToken () ;
{ switch ( n . getToken () ) { case CALL : annotateCalls ( n ) ; break; default: break; } }
next . getToken ()
value . getToken ()
value . getToken ()
{ Token type = n . getToken () ; return ( type == Token.INC || type == Token.DEC ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT + node . getToken () ) ; }
n . getToken ()
FlowScope rightScope = reverseInterpreter . getPreciserScopeKnowingConditionOutcome ( left , leftOutcome . getOutcomeFlowScope ( left . getToken () , nIsAnd ) , nIsAnd ) ;
left . getToken ()
n . getToken ()
newScope = reverseInterpreter . getPreciserScopeKnowingConditionOutcome ( condition , conditionOutcomes . getOutcomeFlowScope ( condition . getToken () , branch == Branch.ON_TRUE ) , branch == Branch.ON_TRUE ) ;
assertEquals ( Token.SCRIPT , global . getDeclaration () . getNode () . getToken () ) ;
assertEquals ( Token.GETPROP , refs . get ( NUMBER_CONSTANT ) . getNode () . getToken () ) ;
assertEquals ( Token.GETPROP , refs . get ( NUMBER_CONSTANT ) . getNode () . getToken () ) ;
assertEquals ( Token.NAME , refs . get ( NUMBER_CONSTANT ) . getNode () . getToken () ) ;
expr . getToken ()
expr . getToken ()
n . getToken ()
n . getToken ()
Token actualType = cfgNodes . get ( i ) . getValue () . getToken () ;
if ( source . getToken () == startToken ) { assertFalse ( STRING_CONSTANT + startToken + STRING_CONSTANT + STRING_CONSTANT , cfg . isImplicitReturn ( dest ) ) ; return; }
if ( source . getToken () == startToken && cfg . isImplicitReturn ( dest ) ) { return; }
n . getToken ()
if ( isSimpleOp ) { msg = STRING_CONSTANT + n . getToken () . toString () . toLowerCase () + STRING_CONSTANT ; }
Token type = parent . getToken () ;
n . getToken ()
typeNode != null && typeNode . getToken () == Token.STRING
n . getToken ()
definitionParent . getToken ()
n . getToken ()
builder . append ( n . getToken () . toString () ) ;
assertEquals ( Token.VAR , var . getToken () ) ;
type != null && type . getToken () != Token.ARRAY_TYPE
if ( invalidInitializers . contains ( initializer . getToken () ) ) { errorReporter . error ( STRING_CONSTANT , sourceName , lineno ( loopNode.initializer ) , charno ( loopNode.initializer ) ) ; }
if ( invalidInitializers . contains ( initializer . getToken () ) ) { errorReporter . error ( STRING_CONSTANT , sourceName , lineno ( loopNode.initializer ) , charno ( loopNode.initializer ) ) ; }
Token nType = n . getToken () ;
{ switch ( n . getToken () ) { case FOR : case FOR_OF : case WHILE : case DO : return true ; default: return false ; } }
{ switch ( n . getToken () ) { case FOR : case FOR_OF : case WHILE : case DO : case SWITCH : return true ; default: return false ; } }
assertEquals ( Token.FUNCTION , fooNode . getToken () ) ;
assertThat ( enumTypeNode . getToken () ) . isEqualTo ( Token.BANG ) ;
node . getToken () == Token.CALL
{ if ( blockNode . getChildCount () == NUMBER_CONSTANT && blockNode . getFirstChild () . getToken () == Token.THROW ) { return true ; } return false ; }
n . getToken ()
if ( fieldTypeNode . getToken () == Token.COLON ) { fieldNameNode = fieldTypeNode . getFirstChild () ; hasType = true ; }
namedImports . getToken () == Token.IMPORT_SPECS
n . getToken ()
throw new RuntimeException ( STRING_CONSTANT + defSite . getToken () ) ;
n . getToken ()
n . getToken ()
Preconditions . checkState ( nameNode . isGetProp () , STRING_CONSTANT , nameNode . getToken () ) ;
Node newVar = IR . declaration ( child , n . getToken () ) . srcref ( n ) ;
refParent . getToken ()
anc . getToken ()
parent . getToken ()
n . getToken ()
grandparent . getToken ()
n . getToken ()
n . getToken ()
Token pType = parent . getToken () ;
Token type = n . getToken () ;
parent . getToken () == Token.PARAM_LIST
aliasReference . getToken () == Token.STRING_KEY
parent . getToken ()
ancestor . getToken ()
n . getToken ()
n . getToken ()
if ( typeNode . getToken () != Token.EQUALS ) { report ( typeNode , DEFAULT_PARAM_MUST_BE_MARKED_OPTIONAL ) ; }
n . getToken ()
n . getToken ()
node . getToken ()
Token parentNodeType = parent . getToken () ;
key . getToken ()
n . getToken ()
n . getToken ()
n . getParent () . getToken ()
arg . getToken ()
isASTNormalized () && Token.NAME == constructorNameNode . getToken ()
result . getToken ()
node . getToken ()
{ if ( n . getToken () == Token.INSTANCEOF ) { reportIfNonObject ( t , n . getFirstChild () , SUSPICIOUS_INSTANCEOF_LEFT_OPERAND ) ; } }
{ if ( n . getToken () == Token.IN ) { reportIfNonObject ( t , n . getLastChild () , SUSPICIOUS_IN_OPERATOR ) ; } }
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
switch ( n . getToken () ) { case FUNCTION : if ( n . isArrowFunction () ) { visitArrowFunction ( t , n ) ; } break; default: break; }
Token operatorToken = condition . getToken () ;
parent . getToken ()
n . getToken ()
Token type = n . getToken () ;
decl.node . getParent () . getToken ()
Preconditions . checkArgument ( n . isGetProp () , STRING_CONSTANT , n . getToken () , n ) ;
Token nType = n . getToken () ;
val . getToken () == Token.OR
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
control . getToken ()
n . getToken ()
n . getToken () == type
n . getToken ()
int offset = provideStringNode == null ? NUMBER_CONSTANT : getSourceInfoOffset () ;
{ return ! type . isUnresolved () ; }
return isKnown ( n ) && ! isTop ( n ) && isClassType ( n ) && ! isNativeObjectType ( n ) && ! isWhitelistedType ( n ) ;
! isTypeVariable ( n )
! isTypeVariable ( n )
if ( type == null || type . isUnknownType () || type . isTop () ) { return new MatchResult ( allowLooseMatches , allowLooseMatches ) ; }
options . setPreserveGoogProvidesAndRequires ( true ) ;
compilerOptions . setPreserveGoogProvidesAndRequires ( true ) ;
importNode . useSourceInfoFrom ( export ) ;
parent . replaceChild ( export , declaration . detach () ) ;
{ if ( n . getParent () != null ) { n . detach () ; compiler . reportCodeChange () ; } }
if ( root != null ) { root . detach () ; }
if ( rep . isExprResult () ) { rep = rep . getFirstChild () ; rep . detach () ; }
{ changeProxy . replaceWith ( grandparent , parent , parent . getLastChild () . detach () ) ; }
Node condStatement = IR . exprResult ( cond . detach () ) . srcref ( cond ) ;
Node statement = IR . exprResult ( cond . detach () ) . useSourceInfoIfMissingFrom ( cond ) ;
n . getParent () . replaceChild ( n , caseBlock . detach () ) ;
{ maybeBreak . detach () ; reportCodeChange () ; }
{ subtree . detach () ; subtree = null ; }
{ subtree . getParent () . replaceChild ( subtree , right . detach () ) ; reportCodeChange () ; return right ; }
argNode . detach () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detach () ; reportCodeChange () ; return null ; }
{ block . replaceChild ( maybeIf , maybeIf . getLastChild () . detach () ) ; }
Node simplified = new Node ( type , condition . detach () , simplifyShortCircuitBranch ( body ) ) . useSourceInfoIfMissingFrom ( hook ) ;
{ if ( original . getParent () != null ) { original . detach () ; } replacements . add ( original ) ; }
{ for ( Node c : externs . children () ) { if ( ! c . hasChildren () ) { c . detach () ; } } }
if ( expected != null ) { expectedRoot = parseExpectedJs ( expected ) ; expectedRoot . detach () ; }
Node decl = IR . declaration ( pattern . detach () , IR . name ( tempVarName ) , declarationType ) ;
Node replacement = firstArg . detach () ;
{ rhs . detach () ; ancestor . replaceChild ( last , rhs ) ; }
inlineValue ( v , ref , value . detach () ) ;
n . detach () ;
{ if ( node != null && node . getParent () != null ) { node . detach () ; } return node ; }
Node newDeclaration = IR . var ( name . detach () ) . useSourceInfoFrom ( declarationList ) ;
rhs . detach () ;
Node body = IR . block ( IR . returnNode ( returnValue . detach () ) ) ;
if ( i == NUMBER_CONSTANT && first . getString () . isEmpty () ) { add = add . getSecondChild () . detach () ; }
{ n . detach () ; }
for ( PrototypeMemberDeclaration declar : instance.declarations ) { block . addChildToBack ( declar.node . detach () ) ; }
{ compiler . report ( JSError . make ( requireNode , MISSING_MODULE_OR_PROVIDE.level , MISSING_MODULE_OR_PROVIDE , legacyNamespace ) ) ; NodeUtil . getEnclosingStatement ( requireNode ) . detach () ; continue; }
moduleBlockNode . detach () ;
returnStatementNode . detach () ;
{ NodeUtil . getEnclosingStatement ( call ) . detach () ; }
private void updateGoogDeclareLegacyNamespace ( Node call ) { NodeUtil . getEnclosingStatement ( call ) . detach () ; }
if ( ! currentScript.declareLegacyNamespace ) { NodeUtil . getEnclosingStatement ( call ) . detach () ; }
Node replacement = value . detach () ;
Node destObj = n . getSecondChild () . detach () ;
Node newNode = new Node ( newType , left . detach () , newRight . detach () ) ;
if ( NodeUtil . isNumericResult ( left ) ) { parent . replaceChild ( n , left . detach () ) ; reportCodeChange () ; return left ; }
{ parent . getParent () . detach () ; compiler . reportCodeChange () ; }
node . detach () ;
Node method = member . getLastChild () . detach () ;
stringKey = IR . stringKey ( ( member . isGetterDef () || member . getBooleanProp ( Node.COMPUTED_PROP_GETTER ) ) ? STRING_CONSTANT : STRING_CONSTANT , function . detach () )
constructor = member . getFirstChild () . detach () ;
for ( Node child : functionBody . children () ) { newBlock . addChildToBack ( child . detach () ) ; }
Node stringKey = IR . stringKey ( name , n . getFirstChild () . detach () ) ;
{ if ( preserveGoogProvidesAndRequires && explicitNode . hasChildren () ) { return; } explicitNode . detach () ; compiler . reportCodeChange () ; }
if ( typeDeclaration != null ) { compiler . forwardDeclareType ( typeDeclaration ) ; parent . detach () ; compiler . reportCodeChange () ; }
Node value = n . getChildAtIndex ( NUMBER_CONSTANT ) . detach () ;
for ( Node closureRequire : requiresToBeRemoved ) { closureRequire . detach () ; compiler . reportCodeChange () ; }
if ( parent . isExprResult () ) { parent . detach () ; } else { parent . replaceChild ( n , elemValue ) ; }
Node opDetached = op . detach () ;
potentialCallee . detach () ;
Node newGetProp = IR . getprop ( target . detach () , prop . detach () ) ;
callbackFunction . detach () ;
if ( secondExpr != firstExpr ) { secondExpr . detach () ; } else { secondExpr = IR . nullNode () ; }
var . detach () ;
{ expectedRoot = parseExpectedJs ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , expected ) ) ) ; expectedRoot . detach () ; }
clinitAssignedValue . detach () ;
arg . detach () ;
callNode . getParent () . replaceChild ( callNode , replacementNode . detach () ) ;
Node child = n . getLastChild () . detach () ;
{ if ( value != null ) { value . detach () ; } varNode = parent ; }
declParent . detach () ;
bind.target . detach () ;
colon . addChildToBack ( member . detach () ) ;
n . detach () ;
for ( Node child : stringKeys ) { child . detach () ; }
member . detach () ;
indexSignature . detach () ;
body . detach () ;
{ Node ancParent = ancestor . getParent () ; ancParent . replaceChild ( ancestor , ancestor . getLastChild () . detach () ) ; break; }
{ objlit . removeChild ( key ) ; value . detach () ; }
typeString . detach () ;
newBlock . detach () ;
Node stringKey = IR . stringKey ( name , memberDef . getFirstChild () . detach () ) ;
assignmentValue . detach () ;
comma . addChildToBack ( leftMostChild . detach () ) ;
if ( subtree . getChildCount () == NUMBER_CONSTANT ) { subtree . getLastChild () . detach () ; }
if ( ! t . inGlobalScope () && NodeUtil . isHoistedFunctionDeclaration ( value ) ) { parent . addChildToFront ( value . detach () ) ; }
List < Node > assignments = new ArrayList <> () ;
List < Node > nodes = new ArrayList <> () ;
public JSType getJSTypeBeforeCast () { return ( JSType ) getTypeIBeforeCast () ; }
@ Override public boolean isInstanceType () { Preconditions . checkState ( this . isSingletonObj () ) ; return this . getNominalTypeIfSingletonObj () . isClassy () ; }
@ Override public boolean isUnresolved () { return isUnknown () ; }
@ Override public TypeI evaluateTypeExpressionInGlobalScope ( JSTypeExpression expr ) { return createTypeFromCommentNode ( expr . getRoot () ) ; }
String externs = DEFAULT_EXTERNS + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
return fn . isLooseSubtypeOf ( other.fn ) ;
UpdateThisAndArgumentsReferences updater = new UpdateThisAndArgumentsReferences ( compiler ) ;
NameBasedDefinitionProvider defFinder = new NameBasedDefinitionProvider ( compiler , true ) ;
public void testHookOperators4 ( ) throws Exception { checkMarkedCalls ( STRING_CONSTANT + STRING_CONSTANT , ImmutableList . < String > of ( STRING_CONSTANT ) ) ; }
{ this . passUnderTest = new NameBasedDefinitionProvider ( compiler , true ) ; this . compiler = compiler ; }
NameBasedDefinitionProvider defFinder = new NameBasedDefinitionProvider ( compiler , false ) ;
defFinder = new NameBasedDefinitionProvider ( compiler , false ) ;
NameBasedDefinitionProvider defFinder = new NameBasedDefinitionProvider ( compiler , true ) ;
public DefinitionUseSiteFinder ( AbstractCompiler compiler ) { super ( compiler , false ) ; this . nameUseSiteMultimap = LinkedHashMultimap . create () ; }
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.ADDING_PROPERTY_TO_NON_OBJECT , NewTypeInference.INEXISTENT_PROPERTY ) ;
typeCheck ( STRING_CONSTANT , NewTypeInference.ADDING_PROPERTY_TO_NON_OBJECT ) ;
if ( isInTestMode () ) { return new StringWriter () ; }
if ( isInTestMode () ) { return new StringWriter () ; }
passes . add ( checkVariableReferencesForTranspileOnly ) ;
phaseopt . process ( externsNode , externAndJsRoot ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; }
if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; }
if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; }
{ testSame ( ImmutableList . of ( NO_J2CL_SOURCE_FILE , NO_J2CL_SOURCE_FILE2 ) ) ; assertThat ( compiler . getAnnotation ( J2clSourceFileChecker.HAS_J2CL_ANNOTATION_KEY ) ) . isEqualTo ( Boolean.FALSE ) ; }
{ testSame ( ImmutableList . of ( NO_J2CL_SOURCE_FILE , J2CL_SOURCE_FILE , NO_J2CL_SOURCE_FILE2 ) ) ; assertThat ( compiler . getAnnotation ( J2clSourceFileChecker.HAS_J2CL_ANNOTATION_KEY ) ) . isEqualTo ( Boolean.TRUE ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } new StaticFieldGetterSetterInliner ( root ) . run () ; }
{ recvType = recvType . withProperty ( pname , JSType.UNKNOWN ) ; inEnv = updateLvalueTypeInEnv ( inEnv , obj , recvLvalue.ptr , recvType ) ; }
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( EXTERNS + STRING_CONSTANT , code + STRING_CONSTANT , null ) ;
RefactoringDriver driver = new RefactoringDriver.Builder ( scanner ) . addExternsFromCode ( STRING_CONSTANT + externs ) . addInputsFromCode ( originalCode ) . build () ;
ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT + externs ) )
isSomeUnknownType ( n )
{ tracker = new PerformanceTracker ( externsRoot , jsRoot , options.tracer , this . outStream ) ; addChangeHandler ( tracker . getCodeChangeHandler () ) ; }
passes . add ( checkVariableReferences ) ;
phaseopt . process ( externsNode , n ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ process ( null , scriptRoot ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
public static ResourceBundle getBundle ( String baseName , Locale locale ) { return getBundle ( baseName ) ; }
optionalFormals . add ( JSType . join ( t , this . commonTypes . UNDEFINED ) ) ;
boolean noCycles = constructorType . addInterfaces ( extendedInterfaces . isEmpty () ? ImmutableSet . of ( this . commonTypes . getObjectType () ) : extendedInterfaces ) ;
NominalType builtinObject = this . commonTypes . getObjectType () ;
{ builder . addRetType ( this . commonTypes . UNDEFINED ) ; }
builder . addRestFormals ( t != null ? t : this . commonTypes . UNKNOWN ) ;
return t . isSingletonObjWithNull () ? t . removeType ( this . commonTypes . NULL ) : t ;
tdType = this . commonTypes . UNKNOWN ;
try { return getTypeFromCommentHelper ( n , registry , typeParameters ) ; } catch ( UnknownTypeException e ) { return this . commonTypes . UNKNOWN ; }
{ if ( anyNumOrStr == null ) { return t . isSubtypeOf ( this . NUMBER_OR_STRING ) ; } return t . isSubtypeOf ( anyNumOrStr ) ; }
{ if ( numberOrNumber == null ) { return t . isSubtypeOf ( this . STRING ) ; } return t . isSubtypeOf ( stringOrString ) ; }
{ if ( numberOrNumber == null ) { return t . isSubtypeOf ( this . NUMBER ) ; } return t . isSubtypeOf ( numberOrNumber ) ; }
stringOrString = JSType . join ( this . STRING , stringInstance ) ;
numberOrNumber = JSType . join ( this . NUMBER , numberInstance ) ;
ObjectType getStringInstanceObjType () { return stringInstanceObjtype != null ? stringInstanceObjtype : this . TOP_OBJECTTYPE ; }
ObjectType getBooleanInstanceObjType () { return booleanInstanceObjtype != null ? booleanInstanceObjtype : this . TOP_OBJECTTYPE ; }
ObjectType getNumberInstanceObjType () { return numberInstanceObjtype != null ? numberInstanceObjtype : this . TOP_OBJECTTYPE ; }
public JSType getStringInstance () { return stringInstance != null ? stringInstance : this . STRING ; }
public JSType getBooleanInstance () { return booleanInstance != null ? booleanInstance : this . BOOLEAN ; }
public JSType getNumberInstance () { return numberInstance != null ? numberInstance : this . NUMBER ; }
public JSType getRegexpType () { return regexpInstance != null ? regexpInstance : this . UNKNOWN ; }
if ( this . arguments == null ) { return this . UNKNOWN ; }
if ( arrayType == null ) { return this . UNKNOWN ; }
lvalue.type = lvalue.type . mayHaveProp ( pname ) ? lvalue.type . getProp ( pname ) : UNKNOWN ;
if ( doSlicing ) { pair.env = envPutType ( pair.env , name , declType != null ? declType : UNKNOWN ) ; }
! lvalueType . isSubtypeOf ( TOP_OBJECT )
if ( requiredType . mayHaveProp ( pname ) ) { reqPtype = requiredType . getProp ( pname ) ; } else { reqPtype = UNKNOWN ; }
return new EnvTypePair ( env , UNKNOWN ) ;
if ( formalType . isBottom () ) { formalType = UNKNOWN ; }
pair.type = BOOLEAN ;
JSType operandType = requiredType . isNumber () ? NUMBER : UNKNOWN ;
private EnvTypePair analyzeExprBwd ( Node expr , TypeEnv outEnv ) { return analyzeExprBwd ( expr , outEnv , UNKNOWN ) ; }
if ( outerType == null ) { outerType = UNKNOWN ; }
{ JSType tmp = t . getIndexedType () ; return tmp == null ? UNKNOWN : tmp ; }
{ reqPtype = specPtype = UNKNOWN ; }
if ( ! currentScope . hasThis () ) { mayWarnAboutGlobalThis ( expr , currentScope ) ; return new EnvTypePair ( inEnv , UNKNOWN ) ; }
return new EnvTypePair ( env , UNKNOWN ) ;
funType . isOptionalArg ( i ) && pair.type . equals ( UNDEFINED )
rhsPair.type = BOOLEAN ;
{ return analyzeExprFwd ( expr , inEnv , UNKNOWN , UNKNOWN ) ; }
if ( rootNs != null && rootNs . isSubtypeOf ( TOP_OBJECT ) ) { namespaceType = rootNs . getProp ( qname . getAllButLeftmost () ) ; }
if ( ! t . isUnknown () && ! t . equals ( JSType . fromTypeVar ( getCommonTypes () , typeVar ) ) ) { return false ; }
if ( typeMap . isEmpty () ) { return Property . make ( getCommonTypes () . UNKNOWN , null ) ; }
{ NominalType thisWithoutTypemap = this . rawType . getAsNominalType () ; return thisWithoutTypemap . instantiateGenerics ( getCommonTypes () . MAP_TO_UNKNOWN ) ; }
JSType result = getCommonTypes () . TOP ;
JSType result = getCommonTypes () . BOTTOM ;
for ( String typedefName : localTypedefs . keySet () ) { locals . put ( typedefName , this . commonTypes . UNDEFINED ) ; }
{ isTypeVar = true ; type = JSType . fromTypeVar ( this . commonTypes , declaredType . getTypeVariableDefinedLocally ( name ) ) ; }
{ addNamespace ( qnameNode , new NamespaceLit ( this . commonTypes , qnameNode . getQualifiedName () , qnameNode ) ) ; }
{ this . root . setTypeI ( this . commonTypes . fromFunctionType ( declaredType . toFunctionType () ) ) ; }
return this . commonTypes . fromFunctionType ( ctorType ) ;
ObjectType arrayType = this . commonTypes . getArrayInstance () . getObjTypeIfSingletonObj () ;
if ( isTrueOrTruthy () ) { return this . commonTypes . FALSY ; } else if ( isFalseOrFalsy () ) { return TRUTHY ; }
return makeType ( lhs.commonTypes , newtype ) ;
{ JSType maybeScalar = ObjectType . mayTurnLooseObjectToScalar ( t , this . commonTypes ) ; if ( t != maybeScalar ) { return maybeScalar ; } }
JSType result = this . commonTypes . BOTTOM ;
JSType result = this . commonTypes . TOP ;
JSType result = commonTypes.BOTTOM ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) { return commonTypes.STRING ; }
recvType = recvType . removeType ( commonTypes.NULL ) ;
if ( propInferredFunType != null ) { rawType . addUndeclaredClassProperty ( pname , propInferredFunType , getProp ) ; } else { rawType . addUndeclaredClassProperty ( pname , commonTypes.UNKNOWN , getProp ) ; }
if ( t == null ) { t = commonTypes.UNKNOWN ; }
FunctionType getInstanceFunType = ( new FunctionTypeBuilder ( commonTypes ) ) . addRetType ( instanceType ) . buildFunction () ;
if ( t == null ) { t = commonTypes.UNKNOWN ; }
{ this . currentScope . addLocal ( varName , commonTypes.UNKNOWN , false , false ) ; }
JSType resultType = commonTypes.TOP ;
{ Preconditions . checkState ( ! this . isFinalized ) ; super . addUndeclaredProperty ( pname , defSite , this . commonTypes . UNKNOWN , false ) ; }
if ( type == null && isConstant ) { type = this . commonTypes . UNKNOWN ; }
this . randomProps . with ( pname , Property . make ( type == null ? this . commonTypes . UNKNOWN : type , type ) )
this == other || other.ns != null || ! other . getNominalType () . equals ( this . commonTypes . getObjectType () )
if ( other == this . commonTypes . TOP_OBJECTTYPE ) { return true ; }
if ( other == this . commonTypes . TOP_OBJECTTYPE ) { return true ; }
if ( newPropType . isBottom () ) { return newPropType . getCommonTypes () . BOTTOM_PROPERTY_MAP ; }
if ( ! isGeneric () || this . commonTypes . MAP_TO_UNKNOWN . equals ( concreteTypes ) ) { return substituteNominalGenerics ( concreteTypes ) ; }
FunctionTypeBuilder builder = new FunctionTypeBuilder ( f1.commonTypes ) ;
{ if ( ! f . isGeneric () ) { return f ; } return f . instantiateGenerics ( f.commonTypes.MAP_TO_UNKNOWN ) ; }
if ( ! this . commonTypes . allowMethodsAsFunctions && this . receiverType != null && other.receiverType == null ) { return false ; }
FunctionTypeBuilder builder = new FunctionTypeBuilder ( f1.commonTypes ) ;
return out ;
EnvTypePair lhsPair = analyzeExprBwd ( lhs , outEnv ) ;
passes . add ( checkVariableReferencesForTranspileOnly ) ;
phaseopt . process ( externsNode , externAndJsRoot ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
this . rawType . isBuiltinWithName ( STRING_CONSTANT ) && NUMERIC_PATTERN . matcher ( pname ) . matches ()
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
public ProcessDefinesTest () { super ( DEFAULT_EXTERNS + STRING_CONSTANT ) ; allowSourcelessWarnings () ; }
assertThat ( jsDocInfoPrinter . print ( info ) ) . isEqualTo ( output ) ;
assertEquals ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , jsDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , jsDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , jsDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , jsDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , jsDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , jsDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , jsDocInfoPrinter . print ( info ) ) ;
passes . add ( checkVariableReferences ) ;
phaseopt . process ( externsNode , n ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ process ( null , scriptRoot ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
long stop () { return System . currentTimeMillis () - start ; }
replacement . setTypeI ( getNativeStringType () ) ;
passes . add ( checkVariableReferencesForTranspileOnly ) ;
phaseopt . process ( externsNode , externAndJsRoot ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ FindStaticMembers findStaticMembers = new FindStaticMembers () ; TranspilationPasses . processTranspile ( compiler , scriptRoot , findStaticMembers ) ; processInherits ( findStaticMembers.inheritsCalls ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new J2clConstantHoisterPass ( compiler , null ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new J2clEqualitySameRewriterPass ( compiler , j2clChangeTracker ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new J2clConstantHoisterPass ( compiler , j2clChangeTracker ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new J2clClinitPrunerPass ( compiler , j2clChangeTracker ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clClinitPrunerPass ( compiler , null ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clEqualitySameRewriterPass ( compiler , null ) ; }
Node moduleNode = newNode ( Token.MODULE_BODY ) ;
Node methodName = member . getFirstFirstChild () ;
Node lhs = node . getFirstFirstChild () ;
Node clinitFunction = multiExpression . getFirstFirstChild () ;
options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ;
public void disable_testClassMethodUnused2 () { this . mode = TypeInferenceMode.NEITHER ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { this . mode = TypeInferenceMode.NEITHER ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
{ passes . add ( flowSensitiveInlineVariables ) ; if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( lastRemoveUnusedVars () ) ; } }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler , false ) ; }
options . setFoldConstants ( true ) ;
options . setFoldConstants ( true ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler , true ) ; }
options . setRemoveDeadCode ( true ) ;
options . setRemoveDeadCode ( true ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ;
options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ;
public void testInvalidAnnotation5 ( ) throws Exception { testWarning ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
public void testInvalidAnnotation4 ( ) throws Exception { testWarning ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
String globalModuleName = t . getInput () . getPath () . resolveEs6Module ( moduleName ) . toModuleName () ;
String moduleName = t . getInput () . getPath () . toModuleName () ;
String moduleName = t . getInput () . getPath () . resolveEs6Module ( moduleIdentifier . getString () ) . toModuleName () ;
{ moduleName = t . getInput () . getPath () . resolveEs6Module ( importName ) . toModuleName () ; }
public String toModuleName () { return ModuleNames . toModuleName ( path ) ; }
public String toJSIdentifier () { return ModuleNames . toJSIdentifier ( path ) ; }
{ requires . add ( file . resolveEs6Module ( arg ) . toModuleName () ) ; }
String moduleName = t . getInput () . getPath () . toModuleName () ;
ModuleLoader.ModulePath actual
TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , this , true ) ;
assertWarning ( STRING_CONSTANT , RhinoErrorReporter.JSDOC_MISSING_BRACES_WARNING , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ errorReporter . warning ( STRING_CONSTANT + SimpleErrorReporter . getMessage0 ( messageId ) + BAD_TYPE_WIKI_LINK , getSourceName () , lineno , charno ) ; }
{ errorReporter . warning ( STRING_CONSTANT + SimpleErrorReporter . getMessage1 ( messageId , messageArg ) + BAD_TYPE_WIKI_LINK , getSourceName () , lineno , charno ) ; }
{ SourceMapObject sourceMapObject = SourceMapObjectParser . parse ( contents ) ; parse ( sourceMapObject , null ) ; }
SourceMapObject sourceMapObject = SourceMapObjectParser . parse ( contents ) ;
{ for ( MemberDefinition prop : PolymerPassStaticUtils . extractProperties ( objLit , compiler ) ) { prop.name . removeProp ( Node.JSDOC_INFO_PROP ) ; } }
PolymerPassStaticUtils . extractProperties ( objLit , compiler )
overwriteMembersIfPresent ( allProperties , PolymerPassStaticUtils . extractProperties ( descriptor , compiler ) ) ;
return MODULE_JOINER . join ( Arrays . copyOf ( buffer , position ) ) ;
{ GwtProperties p = GwtProperties . load ( STRING_CONSTANT ) ; assertThat ( p . propertyNames () ) . isEmpty () ; }
if ( options.coalesceVariableNames ) { passes . add ( coalesceVariableNames ) ; if ( options.foldConstants ) { passes . add ( peepholeOptimizationsOnce ) ; } }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ Preconditions . checkState ( hasInstanceType () , STRING_CONSTANT , this ) ; return typeOfThis . toObjectType () ; }
{ if ( sideEffectInfo . taintedLocals () . contains ( v ) ) { sideEffectInfo . setTaintsGlobalState () ; sideEffectInfo . resetLocalVars () ; break; } }
if ( defs == null ) { functionInfo . setTaintsGlobalState () ; break; }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
String currentJsSource = getCurrentJsSource () ;
Config config = ParserRunner . createConfig ( mode , Config.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , Config.RunMode.KEEP_GOING , null , true ) ;
{ this ( annotationWhitelist , JsDocParsing.TYPES_ONLY , RunMode.STOP_AFTER_ERROR , suppressionNames , languageMode , false ) ; }
Config config = new Config ( extraAnnotations , parseDocumentation , RunMode.STOP_AFTER_ERROR , extraSuppressions , LanguageMode.ECMASCRIPT3 , true ) ;
Config config = new Config ( extraAnnotations , JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , RunMode.KEEP_GOING , extraSuppressions , LanguageMode.ECMASCRIPT3 , true ) ;
return new ParseResult ( root , comments , features , p . getInlineSourceMap () ) ;
{ return createConfig ( languageMode , JsDocParsing.TYPES_ONLY , RunMode.STOP_AFTER_ERROR , extraAnnotationNames , true ) ; }
{ this ( config , errorReporter , source , offset , false , true ) ; }
jsdoc . getToken ()
return jsdocNode != null && jsdocNode . getToken () == Token.ELLIPSIS ;
Preconditions . checkState ( thisRoot . getToken () == Token.BANG ) ;
boolean isPropDeclared = propNode . getToken () == Token.COLON ;
keyNode . setToken ( Token.STRING_KEY ) ;
keyNode . setToken ( Token.STRING_KEY ) ;
n . getToken ()
Token type = n . getToken () ;
{ return include == nodeTypes . contains ( n . getToken () ) ; }
switch ( node . getToken () ) { case NAME : case STRING : case STRING_KEY : return node . getString () ; default: return compiler . toSource ( node ) ; }
{ Node dollarChildProp = n . getGrandparent () ; dollarChildProp . setToken ( Token.GETELEM ) ; compiler . reportCodeChange () ; }
newOperator . setToken ( complementOperator ) ;
shorthand . setToken ( NodeUtil . getOpFromAssignmentOp ( shorthand ) ) ;
n . setToken ( Token.FOR ) ;
{ if ( n . isConst () ) { handleDeclarationList ( n , n . getParent () ) ; } n . setToken ( Token.VAR ) ; }
declarationList . setToken ( Token.VAR ) ;
parent . setToken ( Token.ASSIGN ) ;
valueNode . getToken ()
node . getToken ()
n . getToken () == Token.DIV && n . getFirstChild () . isNumber () && n . getFirstChild () . getDouble () == NUMBER_CONSTANT
parent . getToken ()
parent . getToken ()
parent . getToken ()
value . getToken ()
node . getToken ()
parent . getToken ()
n . getToken ()
ancestor . getToken ()
{ switch ( node . getToken () ) { case GETTER_DEF : case SETTER_DEF : return true ; default: break; } return false ; }
switch ( key . getToken () ) { case STRING_KEY : case GETTER_DEF : case SETTER_DEF : case MEMBER_FUNCTION_DEF : return key . getString () ; default: break; }
{ switch ( node . getToken () ) { case STRING_KEY : case GETTER_DEF : case SETTER_DEF : case MEMBER_FUNCTION_DEF : return true ; default: break; } return false ; }
return parent != null && parent . getToken () == Token.ASSIGN && parent . getFirstChild () == n ;
current . getToken ()
{ switch ( parent . getToken () ) { case DECLARE : case EXPORT : return true ; default: return isStatementParent ( parent ) ; } }
switch ( parent . getToken () ) { case SCRIPT : case MODULE_BODY : case BLOCK : case LABEL : case NAMESPACE_ELEMENTS : return true ; default: return false ; }
n . getToken ()
n . getToken ()
n . getToken ()
parent . getToken ()
n . getToken ()
n . getToken ()
{ switch ( n . getToken () ) { case FOR : case FOR_OF : case DO : case WHILE : return true ; default: return false ; } }
n . getParent () . getToken ()
{ @ Override public boolean apply ( Node n ) { return n . getToken () == type ; } }
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
switch ( n . getToken () ) { case VOID : return true ; case NAME : return n . getString () . equals ( STRING_CONSTANT ) ; default: break; }
n . getToken ()
n . getToken ()
Preconditions . checkArgument ( callNode . isNew () , STRING_CONSTANT , callNode . getToken () ) ;
n . getToken ()
val . getToken ()
n . getToken ()
{ switch ( n . getToken () ) { case GT : case GE : case LT : case LE : return true ; default: break; } return false ; }
switch ( n . getToken () ) { case EQ : case NE : case SHEQ : case SHNE : case MUL : return true ; default: break; }
n . getToken ()
parent . getToken ()
parent . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
propdef . setToken ( Token.STRING ) ;
name . getToken ()
op . setToken ( assignOp ) ;
n . getToken ()
node . getToken ()
n . setToken ( TEMPLATE_LOCAL_NAME ) ;
n . setToken ( TEMPLATE_TYPE_PARAM ) ;
{ currentProp . setToken ( Token.STRING ) ; newProp = IR . getprop ( objectToExtend . cloneTree () , currentProp ) . srcref ( currentProp ) ; }
parent . getToken ()
importedName . setToken ( Token.NAME ) ;
key . setToken ( Token.STRING_KEY ) ;
key . setToken ( Token.SETTER_DEF ) ;
key . setToken ( Token.GETTER_DEF ) ;
{ irNode . setToken ( Token.BLOCK ) ; }
Token type = valueNode . getToken () ;
n . getToken ()
if ( canFoldStandardConstructors ( n ) ) { n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; reportCodeChange () ; }
member . setToken ( Token.STRING_KEY ) ;
c . setToken ( Token.VAR ) ;
Token pType = root . getParent () . getToken () ;
Token parentType = parent . getToken () ;
return DECLARATION_PARENTS . contains ( parent . getToken () ) ;
parent . getToken ()
{ switch ( n . getToken () ) { case FOR : case FOR_OF : case DO : case WHILE : return true ; default: return false ; } }
n . getToken ()
n . getToken ()
{ for ( Token type : types ) { if ( c . getToken () == type ) { return c ; } } }
n . getToken ()
parent . getToken ()
parent . getToken ()
n . getToken ()
{ Token inverseOperator = NodeUtil . getInverseOperator ( subtree . getToken () ) ; subtree . setToken ( inverseOperator ) ; }
( n . isScript () || n . isFunction () ) && comp . hasScopeChanged ( n )
boolean taintsThis () { return getMask ( TAINTS_THIS_MASK ) ; }
boolean taintsGlobalState () { return getMask ( TAINTS_GLOBAL_STATE_MASK ) ; }
boolean pureFunction () { return getMask ( PURE_FUNCTION_MASK ) ; }
{ if ( node . isFunction () ) { functionSideEffectMap . put ( node , createFunctionInfo ( node , parent ) ) ; } return true ; }
Collection < Definition > defs = getFunctionDefinitions ( definitionProvider , callSite ) ;
this . functionSideEffectMap = new LinkedHashMap <> () ;
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new MinimizeExitPoints ( compiler ) . asCompilerPass () ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new J2clConstantHoisterPass ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clClinitPrunerPass ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clEqualitySameRewriterPass ( compiler ) ; }
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
this . compiler = Preconditions . checkNotNull ( compiler ) ;
if ( ! compiler . getOptions () . useTypesForLocalOptimization ) { return; }
final boolean useTypesForOptimization = compiler . getOptions () . useTypesForLocalOptimization ;
@ Override protected CompilerOptions getOptions ( CompilerOptions options ) { options.useTypesForLocalOptimization = true ; return super . getOptions ( options ) ; }
CompilerPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeFoldConstants ( late , compiler . getOptions () . useTypesForLocalOptimization ) ) ;
{ CompilerOptions options = super . getOptions () ; options.useTypesForLocalOptimization = useTypesForOptimization ; options . setJ2clPass ( CompilerOptions.J2clPassMode.ON ) ; return options ; }
compiler . getOptions () . useTypesForLocalOptimization
boolean useTypesForOptimization = compiler . getOptions () . useTypesForLocalOptimization ;
boolean shouldAmbiguateProperties () { return this . ambiguateProperties ; }
boolean shouldDisambiguateProperties () { return this . disambiguateProperties ; }
MockitoOperations . reportLastControlForStubbing ( null ) ;
replay ( mock ) ;
replay ( mock ) ;
{ verify ( mock ) ; }
{ mock . simpleMethodWithArgument ( STRING_CONSTANT ) ; mock . simpleMethodWithArgument ( STRING_CONSTANT ) ; verify ( mock ) ; }
MockitoOperations . reportLastControlForStubbing ( this ) ;
behavior . addInvocation ( invocationWithMatchers ) ;
public void addInvocation ( InvocationWithMatchers invocation ) { this . registeredInvocations . add ( invocation ) ; }
return proxyFactory . createProxy ( toMock , new MockitoObjectMethodsFilter ( toMock , new MockInvocationHandler ( this ) , name ) ) ;
return proxyFactory . createProxy ( toMock , new MockitoObjectMethodsFilter ( toMock , new MockInvocationHandler ( this ) , null ) ) ;
Field methodField = retrieveField ( MockitoObjectMethodsFilter . class , correctMethod . getName () + STRING_CONSTANT ) ;
if ( returnedType . isPrimitive () ) { returnedType = null ; }
throw new AssertionErrorWrapper ( new AssertionError ( STRING_CONSTANT + actual . toString () + STRING_CONSTANT + errorMessage . toString () ) ) ;
stub ( mock . oneArg ( CrazyMatchers . find ( STRING_CONSTANT ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , CrazyMatchers . not ( notNull () ) , eq ( STRING_CONSTANT ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , CrazyMatchers . not ( isNull () ) , eq ( STRING_CONSTANT ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( CrazyMatchers . or ( eq ( NUMBER_CONSTANT ) , eq ( NUMBER_CONSTANT ) ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( CrazyMatchers . cmpEq ( new BigDecimal ( STRING_CONSTANT ) ) ) ) . andReturn ( STRING_CONSTANT ) ;
assertThat ( new InvocationWithMatchers ( invocation , null ) . hashCode () , equalTo ( NUMBER_CONSTANT ) ) ;
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return first ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return null ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return false ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return first ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return null ; }
{ LastArguments . instance () . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new Find ( regex ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new StartsWith ( prefix ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new EndsWith ( suffix ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new Same ( value ) ) ; return null ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return false ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return null ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return false ; }
{ LastArguments . instance () . reportMatcher ( new Contains ( substring ) ) ; return null ; }
{ MockitoState . instance () . verifyingStarted ( VerifyingMode . times ( exactNumberOfInvocations ) ) ; return mock ; }
{ MockUtil . validateMock ( mock ) ; MockitoState . instance () . verifyingStarted ( VerifyingMode . anyTimes () ) ; return mock ; }
{ LastArguments . instance () . reportMatcher ( new EqualsWithDelta ( value , delta ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportMatcher ( new EqualsWithDelta ( value , delta ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportMatcher ( new Matches ( regex ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( NotNull.NOT_NULL ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( Null.NULL ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new Equals ( value ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportMatcher ( new Equals ( value ) ) ; return false ; }
{ LastArguments . instance () . reportMatcher ( new InstanceOf ( clazz ) ) ; return null ; }
{ LastArguments . instance () . reportMatcher ( Any.ANY ) ; return null ; }
public MethodSelector < T > toThrow ( Throwable throwable ) { mockitoState . reportThrowableToBeSetOnVoidMethod ( throwable ) ; return this ; }
public synchronized void verifyingStarted ( VerifyingMode verify ) { checkForUnfinishedVerification () ; verifyingModeLocal . set ( verify ) ; }
MockitoExpectation controlToStub = MockitoState . instance () . removeControlToBeStubbed () ;
assertFalse ( state . verificationScenario () ) ;
assertSame ( mode , mockitoState . removeVerifyingMode () ) ;
public void setMock ( T mock ) { this . mock = mock ; }
Invocation lastInvocation = behavior . lastInvocation () ;
Invocation invocation
Invocation invocation = registeredInvocation . getInvocation () ;
MockitoExpectation controlToStub = MockitoState . instance () . pullControlToBeStubbed () ;
assertNull ( MockitoState . instance () . pullControlToBeStubbed () ) ;
public boolean withBooleanVarargs ( int value , boolean . . . b ) ;
public MethodSelector < T > toThrow ( Throwable throwable ) { throwableToBeSetOnVoidMethod = throwable ; return this ; }
{ MockControl control = lastControl . get () ; lastControl . set ( null ) ; return control ; }
public MockAwareStub () { super ( Object . class , null ) ; }
catch ( VerificationAssertionError e ) {}
{ if ( exactNumberOfInvocations < NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } return new VerifyingMode ( exactNumberOfInvocations ) ; }
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( VerificationAssertionError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationAssertionError e ) {}
try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( VerificationAssertionError e ) {}
if ( mock == null ) { throw new MockitoException ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationAssertionError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationAssertionError e ) {}
catch ( VerificationAssertionError e ) {}
public NumberOfInvocationsAssertionError ( int expectedInvoked , int actuallyInvoked ) { super ( STRING_CONSTANT + expectedInvoked + STRING_CONSTANT + actuallyInvoked , new LastClassIsCglibEnchantedFilter () ) ; }
VerificationAssertionError expected
VerificationAssertionError expected
VerificationAssertionError expected
VerificationAssertionError expected
try { Mockito . verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationAssertionError expected ) {}
try { Mockito . verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationAssertionError expected ) {}
try { Mockito . verify ( mock ) . clear () ; fail () ; } catch ( VerificationAssertionError expected ) {}
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
try { mockitoState . verifyingStarted ( VerifyingMode . anyTimes () ) ; fail () ; } catch ( MockitoException e ) {}
public NumberOfInvocationsAssertionError ( int expectedInvoked , int actuallyInvoked ) { super ( STRING_CONSTANT + expectedInvoked + STRING_CONSTANT + actuallyInvoked ) ; }
{ if ( actuallyInvoked == NUMBER_CONSTANT ) { throw new VerificationAssertionError ( STRING_CONSTANT + STRING_CONSTANT + invocation . toString () ) ; } }
{ verify ( mock ) ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( MockitoException e ) {} }
{ verify ( mock ) ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( MockitoException e ) {} }
try { verify ( mock ) . get ( NUMBER_CONSTANT ) ; fail () ; } catch ( MockitoException e ) {}
{ String expected = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; assertEquals ( expected , error . getMessage () ) ; }
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
{ message += STRING_CONSTANT + expected + STRING_CONSTANT + STRING_CONSTANT ; }
void simpleMethod ( String argument ) ;
throw new VerificationAssertionError ( STRING_CONSTANT + verificationErrorMessage + STRING_CONSTANT + mockName + STRING_CONSTANT + STRING_CONSTANT + registeredInvocation . toString () ) ;
{ mock . add ( STRING_CONSTANT ) ; fail () ; }
try { reader . read () ; fail () ; } catch ( Exception e ) { assertEquals ( ioException , e ) ; }
public InstanceOf ( Class < > clazz ) { this . clazz = clazz ; }
public static Object newInstance ( Class < > clazz ) throws InstantiationException { return ObjenesisHelper . newInstance ( clazz ) ; }
Class < > paramType
public static Object emptyReturnValueFor ( Class < > type ) { return emptyReturnValueToType . get ( type ) ; }
{ return Mockito . verify ( mock , VerifyingMode . inSequence ( exactNumberOfInvocations , mocks ) ) ; }
{ if ( this . isLastStackElementToRemove ( trace ) ) { lastToRemove = i ; } i ++ ; }
verify ( mock , NUMBER_CONSTANT ) . oneArg ( two ) ;
verify ( map , NUMBER_CONSTANT ) . put ( anyObject () , anyObject () ) ;
strictly . verify ( list , NUMBER_CONSTANT ) . add ( STRING_CONSTANT ) ;
strictly . verify ( list , NUMBER_CONSTANT ) . add ( STRING_CONSTANT ) ;
boolean orderOfInvocationsMatters () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
state . verifyingStarted ( VerifyingMode . atLeastOnce () ) ;
{ verifyZeroInteractions ( mock ) ; fail () ; }
{ verifyNoMoreInteractions ( mock ) ; fail () ; }
{ verify ( mock ) . simpleMethod () ; fail () ; }
verifyNoMoreInteractions ( list , map , set ) ;
assertNotNull ( mock ) ;
assertEquals ( ClassWithoutConstructor . class , superClass ) ;
assertEquals ( Object . class , superClass ) ;
boolean atLeastOnceMode () { return expectedNumberOfInvocations == null ; }
Invocation lastInvocation = behavior . getInvocationForStubbing () . getInvocation () ;
invocation . setSequenceNumber ( mockitoState . nextSequenceNumber () ) ;
assertThat ( new ExpectedInvocation ( invocation , null ) . hashCode () , equalTo ( NUMBER_CONSTANT ) ) ;
ExpectedInvocation invocation
ExpectedInvocation expectedInvocation
ExpectedInvocation expectedInvocation
ExpectedInvocation expected
ExpectedInvocation invocation
ExpectedInvocation expected
ExpectedInvocation expected
ExpectedInvocation expected
ExpectedInvocation expected
ExpectedInvocation invocation
boolean shouldMarkAsVerified = verifyingMode . atLeastOnceMode () || verifyingMode . getExpectedNumberOfInvocations () > verifiedSoFar ;
this . expectedInvocationCount = expectedNumberOfInvocations ;
Invocation invocation = new Invocation ( null , m , args , NUMBER_CONSTANT ) ;
List < InvocationChunk > chunks = registeredInvocations . unverifiedInvocationChunks ( mode ) ;
Invocation similarInvocation = registeredInvocations . findSimilarInvocation ( invocation ) ;
int actuallyInvoked = registeredInvocations . countActual ( expected ) ;
int actualCount = registeredInvocations . countActual ( expected ) ;
registeredInvocations . markInvocationsAsVerified ( expected , verifyingMode ) ;
{ assert invocationForStubbing != null ; registeredInvocations . removeLast () ; this . results . put ( invocationForStubbing , result ) ; }
registered . markInvocationsAsVerified ( new ExpectedInvocation ( simpleMethodInvocation , EMPTY_LIST ) , VerifyingMode . times ( NUMBER_CONSTANT ) ) ;
public void markAllInvocationsAsVerified () { for ( Invocation invocation : invocations ) { invocation . markVerifiedInOrder () ; invocation . markVerified () ; } }
if ( i . isVerifiedInOrder () ) { continue; }
strictly = createStrictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
{ return this . verify ( mock , VerifyingMode . inOrder ( expectedNumberOfInvocations , mocksToBeVerifiedInOrder ) ) ; }
{ if ( mocks.length == NUMBER_CONSTANT ) { Exceptions . mocksHaveToBePassedAsArguments () ; } }
strictly = createStrictOrderVerifier ( mockOne , mockThree ) ;
List < InvocationChunk > chunks = registered . unverifiedInvocationChunks ( inOrder ( null , asList ( mock ) ) ) ;
registered . unverifiedInvocationChunks ( inOrder ( null , dummyMocks ) ) ;
ExpectedInvocation invocation = new ExpectedInvocation ( new InvocationBuilder () . toInvocation () ) ;
catch ( VerificationError e ) {}
catch ( VerificationError expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( VerificationError expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( VerificationError expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( VerificationError expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
@ Test ( expected = VerificationError . class )
@ Test ( expected = VerificationError . class ) public void shouldFailWhenLastMethodCalledFirst () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . oneArg ( true ) ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
@ Test ( expected = VerificationError . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodExpected () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = VerificationError . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsExpected () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
@ Test ( expected = VerificationError . class )
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
VerificationError expected
VerificationError expected
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError expected ) {}
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationError expected ) {}
@ Test ( expected = VerificationError . class ) public void shouldFailVerification ( ) throws Exception { verify ( mock ) . clear () ; }
if ( ! atLeastOnce && actuallyInvoked != expectedInvoked ) { throw new NumberOfInvocationsAssertionError ( expectedInvoked , actuallyInvoked , expected . toString () ) ; }
try { strictly . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
@ Test ( expected = NumberOfInvocationsError . class )
@ Test ( expected = NumberOfInvocationsError . class )
try { verify ( mock ) . clear () ; fail () ; } catch ( NumberOfInvocationsError e ) {}
try { Mockito . verify ( mock , NUMBER_CONSTANT ) . clear () ; fail () ; } catch ( NumberOfInvocationsError e ) {}
catch ( NumberOfInvocationsError e ) { assertTrue ( e . getMessage () . endsWith ( STRING_CONSTANT ) ) ; }
catch ( NumberOfInvocationsError e ) { assertTrue ( e . getMessage () . endsWith ( STRING_CONSTANT ) ) ; }
NumberOfInvocationsError e
NumberOfInvocationsError e
{ this . wanted = value ; this . delta = delta ; }
return Mockito . verify ( mock , VerifyingMode . inOrder ( verifyingMode . wantedCount () , mocksToBeVerifiedInOrder ) ) ;
{ if ( actual == null ) { return false ; } return operator . matchResult ( comparator . compare ( ( T ) actual , wanted ) ) ; }
< T > T verify ( T mock , int wantedNumberOfInvocations ) ;
return matchResult ( ( ( Comparable ) actual ) . compareTo ( wanted ) ) ;
if ( mode . wantedCountIsZero () ) { return; }
{ appendQuoting ( buffer ) ; buffer . append ( wanted ) ; appendQuoting ( buffer ) ; }
buffer . append ( wanted ) ;
public Integer wantedCount () { return wantedInvocationCount ; }
{ reportStrictOrderDiscrepancy ( wanted , chunks . get ( NUMBER_CONSTANT ) . getInvocation () ) ; }
if ( actual != null ) { reportDiscrepancy ( wanted , actual ) ; } else { Exceptions . wantedButNotInvoked ( wanted . toString () ) ; }
if ( m . isBridge () ) { if ( m . getName () . equals ( methodName ) ) { return true ; } }
private void print ( Object message ) { mock . print ( message ) ; }
public void say ( String message ) ;
public void say ( Object message ) ;
{ stub ( mock . simpleMethod () ) . andThrows ( new Exception () ) ; }
{ Strictly strictly = createStrictOrderVerifier ( mock ) ; strictly . verify ( mockTwo ) . simpleMethod () ; }
public synchronized void verifyingStarted ( VerifyingMode verify ) { validateState () ; verifyingModeLocal . set ( verify ) ; }
MockitoState . instance () . validateState () ;
MockitoState . instance () . validateState () ;
if ( unverified != null ) { Exceptions . noMoreInteractionsWanted ( unverified . toString () , message ) ; }
{ assert invocationForStubbing != null ; registeredInvocations . removeLast () ; results . put ( invocationForStubbing , result ) ; }
new IAnswer < Object > () { public Object answer ( ) throws Throwable { throw throwable . fillInStackTrace () ; } }
boolean simpleMethod ( String argument ) ;
String simpleMethod ( int argument ) ;
String simpleMethod ( String argument ) ;
stub ( mock . oneArg ( find ( STRING_CONSTANT ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , not ( notNull () ) , eq ( STRING_CONSTANT ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , not ( isNull () ) , eq ( STRING_CONSTANT ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( or ( eq ( NUMBER_CONSTANT ) , eq ( NUMBER_CONSTANT ) ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( cmpEq ( new BigDecimal ( STRING_CONSTANT ) ) ) ) . andReturn ( STRING_CONSTANT ) ;
@ Test @ Ignore public void shouldDetectProblemsWithMatchers () {}
{ assert invocationForStubbing != null ; registeredInvocations . removeLast () ; stubbed . addFirst ( new StubbedInvocation ( invocationForStubbing , result ) ) ; }
assertTrue ( call . equals ( callWithNewStringInstance ) ) ;
public void appendTo ( StringBuilder buffer ) { buffer . append ( STRING_CONSTANT + clazz . getName () + STRING_CONSTANT ) ; }
public void appendTo ( StringBuilder buffer ) { buffer . append ( STRING_CONSTANT + substring + STRING_CONSTANT ) ; }
public void appendTo ( StringBuilder buffer ) { buffer . append ( STRING_CONSTANT + wanted + STRING_CONSTANT + delta + STRING_CONSTANT ) ; }
StringBuilder buffer
public void appendTo ( StringBuilder buffer ) { buffer . append ( STRING_CONSTANT ) ; }
public void appendTo ( StringBuilder buffer ) { buffer . append ( STRING_CONSTANT ) ; }
StringBuilder buffer
public void appendTo ( StringBuilder buffer ) { buffer . append ( STRING_CONSTANT + prefix + STRING_CONSTANT ) ; }
StringBuilder buffer
StringBuilder buffer
StringBuilder result = new StringBuilder () ;
public void appendTo ( StringBuilder buffer ) { buffer . append ( STRING_CONSTANT + suffix + STRING_CONSTANT ) ; }
StringBuilder buffer
StringBuilder buffer
StringBuilder buffer
public void appendTo ( StringBuilder buffer ) { buffer . append ( STRING_CONSTANT ) ; }
public void appendTo ( StringBuilder buffer ) { buffer . append ( getName () + STRING_CONSTANT + wanted + STRING_CONSTANT ) ; }
void appendTo ( StringBuilder buffer ) ;
StringBuilder sb = new StringBuilder () ;
StringBuilder buffer
StringBuilder buffer
StringBuilder buffer
StringBuilder buffer
StringBuilder buffer
public static synchronized MockitoState instance () { return INSTANCE ; }
public static synchronized LastArguments instance () { return INSTANCE ; }
{ MockitoState . instance () . stubbingCompleted () ; validateThrowable ( throwable ) ; behavior . addResult ( Result . createThrowResult ( throwable ) ) ; }
{ MockitoState . instance () . stubbingCompleted () ; behavior . addResult ( Result . createReturnResult ( value ) ) ; }
public void verifyingStarted ( VerifyingMode verify ) { validateState () ; verifyingMode = verify ; }
{ if ( ! toAssert ) { matcherStack . clear () ; throw new InvalidUseOfMatchersException ( message ) ; } }
{ verify ( mock ) . oneArray ( aryEq ( nullArray ) ) ; }
try { three . simpleMethod ( STRING_CONSTANT ) ; fail () ; } catch ( RuntimeException e ) {}
{ map . put ( call , STRING_CONSTANT ) ; fail () ; }
{ map . put ( invocation , STRING_CONSTANT ) ; fail () ; }
catch ( RuntimeException e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerificationError expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerificationError expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerificationError expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerificationError expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
StackTraceFilter filter = new StackTraceFilter () ;
StackTraceFilter filter = new StackTraceFilter () ;
this . stackTrace = new MockitoException ( STRING_CONSTANT ) ;
StackTraceFilter filter = new StackTraceFilter () ;
catch ( VerificationError e ) { assertThat ( e . getCause () . getMessage () , contains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
Invocation actual = registeredInvocations . findActualInvocation ( wanted ) ;
catch ( NumberOfInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooManyActualInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
{ UndesiredInvocation cause = buildUndesiredInvocationCause ( actualInvocationStackTrace , STRING_CONSTANT , undesired ) ; throw new VerificationError ( join ( STRING_CONSTANT ) , cause ) ; }
{ UndesiredInvocation cause = buildUndesiredInvocationCause ( actualInvocationStackTrace , STRING_CONSTANT , undesired ) ; throw new VerificationError ( join ( STRING_CONSTANT ) , cause ) ; }
try { verify ( mock ) . clear () ; fail () ; } catch ( TooManyActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooLittleActualInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
TooLittleActualInvocationsError e
@ Test ( expected = TooLittleActualInvocationsError . class )
MockitoExceptionTest . class
Exceptions . strictlyWantedInvocationDiffersFromActual ( wanted , actual , actualInvocation . getStackTrace () ) ;
public MethodSelector < T > toThrow ( Throwable throwable ) { stubber . addThrowableForVoidMethod ( throwable ) ; return this ; }
InvocationMatcherTest . class
HasStackTrace firstUndesired = registered . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerifyingMode . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = registered . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerifyingMode . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = registered . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerifyingMode . times ( NUMBER_CONSTANT ) ) ;
registered . markInvocationsAsVerified ( new InvocationMatcher ( null ) , mode ) ;
registered . markInvocationsAsVerified ( new InvocationMatcher ( simpleMethodInvocation ) , times ( NUMBER_CONSTANT ) ) ;
registered . markInvocationsAsVerified ( new InvocationMatcher ( simpleMethodInvocation ) , atLeastOnce () ) ;
registered . markInvocationsAsVerified ( new InvocationMatcher ( simpleMethodInvocation ) , times ( NUMBER_CONSTANT ) ) ;
registered . markInvocationsAsVerified ( new InvocationMatcher ( simpleMethodInvocation ) , inOrder ( null , asList ( mock ) ) ) ;
InvocationMatcher invocation
public void setInvocationForPotentialStubbing ( InvocationMatcher invocation ) { this . invocationForStubbing = invocation ; }
InvocationMatcher invocationWithMatchers
s . setInvocationForPotentialStubbing ( new InvocationBuilder () . toMatchingInvocation () ) ;
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher expected
InvocationMatcher wanted
InvocationMatcher wantedInvocation
InvocationMatcher wantedInvocation
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
public void addInvocation ( InvocationMatcher invocation ) { this . registeredInvocations . add ( invocation . getInvocation () ) ; }
EmptyReturnValuesTest . class
if ( verifyingMode != null ) { behavior . verify ( invocationWithMatchers , verifyingMode ) ; return EmptyReturnValues . emptyValueFor ( method . getReturnType () ) ; }
MockitoStateImplTest . class
mockitoState . validateState () ;
mockitoState . validateState () ;
{ MockUtil . validateMock ( mock ) ; mockitoState . verifyingStarted ( mode ) ; return mock ; }
{ mockitoState . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable ) ) ; }
{ mockitoState . stubbingCompleted () ; addResult ( Result . createReturnResult ( value ) ) ; }
assertNull ( Mockito.mockitoState . pullControlToBeStubbed () ) ;
if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator () ) ; }
if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator () ) ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
timeline . setStartTime ( firstMondayAfter1900 () + NUMBER_CONSTANT * timeline . getSegmentSize () ) ;
{ SegmentedTimeline timeline = new SegmentedTimeline ( DAY_SEGMENT_SIZE , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; timeline . setStartTime ( firstMondayAfter1900 () ) ; return timeline ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
{ this ( time , RegularTimePeriod.DEFAULT_TIME_ZONE , Locale . getDefault () ) ; }
catch ( Exception e ) { e . printStackTrace () ; }
if ( index < NUMBER_CONSTANT || index >= getDatasetCount () ) { throw new IllegalArgumentException ( STRING_CONSTANT + index + STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT || index >= getDatasetCount () ) { throw new IllegalArgumentException ( STRING_CONSTANT + index + STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT || index > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + index + STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT || index > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + index + STRING_CONSTANT ) ; }
clone.seriesShapesVisible = ( BooleanList ) this . seriesShapesVisible . clone () ;
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
int pos = getIndex ( key ) ;
{ return new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; }
g2 . setPaint ( getVolumePaint () ) ;
if ( this . gap != that.gap ) { return false ; }
return super . equals ( obj ) ;
return super . equals ( obj ) ;
return super . equals ( obj ) ;
return super . equals ( obj ) ;
return super . equals ( obj ) ;
return super . equals ( obj ) ;
return super . equals ( obj ) ;
MessageBox messageBox = new MessageBox ( this . canvas . getShell () , SWT.OK | SWT.ICON_ERROR ) ;
SWTChartEditor editor = new SWTChartEditor ( this . canvas . getDisplay () , this . chart ) ;
{ this . switchColors () ; this . gc . fillRectangle ( x , y , width , height ) ; this . switchColors () ; }
{ this . gc . drawLine ( x1 , y1 , x2 , y2 ) ; }
this . gc . setClipping ( clipPath ) ;
{ this . gc . setClipping ( x , y , width , height ) ; }
{ org.eclipse.swt.graphics.Rectangle clip = this . gc . getClipping () ; return new Rectangle ( clip.x , clip.y , clip.width , clip.height ) ; }
{ Path path = toSwtPath ( s ) ; this . gc . setClipping ( path ) ; path . dispose () ; }
{ org.eclipse.swt.graphics.Font swtFont = getSwtFontFromPool ( font ) ; this . gc . setFont ( swtFont ) ; }
this . gc . setForeground ( swtColor ) ;
public void setTransform ( AffineTransform Tx ) { this . gc . setTransform ( toSwtTransform ( Tx ) ) ; }
{ this . gc . drawImage ( image , x , y ) ; }
{ Path path = toSwtPath ( shape ) ; this . gc . drawPath ( path ) ; path . dispose () ; }
swtColor = SWTUtils . toSwtColor ( this . gc . getDevice () , awtColor ) ;
DialValueIndicator i1 = new DialValueIndicator ( NUMBER_CONSTANT ) ;
DialValueIndicator i1 = new DialValueIndicator ( NUMBER_CONSTANT ) ;
protected DialPointer () { this ( NUMBER_CONSTANT ) ; }
this . dialFrame = new ArcDialFrame () ;
suite . addTestSuite ( ArcDialFrameTests . class ) ;
public Color getColor () { return this . myColor ; }
{ if ( this . myColor != null ) { this . myColor . dispose () ; } this . myColor = color ; }
e.gc . setBackground ( SWTPaintCanvas . this . myColor ) ;
this . drawBarOutline = false ;
suite . addTestSuite ( XYSplineRendererTests . class ) ;
suite . addTestSuite ( StandardDialFrameTests . class ) ;
Comparable name
Comparable name
Comparable name
{ this . axis . resizeRange ( factor ) ; }
if ( values != null ) { return Collections . unmodifiableList ( values ) ; } else { return Collections.EMPTY_LIST ; }
{ PeriodAxisLabelInfo clone = ( PeriodAxisLabelInfo ) super . clone () ; return clone ; }
public Stroke getStroke () { return this . strokeCanvas . getStroke () ; }
public Color getOutlinePaint () { return this . outlinePaintCanvas . getColor () ; }
public Color getBackGroundPaint () { return this . backgroundPaintCanvas . getColor () ; }
{ return SWTUtils . toAwtFont ( getDisplay () , this . tickLabelFont , true ) ; }
if ( radius <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p == null ) { return NUMBER_CONSTANT ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
{ CategoryPlot plot = ( CategoryPlot ) iterator . next () ; plot . setFixedDomainAxisSpace ( space , false ) ; }
{ CategoryPlot plot = ( CategoryPlot ) iterator . next () ; plot . setFixedRangeAxisSpace ( space , false ) ; }
this . canvas = new Canvas ( this , SWT.DOUBLE_BUFFERED | SWT.NO_BACKGROUND ) ;
fireChangeEvent () ;
if ( this . baseShapesVisible != flag ) { this . baseShapesVisible = flag ; fireChangeEvent () ; }
{ this . legendItemToolTipGenerator = generator ; fireChangeEvent () ; }
{ this . baseToolTipGenerator = generator ; fireChangeEvent () ; }
{ this . toolTipGenerator = generator ; fireChangeEvent () ; }
{ this . baseItemLabelGenerator = generator ; fireChangeEvent () ; }
{ this . itemLabelGeneratorList . set ( series , generator ) ; fireChangeEvent () ; }
{ this . itemLabelGenerator = generator ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
try { new ComparableObjectSeries ( null ) ; } catch ( IllegalArgumentException e ) { pass = true ; }
{ this . legendItemURLGenerator = generator ; fireChangeEvent () ; }
fireChangeEvent () ;
if ( this . includeBaseInRange != include ) { this . includeBaseInRange = include ; fireChangeEvent () ; }
{ this . negativeItemLabelPositionFallback = position ; fireChangeEvent () ; }
{ this . positiveItemLabelPositionFallback = position ; fireChangeEvent () ; }
{ this . gradientPaintTransformer = transformer ; fireChangeEvent () ; }
{ this . minimumBarLength = min ; fireChangeEvent () ; }
{ this . maximumBarWidth = percent ; fireChangeEvent () ; }
{ this . drawBarOutline = draw ; fireChangeEvent () ; }
{ this . itemMargin = percent ; fireChangeEvent () ; }
{ this . base = base ; fireChangeEvent () ; }
{ this . useFillPaint = flag ; fireChangeEvent () ; }
{ this . drawOutlines = flag ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . useSeriesOffset = offset ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . stagger = shouldStagger ; fireChangeEvent () ; }
{ this . maxItemWidth = percent ; fireChangeEvent () ; }
{ this . renderAsPercentages = asPercentages ; fireChangeEvent () ; }
{ this . itemMargin = margin ; fireChangeEvent () ; }
{ this . fillBox = flag ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . yOffset = yOffset ; fireChangeEvent () ; }
{ this . xOffset = xOffset ; fireChangeEvent () ; }
{ this . errorIndicatorStroke = stroke ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . useSeriesOffset = offset ; fireChangeEvent () ; }
{ this . useFillPaint = flag ; fireChangeEvent () ; }
{ this . baseShapesFilled = flag ; fireChangeEvent () ; }
{ this . seriesShapesFilled . setBoolean ( series , filled ) ; fireChangeEvent () ; }
{ this . shapesFilled = filled ; fireChangeEvent () ; }
{ this . useOutlinePaint = use ; fireChangeEvent () ; }
{ this . drawOutlines = flag ; fireChangeEvent () ; }
{ this . baseShapesVisible = flag ; fireChangeEvent () ; }
{ this . seriesShapesVisible . setBoolean ( series , flag ) ; fireChangeEvent () ; }
{ this . shapesVisible = visible ; fireChangeEvent () ; }
{ this . baseLinesVisible = flag ; fireChangeEvent () ; }
{ this . seriesLinesVisible . setBoolean ( series , flag ) ; fireChangeEvent () ; }
{ this . linesVisible = visible ; fireChangeEvent () ; }
{ this . renderAsPercentages = asPercentages ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . errorIndicatorPaint = paint ; fireChangeEvent () ; }
{ this . renderAsPercentages = asPercentages ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . plotLines = draw ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . yOffset = yOffset ; fireChangeEvent () ; }
{ this . xOffset = xOffset ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . showOutline = show ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . closeTickPaint = paint ; fireChangeEvent () ; }
{ this . openTickPaint = paint ; fireChangeEvent () ; }
{ this . drawCloseTicks = draw ; fireChangeEvent () ; }
{ this . drawOpenTicks = draw ; fireChangeEvent () ; }
{ this . legendItemURLGenerator = generator ; fireChangeEvent () ; }
{ this . legendItemToolTipGenerator = generator ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . foregroundAnnotations . clear () ; this . backgroundAnnotations . clear () ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . baseToolTipGenerator = generator ; fireChangeEvent () ; }
{ this . toolTipGeneratorList . set ( series , generator ) ; fireChangeEvent () ; }
{ this . toolTipGenerator = generator ; fireChangeEvent () ; }
{ this . baseItemLabelGenerator = generator ; fireChangeEvent () ; }
{ this . itemLabelGeneratorList . set ( series , generator ) ; fireChangeEvent () ; }
{ this . itemLabelGenerator = generator ; fireChangeEvent () ; }
{ this . fillBox = flag ; fireChangeEvent () ; }
{ this . boxPaint = paint ; fireChangeEvent () ; }
if ( width != this . boxWidth ) { this . boxWidth = width ; fireChangeEvent () ; }
{ this . useOutlinePaint = flag ; fireChangeEvent () ; }
{ this . useFillPaint = flag ; fireChangeEvent () ; }
{ this . drawOutlines = flag ; fireChangeEvent () ; }
{ this . baseShapesFilled = flag ; fireChangeEvent () ; }
{ this . seriesShapesFilled . setBoolean ( series , flag ) ; fireChangeEvent () ; }
{ this . shapesFilled = filled ; fireChangeEvent () ; }
{ this . baseShapesVisible = flag ; fireChangeEvent () ; }
{ this . seriesShapesVisible . setBoolean ( series , flag ) ; fireChangeEvent () ; }
{ this . shapesVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . baseLinesVisible = flag ; fireChangeEvent () ; }
{ this . seriesLinesVisible . setBoolean ( series , flag ) ; fireChangeEvent () ; }
{ this . linesVisible = visible ; fireChangeEvent () ; }
{ this . roundXCoordinates = round ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
if ( this . drawVolume != flag ) { this . drawVolume = flag ; fireChangeEvent () ; }
{ this . downPaint = paint ; fireChangeEvent () ; }
{ this . upPaint = paint ; fireChangeEvent () ; }
if ( this . autoWidthFactor != autoWidthFactor ) { this . autoWidthFactor = autoWidthFactor ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . roundXCoordinates = round ; fireChangeEvent () ; }
{ this . shapesVisible = flag ; fireChangeEvent () ; }
{ this . showOutline = show ; fireChangeEvent () ; }
{ this . negativeItemLabelPositionFallback = position ; fireChangeEvent () ; }
{ this . positiveItemLabelPositionFallback = position ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . gradientPaintTransformer = transformer ; fireChangeEvent () ; }
{ this . drawBarOutline = draw ; fireChangeEvent () ; }
{ this . margin = margin ; fireChangeEvent () ; }
if ( this . useYInterval != use ) { this . useYInterval = use ; fireChangeEvent () ; }
{ this . base = base ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . capLength = length ; fireChangeEvent () ; }
if ( this . drawYError != draw ) { this . drawYError = draw ; fireChangeEvent () ; }
{ this . drawXError = draw ; fireChangeEvent () ; }
{ this . renderAsPercentages = asPercentages ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . showOutline = show ; fireChangeEvent () ; }
org.eclipse.swt.graphics.Image im = new org.eclipse.swt.graphics.Image ( this . gc . getDevice () , SWTUtils . convertToSWT ( image ) ) ;
{ XYPlot plot = ( XYPlot ) iterator . next () ; plot . setFixedDomainAxisSpace ( space , false ) ; }
{ XYPlot plot = ( XYPlot ) iterator . next () ; plot . setFixedRangeAxisSpace ( space , false ) ; }
sb . append ( STRING_CONSTANT + htmlEscape ( name ) + STRING_CONSTANT + htmlEscape ( name ) + STRING_CONSTANT ) ;
BufferedImage image = new BufferedImage ( imageWidth , imageHeight , BufferedImage.TYPE_INT_ARGB ) ;
{ return createBufferedImage ( width , height , BufferedImage.TYPE_INT_ARGB , info ) ; }
{ return STRING_CONSTANT + URLUtilities . encode ( urlText , STRING_CONSTANT ) + STRING_CONSTANT ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
this . seriesToGroupMap . getGroupIndex ( this . seriesToGroupMap . getGroup ( plot . getDataset ( plot . getIndexOf ( this ) ) . getRowKey ( row ) ) )
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
BufferedImage image = chart . createBufferedImage ( width , height , BufferedImage.TYPE_INT_RGB , info ) ;
BufferedImage image = chart . createBufferedImage ( width , height , BufferedImage.TYPE_INT_RGB , info ) ;
Comparable key
double seriesGap = dataArea . getHeight () * getItemMargin () / ( categoryCount * ( seriesCount - NUMBER_CONSTANT ) ) ;
catch ( Exception e ) { e . printStackTrace () ; }
if ( this . showBase ) { result . append ( this . baseLabel ) ; result . append ( this . powerLabel ) ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
{ this . anchorValue = value ; if ( notify ) { fireChangeEvent () ; } }
{ this . drawSharedDomainAxis = draw ; fireChangeEvent () ; }
{ this . fixedRangeAxisSpace = space ; if ( notify ) { fireChangeEvent () ; } }
{ this . fixedDomainAxisSpace = space ; if ( notify ) { fireChangeEvent () ; } }
{ this . weight = weight ; fireChangeEvent () ; }
{ this . annotations . clear () ; fireChangeEvent () ; }
if ( removed && notify ) { fireChangeEvent () ; }
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . rangeCrosshairValue = value ; if ( isRangeCrosshairVisible () && notify ) { fireChangeEvent () ; } }
if ( this . rangeCrosshairLockedOnData != flag ) { this . rangeCrosshairLockedOnData = flag ; fireChangeEvent () ; }
if ( this . rangeCrosshairVisible != flag ) { this . rangeCrosshairVisible = flag ; fireChangeEvent () ; }
if ( removed && notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
if ( notify ) { fireChangeEvent () ; }
if ( removed && notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
if ( notify ) { fireChangeEvent () ; }
{ this . fixedLegendItems = items ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
if ( this . rangeGridlinesVisible != visible ) { this . rangeGridlinesVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
if ( this . domainGridlinesVisible != visible ) { this . domainGridlinesVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . fixedLegendItems = items ; fireChangeEvent () ; }
{ this . fixedRangeAxisSpace = space ; if ( notify ) { fireChangeEvent () ; } }
{ this . fixedDomainAxisSpace = space ; if ( notify ) { fireChangeEvent () ; } }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . rangeCrosshairValue = value ; if ( isRangeCrosshairVisible () && notify ) { fireChangeEvent () ; } }
if ( this . rangeCrosshairLockedOnData != flag ) { this . rangeCrosshairLockedOnData = flag ; fireChangeEvent () ; }
if ( this . rangeCrosshairVisible != flag ) { this . rangeCrosshairVisible = flag ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . domainCrosshairValue = value ; if ( isDomainCrosshairVisible () && notify ) { fireChangeEvent () ; } }
if ( this . domainCrosshairLockedOnData != flag ) { this . domainCrosshairLockedOnData = flag ; fireChangeEvent () ; }
if ( this . domainCrosshairVisible != flag ) { this . domainCrosshairVisible = flag ; fireChangeEvent () ; }
{ fireChangeEvent () ; }
{ this . annotations . clear () ; fireChangeEvent () ; }
if ( removed && notify ) { fireChangeEvent () ; }
if ( notify ) { fireChangeEvent () ; }
if ( removed && notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
if ( removed && notify ) { fireChangeEvent () ; }
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . rangeTickBandPaint = paint ; fireChangeEvent () ; }
{ this . domainTickBandPaint = paint ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . rangeZeroBaselineVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . domainZeroBaselineVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
if ( this . rangeGridlinesVisible != visible ) { this . rangeGridlinesVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
if ( this . domainGridlinesVisible != visible ) { this . domainGridlinesVisible = visible ; fireChangeEvent () ; }
{ this . weight = weight ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
if ( notify ) { fireChangeEvent () ; }
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
if ( orientation != this . orientation ) { this . orientation = orientation ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
if ( this . rangeGridlinesVisible != visible ) { this . rangeGridlinesVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
if ( this . domainGridlinesVisible != visible ) { this . domainGridlinesVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . data = data ; fireChangeEvent () ; }
{ fireChangeEvent () ; }
{ fireChangeEvent () ; }
if ( this . foregroundAlpha != alpha ) { this . foregroundAlpha = alpha ; fireChangeEvent () ; }
{ this . outlineVisible = visible ; fireChangeEvent () ; }
{ this . backgroundImageAlpha = alpha ; fireChangeEvent () ; }
if ( this . backgroundImageAlignment != alignment ) { this . backgroundImageAlignment = alignment ; fireChangeEvent () ; }
{ this . backgroundImage = image ; fireChangeEvent () ; }
{ this . drawingSupplier = supplier ; fireChangeEvent () ; }
if ( this . backgroundAlpha != alpha ) { this . backgroundAlpha = alpha ; fireChangeEvent () ; }
{ this . insets = insets ; if ( notify ) { fireChangeEvent () ; } }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . noDataMessage = message ; fireChangeEvent () ; }
public int getThrowableCount () { return NUMBER_CONSTANT ; }
suite . addTest ( HashCodeBuilderTest . suite () ) ;
if ( index == NUMBER_CONSTANT ) { return this . cause ; }
Throwable [] throwables = this . getThrowables () ;
Throwable nestedCause = ExceptionUtils . getCause ( this . cause ) ;
{ this . cause = ( Throwable ) cause ; }
List list = new ArrayList () ;
{ return ExceptionUtils . indexOfThrowable ( this . nestable , type , fromIndex ) ; }
{ return ExceptionUtils . getThrowables ( this . nestable ) ; }
if ( index == NUMBER_CONSTANT ) { return this . nestable ; }
Throwable nestedCause = ExceptionUtils . getCause ( this . nestable ) ;
n = getTester1 ( getThrowable ( msgs [ NUMBER_CONSTANT ] ) ) ;
public static Test suite () { return new TestSuite ( NestableErrorTestCase . class ) ; }
{ return new NestableRuntimeExceptionTester2 ( msg , ( Throwable ) n ) ; }
public static Test suite () { return new TestSuite ( NestableRuntimeExceptionTestCase . class ) ; }
public RandomStringUtils () {}
public String getSummaryObjectEndText () { return super . getSummaryObjectEndText () ; }
public String getSummaryObjectStartText () { return super . getSummaryObjectStartText () ; }
public String getSizeEndText () { return super . getSizeEndText () ; }
public String getSizeStartText () { return super . getSizeStartText () ; }
public String getNullText () { return super . getNullText () ; }
public String getFieldSeparator () { return super . getFieldSeparator () ; }
public String getFieldNameValueSeparator () { return super . getFieldNameValueSeparator () ; }
public String getContentEnd () { return super . getContentEnd () ; }
public String getContentStart () { return super . getContentStart () ; }
public String getArraySeparator () { return super . getArraySeparator () ; }
public String getArrayEnd () { return super . getArrayEnd () ; }
public String getArrayStart () { return super . getArrayStart () ; }
public void setArrayContentDetail ( boolean arrayContentDetail ) { super . setArrayContentDetail ( arrayContentDetail ) ; }
public void setDefaultFullDetail ( boolean defaultFullDetail ) { super . setDefaultFullDetail ( defaultFullDetail ) ; }
public void setUseFieldNames ( boolean useFieldNames ) { super . setUseFieldNames ( useFieldNames ) ; }
public void setUseIdentityHashCode ( boolean useIdentityHashCode ) { super . setUseIdentityHashCode ( useIdentityHashCode ) ; }
public void setShortClassName ( boolean shortClassName ) { super . setShortClassName ( shortClassName ) ; }
public void setUseClassName ( boolean useClassName ) { super . setUseClassName ( useClassName ) ; }
if ( style == null ) { style = getDefaultStyle () ; }
String linebreak = SystemUtils.LINE_SEPARATOR ;
if ( entry == null ) { return EMPTY_MAP ; }
catch ( ExceptionInInitializerError ex ) { assertTrue ( ex . getException () instanceof IllegalArgumentException ) ; }
catch ( ExceptionInInitializerError ex ) { assertTrue ( ex . getException () instanceof IllegalArgumentException ) ; }
catch ( ExceptionInInitializerError ex ) { assertTrue ( ex . getException () instanceof IllegalArgumentException ) ; }
suite . addTest ( TestExecutorUtils . suite () ) ;
public Number getMaximum () { return max ; }
{ if ( member == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return Modifier . isPublic ( member . getModifiers () ) ; }
! ReflectionUtils . isCompatable ( parameterTypes [ n ] , methodsParams [ n ] )
! ReflectionUtils . isCompatible ( parameterTypes [ n ] , methodsParams [ n ] )
methods [ i ] . getName () . equals ( methodName ) && ReflectionUtils . isCompatible ( paramTypes , methods [ i ] . getParameterTypes () )
catch ( ReflectionException e ) {}
DefaultToStringStyle () { super(); }
private DefaultToStringStyle () { super(); }
{ try { TransformerUtils . switchMapTransformer ( EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { TransformerUtils . switchTransformer ( EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { ExecutorUtils . switchMapExecutor ( EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { ExecutorUtils . switchExecutor ( EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { TransformerUtils . switchMapTransformer ( Collections.EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { TransformerUtils . switchTransformer ( Collections.EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { ExecutorUtils . switchMapExecutor ( Collections.EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { ExecutorUtils . switchExecutor ( Collections.EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
this . clss = listener ;
Method method = getMethod ( object . getClass () , methodName , parameterTypes ) ;
{ try { TransformerUtils . switchMapTransformer ( new HashMap () ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { TransformerUtils . switchTransformer ( new HashMap () ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { ExecutorUtils . switchMapExecutor ( new HashMap () ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { ExecutorUtils . switchExecutor ( new HashMap () ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
buf . append ( ClassUtils . getShortClassName ( th , STRING_CONSTANT ) ) ;
withoutCause = createExceptionWithoutCause () ;
{ ByteArrayOutputStream baos = new ByteArrayOutputStream ( NUMBER_CONSTANT ) ; serialize ( obj , baos ) ; return baos . toByteArray () ; }
return ( cls . getName () . indexOf ( CHAR_CONS ) >= NUMBER_CONSTANT ) ;
String shortName = Enum . getEnumClassName ( getClass () ) ;
String shortName = Enum . getEnumClassName ( getClass () ) ;
{ frames . add ( WRAPPED_MARKER + throwables [ i ] . toString () ) ; }
String shortName = Enum . getEnumClass ( getClass () ) . getName () ;
Entry entry = ( Entry ) cEnumClasses . get ( Enum . getEnumClass ( getClass () ) ) ;
Null () {}
ArrayUtils . reverseArray ( strs ) ;
{ return join ( array , null ) ; }
ArrayUtils . reverse ( strs ) ;
{ iso = entityValue ( entity ) ; }
{ return nextInt ( JVM_RANDOM , n ) ; }
public long nextLong () { return ( long ) ( Math . random () * Long.MAX_VALUE ) ; }
{ return ( int ) ( Math . random () * n ) ; }
{ return random ( count , NUMBER_CONSTANT , set.length , false , false , set ) ; }
public void printPartialStackTrace ( PrintWriter out ) { super . printStackTrace ( out ) ; }
{ return STRING_ALPHANUMERIC_IDENTIFIER_FACTORY . nextStringIdentifier () ; }
{ return STRING_NUMERIC_IDENTIFIER_FACTORY . nextStringIdentifier () ; }
{ return LONG_IDENTIFIER_FACTORY . nextLongIdentifier () ; }
return ( cls . getName () . indexOf ( INNER_CLASS_SEPARATOR_CHAR ) >= NUMBER_CONSTANT ) ;
int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ;
ReflectionToStringBuilder . isRegistered ( value ) && ! ( value instanceof Number || value instanceof Boolean || value instanceof Character )
assertTrue ( ReflectionToStringBuilder . getRegistry () . isEmpty () ) ;
end = ( int ) CHAR_CONS + NUMBER_CONSTANT ;
if ( lastIdx <= NUMBER_CONSTANT ) { return STRING_CONSTANT ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , object , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
assertEquals ( STRING_CONSTANT , cal , DateUtils . truncate ( cal , Calendar.DATE ) , NUMBER_CONSTANT ) ;
final Object array
final Object array
public BinaryEntityMap ( int growBy ) { super ( growBy ) ; }
{ return Entities.XML . unescape ( str ) ; }
{ return Entities.XML . escape ( str ) ; }
{ return Entities.HTML40 . unescape ( str ) ; }
{ return Entities.HTML40 . escape ( str ) ; }
{ entities . entityName ( isovalue ( i ) ) ; }
{ buf . append ( STRING_CONSTANT ) ; char ch = isovalue ( i ) ; buf . append ( ch ) ; }
if ( pads > PAD_LIMIT ) { return leftPad ( str , size , CHAR_CONS ) ; }
if ( pads > PAD_LIMIT ) { return rightPad ( str , size , CHAR_CONS ) ; }
assertEquals ( - NUMBER_CONSTANT , ArrayUtils . lastIndexOf ( array , STRING_CONSTANT , NUMBER_CONSTANT ) ) ;
assertEquals ( - NUMBER_CONSTANT , ArrayUtils . indexOf ( array , STRING_CONSTANT , NUMBER_CONSTANT ) ) ;
{ ObjectUtils . appendIdentityToString ( buffer , value ) ; }
{ ObjectUtils . appendIdentityToString ( this . getStringBuffer () , object ) ; return this ; }
assertEquals ( true , StringUtils . isNotEmptyTrimmed ( null ) ) ;
assertEquals ( false , StringUtils . isEmptyTrimmed ( null ) ) ;
assertEquals ( true , StringUtils . isNotEmpty ( null ) ) ;
assertEquals ( false , StringUtils . isEmpty ( null ) ) ;
if ( pads > PAD_LIMIT ) { return leftPad ( str , size , String . valueOf ( padChar ) ) ; }
AccessibleObject . setAccessible ( fields , true ) ;
try { SerializationUtils . deserialize ( ( byte [] ) null ) ; } catch ( IllegalArgumentException ex ) { return; }
try { SerializationUtils . deserialize ( ( InputStream ) null ) ; } catch ( IllegalArgumentException ex ) { return; }
try { SerializationUtils . serialize ( null , null ) ; } catch ( IllegalArgumentException ex ) { return; }
try { SerializationUtils . serialize ( iMap , null ) ; } catch ( IllegalArgumentException ex ) { return; }
if ( StringUtils . isEmpty ( className ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( StringUtils . isEmpty ( className ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( StringUtils . isEmpty ( className ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( StringUtils . isEmpty ( name ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
AccessibleObject . setAccessible ( fields , true ) ;
AccessibleObject . setAccessible ( fields , true ) ;
AccessibleObject . setAccessible ( fields , true ) ;
try { method = interfaces [ i ] . getDeclaredMethod ( methodName , parameterTypes ) ; } catch ( NoSuchMethodException e ) {}
{ try { RandomUtils.JVM_RANDOM . setSeed ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( UnsupportedOperationException ex ) {} }
catch ( NumberFormatException ex ) {}
catch ( NumberFormatException ex ) {}
catch ( NumberFormatException ex ) {}
catch ( NumberFormatException ex ) {}
catch ( NumberFormatException ex ) {}
catch ( NumberFormatException ex ) {}
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = superCompareTo ; return this ; }
{ rule = new StringLiteral ( sub ) ; }
{ iTotal = iTotal * iConstant + value ; return this ; }
{ iTotal = iTotal * iConstant + value ; return this ; }
{ iTotal = iTotal * iConstant + value ; return this ; }
assertEquals ( CHAR_CONS , Entities.XML . entityValue ( STRING_CONSTANT ) ) ;
String entityValue = Entities.ISO8859_1_ARRAY [ i % Entities.ISO8859_1_ARRAY.length ] [ NUMBER_CONSTANT ] ;
String entityValue = Entities.HTML40_ARRAY [ i % Entities.HTML40_ARRAY.length ] [ NUMBER_CONSTANT ] ;
{ if ( ! validateNumber ( str ) ) { return null ; } return new BigDecimal ( str ) ; }
{ if ( ! validateNumber ( str ) ) { return null ; } return new BigInteger ( str ) ; }
{ if ( ! validateNumber ( str ) ) { return null ; } return Long . valueOf ( str ) ; }
{ if ( ! validateNumber ( str ) ) { return null ; } return Integer . decode ( str ) ; }
{ if ( ! validateNumber ( str ) ) { return null ; } return Double . valueOf ( str ) ; }
{ if ( ! validateNumber ( str ) ) { return null ; } return Float . valueOf ( str ) ; }
{ if ( str == null ) { return null ; } return new BigInteger ( str ) ; }
{ if ( str == null ) { return null ; } return Long . valueOf ( str ) ; }
{ if ( str == null ) { return null ; } return Integer . decode ( str ) ; }
{ if ( str == null ) { return null ; } return Double . valueOf ( str ) ; }
{ if ( str == null ) { return null ; } return Float . valueOf ( str ) ; }
assertEquals ( STRING_CONSTANT , f . nextIdentifier () ) ;
{ return random ( count , start , end , letters , numbers , null , RANDOM ) ; }
if ( out == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( out == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( objectData == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( inputStream == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( outputStream == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( causeFrames == null || wrapperFrames == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( writer == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( stream == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( array1 == null || array2 == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ Validate . notNull ( null ) ; fail ( STRING_CONSTANT ) ; }
{ Validate . isTrue ( false ) ; fail ( STRING_CONSTANT ) ; }
{ String shortName = ClassUtils . getShortClassName ( getEnumClass () ) ; iToString = shortName + STRING_CONSTANT + getName () + STRING_CONSTANT ; }
return entry.unmodifiableList ;
return entry.unmodifiableMap ;
text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT . format ( cal ) ;
{ return format ( date , pattern , DateUtils.UTC_TIME_ZONE , locale ) ; }
{ return format ( new Date ( millis ) , pattern , DateUtils.UTC_TIME_ZONE , locale ) ; }
{ return format ( date , pattern , DateUtils.UTC_TIME_ZONE , null ) ; }
{ return format ( new Date ( millis ) , pattern , DateUtils.UTC_TIME_ZONE , null ) ; }
if ( at == - NUMBER_CONSTANT ) { return EMPTY ; }
{ return ( str == null ? EMPTY : str ) ; }
if ( repeat <= NUMBER_CONSTANT ) { return EMPTY ; }
if ( lastIdx <= NUMBER_CONSTANT ) { return EMPTY ; }
if ( strLen < NUMBER_CONSTANT ) { return EMPTY ; }
if ( idx != - NUMBER_CONSTANT ) { return str . substring ( NUMBER_CONSTANT , idx + sep . length () ) ; } else { return EMPTY ; }
if ( idx != - NUMBER_CONSTANT ) { return str . substring ( idx ) ; } else { return EMPTY ; }
if ( ch == CHAR_CONS || ch == CHAR_CONS ) { return EMPTY ; } else { return str ; }
if ( overlay == null ) { overlay = EMPTY ; }
if ( separator == null ) { separator = EMPTY ; }
if ( separator . length () == NUMBER_CONSTANT ) { return EMPTY ; }
if ( len < NUMBER_CONSTANT || pos > str . length () ) { return EMPTY ; }
if ( len < NUMBER_CONSTANT ) { return EMPTY ; }
if ( len < NUMBER_CONSTANT ) { return EMPTY ; }
if ( start > end ) { return EMPTY ; }
if ( start > str . length () ) { return EMPTY ; }
{ return ( str == null ? EMPTY : strip ( str , null ) ) ; }
{ return ( str == null ? EMPTY : str . trim () ) ; }
{ return ( str == null ? EMPTY : str . trim () ) ; }
{ try { Fraction . getFraction ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {} }
int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ;
int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ;
assertEquals ( STRING_CONSTANT , STRING_CONSTANT , StringUtils . overlayString ( SENTENCE_UNCAP , FOO_UNCAP , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
int at = indexOfDifference ( str1 , str2 ) ;
{ int index = binarySearch ( value ) ; if ( index < NUMBER_CONSTANT ) { return null ; } return names [ index ] ; }
if ( insertAt > NUMBER_CONSTANT ) { return; }
if ( value == null ) { return - NUMBER_CONSTANT ; }
if ( value == null ) { return - NUMBER_CONSTANT ; }
if ( escapeSingleQuote ) { out . write ( CHAR_CONS ) ; }
{ return ReflectionToStringBuilder . toString ( object , style , outputTransients , false , reflectUpToClass ) ; }
{ return ReflectionToStringBuilder . toString ( object , style , outputTransients , false , null ) ; }
{ return toString ( object , style , outputTransients , false , null ) ; }
{ return toString ( object , style , false , false , null ) ; }
{ return toString ( object , null , false , false , null ) ; }
List list = new ArrayList ( ColorEnum . getEnumList () ) ;
{ flush () ; return ( ( StringWriter ) this . out ) . toString () ; }
if ( isEmpty ( str ) || isEmpty ( searchChars ) ) { return str ; }
if ( isEmpty ( str ) || isEmpty ( remove ) ) { return str ; }
if ( isEmpty ( str ) || isEmpty ( remove ) ) { return str ; }
if ( isEmpty ( str ) || isEmpty ( searchChars ) ) { return - NUMBER_CONSTANT ; }
if ( isEmpty ( str ) || searchChars == null || searchChars.length == NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; }
{ if ( isAsciiNumeric ( ch ) == false ) { return defaultValue ; } return ( ch - NUMBER_CONSTANT ) ; }
if ( isAsciiNumeric ( ch ) == false ) { throw new IllegalArgumentException ( STRING_CONSTANT + ch + STRING_CONSTANT ) ; }
{ if ( ch < CHAR_ARRAY.length ) { return CHAR_ARRAY [ ch ] ; } else { return new Character ( ch ) ; } }
{ super(); setValue ( new Float ( value ) ) ; }
{ super(); setValue ( new Short ( value ) ) ; }
{ return this . value . equals ( obj ) ; }
public MutableNumber () { super(); }
{ super(); setValue ( new Long ( value ) ) ; }
{ super(); setValue ( new Double ( value ) ) ; }
{ super(); setValue ( new Integer ( value ) ) ; }
{ super(); setValue ( new Byte ( value ) ) ; }
{ return super . equals ( obj ) ; }
MutableNumber () { super(); }
{ super(); setValue ( value ) ; }
public Object getValue () { return new Integer ( this . value ) ; }
Calendar gval = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
suite . addTest ( MutableIntTest . suite () ) ;
{ return splitWorker ( str , separatorChars , - NUMBER_CONSTANT , false ) ; }
byte holder
short holder
int holder
byte holder
short holder
int holder
int holder
int holder
short holder
int holder
short holder
int holder
int mask
Object array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
Object [] array
boolean [] array
Boolean [] array
float [] array
Float [] array
double [] array
Double [] array
byte [] array
Byte [] array
short [] array
Short [] array
int [] array
Integer [] array
long [] array
Long [] array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
Object [] array
Object array
Object array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
long [] array
Object [] array
Object [] array
Object array
Object array
public EqualsBuilder () {}
{ addToken ( tokens , StringUtils.EMPTY ) ; }
{ this . value = value ; }
{ nEntries ++ ; markers . add ( marker ) ; sources . add ( source ) ; }
long splitTime = watch . getSplitTime () ;
if ( tokenLen >= NUMBER_CONSTANT ) { rule = selectNumberRule ( Calendar.YEAR , tokenLen ) ; } else { rule = TwoDigitYearField.INSTANCE ; }
{ return format ( millis , format , true , TimeZone . getDefault () ) ; }
{ if ( type . isAssignableFrom ( throwables [ i ] . getClass () ) ) { return i ; } }
{ if ( type . isAssignableFrom ( throwables [ i ] . getClass () ) ) { return i ; } }
{ if ( throwables [ i ] . getClass () . equals ( type ) ) { return i ; } }
{ if ( throwables [ i ] . getClass () . equals ( type ) ) { return i ; } }
public Class getThrowableClass () { return EOFException . class ; }
{ return new EOFException ( msg ) ; }
public Class getThrowableClass () { return EOFException . class ; }
{ return new EOFException ( msg ) ; }
public Class getThrowableClass () { return EOFException . class ; }
{ return new EOFException ( msg ) ; }
newArray [ newArray.length - NUMBER_CONSTANT ] = element ;
newArray [ newArray.length - NUMBER_CONSTANT ] = element ;
newArray [ newArray.length - NUMBER_CONSTANT ] = element ;
newArray [ newArray.length - NUMBER_CONSTANT ] = element ;
newArray [ newArray.length - NUMBER_CONSTANT ] = element ;
newArray [ newArray.length - NUMBER_CONSTANT ] = element ;
newArray [ newArray.length - NUMBER_CONSTANT ] = element ;
newArray [ newArray.length - NUMBER_CONSTANT ] = element ;
{ super ( ( argName == null ? STRING_CONSTANT : argName ) + STRING_CONSTANT ) ; }
{ return DurationFormatUtils . formatDurationHMS ( getSplitTime () ) ; }
public String toString () { return DurationFormatUtils . formatDurationHMS ( getTime () ) ; }
public DurationFormatUtils () { super(); }
assertFalse ( STRING_CONSTANT , token . equals ( new DurationFormatUtils.Token ( DurationFormatUtils.y , NUMBER_CONSTANT ) ) ) ;
{ if ( arrayEnd == null ) { arrayEnd = STRING_CONSTANT ; } this . arrayEnd = arrayEnd ; }
return ( Object [] ) add ( array , index , element , clss ) ;
{ return str == null ? defaultStr : str ; }
{ return str == null ? EMPTY : str ; }
{ return str == null ? EMPTY : str . trim () ; }
{ String ts = trim ( str ) ; return isEmpty ( ts ) ? null : ts ; }
{ return str == null ? null : str . trim () ; }
{ return str == null ? EMPTY : str . trim () ; }
{ return indexOf ( str , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ; }
{ super(); if ( initialCapacity <= NUMBER_CONSTANT ) { initialCapacity = CAPACITY ; } buf = new char [ initialCapacity ] ; }
{ return text [ pos ] <= NUMBER_CONSTANT ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
{ return ch == text [ pos ] ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
public int previousIndex () { return tokenPos - NUMBER_CONSTANT ; }
public boolean hasPrevious () { tokenize () ; return tokenPos > NUMBER_CONSTANT ; }
public boolean hasNext () { tokenize () ; return tokenPos < tokens.length ; }
{ if ( cls == null ) { return false ; } return cls . getName () . indexOf ( INNER_CLASS_SEPARATOR_CHAR ) >= NUMBER_CONSTANT ; }
{ return holder & _mask ; }
return min == range.min && max == range.max ;
{ return value >= min && value <= max ; }
{ return JAVA_VERSION_INT >= requiredVersion ; }
{ return JAVA_VERSION_FLOAT >= requiredVersion ; }
return set . equals ( other.set ) ;
return this . stopTime - this . startTime ;
{ if ( str == null || searchStr == null ) { return false ; } return str . indexOf ( searchStr ) >= NUMBER_CONSTANT ; }
{ if ( isEmpty ( str ) ) { return false ; } return str . indexOf ( searchChar ) >= NUMBER_CONSTANT ; }
return str . length () == NUMBER_CONSTANT ? null : str ;
{ return ch >= CHAR_CONS && ch <= CHAR_CONS ; }
{ return ch >= CHAR_CONS && ch <= CHAR_CONS ; }
{ return ch >= CHAR_CONS && ch <= CHAR_CONS ; }
{ return ch < NUMBER_CONSTANT || ch == NUMBER_CONSTANT ; }
{ return ch >= NUMBER_CONSTANT && ch < NUMBER_CONSTANT ; }
{ return ch < NUMBER_CONSTANT ; }
{ if ( isAsciiNumeric ( ch ) == false ) { return defaultValue ; } return ch - NUMBER_CONSTANT ; }
return ch - NUMBER_CONSTANT ;
{ return obj == null ? nullStr : obj . toString () ; }
{ return obj == null ? STRING_CONSTANT : obj . toString () ; }
{ return object != null ? object : defaultValue ; }
return date1 . getTime () == date2 . getTime () ;
public boolean nextBoolean () { return Math . random () > NUMBER_CONSTANT ; }
return min == range.min && max == range.max ;
{ return value >= min && value <= max ; }
public static boolean isThrowableNested () { return THROWABLE_CAUSE_METHOD != null ; }
{ return value >= min && value <= max ; }
return xor ( primitive ) ? Boolean.TRUE : Boolean.FALSE ;
{ return bool ? trueString : falseString ; }
{ if ( bool == null ) { return nullString ; } return bool . booleanValue () ? trueString : falseString ; }
{ if ( bool == null ) { return nullValue ; } return bool . booleanValue () ? trueValue : falseValue ; }
{ return bool ? trueValue : falseValue ; }
{ if ( bool == null ) { return nullValue ; } return bool . booleanValue () ? trueValue : falseValue ; }
{ return bool ? trueValue : falseValue ; }
{ if ( bool == null ) { return null ; } return bool . booleanValue () ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO ; }
{ return bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO ; }
{ return bool ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
{ if ( value == null ) { return null ; } return value . intValue () == NUMBER_CONSTANT ? Boolean.FALSE : Boolean.TRUE ; }
{ return value == NUMBER_CONSTANT ? Boolean.FALSE : Boolean.TRUE ; }
{ return value == NUMBER_CONSTANT ? false : true ; }
{ if ( bool == null ) { return valueIfNull ; } return bool . booleanValue () ? true : false ; }
{ if ( bool == null ) { return false ; } return bool . booleanValue () ? true : false ; }
{ return bool ? Boolean.TRUE : Boolean.FALSE ; }
{ if ( bool == null ) { return false ; } return bool . booleanValue () ? false : true ; }
{ if ( bool == null ) { return false ; } return bool . booleanValue () ? true : false ; }
return compareMin <= NUMBER_CONSTANT && compareMax >= NUMBER_CONSTANT ;
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , objectToFind ) != - NUMBER_CONSTANT ; }
{ return value >= min && value <= max ; }
{ return value == null ? STRING_CONSTANT : value . toString () ; }
public int hashCode () { return value == null ? NUMBER_CONSTANT : value . hashCode () ; }
return compareMin <= NUMBER_CONSTANT && compareMax >= NUMBER_CONSTANT ;
return compareMin <= NUMBER_CONSTANT && compareMax >= NUMBER_CONSTANT ;
