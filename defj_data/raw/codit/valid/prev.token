public String print ( long millisUTC ) { throw unsupported () ; }
public String print ( ReadableInstant instant ) { throw unsupported () ; }
public String print ( ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
char c
char style
char style
int value
catch ( ParseException pe ) { pe . printStackTrace () ; }
try { retDT = new DateTime ( s , DateTimeZone.UTC ) ; } catch ( ParseException pe ) { pe . printStackTrace () ; }
Object f
Object f
Object f
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
DateTimeField field
DateTimeField field
char c
Object element
DateTimeParser parser
DateTimeParser parser
DateTimePrinter printer
DateTimeFormatter formatter
Chronology chrono
DateTimeZone zone
GJWeekyearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
try { retDT = new DateTime ( s ) ; } catch ( ParseException pe ) {}
ReadableInstant instant
public abstract boolean equals ( Object obj ) ;
long millis
public long add ( long millis , int value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
{ return add ( millis , value - get ( millis ) ) ; }
public long add ( long millis , int value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
int digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
int digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
GJMonthOfYearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
public int getMinimumValue ( long millis ) { return NUMBER_CONSTANT ; }
public int get ( long millis ) { return BuddhistChronology.BE ; }
ParseException e
Chronology chrono = ISOChronology . getInstanceUTC () ;
{ return add ( millis , value - get ( millis ) ) ; }
public long add ( long millis , int value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
if ( zone == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
ParseException pe
return ( getMillis () < readableInstant . getMillis () ) ;
{ Chronology chrono = getChronology () ; return chrono != null ? chrono . getDateTimeZone () : null ; }
public AbstractInstant () { super(); }
if ( zone == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
int value
int value
public String getNameKey ( long millis ) { return iNameKey ; }
{ if ( ! field . isSupported () ) { throw new UnsupportedOperationException ( STRING_CONSTANT + name + STRING_CONSTANT ) ; } }
text . length () <= sampleLen
public DurationPrinter toPrinter () { return toPrinter ( iFormatters ) ; }
if ( value == NUMBER_CONSTANT && iPrintZeroSetting == PRINT_ZERO_NEVER ) { return - NUMBER_CONSTANT ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
public String toString ( ) ;
public int getMaximumValue ( ) ;
public int getMinimumValue ( ) ;
public DurationField getLeapDurationField ( ) ;
public boolean isSupported ( ) ;
public String getName ( ) ;
public String toString ( ) ;
public boolean isSupported ( ) ;
public String getName ( ) ;
{ if ( chrono == iChronology ) { return this ; } return new ISOYearMonthType ( iChronology ) ; }
builder . appendNumeric ( field , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return appendSignedNumeric ( iChronoUTC . centuryOfEra () , minDigits , maxDigits ) ; }
{ return appendNumeric ( iChronoUTC . yearOfCentury () , minDigits , maxDigits ) ; }
{ return appendNumeric ( iChronoUTC . yearOfEra () , minDigits , maxDigits ) ; }
{ return appendSignedNumeric ( iChronoUTC . year () , minDigits , maxDigits ) ; }
{ return appendNumeric ( iChronoUTC . monthOfYear () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . weekyear () , minDigits , maxDigits ) ; }
{ return appendNumeric ( iChronoUTC . weekOfWeekyear () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . dayOfYear () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . dayOfMonth () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . dayOfWeek () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . clockhourOfHalfday () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . hourOfHalfday () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . clockhourOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . hourOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . minuteOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . minuteOfHour () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . secondOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . secondOfMinute () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . millisOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . millisOfSecond () , minDigits , NUMBER_CONSTANT ) ; }
ymd = new DateTimeFormatterBuilder ( iChrono ) . append ( yearElement () ) . append ( monthElement () ) . append ( dayElement () ) . toFormatter ()
long scaled = fraction * iScaler / iRangeMillis ;
{ iSavedFields . add ( new SavedField ( field , text , locale ) ) ; }
{ iSavedFields . add ( new SavedField ( field , value ) ) ; }
Arrays . sort ( savedFields , NUMBER_CONSTANT , count ) ;
( value < NUMBER_CONSTANT ? NUMBER_CONSTANT : ( ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ) )
int digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
int digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . toCopy ( iField . roundHalfEven ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . toCopy ( iField . roundHalfCeiling ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . toCopy ( iField . roundHalfFloor ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . toCopy ( iField . roundCeiling ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . toCopy ( iField . roundFloor ( instant . getMillis () ) ) ; }
return ( DateTime ) instant . toCopy ( iField . set ( instant . getMillis () , value ) ) ;
return ( DateTime ) instant . toCopy ( iField . addWrapped ( instant . getMillis () , value ) ) ;
return ( DateTime ) instant . toCopy ( iField . add ( instant . getMillis () , value ) ) ;
return ( DateTime ) instant . toCopy ( iField . add ( instant . getMillis () , value ) ) ;
{ return instant . toCopy ( addTo ( instant . getMillis () , scalar ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . toCopy ( iField . roundHalfEven ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . toCopy ( iField . roundHalfCeiling ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . toCopy ( iField . roundHalfFloor ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . toCopy ( iField . roundCeiling ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . toCopy ( iField . roundFloor ( instant . getMillis () ) ) ; }
return ( TimeOnly ) instant . toCopy ( iField . set ( instant . getMillis () , value ) ) ;
return ( TimeOnly ) instant . toCopy ( iField . addWrapped ( instant . getMillis () , value ) ) ;
return ( TimeOnly ) instant . toCopy ( iField . add ( instant . getMillis () , value ) ) ;
return ( TimeOnly ) instant . toCopy ( iField . add ( instant . getMillis () , value ) ) ;
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . toCopy ( iField . roundHalfEven ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . toCopy ( iField . roundHalfCeiling ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . toCopy ( iField . roundHalfFloor ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . toCopy ( iField . roundCeiling ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . toCopy ( iField . roundFloor ( instant . getMillis () ) ) ; }
return ( DateOnly ) instant . toCopy ( iField . set ( instant . getMillis () , value ) ) ;
return ( DateOnly ) instant . toCopy ( iField . addWrapped ( instant . getMillis () , value ) ) ;
return ( DateOnly ) instant . toCopy ( iField . add ( instant . getMillis () , value ) ) ;
return ( DateOnly ) instant . toCopy ( iField . add ( instant . getMillis () , value ) ) ;
ImpreciseCutoverField ( DateTimeField julianField , DateTimeField gregorianField ) { this ( julianField , gregorianField , null ) ; }
{ this ( julianField , gregorianField , iCutoverInstant ) ; }
{ return appendDecimal ( iChronoUTC . weekyear () , minDigits , maxDigits ) ; }
instant = iChronology . getTimeOnlyMillis ( instant ) ;
DateTimeOfYear dtOfYear = START_OF_YEAR ;
{ return localToUTC ( iChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , millisOfDay ) ) ; }
{ return localToUTC ( iChronology . getTimeOnlyMillis ( hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ) ; }
int newYear = year + Utils . safeToInt ( value ) ;
int wrapped = Utils . getWrappedValue ( year , value , getMinimumValue () , getMaximumValue () ) ;
int newWeekyear = weekyear + Utils . safeToInt ( value ) ;
int wrapped = Utils . getWrappedValue ( weekyear , value , getMinimumValue () , getMaximumValue () ) ;
fields.centuryOfEra = new DividedDateTimeField ( fields.yearOfEra , STRING_CONSTANT , STRING_CONSTANT , NUMBER_CONSTANT ) ;
{ return DurationType . getAverageYearMonthType () ; }
{ return DurationType . getMillisType () ; }
{ return new PreciseYearMonthType ( ISOChronology . getInstanceUTC () ) ; }
{ return new AverageYearMonthType ( ISOChronology . getInstanceUTC () ) ; }
{ super(); iChronology = selectChronology ( chronology ) ; iMillis = System . currentTimeMillis () ; }
{ super(); iChronology = ISOChronology . getInstance ( zone ) ; iMillis = System . currentTimeMillis () ; }
{ super(); iChronology = ISOChronology . getInstance () ; iMillis = System . currentTimeMillis () ; }
{ iChronology = selectChronologyUTC ( chronology ) ; iMillis = resetUnsupportedFields ( toLocalTime ( System . currentTimeMillis () , chronology , iChronology ) ) ; }
return chrono . withDateTimeZone ( DateTimeZone . getDefault () ) ;
if ( chrono == null ) { zone = DateTimeZone . getDefault () ; } else { zone = chrono . getDateTimeZone () ; }
if ( zone == null ) { zone = getDateTimeZone () ; }
if ( zone == null ) { zone = getDateTimeZone () ; }
if ( zone == null ) { zone = getDateTimeZone () ; }
DateTimeZone zone = chrono . getDateTimeZone () ;
private Object readResolve () { return getInstance ( getBase () . getDateTimeZone () ) ; }
if ( ! UTC . equals ( provider . getDateTimeZone ( STRING_CONSTANT ) ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
DateTimeZone zone = cProvider . getDateTimeZone ( id ) ;
DateTimeZone zone = instant . getDateTimeZone () ;
DateTimeZone zone = chrono . getDateTimeZone () ;
if ( zone == null ) { zone = getDateTimeZone () ; }
{ return print ( millisUTC , chrono . getDateTimeZone () ) ; }
if ( zone == null ) { zone = getDateTimeZone () ; }
if ( zone == null ) { zone = getDateTimeZone () ; }
{ printTo ( out , millisUTC , chrono . getDateTimeZone () ) ; }
{ printTo ( buf , millisUTC , chrono . getDateTimeZone () ) ; }
private Object writeReplace () { return new Stub ( getDateTimeZone () ) ; }
getBase () . getDateTimeZone () == DateTimeZone.UTC
DateTimeZone zone = getDateTimeZone () ;
if ( chrono != null && chrono . getDateTimeZone () == zone ) { return chrono ; }
getDateTimeZone () == DateTimeZone.UTC
DateTimeZone getDateTimeZone ( ) ;
public Chronology withUTC () { return withDateTimeZone ( DateTimeZone.UTC ) ; }
sb . append ( getDateTimeZone () . getID () ) ;
public Chronology withUTC () { return withDateTimeZone ( DateTimeZone.UTC ) ; }
DateTimeZone baseZone = base . getDateTimeZone () ;
{ if ( base == null || isMatchingType ( base ) ) { return getMillis () ; } return getMillis ( base , base . getDateTimeZone () ) ; }
DateTimeZone zone = chronology . getDateTimeZone () ;
DateTimeZone zone = original . getDateTimeZone () ;
assertEquals ( msg + STRING_CONSTANT , z , dt . getDateTimeZone () ) ;
private Object readResolve () { return getInstance ( getBase () . getDateTimeZone () ) ; }
private Object readResolve () { return getInstance ( getBase () . getDateTimeZone () ) ; }
assertSame ( zone , BuddhistChronology . getInstance ( zone ) . getDateTimeZone () ) ;
assertSame ( zone , BuddhistChronology . getInstance () . getDateTimeZone () ) ;
DateTimeZone getDateTimeZone ( ) ;
DateTimeZone zone = getDateTimeZone () ;
DateTimeZone zone = getDateTimeZone () ;
DateTimeZone zone = getDateTimeZone () ;
return new MutableDateTime ( getMillis ( base , chronology . getDateTimeZone () ) , chronology ) ;
return new MutableDateTime ( getMillis ( base , zone ) , getChronology () . withDateTimeZone ( zone ) ) ;
DateTimeZone zone = getDateTimeZone () ;
return new DateTime ( getMillis ( base , chronology . getDateTimeZone () ) , chronology ) ;
return new DateTime ( getMillis ( base , zone ) , getChronology () . withDateTimeZone ( zone ) ) ;
if ( this instanceof DateTime && getDateTimeZone () == zone ) { return ( DateTime ) this ; }
public DateTimeZone getDateTimeZone () { return null ; }
DateTimeZone zone = getDateTimeZone () ;
private Object readResolve () { return getInstance ( getBase () . getDateTimeZone () ) ; }
getDateTimeZone ()
ZonedDurationField zonedField = new ZonedDurationField ( field , getDateTimeZone () ) ;
DateTimeZone zone = getDateTimeZone () ;
{ return localToUTC ( getBase () . getDateTimeMillis ( instant + getDateTimeZone () . getOffset ( instant ) , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ) ; }
getDateTimeZone () == DateTimeZone.UTC
public RealMatrix copy () { return null ; }
suite . addTest ( UnivariateTest . suite () ) ;
this . initialCapacity = initialCapacity ;
this . initialCapacity = initialCapacity ;
protected void setUp ( ) throws Exception { eDA = new ExpandableDoubleArray () ; }
assertTrue ( STRING_CONSTANT , eDA . getInternalLength () < ( ( int ) NUMBER_CONSTANT * NUMBER_CONSTANT ) ) ;
protected void setUp ( ) throws Exception { eDA = new ContractableDoubleArray () ; }
public void clear () { eDA . clear () ; }
System . arraycopy ( eDA . getValues () , NUMBER_CONSTANT , copiedArray , NUMBER_CONSTANT , eDA . getNumElements () ) ;
protected void tearDown ( ) throws Exception { da = null ; }
i < numElements
i < numElements
public abstract void clear ( ) ;
public abstract double [] getElements ( ) ;
if ( index < NUMBER_CONSTANT ) { String msg = STRING_CONSTANT ; throw new IllegalArgumentException ( msg ) ; }
public double getN () { return eDA . getNumElements () ; }
public abstract double getN ( ) ;
double n = u . getN () ;
public abstract int getWindowSize ( ) ;
windowSize != Univariate.INIFINTE_WINDOW
windowSize != Univariate.INIFINTE_WINDOW
windowSize != Univariate.INIFINTE_WINDOW
windowSize != Univariate.INIFINTE_WINDOW && windowSize < list . size ()
windowSize != Univariate.INIFINTE_WINDOW && windowSize < list . size ()
public CertifiedDataTest ( String name ) { super ( name ) ; setUp () ; }
return lower + ( int ) ( Math . random () * ( upper - lower + NUMBER_CONSTANT ) ) ;
{ double actual = t . inverseCummulativeProbability ( p ) ; assertEquals ( STRING_CONSTANT + p , expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = t . cummulativeProbability ( x ) ; assertEquals ( STRING_CONSTANT + x , expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = exp . inverseCummulativeProbability ( p ) ; assertEquals ( STRING_CONSTANT + p , expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = exp . cummulativeProbability ( x ) ; assertEquals ( STRING_CONSTANT + x , expected , actual , NUMBER_CONSTANT ) ; }
public int getColumnDimension ( ) ;
public int getRowDimension ( ) ;
public boolean isSingular ( ) ;
public boolean isSquare ( ) ;
public double getDeterminant ( ) ;
public RealMatrix transpose ( ) ;
{ if ( windowSize != Univariate.INFINITE_WINDOW ) { return super . getVariance () ; } return variance ; }
variance = accum / ( values.length - NUMBER_CONSTANT ) ;
{ return sum ( values ) / values.length ; }
{ return Math . pow ( product ( values ) , ( NUMBER_CONSTANT / values.length ) ) ; }
{ double actual = Gamma . logGamma ( x , NUMBER_CONSTANT , Integer.MAX_VALUE ) ; TestUtils . assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ if ( n < NUMBER_CONSTANT ) { return Double.NaN ; } return sumSqY - sumY * sumY / ( double ) n ; }
{ return Math . exp ( sumLog ( values ) / ( double ) values.length ) ; }
{ return sum ( values ) / ( double ) values.length ; }
{ return geometricMean ( values , NUMBER_CONSTANT , values.length ) ; }
{ return sumLog ( values , NUMBER_CONSTANT , values.length ) ; }
{ return product ( values , NUMBER_CONSTANT , values.length ) ; }
{ return sumSq ( values , NUMBER_CONSTANT , values.length ) ; }
{ return sum ( values , NUMBER_CONSTANT , values.length ) ; }
public abstract double getKurtosis ( ) ;
abstract int getWindowSize ( ) ;
abstract void clear ( ) ;
abstract double getSumsq ( ) ;
abstract double getSum ( ) ;
abstract int getN ( ) ;
abstract double getMin ( ) ;
abstract double getMax ( ) ;
abstract double getStandardDeviation ( ) ;
abstract double getVariance ( ) ;
abstract double getMean ( ) ;
{ return mean . evaluate ( values ) ; }
{ return geoMean . evaluate ( values ) ; }
{ return sumLog . evaluate ( values ) ; }
{ return product . evaluate ( values ) ; }
{ return sumSq . evaluate ( values ) ; }
{ return sum . evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
variance = ( n <= NUMBER_CONSTANT ) ? NUMBER_CONSTANT : m2 / ( double ) ( n - NUMBER_CONSTANT ) ;
double [] d
{ return Math . exp ( sumLog . evaluate ( values , begin , length ) / ( double ) length ) ; }
public void clear () { super . clear () ; std = Double.NaN ; }
public void clear () { value = Double.NaN ; }
public void clear () { super . clear () ; }
public UnivariateImpl () {}
public void clear ( ) ;
if ( test ( values , begin , length ) ) { return super . evaluate ( values , begin , length ) / ( ( double ) length ) ; }
private UnivariateRealSolverFactory () {}
for ( int i = begin ; i < begin + length ; i ++ ) { increment ( values [ i ] ) ; }
double root = UnivariateRealSolverFactory . solve ( rootFindingFunction , bracket [ NUMBER_CONSTANT ] , bracket [ NUMBER_CONSTANT ] ) ;
double d
double d
int n
int n
int n
double d
double d
double d
double d
public void setPropertyName ( String string ) { propertyName = string ; }
Object o
double d
double d
public void setPercentile ( double p ) { percentile = p ; }
double [] values
double d
public void increment ( double d ) { super . increment ( d ) ; }
double d
double d
double [] values
double [] values
double [] values
double [] values
double [] values
double [] values
double d
public MathException ( Throwable throwable ) { super ( throwable ) ; }
public MathException ( String message ) { super ( message ) ; }
public MathConfigurationException ( Throwable throwable ) { super ( throwable ) ; }
public MathConfigurationException ( String message ) { super ( message ) ; }
double d
double d
if ( expansionFactor < NUMBER_CONSTANT ) { String msg = STRING_CONSTANT + STRING_CONSTANT ; throw new IllegalArgumentException ( msg ) ; }
{ String msg = STRING_CONSTANT + STRING_CONSTANT ; throw new ArrayIndexOutOfBoundsException ( msg ) ; }
protected void setUp ( ) throws Exception { super . setUp () ; b = DistributionFactory . newInstance () . createBinomailDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ try { factory . createBinomailDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {} }
{ try { factory . createBinomailDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { fail ( STRING_CONSTANT ) ; } }
{ try { factory . createBinomailDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { fail ( STRING_CONSTANT ) ; } }
{ try { factory . createBinomailDistribution ( NUMBER_CONSTANT , - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {} }
{ try { factory . createBinomailDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { fail ( STRING_CONSTANT ) ; } }
{ try { factory . createBinomailDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { fail ( STRING_CONSTANT ) ; } }
{ try { factory . createBinomailDistribution ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {} }
DistributionFactoryImpl () { super(); }
UnivariateRealSolverFactoryImpl () {}
public ConvergenceException ( String message ) { super ( message ) ; }
public BeanListUnivariateImpl ( List list ) { super ( list ) ; }
{ this . propertyName = property ; }
{ super(); this . name = name ; }
public MathConfigurationException ( final Throwable throwable ) { super ( throwable ) ; }
public MathConfigurationException ( final String message ) { super ( message ) ; }
{ return min ( values , NUMBER_CONSTANT , values.length ) ; }
{ return max ( values , NUMBER_CONSTANT , values.length ) ; }
{ return variance ( values , NUMBER_CONSTANT , values.length ) ; }
{ return sum ( values ) / ( double ) values.length ; }
{ return sumLog ( values , NUMBER_CONSTANT , values.length ) ; }
{ return product ( values , NUMBER_CONSTANT , values.length ) ; }
{ return sumSq ( values , NUMBER_CONSTANT , values.length ) ; }
{ return sum ( values , NUMBER_CONSTANT , values.length ) ; }
StoreUnivariate u = new BeanListUnivariateImpl ( patientList ) ;
StoreUnivariate u = new StoreUnivariateImpl () ;
StoreUnivariate u = new ListUnivariateImpl ( list ) ;
StoreUnivariate u = new ListUnivariateImpl ( externalList ) ;
StoreUnivariate u = new ListUnivariateImpl ( externalList , transformers ) ;
StoreUnivariateImpl u = new StoreUnivariateImpl () ;
StoreUnivariateImpl u = new StoreUnivariateImpl () ;
StoreUnivariateImpl u = new StoreUnivariateImpl () ;
StoreUnivariate u = new StoreUnivariateImpl () ;
StoreUnivariate u = new StoreUnivariateImpl () ;
StoreUnivariate u = new StoreUnivariateImpl () ;
Univariate u = new UnivariateImpl () ;
Univariate stats = new UnivariateImpl () ;
return new Complex ( MathUtils . sinh ( a2 ) / d , Math . sin ( b2 ) / NUMBER_CONSTANT ) ;
return new Complex ( Math . sin ( a2 ) / d , MathUtils . sinh ( b2 ) / NUMBER_CONSTANT ) ;
public void clear () { value = Double.NaN ; }
public void clear () { value = Double.NaN ; }
public void clear () { value = Double.NaN ; }
public void clear () { value = Double.NaN ; }
public void clear () { value = Double.NaN ; }
{ URL url = getClass () . getResource ( STRING_CONSTANT ) ; vs . setValuesFileURL ( url . toExternalForm () ) ; }
empiricalDistribution . load ( file ) ;
vs . openReplayFile () ;
StorelessDescriptiveStatisticsImpl u = new StorelessDescriptiveStatisticsImpl () ;
StorelessDescriptiveStatisticsImpl u = new StorelessDescriptiveStatisticsImpl () ;
public void clear () { super . clear () ; list . clear () ; }
DescriptiveStatistics sampleStats
public AbstractDescriptiveStatistics ( int window ) { super ( window ) ; }
public AbstractDescriptiveStatistics () { super(); }
sampleStats = new StorelessDescriptiveStatisticsImpl () ;
public abstract int getN ( ) ;
DescriptiveStatistics u = new StorelessDescriptiveStatisticsImpl () ;
DescriptiveStatistics stats = new StorelessDescriptiveStatisticsImpl () ;
new Complex ( Math . abs ( z . getImaginary () ) / ( NUMBER_CONSTANT * t ) , MathUtils . sign ( b ) * t )
public double getMean () { return new Mean ( firstMoment ) . getResult () ; }
empiricalDistribution . load ( file ) ;
public void testNext ( ) throws Exception { tstGen ( NUMBER_CONSTANT ) ; }
fail () ;
{ return ( ( Number ) org.apache.commons.beanutils.PropertyUtils . getProperty ( o , getPropertyName () ) ) . doubleValue () ; }
return NUMBER_CONSTANT - tDistribution . cummulativeProbability ( - t , t ) ;
return NUMBER_CONSTANT - tDistribution . cummulativeProbability ( - t , t ) ;
return NUMBER_CONSTANT - chiSquaredDistribution . cummulativeProbability ( chiSquare ( expected , observed ) ) ;
{ double actual = h . cummulativeProbability ( x ) ; assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability1 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability0 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability999 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ double actual = chiSquare . inverseCummulativeProbability ( p ) ; assertEquals ( STRING_CONSTANT + p , expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = chiSquare . cummulativeProbability ( x ) ; assertEquals ( STRING_CONSTANT + x , expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = b . cummulativeProbability ( x ) ; assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability8 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability1 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability999 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability001 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ double actual = t . inverseCummulativeProbability ( p ) ; assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = t . cummulativeProbability ( x ) ; assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability999 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability999 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ double actual = f . inverseCummulativeProbability ( p ) ; assertEquals ( STRING_CONSTANT + p , expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = f . cummulativeProbability ( x ) ; assertEquals ( STRING_CONSTANT + x , expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = z . inverseCummulativeProbability ( p ) ; assertEquals ( expected , actual , PRECISION ) ; }
assertEquals ( NUMBER_CONSTANT , z . cummulativeProbability ( z . getMean () + z . getStandardDeviation () ) , PRECISION ) ;
assertEquals ( NUMBER_CONSTANT , z . cummulativeProbability ( mu ) , PRECISION ) ;
{ double actual = exp . inverseCummulativeProbability ( p ) ; TestUtils . assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ double actual = exp . cummulativeProbability ( x ) ; TestUtils . assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbabilityPositive () { testValue ( Double.NaN , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbabilityOne () { testValue ( Double.POSITIVE_INFINITY , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbabilityZero () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCummulativeProbabilityZero () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability900 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability950 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability975 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability990 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability999 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability100 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability050 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability025 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability010 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testCummulativeProbability001 () { testProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability900 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability950 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability975 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability990 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability999 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability100 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability050 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability025 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability010 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testInverseCummulativeProbability001 () { testValue ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
return getSlopeStdErr () * getTDistribution () . inverseCummulativeProbability ( NUMBER_CONSTANT - alpha / NUMBER_CONSTANT ) ;
double actual = DistributionFactory . newInstance () . createGammaDistribution ( a , b ) . inverseCummulativeProbability ( p ) ;
double actual = DistributionFactory . newInstance () . createGammaDistribution ( a , b ) . cummulativeProbability ( x ) ;
UnivariateRealFunction f = new PolynomialFunction ( c ) ;
catch ( MathException e ) { e . printStackTrace () ; }
catch ( MathException e ) { e . printStackTrace () ; }
{ bp [ row ] [ col ] = bv [ pivot [ row ] ] [ col ] ; }
{ try { LUDecompose () ; return false ; } catch ( InvalidMatrixException ex ) { return true ; } }
{ ( new RealMatrixImpl ( testData2 ) ) . LUDecompose () ; fail ( STRING_CONSTANT ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
if ( test ( values , begin , length ) ) { return sum . evaluate ( values ) / ( ( double ) length ) ; }
catch ( Exception ex ) {}
public AbstractDescriptiveStatistics () {}
ExpandableDoubleArray eDA3 = new ExpandableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
ExpandableDoubleArray eDA2 = new ExpandableDoubleArray ( NUMBER_CONSTANT ) ;
try { result = freqTable . getCount ( new Character ( v ) ) ; } catch ( Exception ex ) {}
try { result = freqTable . getCount ( new Long ( v ) ) ; } catch ( Exception ex ) {}
try { result = freqTable . getCount ( new Long ( v ) ) ; } catch ( Exception ex ) {}
try { result = freqTable . getCount ( v ) ; } catch ( Exception ex ) {}
TDistribution tDistribution = DistributionFactory . newInstance () . createTDistribution ( degreesOfFreedom ) ;
TDistribution tDistribution = DistributionFactory . newInstance () . createTDistribution ( n - NUMBER_CONSTANT ) ;
ChiSquaredDistribution chiSquaredDistribution = DistributionFactory . newInstance () . createChiSquareDistribution ( df ) ;
ChiSquaredDistribution chiSquaredDistribution = DistributionFactory . newInstance () . createChiSquareDistribution ( ( double ) expected.length - NUMBER_CONSTANT ) ;
{ super(); eDA = new ContractableDoubleArray () ; setWindowSize ( window ) ; }
Iterator iter = freqTable . uniqueSet () . iterator () ;
{ freqTable = new TreeBag ( comparator ) ; }
double det = ( double ) parity ;
public void clear () { super . clear () ; lastVar = NUMBER_CONSTANT ; }
if ( moment.n == NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return moment.m2 / ( moment.n0 - NUMBER_CONSTANT ) ; }
{ sumSq += Math . pow ( values [ i ] , NUMBER_CONSTANT ) ; }
{ super . increment ( d ) ; }
{ super ( m2 ) ; }
catch ( Exception ex ) {}
catch ( Exception ex ) {}
catch ( Exception ex ) { ex . printStackTrace () ; }
double getN ( ) ;
public void resetFunctionValueAccuracy ( ) ;
public double getFunctionValueAccuracy ( ) ;
public void resetRelativeAccuracy ( ) ;
public double getRelativeAccuracy ( ) ;
public void resetAbsoluteAccuracy ( ) ;
public double getAbsoluteAccuracy ( ) ;
public int getMaximalIterationCount ( ) ;
{ return Math . exp ( super . evaluate ( values , begin , length ) / ( double ) length ) ; }
{ n ++ ; super . increment ( d ) ; }
{ os += m . getEntry ( i + NUMBER_CONSTANT , j + NUMBER_CONSTANT ) + STRING_CONSTANT ; }
{ os += m . getEntry ( i + NUMBER_CONSTANT , j + NUMBER_CONSTANT ) + STRING_CONSTANT ; }
{ return DEFAULT . format ( c ) ; }
public InvalidMatrixException ( String message ) { this ( message , null ) ; }
PoissonDistribution dist = new PoissonDistributionImpl ( DEFAULT_TEST_POISSON_PARAMETER ) ;
PoissonDistribution dist = new PoissonDistributionImpl ( NUMBER_CONSTANT ) ;
double t = Math . abs ( t ( m1 , m2 , v1 , v2 , n1 , n2 ) ) ;
{ if ( rand == null ) { rand = new Random () ; } rand . setSeed ( System . currentTimeMillis () ) ; }
{ if ( rand == null ) { rand = new Random () ; } rand . setSeed ( seed ) ; }
Random rand = getRan () ;
Random rand = getRan () ;
Random rand = getRan () ;
Random rand = getRan () ;
Random rand = getRan () ;
Random ran = getRan () ;
public RandomDataTest ( String name ) { super ( name ) ; }
{ return solve ( getIdentity ( this . getRowDimension () ) ) ; }
{ return solve ( getIdentity ( this . getRowDimension () ) ) ; }
private MathUtils () {}
x < a || a <= NUMBER_CONSTANT
a > NUMBER_CONSTANT && x > a
float sign = sign ( x ) ;
double sign = sign ( x ) ;
if ( numberOfSuccesses > populationSize ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
public AbstractRandomGeneratorTest ( String name ) { super ( name ) ; randomData = new RandomDataImpl ( new TestRandomGenerator () ) ; }
if ( fm * fmin > NUMBER_CONSTANT ) { min = m ; fmin = fm ; } else { max = m ; }
z = new Complex ( Double.NaN , NUMBER_CONSTANT ) ;
double result = Math . sqrt ( getRSquare ( b1 ) ) ;
{ return getSumSquaredErrors ( getSlope () ) ; }
Number number = getRealFormat () . parse ( source , pos ) ;
{ getRealFormat () . format ( value , toAppendTo , pos ) ; }
FastSineTransformer () { super(); }
FastCosineTransformer () { super(); }
FastFourierTransformer () { super(); }
v . multiplySelf ( NUMBER_CONSTANT ) ;
v1 . addToSelf ( v2 ) ;
v1 . subtractFromSelf ( v2 ) ;
{ return new Rotation ( - q0 , q1 , q2 , q3 ) ; }
public int eventOccurred ( double t , double [] y ) { sign = - sign ; return SwitchingFunction.RESET ; }
return ( largest . getCost () - smallest . getCost () ) < threshold ;
RationalNumber newCoeff = RationalNumber . multiply ( a [ i ] , lcm ) ;
double [] estimatedMean = sample . getMean ( null ) ;
{ d . setElement ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; result = d . solve ( b , NUMBER_CONSTANT ) ; }
try { while ( true ) { sum = sampler . nextSamplePoint () . getY () ; } } catch ( ExhaustedSampleException e ) {}
double [] estimatedMean = sample . getMean ( null ) ;
{ return coefficients ; }
{ return coefficients ; }
new GaussNewtonEstimator ( maxIterations , convergence , steadyStateThreshold , epsilon ) . estimate ( this ) ;
double [] data = mapper . getInternalDataArray () ;
assertTrue ( mapper . getInternalDataArray () . length == size ) ;
WeightedMeasurement m = new MyMeasurement ( NUMBER_CONSTANT , theoretical () + NUMBER_CONSTANT ) ;
WeightedMeasurement m = new MyMeasurement ( NUMBER_CONSTANT , theoretical () + NUMBER_CONSTANT ) ;
WeightedMeasurement m = new MyMeasurement ( NUMBER_CONSTANT , theoretical () + NUMBER_CONSTANT ) ;
return ( TestProblem [] ) problems . toArray ( new TestProblem [ NUMBER_CONSTANT ] ) ;
public ScalarSampleStatisticsTest ( String name ) { super ( name ) ; }
double [] mean = sample . getMean ( null ) ;
public VectorialSampleStatisticsTest ( String name ) { super ( name ) ; }
{ return interpolatedState ; }
double [] data = mapper . getInternalDataArray () ;
public void tearOff () { fitter = null ; }
public AbstractCurveFitterTest ( String name ) { super ( name ) ; }
fail ( STRING_CONSTANT ) ;
{ l . setElement ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; result = l . solve ( b , NUMBER_CONSTANT ) ; }
p . multiplySelf ( lcm ) ;
{ u . setElement ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; result = u . solve ( b , NUMBER_CONSTANT ) ; }
double originalCost = original [ NUMBER_CONSTANT ] . getCost () ;
public SwitchingFunction [] getSwitchingFunctions () { return null ; }
simplex [ i ] . getCost () > pointCostPair . getCost ()
{ return minima ; }
{ simplex [ i ] = new PointCostPair ( vertices [ i ] ) ; }
simplex [ i ] = new PointCostPair ( vertex ) ;
RandomVectorGenerator rvg = new CorrelatedRandomVectorGenerator ( statistics . getMean ( null ) , statistics . getCovarianceMatrix ( null ) , new UniformRandomGenerator ( seed ) ) ;
ElementPattern pattern
public double [] getArray () { return internalArray ; }
return ( largest . getCost () - smallest . getCost () ) < threshold ;
assertTrue ( optimum . getCost () > NUMBER_CONSTANT ) ;
assertTrue ( optimum . getCost () > NUMBER_CONSTANT ) ;
try { while ( true ) { sum = sampler . nextSamplePoint () . getY () ; } } catch ( ExhaustedSampleException e ) {}
String name = new Integer ( k ) . toString () ;
{ throw new ConvergenceException ( STRING_CONSTANT ) ; }
throw new ConvergenceException ( STRING_CONSTANT ) ;
super ( new MessageFormat ( pattern , Locale.US ) . format ( arguments ) ) ;
super ( new MessageFormat ( pattern , Locale.US ) . format ( arguments ) ) ;
{ return ( new BigDecimal ( new Double ( x ) . toString () ) . setScale ( scale , roundingMethod ) ) . doubleValue () ; }
return getSlopeStdErr () * getTDistribution () . inverseCumulativeProbability ( NUMBER_CONSTANT - alpha / NUMBER_CONSTANT ) ;
{ super(); setMean ( p ) ; }
HypergeometricDistribution dist = DistributionFactory . newInstance () . createHypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
setDistribution ( DistributionFactory . newInstance () . createHypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( DistributionFactory . newInstance () . createHypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( DistributionFactory . newInstance () . createHypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( DistributionFactory . newInstance () . createChiSquareDistribution ( NUMBER_CONSTANT ) ) ;
setDistribution ( DistributionFactory . newInstance () . createBinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( DistributionFactory . newInstance () . createBinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( DistributionFactory . newInstance () . createTDistribution ( NUMBER_CONSTANT ) ) ;
PoissonDistribution dist = DistributionFactory . newInstance () . createPoissonDistribution ( NUMBER_CONSTANT ) ;
PoissonDistribution dist = DistributionFactory . newInstance () . createPoissonDistribution ( NUMBER_CONSTANT ) ;
PoissonDistribution dist = DistributionFactory . newInstance () . createPoissonDistribution ( DEFAULT_TEST_POISSON_PARAMETER ) ;
PoissonDistribution dist = DistributionFactory . newInstance () . createPoissonDistribution ( DEFAULT_TEST_POISSON_PARAMETER ) ;
PoissonDistribution dist = DistributionFactory . newInstance () . createPoissonDistribution ( NUMBER_CONSTANT ) ;
setDistribution ( DistributionFactory . newInstance () . createPascalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( DistributionFactory . newInstance () . createPascalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
public void setUp () { testStatistic = TestUtils . getTTest () ; }
public void setUp () { testStatistic = TestUtils . getChiSquareTest () ; }
{ double x = MathUtils . factorial ( test ) ; }
try { x = m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
transformer . scaleArray ( x2 , NUMBER_CONSTANT / Math . sqrt ( x2.length ) ) ;
try { percentile = new Percentile ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ return ( internalArray.length / numElements ) > contractionCriteria ; }
if ( normProduct < NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics stats = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
RungeKuttaStepInterpolator rki = ( RungeKuttaStepInterpolator ) prototype . clone () ;
RungeKuttaStepInterpolator rki = ( RungeKuttaStepInterpolator ) prototype . clone () ;
this . safety = NUMBER_CONSTANT ;
this . safety = NUMBER_CONSTANT ;
{ super ( false , c , a , b , new GillStepInterpolator () , step ) ; }
{ super ( false , c , a , b , new EulerStepInterpolator () , step ) ; }
{ super ( false , c , a , b , new MidpointStepInterpolator () , step ) ; }
{ super ( false , c , a , b , new ThreeEighthesStepInterpolator () , step ) ; }
{ super ( false , c , a , b , new ClassicalRungeKuttaStepInterpolator () , step ) ; }
public double getCurrentStepsize () { return stepSize ; }
public double getCurrentStepsize () { return stepSize ; }
TestProblemHandler handler = new TestProblemHandler ( pb ) ;
TestProblemHandler handler = new TestProblemHandler ( pb ) ;
TestProblemHandler handler = new TestProblemHandler ( pb ) ;
TestProblemHandler handler = new TestProblemHandler ( pb ) ;
integ . addSwitchingFunction ( stepProblem , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
integ . addSwitchingFunction ( stepProblem , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
integ . addSwitchingFunction ( stepProblem , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ if ( isNaN () ) { return NaN ; } return new Complex ( - real , - imaginary ) ; }
{ if ( isNaN () ) { return NaN ; } return new Complex ( real , - imaginary ) ; }
{ SummaryStatistics stats = SummaryStatistics . newInstance () ; binStats . add ( i , stats ) ; }
sampleStats = SummaryStatistics . newInstance () ;
sampleStats = SummaryStatistics . newInstance () ;
SummaryStatistics u = SummaryStatistics . newInstance () ;
SummaryStatistics stats = SummaryStatistics . newInstance () ;
SummaryStatistics stats = SummaryStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
SummaryStatistics oneSidedPStats = SummaryStatistics . newInstance () ;
sampleStats = SummaryStatistics . newInstance () ;
SummaryStatistics oneSidedPStats = SummaryStatistics . newInstance () ;
sampleStats = SummaryStatistics . newInstance () ;
DescriptiveStatistics u = DescriptiveStatistics . newInstance () ;
BufferedReader in = new BufferedReader ( new InputStreamReader ( getClass () . getResourceAsStream ( resource ) ) ) ;
{ return arguments ; }
String [] parts
String [] parts
{ throw new ConvergenceException ( STRING_CONSTANT + STRING_CONSTANT , new String [] { Integer . toString ( starts ) } ) ; }
return ( largest.cost - smallest.cost ) < threshold ;
return ( largest.cost - smallest.cost ) < threshold ;
assertTrue ( optimum.cost > NUMBER_CONSTANT ) ;
assertTrue ( optimum.cost > NUMBER_CONSTANT ) ;
simplex [ i ] . cost > pointCostPair.cost
double originalCost = original [ NUMBER_CONSTANT ] . cost ;
{ throw new EstimationException ( STRING_CONSTANT , new String [] { Integer . toString ( maxCostEval ) } ) ; }
VectorialCovariance covStat = new VectorialCovariance ( mean.length ) ;
VectorialCovariance stat = new VectorialCovariance ( points [ NUMBER_CONSTANT ] . length ) ;
VectorialCovariance stat = new VectorialCovariance ( NUMBER_CONSTANT ) ;
{ new VectorialCovariance ( NUMBER_CONSTANT ) . increment ( new double [ NUMBER_CONSTANT ] ) ; fail ( STRING_CONSTANT ) ; }
VectorialCovariance covStat = new VectorialCovariance ( mean.length ) ;
double c = NUMBER_CONSTANT / ( n * ( n - NUMBER_CONSTANT ) ) ;
VectorialCovariance covStat = new VectorialCovariance ( vertices [ NUMBER_CONSTANT ] . length ) ;
{ return meanImpl ; }
{ return geoMeanImpl ; }
{ return sumLogImpl ; }
{ return maxImpl ; }
{ return minImpl ; }
{ return sumSqImpl ; }
{ return sumImpl ; }
try { u . setMeanImpl ( new sumMean () ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalStateException ex ) {}
++ jacobianEvaluations ;
++ jacobianEvaluations ;
catch ( ArithmeticException e ) {}
catch ( ArithmeticException e ) {}
String [] parts
return NUMBER_CONSTANT - distribution . cumulativeProbability ( - t , t ) ;
return NUMBER_CONSTANT - distribution . cumulativeProbability ( - t , t ) ;
return NUMBER_CONSTANT - distribution . cumulativeProbability ( - t , t ) ;
{ switchesHandler . add ( function , maxCheckInterval , convergence , maxIterationCount ) ; }
{ functions = new ArrayList () ; first = null ; initialized = false ; }
{ return ( ( StepInterpolator ) steps . get ( index ) ) . getInterpolatedState () ; }
{ return ( ( StepInterpolator ) steps . get ( index ) ) . getInterpolatedTime () ; }
public ContinuousOutputModel () { steps = new ArrayList () ; reset () ; }
points = new ArrayList () ;
points = new ArrayList () ;
{ switchesHandler . add ( function , maxCheckInterval , convergence , maxIterationCount ) ; }
Collection c
Collection categoryData
Collection categoryData
Collection categoryData
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList () ) ;
Collection categoryData
Collection categoryData
Collection categoryData
certifiedValues = new HashMap () ;
List list
List list
public ListUnivariateImpl () { this ( new ArrayList () ) ; }
Collection c
{ this . binCount = binCount ; binStats = new ArrayList () ; }
public EmpiricalDistributionImpl () { binStats = new ArrayList () ; }
Collection categoryData
Collection categoryData
Collection categoryData
Class key
Class key
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList () , transformers ) ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList () , transformers ) ;
DescriptiveStatistics u = new ListUnivariateImpl ( new ArrayList () , transformers ) ;
{ return solve ( MatrixUtils . createBigIdentityMatrix ( this . getRowDimension () ) ) ; }
public BigMatrix copy () { return new BigMatrixImpl ( this . copyOut () ) ; }
int nRows = v.length ;
{ return solve ( MatrixUtils . createRealIdentityMatrix ( this . getRowDimension () ) ) ; }
{ new Rotation ( u , new Vector3D () ) ; fail ( STRING_CONSTANT ) ; }
{ Vector3D . angle ( new Vector3D () , Vector3D.plusI ) ; fail ( STRING_CONSTANT ) ; }
{ new Vector3D () . normalize () ; fail ( STRING_CONSTANT ) ; }
assertTrue ( Math . abs ( new Vector3D () . getNorm () ) < NUMBER_CONSTANT ) ;
String [] parts
Object [] arguments = { new Double ( NUMBER_CONSTANT ) } ;
Object [] arguments = { new Double ( NUMBER_CONSTANT ) } ;
if ( offset > NUMBER_CONSTANT ) { throw new SwitchException ( STRING_CONSTANT , new Object [] { new Double ( t ) } ) ; }
return new Double ( newA ) ;
return new Double ( newA ) ;
return new Double ( newA ) ;
return new Double ( newA ) ;
Object [] arguments = { new Integer ( NUMBER_CONSTANT ) , new Integer ( NUMBER_CONSTANT ) } ;
Object [] arguments = { new Integer ( NUMBER_CONSTANT ) , new Integer ( NUMBER_CONSTANT ) } ;
Double pi = new Double ( Math.PI ) ;
assertFalse ( zero . equals ( new Double ( NUMBER_CONSTANT ) ) ) ;
{ return new Double ( o . toString () ) . doubleValue () ; }
assertFalse ( STRING_CONSTANT , u . equals ( new Double ( NUMBER_CONSTANT ) ) ) ;
Object [] arguments = { new Integer ( NUMBER_CONSTANT ) , new Integer ( NUMBER_CONSTANT ) } ;
Object [] arguments = { new Integer ( NUMBER_CONSTANT ) , new Integer ( NUMBER_CONSTANT ) } ;
new Object [] { new Double ( NUMBER_CONSTANT ) }
new Object [] { new Double ( p ) }
{ super ( STRING_CONSTANT , new Object [] { new Integer ( maxIterations ) } ) ; this . maxIterations = maxIterations ; }
{ super ( STRING_CONSTANT , new Object [] { new Double ( value ) , new Integer ( maxIterations ) } ) ; }
list . add ( new Double ( one ) ) ;
Object [] arguments = { new Integer ( NUMBER_CONSTANT ) , new Integer ( NUMBER_CONSTANT ) } ;
Object [] arguments = { new Integer ( NUMBER_CONSTANT ) , new Integer ( NUMBER_CONSTANT ) } ;
assertFalse ( STRING_CONSTANT , u . equals ( new Double ( NUMBER_CONSTANT ) ) ) ;
assertFalse ( u . equals ( new Double ( NUMBER_CONSTANT ) ) ) ;
dynaBean . set ( propertyName , new Double ( v ) ) ;
{ throw new EstimationException ( STRING_CONSTANT , new Object [] { new Integer ( rows ) , new Integer ( cols ) } ) ; }
{ return getCumPct ( new Long ( v ) ) ; }
{ return getCumPct ( new Long ( v ) ) ; }
{ return getCumFreq ( new Long ( v ) ) ; }
{ return getCumFreq ( new Long ( v ) ) ; }
{ return getPct ( new Long ( v ) ) ; }
{ return getPct ( new Long ( v ) ) ; }
{ return getCount ( new Long ( v ) ) ; }
{ return getCount ( new Long ( v ) ) ; }
{ addValue ( new Long ( v . longValue () ) ) ; }
Double value = new Double ( valueString ) ;
Integer input = new Integer ( NUMBER_CONSTANT ) ;
Double input = new Double ( expected ) ;
{ throw new EstimationException ( STRING_CONSTANT , new Object [] { new Integer ( m ) , new Integer ( p ) } ) ; }
{ throw new EstimationException ( STRING_CONSTANT , new Object [] { new Integer ( maxCostEval ) } ) ; }
double delta = ( max - min ) / ( new Double ( binCount ) ) . doubleValue () ;
{ val = new Double ( str ) . doubleValue () ; sampleStats . addValue ( val ) ; }
super ( STRING_CONSTANT , new Object [] { new Integer ( dimension1 ) , new Integer ( dimension2 ) } ) ;
{ super ( STRING_CONSTANT , new Object [] { new Double ( argument ) } ) ; this . argument = argument ; }
{ ret = new Double ( value ) ; pos . setIndex ( endIndex ) ; }
seenNames . add ( nameNode . getQualifiedName () ) ;
{ if ( seenNames . contains ( nameNode . getQualifiedName () ) ) { return RemovalType.REMOVE_ALL ; } jsdocNode . setJSDocInfo ( getAllTypeJSDoc () ) ; return RemovalType.REMOVE_RHS ; }
NodeTraversal . traverseEs6 ( compiler , root , new RemoveCode ( compiler ) ) ;
export . getFirstChild () . getType () == Token.EXPORT_SPECS
n . getType ()
Preconditions . checkArgument ( source == null || Token.FUNCTION == source . getType () ) ;
Preconditions . checkArgument ( source == null || Token.FUNCTION == source . getType () ) ;
parent . getType ()
n . getType ()
while ( moveIt . hasNext () ) { actualTokens . add ( moveIt . next () . getType () ) ; }
Token secondArgumentType = secondArgument . getType () ;
assertThat ( cont . getType () ) . isSameAs ( Token.CONTINUE ) ;
assertThat ( breakStm . getType () ) . isSameAs ( Token.BREAK ) ;
value . getType ()
n . getType ()
parent . getType ()
rootNameNode . getType ()
parent . getType ()
n . getType ()
changed = changed || finalValue . getType () != info.initialValue . getType () || ! finalValue . isEquivalentTo ( info.initialValue ) ;
Token type = n . getType () ;
{ switch ( n . getFirstChild () . getType () ) { case HOOK : case AND : case OR : return true ; default: break; } }
{ switch ( n . getType () ) { case BREAK : case CONTINUE : case RETURN : case THROW : return true ; default: return false ; } }
blockChild . getType ()
n . getType ()
subtree . getType ()
n . getType ()
if ( typeExprNode . getType () == Token.QMARK && ! typeExprNode . hasChildren () ) { return true ; }
n . getType ()
n . getType ()
{ Preconditions . checkState ( sourceName != null ) ; Preconditions . checkState ( n . getType () == type , n ) ; }
n . getType ()
n . getType ()
node . getType ()
n . getType ()
input . getType ()
n . getParent () . getType ()
n . getType ()
n . getType ()
int parentPrecedence = NodeUtil . precedence ( n . getType () ) ;
node . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
notChild . getType ()
n . getType ()
node . getType ()
Preconditions . checkArgument ( node . isNew () , STRING_CONSTANT , node . getType () ) ;
Preconditions . checkArgument ( node . isCall () , STRING_CONSTANT , node . getType () ) ;
Preconditions . checkArgument ( node . isHook () , STRING_CONSTANT , node . getType () ) ;
Preconditions . checkArgument ( ( node . isAnd () ) || ( node . isOr () ) , STRING_CONSTANT , node . getType () ) ;
Preconditions . checkArgument ( hook . isHook () , STRING_CONSTANT , hook . getType () ) ;
Preconditions . checkArgument ( ( original . isAnd () ) || ( original . isOr () ) , STRING_CONSTANT , original . getType () ) ;
Token parentType = parent . getType () ;
{ if ( typeNode . getType () == Token.BANG ) { typeNode = typeNode . getFirstChild () ; } return typeNode ; }
rhs . getType ()
Token type = current . getType () ;
{ assertEquals ( Token.FUNCTION , function . getType () ) ; assertEquals ( name , NodeUtil . getName ( function ) ) ; }
switch ( n . getParent () . getType () ) { case VAR : case CATCH : names . add ( n . getString () ) ; break; default: break; }
Token type = n . getType () ;
switch ( c . getType () ) { case FUNCTION : case AND : case OR : case HOOK : return true ; default: break; }
cArg . getType ()
Token type = parent . getType () ;
Token declarationType = declarationNode . getType () ;
{ newNode = IR . declaration ( newLHS , newRHS , parent . getType () ) ; }
{ newNode = IR . declaration ( newLHS , newRHS , parent . getType () ) ; }
n . getType ()
n . getType ()
n . getType ()
Token parentType = parent . getType () ;
c . getType ()
last . getType ()
n . getType ()
n . getType ()
n . getParent () . getType ()
n . getType ()
{ @ Override public boolean apply ( Node n ) { return type == n . getType () ; } }
Token exprKind = expr . getType () ;
expr . getType ()
insideQualifiedName || propAccessNode . getParent () . getType () != Token.ASSIGN
expr . getType ()
lvalue . getType ()
Token tokenType = expr . getType () ;
{ warnInvalidOperand ( expr , expr . getType () , STRING_CONSTANT , lhsType + STRING_CONSTANT + rhsType ) ; }
if ( ! commonTypes . isNumberScalarOrObj ( pair.type ) ) { warnInvalidOperand ( child , expr . getType () , JSType.NUMBER , pair.type ) ; }
Token exprKind = expr . getType () ;
{ warnings . add ( JSError . make ( expr , UNKNOWN_EXPR_TYPE , expr . getType () . toString () ) ) ; }
dn . getValue () . getType ()
if ( ! propName . isString () ) { throw new IllegalStateException ( STRING_CONSTANT + propName . getType () ) ; }
if ( ! propName . isString () ) { throw new IllegalStateException ( STRING_CONSTANT + propName . getType () ) ; }
assertEquals ( Token.STRING , n . getType () ) ;
{ assertEquals ( Token.STRING , n . getType () ) ; visited . append ( n . getString () ) ; }
parent . getType ()
Token nodeType = input . getType () ;
n . getType ()
{ switch ( n . getType () ) { case CALL : visitCall ( t , n ) ; break; default: break; } }
Node decl = IR . declaration ( cls.name . cloneTree () , cls.constructor.value , exprRoot . getType () ) . srcref ( exprRoot ) ;
parent . getType ()
! registerFunc . isValidNodeType ( valueNode . getType () )
! registerFunc . isValidNodeType ( value . getType () )
getType ()
getType ()
getType ()
getType ()
return enclosingNode != null && enclosingNode . getType () != Token.FUNCTION ;
n . getType ()
{ switch ( n . getType () ) { case AND : case OR : case HOOK : return true ; default: return false ; } }
lhs . getType ()
Token parentType = parent . getType () ;
{ switch ( n . getType () ) { case HOOK : case AND : case OR : return true ; default: return false ; } }
expr . getType ()
n . getType ()
node . getType ()
node . getType ()
n . getType ()
n . getType ()
assertEquals ( Token.NEW , callsiteNode . getType () ) ;
assertEquals ( Token.CALL , callsiteNode . getType () ) ;
assertEquals ( Token.CALL , callsiteNode . getType () ) ;
n . getType ()
Token type = n . getType () ;
n . getType ()
n . getType ()
n . getType ()
expr . getRoot () . getType ()
n . getType ()
int expectedArity = Token . arity ( n . getType () ) ;
switch ( n . getType () ) { case NAME : validateName ( n ) ; break; case GETPROP : validateGetProp ( n ) ; break; default: break; }
catch ( UnsupportedOperationException e ) { violation ( STRING_CONSTANT + n . getType () , n ) ; }
{ validateChildCount ( n , NUMBER_CONSTANT ) ; validateNameDeclarationHelper ( n . getType () , n ) ; }
{ if ( NodeUtil . isNameDeclaration ( n ) ) { validateNameDeclarationHelper ( n . getType () , n ) ; } else { validateOptionalExpression ( n ) ; } }
if ( body . getType () == Token.BLOCK ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
n . getFirstChild () . getType () == Token.EXPORT_SPECS
secondChild . getType ()
Token type = nextNode . getType () ;
n . getType ()
n . getType ()
n . getType ()
c . getType ()
left . getType ()
TernaryValue result = evaluateComparison ( n . getType () , left , right , shouldUseTypes ) ;
Node result = performArithmeticOp ( n . getType () , left , right ) ;
Token type = n . getType () ;
n . getType ()
argumentNode . getType ()
n . getType ()
n . getType ()
subtree . getType ()
subtree . getType ()
n . getType ()
n . getType ()
declType = variable . getType () ;
n . getType ()
n . getType ()
parent . getType ()
n . getType ()
n . getType ()
arg . getType () != desiredType
val . getType ()
n . getType ()
n . getType ()
switch ( n . getType () ) { case GETPROP : return n . getLastChild () . getString () ; case MEMBER_FUNCTION_DEF : return n . getString () ; default: break; }
n . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
if ( node . getType () == type ) { matchingNodes . add ( node ) ; }
n . getType ()
Token type = ancestor . getType () ;
return parent != null && parent . getType () == Token.EXPONENT && parent . getFirstChild () == n ;
{ return NodeUtil . precedence ( n . getType () ) < minPrecedence ; }
{ switch ( n . getType () ) { case LET : case CONST : case FUNCTION : case CLASS : case DO : return true ; default: return false ; } }
while ( firstNonOperator . getType () == op ) { firstNonOperator = firstNonOperator . getFirstChild () ; }
n . getType ()
Token parentType = useParent . getType () ;
Token nodeType = n . getType () ;
{ switch ( n . getType () ) { case CALL : annotateCalls ( n ) ; break; default: break; } }
next . getType ()
value . getType ()
value . getType ()
{ Token type = n . getType () ; return ( type == Token.INC || type == Token.DEC ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT + node . getType () ) ; }
n . getType ()
FlowScope rightScope = reverseInterpreter . getPreciserScopeKnowingConditionOutcome ( left , leftOutcome . getOutcomeFlowScope ( left . getType () , nIsAnd ) , nIsAnd ) ;
left . getType ()
n . getType ()
newScope = reverseInterpreter . getPreciserScopeKnowingConditionOutcome ( condition , conditionOutcomes . getOutcomeFlowScope ( condition . getType () , branch == Branch.ON_TRUE ) , branch == Branch.ON_TRUE ) ;
assertEquals ( Token.SCRIPT , global . getDeclaration () . getNode () . getType () ) ;
assertEquals ( Token.GETPROP , refs . get ( NUMBER_CONSTANT ) . getNode () . getType () ) ;
assertEquals ( Token.GETPROP , refs . get ( NUMBER_CONSTANT ) . getNode () . getType () ) ;
assertEquals ( Token.NAME , refs . get ( NUMBER_CONSTANT ) . getNode () . getType () ) ;
expr . getType ()
expr . getType ()
n . getType ()
n . getType ()
Token actualType = cfgNodes . get ( i ) . getValue () . getType () ;
if ( source . getType () == startToken ) { assertFalse ( STRING_CONSTANT + startToken + STRING_CONSTANT + STRING_CONSTANT , cfg . isImplicitReturn ( dest ) ) ; return; }
if ( source . getType () == startToken && cfg . isImplicitReturn ( dest ) ) { return; }
n . getType ()
if ( isSimpleOp ) { msg = STRING_CONSTANT + n . getType () . toString () . toLowerCase () + STRING_CONSTANT ; }
Token type = parent . getType () ;
n . getType ()
typeNode != null && typeNode . getType () == Token.STRING
n . getType ()
definitionParent . getType ()
n . getType ()
builder . append ( n . getType () . toString () ) ;
assertEquals ( Token.VAR , var . getType () ) ;
type != null && type . getType () != Token.ARRAY_TYPE
if ( invalidInitializers . contains ( initializer . getType () ) ) { errorReporter . error ( STRING_CONSTANT , sourceName , lineno ( loopNode.initializer ) , charno ( loopNode.initializer ) ) ; }
if ( invalidInitializers . contains ( initializer . getType () ) ) { errorReporter . error ( STRING_CONSTANT , sourceName , lineno ( loopNode.initializer ) , charno ( loopNode.initializer ) ) ; }
Token nType = n . getType () ;
{ switch ( n . getType () ) { case FOR : case FOR_OF : case WHILE : case DO : return true ; default: return false ; } }
{ switch ( n . getType () ) { case FOR : case FOR_OF : case WHILE : case DO : case SWITCH : return true ; default: return false ; } }
assertEquals ( Token.FUNCTION , fooNode . getType () ) ;
assertThat ( enumTypeNode . getType () ) . isEqualTo ( Token.BANG ) ;
node . getType () == Token.CALL
{ if ( blockNode . getChildCount () == NUMBER_CONSTANT && blockNode . getFirstChild () . getType () == Token.THROW ) { return true ; } return false ; }
n . getType ()
if ( fieldTypeNode . getType () == Token.COLON ) { fieldNameNode = fieldTypeNode . getFirstChild () ; hasType = true ; }
namedImports . getType () == Token.IMPORT_SPECS
n . getType ()
throw new RuntimeException ( STRING_CONSTANT + defSite . getType () ) ;
n . getType ()
n . getType ()
Preconditions . checkState ( nameNode . isGetProp () , STRING_CONSTANT , nameNode . getType () ) ;
Node newVar = IR . declaration ( child , n . getType () ) . srcref ( n ) ;
refParent . getType ()
anc . getType ()
parent . getType ()
n . getType ()
grandparent . getType ()
n . getType ()
n . getType ()
Token pType = parent . getType () ;
Token type = n . getType () ;
parent . getType () == Token.PARAM_LIST
aliasReference . getType () == Token.STRING_KEY
parent . getType ()
ancestor . getType ()
n . getType ()
n . getType ()
if ( typeNode . getType () != Token.EQUALS ) { report ( typeNode , DEFAULT_PARAM_MUST_BE_MARKED_OPTIONAL ) ; }
n . getType ()
n . getType ()
node . getType ()
Token parentNodeType = parent . getType () ;
key . getType ()
n . getType ()
n . getType ()
n . getParent () . getType ()
arg . getType ()
isASTNormalized () && Token.NAME == constructorNameNode . getType ()
result . getType ()
node . getType ()
{ if ( n . getType () == Token.INSTANCEOF ) { reportIfNonObject ( t , n . getFirstChild () , SUSPICIOUS_INSTANCEOF_LEFT_OPERAND ) ; } }
{ if ( n . getType () == Token.IN ) { reportIfNonObject ( t , n . getLastChild () , SUSPICIOUS_IN_OPERATOR ) ; } }
n . getType ()
n . getType ()
n . getType ()
n . getType ()
switch ( n . getType () ) { case FUNCTION : if ( n . isArrowFunction () ) { visitArrowFunction ( t , n ) ; } break; default: break; }
Token operatorToken = condition . getType () ;
parent . getType ()
n . getType ()
Token type = n . getType () ;
decl.node . getParent () . getType ()
Preconditions . checkArgument ( n . isGetProp () , STRING_CONSTANT , n . getType () , n ) ;
Token nType = n . getType () ;
val . getType () == Token.OR
n . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
control . getType ()
n . getType ()
n . getType () == type
n . getType ()
int offset = getSourceInfoOffset ( provideStringNode ) ;
{ return ! type . isNoResolvedType () ; }
return isKnown ( n ) && ! isAllType ( n ) && isClassType ( n ) && ! isNativeObjectType ( n ) && ! isWhitelistedType ( n ) ;
! isTemplateType ( n )
! isTemplateType ( n )
if ( type == null || type . isUnknownType () || type . isAllType () ) { return new MatchResult ( allowLooseMatches , allowLooseMatches ) ; }
options . setPreserveGoogRequires ( true ) ;
compilerOptions . setPreserveGoogRequires ( true ) ;
importNode . copyInformationFrom ( export ) ;
parent . replaceChild ( export , declaration . detachFromParent () ) ;
{ if ( n . getParent () != null ) { n . detachFromParent () ; compiler . reportCodeChange () ; } }
if ( root != null ) { root . detachFromParent () ; }
if ( rep . isExprResult () ) { rep = rep . getFirstChild () ; rep . detachFromParent () ; }
{ changeProxy . replaceWith ( grandparent , parent , parent . getLastChild () . detachFromParent () ) ; }
Node condStatement = IR . exprResult ( cond . detachFromParent () ) . srcref ( cond ) ;
Node statement = IR . exprResult ( cond . detachFromParent () ) . useSourceInfoIfMissingFrom ( cond ) ;
n . getParent () . replaceChild ( n , caseBlock . detachFromParent () ) ;
{ maybeBreak . detachFromParent () ; reportCodeChange () ; }
{ subtree . detachFromParent () ; subtree = null ; }
{ subtree . getParent () . replaceChild ( subtree , right . detachFromParent () ) ; reportCodeChange () ; return right ; }
argNode . detachFromParent () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detachFromParent () ; reportCodeChange () ; return null ; }
{ block . replaceChild ( maybeIf , maybeIf . getLastChild () . detachFromParent () ) ; }
Node simplified = new Node ( type , condition . detachFromParent () , simplifyShortCircuitBranch ( body ) ) . useSourceInfoIfMissingFrom ( hook ) ;
{ if ( original . getParent () != null ) { original . detachFromParent () ; } replacements . add ( original ) ; }
{ for ( Node c : externs . children () ) { if ( ! c . hasChildren () ) { c . detachFromParent () ; } } }
if ( expected != null ) { expectedRoot = parseExpectedJs ( expected ) ; expectedRoot . detachFromParent () ; }
Node decl = IR . declaration ( pattern . detachFromParent () , IR . name ( tempVarName ) , declarationType ) ;
Node replacement = firstArg . detachFromParent () ;
{ rhs . detachFromParent () ; ancestor . replaceChild ( last , rhs ) ; }
inlineValue ( v , ref , value . detachFromParent () ) ;
n . detachFromParent () ;
{ if ( node != null && node . getParent () != null ) { node . detachFromParent () ; } return node ; }
Node newDeclaration = IR . var ( name . detachFromParent () ) . useSourceInfoFrom ( declarationList ) ;
rhs . detachFromParent () ;
Node body = IR . block ( IR . returnNode ( returnValue . detachFromParent () ) ) ;
if ( i == NUMBER_CONSTANT && first . getString () . isEmpty () ) { add = add . getSecondChild () . detachFromParent () ; }
{ n . detachFromParent () ; }
for ( PrototypeMemberDeclaration declar : instance.declarations ) { block . addChildToBack ( declar.node . detachFromParent () ) ; }
{ compiler . report ( JSError . make ( requireNode , MISSING_MODULE_OR_PROVIDE.level , MISSING_MODULE_OR_PROVIDE , legacyNamespace ) ) ; NodeUtil . getEnclosingStatement ( requireNode ) . detachFromParent () ; continue; }
moduleBlockNode . detachFromParent () ;
returnStatementNode . detachFromParent () ;
{ NodeUtil . getEnclosingStatement ( call ) . detachFromParent () ; }
private void updateGoogDeclareLegacyNamespace ( Node call ) { NodeUtil . getEnclosingStatement ( call ) . detachFromParent () ; }
if ( ! currentScript.declareLegacyNamespace ) { NodeUtil . getEnclosingStatement ( call ) . detachFromParent () ; }
Node replacement = value . detachFromParent () ;
Node destObj = n . getSecondChild () . detachFromParent () ;
Node newNode = new Node ( newType , left . detachFromParent () , newRight . detachFromParent () ) ;
if ( NodeUtil . isNumericResult ( left ) ) { parent . replaceChild ( n , left . detachFromParent () ) ; reportCodeChange () ; return left ; }
{ parent . getParent () . detachFromParent () ; compiler . reportCodeChange () ; }
node . detachFromParent () ;
Node method = member . getLastChild () . detachFromParent () ;
stringKey = IR . stringKey ( ( member . isGetterDef () || member . getBooleanProp ( Node.COMPUTED_PROP_GETTER ) ) ? STRING_CONSTANT : STRING_CONSTANT , function . detachFromParent () )
constructor = member . getFirstChild () . detachFromParent () ;
for ( Node child : functionBody . children () ) { newBlock . addChildToBack ( child . detachFromParent () ) ; }
Node stringKey = IR . stringKey ( name , n . getFirstChild () . detachFromParent () ) ;
{ if ( preserveGoogProvidesAndRequires && explicitNode . hasChildren () ) { return; } explicitNode . detachFromParent () ; compiler . reportCodeChange () ; }
if ( typeDeclaration != null ) { compiler . forwardDeclareType ( typeDeclaration ) ; parent . detachFromParent () ; compiler . reportCodeChange () ; }
Node value = n . getChildAtIndex ( NUMBER_CONSTANT ) . detachFromParent () ;
for ( Node closureRequire : requiresToBeRemoved ) { closureRequire . detachFromParent () ; compiler . reportCodeChange () ; }
if ( parent . isExprResult () ) { parent . detachFromParent () ; } else { parent . replaceChild ( n , elemValue ) ; }
Node opDetached = op . detachFromParent () ;
potentialCallee . detachFromParent () ;
Node newGetProp = IR . getprop ( target . detachFromParent () , prop . detachFromParent () ) ;
callbackFunction . detachFromParent () ;
if ( secondExpr != firstExpr ) { secondExpr . detachFromParent () ; } else { secondExpr = IR . nullNode () ; }
var . detachFromParent () ;
{ expectedRoot = parseExpectedJs ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , expected ) ) ) ; expectedRoot . detachFromParent () ; }
clinitAssignedValue . detachFromParent () ;
arg . detachFromParent () ;
callNode . getParent () . replaceChild ( callNode , replacementNode . detachFromParent () ) ;
Node child = n . getLastChild () . detachFromParent () ;
{ if ( value != null ) { value . detachFromParent () ; } varNode = parent ; }
declParent . detachFromParent () ;
bind.target . detachFromParent () ;
colon . addChildToBack ( member . detachFromParent () ) ;
n . detachFromParent () ;
for ( Node child : stringKeys ) { child . detachFromParent () ; }
member . detachFromParent () ;
indexSignature . detachFromParent () ;
body . detachFromParent () ;
{ Node ancParent = ancestor . getParent () ; ancParent . replaceChild ( ancestor , ancestor . getLastChild () . detachFromParent () ) ; break; }
{ objlit . removeChild ( key ) ; value . detachFromParent () ; }
typeString . detachFromParent () ;
newBlock . detachFromParent () ;
Node stringKey = IR . stringKey ( name , memberDef . getFirstChild () . detachFromParent () ) ;
assignmentValue . detachFromParent () ;
comma . addChildToBack ( leftMostChild . detachFromParent () ) ;
if ( subtree . getChildCount () == NUMBER_CONSTANT ) { subtree . getLastChild () . detachFromParent () ; }
if ( ! t . inGlobalScope () && NodeUtil . isHoistedFunctionDeclaration ( value ) ) { parent . addChildToFront ( value . detachFromParent () ) ; }
List < Node > assignments = new ArrayList < Node > () ;
List < Node > nodes = new ArrayList < Node > () ;
public JSType getJSTypeBeforeCast () { return ( JSType ) getProp ( TYPE_BEFORE_CAST ) ; }
@ Override public boolean isInstanceType () { Preconditions . checkState ( this . isSingletonObj () ) ; return this . getNominalTypeIfSingletonObj () . isClass () ; }
@ Override public boolean isUnknownType () { return isUnknown () ; }
@ Override public TypeI evaluateTypeExpressionInGlobalScope ( JSTypeExpression expr ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
String externs = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
return fn . isLooseSubtypeOf ( other.fn , subSuperMap ) ;
UpdateThisAndArgumentsReferences updater = new UpdateThisAndArgumentsReferences () ;
NameBasedDefinitionProvider defFinder = new NameBasedDefinitionProvider ( compiler ) ;
public void testHookOperators4 ( ) throws Exception { checkMarkedCalls ( STRING_CONSTANT + STRING_CONSTANT , ImmutableList . < String > of () ) ; }
{ this . passUnderTest = new NameBasedDefinitionProvider ( compiler ) ; this . compiler = compiler ; }
NameBasedDefinitionProvider defFinder = new NameBasedDefinitionProvider ( compiler ) ;
defFinder = new NameBasedDefinitionProvider ( compiler ) ;
NameBasedDefinitionProvider defFinder = new NameBasedDefinitionProvider ( compiler ) ;
public DefinitionUseSiteFinder ( AbstractCompiler compiler ) { super ( compiler ) ; this . nameUseSiteMultimap = LinkedHashMultimap . create () ; }
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.INEXISTENT_PROPERTY ) ;
typeCheck ( STRING_CONSTANT , NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT ) ;
if ( testMode ) { return new StringWriter () ; }
if ( testMode ) { return new StringWriter () ; }
passes . add ( checkVariableReferences ) ;
phaseopt . process ( externsNode , n ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ process ( null , scriptRoot ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ if ( J2clSourceFileChecker . shouldSkipExecution ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
if ( J2clSourceFileChecker . shouldSkipExecution ( compiler ) ) { return; }
if ( J2clSourceFileChecker . shouldSkipExecution ( compiler ) ) { return; }
if ( J2clSourceFileChecker . shouldSkipExecution ( compiler ) ) { return; }
{ testSame ( Lists . newArrayList ( NO_J2CL_SOURCE_FILE , NO_J2CL_SOURCE_FILE2 ) ) ; assertThat ( compiler . getAnnotation ( J2clSourceFileChecker.HAS_J2CL_ANNOTATION_KEY ) ) . isEqualTo ( Boolean.FALSE ) ; }
{ testSame ( Lists . newArrayList ( NO_J2CL_SOURCE_FILE , J2CL_SOURCE_FILE , NO_J2CL_SOURCE_FILE2 ) ) ; assertThat ( compiler . getAnnotation ( J2clSourceFileChecker.HAS_J2CL_ANNOTATION_KEY ) ) . isEqualTo ( Boolean.TRUE ) ; }
{ if ( J2clSourceFileChecker . shouldSkipExecution ( compiler ) ) { return; } new StaticFieldGetterSetterInliner ( root ) . run () ; }
{ recvType = recvType . withProperty ( pname , JSType.TOP_OBJECT . withLoose () ) ; inEnv = updateLvalueTypeInEnv ( inEnv , obj , recvLvalue.ptr , recvType ) ; }
String js = STRING_CONSTANT ;
testSame ( code + STRING_CONSTANT ) ;
RefactoringDriver driver = new RefactoringDriver.Builder ( scanner ) . addExternsFromCode ( externs ) . addInputsFromCode ( originalCode ) . build () ;
ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , externs ) )
n . getTypeI () . isSomeUnknownType ()
{ tracker = new PerformanceTracker ( jsRoot , options.tracer , this . outStream ) ; addChangeHandler ( tracker . getCodeChangeHandler () ) ; }
passes . add ( checkVariableReferencesForTranspileOnly ) ;
phaseopt . process ( externsNode , externAndJsRoot ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
public static ResourceBundle getBundle ( String baseName , Locale locale ) { return new ResourceBundle () ; }
optionalFormals . add ( JSType . join ( t , JSType.UNDEFINED ) ) ;
boolean noCycles = constructorType . addInterfaces ( extendedInterfaces . isEmpty () ? ImmutableSet . of ( registry . getCommonTypes () . getObjectType () ) : extendedInterfaces ) ;
NominalType builtinObject = registry . getCommonTypes () . getObjectType () ;
{ builder . addRetType ( JSType.UNDEFINED ) ; }
builder . addRestFormals ( t != null ? t : JSType.UNKNOWN ) ;
return t . isSingletonObjWithNull () ? t . removeType ( JSType.NULL ) : t ;
tdType = JSType.UNKNOWN ;
try { return getTypeFromCommentHelper ( n , registry , typeParameters ) ; } catch ( UnknownTypeException e ) { return JSType.UNKNOWN ; }
{ if ( anyNumOrStr == null ) { return t . isSubtypeOf ( JSType.NUM_OR_STR ) ; } return t . isSubtypeOf ( anyNumOrStr ) ; }
{ if ( numberOrNumber == null ) { return t . isSubtypeOf ( JSType.STRING ) ; } return t . isSubtypeOf ( stringOrString ) ; }
{ if ( numberOrNumber == null ) { return t . isSubtypeOf ( JSType.NUMBER ) ; } return t . isSubtypeOf ( numberOrNumber ) ; }
stringOrString = JSType . join ( JSType.STRING , stringInstance ) ;
numberOrNumber = JSType . join ( JSType.NUMBER , numberInstance ) ;
ObjectType getStringInstanceObjType () { return stringInstanceObjtype != null ? stringInstanceObjtype : ObjectType.TOP_OBJECT ; }
ObjectType getBooleanInstanceObjType () { return booleanInstanceObjtype != null ? booleanInstanceObjtype : ObjectType.TOP_OBJECT ; }
ObjectType getNumberInstanceObjType () { return numberInstanceObjtype != null ? numberInstanceObjtype : ObjectType.TOP_OBJECT ; }
public JSType getStringInstance () { return stringInstance != null ? stringInstance : JSType.STRING ; }
public JSType getBooleanInstance () { return booleanInstance != null ? booleanInstance : JSType.BOOLEAN ; }
public JSType getNumberInstance () { return numberInstance != null ? numberInstance : JSType.NUMBER ; }
public JSType getRegexpType () { return regexpInstance != null ? regexpInstance : JSType.UNKNOWN ; }
if ( this . arguments == null ) { return JSType.UNKNOWN ; }
if ( arrayType == null ) { return JSType.UNKNOWN ; }
lvalue.type = lvalue.type . mayHaveProp ( pname ) ? lvalue.type . getProp ( pname ) : JSType.UNKNOWN ;
if ( doSlicing ) { pair.env = envPutType ( pair.env , name , declType != null ? declType : JSType.UNKNOWN ) ; }
! lvalueType . isSubtypeOf ( JSType.TOP_OBJECT )
if ( requiredType . mayHaveProp ( pname ) ) { reqPtype = requiredType . getProp ( pname ) ; } else { reqPtype = JSType.UNKNOWN ; }
return new EnvTypePair ( env , JSType.UNKNOWN ) ;
if ( formalType . isBottom () ) { formalType = JSType.UNKNOWN ; }
pair.type = JSType.BOOLEAN ;
JSType operandType = requiredType . isNumber () ? JSType.NUMBER : JSType.UNKNOWN ;
private EnvTypePair analyzeExprBwd ( Node expr , TypeEnv outEnv ) { return analyzeExprBwd ( expr , outEnv , JSType.UNKNOWN ) ; }
if ( outerType == null ) { outerType = JSType.UNKNOWN ; }
{ JSType tmp = t . getIndexedType () ; return tmp == null ? JSType.UNKNOWN : tmp ; }
{ reqPtype = specPtype = JSType.UNKNOWN ; }
if ( ! currentScope . hasThis () ) { mayWarnAboutGlobalThis ( expr , currentScope ) ; return new EnvTypePair ( inEnv , JSType.UNKNOWN ) ; }
return new EnvTypePair ( env , JSType.UNKNOWN ) ;
funType . isOptionalArg ( i ) && pair.type . equals ( JSType.UNDEFINED )
rhsPair.type = JSType.BOOLEAN ;
{ return analyzeExprFwd ( expr , inEnv , JSType.UNKNOWN , JSType.UNKNOWN ) ; }
if ( rootNs != null && rootNs . isSubtypeOf ( JSType.TOP_OBJECT ) ) { namespaceType = rootNs . getProp ( qname . getAllButLeftmost () ) ; }
if ( ! t . isUnknown () && ! t . equals ( JSType . fromTypeVar ( typeVar ) ) ) { return false ; }
if ( typeMap . isEmpty () ) { return Property . make ( JSType.UNKNOWN , null ) ; }
{ NominalType thisWithoutTypemap = this . rawType . getAsNominalType () ; return thisWithoutTypemap . instantiateGenerics ( JSType.MAP_TO_UNKNOWN ) ; }
JSType result = JSType.TOP ;
JSType result = JSType.BOTTOM ;
for ( String typedefName : localTypedefs . keySet () ) { locals . put ( typedefName , JSType.UNDEFINED ) ; }
{ isTypeVar = true ; type = JSType . fromTypeVar ( declaredType . getTypeVariableDefinedLocally ( name ) ) ; }
{ addNamespace ( qnameNode , new NamespaceLit ( getCommonTypes () , qnameNode . getQualifiedName () , qnameNode ) ) ; }
{ this . root . setTypeI ( getCommonTypes () . fromFunctionType ( declaredType . toFunctionType () ) ) ; }
return commonTypes . fromFunctionType ( ctorType ) ;
ObjectType arrayType = commonTypes . getArrayInstance () . getObjTypeIfSingletonObj () ;
if ( isTrueOrTruthy () ) { return FALSY ; } else if ( isFalseOrFalsy () ) { return TRUTHY ; }
return makeType ( newtype ) ;
{ JSType maybeScalar = ObjectType . mayTurnLooseObjectToScalar ( t , JSType.commonTypes ) ; if ( t != maybeScalar ) { return maybeScalar ; } }
JSType result = BOTTOM ;
JSType result = TOP ;
JSType result = JSType.BOTTOM ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) { return JSType.STRING ; }
recvType = recvType . removeType ( JSType.NULL ) ;
if ( propInferredFunType != null ) { rawType . addUndeclaredClassProperty ( pname , propInferredFunType , getProp ) ; } else { rawType . addUndeclaredClassProperty ( pname , JSType.UNKNOWN , getProp ) ; }
if ( t == null ) { t = JSType.UNKNOWN ; }
FunctionType getInstanceFunType = ( new FunctionTypeBuilder () ) . addRetType ( instanceType ) . buildFunction () ;
if ( t == null ) { t = JSType.UNKNOWN ; }
{ this . currentScope . addLocal ( varName , JSType.UNKNOWN , false , false ) ; }
JSType resultType = JSType.TOP ;
{ Preconditions . checkState ( ! this . isFinalized ) ; super . addUndeclaredProperty ( pname , defSite , JSType.UNKNOWN , false ) ; }
if ( type == null && isConstant ) { type = JSType.UNKNOWN ; }
this . randomProps . with ( pname , Property . make ( type == null ? JSType.UNKNOWN : type , type ) )
this == other || other.ns != null || ! other . getNominalType () . equals ( builtinObject )
if ( other == TOP_OBJECT ) { return true ; }
if ( other == TOP_OBJECT ) { return true ; }
if ( newPropType . isBottom () ) { return BOTTOM_MAP ; }
if ( ! isGeneric () || JSType.MAP_TO_UNKNOWN . equals ( concreteTypes ) ) { return substituteNominalGenerics ( concreteTypes ) ; }
FunctionTypeBuilder builder = new FunctionTypeBuilder () ;
{ if ( ! f . isGeneric () ) { return f ; } return f . instantiateGenerics ( JSType.MAP_TO_UNKNOWN ) ; }
if ( ! FunctionType.allowMethodsAsFunctions && this . receiverType != null && other.receiverType == null ) { return false ; }
FunctionTypeBuilder builder = new FunctionTypeBuilder () ;
return ImmutableList . copyOf ( out ) ;
EnvTypePair lhsPair = analyzeExprBwd ( lhs , rhsPair.env ) ;
passes . add ( checkVariableReferences ) ;
phaseopt . process ( externsNode , n ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ process ( null , scriptRoot ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
this . rawType . name . equals ( STRING_CONSTANT ) && NUMERIC_PATTERN . matcher ( pname ) . matches ()
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
public ProcessDefinesTest () { super ( STRING_CONSTANT ) ; allowSourcelessWarnings () ; }
assertThat ( JSDocInfoPrinter . print ( info ) ) . isEqualTo ( output ) ;
assertEquals ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , JSDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , JSDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , JSDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , JSDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , JSDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , JSDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , JSDocInfoPrinter . print ( info ) ) ;
passes . add ( checkVariableReferencesForTranspileOnly ) ;
phaseopt . process ( externsNode , externAndJsRoot ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
long stop () { return System . currentTimeMillis () + start ; }
replacement . setTypeI ( nativeStringType ) ;
passes . add ( checkVariableReferences ) ;
phaseopt . process ( externsNode , n ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ process ( null , scriptRoot ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ FindStaticMembers findStaticMembers = new FindStaticMembers () ; NodeTraversal . traverseEs6 ( compiler , scriptRoot , findStaticMembers ) ; processInherits ( findStaticMembers.inheritsCalls ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new J2clConstantHoisterPass ( compiler ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new J2clEqualitySameRewriterPass ( compiler ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new J2clConstantHoisterPass ( compiler ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new J2clClinitPrunerPass ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clClinitPrunerPass ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clEqualitySameRewriterPass ( compiler ) ; }
Node moduleNode = new Node ( Token.MODULE_BODY ) ;
Node methodName = member . getFirstChild () . getFirstChild () ;
Node lhs = node . getFirstChild () . getFirstChild () ;
Node clinitFunction = multiExpression . getFirstChild () . getFirstChild () ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ;
public void disable_testClassMethodUnused2 () { this . disableTypeCheck () ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { this . disableTypeCheck () ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
{ passes . add ( flowSensitiveInlineVariables ) ; if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedVars ( STRING_CONSTANT , false ) ) ; } }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler , true ) ; }
options . setRemoveDeadCode ( true ) ;
options . setRemoveDeadCode ( true ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler , false ) ; }
options . setFoldConstants ( true ) ;
options . setFoldConstants ( true ) ;
options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ;
public void testInvalidAnnotation5 ( ) throws Exception { testError ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
public void testInvalidAnnotation4 ( ) throws Exception { testError ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
String globalModuleName = t . getInput () . getUri () . resolveEs6Module ( moduleName ) . toModuleName () ;
String moduleName = t . getInput () . getUri () . toModuleName () ;
String moduleName = t . getInput () . getUri () . resolveEs6Module ( moduleIdentifier . getString () ) . toModuleName () ;
{ moduleName = t . getInput () . getUri () . resolveEs6Module ( importName ) . toModuleName () ; }
public String toModuleName () { return ModuleNames . toModuleName ( uri ) ; }
public String toJSIdentifier () { return ModuleNames . toJSIdentifier ( uri ) ; }
{ requires . add ( fileUri . resolveEs6Module ( arg ) . toModuleName () ) ; }
String moduleName = t . getInput () . getUri () . toModuleName () ;
ModuleLoader.ModuleUri actual
TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , this ) ;
assertWarning ( STRING_CONSTANT , RhinoErrorReporter.JSDOC_MISSING_BRACES_WARNING , STRING_CONSTANT ) ;
{ errorReporter . warning ( STRING_CONSTANT + SimpleErrorReporter . getMessage0 ( messageId ) , getSourceName () , lineno , charno ) ; }
{ errorReporter . warning ( STRING_CONSTANT + SimpleErrorReporter . getMessage1 ( messageId , messageArg ) , getSourceName () , lineno , charno ) ; }
{ SourceMapObject sourceMapObject = new SourceMapObject ( contents ) ; parse ( sourceMapObject , null ) ; }
SourceMapObject sourceMapObject = new SourceMapObject ( contents ) ;
{ for ( MemberDefinition prop : PolymerPassStaticUtils . extractProperties ( objLit ) ) { prop.name . removeProp ( Node.JSDOC_INFO_PROP ) ; } }
PolymerPassStaticUtils . extractProperties ( objLit )
overwriteMembersIfPresent ( allProperties , PolymerPassStaticUtils . extractProperties ( descriptor ) ) ;
return MODULE_JOINER . join ( Arrays . copyOfRange ( buffer , NUMBER_CONSTANT , position ) ) ;
{ GwtProperties p = GwtProperties . load ( STRING_CONSTANT ) ; assertTrue ( p . propertyNames () . isEmpty () ) ; }
if ( options.coalesceVariableNames ) { passes . add ( coalesceVariableNames ) ; if ( options.foldConstants ) { passes . add ( peepholeOptimizations ) ; } }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ Preconditions . checkState ( hasInstanceType () ) ; return typeOfThis . toObjectType () ; }
{ if ( sideEffectInfo . taintedLocals () . contains ( v ) ) { sideEffectInfo . setTaintsUnknown () ; sideEffectInfo . resetLocalVars () ; break; } }
if ( defs == null ) { functionInfo . setTaintsUnknown () ; break; }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String currentJsSource = toSource () ;
Config config = ParserRunner . createConfig ( mode , Config.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , Config.RunMode.KEEP_GOING , null ) ;
{ this ( annotationWhitelist , JsDocParsing.TYPES_ONLY , RunMode.STOP_AFTER_ERROR , suppressionNames , languageMode ) ; }
Config config = new Config ( extraAnnotations , parseDocumentation , RunMode.STOP_AFTER_ERROR , extraSuppressions , LanguageMode.ECMASCRIPT3 ) ;
Config config = new Config ( extraAnnotations , JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , RunMode.KEEP_GOING , extraSuppressions , LanguageMode.ECMASCRIPT3 ) ;
return new ParseResult ( root , comments , features ) ;
{ return createConfig ( languageMode , JsDocParsing.TYPES_ONLY , RunMode.STOP_AFTER_ERROR , extraAnnotationNames ) ; }
{ this ( config , errorReporter , source , offset , false ) ; }
jsdoc . getType ()
return jsdocNode != null && jsdocNode . getType () == Token.ELLIPSIS ;
Preconditions . checkState ( thisRoot . getType () == Token.BANG ) ;
boolean isPropDeclared = propNode . getType () == Token.COLON ;
keyNode . setType ( Token.STRING_KEY ) ;
keyNode . setType ( Token.STRING_KEY ) ;
n . getType ()
Token type = n . getType () ;
{ return include == nodeTypes . contains ( n . getType () ) ; }
switch ( node . getType () ) { case NAME : case STRING : case STRING_KEY : return node . getString () ; default: return compiler . toSource ( node ) ; }
{ Node dollarChildProp = n . getGrandparent () ; dollarChildProp . setType ( Token.GETELEM ) ; compiler . reportCodeChange () ; }
newOperator . setType ( complementOperator ) ;
shorthand . setType ( NodeUtil . getOpFromAssignmentOp ( shorthand ) ) ;
n . setType ( Token.FOR ) ;
{ if ( n . isConst () ) { handleDeclarationList ( n , n . getParent () ) ; } n . setType ( Token.VAR ) ; }
declarationList . setType ( Token.VAR ) ;
parent . setType ( Token.ASSIGN ) ;
valueNode . getType ()
node . getType ()
n . getType () == Token.DIV && n . getFirstChild () . isNumber () && n . getFirstChild () . getDouble () == NUMBER_CONSTANT
parent . getType ()
parent . getType ()
parent . getType ()
value . getType ()
node . getType ()
parent . getType ()
n . getType ()
ancestor . getType ()
{ switch ( node . getType () ) { case GETTER_DEF : case SETTER_DEF : return true ; default: break; } return false ; }
switch ( key . getType () ) { case STRING_KEY : case GETTER_DEF : case SETTER_DEF : case MEMBER_FUNCTION_DEF : return key . getString () ; default: break; }
{ switch ( node . getType () ) { case STRING_KEY : case GETTER_DEF : case SETTER_DEF : case MEMBER_FUNCTION_DEF : return true ; default: break; } return false ; }
return parent != null && parent . getType () == Token.ASSIGN && parent . getFirstChild () == n ;
current . getType ()
{ switch ( parent . getType () ) { case DECLARE : case EXPORT : return true ; default: return isStatementParent ( parent ) ; } }
switch ( parent . getType () ) { case SCRIPT : case MODULE_BODY : case BLOCK : case LABEL : case NAMESPACE_ELEMENTS : return true ; default: return false ; }
n . getType ()
n . getType ()
n . getType ()
parent . getType ()
n . getType ()
n . getType ()
{ switch ( n . getType () ) { case FOR : case FOR_OF : case DO : case WHILE : return true ; default: return false ; } }
n . getParent () . getType ()
{ @ Override public boolean apply ( Node n ) { return n . getType () == type ; } }
n . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
switch ( n . getType () ) { case VOID : return true ; case NAME : return n . getString () . equals ( STRING_CONSTANT ) ; default: break; }
n . getType ()
n . getType ()
Preconditions . checkArgument ( callNode . isNew () , STRING_CONSTANT , callNode . getType () ) ;
n . getType ()
val . getType ()
n . getType ()
{ switch ( n . getType () ) { case GT : case GE : case LT : case LE : return true ; default: break; } return false ; }
switch ( n . getType () ) { case EQ : case NE : case SHEQ : case SHNE : case MUL : return true ; default: break; }
n . getType ()
parent . getType ()
parent . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
propdef . setType ( Token.STRING ) ;
name . getType ()
op . setType ( assignOp ) ;
n . getType ()
node . getType ()
n . setType ( TEMPLATE_LOCAL_NAME ) ;
n . setType ( TEMPLATE_TYPE_PARAM ) ;
{ currentProp . setType ( Token.STRING ) ; newProp = IR . getprop ( objectToExtend . cloneTree () , currentProp ) . srcref ( currentProp ) ; }
parent . getType ()
importedName . setType ( Token.NAME ) ;
key . setType ( Token.STRING_KEY ) ;
key . setType ( Token.SETTER_DEF ) ;
key . setType ( Token.GETTER_DEF ) ;
{ irNode . setType ( Token.BLOCK ) ; }
Token type = valueNode . getType () ;
n . getType ()
if ( canFoldStandardConstructors ( n ) ) { n . setType ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; reportCodeChange () ; }
member . setType ( Token.STRING_KEY ) ;
c . setType ( Token.VAR ) ;
Token pType = root . getParent () . getType () ;
Token parentType = parent . getType () ;
return DECLARATION_PARENTS . contains ( parent . getType () ) ;
parent . getType ()
{ switch ( n . getType () ) { case FOR : case FOR_OF : case DO : case WHILE : return true ; default: return false ; } }
n . getType ()
n . getType ()
{ for ( Token type : types ) { if ( c . getType () == type ) { return c ; } } }
n . getType ()
parent . getType ()
parent . getType ()
n . getType ()
{ Token inverseOperator = NodeUtil . getInverseOperator ( subtree . getToken () ) ; subtree . setType ( inverseOperator ) ; }
( n == jsRoot || n . isFunction () ) && comp . hasScopeChanged ( n )
private boolean taintsThis () { return getMask ( TAINTS_THIS_MASK ) ; }
private boolean taintsGlobalState () { return getMask ( TAINTS_GLOBAL_STATE_MASK ) ; }
private boolean pureFunction () { return getMask ( PURE_FUNCTION_MASK ) ; }
{ if ( node . isFunction () ) { visitFunction ( node , parent ) ; } return true ; }
Collection < Definition > defs = getCallableDefinitions ( definitionProvider , callSite . getFirstChild () ) ;
this . functionSideEffectMap = new HashMap <> () ;
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new MinimizeExitPoints ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new J2clConstantHoisterPass ( compiler , null ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clClinitPrunerPass ( compiler , null ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clEqualitySameRewriterPass ( compiler , null ) ; }
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , OPTIONAL_TYPE_NOT_USING_OPTIONAL_NAME ) ;
this . compiler = compiler ;
if ( ! compiler . getOptions () . useTypesForOptimization ) { return; }
final boolean useTypesForOptimization = compiler . getOptions () . useTypesForOptimization ;
@ Override protected CompilerOptions getOptions ( CompilerOptions options ) { options.useTypesForOptimization = true ; return super . getOptions ( options ) ; }
CompilerPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeFoldConstants ( late , compiler . getOptions () . useTypesForOptimization ) ) ;
{ CompilerOptions options = super . getOptions () ; options.useTypesForOptimization = useTypesForOptimization ; options . setJ2clPass ( CompilerOptions.J2clPassMode.ON ) ; return options ; }
compiler . getOptions () . useTypesForOptimization
boolean useTypesForOptimization = compiler . getOptions () . useTypesForOptimization ;
boolean shouldAmbiguateProperties () { return this . useTypesForOptimization || this . ambiguateProperties ; }
boolean shouldDisambiguateProperties () { return this . useTypesForOptimization || this . disambiguateProperties ; }
MockitoOperations . reportControlForStubbing ( null ) ;
control . replay () ;
control . replay () ;
{ control . verify () ; }
{ mock . simpleMethodWithArgument ( STRING_CONSTANT ) ; mock . simpleMethodWithArgument ( STRING_CONSTANT ) ; control . verify () ; }
MockitoOperations . reportControlForStubbing ( this ) ;
behavior . addInvocation ( invocation ) ;
public void addInvocation ( MockitoInvocation invocation ) { this . registeredInvocations . add ( invocation ) ; }
return proxyFactory . createProxy ( toMock , new ObjectMethodsFilter ( toMock , new MockInvocationHandler ( this ) , name ) ) ;
return proxyFactory . createProxy ( toMock , new ObjectMethodsFilter ( toMock , new MockInvocationHandler ( this ) , null ) ) ;
Field methodField = retrieveField ( ObjectMethodsFilter . class , correctMethod . getName () + STRING_CONSTANT ) ;
if ( returnedType . isPrimitive () ) { returnedType = ToTypeMappings.primitiveToWrapperType . get ( returnedType ) ; }
throw new AssertionErrorWrapper ( new AssertionError ( STRING_CONSTANT + actual . toString ( MockControl.EQUALS_MATCHER ) + STRING_CONSTANT + errorMessage . toString () ) ) ;
stub ( mock . oneArg ( Matchers . find ( STRING_CONSTANT ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , Matchers . not ( notNull () ) , eq ( STRING_CONSTANT ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , Matchers . not ( isNull () ) , eq ( STRING_CONSTANT ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( Matchers . or ( eq ( NUMBER_CONSTANT ) , eq ( NUMBER_CONSTANT ) ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( Matchers . cmpEq ( new BigDecimal ( STRING_CONSTANT ) ) ) ) . andReturn ( STRING_CONSTANT ) ;
assertThat ( new ExpectedInvocation ( invocation , null ) . hashCode () , equalTo ( NUMBER_CONSTANT ) ) ;
{ LastArguments . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportOr ( NUMBER_CONSTANT ) ; return first ; }
{ LastArguments . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportOr ( NUMBER_CONSTANT ) ; return null ; }
{ LastArguments . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . reportNot () ; return false ; }
{ LastArguments . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . reportNot () ; return first ; }
{ LastArguments . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . reportNot () ; return null ; }
{ LastArguments . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ LastArguments . reportMatcher ( new Find ( regex ) ) ; return null ; }
{ LastArguments . reportMatcher ( new StartsWith ( prefix ) ) ; return null ; }
{ LastArguments . reportMatcher ( new EndsWith ( suffix ) ) ; return null ; }
{ LastArguments . reportMatcher ( new Same ( value ) ) ; return null ; }
{ LastArguments . reportOr ( NUMBER_CONSTANT ) ; return false ; }
{ LastArguments . reportAnd ( NUMBER_CONSTANT ) ; return null ; }
{ LastArguments . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportAnd ( NUMBER_CONSTANT ) ; return false ; }
{ LastArguments . reportMatcher ( new Contains ( substring ) ) ; return null ; }
{ MockitoOperations . reportVerifyingMode ( VerifyingMode . times ( exactNumberOfInvocations ) ) ; return mock ; }
{ MockUtil . validateMock ( mock ) ; MockitoOperations . reportVerifyingMode ( VerifyingMode . anyTimes () ) ; return mock ; }
{ LastArguments . reportMatcher ( new EqualsWithDelta ( value , delta ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportMatcher ( new EqualsWithDelta ( value , delta ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportMatcher ( new Matches ( regex ) ) ; return null ; }
{ LastArguments . reportMatcher ( NotNull.NOT_NULL ) ; return null ; }
{ LastArguments . reportMatcher ( Null.NULL ) ; return null ; }
{ LastArguments . reportMatcher ( new Equals ( value ) ) ; return null ; }
{ LastArguments . reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ LastArguments . reportMatcher ( new Equals ( value ) ) ; return false ; }
{ LastArguments . reportMatcher ( new InstanceOf ( clazz ) ) ; return null ; }
{ LastArguments . reportMatcher ( Any.ANY ) ; return null ; }
public MethodSelector < T > toThrow ( Throwable throwable ) { MockitoOperations . reportThrowableToBeSetOnVoidMethod ( throwable ) ; return this ; }
public synchronized void verifyingStarted ( VerifyingMode verify ) { verifyingModeLocal . set ( verify ) ; }
MockitoExpectation controlToStub = MockitoState . instance () . controlToBeStubbed () ;
assertFalse ( state . mockVerificationScenario () ) ;
assertSame ( mode , mockitoState . verifyingCompleted () ) ;
public void setMock ( Object mock ) { this . mock = mock ; }
MockitoInvocation lastInvocation = behavior . lastInvocation () ;
MockitoInvocation invocation
MockitoInvocation invocation = registeredInvocation . getInvocation () ;
MockitoExpectation controlToStub = MockitoState . instance () . removeControlToBeStubbed () ;
assertNull ( MockitoState . instance () . removeControlToBeStubbed () ) ;
public void withBooleanVarargs ( int value , boolean . . . b ) ;
public MethodSelector < T > toThrow ( Throwable throwable ) { mockitoState . reportThrowableToBeSetOnVoidMethod ( throwable ) ; return this ; }
{ MockitoControl control = lastControl . get () ; lastControl . set ( null ) ; return control ; }
public MockAwareStub () { super ( Object . class , null , null ) ; }
catch ( MockVerificationAssertionError e ) {}
{ if ( exactNumberOfInvocations < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return new VerifyingMode ( exactNumberOfInvocations ) ; }
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( MockVerificationAssertionError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( MockVerificationAssertionError e ) {}
try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( MockVerificationAssertionError e ) {}
if ( mock == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockVerificationAssertionError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( MockVerificationAssertionError e ) {}
catch ( MockVerificationAssertionError e ) {}
public NumberOfInvocationsAssertionError ( int expectedInvoked , int actuallyInvoked ) { super ( STRING_CONSTANT + expectedInvoked + STRING_CONSTANT + actuallyInvoked ) ; }
MockVerificationAssertionError expected
MockVerificationAssertionError expected
MockVerificationAssertionError expected
MockVerificationAssertionError expected
try { Mockito . verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( MockVerificationAssertionError expected ) {}
try { Mockito . verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( MockVerificationAssertionError expected ) {}
try { Mockito . verify ( mock ) . clear () ; fail () ; } catch ( MockVerificationAssertionError expected ) {}
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
try { mockitoState . verifyingStarted ( VerifyingMode . anyTimes () ) ; fail () ; } catch ( UnfinishedVerificationException e ) {}
public NumberOfInvocationsAssertionError ( int expectedInvoked , int actuallyInvoked ) { super ( STRING_CONSTANT + expectedInvoked + STRING_CONSTANT + actuallyInvoked , new LastClassIsCglibEnchantedFilter () ) ; }
{ if ( actuallyInvoked == NUMBER_CONSTANT ) { throw VerificationAssertionError . createNotInvokedError ( STRING_CONSTANT + STRING_CONSTANT + invocation . toString () ) ; } }
{ verify ( mock ) ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( UnfinishedVerificationException e ) {} }
{ verify ( mock ) ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( UnfinishedVerificationException e ) {} }
try { verify ( mock ) . get ( NUMBER_CONSTANT ) ; fail () ; } catch ( UnfinishedVerificationException e ) {}
{ String expected = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; assertEquals ( expected , error . getMessage () ) ; }
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT ;
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT ;
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
{ message += STRING_CONSTANT + expected ; }
void simpleMethodWithArgument ( String argument ) ;
throw new VerificationAssertionError ( STRING_CONSTANT + verificationErrorMessage + STRING_CONSTANT + mockName + STRING_CONSTANT + registeredInvocation . toString () ) ;
{ mock . add ( STRING_CONSTANT ) ; }
try { reader . read () ; } catch ( Exception e ) { assertEquals ( ioException , e ) ; }
public InstanceOf ( Class clazz ) { this . clazz = clazz ; }
public static Object newInstance ( Class clazz ) throws InstantiationException { return ObjenesisHelper . newInstance ( clazz ) ; }
Class paramType
public static Object emptyReturnValueFor ( Class type ) { return emptyReturnValueToType . get ( type ) ; }
{ return Mockito . verify ( mock , exactNumberOfInvocations ) ; }
{ if ( this . isLastStackElementToRemove ( trace ) ) { lastToRemove = i ; break; } i ++ ; }
verify ( mock ) . oneArg ( two ) ;
verify ( map ) . put ( anyObject () , anyObject () ) ;
strictly . verify ( list ) . add ( STRING_CONSTANT ) ;
strictly . verify ( list ) . add ( STRING_CONSTANT ) ;
public boolean orderOfInvocationsMatters () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
state . verifyingStarted ( VerifyingMode . anyTimes () ) ;
{ verifyZeroInteractions ( mock ) ; }
{ verifyNoMoreInteractions ( mock ) ; }
{ verify ( mock ) . simpleMethod () ; }
strictly . verifyNoMoreInteractions () ;
assertThat ( mock , notNullValue () ) ;
assertThat ( superClass , equalTo ( ClassWithoutConstructor . class ) ) ;
assertThat ( superClass , equalTo ( Object . class ) ) ;
boolean invokedAtLeastOnce () { return expectedNumberOfInvocations == null ; }
Invocation lastInvocation = behavior . lastInvocation () ;
invocationWithMatchers . setSequenceNumber ( mockitoState . nextSequenceNumber () ) ;
assertThat ( new InvocationWithMatchers ( invocation , null ) . hashCode () , equalTo ( NUMBER_CONSTANT ) ) ;
InvocationWithMatchers invocation
InvocationWithMatchers expectedInvocation
InvocationWithMatchers expectedInvocation
InvocationWithMatchers expected
InvocationWithMatchers invocation
InvocationWithMatchers expected
InvocationWithMatchers expected
InvocationWithMatchers expected
InvocationWithMatchers expected
InvocationWithMatchers invocation
boolean shouldMarkAsVerified = verifyingMode . atLeastOnceMode () || verifyingMode . getExpectedNumberOfInvocations () >= verifiedSoFar ;
this . expectedNumberOfInvocations = expectedNumberOfInvocations ;
Invocation invocation = new Invocation ( null , m , args ) ;
List < InvocationChunk > chunks = getUnverifiedInvocationChunks ( mode ) ;
Invocation similarInvocation = findSimilarInvocation ( invocation ) ;
int actuallyInvoked = numberOfActualInvocations ( expected ) ;
int actualCount = numberOfActualInvocations ( expected ) ;
markInvocationsAsVerified ( expected , verifyingMode ) ;
{ assert invocationForStubbing != null ; registeredInvocations . remove ( invocationForStubbing . getInvocation () ) ; this . results . put ( invocationForStubbing , result ) ; }
registered . markInvocationsAsVerified ( new ExpectedInvocation ( toLowerCaseInvocation , EMPTY_LIST ) , VerifyingMode . times ( NUMBER_CONSTANT ) ) ;
public void markAllInvocationsAsVerified () { for ( Invocation invocation : invocations ) { invocation . markVerified () ; } }
if ( i . isVerified () ) { continue; }
strictly = strictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
{ return Mockito . verify ( mock , VerifyingMode . inOrder ( expectedNumberOfInvocations , mocksToBeVerifiedInOrder ) ) ; }
{ if ( mocks.length == NUMBER_CONSTANT ) { throw Exceptions . mocksHaveToBePassedAsArguments () ; } }
strictly = strictOrderVerifier ( mockOne , mockThree ) ;
List < InvocationChunk > chunks = registered . unverifiedInvocationChunks ( VerifyingMode . inOrder ( null , asList ( mock ) ) ) ;
registered . unverifiedInvocationChunks ( VerifyingMode . inOrder ( null , dummyMocks ) ) ;
ExpectedInvocation invocation = new ExpectedInvocation ( new InvocationBuilder () . toInvocation () , Collections.EMPTY_LIST ) ;
catch ( VerificationAssertionError e ) {}
catch ( StrictVerificationError expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( VerificationAssertionError expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( VerificationAssertionError expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( VerificationAssertionError expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationAssertionError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationError e ) {}
@ Test ( expected = StrictVerificationError . class )
@ Test ( expected = StrictVerificationError . class ) public void shouldFailWhenLastMethodCalledFirst () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerificationAssertionError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationAssertionError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . oneArg ( true ) ; fail () ; } catch ( StrictVerificationError e ) {}
catch ( StrictVerificationError e ) {}
@ Test ( expected = VerificationAssertionError . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodExpected () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = VerificationAssertionError . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsExpected () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationError e ) {}
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( VerificationAssertionError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationAssertionError e ) {}
try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( VerificationAssertionError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationAssertionError e ) {}
@ Test ( expected = VerificationAssertionError . class )
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationAssertionError e ) {}
catch ( VerificationAssertionError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationAssertionError e ) {}
catch ( VerificationAssertionError e ) {}
VerificationAssertionError expected
VerificationAssertionError expected
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationAssertionError expected ) {}
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationAssertionError expected ) {}
@ Test ( expected = VerificationAssertionError . class ) public void shouldFailVerification ( ) throws Exception { verify ( mock ) . clear () ; }
if ( ! atLeastOnce && actuallyInvoked != expectedInvoked ) { throw new NumberOfInvocationsAssertionError ( expectedInvoked , actuallyInvoked , expected ) ; }
try { strictly . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationError e ) {}
try { strictly . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationAssertionError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationAssertionError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsAssertionError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsAssertionError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsAssertionError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsAssertionError e ) {}
@ Test ( expected = NumberOfInvocationsAssertionError . class )
@ Test ( expected = NumberOfInvocationsAssertionError . class )
try { verify ( mock ) . clear () ; fail () ; } catch ( NumberOfInvocationsAssertionError e ) {}
try { Mockito . verify ( mock , NUMBER_CONSTANT ) . clear () ; fail () ; } catch ( NumberOfInvocationsAssertionError e ) {}
catch ( NumberOfInvocationsAssertionError e ) { assertTrue ( e . getMessage () . endsWith ( STRING_CONSTANT ) ) ; }
catch ( NumberOfInvocationsAssertionError e ) { assertTrue ( e . getMessage () . endsWith ( STRING_CONSTANT ) ) ; }
NumberOfInvocationsAssertionError e
NumberOfInvocationsAssertionError e
{ this . expected = value ; this . delta = delta ; }
return Mockito . verify ( mock , VerifyingMode . inOrder ( verifyingMode . expectedCount () , mocksToBeVerifiedInOrder ) ) ;
{ if ( actual == null ) { return false ; } return operator . matchResult ( comparator . compare ( ( T ) actual , expected ) ) ; }
< T > T verify ( T mock , int expectedNumberOfInvocations ) ;
return matchResult ( ( ( Comparable ) actual ) . compareTo ( expected ) ) ;
if ( mode . expectedCountIsZero () ) { return; }
{ appendQuoting ( buffer ) ; buffer . append ( expected ) ; appendQuoting ( buffer ) ; }
buffer . append ( expected ) ;
Integer wantedCount () { return wantedInvocationCount ; }
{ reportDiscrepancy ( wanted , chunks . get ( NUMBER_CONSTANT ) . getInvocation () , Exceptions.STRICT_DISCREPANCY ) ; }
if ( actual != null ) { reportDiscrepancy ( wanted , actual , Exceptions.REGULAR_DISCREPANCY ) ; } else { Exceptions . wantedButNotInvoked ( wanted . toString () ) ; }
if ( m . isBridge () ) { if ( m . getName () . equals ( methodName ) ) { System.out . println ( m ) ; return true ; } }
private void print ( BaseMessage message ) { mock . print ( message ) ; }
public void print ( String message ) ;
public void print ( Object message ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . andThrows ( new Exception () ) ; }
{ Strictly strictly = createStrictOrderVerifier ( mock ) ; strictly . verify ( mockTwo ) . clear () ; }
public synchronized void verifyingStarted ( VerifyingMode verify ) { checkForUnfinishedVerification () ; verifyingModeLocal . set ( verify ) ; }
MockitoState . instance () . checkForUnfinishedVerification () ;
MockitoState . instance () . checkForUnfinishedVerification () ;
if ( unverified != null ) { Exceptions . noMoreInteractionsWanted ( unverified , message ) ; }
{ assert invocationForStubbing != null ; registeredInvocations . removeLast () ; this . results . put ( invocationForStubbing , result ) ; }
new IAnswer < Object > () { public Object answer ( ) throws Throwable { throw throwable ; } }
void simpleMethod ( String argument ) ;
void simpleMethod ( int argument ) ;
boolean simpleMethod ( String argument ) ;
stub ( mock . oneArg ( CrazyMatchers . find ( STRING_CONSTANT ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , CrazyMatchers . not ( notNull () ) , eq ( STRING_CONSTANT ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , CrazyMatchers . not ( isNull () ) , eq ( STRING_CONSTANT ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( CrazyMatchers . or ( eq ( NUMBER_CONSTANT ) , eq ( NUMBER_CONSTANT ) ) ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( CrazyMatchers . cmpEq ( new BigDecimal ( STRING_CONSTANT ) ) ) ) . andReturn ( STRING_CONSTANT ) ;
@ Test @ Ignore public void shouldCorrectStateAfterDetectingInvalidity () {}
{ assert invocationForStubbing != null ; registeredInvocations . removeLast () ; results . put ( invocationForStubbing , result ) ; }
assertFalse ( call . equals ( newStringObjectShouldNotBeEqual ) ) ;
public void appendTo ( StringBuffer buffer ) { buffer . append ( STRING_CONSTANT + clazz . getName () + STRING_CONSTANT ) ; }
public void appendTo ( StringBuffer buffer ) { buffer . append ( STRING_CONSTANT + substring + STRING_CONSTANT ) ; }
public void appendTo ( StringBuffer buffer ) { buffer . append ( STRING_CONSTANT + wanted + STRING_CONSTANT + delta + STRING_CONSTANT ) ; }
StringBuffer buffer
public void appendTo ( StringBuffer buffer ) { buffer . append ( STRING_CONSTANT ) ; }
public void appendTo ( StringBuffer buffer ) { buffer . append ( STRING_CONSTANT ) ; }
StringBuffer buffer
public void appendTo ( StringBuffer buffer ) { buffer . append ( STRING_CONSTANT + prefix + STRING_CONSTANT ) ; }
StringBuffer buffer
StringBuffer buffer
StringBuffer result = new StringBuffer () ;
public void appendTo ( StringBuffer buffer ) { buffer . append ( STRING_CONSTANT + suffix + STRING_CONSTANT ) ; }
StringBuffer buffer
StringBuffer buffer
StringBuffer buffer
public void appendTo ( StringBuffer buffer ) { buffer . append ( STRING_CONSTANT ) ; }
public void appendTo ( StringBuffer buffer ) { buffer . append ( getName () + STRING_CONSTANT + wanted + STRING_CONSTANT ) ; }
void appendTo ( StringBuffer buffer ) ;
StringBuffer sb = new StringBuffer () ;
StringBuffer buffer
StringBuffer buffer
StringBuffer buffer
StringBuffer buffer
StringBuffer buffer
public static MockitoState instance () { return INSTANCE ; }
public static LastArguments instance () { return INSTANCE ; }
{ mockitoState . stubbingCompleted () ; validateThrowable ( throwable ) ; behavior . addResult ( Result . createThrowResult ( throwable ) ) ; }
{ mockitoState . stubbingCompleted () ; behavior . addResult ( Result . createReturnResult ( value ) ) ; }
public void verifyingStarted ( VerifyingMode verify ) { validateState () ; verifyingModeLocal = verify ; }
{ if ( ! toAssert ) { reset () ; throw new InvalidUseOfMatchersException ( message ) ; } }
{ verify ( mock ) . oneArray ( nullArray ) ; }
try { three . simpleMethod ( STRING_CONSTANT ) ; } catch ( RuntimeException e ) {}
{ map . put ( call , STRING_CONSTANT ) ; }
{ map . put ( call , STRING_CONSTANT ) ; fail () ; }
catch ( RuntimeException e ) { assertThat ( e , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( VerificationError expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( VerificationError expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( VerificationError expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
catch ( VerificationError expected ) { assertThat ( expected , firstMethodOnStackEqualsTo ( STRING_CONSTANT ) ) ; }
MockitoStackTraceFilter filter = new MockitoStackTraceFilter () ;
MockitoStackTraceFilter filter = new MockitoStackTraceFilter () ;
this . stackTrace = new MockitoException ( STRING_CONSTANT ) . getStackTrace () ;
MockitoStackTraceFilter filter = new MockitoStackTraceFilter () ;
catch ( VerificationError e ) { assertTrue ( e . getMessage () . contains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e . getCause () . getMessage () , contains ( STRING_CONSTANT ) ) ; }
Invocation actual = registeredInvocations . findSimilarInvocation ( wanted ) ;
catch ( NumberOfInvocationsError e ) {}
catch ( NumberOfInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
{ UndesiredInvocation cause = buildCause ( actualInvocationStackTrace , STRING_CONSTANT , undesired ) ; throw new VerificationError ( join ( STRING_CONSTANT ) , cause ) ; }
{ UndesiredInvocation cause = buildCause ( actualInvocationStackTrace , STRING_CONSTANT , undesired ) ; throw new VerificationError ( join ( STRING_CONSTANT ) , cause ) ; }
try { verify ( mock ) . clear () ; fail () ; } catch ( NumberOfInvocationsError e ) {}
catch ( NumberOfInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( NumberOfInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
NumberOfInvocationsError e
@ Test ( expected = NumberOfInvocationsError . class )
MockitoErrorTest . class
Exceptions . strictlyWantedInvocationDiffersFromActual ( wanted , actual ) ;
public MethodSelector < T > toThrow ( Throwable throwable ) { throwableToBeSetOnVoidMethod = throwable ; return this ; }
ExpectedInvocationTest . class
HasStackTrace firstUndesired = registered . getFirstUndesiredInvocationStackTrace ( new ExpectedInvocation ( simpleMethodInvocation ) , VerifyingMode . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = registered . getFirstUndesiredInvocationStackTrace ( new ExpectedInvocation ( simpleMethodInvocation ) , VerifyingMode . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = registered . getFirstUndesiredInvocationStackTrace ( new ExpectedInvocation ( simpleMethodInvocation ) , VerifyingMode . times ( NUMBER_CONSTANT ) ) ;
registered . markInvocationsAsVerified ( new ExpectedInvocation ( null ) , mode ) ;
registered . markInvocationsAsVerified ( new ExpectedInvocation ( simpleMethodInvocation ) , times ( NUMBER_CONSTANT ) ) ;
registered . markInvocationsAsVerified ( new ExpectedInvocation ( simpleMethodInvocation ) , atLeastOnce () ) ;
registered . markInvocationsAsVerified ( new ExpectedInvocation ( simpleMethodInvocation ) , times ( NUMBER_CONSTANT ) ) ;
registered . markInvocationsAsVerified ( new ExpectedInvocation ( simpleMethodInvocation ) , inOrder ( null , asList ( mock ) ) ) ;
ExpectedInvocation invocation
public void setInvocationForPotentialStubbing ( ExpectedInvocation invocation ) { this . invocationForStubbing = invocation ; }
ExpectedInvocation invocationWithMatchers
s . setInvocationForPotentialStubbing ( new InvocationBuilder () . toExpecteInvocation () ) ;
ExpectedInvocation wanted
ExpectedInvocation wanted
ExpectedInvocation wanted
ExpectedInvocation wanted
ExpectedInvocation expected
ExpectedInvocation wanted
ExpectedInvocation wantedInvocation
ExpectedInvocation wantedInvocation
ExpectedInvocation wanted
ExpectedInvocation wanted
ExpectedInvocation wanted
ExpectedInvocation wanted
public void addInvocation ( ExpectedInvocation invocation ) { this . registeredInvocations . add ( invocation . getInvocation () ) ; }
ToTypeMappingsTest . class
if ( verifyingMode != null ) { behavior . verify ( invocationWithMatchers , verifyingMode ) ; return ToTypeMappings . emptyReturnValueFor ( method . getReturnType () ) ; }
MockitoStateTest . class
MockitoState . instance () . validateState () ;
MockitoState . instance () . validateState () ;
{ MockUtil . validateMock ( mock ) ; MockitoState . instance () . verifyingStarted ( mode ) ; return mock ; }
{ MockitoState . instance () . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable ) ) ; }
{ MockitoState . instance () . stubbingCompleted () ; addResult ( Result . createReturnResult ( value ) ) ; }
assertNull ( MockitoState . instance () . pullControlToBeStubbed () ) ;
if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( StandardPieToolTipGenerator.DEFAULT_SECTION_LABEL_FORMAT ) ) ; }
if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( StandardPieToolTipGenerator.DEFAULT_SECTION_LABEL_FORMAT ) ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
timeline . setStartTime ( FIRST_MONDAY_AFTER_1900 + NUMBER_CONSTANT * timeline . getSegmentSize () ) ;
{ SegmentedTimeline timeline = new SegmentedTimeline ( DAY_SEGMENT_SIZE , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; timeline . setStartTime ( FIRST_MONDAY_AFTER_1900 ) ; return timeline ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
{ this ( time , RegularTimePeriod.DEFAULT_TIME_ZONE ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
if ( index < NUMBER_CONSTANT || index >= getDatasetCount () ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT || index >= getDatasetCount () ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT || index > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT || index > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
clone.seriesShapesVisible = ( BooleanList ) this . seriesLinesVisible . clone () ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
int pos = this . getIndex ( key ) ;
{ return this . rangeBounds ; }
g2 . setPaint ( Color.gray ) ;
if ( this . gapRadius != that.gapRadius ) { return false ; }
return true ;
return true ;
return true ;
return true ;
return true ;
return true ;
return true ;
MessageBox messageBox = new MessageBox ( canvas . getShell () , SWT.OK | SWT.ICON_ERROR ) ;
SWTChartEditor editor = new SWTChartEditor ( canvas . getDisplay () , this . chart ) ;
{ this . switchColors () ; gc . fillRectangle ( x , y , width , height ) ; this . switchColors () ; }
{ gc . drawLine ( x1 , y1 , x2 , y2 ) ; }
gc . setClipping ( clipPath ) ;
{ gc . setClipping ( x , y , width , height ) ; }
{ org.eclipse.swt.graphics.Rectangle clip = gc . getClipping () ; return new Rectangle ( clip.x , clip.y , clip.width , clip.height ) ; }
{ Path path = toSwtPath ( s ) ; gc . setClipping ( path ) ; path . dispose () ; }
{ org.eclipse.swt.graphics.Font swtFont = getSwtFontFromPool ( font ) ; gc . setFont ( swtFont ) ; }
gc . setForeground ( swtColor ) ;
public void setTransform ( AffineTransform Tx ) { gc . setTransform ( toSwtTransform ( Tx ) ) ; }
{ gc . drawImage ( image , x , y ) ; }
{ Path path = toSwtPath ( shape ) ; gc . drawPath ( path ) ; path . dispose () ; }
swtColor = SWTUtils . toSwtColor ( gc . getDevice () , awtColor ) ;
DialValueIndicator i1 = new DialValueIndicator ( NUMBER_CONSTANT , STRING_CONSTANT ) ;
DialValueIndicator i1 = new DialValueIndicator ( NUMBER_CONSTANT , STRING_CONSTANT ) ;
public DialPointer () { this ( NUMBER_CONSTANT ) ; }
this . dialFrame = new StandardDialFrame () ;
suite . addTestSuite ( StandardDialFrameTests . class ) ;
public Color getColor () { return myColor ; }
{ if ( this . myColor != null ) { myColor . dispose () ; } this . myColor = color ; }
e.gc . setBackground ( myColor ) ;
this . drawBarOutline = true ;
suite . addTestSuite ( XYSplineAndShapeRendererTests . class ) ;
suite . addTestSuite ( SimpleDialFrameTests . class ) ;
String name
String name
String name
{ axis . resizeRange ( factor ) ; }
if ( values != null ) { return Collections . unmodifiableList ( values ) ; } else { return null ; }
{ Object clone = ( PeriodAxisLabelInfo ) super . clone () ; return clone ; }
public Stroke getStroke () { return strokeCanvas . getStroke () ; }
public Color getOutlinePaint () { return outlinePaintCanvas . getColor () ; }
public Color getBackGroundPaint () { return backgroundPaintCanvas . getColor () ; }
{ return SWTUtils . toAwtFont ( getDisplay () , tickLabelFont , true ) ; }
if ( radius <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
if ( p == null ) return NUMBER_CONSTANT ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
{ CategoryPlot plot = ( CategoryPlot ) iterator . next () ; plot . setFixedDomainAxisSpace ( space ) ; }
{ CategoryPlot plot = ( CategoryPlot ) iterator . next () ; plot . setFixedRangeAxisSpace ( space ) ; }
this . canvas = new Canvas ( this , SWT.NO_BACKGROUND ) ;
notifyListeners ( new RendererChangeEvent ( this ) ) ;
if ( this . baseShapesVisible != flag ) { this . baseShapesVisible = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . legendItemToolTipGenerator = generator ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . baseToolTipGenerator = generator ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . toolTipGenerator = generator ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . baseItemLabelGenerator = generator ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . itemLabelGeneratorList . set ( series , generator ) ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . itemLabelGenerator = generator ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
notifyListeners ( new RendererChangeEvent ( this ) ) ;
try { s1 = new ComparableObjectSeries ( null ) ; } catch ( IllegalArgumentException e ) { pass = true ; }
{ this . legendItemURLGenerator = generator ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
if ( this . includeBaseInRange != include ) { this . includeBaseInRange = include ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . negativeItemLabelPositionFallback = position ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . positiveItemLabelPositionFallback = position ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . gradientPaintTransformer = transformer ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . minimumBarLength = min ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . maximumBarWidth = percent ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . drawBarOutline = draw ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . itemMargin = percent ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . base = base ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . useFillPaint = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . drawOutlines = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . useSeriesOffset = offset ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . stagger = shouldStagger ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . maxItemWidth = percent ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . renderAsPercentages = asPercentages ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . itemMargin = margin ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . fillBox = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . yOffset = yOffset ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . xOffset = xOffset ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . errorIndicatorStroke = stroke ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . useSeriesOffset = offset ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . useFillPaint = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . baseShapesFilled = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . seriesShapesFilled . setBoolean ( series , filled ) ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . shapesFilled = filled ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . useOutlinePaint = use ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . drawOutlines = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . baseShapesVisible = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . seriesShapesVisible . setBoolean ( series , flag ) ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . shapesVisible = visible ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . baseLinesVisible = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . seriesLinesVisible . setBoolean ( series , flag ) ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . linesVisible = visible ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . renderAsPercentages = asPercentages ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
notifyListeners ( new RendererChangeEvent ( this ) ) ;
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . errorIndicatorPaint = paint ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . renderAsPercentages = asPercentages ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
notifyListeners ( new RendererChangeEvent ( this ) ) ;
notifyListeners ( new RendererChangeEvent ( this ) ) ;
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . plotLines = draw ; this . notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . yOffset = yOffset ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . xOffset = xOffset ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . showOutline = show ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
notifyListeners ( new RendererChangeEvent ( this ) ) ;
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . closeTickPaint = paint ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . openTickPaint = paint ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . drawCloseTicks = draw ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . drawOpenTicks = draw ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . legendItemURLGenerator = generator ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . legendItemToolTipGenerator = generator ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . foregroundAnnotations . clear () ; this . backgroundAnnotations . clear () ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . baseToolTipGenerator = generator ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . toolTipGeneratorList . set ( series , generator ) ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . toolTipGenerator = generator ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . baseItemLabelGenerator = generator ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . itemLabelGeneratorList . set ( series , generator ) ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . itemLabelGenerator = generator ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . fillBox = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . boxPaint = paint ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
if ( width != this . boxWidth ) { this . boxWidth = width ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . useOutlinePaint = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . useFillPaint = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . drawOutlines = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . baseShapesFilled = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . seriesShapesFilled . setBoolean ( series , flag ) ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . shapesFilled = filled ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . baseShapesVisible = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . seriesShapesVisible . setBoolean ( series , flag ) ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . shapesVisible = visible ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . baseLinesVisible = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . seriesLinesVisible . setBoolean ( series , flag ) ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . linesVisible = visible ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . roundXCoordinates = round ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
notifyListeners ( new RendererChangeEvent ( this ) ) ;
if ( this . drawVolume != flag ) { this . drawVolume = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . downPaint = paint ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . upPaint = paint ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
if ( this . autoWidthFactor != autoWidthFactor ) { this . autoWidthFactor = autoWidthFactor ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . roundXCoordinates = round ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . shapesVisible = flag ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . showOutline = show ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . negativeItemLabelPositionFallback = position ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . positiveItemLabelPositionFallback = position ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . gradientPaintTransformer = transformer ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . drawBarOutline = draw ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . margin = margin ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
if ( this . useYInterval != use ) { this . useYInterval = use ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . base = base ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . capLength = length ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
if ( this . drawYError != draw ) { this . drawYError = draw ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . drawXError = draw ; this . notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ this . renderAsPercentages = asPercentages ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
notifyListeners ( new RendererChangeEvent ( this ) ) ;
{ this . showOutline = show ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
org.eclipse.swt.graphics.Image im = new org.eclipse.swt.graphics.Image ( this . gc . getDevice () , convertToSWT ( image ) ) ;
{ XYPlot plot = ( XYPlot ) iterator . next () ; plot . setFixedDomainAxisSpace ( space ) ; }
{ XYPlot plot = ( XYPlot ) iterator . next () ; plot . setFixedRangeAxisSpace ( space ) ; }
sb . append ( STRING_CONSTANT + name + STRING_CONSTANT + name + STRING_CONSTANT ) ;
BufferedImage image = new BufferedImage ( imageWidth , imageHeight , BufferedImage.TYPE_INT_RGB ) ;
{ return createBufferedImage ( width , height , BufferedImage.TYPE_INT_RGB , info ) ; }
{ return STRING_CONSTANT + ImageMapUtilities . htmlEscape ( urlText ) + STRING_CONSTANT ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
this . seriesToGroupMap . getGroupIndex ( this . seriesToGroupMap . getGroup ( plot . getDataset () . getRowKey ( row ) ) )
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
BufferedImage image = chart . createBufferedImage ( width , height , info ) ;
BufferedImage image = chart . createBufferedImage ( width , height , info ) ;
String key
double seriesGap = dataArea . getWidth () * getItemMargin () / ( categoryCount * ( seriesCount - NUMBER_CONSTANT ) ) ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
if ( this . showBase ) { result . append ( this . baseLabel ) ; result . append ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
{ this . anchorValue = value ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
{ this . drawSharedDomainAxis = draw ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . fixedRangeAxisSpace = space ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
{ this . fixedDomainAxisSpace = space ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
{ this . weight = weight ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . annotations . clear () ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( removed && notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . rangeCrosshairValue = value ; if ( isRangeCrosshairVisible () && notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
if ( this . rangeCrosshairLockedOnData != flag ) { this . rangeCrosshairLockedOnData = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . rangeCrosshairVisible != flag ) { this . rangeCrosshairVisible = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( removed && notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( removed && notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . fixedLegendItems = items ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . rangeGridlinesVisible != visible ) { this . rangeGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . domainGridlinesVisible != visible ) { this . domainGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . fixedLegendItems = items ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . fixedRangeAxisSpace = space ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
{ this . fixedDomainAxisSpace = space ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . rangeCrosshairValue = value ; if ( isRangeCrosshairVisible () && notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
if ( this . rangeCrosshairLockedOnData != flag ) { this . rangeCrosshairLockedOnData = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . rangeCrosshairVisible != flag ) { this . rangeCrosshairVisible = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . domainCrosshairValue = value ; if ( isDomainCrosshairVisible () && notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
if ( this . domainCrosshairLockedOnData != flag ) { this . domainCrosshairLockedOnData = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . domainCrosshairVisible != flag ) { this . domainCrosshairVisible = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . annotations . clear () ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( removed && notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( removed && notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( removed && notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . rangeTickBandPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . domainTickBandPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . rangeZeroBaselineVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . domainZeroBaselineVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . rangeGridlinesVisible != visible ) { this . rangeGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . domainGridlinesVisible != visible ) { this . domainGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . weight = weight ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( orientation != this . orientation ) { this . orientation = orientation ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . rangeGridlinesVisible != visible ) { this . rangeGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . domainGridlinesVisible != visible ) { this . domainGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . data = data ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . foregroundAlpha != alpha ) { this . foregroundAlpha = alpha ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . outlineVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . backgroundImageAlpha = alpha ; this . notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . backgroundImageAlignment != alignment ) { this . backgroundImageAlignment = alignment ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . backgroundImage = image ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . drawingSupplier = supplier ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . backgroundAlpha != alpha ) { this . backgroundAlpha = alpha ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . insets = insets ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . noDataMessage = message ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
public int getLength () { return NUMBER_CONSTANT ; }
suite . addTest ( HashCodeUtilsTest . suite () ) ;
if ( index == NUMBER_CONSTANT ) { return ( Throwable ) this . cause ; }
Throwable throwables [] = this . getThrowables () ;
Throwable nestedCause = cause . getCause () ;
{ this . cause = cause ; }
ArrayList list = new ArrayList () ;
{ return ExceptionUtils . indexOfThrowable ( this . cause , type , fromIndex ) ; }
{ return ExceptionUtils . getThrowables ( this . cause ) ; }
if ( index == NUMBER_CONSTANT ) { return this . cause ; }
Throwable nestedCause = ExceptionUtils . getCause ( this . cause ) ;
n = new NestableExceptionTester1 ( getThrowable ( msgs [ NUMBER_CONSTANT ] ) ) ;
public static Test suite () { return new TestSuite ( ANestableExceptionTestCase . class ) ; }
{ return new NestableRuntimeExceptionTester1 ( msg , ( Throwable ) n ) ; }
public static Test suite () { return new TestSuite ( NestableExceptionTestCase . class ) ; }
private RandomStringUtils () {}
public String getSummaryObjectEndText () { return summaryObjectEndText ; }
public String getSummaryObjectStartText () { return summaryObjectStartText ; }
public String getSizeEndText () { return sizeEndText ; }
public String getSizeStartText () { return sizeStartText ; }
public String getNullText () { return nullText ; }
public String getFieldSeparator () { return fieldSeparator ; }
public String getFieldNameValueSeparator () { return fieldNameValueSeparator ; }
public String getContentEnd () { return contentEnd ; }
public String getContentStart () { return contentStart ; }
public String getArraySeparator () { return arraySeparator ; }
public String getArrayEnd () { return arrayEnd ; }
public String getArrayStart () { return arrayStart ; }
public void setArrayContentDetail ( boolean arrayContentDetail ) { this . arrayContentDetail = arrayContentDetail ; }
public void setDefaultFullDetail ( boolean defaultFullDetail ) { this . defaultFullDetail = defaultFullDetail ; }
public void setUseFieldNames ( boolean useFieldNames ) { this . useFieldNames = useFieldNames ; }
public void setUseIdentityHashCode ( boolean useIdentityHashCode ) { this . useIdentityHashCode = useIdentityHashCode ; }
public void setShortClassName ( boolean shortClassName ) { this . useShortClassName = shortClassName ; }
public void setUseClassName ( boolean useClassName ) { this . useClassName = useClassName ; }
if ( style == null ) { style = ToStringStyle.DEFAULT_STYLE ; }
String linebreak = System . getProperty ( STRING_CONSTANT ) ;
if ( entry == null ) { return Collections.EMPTY_MAP ; }
catch ( ExceptionInInitializerError ex ) { assertTrue ( ex . getCause () instanceof IllegalArgumentException ) ; }
catch ( ExceptionInInitializerError ex ) { assertTrue ( ex . getCause () instanceof IllegalArgumentException ) ; }
catch ( ExceptionInInitializerError ex ) { assertTrue ( ex . getCause () instanceof IllegalArgumentException ) ; }
suite . addTest ( TestClosureUtils . suite () ) ;
public Number getMaximum () { return min ; }
{ if ( member == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return Modifier . isStatic ( member . getModifiers () ) ; }
! isAssignmentCompatible ( methodsParams [ n ] , parameterTypes [ n ] )
! ReflectionUtils . isCompatable ( parameterTypes [ n ] , methodsParams [ n ] )
methods [ i ] . getName () . equals ( methodName ) && ReflectionUtils . isCompatable ( paramTypes , methods [ i ] . getParameterTypes () )
catch ( NoSuchMethodException e ) {}
private DefaultToStringStyle () { super(); }
DefaultToStringStyle () { super(); }
{ try { TransformerUtils . switchMapTransformer ( Collections.EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { TransformerUtils . switchTransformer ( Collections.EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { ExecutorUtils . switchMapExecutor ( Collections.EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { ExecutorUtils . switchExecutor ( Collections.EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { TransformerUtils . switchMapTransformer ( EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { TransformerUtils . switchTransformer ( EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { ExecutorUtils . switchMapExecutor ( EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { ExecutorUtils . switchExecutor ( EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
this . clss = clss ;
Method method = getMatchingAccessibleMethod ( object . getClass () , methodName , parameterTypes ) ;
{ try { TransformerUtils . switchMapTransformer ( Collections.EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { TransformerUtils . switchTransformer ( Collections.EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { ExecutorUtils . switchMapExecutor ( Collections.EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { ExecutorUtils . switchExecutor ( Collections.EMPTY_MAP ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
buf . append ( ClassUtils . getShortClassName ( th ) ) ;
withoutCause = new ExceptionWithoutCause () ;
{ ByteArrayOutputStream baos = new ByteArrayOutputStream () ; serialize ( obj , baos ) ; return baos . toByteArray () ; }
return ( cls . getDeclaringClass () != null ) ;
String shortName = getClass () . getName () ;
String shortName = getClass () . getName () ;
{ frames . add ( STRING_CONSTANT + throwables [ i ] . toString () ) ; }
String shortName = Enum . getEnumClassName ( getClass () ) ;
Entry entry = ( Entry ) cEnumClasses . get ( Enum . getEnumClassName ( getClass () ) ) ;
private Null () {}
reverseArray ( strs ) ;
{ return join ( array , STRING_CONSTANT ) ; }
ArrayUtils . reverseArray ( strs ) ;
{ iso = ( Integer ) e2i . get ( entity ) ; }
{ return ( int ) Math . random () * n ; }
public long nextLong () { return ( long ) Math . random () * Long.MAX_VALUE ; }
{ return ( int ) Math . random () * n ; }
{ return random ( count , NUMBER_CONSTANT , set.length - NUMBER_CONSTANT , false , false , set ) ; }
public void printPartialStackTrace ( PrintWriter out ) {}
{ return ( String ) STRING_ALPHANUMERIC_IDENTIFIER_FACTORY . create () ; }
{ return ( String ) STRING_NUMERIC_IDENTIFIER_FACTORY . create () ; }
{ return ( Long ) LONG_IDENTIFIER_FACTORY . create () ; }
return ( cls . getName () . indexOf ( CHAR_CONS ) >= NUMBER_CONSTANT ) ;
int i = className . lastIndexOf ( CHAR_CONS ) ;
ToStringBuilder . isRegistered ( value ) && ! ( value instanceof Number || value instanceof Boolean || value instanceof Character )
assertTrue ( ToStringBuilder . getReflectionRegistry () . isEmpty () ) ;
end = ( int ) CHAR_CONS ;
if ( lastIdx == NUMBER_CONSTANT ) { return STRING_CONSTANT ; }
{ style . append ( buffer , fieldName , array , new Boolean ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , new Boolean ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , object , new Boolean ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , new Boolean ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , new Boolean ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , new Boolean ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , new Boolean ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , new Boolean ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , new Boolean ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , new Boolean ( fullDetail ) ) ; return this ; }
assertEquals ( STRING_CONSTANT , cal , DateUtils . trunc ( cal , Calendar.DATE ) , NUMBER_CONSTANT ) ;
Object array
Object array
public BinaryIntMap ( int growBy ) { super ( growBy ) ; }
{ return unescapeEntities ( str , Entities.XML ) ; }
{ return escapeEntities ( str , Entities.XML ) ; }
{ return unescapeEntities ( str , Entities.HTML40 ) ; }
{ return escapeEntities ( str , Entities.HTML40 ) ; }
{ entities . entityName ( html40value ( i ) ) ; }
{ buf . append ( STRING_CONSTANT ) ; char ch = html40value ( i ) ; buf . append ( ch ) ; }
if ( pads > PAD_LIMIT ) { return leftPad ( str , size , STRING_CONSTANT ) ; }
if ( pads > PAD_LIMIT ) { return rightPad ( str , size , STRING_CONSTANT ) ; }
assertEquals ( - NUMBER_CONSTANT , ArrayUtils . lastIndexOf ( array , STRING_CONSTANT ) ) ;
assertEquals ( - NUMBER_CONSTANT , ArrayUtils . indexOf ( array , STRING_CONSTANT ) ) ;
{ appendAsObjectToString ( buffer , value ) ; }
{ this . getStyle () . appendAsObjectToString ( this . getStringBuffer () , object ) ; return this ; }
assertEquals ( false , StringUtils . isNotEmptyTrimmed ( null ) ) ;
assertEquals ( true , StringUtils . isEmptyTrimmed ( null ) ) ;
assertEquals ( false , StringUtils . isNotEmpty ( null ) ) ;
assertEquals ( true , StringUtils . isEmpty ( null ) ) ;
if ( pads > PAD_LIMIT ) { return leftPad ( str , size , CHAR_CONS ) ; }
Field . setAccessible ( fields , true ) ;
try { SerializationUtils . deserialize ( ( byte [] ) null ) ; } catch ( NullPointerException ex ) { return; }
try { SerializationUtils . deserialize ( ( InputStream ) null ) ; } catch ( NullPointerException ex ) { return; }
try { SerializationUtils . serialize ( null , null ) ; } catch ( NullPointerException ex ) { return; }
try { SerializationUtils . serialize ( iMap , null ) ; } catch ( NullPointerException ex ) { return; }
if ( StringUtils . isEmptyOrNull ( className ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( StringUtils . isEmptyOrNull ( className ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( StringUtils . isEmptyOrNull ( className ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( StringUtils . isEmptyOrNull ( name ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
Field . setAccessible ( fields , true ) ;
Field . setAccessible ( fields , true ) ;
Field . setAccessible ( fields , true ) ;
try { method = interfaces [ i ] . getDeclaredMethod ( methodName , parameterTypes ) ; } catch ( NoSuchMethodException e ) { ; }
{ try { RandomUtils.JVM_RANDOM . setSeed ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( UnsupportedOperationException ex ) { ; } }
catch ( NumberFormatException ex ) { ; }
catch ( NumberFormatException ex ) { ; }
catch ( NumberFormatException ex ) { ; }
catch ( NumberFormatException ex ) { ; }
catch ( NumberFormatException ex ) { ; }
catch ( NumberFormatException ex ) { ; }
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = superHashCode ; return this ; }
{ rule = new StringLiteral ( new String ( sub ) ) ; }
{ iTotal = iTotal * iConstant + ( int ) value ; return this ; }
{ iTotal = iTotal * iConstant + ( int ) value ; return this ; }
{ iTotal = iTotal * iConstant + ( int ) value ; return this ; }
assertEquals ( ( int ) CHAR_CONS , Entities.XML . entityValue ( STRING_CONSTANT ) ) ;
String entityValue = Entities.iso8859_1 [ i % Entities.iso8859_1.length ] [ NUMBER_CONSTANT ] ;
String entityValue = Entities.html40 [ i % Entities.html40.length ] [ NUMBER_CONSTANT ] ;
{ if ( str == null ) { return null ; } return new BigDecimal ( str ) ; }
{ if ( str == null ) { return null ; } return new BigInteger ( str ) ; }
{ if ( str == null ) { return null ; } return Long . valueOf ( str ) ; }
{ if ( str == null ) { return null ; } return Integer . decode ( str ) ; }
{ if ( str == null ) { return null ; } return Double . valueOf ( str ) ; }
{ if ( str == null ) { return null ; } return Float . valueOf ( str ) ; }
{ if ( ! validateNumber ( str ) ) { return null ; } return new BigInteger ( str ) ; }
{ if ( ! validateNumber ( str ) ) { return null ; } return Long . valueOf ( str ) ; }
{ if ( ! validateNumber ( str ) ) { return null ; } return Integer . decode ( str ) ; }
{ if ( ! validateNumber ( str ) ) { return null ; } return Double . valueOf ( str ) ; }
{ if ( ! validateNumber ( str ) ) { return null ; } return Float . valueOf ( str ) ; }
assertEquals ( STRING_CONSTANT , f . nextStringIdentifier () ) ;
{ return random ( count , start , end , letters , numbers , null ) ; }
if ( out == null ) { throw new NullArgumentException ( STRING_CONSTANT ) ; }
if ( out == null ) { throw new NullArgumentException ( STRING_CONSTANT ) ; }
if ( objectData == null ) { throw new NullArgumentException ( STRING_CONSTANT ) ; }
if ( inputStream == null ) { throw new NullArgumentException ( STRING_CONSTANT ) ; }
if ( outputStream == null ) { throw new NullArgumentException ( STRING_CONSTANT ) ; }
if ( causeFrames == null || wrapperFrames == null ) { throw new NullArgumentException ( STRING_CONSTANT ) ; }
if ( writer == null ) { throw new NullArgumentException ( STRING_CONSTANT ) ; }
if ( stream == null ) { throw new NullArgumentException ( STRING_CONSTANT ) ; }
if ( array1 == null || array2 == null ) { throw new NullArgumentException ( STRING_CONSTANT ) ; }
{ Validate . notNull ( null ) ; }
{ Validate . isTrue ( false ) ; }
{ String shortName = ClassUtils . getShortClassName ( iEnumClass ) ; iToString = shortName + STRING_CONSTANT + getName () + STRING_CONSTANT ; }
return Collections . unmodifiableList ( entry.list ) ;
return Collections . unmodifiableMap ( entry.map ) ;
text = DateFormatUtils.ISO_DATETIME_TIMEZONE_FORMAT . format ( cal ) ;
{ return format ( date , pattern , DateUtils.UTC_TIMEZONE , locale ) ; }
{ return format ( new Date ( millis ) , pattern , DateUtils.UTC_TIMEZONE , locale ) ; }
{ return format ( date , pattern , DateUtils.UTC_TIMEZONE , null ) ; }
{ return format ( new Date ( millis ) , pattern , DateUtils.UTC_TIMEZONE , null ) ; }
if ( at == - NUMBER_CONSTANT ) { return STRING_CONSTANT ; }
{ return ( str == null ? STRING_CONSTANT : str ) ; }
if ( repeat <= NUMBER_CONSTANT ) { return STRING_CONSTANT ; }
if ( lastIdx <= NUMBER_CONSTANT ) { return STRING_CONSTANT ; }
if ( strLen < NUMBER_CONSTANT ) { return STRING_CONSTANT ; }
if ( idx != - NUMBER_CONSTANT ) { return str . substring ( NUMBER_CONSTANT , idx + sep . length () ) ; } else { return STRING_CONSTANT ; }
if ( idx != - NUMBER_CONSTANT ) { return str . substring ( idx ) ; } else { return STRING_CONSTANT ; }
if ( ch == CHAR_CONS || ch == CHAR_CONS ) { return STRING_CONSTANT ; } else { return str ; }
if ( overlay == null ) { overlay = STRING_CONSTANT ; }
if ( separator == null ) { separator = STRING_CONSTANT ; }
if ( separator . length () == NUMBER_CONSTANT ) { return STRING_CONSTANT ; }
if ( len < NUMBER_CONSTANT || pos > str . length () ) { return STRING_CONSTANT ; }
if ( len < NUMBER_CONSTANT ) { return STRING_CONSTANT ; }
if ( len < NUMBER_CONSTANT ) { return STRING_CONSTANT ; }
if ( start > end ) { return STRING_CONSTANT ; }
if ( start > str . length () ) { return STRING_CONSTANT ; }
{ return ( str == null ? STRING_CONSTANT : strip ( str , null ) ) ; }
{ return ( str == null ? STRING_CONSTANT : str . trim () ) ; }
{ return ( str == null ? STRING_CONSTANT : str . trim () ) ; }
{ try { Fraction . getFraction ( null ) ; } catch ( IllegalArgumentException ex ) {} }
int gcd = greatestCommonDenominator ( Math . abs ( numerator ) , denominator ) ;
int gcd = greatestCommonDenominator ( Math . abs ( numerator ) , denominator ) ;
assertEquals ( STRING_CONSTANT , STRING_CONSTANT , StringUtils . overlayString ( SENTENCE , FOO , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
int at = differenceAt ( str1 , str2 ) ;
{ int index = binarySearch ( value ) ; if ( index < NUMBER_CONSTANT ) return null ; return names [ index ] ; }
if ( insertAt > NUMBER_CONSTANT ) return;
if ( value == null ) return - NUMBER_CONSTANT ;
if ( value == null ) return - NUMBER_CONSTANT ;
if ( escapeSingleQuote ) out . write ( CHAR_CONS ) ;
{ return ReflectionToStringBuilder . toString ( object , style , outputTransients , reflectUpToClass ) ; }
{ return ReflectionToStringBuilder . toString ( object , style , outputTransients , null ) ; }
{ return toString ( object , style , outputTransients , null ) ; }
{ return toString ( object , style , false , null ) ; }
{ return toString ( object , null , false , null ) ; }
List list = ColorEnum . getEnumList () ;
{ flush () ; return ( ( StringWriter ) out ) . toString () ; }
if ( StringUtils . isEmpty ( str ) || StringUtils . isEmpty ( searchChars ) ) { return str ; }
if ( StringUtils . isEmpty ( str ) || StringUtils . isEmpty ( remove ) ) { return str ; }
if ( StringUtils . isEmpty ( str ) || StringUtils . isEmpty ( remove ) ) { return str ; }
if ( StringUtils . isEmpty ( str ) || StringUtils . isEmpty ( searchChars ) ) { return - NUMBER_CONSTANT ; }
if ( StringUtils . isEmpty ( str ) || searchChars == null || searchChars.length == NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; }
{ if ( isASCIINumeric ( ch ) == false ) { return defaultValue ; } return ( ch - NUMBER_CONSTANT ) ; }
if ( isASCIINumeric ( ch ) == false ) { throw new IllegalArgumentException ( STRING_CONSTANT + ch + STRING_CONSTANT ) ; }
{ if ( ch < NUMBER_CONSTANT ) { return CHAR_ARRAY [ ch ] ; } else { return new Character ( ch ) ; } }
{ super(); this . value = value ; }
{ super(); this . value = value ; }
{ return super . equals ( obj ) ; }
MutableNumber () { super(); }
{ super(); setValue ( value ) ; }
{ super(); this . value = value ; }
{ super(); this . value = value ; }
{ super(); this . value = value ; }
{ return this . value . equals ( obj ) ; }
public MutableNumber () { super(); }
{ super(); setValue ( new Long ( value ) ) ; }
public Object getValue () { return new Float ( this . value ) ; }
GregorianCalendar gval = new GregorianCalendar () ;
GregorianCalendar gval = new GregorianCalendar () ;
GregorianCalendar gval = new GregorianCalendar () ;
suite . addTest ( MutableIntegerTest . suite () ) ;
{ return split ( str , separatorChars , - NUMBER_CONSTANT ) ; }
final byte holder
final short holder
final int holder
final byte holder
final short holder
final int holder
final int holder
final int holder
final short holder
final int holder
final short holder
final int holder
final int mask
final Object array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final Object [] array
final boolean [] array
final Boolean [] array
final float [] array
final Float [] array
final double [] array
final Double [] array
final byte [] array
final Byte [] array
final short [] array
final Short [] array
final int [] array
final Integer [] array
final long [] array
final Long [] array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final Object [] array
final Object array
final Object array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final long [] array
final Object [] array
final Object [] array
final Object array
final Object array
public EqualsBuilder () { super(); isEquals = true ; }
{ addToken ( tokens , new String () ) ; }
{ this . value = value ; ; }
{ ++ nEntries ; markers . add ( marker ) ; sources . add ( source ) ; }
long splitTime = watch . getTime () ;
if ( tokenLen >= NUMBER_CONSTANT ) { rule = UnpaddedNumberField.INSTANCE_YEAR ; } else { rule = TwoDigitYearField.INSTANCE ; }
{ return format ( millis , format , true ) ; }
{ if ( throwables [ i ] . getClass () . equals ( type ) ) { return i ; } }
{ if ( throwables [ i ] . getClass () . equals ( type ) ) { return i ; } }
{ if ( type . isAssignableFrom ( throwables [ i ] . getClass () ) ) { return i ; } }
{ if ( type . isAssignableFrom ( throwables [ i ] . getClass () ) ) { return i ; } }
public Class getThrowableClass () { return RuntimeException . class ; }
{ return new RuntimeException ( msg ) ; }
public Class getThrowableClass () { return Error . class ; }
{ return new Error ( msg ) ; }
public Class getThrowableClass () { return Exception . class ; }
{ return new Exception ( msg ) ; }
newArray [ lastIndex ( newArray ) ] = element ;
newArray [ lastIndex ( newArray ) ] = element ;
newArray [ lastIndex ( newArray ) ] = element ;
newArray [ lastIndex ( newArray ) ] = element ;
newArray [ lastIndex ( newArray ) ] = element ;
newArray [ lastIndex ( newArray ) ] = element ;
newArray [ lastIndex ( newArray ) ] = element ;
newArray [ lastIndex ( newArray ) ] = element ;
{ super ( argName + STRING_CONSTANT ) ; }
{ return DurationFormatUtils . formatISO ( getSplitTime () ) ; }
public String toString () { return DurationFormatUtils . formatISO ( getTime () ) ; }
public DurationFormatUtils () {}
assertFalse ( STRING_CONSTANT , token . equals ( new DurationFormatUtils.Token ( new Object () , NUMBER_CONSTANT ) ) ) ;
{ if ( arrayStart == null ) { arrayStart = STRING_CONSTANT ; } this . arrayEnd = arrayEnd ; }
return ( Object [] ) add ( ( Object ) array , index , element , clss ) ;
{ return ( str == null ? defaultStr : str ) ; }
{ return ( str == null ? EMPTY : str ) ; }
{ return ( str == null ? EMPTY : str . trim () ) ; }
{ String ts = trim ( str ) ; return ( isEmpty ( ts ) ? null : ts ) ; }
{ return ( str == null ? null : str . trim () ) ; }
{ return ( str == null ? EMPTY : str . trim () ) ; }
{ return ( indexOf ( str , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ) ; }
{ super(); if ( initialCapacity <= NUMBER_CONSTANT ) { initialCapacity = NUMBER_CONSTANT ; } buf = new char [ initialCapacity ] ; }
{ return ( text [ pos ] <= NUMBER_CONSTANT ? NUMBER_CONSTANT : NUMBER_CONSTANT ) ; }
{ return ( ch == text [ pos ] ? NUMBER_CONSTANT : NUMBER_CONSTANT ) ; }
public int previousIndex () { return ( tokenPos - NUMBER_CONSTANT ) ; }
public boolean hasPrevious () { tokenize () ; return ( tokenPos > NUMBER_CONSTANT ) ; }
public boolean hasNext () { tokenize () ; return ( tokenPos < tokens.length ) ; }
{ if ( cls == null ) { return false ; } return ( cls . getName () . indexOf ( INNER_CLASS_SEPARATOR_CHAR ) >= NUMBER_CONSTANT ) ; }
{ return ( holder & _mask ) ; }
return ( min == range.min && max == range.max ) ;
{ return ( value >= min && value <= max ) ; }
{ return ( JAVA_VERSION_INT >= requiredVersion ) ; }
{ return ( JAVA_VERSION_FLOAT >= requiredVersion ) ; }
return ( set . equals ( other.set ) ) ;
return ( this . stopTime - this . startTime ) ;
{ if ( str == null || searchStr == null ) { return false ; } return ( str . indexOf ( searchStr ) >= NUMBER_CONSTANT ) ; }
{ if ( isEmpty ( str ) ) { return false ; } return ( str . indexOf ( searchChar ) >= NUMBER_CONSTANT ) ; }
return ( str . length () == NUMBER_CONSTANT ? null : str ) ;
{ return ( ch >= CHAR_CONS && ch <= CHAR_CONS ) ; }
{ return ( ch >= CHAR_CONS && ch <= CHAR_CONS ) ; }
{ return ( ch >= CHAR_CONS && ch <= CHAR_CONS ) ; }
{ return ( ch < NUMBER_CONSTANT || ch == NUMBER_CONSTANT ) ; }
{ return ( ch >= NUMBER_CONSTANT && ch < NUMBER_CONSTANT ) ; }
{ return ( ch < NUMBER_CONSTANT ) ; }
{ if ( isAsciiNumeric ( ch ) == false ) { return defaultValue ; } return ( ch - NUMBER_CONSTANT ) ; }
return ( ch - NUMBER_CONSTANT ) ;
{ return ( obj == null ? nullStr : obj . toString () ) ; }
{ return ( obj == null ? STRING_CONSTANT : obj . toString () ) ; }
{ return ( object != null ? object : defaultValue ) ; }
return ( date1 . getTime () == date2 . getTime () ) ;
public boolean nextBoolean () { return ( Math . random () > NUMBER_CONSTANT ) ; }
return ( min == range.min && max == range.max ) ;
{ return ( value >= min && value <= max ) ; }
public static boolean isThrowableNested () { return ( THROWABLE_CAUSE_METHOD != null ) ; }
{ return ( value >= min && value <= max ) ; }
return ( xor ( primitive ) ? Boolean.TRUE : Boolean.FALSE ) ;
{ return ( bool ? trueString : falseString ) ; }
{ if ( bool == null ) { return nullString ; } return ( bool . booleanValue () ? trueString : falseString ) ; }
{ if ( bool == null ) { return nullValue ; } return ( bool . booleanValue () ? trueValue : falseValue ) ; }
{ return ( bool ? trueValue : falseValue ) ; }
{ if ( bool == null ) { return nullValue ; } return ( bool . booleanValue () ? trueValue : falseValue ) ; }
{ return ( bool ? trueValue : falseValue ) ; }
{ if ( bool == null ) { return null ; } return ( bool . booleanValue () ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO ) ; }
{ return ( bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO ) ; }
{ return ( bool ? NUMBER_CONSTANT : NUMBER_CONSTANT ) ; }
{ if ( value == null ) { return null ; } return ( value . intValue () == NUMBER_CONSTANT ? Boolean.FALSE : Boolean.TRUE ) ; }
{ return ( value == NUMBER_CONSTANT ? Boolean.FALSE : Boolean.TRUE ) ; }
{ return ( value == NUMBER_CONSTANT ? false : true ) ; }
{ if ( bool == null ) { return valueIfNull ; } return ( bool . booleanValue () ? true : false ) ; }
{ if ( bool == null ) { return false ; } return ( bool . booleanValue () ? true : false ) ; }
{ return ( bool ? Boolean.TRUE : Boolean.FALSE ) ; }
{ if ( bool == null ) { return false ; } return ( bool . booleanValue () ? false : true ) ; }
{ if ( bool == null ) { return false ; } return ( bool . booleanValue () ? true : false ) ; }
return ( compareMin <= NUMBER_CONSTANT && compareMax >= NUMBER_CONSTANT ) ;
{ return ( indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ) ; }
{ return ( indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ) ; }
{ return ( indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ) ; }
{ return ( indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ) ; }
{ return ( indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ) ; }
{ return ( indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ) ; }
{ return ( indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ) ; }
{ return ( indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ) ; }
{ return ( indexOf ( array , objectToFind ) != - NUMBER_CONSTANT ) ; }
{ return ( value >= min && value <= max ) ; }
{ return ( value == null ? STRING_CONSTANT : value . toString () ) ; }
public int hashCode () { return ( value == null ? NUMBER_CONSTANT : value . hashCode () ) ; }
return ( compareMin <= NUMBER_CONSTANT && compareMax >= NUMBER_CONSTANT ) ;
return ( compareMin <= NUMBER_CONSTANT && compareMax >= NUMBER_CONSTANT ) ;
