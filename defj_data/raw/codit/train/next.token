{ super . setZoneRetainFields ( zone ) ; }
if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING_CONSTANT ) ) ; }
{ return getAsText ( null ) ; }
public abstract DurationField getLeapDurationField ( ) ;
public abstract boolean isSupported ( ) ;
DateTime result = new DateTime ( test . resolve ( dt . getMillis () , DateTimeZone.UTC ) ) ;
{ super ( instant ) ; }
{ super ( chronology ) ; }
public TimeOfDay () { super(); }
iInstantConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , PartialInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
iInstantConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
return ( getMillis () < readableInstant . getMillis () ) ;
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
public abstract int getMaximumValue ( ReadablePartial instant ) ;
ReadablePartial instant
public abstract int getMinimumValue ( ReadablePartial instant ) ;
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial partial
ReadablePartial partial
ReadablePartial partial
ReadablePartial partial
ReadablePartial instant
public DateTimeField getField () { return iTimeOfDay . getField ( iFieldIndex ) ; }
public DateTimeField getField () { return iYearMonthDay . getField ( iFieldIndex ) ; }
{ test1 . dayOfMonth () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . dayOfMonth () . getReadablePartial () ) ;
{ test1 . monthOfYear () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . monthOfYear () . getReadablePartial () ) ;
{ test1 . year () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . year () . getReadablePartial () ) ;
assertEquals ( false , test1 . equals ( MockPartial.EMPTY_INSTANCE ) ) ;
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
public int getMinimumValue ( ReadablePartial instant ) { return NUMBER_CONSTANT ; }
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial partial
ReadablePartial partial
{ return getField () . getMaximumValue ( getReadablePartial () ) ; }
{ return getField () . getMinimumValue ( getReadablePartial () ) ; }
{ return getField () . getAsShortText ( getReadablePartial () , get () , locale ) ; }
{ return getField () . getAsText ( getReadablePartial () , get () , locale ) ; }
ReadablePartial instant
public int getMaximumValue ( ReadablePartial instant ) { throw unsupported () ; }
ReadablePartial instant
public int getMinimumValue ( ReadablePartial instant ) { throw unsupported () ; }
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial partial
ReadablePartial partial
void validate ( ReadablePartial instant ) ;
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
public int getMaximumValue ( ReadablePartial instant , int [] values ) { return iField . getMaximumValue ( instant , values ) ; }
public int getMaximumValue ( ReadablePartial instant ) { return iField . getMaximumValue ( instant ) ; }
public int getMinimumValue ( ReadablePartial instant , int [] values ) { return iField . getMinimumValue ( instant , values ) ; }
public int getMinimumValue ( ReadablePartial instant ) { return iField . getMinimumValue ( instant ) ; }
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
public String getAsShortText ( ReadablePartial partial , Locale locale ) { return iField . getAsShortText ( partial , locale ) ; }
ReadablePartial partial
public String getAsText ( ReadablePartial partial , Locale locale ) { return iField . getAsText ( partial , locale ) ; }
ReadablePartial partial
{ test1 . millisOfSecond () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . millisOfSecond () . getReadablePartial () ) ;
{ test1 . secondOfMinute () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . secondOfMinute () . getReadablePartial () ) ;
{ test1 . minuteOfHour () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . minuteOfHour () . getReadablePartial () ) ;
{ test1 . hourOfDay () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . hourOfDay () . getReadablePartial () ) ;
assertEquals ( false , test1 . equals ( MockPartial.EMPTY_INSTANCE ) ) ;
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
{ t = new DateTimeFormatterBuilder ( iChrono ) . append ( hourMinuteSecondMillis () ) . append ( offsetElement () ) . toFormatter () ; }
iChronology = selectChronology ( converter . getChronology ( instant , chronology ) ) ;
iChronology = selectChronology ( converter . getChronology ( instant , zone ) ) ;
iChronology = selectChronology ( converter . getChronology ( instant ) ) ;
{ return DurationType . getMillisType () ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField millis () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField seconds () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField minutes () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField hours () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField days () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField weeks () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField months () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField years () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public abstract boolean isSupported ( ) ;
{ return getField () . remainder ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMaximumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMinimumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getLeapAmount ( getReadableInstant () . getMillis () ) ; }
{ return getField () . isLeap ( getReadableInstant () . getMillis () ) ; }
return getField () . getDifferenceAsLong ( getReadableInstant () . getMillis () , instant . getMillis () ) ;
return getField () . getDifference ( getReadableInstant () . getMillis () , instant . getMillis () ) ;
{ return getField () . getAsShortText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . getAsText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . get ( getReadableInstant () . getMillis () ) ; }
assertSame ( test , test . dayOfMonth () . getReadableInstant () ) ;
assertSame ( test , test . monthOfYear () . getReadableInstant () ) ;
assertSame ( test , test . year () . getReadableInstant () ) ;
assertSame ( test , test . yearOfCentury () . getReadableInstant () ) ;
assertSame ( test , test . centuryOfEra () . getReadableInstant () ) ;
assertSame ( test , test . yearOfEra () . getReadableInstant () ) ;
assertSame ( test , test . era () . getReadableInstant () ) ;
try { iChrono . era () . addWrapField ( SMALL_MILLIS , NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
iMillis = round ( converter . getInstantMillis ( instant , chronology ) , iChronology ) ;
iMillis = round ( converter . getInstantMillis ( instant , zone ) , iChronology ) ;
iMillis = round ( converter . getInstantMillis ( instant ) , iChronology ) ;
{ super(); iChronology = selectChronology ( chronology ) ; iMillis = round ( instant , iChronology ) ; }
{ setMillis ( instant ) ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
NullConverter.INSTANCE . setInto ( m , null ) ;
withUTC () . dayOfYear () . remainder ( iCutoverMillis ) == NUMBER_CONSTANT
{ long instant = getChronology () . getDateTimeMillis ( getMillis () , hour , minuteOfHour , secondOfMinute , millisOfSecond ) ; setMillis ( instant ) ; }
return getDateMidnightMillis ( year , monthOfYear , dayOfMonth ) + millisOfDay ;
assertEquals ( false , zone5 . equals ( zone4 ) ) ;
private DateTimeUtils () { super(); }
protected DateTimeUtils () { super(); }
int size () { return iConverters.length ; }
catch ( IllegalStateException ex ) {}
assertTrue ( set != result ) ;
assertEquals ( ( NUMBER_CONSTANT - NUMBER_CONSTANT ) * DateTimeConstants.MILLIS_PER_DAY , test . monthOfYear () . remainder () ) ;
MutableDuration duration = new MutableDuration ( NUMBER_CONSTANT , type ) ;
public String toString () { return STRING_CONSTANT ; }
{ if ( chrono == getChronology () ) { return this ; } return MaskedType . mask ( iType . withChronology ( chrono ) , iMask ) ; }
{ if ( chrono == iChronology ) { return this ; } return DurationType . getYearWeekType ( chrono ) ; }
{ if ( chrono == iChronology ) { return this ; } return DurationType . getYearMonthType ( chrono ) ; }
{ if ( chrono == iChronology ) { return this ; } return DurationType . getAllType ( chrono ) ; }
{ if ( chrono == iChronology ) { return this ; } return DurationType . getAverageYearMonthType ( chrono ) ; }
if ( isPrecise () ) { return FieldUtils . safeAdd ( instant , getTotalMillis () * scalar ) ; }
MutableDuration test = new MutableDuration ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
{ assertEquals ( NUMBER_CONSTANT , Duration.ZERO . getTotalMillis () ) ; assertEquals ( DurationType . getAllType () , Duration.ZERO . getDurationType () ) ; }
YearMonthType ( Chronology chrono ) { super ( chrono ) ; }
YearWeekType ( Chronology chrono ) { super ( chrono ) ; }
public void testGetDurationType_Object ( ) throws Exception { assertEquals ( null , NullConverter.INSTANCE . getDurationType ( null ) ) ; }
{ duration = duration . withDurationTypeUsingTotalMillis ( type ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( duration , type , false ) ; }
{ super ( duration , null , false ) ; }
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( duration , type , false ) ; }
{ super ( duration , null , false ) ; }
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
{ MutableDuration test = new MutableDuration () ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
{ convId = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return fixedOffsetZone ( convId , offset ) ; }
{ id = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return fixedOffsetZone ( id , offset ) ; }
assertEquals ( false , test1 . equals ( new Duration ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
type = ( type == null ? converter . getDurationType ( duration , totalMillisMaster ) : type ) ;
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getYearWeekType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getYearMonthType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getAllType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getDayHourType () ; }
assertEquals ( type , type . withChronology ( ISOChronology . getInstance () ) ) ;
assertEquals ( ISOChronology . getInstanceUTC () , type . getChronology () ) ;
assertEquals ( false , test1 . equals ( new Duration ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
ReadWritableTimePeriod duration
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
{ return ( ( ReadableDuration ) object ) . getMillis () ; }
{ return true ; }
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ;
{ TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
public void setInto ( ReadWritableTimePeriod duration , Object object ) {}
public void setInto ( ReadWritableTimePeriod duration , Object object ) {}
public void setInto ( ReadWritableTimePeriod duration , Object object ) {}
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( DurationType . getMillisType () ) ) ;
TimePeriod test = new TimePeriod ( STRING_CONSTANT ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( length , null ) ;
TimePeriod test = new TimePeriod ( length ) ;
TimePeriod test = TimePeriod.ZERO ;
MutableTimePeriod test = new MutableTimePeriod ( STRING_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( length , null ) ;
MutableTimePeriod test = new MutableTimePeriod ( length ) ;
{ try { new MutableTimePeriod ( DurationType . getAllType () , true ) ; fail () ; } catch ( IllegalArgumentException ex ) {} }
MutableTimePeriod test = new MutableTimePeriod ( null , false ) ;
MutableTimePeriod test = new MutableTimePeriod ( null , true ) ;
MutableTimePeriod test = new MutableTimePeriod () ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod () ;
{ MutableTimePeriod test = new MutableTimePeriod () ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
{ DurationConverter [] array = ConverterManager . getInstance () . getDurationConverters () ; assertEquals ( DURATION_SIZE , array.length ) ; }
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , m . toDurationMillis () ) ;
assertEquals ( NUMBER_CONSTANT , m . toDurationMillis () ) ;
{ add ( new TimePeriod ( duration , getDurationType () ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () , getDurationType () ) ) ; } }
suite . addTest ( TestPeriodType . suite () ) ;
{ add ( new TimePeriod ( duration , getPeriodType () ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () , getPeriodType () ) ) ; } }
{ if ( interval != null ) { add ( interval . toTimePeriod ( getPeriodType () ) ) ; } }
final PeriodType type = iType ;
PeriodType type
PeriodType type
PeriodType type
PeriodType type
int hash = getPeriodType () . hashCode () ;
PeriodType type = iType ;
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getMillisType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getYearMonthType () ) ;
PeriodType type = period . getPeriodType () ;
PeriodType type
if ( ! mustParse && ! isSupported ( period . getPeriodType () ) ) { return position ; }
PeriodType type
PeriodType type
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
TimePeriodConverter c = ConverterManager . getInstance () . getTimePeriodConverter ( new TimePeriod ( PeriodType . getMillisType () ) ) ;
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( PeriodType . getMillisType () ) ) ;
{ return new TimePeriod ( toDurationMillis () , getPeriodType () ) ; }
PeriodType type
PeriodType type
PeriodType type
PeriodType type
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
test . add ( new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseAllType () ) ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearWeekType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearWeekType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
PeriodType type
PeriodType type
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getMillisType () ) ;
public TestPeriodType ( String name ) { super ( name ) ; }
assertEquals ( test . getPeriodType () , copy . getPeriodType () ) ;
assertEquals ( test . getPeriodType () , copy . getPeriodType () ) ;
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
MillisDuration base = new MillisDuration ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getDayHourType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
PeriodType type
PeriodType type
PeriodType type
PeriodType type
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getMillisType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getYearMonthType () ) ;
if ( pos < NUMBER_CONSTANT ) { parser . parseMutableTimePeriod ( period . getPeriodType () , str ) ; }
ReadablePeriod period
ReadablePeriod period
public void testSetDuration_RD () { setPeriod ( ( ReadableDuration ) null ) ; }
Period test = new Period ( NUMBER_CONSTANT ) ;
Period test = new Period ( NUMBER_CONSTANT ) ;
{ Period test = new Period ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
MutablePeriod result = test . toMutableTimePeriod () ;
c = ConverterManager . getInstance () . getDurationConverter ( new Period ( PeriodType . getMillisType () ) ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
ReadablePeriod period
ReadablePeriod period
Period duration ;
{ return STRING_CONSTANT + iInstantConverters . size () + STRING_CONSTANT + iDurationConverters . size () + STRING_CONSTANT + iPeriodConverters . size () + STRING_CONSTANT + iIntervalConverters . size () + STRING_CONSTANT ; }
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod () ;
{ MutablePeriod test = new MutablePeriod () ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
Period test = new Period ( STRING_CONSTANT ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( length , null ) ;
Period test = new Period ( length ) ;
Period test = new Period ( length ) ;
MutablePeriod test = new MutablePeriod ( STRING_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( length , null ) ;
MutablePeriod test = new MutablePeriod ( length ) ;
MutablePeriod test = new MutablePeriod ( length ) ;
MutablePeriod test = new MutablePeriod () ;
Class cls = ReadablePeriodConverter . class ;
ReadablePeriod period
ReadablePeriod period
public void testSetPeriod_2 () { setPeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testSetPeriod_1 () { setPeriod ( NUMBER_CONSTANT ) ; }
public void testSetDuration_RD_1 () { setDuration ( null ) ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
{ if ( chrono == iChronology ) { return this ; } return PeriodType . getYearDayType ( chrono ) ; }
{ return PRECISE_ALL ; }
{ return PRECISE_YEAR_WEEK ; }
{ return PRECISE_YEAR_MONTH ; }
public static PeriodType getPreciseYearDayType () { return PRECISE_YEAR_DAY ; }
public static PeriodType getPreciseDayHourType () { return PRECISE_DAY_HOUR ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearWeekTypeUTC () ; }
{ return YEAR_WEEK ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearMonthTypeUTC () ; }
{ return YEAR_MONTH ; }
public static PeriodType getYearDayType () { return YEAR_DAY ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getAllTypeUTC () ; }
{ return ALL ; }
public static PeriodType getMillisType () { return MILLIS ; }
public Duration ( long duration ) { super(); iMillis = duration ; }
protected AbstractDuration () { super(); }
{ long durationMillis = DateTimeUtils . getDurationMillis ( duration ) ; setStartMillis ( FieldUtils . safeAdd ( getEndMillis () , - durationMillis ) ) ; }
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
Object duration
public Duration ( long duration ) { super ( duration ) ; }
{ long endMillis = DateTimeUtils . getInstantMillis ( end ) ; setEndMillis ( endMillis ) ; }
{ long startMillis = DateTimeUtils . getInstantMillis ( start ) ; setStartMillis ( startMillis ) ; }
{ super . setStartMillis ( startInstant ) ; }
public void normalize () { setPeriod ( toDurationMillis () ) ; }
{ return new MutableDateTime ( getMillis () , chronology ) ; }
public MutableDateTime toMutableDateTime () { return new MutableDateTime ( getMillis () ) ; }
{ long instant = getChronology () . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; setMillis ( instant ) ; }
{ super ( partial , values ) ; }
{ super ( partial , values ) ; }
{ Chronology chrono = getChronology () . withZone ( zone ) ; return resolve ( baseInstant , chrono ) ; }
BaseGJChronology chronology
GJWeekyearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
BaseGJChronology chronology
GJYearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
BaseGJChronology chronology
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
BaseGJChronology chronology
GJMonthOfYearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
BaseGJChronology chronology
NoWeekyearZeroField ( BaseGJChronology chronology , DateTimeField field ) { super ( chronology , field ) ; }
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chrono = iChronology ;
CopticYearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public static TestSuite suite () { return new TestSuite ( TestDateTimeConstants . class ) ; }
public static TestSuite suite () { return new TestSuite ( TestParseISO . class ) ; }
{ millis = getField ( i , chrono ) . set ( millis , getValue ( i ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendSuffix ( new SimpleAffix ( text ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendPrefix ( new SimpleAffix ( text ) ) ; }
PeriodFieldAffix affix ;
PeriodFieldAffix affix ;
PeriodFieldAffix affix ;
PeriodFieldAffix suffix
int scan ( String periodStr , int position ) ;
int parse ( String periodStr , int position ) ;
PeriodFieldAffix suffix
PeriodFieldAffix prefix
{ if ( iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue ( period ) != Long.MAX_VALUE ) { return NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
public PeriodFormatterBuilder appendMillis () { appendField ( MILLIS ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithOptionalMillis () { appendField ( SECONDS_OPTIONAL_MILLIS ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithMillis () { appendField ( SECONDS_MILLIS ) ; return this ; }
public PeriodFormatterBuilder appendSeconds () { appendField ( SECONDS ) ; return this ; }
public PeriodFormatterBuilder appendMinutes () { appendField ( MINUTES ) ; return this ; }
public PeriodFormatterBuilder appendHours () { appendField ( HOURS ) ; return this ; }
public PeriodFormatterBuilder appendDays () { appendField ( DAYS ) ; return this ; }
public PeriodFormatterBuilder appendWeeks () { appendField ( WEEKS ) ; return this ; }
public PeriodFormatterBuilder appendMonths () { appendField ( MONTHS ) ; return this ; }
public PeriodFormatterBuilder appendYears () { appendField ( YEARS ) ; return this ; }
DateTimeComparator c = DateTimeComparator . getInstance ( DateTimeFieldType . hourOfDay () , DateTimeFieldType . dayOfYear () ) ;
DateTimeFieldType lowerLimit
public static DateTimeComparator getInstance () { return ALL_INSTANCE ; }
public DateTimeField era () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . era () , eras () ) ; }
public DateTimeField centuryOfEra () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . centuryOfEra () , centuries () ) ; }
public DateTimeField yearOfCentury () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . yearOfCentury () , years () ) ; }
public DateTimeField yearOfEra () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . yearOfEra () , years () ) ; }
public DateTimeField year () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . year () , years () ) ; }
public DateTimeField monthOfYear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . monthOfYear () , months () ) ; }
public DateTimeField weekyear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . weekyear () , weekyears () ) ; }
public DateTimeField weekOfWeekyear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . weekOfWeekyear () , weeks () ) ; }
public DateTimeField dayOfYear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . dayOfYear () , days () ) ; }
public DateTimeField dayOfMonth () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . dayOfMonth () , days () ) ; }
{ return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . dayOfWeek () , days () ) ; }
{ return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . halfdayOfDay () , UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ) ; }
public DateTimeField clockhourOfHalfday () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . clockhourOfHalfday () , hours () ) ; }
public DateTimeField hourOfHalfday () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . hourOfHalfday () , hours () ) ; }
public DateTimeField clockhourOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . clockhourOfDay () , hours () ) ; }
public DateTimeField hourOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . hourOfDay () , hours () ) ; }
public DateTimeField minuteOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . minuteOfDay () , minutes () ) ; }
public DateTimeField minuteOfHour () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . minuteOfHour () , minutes () ) ; }
public DateTimeField secondOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . secondOfDay () , seconds () ) ; }
public DateTimeField secondOfMinute () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . secondOfMinute () , seconds () ) ; }
public DateTimeField millisOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . millisOfDay () , millis () ) ; }
public DateTimeField millisOfSecond () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . millisOfSecond () , millis () ) ; }
{ super ( DateTimeFieldType . dayOfMonth () , days ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( yearField , DateTimeFieldType . yearOfEra () ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
if ( iParseField == null ) { iParseField = new PreciseDateTimeField ( DateTimeFieldType . millisOfSecond () , MillisDurationField.INSTANCE , iField . getDurationField () ) ; }
{ super ( DateTimeFieldType . dayOfYear () , days ) ; iChronology = chronology ; }
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( DateTimeFieldType . era () ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chrono . millisPerMonth () , chrono ) ; }
public TestGJYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . year () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . weekOfWeekyear () , weeks ) ; iChronology = chronology ; }
{ super ( field , field . getType () ) ; iDurationField = durationField ; iRangeDurationField = rangeDurationField ; iLeapDurationField = leapDurationField ; }
private ISOYearOfEraDateTimeField () { super ( GregorianChronology . getInstanceUTC () . year () , DateTimeFieldType . yearOfEra () ) ; }
{ super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
super ( gregorianField . getType () ) ;
{ super ( DateTimeFieldType . dayOfWeek () , days ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . monthOfYear () , months ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . dayOfMonth () , days ) ; iChronology = chronology ; }
super ( field . getType () ) ;
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , chrono.MILLIS_PER_DAY , chrono ) ; }
{ return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . halfdayOfDay () , halfdays () ) ; }
{ super ( DateTimeFieldType . weekyear () , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . year () , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , chrono.MILLIS_PER_DAY , chrono ) ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . monthOfYear () , chrono . millisPerMonth () , chrono ) ; }
fields.centuryOfEra = new DividedDateTimeField ( ISOYearOfEraDateTimeField.INSTANCE , DateTimeFieldType . centuryOfEra () , NUMBER_CONSTANT ) ;
public TestGJYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . year () , chrono . millisPerYear () , chrono ) ; }
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . weekyear () , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . monthOfYear () , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , NUMBER_CONSTANT ) ;
LinkedDurationField ( DurationField durationField , ImpreciseCutoverField dateTimeField ) { super ( durationField , durationField . getType () ) ; iField = dateTimeField ; }
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , chrono.MILLIS_PER_DAY , chrono ) ; }
public String toString () { return STRING_CONSTANT + getName () + CHAR_CONS ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , NUMBER_CONSTANT ) ;
super ( field . getType () ) ;
{ super ( DateTimeFieldType . year () , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . millis () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . seconds () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . minutes () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . hours () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . days () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . weeks () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . months () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . years () ) ; }
{ super ( chrono ) ; iMonths = new ScaledDurationField ( chrono . days () , DurationFieldType . months () , NUMBER_CONSTANT ) ; }
{ super ( chrono ) ; iYears = new ScaledDurationField ( chrono . days () , DurationFieldType . years () , NUMBER_CONSTANT ) ; }
partial . isSupported ( iField . getType () )
partial . isSupported ( iField . getType () )
partial . isSupported ( iField . getType () )
{ return getAsShortText ( partial , partial . get ( getType () ) , locale ) ; }
{ return getAsText ( partial , partial . get ( getType () ) , locale ) ; }
public int size () { return NUMBER_CONSTANT ; }
int i = NUMBER_CONSTANT , isize = size ()
int size ( ) ;
public int size () { return getFields () . length ; }
public int size () { return NUMBER_CONSTANT ; }
int [] values = new int [ size () ] ;
int otherValue = getFieldType () . getField ( chrono ) . get ( instant . getMillis () ) ;
public static DurationFieldType eras () { return ERAS_TYPE ; }
public static DurationFieldType centuries () { return CENTURIES_TYPE ; }
public static DurationFieldType years () { return YEARS_TYPE ; }
public static DurationFieldType months () { return MONTHS_TYPE ; }
public static DurationFieldType weekyears () { return WEEKYEARS_TYPE ; }
public static DurationFieldType weeks () { return WEEKS_TYPE ; }
public static DurationFieldType days () { return DAYS_TYPE ; }
public static DurationFieldType halfdays () { return HALFDAYS_TYPE ; }
public static DurationFieldType hours () { return HOURS_TYPE ; }
public static DurationFieldType minutes () { return MINUTES_TYPE ; }
public static DurationFieldType seconds () { return SECONDS_TYPE ; }
public static DurationFieldType millis () { return MILLIS_TYPE ; }
public static DateTimeFieldType era () { return ERA_TYPE ; }
public static DateTimeFieldType centuryOfEra () { return CENTURY_OF_ERA_TYPE ; }
public static DateTimeFieldType yearOfCentury () { return YEAR_OF_CENTURY_TYPE ; }
public static DateTimeFieldType yearOfEra () { return YEAR_OF_ERA_TYPE ; }
public static DateTimeFieldType year () { return YEAR_TYPE ; }
public static DateTimeFieldType monthOfYear () { return MONTH_OF_YEAR_TYPE ; }
public static DateTimeFieldType weekyearOfCentury () { return WEEKYEAR_OF_CENTURY_TYPE ; }
public static DateTimeFieldType weekyear () { return WEEKYEAR_TYPE ; }
public static DateTimeFieldType weekOfWeekyear () { return WEEK_OF_WEEKYEAR_TYPE ; }
public static DateTimeFieldType dayOfYear () { return DAY_OF_YEAR_TYPE ; }
public static DateTimeFieldType dayOfMonth () { return DAY_OF_MONTH_TYPE ; }
public static DateTimeFieldType dayOfWeek () { return DAY_OF_WEEK_TYPE ; }
public static DateTimeFieldType halfdayOfDay () { return HALFDAY_OF_DAY_TYPE ; }
public static DateTimeFieldType clockhourOfHalfday () { return CLOCKHOUR_OF_HALFDAY_TYPE ; }
public static DateTimeFieldType hourOfHalfday () { return HOUR_OF_HALFDAY_TYPE ; }
public static DateTimeFieldType clockhourOfDay () { return CLOCKHOUR_OF_DAY_TYPE ; }
public static DateTimeFieldType hourOfDay () { return HOUR_OF_DAY_TYPE ; }
public static DateTimeFieldType minuteOfDay () { return MINUTE_OF_DAY_TYPE ; }
public static DateTimeFieldType minuteOfHour () { return MINUTE_OF_HOUR_TYPE ; }
public static DateTimeFieldType secondOfDay () { return SECOND_OF_DAY_TYPE ; }
public static DateTimeFieldType secondOfMinute () { return SECOND_OF_MINUTE_TYPE ; }
public static DateTimeFieldType millisOfDay () { return MILLIS_OF_DAY_TYPE ; }
public static DateTimeFieldType millisOfSecond () { return MILLIS_OF_SECOND_TYPE ; }
{ if ( instant == null ) { return isAfterNow () ; } return isAfter ( instant . getMillis () ) ; }
{ if ( instant == null ) { return isBeforeNow () ; } return isBefore ( instant . getMillis () ) ; }
{ if ( instant == null ) { return containsNow () ; } return contains ( instant . getMillis () ) ; }
assertEquals ( false , test . isAfter ( ( ReadableInstant ) null ) ) ;
assertEquals ( false , test . isBefore ( ( ReadableInstant ) null ) ) ;
assertEquals ( false , test . isAfter ( ( ReadableInstant ) null ) ) ;
assertEquals ( false , test . isBefore ( ( ReadableInstant ) null ) ) ;
{ super . setField ( DurationFieldType . millis () , millis ) ; }
{ super . setField ( DurationFieldType . seconds () , seconds ) ; }
{ super . setField ( DurationFieldType . minutes () , minutes ) ; }
{ super . setField ( DurationFieldType . hours () , hours ) ; }
{ super . setField ( DurationFieldType . days () , days ) ; }
{ super . setField ( DurationFieldType . weeks () , weeks ) ; }
{ super . setField ( DurationFieldType . months () , months ) ; }
{ super . setField ( DurationFieldType . years () , years ) ; }
{ setPeriod ( duration , null ) ; }
{ super ( period , type , null ) ; }
{ super ( period , null , null ) ; }
public MutablePeriod ( PeriodType type ) { super ( NUMBER_CONSTANT , type , null ) ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period result = test . withPeriodType ( PeriodType . standard () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . dayTime () ) ) ) ;
{ Period test = new Period ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . standard () , test . getPeriodType () ) ; }
{ super ( period , type , null ) ; }
{ super ( period , null , null ) ; }
test = new MutablePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . millis () ) ;
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . dayTime () ) ) ) ;
{ MutablePeriod test = new MutablePeriod () ; assertEquals ( PeriodType . standard () , test . getPeriodType () ) ; }
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
{ if ( period != null ) { setMillis ( period . addTo ( getMillis () , scalar , getChronology () ) ) ; } }
{ test1 . year () . compareTo ( ( ReadableInstant ) null ) ; fail () ; }
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setStartMillis ( chrono . add ( getEndMillis () , period , - NUMBER_CONSTANT ) ) ; }
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setEndMillis ( chrono . add ( getStartMillis () , period , NUMBER_CONSTANT ) ) ; }
assertEquals ( PeriodType . standard () , test . getPeriodType () ) ;
{ if ( period != null ) { setMillis ( getChronology () . add ( getMillis () , period , scalar ) ) ; } }
assertEquals ( PeriodType . standard () , test . getPeriodType () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , millis } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , seconds , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , minutes , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , hours , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , days , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , weeks , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , months , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
new Period ( new int [] { years , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () )
try { test . setYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
{ duration . setPeriod ( ( Period ) null ) ; }
{ super . setInterval ( getStartMillis () , endInstant , getChronology () ) ; }
{ super . setInterval ( startInstant , getEndMillis () , getChronology () ) ; }
public long toDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
{ IntervalConverter [] array = ConverterManager . getInstance () . getIntervalConverters () ; assertEquals ( INTERVAL_SIZE , array.length ) ; }
{ return ( ( ( ReadableInterval ) object ) ) . toDurationMillis () ; }
{ MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . toDuration () ) ; }
iIntervalConverters = new ConverterSet ( new Converter [] { ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
public long toDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
Interval result = test . withEnd ( null ) ;
{ test . withEnd ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withEnd ( new Instant ( TEST_TIME2 - NUMBER_CONSTANT ) ) ;
Interval result = test . withStart ( null ) ;
{ test . withStart ( new Instant ( TEST_TIME2 + NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withStart ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ;
{ Interval test = new Interval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . toDuration () ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
DateTime getEnd ( ) ;
DateTime getStart ( ) ;
long resolved = chrono . set ( this , instantMillis ) ;
{ Chronology chrono = getChronology () . withZone ( zone ) ; return chrono . set ( this , baseInstant ) ; }
iValues = chronology . get ( this , millis ) ;
iValues = chronology . get ( this , millis ) ;
iValues = chronology . get ( this , instant ) ;
{ setStartMillis ( getChronology () . add ( period , getEndMillis () , - NUMBER_CONSTANT ) ) ; }
{ setEndMillis ( getChronology () . add ( period , getStartMillis () , NUMBER_CONSTANT ) ) ; }
{ if ( period == null ) { setValues ( new int [ size () ] ) ; } else { setPeriodInternal ( period ) ; } }
long endMillis = chrono . add ( this , startMillis , NUMBER_CONSTANT ) ;
iValues = chrono . get ( this , startMillis , endMillis ) ;
if ( period == null ) { iStartMillis = iEndMillis ; } else { iStartMillis = chrono . add ( period , iEndMillis , - NUMBER_CONSTANT ) ; }
if ( period == null ) { iEndMillis = iStartMillis ; } else { iEndMillis = chrono . add ( period , iStartMillis , NUMBER_CONSTANT ) ; }
long instant = getChronology () . add ( period , getMillis () , scalar ) ;
{ if ( period != null ) { setMillis ( getChronology () . add ( period , getMillis () , scalar ) ) ; } }
{ if ( period != null ) { super . addPeriod ( period ) ; } }
{ long millis = this . iChrono . withUTC () . set ( partial , NUMBER_CONSTANT ) ; printTo ( null , out , millis ) ; }
long millis = this . iChrono . withUTC () . set ( partial , NUMBER_CONSTANT ) ;
DateTime result = test . toDateTimeUsing ( null ) ;
{ if ( partial == null ) { return this ; } return withMillis ( getChronology () . set ( partial , getMillis () ) ) ; }
DateTime result = test . toDateTimeUsing ( null ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
{ return new Period ( getStartMillis () , getEndMillis () , type , getChronology () ) ; }
{ return new Period ( getStartMillis () , getEndMillis () , getChronology () ) ; }
{ return new MutableInterval ( getStartMillis () , getEndMillis () , getChronology () ) ; }
{ return new Interval ( getStartMillis () , getEndMillis () , getChronology () ) ; }
Interval test4 = new Interval ( TEST_TIME1 , TEST_TIME2 , Chronology . getGJ () ) ;
{ if ( endInstant == getEndMillis () ) { return this ; } return new Interval ( getStartMillis () , endInstant , getChronology () ) ; }
{ if ( startInstant == getStartMillis () ) { return this ; } return new Interval ( startInstant , getEndMillis () , getChronology () ) ; }
{ test . set ( DateTimeFieldType . monthOfYear () , NUMBER_CONSTANT ) ; fail () ; }
test . set ( DateTimeFieldType . year () , NUMBER_CONSTANT ) ;
public MutableDateTime parseMutableDateTime ( String text ) { return mParser . parseMutableDateTime ( text ) ; }
public DateTime parseDateTime ( String text ) { return mParser . parseDateTime ( text ) ; }
public long parseMillis ( String text ) { return mParser . parseMillis ( text ) ; }
public String print ( long instant ) { throw unsupported () ; }
public String print ( ReadableInstant instant ) { throw unsupported () ; }
FParser ( DateTimeParser parser ) { super(); mParser = parser ; }
public MutableDateTime parseMutableDateTime ( String text ) { throw unsupported () ; }
public DateTime parseDateTime ( String text ) { throw unsupported () ; }
public long parseMillis ( String text ) { throw unsupported () ; }
public String print ( long instant ) { return mPrinter . print ( instant ) ; }
public String print ( ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
FPrinter ( DateTimePrinter printer ) { super(); mPrinter = printer ; }
Object f
Object f
Object f
public DateTimeFormatterBuilder appendEraText () { return appendText ( DateTimeFieldType . era () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearShortText () { return appendShortText ( DateTimeFieldType . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearText () { return appendText ( DateTimeFieldType . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekShortText () { return appendShortText ( DateTimeFieldType . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekText () { return appendText ( DateTimeFieldType . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendHalfdayOfDayText () { return appendText ( DateTimeFieldType . halfdayOfDay () ) ; }
String text
char c
Object element
DateTimeParser parser
DateTimeParser parser
DateTimePrinter printer
DateTimeFormatter formatter
Chronology chrono
DateTimeZone zone
iMillis = converter . getInstantMillis ( instant , Chronology . getISOUTC () ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
{ PartialConverter [] array = ConverterManager . getInstance () . getPartialConverters () ; assertEquals ( PARTIAL_SIZE , array.length ) ; }
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
iPartialConverters = new ConverterSet ( new Converter [] { ReadablePartialConverter.INSTANCE , ReadableInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , UnsupportedDurationField . getInstance ( getDurationType () ) ) ; }
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , UnsupportedDurationField . getInstance ( getDurationType () ) ) ; }
throw new InternalError () ;
throw new InternalError () ;
{ return FieldUtils . safeMultiply ( value , getUnitMillis () ) ; }
{ return FieldUtils . safeMultiply ( value , iUnitMillis ) ; }
try { MillisDurationField.INSTANCE . getDifferenceAsLong ( Long.MAX_VALUE , - NUMBER_CONSTANT ) ; fail () ; } catch ( ArithmeticException ex ) {}
BaseDateTimeField field = new MockStandardBaseDateTimeField () ;
PreciseDateTimeField field = new MockPreciseDateTimeField () ;
DateTimeParser dateTimeParser = ISODateTimeFormat . getInstance ( chrono ) . dateTimeParser () ;
{ assertEquals ( PARIS , DateTimeUtils . getZone ( PARIS ) ) ; assertEquals ( DateTimeZone . getDefault () , DateTimeUtils . getZone ( null ) ) ; }
DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder ( iLocale ) ;
BasePeriodFormatter [] parsers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
Separator finish ( BasePeriodFormatter after ) { iAfter = after ; return this ; }
BasePeriodFormatter before
BasePeriodFormatter composite = createComposite ( formatters ) ;
return printTimeZone ( getOffset ( instant ) ) ;
return printTimeZone ( getOffset ( instant ) ) ;
{ convId = printTimeZone ( offset ) ; return fixedOffsetZone ( convId , offset ) ; }
return DateTimeFormat . getInstance ( locale ) . forPattern ( pattern ) . print ( this ) ;
return DateTimeFormat . getInstance () . forPattern ( pattern ) . print ( this ) ;
DateTimeParser p = ISODateTimeFormat . getInstance () . hourMinuteSecondFraction () ;
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket = new ParseBucket ( instantLocal , chrono ) ;
ParseBucket bucket = new ParseBucket ( NUMBER_CONSTANT , chrono ) ;
ParseBucket bucket = new ParseBucket ( instantLocal , chrono ) ;
{ if ( permission instanceof JodaTimePermission ) { return false ; } return true ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return true ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return true ; }
iFieldType >= SECONDS_MILLIS
{ return appendSeparator ( text , finalText , null , true , true ) ; }
{ return appendSeparator ( text , text , null , true , true ) ; }
int offset = - ( int ) offsetFormatter () . parseMillis ( convId , ISOChronology . getInstance ( UTC ) ) ;
int offset = - ( int ) offsetFormatter () . parseMillis ( id , ISOChronology . getInstance ( UTC ) ) ;
int itimeStyle = selectStyle ( timeStyle ) ;
DateTimeField field = iFieldType . getField ( chronoLocal ) ;
return printOffset ( getOffset ( instant ) ) ;
return printOffset ( getOffset ( instant ) ) ;
String id = printOffset ( offset ) ;
public MutableDateTime parseMutableDateTime ( String text , ReadableInstant instant ) { return iParser . parseMutableDateTime ( text , instant ) ; }
public MutableDateTime parseMutableDateTime ( String text , Chronology chrono ) { return iParser . parseMutableDateTime ( text , chrono ) ; }
public DateTime parseDateTime ( String text , ReadableInstant instant ) { return iParser . parseDateTime ( text , instant ) ; }
public DateTime parseDateTime ( String text , Chronology chrono ) { return iParser . parseDateTime ( text , chrono ) ; }
{ return iParser . parseMillis ( text , instant , chrono ) ; }
{ return iParser . parseInto ( instant , text , position ) ; }
public String print ( long instant , Chronology chrono ) { return iPrinter . print ( instant , chrono ) ; }
public String print ( long instant , DateTimeZone zone ) { return iPrinter . print ( instant , zone ) ; }
{ iPrinter . printTo ( out , instant , chrono ) ; }
{ iPrinter . printTo ( buf , instant , chrono ) ; }
{ iPrinter . printTo ( out , instant , zone ) ; }
{ iPrinter . printTo ( buf , instant , zone ) ; }
public void printTo ( Writer out , long instant ) throws IOException { iPrinter . printTo ( out , instant ) ; }
{ iPrinter . printTo ( out , instant ) ; }
public int estimateParsedLength () { return iParsedLengthEstimate ; }
public int estimateParsedLength () { return iParsedLengthEstimate ; }
DateTimePrinter [] elements = iPrinters ;
DateTimePrinter [] elements = iPrinters ;
public int estimatePrintedLength () { return iPrintedLengthEstimate ; }
DateTimeFormatter [] printers
public int estimatePrintedLength () { return iShortFormat ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
public int estimateParsedLength () { return estimatePrintedLength () ; }
public int estimateParsedLength () { return iMaxDigits ; }
public int estimatePrintedLength () { return iMaxDigits ; }
public int estimateParsedLength () { return estimatePrintedLength () ; }
public int estimatePrintedLength () { return iShort ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
public int estimatePrintedLength () { return NUMBER_CONSTANT ; }
public int estimateParsedLength () { return NUMBER_CONSTANT ; }
public int estimatePrintedLength () { return iMaxParsedDigits ; }
public int estimatePrintedLength () { return iMaxParsedDigits ; }
public int estimateParsedLength () { return iMaxParsedDigits ; }
DateTimeParserBucket bucket
public int estimateParsedLength () { return NUMBER_CONSTANT ; }
return new MutableDateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new MutableDateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , chrono ) , chrono ) ; }
return new DateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new DateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , chrono ) , chrono ) ; }
return ( ( DateTimePrinter ) this ) . print ( millis , chrono ) ;
( ( DateTimePrinter ) this ) . printTo ( out , millis , chrono ) ;
( ( DateTimePrinter ) this ) . printTo ( buf , millis , chrono ) ;
PeriodFormatter [] parsers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
Separator finish ( PeriodFormatter after ) { iAfter = after ; return this ; }
PeriodFormatter before
PeriodFormatter composite = createComposite ( formatters ) ;
{ return getField () . remainder ( getMillis () ) ; }
{ return getField () . getMaximumValue ( getMillis () ) ; }
{ return getField () . getMinimumValue ( getMillis () ) ; }
{ return getField () . getLeapAmount ( getMillis () ) ; }
{ return getField () . isLeap ( getMillis () ) ; }
{ return getField () . getAsShortText ( getMillis () , locale ) ; }
{ return getField () . getAsText ( getMillis () , locale ) ; }
{ return getField () . get ( getMillis () ) ; }
if ( value == getValue ( index ) ) { return this ; }
fields.era = ThaiBuddhistEraDateTimeField.INSTANCE ;
{ zone = DateTimeZone . forTimeZone ( cal . getTimeZone () ) ; }
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
{ DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , zone . getID () ) ; }
DateTimeZone . setDefault ( DateTimeZone . forID ( STRING_CONSTANT ) ) ;
iChronology = ISOChronology . getInstance ( DateTimeZone . forID ( id ) ) ;
z = DateTimeZone . forID ( str ) ;
zones [ i ++ ] = new ZoneData ( id , DateTimeZone . forID ( id ) ) ;
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , TestGJChronology.MILLIS_PER_DAY , chrono ) ; }
int dayOfWeek = ( int ) TestGJChronology . mod ( iChronology . fixedFromMillis ( millis ) , NUMBER_CONSTANT ) ;
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , TestGJChronology.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , TestGJChronology.MILLIS_PER_DAY , chrono ) ; }
DateTimePrinter [] printers
{ return append0 ( new TimeZoneOffset ( zeroOffsetText , showSeparators , minFields , maxFields ) ) ; }
{ return append0 ( new TimeZonePrinter ( true ) , null ) ; }
{ return append0 ( new TimeZonePrinter ( false ) , null ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , true ) ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , false ) ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter () , formatter . getParser () ) ; }
return - ( int ) offsetFormatter () . withChronology ( chrono ) . parseMillis ( str ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . withLocale ( locale ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . print ( this ) ; }
DateTimeFormatter p = ISODateTimeFormat . hourMinuteSecondFraction () ;
parse ( ISODateTimeFormat . dateTimeParser () ) ;
DateTimeFormatter p
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . withLocale ( locale ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . print ( this ) ; }
return cOffsetFormatter . withZone ( iZone ) . print ( millis ) ;
bucket . saveField ( iType , year ) ;
try { g . parseMutableDateTime ( STRING_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { g . parseDateTime ( STRING_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
append0 ( field , field ) ;
append0 ( literal , literal ) ;
append0 ( formatter . getPrinter () , formatter . getParser () ) ;
PeriodFormatter formatter = toFormatter ( iElementPairs ) ;
public PeriodParser toParser () { return toFormatter () . getParser () ; }
public PeriodPrinter toPrinter () { return toFormatter () . getPrinter () ; }
f = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
InputStream in = new ByteArrayInputStream ( data . getBytes ( STRING_CONSTANT ) ) ;
{ return ISOPeriodFormat . standard () . print ( this ) ; }
PeriodFormatter periodParser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = PeriodFormat . getDefault () ;
Locale locale
Locale locale
Locale locale
Locale locale
fields.year = new BasicYearDateTimeField ( this ) ;
fields.year = new BasicYearDateTimeField ( this ) ;
fields.year = new CopticYearDateTimeField ( this ) ;
fields.year = new GJYearDateTimeField ( this ) ;
{ if ( iZone == zone ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , false , iChrono , zone , iPivotYear ) ; }
{ if ( iChrono == chrono ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , iOffsetParsed , chrono , iZone , iPivotYear ) ; }
{ if ( iOffsetParsed == true ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , true , iChrono , null , iPivotYear ) ; }
return new DateTimeFormatter ( iPrinter , iParser , locale , iOffsetParsed , iChrono , iZone , iPivotYear ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
{ return appendTwoDigitWeekyear ( pivot , false ) ; }
{ return appendTwoDigitYear ( pivot , false ) ; }
suite . addTest ( TestIllegalFieldValueException . suite () ) ;
catch ( NumberFormatException ex ) { throw new IllegalFieldValueException ( getType () , text ) ; }
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalFieldValueException ( DateTimeFieldType . era () , text ) ; } return instant ; }
FieldUtils . verifyValueBounds ( DateTimeFieldType . millisOfDay () , millisOfDay , NUMBER_CONSTANT , DateTimeConstants.MILLIS_PER_DAY ) ;
throw new IllegalFieldValueException ( DateTimeFieldType . halfdayOfDay () , text ) ;
throw new IllegalFieldValueException ( DateTimeFieldType . dayOfWeek () , text ) ;
throw new IllegalFieldValueException ( DateTimeFieldType . monthOfYear () , text ) ;
throw new IllegalFieldValueException ( DateTimeFieldType . era () , text ) ;
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalFieldValueException ( DateTimeFieldType . era () , text ) ; } return instant ; }
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
public int getMinimumDaysInFirstWeek () { return iMinDaysInFirstWeek ; }
DateTimeZone test = DateTimeZone . forID ( STRING_CONSTANT ) ;
protected DateTimeFormat () { super(); }
protected PeriodFormat () { super(); }
protected ISOPeriodFormat () { super(); }
cfg . setProperty ( STRING_CONSTANT , STRING_CONSTANT + getClass () . getName () ) ;
fields.era = ERA_FIELD ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
ReadableIntervalConverter.INSTANCE . setInto ( m , i , CopticChronology . getInstance () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
Chronology chrono = ISOChronology . getInstance ( ZONES [ i ] ) ;
Chronology chrono = ISOChronology . getInstance ( ZONES [ i ] ) ;
Chronology chrono = GregorianChronology . getInstance () ;
Chronology chrono = GJChronology . getInstanceUTC () ;
test . add ( ms , ISOChronology . getInstanceUTC () ) ;
test . add ( ms , ISOChronology . getInstance () ) ;
test . add ( NUMBER_CONSTANT , ISOChronology . getInstance () ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( ISOChronology . getInstance () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == ISOChronology . getInstance () . minutes () . hashCode () ) ;
assertEquals ( false , iField . equals ( ISOChronology . getInstance () . minutes () ) ) ;
int [] actual = NullConverter.INSTANCE . getPartialValues ( tod , null , ISOChronology . getInstance () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
int [] actual = StringConverter.INSTANCE . getPartialValues ( tod , STRING_CONSTANT , ISOChronology . getInstance () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( new Interval ( TEST_TIME1 , TEST_TIME2 , ISOChronology . getInstance () ) , test ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
try { type . getField ( CopticChronology . getInstanceUTC () ) ; fail () ; } catch ( InternalError ex ) {}
assertEquals ( - NUMBER_CONSTANT , MillisDurationField.INSTANCE . compareTo ( ISOChronology . getInstance () . seconds () ) ) ;
Period test = new Period ( length , PeriodType . standard () , ISOChronology . getInstanceUTC () ) ;
Period test = new Period ( length , PeriodType . time () . withMillisRemoved () , ISOChronology . getInstance () ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( ISOChronology . getInstance () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == ISOChronology . getInstance () . minutes () . hashCode () ) ;
assertEquals ( false , iField . equals ( ISOChronology . getInstance () . minutes () ) ) ;
{ FieldUtils . verifyValueBounds ( ISOChronology . getInstance () . monthOfYear () , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail () ; }
actual = ReadablePartialConverter.INSTANCE . getPartialValues ( tod , new TimeOfDay ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , ISOChronology . getInstance ( PARIS ) )
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , ISOChronology . getInstanceUTC () ) ;
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , ISOChronology . getInstance () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . standard () , ISOChronology . getInstanceUTC () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . time () . withMillisRemoved () , ISOChronology . getInstance () ) ;
try { type . getField ( CopticChronology . getInstanceUTC () ) ; fail () ; } catch ( InternalError ex ) {}
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
public Chronology getChronology () { return ChronologyType . iso () . getChronologyUTC () ; }
iMillis = converter . getInstantMillis ( instant , ChronologyType . iso () . getChronologyUTC () ) ;
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = ChronologyType . iso () . getChronology () ; }
{ return ChronologyType . iso () . getChronology ( zone ) ; }
iZone = zone ;
iZone = zone ;
{ newValues = getField ( index ) . addWrapPartial ( this , index , newValues , FieldUtils . safeMultiply ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiply ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiply ( period . getValue ( i ) , scalar ) ) ; }
if ( val < NUMBER_CONSTANT ) { System.out . println ( STRING_CONSTANT ) ; }
if ( val < NUMBER_CONSTANT ) { System.out . println ( STRING_CONSTANT ) ; }
cal . setTime ( convertToDate ( cal ) ) ;
cal . setTime ( convertToDate ( cal ) ) ;
{ out . write ( print ( instant - displayOffset , displayZone , locale ) ) ; }
{ buf . append ( print ( instant - displayOffset , displayZone , locale ) ) ; }
{ super ( ISOChronology . getInstance ( zone ) ) ; }
{ return ISOChronology . getInstance ( zone ) ; }
{ super ( ISOChronology . getInstance ( zone ) ) ; }
public Chronology getChronology () { return ISOChronology . getInstanceUTC () ; }
iMillis = converter . getInstantMillis ( instant , ISOChronology . getInstanceUTC () ) ;
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = ISOChronology . getInstance () ; }
{ return ISOChronology . getInstance ( zone ) ; }
return iChronology . getDaysInYearMax () ;
return iChronology . getDaysInYearMax () ;
FieldUtils . verifyValueBounds ( this , month , MIN , iMax ) ;
long difference = ( minuendYear - subtrahendYear ) * ( ( long ) iMax ) + minuendMonth - subtrahendMonth ;
{ return set ( instant , FieldUtils . getWrappedValue ( get ( instant ) , months , MIN , iMax ) ) ; }
assertEquals ( false , CopticChronology . getInstanceUTC () . months () . isPrecise () ) ;
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * MILLIS_PER_DAY ; return new TestSuite ( TestCopticChronology . class ) ; }
assertEquals ( false , EthiopicChronology . getInstanceUTC () . months () . isPrecise () ) ;
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * MILLIS_PER_DAY ; return new TestSuite ( TestEthiopicChronology . class ) ; }
fields.monthOfYear = new IslamicMonthOfYearDateTimeField ( this ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
fields.monthOfYear = new BasicMonthOfYearDateTimeField ( this , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
BasicChronology chronology
BasicChronology chronology
GJEraDateTimeField ( BasicChronology chronology ) { super ( DateTimeFieldType . era () ) ; iChronology = chronology ; }
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
GJMonthOfYearDateTimeField ( BasicChronology chronology ) { super ( chronology , NUMBER_CONSTANT ) ; }
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
{ int len = parser . estimateParsedLength () ; if ( len > est ) { est = len ; } }
long instant = chronology . getDateTimeMillis ( NUMBER_CONSTANT , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
LocalTime test = LocalTime . forInstant ( ( Object ) null , JULIAN_LONDON ) ;
LocalTime test = LocalTime . forInstant ( date , JULIAN_LONDON ) ;
LocalTime test = LocalTime . forInstant ( TEST_TIME2 , JULIAN_LONDON ) ;
LocalTime test = LocalTime . now ( JULIAN_LONDON ) ;
LocalTime test = LocalTime . fromMillisOfDay ( TEST_TIME1 , JULIAN_LONDON ) ;
assertEquals ( false , test . isSupported ( DurationFieldType . eras () ) ) ;
DateMidnight test = base . toDateMidnight () ;
DateTime test = base . toDateTimeAtCurrentTime () ;
DateTime test = base . toDateTimeAtMidnight () ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate () ;
LocalDate test = new LocalDate () ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
public void testSize () { LocalDate test = new LocalDate () ; assertEquals ( NUMBER_CONSTANT , test . size () ) ; }
LocalDate test = new LocalDate () ;
DateTime test = base . toDateTimeToday () ;
long getApproxMillisAtEpochDividedByTwo () { return ( - MILLIS_YEAR_1 ) / NUMBER_CONSTANT ; }
public long computeMillis () { return computeMillis ( false , null ) ; }
long millis = bucket . computeMillis ( true , text ) ;
long millis = bucket . computeMillis ( true , text ) ;
{ if ( newPos >= text . length () ) { return bucket . computeMillis ( true , text ) ; } }
instant . setMillis ( bucket . computeMillis ( false , text ) ) ;
test = new DateMidnight ( TEST_TIME1_UTC , GREGORIAN_PARIS ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( false , test1 . equals ( new DateMidnight ( TEST_TIME1_UTC , GREGORIAN_DEFAULT ) ) ) ;
assertEquals ( ISO_DEFAULT , test . getChronology () ) ;
test = new DateTime ( TEST_TIME1 , GREGORIAN_PARIS ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( ISO_DEFAULT , test . getChronology () ) ;
long millis = converter . getInstantMillis ( instant , chronology , ISODateTimeFormat . dateParser () ) ;
long millis = converter . getInstantMillis ( instant , chronology , ISODateTimeFormat . dateParser () ) ;
long millis = converter . getInstantMillis ( instant , chronology , ISODateTimeFormat . timeParser () ) ;
long millis = converter . getInstantMillis ( instant , chronology , ISODateTimeFormat . timeParser () ) ;
{ super ( instant , DateTimeUtils . getChronology ( chronology ) , ISODateTimeFormat . timeParser () ) ; }
{ super ( instant , null , ISODateTimeFormat . timeParser () ) ; }
int index = ( ( dateStyle < < NUMBER_CONSTANT ) + dateStyle ) + timeStyle ;
LocalTime copy = test . millisOfSecond () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . secondOfMinute () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . minuteOfHour () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . hourOfDay () . setCopy ( STRING_CONSTANT ) ;
public LocalDate withMinimumValue () { return setCopy ( getMinimumValue () ) ; }
{ return setCopy ( getMaximumValue () ) ; }
public LocalDateTime withMinimumValue () { return setCopy ( getMinimumValue () ) ; }
{ return setCopy ( getMaximumValue () ) ; }
LocalDateTime copy = test . millisOfSecond () . setCopy ( STRING_CONSTANT ) ;
LocalDateTime copy = test . secondOfMinute () . setCopy ( STRING_CONSTANT ) ;
LocalDateTime copy = test . minuteOfHour () . setCopy ( STRING_CONSTANT ) ;
LocalDateTime copy = test . hourOfDay () . setCopy ( STRING_CONSTANT ) ;
public LocalTime withMinimumValue () { return setCopy ( getMinimumValue () ) ; }
public LocalTime withMaximumValue () { return setCopy ( getMaximumValue () ) ; }
assertEquals ( false , interval33 . contains ( new Instant ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( false , interval33 . containsNow () ) ;
assertEquals ( false , interval33 . contains ( NUMBER_CONSTANT ) ) ;
return FieldUtils . equals ( getChronology () , other . getChronology () ) ;
public synchronized Set getAvailableIDs () { return new TreeSet ( iZoneInfoMap . keySet () ) ; }
if ( value >= min && value <= getMaximumValue ( instant ) ) { return super . set ( instant , value ) ; }
DateTimeZone tz = builder . toDateTimeZone ( STRING_CONSTANT , true ) ;
builder . writeTo ( STRING_CONSTANT , out ) ;
super ( createMessage ( fieldName , value , lowerBound , upperBound , null ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound , null ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound , null ) ) ;
try { test . minusYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
try { test . plusYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
try { test . withYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
{ printTo ( out , instant , null ) ; }
{ printTo ( buf , instant , null ) ; }
DateTime now = new DateTime ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
( offsetLocal - offsetAdjusted ) < NUMBER_CONSTANT
{ t = new DateTimeFormatterBuilder () . append ( hourMinuteSecondFraction () ) . append ( offsetElement () ) . toFormatter () ; }
DateTime start = base . toDateTimeAtStartOfDay ( LONDON ) ;
DateTime start = base . toDateTimeAtStartOfDay ( TOKYO ) ;
DateTime start = base . toDateTimeAtStartOfDay () ;
String [] [] zoneStrings = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
DateFormatSymbols dfs = DateTimeUtils . getDateFormatSymbols ( locale ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + id + STRING_CONSTANT ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + id + STRING_CONSTANT ) ;
{ Hibernate.DATE . nullSafeSet ( preparedStatement , ( ( LocalDate ) value ) . toDateTimeAtStartOfDay () . toDate () , index ) ; }
f = cCache . get ( key ) ;
formatter = cPatternedCache . get ( pattern ) ;
DurationField durationField
public int compareTo ( DurationField durationField ) { return iField . compareTo ( durationField ) ; }
List < Object > list
List < Object > elementPairs
List < Object > elementPairs
List < Object > pairs = iElementPairs ;
if ( iElementPairs == null ) { iElementPairs = new ArrayList < Object > () ; } else { iElementPairs . clear () ; }
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
List < Object > list
public DateTimeFormatterBuilder () { super(); iElementPairs = new ArrayList < Object > () ; }
chrono = cCache . get ( zone ) ;
ReadablePartial partial
HashMap < Object , Object > converted
HashMap < Object , Object > converted
iRules = new ArrayList < Rule > ( rs.iRules ) ;
RuleSet () { iRules = new ArrayList < Rule > ( NUMBER_CONSTANT ) ; iUpperYear = Integer.MAX_VALUE ; }
TreeMap < String , Integer > map
TreeMap < String , Integer > map
symbols = cCache . get ( locale ) ;
ReadablePartial partial
Map < String , RuleSet > ruleSets
{ iRules = new ArrayList < Rule > () ; iRules . add ( rule ) ; }
ReadableInstant readableInstant
Map < String , Object > zimap
iZoneInfoMap . put ( id , new SoftReference < DateTimeZone > ( tz ) ) ;
public int compareTo ( DurationField durationField ) { return NUMBER_CONSTANT ; }
ReadablePartial partial
HashMap < Object , Object > converted
HashMap < Object , Object > converted
Class < > type
Class < > type
ReadableDuration obj
try { Single . between ( start , new LocalTime () , zero ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
{ if ( ldp == null ) { ldp = dateElementParser () . withZoneUTC () ; } return ldp ; }
assertEquals ( STRING_CONSTANT , f . withZoneUTC () . print ( dt ) ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.KOREAN ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withPivotYear ( NUMBER_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withPivotYear ( NUMBER_CONSTANT ) . withZoneUTC () ;
{ if ( value == null ) { return null ; } return new Instant ( value ) ; }
{ return org.joda.time.gwt.util.Arrays . copyOf ( iValues , iValues.length ) ; }
{ return Arrays . copyOf ( iValues , iValues.length ) ; }
Locale . setDefault ( Locale.JAPAN ) ;
TimeZone . setDefault ( DateTimeZone . forID ( STRING_CONSTANT ) . toTimeZone () ) ;
Locale . setDefault ( Locale.JAPAN ) ;
Locale . setDefault ( Locale.JAPAN ) ;
Locale . setDefault ( Locale.JAPAN ) ;
TimeZone . setDefault ( DateTimeZone . forID ( STRING_CONSTANT ) . toTimeZone () ) ;
Locale . setDefault ( Locale.JAPAN ) ;
{ locale = Locale . getDefault () ; zone = DateTimeZone . getDefault () ; Locale . setDefault ( Locale.JAPAN ) ; }
Locale . setDefault ( Locale.JAPAN ) ;
public YearMonth getYearMonth () { return iBase ; }
protected ReadablePartial getReadablePartial () { return iBase ; }
public DateTimeField getField () { return iBase . getField ( iFieldIndex ) ; }
{ super(); iBase = partial ; iFieldIndex = fieldIndex ; }
Map < String , Object > map = new ConcurrentHashMap < String , Object > () ;
DateTimeZone . setDefault ( PARIS ) ;
return iZone . convertLocalToUTC ( localInstant , false , instant ) ;
return iZone . convertLocalToUTC ( localInstant , false , instant ) ;
return iZone . convertLocalToUTC ( localInstant , false , instant ) ;
long result = iZone . convertLocalToUTC ( localInstant , false , instant ) ;
return iZone . convertLocalToUTC ( localInstant , false , instant ) ;
return iZone . convertLocalToUTC ( localInstant , false , instant ) ;
return iZone . convertLocalToUTC ( localInstant , false , instant ) ;
return iBase . getZone () . convertLocalToUTC ( localInstant , false , instant ) ;
{ super ( duration ) ; }
{ super ( duration ) ; }
Object timestamp = StandardBasicTypes.TIMESTAMP . nullSafeGet ( resultSet , string ) ;
Object date = StandardBasicTypes.TIME . nullSafeGet ( resultSet , string ) ;
Object date = StandardBasicTypes.DATE . nullSafeGet ( resultSet , string ) ;
Object timestamp = StandardBasicTypes.TIME . nullSafeGet ( resultSet , string ) ;
Object timestamp = StandardBasicTypes.DATE . nullSafeGet ( resultSet , string ) ;
Object timestamp = StandardBasicTypes.INTEGER . nullSafeGet ( resultSet , string ) ;
Object timestamp = StandardBasicTypes.TIMESTAMP . nullSafeGet ( resultSet , string ) ;
Object timestamp = StandardBasicTypes.STRING . nullSafeGet ( resultSet , string ) ;
String s = ( String ) StandardBasicTypes.STRING . nullSafeGet ( resultSet , strings [ NUMBER_CONSTANT ] ) ;
Object value = StandardBasicTypes.TIMESTAMP . nullSafeGet ( resultSet , name ) ;
Object value = StandardBasicTypes.LONG . nullSafeGet ( resultSet , name ) ;
{ if ( period != null ) { setValues ( addPeriodInto ( getValues () , period ) ) ; } }
{ if ( period != null ) { setValues ( mergePeriodInto ( getValues () , period ) ) ; } }
setValues ( newValues ) ;
{ integers [ i ] = Integer . valueOf ( i ) ; }
array = new Object [] { validValues , Integer . valueOf ( maxLength ) } ;
{ return withPivotYear ( Integer . valueOf ( pivotYear ) ) ; }
array = new Object [] { validValues , Integer . valueOf ( maxLength ) } ;
{ return withPivotYear ( Integer . valueOf ( pivotYear ) ) ; }
DateTimeFormatter printer = ISODateTimeFormat . dateTime () ;
protected void setUp ( ) throws Exception { originalLocale = Locale . getDefault () ; Locale . setDefault ( DE ) ; }
convId = zone . getID () ;
catch ( ArrayIndexOutOfBoundsException ex ) { throw new IOException ( STRING_CONSTANT ) ; }
try { readZoneInfoMap ( din , map ) ; } finally { try { din . close () ; } catch ( IOException ex ) {} }
StringBuilder msg = new StringBuilder () ;
StringBuilder sb = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder () ;
if ( tokenLen >= NUMBER_CONSTANT ) { builder . appendTimeZoneName () ; } else { builder . appendTimeZoneShortName ( null ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . startsWith ( STRING_CONSTANT ) ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . startsWith ( STRING_CONSTANT ) ) ; }
try { localDateTime . toDateTime ( this ) ; return false ; } catch ( IllegalInstantException ex ) { return true ; }
throw new IllegalInstantException ( message ) ;
{ if ( divisor == NUMBER_CONSTANT ) { return this ; } return new Duration ( FieldUtils . safeDivide ( getMillis () , divisor ) ) ; }
{ if ( multiplicand == NUMBER_CONSTANT ) { return this ; } return new Duration ( FieldUtils . safeMultiply ( getMillis () , multiplicand ) ) ; }
{ printTo ( appendable , instant , null ) ; }
InternalPrinter [] elements = iPrinters ;
InternalPrinter [] elements = iPrinters ;
{ printTo ( appendable , instant , chrono ) ; }
f instanceof InternalPrinter
InternalPrinter printer
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , parser ) ; }
{ checkPrinter ( printer ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , null ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter0 () , formatter . getParser () ) ; }
{ InternalPrinter p = getFormatter ( locale ) . getPrinter0 () ; p . printTo ( appendable , partial , locale ) ; }
InternalPrinter p = getFormatter ( locale ) . getPrinter0 () ;
return ( ( StyleFormatter ) formatter . getPrinter0 () ) . getPattern ( locale ) ;
f2 = new DateTimeFormatter ( ( InternalPrinter ) null , f . getParser () ) ;
InternalPrinter printer = requirePrinter () ;
InternalPrinter printer = requirePrinter () ;
{ printTo ( ( Appendable ) out , instant ) ; }
InternalPrinter printer
catch ( IllegalArgumentException ex ) { assertMessageContains ( ex , STRING_CONSTANT ) ; }
{ return computeMillis ( resetFields , ( CharSequence ) null ) ; }
{ return computeMillis ( false , ( CharSequence ) null ) ; }
{ obtainSaveField () . init ( fieldType . getField ( iChrono ) , value ) ; }
{ obtainSaveField () . init ( field , value ) ; }
CharSequence text
CharSequence text
CharSequence text
CharSequence text
f instanceof InternalParser
InternalParser parser
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , DateTimeParserInternalParser . of ( parser ) ) ; }
{ checkParser ( parser ) ; return append0 ( null , DateTimeParserInternalParser . of ( parser ) ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter0 () , formatter . getParser0 () ) ; }
{ reset () ; return doParseMillis ( DateTimeParserInternalParser . of ( parser ) , text ) ; }
f2 = new DateTimeFormatter ( ( DateTimePrinter ) null , f . getParser () ) ;
InternalParser parser = requireParser () ;
InternalParser parser = requireParser () ;
InternalParser parser = requireParser () ;
InternalParser parser = requireParser () ;
InternalParser parser = requireParser () ;
public DateTimeParser getParser () { return InternalParserDateTimeParser . of ( iParser ) ; }
InternalParser parser
InternalParser parser
{ this ( DateTimePrinterInternalPrinter . of ( printer ) , DateTimeParserInternalParser . of ( parser ) ) ; }
iMillis = FieldUtils . safeSubtract ( endMillis , startMillis ) ;
{ super(); iMillis = FieldUtils . safeSubtract ( endInstant , startInstant ) ; }
try { builder . appendSuffix ( NULL_STRING , null ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { builder . appendPrefix ( NULL_STRING , null ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
iSuffixes = texts . clone () ;
builder . appendDays () . appendSuffix ( STRING_CONSTANT ) . appendSuffix ( STRING_CONSTANT , STRING_CONSTANT )
builder . appendPrefix ( STRING_CONSTANT ) . appendPrefix ( STRING_CONSTANT , STRING_CONSTANT )
if ( periodStr . regionMatches ( false , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
if ( periodStr . regionMatches ( true , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
synchronized ( cDefaultLock ) { cDefault = zone ; }
{ return iZoneInfoKeys ; }
public Set < String > getAvailableIDs () { return AVAILABLE_IDS ; }
public static Set < String > getAvailableIDs () { return getProvider () . getAvailableIDs () ; }
DateTimeZone zone = getProvider () . getZone ( id ) ;
assertEquals ( zone , result ) ;
int curMonth0 = values [ NUMBER_CONSTANT ] - NUMBER_CONSTANT ;
if ( ZoneInfoLogger . verbose () ) { System.out . println ( STRING_CONSTANT + tz . getID () ) ; }
ZoneInfoLogger . set ( verbose ) ;
Interval interval = new Interval ( start , end , getChronology () ) ;
int compare = csCompare ( text , position , value ) ;
{ return FieldUtils . safeSubtract ( getEndMillis () , getStartMillis () ) ; }
{ millis = iField . setExtended ( millis , iValue ) ; }
str = str . toLowerCase ( Locale.ENGLISH ) ;
DateTimeFormatter fmt = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.ENGLISH ) ;
assertEquals ( STRING_CONSTANT , str . toUpperCase ( Locale.ENGLISH ) ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.ENGLISH ) ;
{ Provider provider = new ZoneInfoProvider ( DEFAULT_TZ_DATA_PATH ) ; return validateProvider ( provider ) ; }
{ return getCumPct ( Character . valueOf ( v ) ) ; }
{ return getCumFreq ( Character . valueOf ( v ) ) ; }
{ return getPct ( Character . valueOf ( v ) ) ; }
{ return getCount ( Character . valueOf ( v ) ) ; }
public IntegratorException ( final Throwable cause ) { super ( cause ) ; }
final double initialStepSize
final SecondOrderDifferentialEquations equations
public DerivativeException ( final Throwable cause ) { super ( cause ) ; }
{ super ( STRING_CONSTANT , c , a , b , new EulerStepInterpolator () , step ) ; }
super ( METHOD_NAME , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( METHOD_NAME , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
{ super ( STRING_CONSTANT , c , a , b , new GillStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , c , a , b , new ClassicalRungeKuttaStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , c , a , b , new MidpointStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , c , a , b , new ThreeEighthesStepInterpolator () , step ) ; }
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( new VariableHandler () ) ;
integ . addStepHandler ( new KeplerHandler ( pb ) ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( new KeplerHandler ( pb ) ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( new VariableHandler () ) ;
integ . addStepHandler ( new KeplerHandler ( pb ) ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
stepHandlers = new ArrayList < StepHandler > () ;
integ . addStepHandler ( new VariableStepHandler () ) ;
integ . addStepHandler ( new KeplerStepHandler ( pb ) ) ;
integrator . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( new KeplerStepHandler ( pb ) ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( new KeplerHandler ( pb ) ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( cm ) ;
integ . addStepHandler ( new KeplerHandler ( pb ) ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
ODEIntegrator integrator
createRegression () . newSampleData ( y , x , omega ) ;
createRegression () . newSampleData ( y , x , omega ) ;
CombinedEventsManager manager = addEndTimeChecker ( t0 , t , eventsHandlersManager ) ;
CombinedEventsManager manager = addEndTimeChecker ( t0 , t , eventsHandlersManager ) ;
{ maxValueError = NUMBER_CONSTANT ; maxTimeError = NUMBER_CONSTANT ; lastError = NUMBER_CONSTANT ; expectedStepStart = Double.NaN ; }
CompositeFormat cf = new ComplexFormat () ;
CompositeFormat cf = ComplexFormat . getInstance ( getLocale () ) ;
stepSize = forward ? step : - step ;
this . step = Math . abs ( step ) ;
stepSize = forward ? step : - step ;
this . step = Math . abs ( step ) ;
this . step = Math . abs ( step ) ;
{ if ( qrt == null ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ System . arraycopy ( b [ i ] , NUMBER_CONSTANT , root . getDataRef () [ index [ i ] ] , NUMBER_CONSTANT , rank ) ; }
{ new QRDecompositionImpl () . isNonSingular () ; fail ( STRING_CONSTANT ) ; }
if ( ! isNonSingular () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! isNonSingular () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
cachedQT == null
RealMatrix sse = u . transpose () . multiply ( getOmegaInverse () ) . multiply ( u ) ;
{ RealMatrix XTX = X . transpose () . multiply ( X ) ; return new LUDecompositionImpl ( XTX ) . getInverse () ; }
catch ( IndexOutOfBoundsException e ) { checkIndex ( index ) ; }
if ( singular ) { throw new SingularMatrixException () ; }
if ( singular ) { throw new SingularMatrixException () ; }
if ( singular ) { throw new SingularMatrixException () ; }
if ( ! matrix . isSquare () ) { throw new NonSquareMatrixException ( matrix . getRowDimension () , matrix . getColumnDimension () ) ; }
if ( ! isSquare () ) { throw new NonSquareMatrixException ( getRowDimension () , getColumnDimension () ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
if ( ! matrix . isSquare () ) { throw new NonSquareMatrixException ( matrix . getRowDimension () , matrix . getColumnDimension () ) ; }
if ( ! isNonSingular () ) { throw new RankDeficientMatrixException () ; }
if ( ! isNonSingular () ) { throw new RankDeficientMatrixException () ; }
MatrixIndexException ex = new MatrixIndexException ( msg , new Object [ NUMBER_CONSTANT ] ) ;
throw new MathRuntimeException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ;
catch ( Exception e ) { throw new MathRuntimeException ( e ) ; }
{ return arguments . clone () ; }
{ super(); this . pattern = null ; this . arguments = null ; }
{ return arguments . clone () ; }
assertEquals ( NUMBER_CONSTANT , ex . getMessage ( Locale.FRENCH ) . length () ) ;
{ throw new InvalidMatrixException ( STRING_CONSTANT , null ) ; }
assertEquals ( NUMBER_CONSTANT , ex . getMessage ( Locale.FRENCH ) . length () ) ;
InvalidMatrixException ex = new InvalidMatrixException ( msg , null ) ;
MatrixIndexException ex = new MatrixIndexException ( msg , null ) ;
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( o == null ) { throw new MathException ( STRING_CONSTANT , null ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , null ) ; }
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT , null ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT , null ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
throw new MathRuntimeException ( STRING_CONSTANT , null ) ;
public Double getZ () { throw new MathRuntimeException ( STRING_CONSTANT , null ) ; }
{ super(); this . pattern = null ; this . arguments = new Object [ NUMBER_CONSTANT ] ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( Exception e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( Exception e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( Exception e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( IOException ioe ) { assertEquals ( NUMBER_CONSTANT , ioe . getMessage () . length () ) ; }
catch ( IOException ioe ) { assertEquals ( NUMBER_CONSTANT , ioe . getMessage () . length () ) ; }
{ if ( resultComputed ) { return iterationCount ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ if ( lu == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT + STRING_CONSTANT , null ) ; } }
{ if ( resultComputed ) { return iterationCount ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ if ( qrt == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
if ( ! loaded ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; }
{ throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; }
assertEquals ( NUMBER_CONSTANT , vTv . subtract ( id ) . getNorm () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
{ assertEquals ( refValues [ i ] , eigenValues [ i ] , NUMBER_CONSTANT ) ; }
transformer = null ;
public int [] getPivot ( ) throws IllegalStateException { return pivot ; }
public double getNorm ( ) throws InvalidMatrixException { return singularValues [ NUMBER_CONSTANT ] ; }
public double [] getSingularValues ( ) throws InvalidMatrixException { return singularValues . clone () ; }
ds = null ;
ds = null ;
{ copyIn ( d ) ; ds = null ; }
ds = null ;
{ return eigenvalues [ i ] ; }
public double [] getEigenvalues ( ) throws InvalidMatrixException { return eigenvalues . clone () ; }
EigenDecomposition ed = new DecompositionSolver ( distinct ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( repeated ) . eigenDecompose () ;
RealMatrix v = new DecompositionSolver ( matrix ) . eigenDecompose () . getV () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new EigenDecompositionImpl ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
lu = null ;
lu = null ;
{ copyIn ( d ) ; lu = null ; }
lu = null ;
EigenDecomposition ed = new EigenDecompositionImpl ( distinct , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( repeated , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( m , MathUtils.SAFE_MIN ) ;
RealMatrix v = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) . getV () ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
public DescriptiveStatistics ( int window ) { setWindowSize ( window ) ; }
{ return stat . evaluate ( eDA . getInternalValues () , eDA . start () , eDA . getNumElements () ) ; }
final double [] [] in
final RealVectorImpl v
final double [] v
final RealMatrixImpl m
final RealMatrixImpl m
final RealMatrixImpl m
final double [] v
UnivariateRealSolver solver = factory . newSecantSolver () ;
UnivariateRealSolver solver = factory . newBrentSolver () ;
UnivariateRealSolver solver = factory . newNewtonSolver () ;
UnivariateRealSolver solver = factory . newBisectionSolver () ;
{ setup ( f ) ; return factory . newDefaultSolver () . solve ( f , x0 , x1 ) ; }
try { iterator . advance () ; fail ( STRING_CONSTANT ) ; } catch ( ConcurrentModificationException cme ) {}
RealMatrix covRM = MatrixUtils . createRealMatrix ( cov ) ;
{ this . Omega = MatrixUtils . createRealMatrix ( omega ) ; this . OmegaInverse = null ; }
cachedV = transformer . getV () . multiply ( MatrixUtils . createRealMatrix ( iData ) ) ;
cachedU = transformer . getU () . multiply ( MatrixUtils . createRealMatrix ( iData ) ) ;
RealMatrix matrix = MatrixUtils . createRealMatrix ( testSquare ) ;
return MatrixUtils . createRealMatrix ( xData ) ;
{ this . X = MatrixUtils . createRealMatrix ( x ) ; }
{ this . Y = new RealVectorImpl ( y ) ; }
@ Test ( expected = ArrayIndexOutOfBoundsException . class )
RealMatrix m_outerProduct = v1 . outerProduct ( v2 ) ;
return MatrixUtils . createRealMatrix ( dData ) ;
return MatrixUtils . createRealMatrix ( data ) ;
{ this . X = new DenseRealMatrix ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
RealMatrix matrix = MatrixUtils . createRealMatrix ( testData ) ;
RealMatrix matrix = MatrixUtils . createRealMatrix ( testData ) ;
RealMatrix matrix = MatrixUtils . createRealMatrix ( testData ) ;
RealMatrix matrix = MatrixUtils . createRealMatrix ( testData ) ;
return MatrixUtils . createRealMatrix ( bp ) ;
return MatrixUtils . createRealMatrix ( invData ) ;
return MatrixUtils . createRealMatrix ( bp ) ;
{ return solver . solve ( b ) ; }
{ this . solver = decomposition . getSolver () ; }
assertFalse ( solver . isNonSingular () ) ;
{ this . Omega = new RealMatrixImpl ( omega ) ; this . OmegaInverse = null ; }
{ this . X = new RealMatrixImpl ( x ) ; }
{ this . Y = new RealMatrixImpl ( y ) ; }
@ Test ( expected = IllegalArgumentException . class )
{ this . X = new RealMatrixImpl ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
return new RealMatrixImpl ( data , false ) ;
boolean isSingular ( ) ;
return MatrixUtils . createRealMatrix ( data ) ;
{ this . solver = decomposition . getSolver () ; }
{ eigenvectors [ i ] = findEigenvector ( realEigenvalues [ i ] , d , l ) ; }
{ realEigenvalues [ index ] = main [ index ] ; }
{ if ( eigenvectors == null ) { findEigenVectors () ; } return new Solver ( realEigenvalues , eigenvectors ) ; }
{ double determinant = NUMBER_CONSTANT ; for ( double lambda : realEigenvalues ) { determinant *= lambda ; } return determinant ; }
{ if ( cachedD == null ) { cachedD = MatrixUtils . createRealDiagonalMatrix ( realEigenvalues ) ; } return cachedD ; }
double [] observed = ed . getRealEigenvalues () ;
double lambda = ed . getRealEigenvalue ( i ) ;
double [] eigenValues = ed . getRealEigenvalues () ;
double [] eigenValues = ed . getRealEigenvalues () ;
double [] eigenValues = ed . getRealEigenvalues () ;
assertEquals ( NUMBER_CONSTANT , ed . getRealEigenvalue ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
singularValues = eigenDecomposition . getRealEigenvalues () ;
{ if ( eigenvectors == null ) { findEigenVectors () ; } return new Solver ( realEigenvalues , imagEigenvalues , eigenvectors ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
{ return FastFourierTransformer . scaleArray ( fht ( f ) , NUMBER_CONSTANT / f.length ) ; }
{ OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap () ; assertTrue ( Double . isNaN ( map . remove ( NUMBER_CONSTANT ) ) ) ; }
this . entries = new OpenIntToDoubleHashMap ( NUMBER_CONSTANT ) ;
double previous = missingEntries ;
values [ index ] = missingEntries ;
return new LUDecompositionImpl ( XTX ) . getSolver () . getInverse () ;
assertEquals ( new DenseRealMatrix ( reference ) , new DenseRealMatrix ( sub ) ) ;
assertEquals ( new DenseRealMatrix ( reference ) , new DenseRealMatrix ( sub ) ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
assertEquals ( new DenseRealMatrix ( reference ) , sub ) ;
assertEquals ( new DenseRealMatrix ( reference ) , sub ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
rDiag = new double [ Math . min ( m , n ) ] ;
return new LUDecompositionImpl ( XTOIX ) . getSolver () . getInverse () ;
private double getDeterminant ( RealMatrix m ) { return new LUDecompositionImpl ( m ) . getDeterminant () ; }
{ if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; } }
if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; }
if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; }
if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; }
if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; }
{ clearResult () ; return localMin ( min , max , relativeAccuracy , absoluteAccuracy , f ) ; }
TestUtils . assertSame ( Float.NaN , MathUtils . sign ( Float.NaN ) ) ;
{ vals [ i ] = values [ i ] . doubleValue () ; }
roots . computeOmega ( - f.length ) ;
roots . computeOmega ( - f.length ) ;
roots . computeOmega ( f.length ) ;
{ roots . computeOmega ( f.length ) ; return fft ( f ) ; }
{ setSubVector ( index , v.data ) ; }
{ for ( int i = NUMBER_CONSTANT ; i < virtualSize ; i ++ ) { setEntry ( i , value ) ; } }
{ setEntry ( i , Math . log ( getEntry ( i ) ) ) ; }
{ setEntry ( i , Math . log10 ( getEntry ( i ) ) ) ; }
{ setEntry ( i , NUMBER_CONSTANT / getEntry ( i ) ) ; }
{ setEntry ( i , getEntry ( i ) + d ) ; }
{ setEntry ( i , Math . acos ( getEntry ( i ) ) ) ; }
{ res . setEntry ( i + virtualSize , a [ i ] ) ; }
{ RealVector res = new SparseRealVector ( this , NUMBER_CONSTANT ) ; res . setEntry ( virtualSize , d ) ; return res ; }
w . setEntry ( i , w . getEntry ( i ) / si ) ;
TestUtils . assertEquals ( STRING_CONSTANT , m3 . multiply ( m4 ) , m5 , entryTolerance ) ;
FunctionEvaluationException ex = new FunctionEvaluationException ( cause , NUMBER_CONSTANT ) ;
FunctionEvaluationException ex = new FunctionEvaluationException ( cause , NUMBER_CONSTANT , pattern , arguments ) ;
{ super ( STRING_CONSTANT , rows , columns ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
MathException ex = new MathException ( cause , pattern , arguments ) ;
if ( b.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( ! isSquare () ) { throw new NonSquareMatrixException ( getRowDimension () , getColumnDimension () ) ; }
final Object . . . arguments
if ( isZero ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( numElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( STRING_CONSTANT ) ; }
{ return buildMessage ( locale , pattern , arguments ) ; }
catch ( DerivativeException de ) { throw new MathRuntimeException ( de , STRING_CONSTANT ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
catch ( ClassCastException cce ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
ConvergenceException ex = new ConvergenceException ( cause , pattern , arguments ) ;
Object . . . parts
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
final Object . . . parts
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
MathConfigurationException ex = new MathConfigurationException ( cause , pattern , arguments ) ;
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT ) ; }
Object . . . arguments
{ super ( isCardan ? STRING_CONSTANT : STRING_CONSTANT ) ; }
final Object . . . arguments
catch ( DimensionMismatchException dme ) { throw new MathRuntimeException ( dme , STRING_CONSTANT ) ; }
final Object . . . parts
final Object . . . parts
Object . . . parts
Object . . . arguments
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
{ return buildMessage ( locale , pattern , arguments ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return isForward ; }
Object . . . arguments
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
Object . . . arguments
public Double getZ () { throw new MathRuntimeException ( STRING_CONSTANT ) ; }
MatrixIndexException ex = new MatrixIndexException ( msg ) ;
{ throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , data.length , n ) ; } }
if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
while ( iter . hasNext () ) { iter . advance () ; if ( Double . isNaN ( iter . value () ) ) { return true ; } }
while ( iter . hasNext () ) { iter . advance () ; if ( Double . isInfinite ( iter . value () ) ) { return true ; } }
if ( delta > max ) { max = delta ; }
{ this ( values , DEFAULT_ZERO_TOLERANCE ) ; }
epsilon = v . getEpsilon () ;
public void setConvergenceChecker ( ScalarConvergenceChecker checker ) { optimizer . setConvergenceChecker ( checker ) ; }
final ScalarOptimizer optimizer
final VectorialObjectiveFunction function
final VectorialObjectiveFunction function
final VectorialObjectiveFunction function
final Comparator < ScalarPointValuePair > comparator
public void setConvergenceChecker ( ScalarConvergenceChecker checker ) { this . checker = checker ; }
final double residual = residuals [ i ] ;
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , buildArray ( m , factor ) , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , buildChebyquadArray ( n , factor ) , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , buildArray ( n , x0 ) , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; if ( theoreticalStartCost > NUMBER_CONSTANT ) { setCostAccuracy ( NUMBER_CONSTANT ) ; setParamsAccuracy ( NUMBER_CONSTANT ) ; } }
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; if ( theoreticalStartCost > NUMBER_CONSTANT ) { setCostAccuracy ( NUMBER_CONSTANT ) ; setParamsAccuracy ( NUMBER_CONSTANT ) ; } }
{ super ( NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , x0 ) , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
{ super ( NUMBER_CONSTANT , startParams , NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
{ super ( m , buildArray ( n , x0 ) , theoreticalMinCost , null ) ; }
optimizer . setMaxIterations ( maxCostEval ) ;
++ jacobianEvaluations ;
{ setConvergenceChecker ( new SimpleVectorialValueChecker () ) ; setMaxIterations ( DEFAULT_MAX_ITERATIONS ) ; }
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
{ super ( cause , pattern , arguments ) ; this . argument = new double [] { argument } ; }
{ super ( cause ) ; this . argument = new double [] { argument } ; }
{ super ( pattern , arguments ) ; this . argument = new double [] { argument } ; }
assertEquals ( NUMBER_CONSTANT , ex . getArgument () [ NUMBER_CONSTANT ] , NUMBER_CONSTANT ) ;
assertEquals ( Math.PI , ex . getArgument () [ NUMBER_CONSTANT ] , NUMBER_CONSTANT ) ;
final MultivariateVectorialFunction function
public void setConvergenceChecker ( RealConvergenceChecker checker ) { this . checker = checker ; }
catch ( FunctionEvaluationException fe ) { assertTrue ( exceptionExpected ) ; }
{ if ( numerator == NUMBER_CONSTANT ) { return ZERO ; } return new BigFraction ( numerator , denominator ) ; }
public FractionFormat () {}
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . wholeFormat = format ; }
{ return subtract ( BigInteger . valueOf ( l ) ) ; }
{ return subtract ( BigInteger . valueOf ( i ) ) ; }
{ return multiply ( BigInteger . valueOf ( l ) ) ; }
{ return multiply ( BigInteger . valueOf ( i ) ) ; }
{ return add ( BigInteger . valueOf ( l ) ) ; }
{ return add ( BigInteger . valueOf ( i ) ) ; }
final ArrayList < BigFraction > coefficients
assertEquals ( ci , l40 [ i ] , Math . abs ( ci ) * NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , new BigFraction ( Double . longBitsToDouble ( NUMBER_CONSTANT ) ) . getNumeratorAsLong () ) ;
@ Override protected Locale getLocale () { return Locale.US ; }
@ Override protected Locale getLocale () { return Locale.US ; }
@ Override protected Locale getLocale () { return Locale.FRENCH ; }
@ Override protected Locale getLocale () { return Locale.US ; }
@ Override protected String getResourceName () { return STRING_CONSTANT ; }
@ Override protected String getResourceName () { return STRING_CONSTANT ; }
@ Override protected Locale getLocale () { return Locale.FRENCH ; }
@ Override protected Locale getLocale () { return Locale.FRENCH ; }
UnivariateRealSolver solver = LazyHolder.FACTORY . newDefaultSolver () ;
{ setup ( f ) ; return LazyHolder.FACTORY . newDefaultSolver () . solve ( f , x0 , x1 ) ; }
{ logSum += Math . log ( i ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
double n = length ;
{ return contents . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
double degreesOfFreedom = ( n1 + n2 - NUMBER_CONSTANT ) ;
{ dest.sumOfLogs = source.sumOfLogs . copy () ; }
{ return Math . exp ( sumOfLogs . evaluate ( values , begin , length ) / length ) ; }
{ return Math . exp ( sumOfLogs . getResult () / sumOfLogs . getN () ) ; }
{ return meanImpl . clone () ; }
{ return geoMeanImpl . clone () ; }
{ return sumLogImpl . clone () ; }
{ return maxImpl . clone () ; }
{ return minImpl . clone () ; }
{ return sumSqImpl . clone () ; }
{ return sumImpl . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
double n0 = n ;
{ dest.moment = source.moment . copy () ; dest.incMoment = source.incMoment ; }
double n0 = n ;
{ result [ i - NUMBER_CONSTANT ] = i * coefficients [ i ] ; }
{ dest.incMoment = source.incMoment ; dest.moment = source.moment . copy () ; }
double sampleSize = length ;
{ return ( sumY - slope * sumX ) / ( n ) ; }
Math . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / n ) + ( xbar * xbar ) / sumXX ) )
{ if ( n < NUMBER_CONSTANT ) { return Double.NaN ; } return getSumSquaredErrors () / ( n - NUMBER_CONSTANT ) ; }
{ dest.moment = source.moment . copy () ; dest.isBiasCorrected = source.isBiasCorrected ; dest.incMoment = source.incMoment ; }
double len = length ;
double n0 = n ;
{ return sumDifference ( sample1 , sample2 ) / sample1.length ; }
{ return map . get ( key ) ; }
{ dest.moment = new ThirdMoment ( source.moment . copy () ) ; dest.incMoment = source.incMoment ; }
{ dest.variance = source.variance . copy () ; }
return sum / v.length ;
catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( asBigDecimal ( testVector ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . getTrace () . doubleValue () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) {}
catch ( InvalidMatrixException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ super ( problem ) ; a = problem.a ; y = problem.y . clone () ; }
return Math . sqrt ( sum / v.length ) ;
{ super ( problem ) ; e = problem.e ; y = problem.y . clone () ; }
{ super ( problem ) ; y = problem.y . clone () ; }
{ dY [ i ] = y [ i ] ; }
{ dX [ i ] = x [ i ] ; }
{ super ( problem ) ; y = problem.y . clone () ; }
try { randomData . nextExponential ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { randomData . nextSecureInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { randomData . nextSecureLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { randomData . nextLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { randomData . nextInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) {}
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
final SimplexTableau tableau = new SimplexTableau ( f , constraints , goalType , restrictToNonNegative , epsilon ) ;
SimplexTableau tableau = new SimplexTableau ( f , constraints , GoalType.MAXIMIZE , false , NUMBER_CONSTANT ) ;
SimplexTableau tableau = new SimplexTableau ( f , constraints , GoalType.MAXIMIZE , false , NUMBER_CONSTANT ) ;
{ return ( sumY - slope * sumX ) / n ; }
Math . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / ( double ) n ) + ( xbar * xbar ) / sumXX ) )
Math . sqrt ( ( accum - ( Math . pow ( accum2 , NUMBER_CONSTANT ) / length ) ) / ( length - NUMBER_CONSTANT ) )
double degreesOfFreedom = n1 + n2 - NUMBER_CONSTANT ;
{ checkSufficientData ( matrix ) ; nObs = matrix . getRowDimension () ; correlationMatrix = computeCorrelationMatrix ( matrix ) ; }
{ checkSufficientData ( matrix ) ; n = matrix . getRowDimension () ; covarianceMatrix = computeCovarianceMatrix ( matrix , biasCorrected ) ; }
catch ( IllegalStateException ex ) {}
{ try { vs . getNext () ; fail ( STRING_CONSTANT ) ; } catch ( IllegalStateException ex ) {} }
try { testGenerator . nextInt ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { regression . getSlopeConfidenceInterval ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
Iterator < > it = f . valuesIterator () ;
final T [] out = buildArray ( field , nCols ) ;
final T [] out = buildArray ( field , nCols ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nCols ) ;
final T [] [] data = buildArray ( field , getRowDimension () , getColumnDimension () ) ;
final T [] [] out = buildArray ( getField () , nRows , getColumnDimension () ) ;
final T [] out = buildArray ( getField () , nCols ) ;
final T [] out = buildArray ( getField () , nRows ) ;
data = buildArray ( getField () , subMatrix.length , nCols ) ;
final T [] [] outData = buildArray ( getField () , nRows , nCols ) ;
final T [] [] outData = buildArray ( getField () , rowCount , columnCount ) ;
final T [] [] outData = buildArray ( getField () , rowCount , columnCount ) ;
{ return ( FieldVectorImpl < T > ) subtract ( v.data ) ; }
{ return ( FieldVectorImpl < T > ) add ( v.data ) ; }
super ( extractField ( v ) ) ;
super ( extractField ( d ) ) ;
{ super ( extractField ( d ) ) ; copyIn ( d ) ; }
nextAction = handler . eventOccurred ( t , y , ! ( increasing ^ forward ) ) ;
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
return res ;
if ( Double . doubleToLongBits ( test ) != Double . doubleToLongBits ( getEntry ( iter . key () ) ) ) { return false ; }
double [] hatResiduals = I . subtract ( hat ) . operate ( model.Y ) . getData () ;
if ( mean.length != standardDeviation.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean.length , standardDeviation.length ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
MatrixUtils . checkColumnIndex ( this , col ) ;
MatrixUtils . checkColumnIndex ( this , col ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
MatrixUtils . checkMultiplicationCompatible ( this , m ) ;
MatrixUtils . checkMultiplicationCompatible ( this , m ) ;
MatrixUtils . checkAdditionCompatible ( this , m ) ;
MatrixUtils . checkAdditionCompatible ( this , m ) ;
if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
if ( r < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , r ) ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ;
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( trials < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , trials ) ; } numberOfTrials = trials ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , windowSize ) ; } }
{ this . Y = new RealVectorImpl ( y ) ; }
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkMultiplicationCompatible ( this , m ) ;
MatrixUtils . checkSubtractionCompatible ( this , m ) ;
MatrixUtils . checkAdditionCompatible ( this , m ) ;
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . degreesOfFreedom = degreesOfFreedom ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; } this . mean = mean ; }
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkSubMatrixIndex ( this , selectedRows , selectedColumns ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , selectedRows , selectedColumns ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkMultiplicationCompatible ( this , m ) ;
MatrixUtils . checkSubtractionCompatible ( this , m ) ;
MatrixUtils . checkAdditionCompatible ( this , m ) ;
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
catch ( ClassCastException ex ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getClass () . getName () ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getClass () . getName () ) ; }
if ( p <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
{ if ( size < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , size ) ; } sampleSize = size ; }
{ if ( size <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , size ) ; } populationSize = size ; }
{ if ( num < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , num ) ; } numberOfSuccesses = num ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ;
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . alpha = alpha ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( sd <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , sd ) ; } standardDeviation = sd ; }
if ( n < NUMBER_CONSTANT || n != sample2.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n , sample2.length ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( mean < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; }
if ( sigma <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , sigma ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , len ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , len ) ; }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , s ) ; } scale = s ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . alpha = alpha ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( successes < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , successes ) ; } numberOfSuccesses = successes ; }
{ if ( realFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . realFormat = realFormat ; }
{ if ( imaginaryFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . imaginaryFormat = imaginaryFormat ; }
if ( imaginaryCharacter == null || imaginaryCharacter . length () == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ; }
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkSubMatrixIndex ( this , row , endRow , column , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkMultiplicationCompatible ( this , m ) ;
MatrixUtils . checkMultiplicationCompatible ( this , m ) ;
MatrixUtils . checkSubtractionCompatible ( this , m ) ;
MatrixUtils . checkSubtractionCompatible ( this , m ) ;
MatrixUtils . checkAdditionCompatible ( this , m ) ;
MatrixUtils . checkAdditionCompatible ( this , m ) ;
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
Comparable < > obj1 = null ;
OpenMapRealVector v1 = new OpenMapRealVector ( vec1 ) ;
return new OpenMapRealVector ( out ) ;
{ assertEquals ( expected [ i ] , observed [ i ] , tolerance ) ; }
final int dimension = ( currentState == null ) ? - NUMBER_CONSTANT : currentState.length ;
final int dimension = ( currentState == null ) ? - NUMBER_CONSTANT : currentState.length ;
final StepInterpolator prototype
computeDerivatives ( t0 + h , y1 , yDot1 ) ;
integrator = null ;
integrator = null ;
{ super(); yDotK = null ; integrator = null ; }
interpolator . reinitialize ( new DummyIntegrator ( interpolator ) , y , yDot , true ) ;
interpolator . reinitialize ( new DummyIntegrator ( interpolator ) , y , yDot , true ) ;
interpolator . reinitialize ( new DummyIntegrator ( interpolator ) , y , yDot , true ) ;
RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ;
{ return computeCorrelationMatrix ( new BlockRealMatrix ( data ) ) ; }
RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ;
return new BlockRealMatrix ( out ) ;
return new BlockRealMatrix ( out ) ;
{ this ( new BlockRealMatrix ( data ) ) ; }
assertClose ( STRING_CONSTANT , m . multiply ( new BlockRealMatrix ( testDataInv ) ) , identity , entryTolerance ) ;
RealMatrix mA = new BlockRealMatrix ( a ) ;
assertEquals ( MatrixUtils . createColumnRealMatrix ( col ) , new BlockRealMatrix ( colMatrix ) ) ;
assertEquals ( MatrixUtils . createRowRealMatrix ( row ) , new BlockRealMatrix ( rowMatrix ) ) ;
assertEquals ( new BlockRealMatrix ( testData ) , MatrixUtils . createRealMatrix ( testData ) ) ;
{ return computeCovarianceMatrix ( new BlockRealMatrix ( data ) , biasCorrected ) ; }
RealMatrix outMatrix = new BlockRealMatrix ( dimension , dimension ) ;
{ this ( new BlockRealMatrix ( data ) , biasCorrected ) ; }
{ this . factors = new BlockRealMatrix ( factors ) ; this . target = target ; }
{ BlockRealMatrix m = new BlockRealMatrix ( testData ) ; assertEquals ( m , TestUtils . serializeAndRecover ( m ) ) ; }
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
assertEquals ( new BlockRealMatrix ( reference ) , new BlockRealMatrix ( sub ) ) ;
assertEquals ( new BlockRealMatrix ( reference ) , new BlockRealMatrix ( sub ) ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
assertEquals ( new BlockRealMatrix ( reference ) , sub ) ;
assertEquals ( new BlockRealMatrix ( reference ) , sub ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( testData ) ;
RealMatrix m = new BlockRealMatrix ( testData ) ;
RealMatrix m = new BlockRealMatrix ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return computeCorrelationMatrix ( new BlockRealMatrix ( data ) ) ; }
{ this . factors = new BlockRealMatrix ( factors ) ; this . target = target ; }
RealMatrix result = new BlockRealMatrix ( dimension , dimension ) ;
return new BlockRealMatrix ( matrixData ) ;
{ this . factors = new BlockRealMatrix ( factors ) ; this . target = target ; }
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
assertEquals ( new BlockFieldMatrix < Fraction > ( reference ) , sub ) ;
assertEquals ( new BlockFieldMatrix < Fraction > ( reference ) , sub ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
decompMatrix = new Array2DRowRealMatrix ( decomp ) ;
return new Array2DRowFieldMatrix < Fraction > ( out ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
return new ArrayFieldVector < Fraction > ( data , false ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
assertEquals ( new Array2DRowFieldMatrix < Fraction > ( reference ) , sub ) ;
assertEquals ( new Array2DRowFieldMatrix < Fraction > ( reference ) , sub ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < T > identity = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
return new Array2DRowFieldMatrix < T > ( bp , false ) ;
cachedP = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
cachedU = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
cachedL = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
return new Array2DRowRealMatrix ( bp , false ) ;
{ this ( new ArrayRealVector ( coefficients ) , constantTerm ) ; }
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
final RealMatrix matrix = new Array2DRowRealMatrix ( data , false ) ;
final RealVector vector = new ArrayRealVector ( data , false ) ;
RealMatrix getConvertedMatrix () { return new Array2DRowRealMatrix ( data , false ) ; }
RealMatrix getConvertedMatrix () { return new Array2DRowRealMatrix ( data , false ) ; }
{ return new ArrayFieldVector < T > ( data , true ) ; }
{ return new ArrayRealVector ( data , true ) ; }
return new Array2DRowFieldMatrix < T > ( d , false ) ;
new Array2DRowFieldMatrix < T > ( data )
new Array2DRowFieldMatrix < T > ( field , rows , columns )
this . coefficients = new ArrayRealVector ( sub , false ) ;
{ this ( new ArrayRealVector ( coefficients ) , relationship , value ) ; }
this . tableau = new Array2DRowRealMatrix ( matrix ) ;
this . tableau = new Array2DRowRealMatrix ( createTableau ( goalType == GoalType.MAXIMIZE ) ) ;
return new ArrayRealVector ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
{ this . Omega = new Array2DRowRealMatrix ( omega ) ; this . OmegaInverse = null ; }
{ setColumn ( column , ( ( ArrayFieldVector < T > ) vector ) . getDataRef () ) ; }
return new ArrayFieldVector < T > ( outData , false ) ;
{ setRow ( row , ( ( ArrayFieldVector < T > ) vector ) . getDataRef () ) ; }
return new ArrayFieldVector < T > ( outData , false ) ;
nordsieck = new Array2DRowRealMatrix ( nData , false ) ;
{ setColumn ( column , ( ( ArrayRealVector ) vector ) . getDataRef () ) ; }
return new ArrayRealVector ( outData , false ) ;
{ setRow ( row , ( ( ArrayRealVector ) vector ) . getDataRef () ) ; }
return new ArrayRealVector ( outData , false ) ;
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
RealVector lhs = new ArrayRealVector ( numCoefficients ) ;
{ es . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
return new Array2DRowRealMatrix ( x , false ) ;
{ this . X = new Array2DRowRealMatrix ( x ) ; }
{ this . Y = new ArrayRealVector ( y ) ; }
return new ArrayFieldVector < Fraction > ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayFieldVector < Fraction > ( testVector ) ) . getData () , entryTolerance ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix < Fraction > ( testDataInv ) ) , identity , entryTolerance ) ;
return new ArrayRealVector ( data , false ) ;
{ m . setColumnVector ( NUMBER_CONSTANT , new ArrayRealVector ( NUMBER_CONSTANT ) ) ; fail ( STRING_CONSTANT ) ; }
TestUtils . assertEquals ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
eigenvectors = new ArrayRealVector [ m ] ;
final ArrayRealVector v = eigenvectors [ i ] ;
final ArrayRealVector v = eigenvectors [ i ] ;
final ArrayRealVector [] eigenvectors
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ return new ArrayRealVector ( getColumn ( column ) , false ) ; }
{ return new ArrayRealVector ( getRow ( row ) , false ) ; }
return new Array2DRowRealMatrix ( matrixData ) ;
RealMatrix repeatedColumns = new Array2DRowRealMatrix ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
return new ArrayRealVector ( x ) ;
{ this . X = new Array2DRowRealMatrix ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
Array2DRowRealMatrix augI = new Array2DRowRealMatrix ( n , n ) ;
return new Array2DRowFieldMatrix < BigFraction > ( pData , false ) ;
FieldMatrix < BigFraction > bigMSupdate = bigMStoN . multiply ( new Array2DRowFieldMatrix < BigFraction > ( shiftedP , false ) ) ;
return coefficients.msToN . multiply ( new Array2DRowRealMatrix ( multistep , false ) ) ;
{ return new ArrayFieldVector < T > ( getColumn ( column ) , false ) ; }
{ return new ArrayFieldVector < T > ( getRow ( row ) , false ) ; }
{ super ( STRING_CONSTANT , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
return new Array2DRowFieldMatrix < BigFraction > ( pData , false ) ;
FieldMatrix < BigFraction > bigMSupdate = bigMStoN . multiply ( new Array2DRowFieldMatrix < BigFraction > ( shiftedP , false ) ) ;
return coefficients.msToN . multiply ( new Array2DRowRealMatrix ( multistep , false ) ) ;
RealMatrix triangularMatrix = new Array2DRowRealMatrix ( lowerTriangularMatrix ) ;
RealMatrix triangularMatrix = new Array2DRowRealMatrix ( lowerTriangularMatrix ) ;
solver . solve ( new Array2DRowRealMatrix ( m3 ) , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } ) ;
solver . decompose ( new Array2DRowRealMatrix ( m7 ) ) ;
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n , startConfiguration.length ) ; }
{ Arrays . fill ( after , NUMBER_CONSTANT ) ; }
f . set ( this , NordsieckTransformer . getInstance ( nSteps + NUMBER_CONSTANT ) ) ;
{ super ( STRING_CONSTANT , nSteps , nSteps , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
final Array2DRowRealMatrix nordsieck
if ( interpolator.nordsieck != null ) { nordsieck = new Array2DRowRealMatrix ( interpolator.nordsieck . getDataRef () , true ) ; }
nordsieck = initializeHighOrderDerivatives ( scaled , multistep ) ;
! ( original instanceof RandomKey < > )
TestProblem1 pb2 = pb1 . copy () ;
if ( ! ( another instanceof RandomKey < > ) ) return false ;
v instanceof SparseFieldVector < >
v instanceof SparseFieldVector < >
v instanceof SparseFieldVector < >
v instanceof SparseFieldVector < >
{ addMeasurement ( new LocalMeasurement ( this , x , y , w ) ) ; }
{ measurements [ i ] = new MinpackMeasurement ( this , i ) ; }
Comparable < > v
Comparable < > v
Comparable < > v
final double curN = current . getN () ;
StatisticalSummary observed
StatisticalSummary aggregatedStats = AggregateSummaryStatistics . aggregate ( aggregate ) ;
optimizer . setConvergenceChecker ( new SimpleRealPointChecker ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
optimizer . setConvergenceChecker ( new SimpleVectorialPointChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
final DescriptiveStatistics dstat = createDescriptiveStatistics () ;
DescriptiveStatistics stats = createDescriptiveStatistics () ;
DescriptiveStatistics stats = createDescriptiveStatistics () ;
MultivariateSummaryStatistics u = createMultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = createMultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = createMultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = createMultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = createMultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = createMultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
{ super ( m , startParams , theoreticalMinCost , theoreticalMinParams ) ; setCostAccuracy ( NUMBER_CONSTANT ) ; }
OpenMapRealVector res = copy () ;
OpenMapRealVector res = copy () ;
this . constraints = normalizeConstraints ( constraints ) ;
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new ThreeEighthesStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new GillStepInterpolator () , step ) ; }
return FACTORIALS [ n ] ;
public static DummyStepHandler getInstance () { return INSTANCE ; }
{ return PERCENTILE . evaluate ( values , begin , length , p ) ; }
{ return PERCENTILE . evaluate ( values , p ) ; }
{ return MIN . evaluate ( values , begin , length ) ; }
{ return MIN . evaluate ( values ) ; }
{ return MAX . evaluate ( values , begin , length ) ; }
{ return MAX . evaluate ( values ) ; }
{ return VARIANCE . evaluate ( values , mean ) ; }
{ return VARIANCE . evaluate ( values , mean , begin , length ) ; }
{ return VARIANCE . evaluate ( values , begin , length ) ; }
{ return VARIANCE . evaluate ( values ) ; }
{ return GEOMETRIC_MEAN . evaluate ( values , begin , length ) ; }
{ return GEOMETRIC_MEAN . evaluate ( values ) ; }
{ return MEAN . evaluate ( values , begin , length ) ; }
{ return MEAN . evaluate ( values ) ; }
{ return SUM_OF_LOGS . evaluate ( values , begin , length ) ; }
{ return SUM_OF_LOGS . evaluate ( values ) ; }
{ return PRODUCT . evaluate ( values , begin , length ) ; }
{ return PRODUCT . evaluate ( values ) ; }
{ return SUM_OF_SQUARES . evaluate ( values , begin , length ) ; }
{ return SUM_OF_SQUARES . evaluate ( values ) ; }
{ return SUM . evaluate ( values , begin , length ) ; }
{ return SUM . evaluate ( values ) ; }
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new EulerStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new ClassicalRungeKuttaStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new MidpointStepInterpolator () , step ) ; }
@ Override public Object [] [] getContents () { return CONTENTS . clone () ; }
try { alg = MessageDigest . getInstance ( STRING_CONSTANT ) ; } catch ( NoSuchAlgorithmException ex ) { throw MathRuntimeException . createInternalError ( ex ) ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . scale = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . shape = alpha ; }
final SimplexTableau tableau = new SimplexTableau ( function , linearConstraints , goal , nonNegative , epsilon ) ;
{ return row * columns + column ; }
@ Override public int getRowDimension () { return rows ; }
@ Override public int getColumnDimension () { return columns ; }
{ final double residual = residuals [ i ] ; chiSquare += residual * residual / residualsWeights [ i ] ; }
{ final double residual = residuals [ i ] ; criterion += residualsWeights [ i ] * residual * residual ; }
final double factor = - Math . sqrt ( residualsWeights [ i ] ) ;
{ return row * columns + column ; }
@ Override public int getRowDimension () { return rows ; }
@ Override public int getColumnDimension () { return columns ; }
catch ( NumberFormatException e ) { throw new MathException ( e , STRING_CONSTANT , e . getMessage () ) ; }
void resetRelativeAccuracy ( ) ;
double getRelativeAccuracy ( ) ;
void resetAbsoluteAccuracy ( ) ;
double getAbsoluteAccuracy ( ) ;
int getMaximalIterationCount ( ) ;
UnivariateMatrixFunction derivative ( ) ;
double getCurrentTime ( ) ;
double getPreviousTime ( ) ;
void reset ( ) ;
UnivariateVectorialFunction derivative ( ) ;
double getMean ( ) ;
double getSum ( ) ;
long getN ( ) ;
double getMin ( ) ;
double getMax ( ) ;
boolean isNaN ( ) ;
double getExponent ( ) ;
int getNumberOfElements ( ) ;
double fitness ( ) ;
int getSampleSize ( ) ;
int getPopulationSize ( ) ;
int getNumberOfSuccesses ( ) ;
int getDimension ( ) ;
int getDimension ( ) ;
UnivariateRealFunction derivative ( ) ;
long getN ( ) ;
int getDimension ( ) ;
final RandomGenerator generator
public static DummyStepHandler getInstance () { return LazyHolder.INSTANCE ; }
{ this . randomData = randomData ; }
{ correction += values [ i ] - xbar ; }
return anovaPValue ( categoryData ) < alpha ;
{ checkSignificanceLevel ( alpha ) ; return tTest ( sampleStats1 , sampleStats2 ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return homoscedasticTTest ( sample1 , sample2 ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return tTest ( sample1 , sample2 ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return tTest ( mu , sampleStats ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return tTest ( mu , sample ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return pairedTTest ( sample1 , sample2 ) < alpha ; }
final boolean forward = t > t0 ;
final boolean forward = t > t0 ;
i < getRowDimension ()
{ return o1 . compareTo ( ( T ) o2 ) ; }
return stdDev ;
double dx = x2 - x1 ;
return super . equals ( stat ) && aggregateStatistics . equals ( stat.aggregateStatistics ) ;
{ sum += values [ i ] * weights [ i ] ; }
public boolean isSquare () { return getColumnDimension () == getRowDimension () ; }
{ return internalArray ; }
{ return internalArray ; }
synchronized int getInternalLength () { return internalArray.length ; }
final boolean forward = t > t0 ;
public boolean isSquare () { return getColumnDimension () == getRowDimension () ; }
{ g0Positive = g0 >= NUMBER_CONSTANT ; nextAction = EventHandler.CONTINUE ; }
increasing = gb >= ga ;
{ t0 = tStart ; g0 = handler . g ( tStart , yStart ) ; g0Positive = g0 >= NUMBER_CONSTANT ; }
return stdDev ;
return isForward ? omegaImaginaryForward [ k ] : omegaImaginaryInverse [ k ] ;
isForward = n > NUMBER_CONSTANT ;
final boolean forward = t > t0 ;
forward = interpolator . getCurrentTime () >= lastTime ;
return chiSquareTestDataSetsComparison ( observed1 , observed2 ) < alpha ;
unequalCounts = countSum1 != countSum2 ;
return chiSquareTest ( counts ) < alpha ;
return chiSquareTest ( expected , observed ) < alpha ;
final boolean forward = t > t0 ;
Complex N1 = new Complex ( n - NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
while ( ! tableau . isOptimal () ) { doIteration ( tableau ) ; }
while ( ! tableau . isOptimal () ) { doIteration ( tableau ) ; }
Integer pivotRow = getPivotRow ( tableau , pivotCol ) ;
Assert . assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
tableau . dropPhase1Objective () ;
Assert . assertTrue ( fitResidualSum < noisyResidualSum ) ;
double [] bounds = ( ( EmpiricalDistributionImpl ) empiricalDistribution2 ) . getGeneratorUpperBounds () ;
{ if ( microsphereElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , microsphereElements ) ; } this . microsphereElements = microsphereElements ; }
{ if ( brightnessExponent < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , brightnessExponent ) ; } this . brightnessExponent = brightnessExponent ; }
if ( xval.length == NUMBER_CONSTANT || xval [ NUMBER_CONSTANT ] == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
super ( rootCause ) ;
super ( rootCause ) ;
catch ( IOException e ) { throw new MathRuntimeException ( e ) ; }
Math . sqrt ( MathUtils.TWO_PI * x )
double f = ( MathUtils.TWO_PI * x * ( n - x ) ) / n ;
double d = x - mu ;
flipAllIfWarranted ( deflatedEnd )
flipEveryOtherIfWarranted ( n ) ;
Assert . assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( DIMENSION_MISMATCH_MESSAGE , n , startConfiguration.length ) ; }
if ( steps [ j ] == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EQUAL_VERTICES_MESSAGE , j , j + NUMBER_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FRACTION ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FRACTION ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FRACTION ) ; }
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( OVERFLOW_MESSAGE , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( OUT_OF_RANGE_POINT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( WRONG_ORDER_ENDPOINTS_MESSAGE , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( WRONG_ORDER_ENDPOINTS_MESSAGE , x0 , x1 ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTH_MISMATCH_MESSAGE , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTH_MISMATCH_MESSAGE , b.length , m ) ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( MISSING_ROOTS_OF_UNITY_MESSAGE ) ; } return isForward ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( NOT_POWER_OF_TWO_MESSAGE , o.length ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( NOT_POWER_OF_TWO_MESSAGE , d.length ) ; } }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FUNCTION_MESSAGE ) ; } }
if ( function == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FUNCTION_MESSAGE ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
{ if ( BigInteger.ZERO . equals ( fraction.numerator ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; } return multiply ( fraction . reciprocal () ) ; }
if ( BigInteger.ZERO . equals ( bg ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; }
if ( BigInteger.ZERO . equals ( den ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREE_MESSAGE , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREE_MESSAGE , n ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POLYNOMIAL_FUNCTION_MESSAGE ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( NON_POLYNOMIAL_FUNCTION_MESSAGE ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( NON_FITTING_POSITION_AND_SIZE_MESSAGE , pos , size , d.length ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( NON_FITTING_POSITION_AND_SIZE_MESSAGE , pos , size , d.length ) ; }
{ super ( FAILED_EVALUATION_MESSAGE , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
{ super ( FAILED_EVALUATION_MESSAGE , argument ) ; this . argument = new double [] { argument } ; }
int negativeVarColumn = columnLabels . indexOf ( NEGATIVE_VAR_COLUMN_LABEL ) ;
if ( ! restrictToNonNegative ) { columnLabels . add ( NEGATIVE_VAR_COLUMN_LABEL ) ; }
int value = decoded . get ( i ) ;
if ( isDefaultValue ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
! isDefaultValue ( value )
{ this ( values , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
public OpenMapRealVector ( int dimension ) { this ( dimension , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
{ this ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
public void setEntry ( int index , double value ) throws MatrixIndexException { data [ index ] = value ; }
return mapDivide ( norm ) ;
public ArrayRealVector ( ArrayRealVector v ) { this ( v , true ) ; }
{ try { return mapToSelf ( ComposableFunction.ULP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TANH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SQRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SINH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIGNUM ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.RINT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG10 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.FLOOR ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXPM1 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.COSH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.COS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CEIL ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CBRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ATAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ACOS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ABS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG1P ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
Iterator < Entry > it = iterator () ;
epsilon = DEFAULT_ZERO_TOLERANCE ;
{ this ( values , DEFAULT_ZERO_TOLERANCE ) ; }
this . epsilon = epsilon ;
public OpenMapRealVector ( int dimension ) { this ( dimension , DEFAULT_ZERO_TOLERANCE ) ; }
{ this ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE ) ; }
{ return new BigReal ( d . divide ( a.d , scale , roundingMode ) ) ; }
return new ArrayRealVector ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
if ( lcm == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , a , b ) ; }
{ return new Solver ( singularValues , getUT () , getV () , getRank () == Math . max ( m , n ) ) ; }
@ Override public double getNorm () { throw unsupported () ; }
@ Override public double getL1Norm () { throw unsupported () ; }
@ Override public double getLInfNorm () { throw unsupported () ; }
@ Override public double getNorm () { throw unsupported () ; }
@ Override public double getL1Norm () { throw unsupported () ; }
@ Override public double getLInfNorm () { throw unsupported () ; }
{ dest.n = source.n ; dest.m1 = source.m1 ; dest.dev = source.dev ; dest.nDev = source.nDev ; }
{ new LoessInterpolator ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ new LoessInterpolator ( - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; }
assertEquals ( NUMBER_CONSTANT , solution . subtract ( xRef ) . getNorm () , NUMBER_CONSTANT ) ;
{ interpolator = new DummyStepInterpolator ( yTmp , yDotK [ stages - NUMBER_CONSTANT ] , forward ) ; }
{ interpolator = new DummyStepInterpolator ( yTmp , yDotK [ stages - NUMBER_CONSTANT ] , forward ) ; }
public BadStepInterpolator ( double [] y , boolean forward ) { super ( y , new double [ y.length ] , forward ) ; }
DummyStepInterpolator interpolator = new DummyStepInterpolator ( y , new double [ y.length ] , true ) ;
{ interpolator = new DummyStepInterpolator ( y , yDot1 , forward ) ; }
{ super ( interpolator ) ; currentDerivative = interpolator.currentDerivative . clone () ; }
{ super(); currentDerivative = null ; }
{ handler . handleStep ( new StepInterpolatorWrapper ( interpolator , n , k ) , isLast ) ; }
final ODEWithJacobians ode
{ this ( mean , sd , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ super ( f , DEFAULT_MAXIMUM_ITERATIONS , DEFAULT_ABSOLUTE_ACCURACY ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setTolerance ( defaultTolerance ) ; }
if ( p < NUMBER_CONSTANT ) { ret = mean ; } else { ret = Double.MAX_VALUE ; }
if ( p < NUMBER_CONSTANT ) { ret = - Double.MAX_VALUE ; } else { ret = mean ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - Math . pow ( x / scale , shape ) ) ; }
{ super(); setShapeInternal ( alpha ) ; setScaleInternal ( beta ) ; }
{ ret = Beta . regularizedBeta ( probabilityOfSuccess , numberOfSuccesses , x + NUMBER_CONSTANT ) ; }
{ super(); setNumberOfSuccessesInternal ( r ) ; setProbabilityOfSuccessInternal ( p ) ; }
public TDistributionImpl ( double degreesOfFreedom ) { super(); setDegreesOfFreedomInternal ( degreesOfFreedom ) ; }
{ if ( p < NUMBER_CONSTANT ) { return mean ; } else { return Double.MAX_VALUE ; } }
{ ret = - mean * Math . log ( NUMBER_CONSTANT - p ) ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - x / mean ) ; }
public ExponentialDistributionImpl ( double mean ) { super(); setMeanInternal ( mean ) ; }
if ( p < NUMBER_CONSTANT ) { ret = median ; } else { ret = Double.MAX_VALUE ; }
if ( p < NUMBER_CONSTANT ) { ret = - Double.MAX_VALUE ; } else { ret = median ; }
{ super(); setMedianInternal ( median ) ; setScaleInternal ( s ) ; }
double d = denominatorDegreesOfFreedom ;
{ super(); setNumeratorDegreesOfFreedomInternal ( numeratorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedomInternal ( denominatorDegreesOfFreedom ) ; }
{ return getUpperDomain ( sampleSize , numberOfSuccesses ) ; }
{ return getLowerDomain ( populationSize , numberOfSuccesses , sampleSize ) ; }
x < NUMBER_CONSTANT || x > numberOfTrials
{ return numberOfTrials ; }
{ super(); setNumberOfTrialsInternal ( trials ) ; setProbabilityOfSuccessInternal ( p ) ; }
if ( p < NUMBER_CONSTANT ) { ret = alpha * beta ; } else { ret = Double.MAX_VALUE ; }
{ ret = Gamma . regularizedGammaP ( alpha , x / beta ) ; }
{ super(); setAlphaInternal ( alpha ) ; setBetaInternal ( beta ) ; }
if ( x <= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else if ( x >= numberOfElements ) { return NUMBER_CONSTANT ; }
if ( x <= NUMBER_CONSTANT || x > numberOfElements ) { return NUMBER_CONSTANT ; }
{ setNumberOfElementsInternal ( numberOfElements ) ; setExponentInternal ( exponent ) ; }
{ return Double.MIN_VALUE * gamma . getBeta () ; }
{ return gamma . cumulativeProbability ( x ) ; }
public LaguerreSolver () { super ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; p = null ; }
{ this ( alpha , beta , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
protected void setDistribution ( AbstractContinuousDistribution distribution ) { this . distribution = distribution ; }
public TDistributionImpl ( double degreesOfFreedom ) { this ( degreesOfFreedom , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ this ( numeratorDegreesOfFreedom , denominatorDegreesOfFreedom , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ this ( alpha , beta , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
public ExponentialDistributionImpl ( double mean ) { this ( mean , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ this ( median , s , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
final double [] row = AINV [ i ] ;
{ p = interpolator . interpolate ( xval , wyval , wzval ) ; Assert . fail ( STRING_CONSTANT ) ; }
int length = TestUtils . eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = TestUtils . eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = TestUtils . eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = TestUtils . eliminateZeroMassPoints ( densityPoints , densityValues ) ;
if ( ak2 < NUMBER_CONSTANT ) { rank = k ; return; }
if ( ak2 == NUMBER_CONSTANT ) { rank = k ; return; }
if ( ak2 <= qrRankingThreshold ) { rank = k ; return; }
assertFalse ( MathUtils . equals ( Double.NaN , Double.NaN , NUMBER_CONSTANT ) ) ;
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , n , startConfiguration.length ) ; }
if ( steps [ j ] == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX , j , j + NUMBER_CONSTANT ) ; }
{ if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p ) ; } quantile = p ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p ) ; }
{ if ( getDimension () != n ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , getDimension () , n ) ; } }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( sd <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_STANDARD_DEVIATION , sd ) ; } standardDeviation = sd ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SCALE , beta ) ; } this . scale = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SHAPE , alpha ) ; } this . shape = alpha ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( microsphereElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NON_POSITIVE_MICROSPHERE_ELEMENTS , microsphereElements ) ; } this . microsphereElements = elements ; }
{ if ( brightnessExponent < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_BRIGHTNESS_EXPONENT , brightnessExponent ) ; } this . brightnessExponent = brightnessExponent ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 ) ; }
throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_REAL_VECTOR , obj . getClass () . getName () ) ;
{ if ( realFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_REAL_FORMAT ) ; } this . realFormat = realFormat ; }
{ if ( imaginaryFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_IMAGINARY_FORMAT ) ; } this . imaginaryFormat = imaginaryFormat ; }
if ( imaginaryCharacter == null || imaginaryCharacter . length () == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EMPTY_STRING_FOR_IMAGINARY_CHARACTER ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_COMPLEX , obj . getClass () . getName () ) ; }
{ double d = getDimension () ; if ( d != n ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , d , n ) ; } }
catch ( InvalidMatrixException e ) { throw new OptimizationException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
if ( arrayDimension != expected ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , arrayDimension , expected ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
Localizable specifier
if ( y0 * y1 >= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.SAME_SIGN_AT_ENDPOINTS , min , max , y0 , y1 ) ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , columns ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIFFERENT_ROWS_LENGTHS , columns , length ) ; }
{ this ( new DummyLocalizable ( pattern ) , arguments ) ; }
if ( nSteps <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INTEGRATION_METHOD_NEEDS_AT_LEAST_ONE_PREVIOUS_POINT , name ) ; }
if ( ( c1 / c2 < NUMBER_CONSTANT ) || ( c2 / c3 < NUMBER_CONSTANT ) ) { throw new OptimizationException ( LocalizedFormats.UNABLE_TO_FIRST_GUESS_HARMONIC_COEFFICIENTS ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_PLUS_ONE , f.length ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS ) ; } }
if ( e . compareTo ( BigInteger.ZERO ) < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
{ if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; } return k . pow ( e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( lcm == Long.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.LCM_OVERFLOW_64_BITS , a , b ) ; }
if ( lcm == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.LCM_OVERFLOW_32_BITS , a , b ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER , n ) ; }
{ if ( ( minimalIterationCount <= NUMBER_CONSTANT ) || ( maximalIterationCount <= minimalIterationCount ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_ITERATIONS_LIMITS , minimalIterationCount , maximalIterationCount ) ; } }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_RESULT_AVAILABLE ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
{ if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optima . clone () ; }
Localizable pattern
Localizable pattern
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FRACTION ) ; }
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.OVERFLOW_IN_FRACTION , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
if ( p <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_POISSON_MEAN , p ) ; }
{ this ( new DummyLocalizable ( pattern ) , arguments ) ; }
if ( r < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_COMPLEX_MODULE , r ) ; }
if ( nRows == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.AT_LEAST_ONE_ROW ) ; }
if ( nCols == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.AT_LEAST_ONE_COLUMN ) ; }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N , n ) ; }
if ( dimension == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE , minSingularValue , singularValues [ NUMBER_CONSTANT ] ) ; }
if ( target.length != weights.length ) { throw new OptimizationException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , target.length , weights.length ) ; }
if ( rows <= cols ) { throw new OptimizationException ( LocalizedFormats.NO_DEGREES_OF_FREEDOM , rows , cols ) ; }
catch ( InvalidMatrixException ime ) { throw new OptimizationException ( LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM ) ; }
if ( objective.length != rows ) { throw new FunctionEvaluationException ( point , LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , objective.length , rows ) ; }
if ( jacobian.length != rows ) { throw new FunctionEvaluationException ( point , LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , jacobian.length , rows ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( successes < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_NUMBER_OF_SUCCESSES , successes ) ; } numberOfSuccesses = successes ; }
{ if ( newDegreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM , newDegreesOfFreedom ) ; } this . degreesOfFreedom = newDegreesOfFreedom ; }
if ( b.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v.length != getColumnDimension () ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( sampleSize <= NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE , sampleSize ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS , nRows , nCols ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_COVARIANCE_MATRIX ) ; }
if ( observations.length < NUMBER_CONSTANT ) { throw new OptimizationException ( LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE , observations.length , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( newMean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_MEAN , newMean ) ; } this . mean = newMean ; }
catch ( ClassCastException ex ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES , v . getClass () . getName () ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CLASS_DOESNT_IMPLEMENT_COMPARABLE , v . getClass () . getName () ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , n ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , n ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_ITERATIONS_LIMITS , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
if ( ( str = filePointer . readLine () ) == null ) { throw MathRuntimeException . createEOFException ( LocalizedFormats.URL_CONTAINS_NO_DATA , valuesFileURL ) ; }
if ( ( empiricalDistribution == null ) || ( empiricalDistribution . getBinStats () . size () == NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.DIGEST_NOT_INITIALIZED ) ; }
{ super ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , dimension1 , dimension2 ) ; this . dimension1 = dimension1 ; this . dimension2 = dimension2 ; }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SCALE , s ) ; } scale = s ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_FORMAT_OBJECT_TO_FRACTION ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.SAME_SIGN_AT_ENDPOINTS , min , max , yMin , yMax ) ; }
if ( isDefaultValue ( norm ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( vector . getDimension () != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , vector . getDimension () , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( vector . getDimension () != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nCols ) ; }
{ if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.AT_LEAST_ONE_ROW ) ; } return d [ NUMBER_CONSTANT ] . getField () ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( Double . isInfinite ( norm2 ) || Double . isNaN ( norm2 ) ) { throw new OptimizationException ( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN , rows , cols ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( getN () > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC , getN () ) ; } }
{ super ( LocalizedFormats.DUPLICATED_ABSCISSA , abscissa , i1 , i2 ) ; }
if ( i < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INDEX_NOT_POSITIVE , i ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INITIAL_CAPACITY_NOT_POSITIVE , initialCapacity ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.UNSUPPORTED_EXPANSION_MODE , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( LocalizedFormats.CANNOT_SET_AT_NEGATIVE_INDEX , index ) ; }
if ( expansion <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EXPANSION_FACTOR_SMALLER_THAN_ONE , expansion ) ; }
if ( numElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY ) ; }
{ throw new IntegratorException ( LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION , minStep , Math . abs ( h ) ) ; }
if ( m <= p ) { throw new EstimationException ( LocalizedFormats.NO_DEGREES_OF_FREEDOM , m , p ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM ) ; }
if ( ++ costEvaluations > maxCostEval ) { throw new EstimationException ( LocalizedFormats.MAX_EVALUATIONS_EXCEEDED , maxCostEval ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
{ if ( size < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE , size ) ; } sampleSize = size ; }
{ if ( size <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_POPULATION_SIZE , size ) ; } populationSize = size ; }
{ if ( num < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_NUMBER_OF_SUCCESSES , num ) ; } numberOfSuccesses = num ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optima . clone () ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_MEAN , mean ) ; }
if ( sigma <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_STANDARD_DEVIATION , sigma ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_POISSON_MEAN , mean ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_LENGTH , len ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_LENGTH , len ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( vector . getDimension () != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , vector . getDimension () , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( vector . getDimension () != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nCols ) ; }
throw new NotARotationMatrixException ( LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX , i - NUMBER_CONSTANT ) ;
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS ) ; }
catch ( IllegalAccessException e2 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD , SET_QUANTILE_METHOD_NAME , percentileImpl . getClass () . getName () ) ; }
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_WINDOW_SIZE , windowSize ) ; } }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_ITERATIONS_LIMITS , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
public CardanEulerSingularityException ( boolean isCardan ) { super ( isCardan ? LocalizedFormats.CARDAN_ANGLES_SINGULARITY : LocalizedFormats.EULER_ANGLES_SINGULARITY ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
if ( Double . isNaN ( optima [ NUMBER_CONSTANT ] ) ) { throw new OptimizationException ( LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT , starts ) ; }
{ if ( optimaValues == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optimaValues . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optima . clone () ; }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_UPPER_BOUND , n ) ; }
catch ( DuplicateSampleAbscissaException e ) { throw new FunctionEvaluationException ( e , z , e . getLocalizablePattern () , e . getArguments () ) ; }
if ( Double . isInfinite ( norm2 ) || Double . isNaN ( norm2 ) ) { throw new EstimationException ( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN , rows , cols ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_ITERATIONS_LIMITS , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
final Localizable pattern
if ( xval.length != yval.length ) { throw new MathException ( LocalizedFormats.MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS , xval.length , yval.length ) ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , columns ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIFFERENT_ROWS_LENGTHS , columns , length ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optima . clone () ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
{ throw new InvalidMatrixException ( LocalizedFormats.ASSYMETRIC_EIGEN_NOT_SUPPORTED ) ; }
if ( offset > NUMBER_CONSTANT ) { throw new EventException ( LocalizedFormats.EVALUATION_FAILED , t ) ; }
{ throw new DerivativeException ( LocalizedFormats.SIMPLE_MESSAGE , STRING_CONSTANT ) ; }
if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET ) ; }
if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_COMPUTE_0TH_ROOT_OF_UNITY ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET ) ; } return isForward ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , o.length ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , d.length ) ; } }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES , n ) ; }
{ this ( cause , new DummyLocalizable ( pattern ) , arguments ) ; }
{ this ( new DummyLocalizable ( pattern ) , arguments ) ; }
if ( sampleStats . getN () == NUMBER_CONSTANT ) { throw MathRuntimeException . createEOFException ( LocalizedFormats.URL_CONTAINS_NO_DATA , url ) ; }
final Localizable specifier
{ if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS , lower , initial , upper ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_RESULT_AVAILABLE ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; } }
catch ( InvalidMatrixException e ) { throw new EstimationException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
final Localizable specifier
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( trials < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_NUMBER_OF_TRIALS , trials ) ; } numberOfTrials = trials ; }
{ if ( BigInteger.ZERO . equals ( fraction.numerator ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; } return multiply ( fraction . reciprocal () ) ; }
if ( BigInteger.ZERO . equals ( bg ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
throw new OptimizationException ( LocalizedFormats.UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH ) ;
{ if ( newBeta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_BETA , newBeta ) ; } this . beta = newBeta ; }
{ if ( newAlpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_ALPHA , newAlpha ) ; } this . alpha = newAlpha ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ super ( LocalizedFormats.FRACTION_CONVERSION_OVERFLOW , value , p , q ) ; }
{ super ( LocalizedFormats.FAILED_FRACTION_CONVERSION , value , maxIterations ) ; }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_EXPONENT , s ) ; } this . exponent = s ; }
{ if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_DIMENSION , n , NUMBER_CONSTANT ) ; } this . numberOfElements = n ; }
throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR , obj . getClass () . getName () ) ;
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_WHOLE_FORMAT ) ; } this . wholeFormat = format ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_NUMERATOR_FORMAT ) ; } this . numeratorFormat = format ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_DENOMINATOR_FORMAT ) ; } this . denominatorFormat = format ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_UPPER_BOUND , n ) ; }
{ if ( in [ i ] < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX , i , in [ i ] ) ; } }
{ if ( in [ i ] <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_ELEMENT_AT_INDEX , i , in [ i ] ) ; } }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NON_POSITIVE_POLYNOMIAL_DEGREE , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NON_POSITIVE_POLYNOMIAL_DEGREE , n ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FUNCTION_NOT_POLYNOMIAL ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FUNCTION_NOT_POLYNOMIAL ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS , nRows , nCols ) ; }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_RESULT_AVAILABLE ) ; } }
if ( residuals.length != observations.length ) { throw new FunctionEvaluationException ( point , LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , residuals.length , observations.length ) ; }
if ( observations.length != scale . getColumnDimension () ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , observations.length , scale . getColumnDimension () ) ; }
if ( observations.length != weights.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , observations.length , weights.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
public Double getZ () { throw new MathRuntimeException ( LocalizedFormats.SIMPLE_MESSAGE , STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY ) ; }
if ( mean.length != standardDeviation.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , mean.length , standardDeviation.length ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , data.length , n ) ; } }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY , pos , size , d.length ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT ) ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( xval.length == NUMBER_CONSTANT || xval [ NUMBER_CONSTANT ] == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || zval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
{ super ( LocalizedFormats.NON_SQUARE_MATRIX , rows , columns ) ; }
if ( f [ NUMBER_CONSTANT ] != NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FIRST_ELEMENT_NOT_ZERO , f [ NUMBER_CONSTANT ] ) ; }
catch ( ClassCastException cce ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FUNCTION_NOT_DIFFERENTIABLE ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , data.length , n ) ; } }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY , pos , size , d.length ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY , pos , size , d.length ) ; }
if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
if ( sampleSize <= NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE , sampleSize ) ; }
{ throw new MathRuntimeException ( new UnsupportedOperationException () , LocalizedFormats.NO_DENSITY_FOR_THIS_DISTRIBUTION ) ; }
{ super ( LocalizedFormats.EVALUATION_FAILED , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
{ super ( LocalizedFormats.EVALUATION_FAILED , argument ) ; this . argument = new double [] { argument } ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_WHOLE_FORMAT ) ; } this . wholeFormat = format ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_REAL_VECTOR , source ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_COMPLEX_NUMBER , source ) ; }
if ( sum == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ARRAY_SUMS_TO_ZERO ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL , lower , upper ) ; } }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_FRACTION_NUMBER , source ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_FRACTION_NUMBER , source ) ; }
catch ( NoSuchMethodException e1 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD , percentileImpl . getClass () . getName () , SET_QUANTILE_METHOD_NAME ) ; }
{ throw MathRuntimeException . createArithmeticException ( LocalizedFormats.IDENTICAL_ABSCISSAS_DIVISION_BY_ZERO , i , k , x [ i ] ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX , k , NUMBER_CONSTANT , omegaCount - NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX , k , NUMBER_CONSTANT , omegaCount - NUMBER_CONSTANT ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL , lower , upper ) ; } }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.RANDOMKEY_MUTATION_WRONG_CLASS , original . getClass () . getSimpleName () ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL , lower , upper ) ; } }
throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED , n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_3D_VECTOR , source ) ; }
public NotStrictlyPositiveException ( Number value ) { super ( value , NUMBER_CONSTANT , false ) ; }
public NotPositiveException ( Number value ) { super ( value , NUMBER_CONSTANT , true ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw new NoDataException () ; }
if ( x.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NUMBER_OF_POINTS , x.length , NUMBER_CONSTANT , true ) ; }
if ( x.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NUMBER_OF_POINTS , x.length , NUMBER_CONSTANT , true ) ; }
if ( n < NUMBER_CONSTANT ) { throw new NotStrictlyPositiveException ( n ) ; }
if ( mean.length != standardDeviation.length ) { throw new DimensionMismatchException ( mean.length , standardDeviation.length ) ; }
{ return ( point == null ? null : point . clone () ) ; }
{ return ( value == null ? null : value . clone () ) ; }
{ return ( point == null ? null : point . clone () ) ; }
final double [] scale = new double [ mainSetDimension ] ;
catch ( NoDataException ise ) {}
{ super ( specific , LocalizedFormats.NO_DATA , ( Object [] ) null ) ; }
( startConfiguration == null ) || ( startConfiguration.length != startPoint.length )
a [ i ] [ j ] [ k ] = aV [ i + N * ( j + N * k ) ]
super ( specific , boundIsAllowed ? LocalizedFormats.NUMBER_TOO_SMALL : LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED , wrong , min ) ;
{ return ( point == null ) ? null : point . clone () ; }
{ return ( value == null ) ? null : value . clone () ; }
{ return ( point == null ) ? null : point . clone () ; }
public GoalType getGoalType () { return optimizationGoal ; }
{ throw new MatrixIndexException ( LocalizedFormats.INDEX_OUT_OF_RANGE , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( LocalizedFormats.INDEX_OUT_OF_RANGE , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( LocalizedFormats.COLUMN_INDEX_OUT_OF_RANGE , column , NUMBER_CONSTANT , getColumnDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( LocalizedFormats.ROW_INDEX_OUT_OF_RANGE , row , NUMBER_CONSTANT , getRowDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( LocalizedFormats.INDEX_OUT_OF_RANGE , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
public void remove () { throw MathRuntimeException . createUnsupportedOperationException ( LocalizedFormats.UNSUPPORTED_OPERATION ) ; }
{ super ( METHOD_NAME , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( METHOD_NAME , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
{ super ( METHOD_NAME , nSteps , nSteps , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( METHOD_NAME , nSteps , nSteps , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
{ ret = addAndCheck ( a , - b , LocalizedFormats.OVERFLOW_IN_ADDITION ) ; }
if ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.OVERFLOW_IN_SUBTRACTION , x , y ) ; }
{ return addAndCheck ( a , b , LocalizedFormats.OVERFLOW_IN_ADDITION ) ; }
if ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.OVERFLOW_IN_ADDITION , x , y ) ; }
if ( populationLimit < NUMBER_CONSTANT ) { throw new NotPositiveException ( LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE , populationLimit ) ; }
catch ( ArithmeticException ex ) { assertTrue ( ex . getMessage () . length () > NUMBER_CONSTANT ) ; }
{ this ( wrong , previous , index , MathUtils.OrderDirection.INCREASING , true ) ; }
{ checkOrder ( val , OrderDirection.INCREASING , true ) ; }
if ( t == NUMBER_CONSTANT && i >= j ) continue;
arguments = ArgUtils . flatten ( args ) ;
public void remove () { throw new MathUnsupportedOperationException () ; }
@ Test ( expected = ZeroException . class )
if ( f == null ) { throw new NullArgumentException ( LocalizedFormats.FUNCTION ) ; }
if ( fraction == null ) { throw new NullArgumentException ( LocalizedFormats.FRACTION ) ; }
if ( fraction == null ) { throw new NullArgumentException ( LocalizedFormats.FRACTION ) ; }
if ( fraction == null ) { throw new NullArgumentException ( LocalizedFormats.FRACTION ) ; }
if ( d == NUMBER_CONSTANT ) { throw new ZeroException () ; }
{ throw new DimensionMismatchException ( xArray.length , yArray.length ) ; }
if ( covarianceMatrix == null ) { throw new NullArgumentException ( LocalizedFormats.COVARIANCE_MATRIX ) ; }
{ if ( values == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( idxStep == NUMBER_CONSTANT ) { throw new ZeroException () ; }
if ( idxStep == NUMBER_CONSTANT ) { throw new ZeroException () ; }
if ( observations == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; }
if ( f == null ) { throw new NullArgumentException ( LocalizedFormats.FUNCTION ) ; }
{ if ( f == null ) { throw new NullArgumentException ( LocalizedFormats.FUNCTION ) ; } }
if ( function == null ) { throw new NullArgumentException ( LocalizedFormats.FUNCTION ) ; }
{ if ( values == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( d == NUMBER_CONSTANT ) { throw new ZeroException () ; }
{ if ( values == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
final double [] grad = weightedResidualJacobian [ i ] ;
{ this ( cause , argument , new DummyLocalizable ( pattern ) , arguments ) ; }
{ this ( cause , argument , new DummyLocalizable ( pattern ) , arguments ) ; }
{ this ( argument , new DummyLocalizable ( pattern ) , arguments ) ; }
{ this ( argument , new DummyLocalizable ( pattern ) , arguments ) ; }
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double fpos = FastMath . floor ( pos ) ;
{ return FastMath . asin ( z / getNorm () ) ; }
{ return FastMath . atan2 ( y , x ) ; }
double expected = FastMath . random () ;
double expected = FastMath . random () ;
double range = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double range = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
NUMBER_CONSTANT * ( NUMBER_CONSTANT + Erf . erf ( ( x - mean ) / ( standardDeviation * FastMath . sqrt ( NUMBER_CONSTANT ) ) ) )
return FastMath . sqrt ( sum / v.length ) ;
if ( value != i ) { res += FastMath . abs ( value - i ) ; }
{ norm = FastMath . max ( norm , FastMath . abs ( e . getValue () ) ) ; }
{ norm += FastMath . abs ( e . getValue () ) ; }
return FastMath . sqrt ( sum ) ;
return FastMath . sqrt ( d ) ;
FastFourierTransformer . scaleArray ( x , FastMath . sqrt ( x.length / NUMBER_CONSTANT ) ) ;
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
minor < FastMath . min ( m , n )
j < FastMath . min ( i + NUMBER_CONSTANT , n )
int row = FastMath . min ( m , n ) - NUMBER_CONSTANT
assertEquals ( FastMath . sqrt ( NUMBER_CONSTANT ) , e1 . distanceFrom ( e2 ) , NUMBER_CONSTANT ) ;
{ Assert . assertEquals ( FastMath . pow ( NUMBER_CONSTANT , x ) , f . value ( x ) , NUMBER_CONSTANT ) ; }
{ assertTrue ( FastMath . abs ( value - reference ) < NUMBER_CONSTANT ) ; }
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
assertTrue ( FastMath . abs ( h ) < minStep ) ;
double maxStep = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
FastMath . abs ( max - min ) <= absoluteAccuracy
final double power = FastMath . pow ( normalizedAbscissa , order ) ;
final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , rows ) ;
final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , rows ) ;
Assert . assertEquals ( STRING_CONSTANT , expected , result , FastMath . ulp ( NUMBER_CONSTANT ) ) ;
Assert . assertEquals ( STRING_CONSTANT , expected , result , FastMath . ulp ( NUMBER_CONSTANT ) ) ;
setMaxGrowth ( FastMath . pow ( NUMBER_CONSTANT , - exp ) ) ;
setMaxGrowth ( FastMath . pow ( NUMBER_CONSTANT , - exp ) ) ;
{ assertEquals ( msg , expected , actual , FastMath . abs ( tolerance * actual ) ) ; }
Gamma . digamma ( FastMath . pow ( NUMBER_CONSTANT , - n ) )
final int capacity = ( int ) FastMath . ceil ( expectedSize / LOAD_FACTOR ) ;
double scaling_coefficient = FastMath . sqrt ( NUMBER_CONSTANT / ( n - NUMBER_CONSTANT ) ) ;
double scaling_coefficient = FastMath . sqrt ( NUMBER_CONSTANT / ( f.length - NUMBER_CONSTANT ) ) ;
{ sum += FastMath . abs ( p1 [ i ] - p2 [ i ] ) ; }
{ return ( FastMath . exp ( x ) - FastMath . exp ( - x ) ) / NUMBER_CONSTANT ; }
float factor = ( float ) FastMath . pow ( NUMBER_CONSTANT , scale ) * sign ;
{ return FastMath . log ( x ) / FastMath . log ( base ) ; }
return FastMath . abs ( u ) + FastMath . abs ( v ) ;
return FastMath . abs ( u ) + FastMath . abs ( v ) ;
final boolean isEqual = FastMath . abs ( xInt - yInt ) <= maxUlps ;
{ return equalsIncludingNaN ( x , y ) || ( FastMath . abs ( y - x ) <= eps ) ; }
{ return equals ( x , y , NUMBER_CONSTANT ) || FastMath . abs ( y - x ) <= eps ; }
{ return ( FastMath . exp ( x ) + FastMath . exp ( - x ) ) / NUMBER_CONSTANT ; }
return FastMath . floor ( result + NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / FastMath . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / FastMath . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / FastMath . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / FastMath . sqrt ( NUMBER_CONSTANT ) ;
assertEquals ( FastMath.PI , x , accuracy ) ;
{ double x = UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; assertEquals ( FastMath.PI , x , NUMBER_CONSTANT ) ; }
double t = FastMath . abs ( t ( m , mu , v , n ) ) ;
{ return ( m - mu ) / FastMath . sqrt ( v / n ) ; }
double sqrt = FastMath . sqrt ( c [ ir ] [ ir ] ) ;
{ return ( int ) FastMath . min ( randomData . nextPoisson ( mean ) , Integer.MAX_VALUE ) ; }
normal . setStandardDeviation ( FastMath . sqrt ( p ) ) ;
final int p = FastMath . min ( m , n ) ;
assertEquals ( FastMath.PI , MathUtils . scalb ( FastMath.PI , NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
MathUtils . hash ( new double [] { FastMath . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) } )
assertEquals ( i + STRING_CONSTANT , FastMath . log ( factorial ( i ) ) , MathUtils . factorialLog ( i ) , NUMBER_CONSTANT ) ;
new double [] { FastMath . nextAfter ( FastMath . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT ) }
MathUtils . equals ( new double [] { NUMBER_CONSTANT } , new double [] { FastMath . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) } )
error = FastMath . sqrt ( error / scale.length ) * errfac [ currentDegree - NUMBER_CONSTANT ] ;
final int capacity = ( int ) FastMath . ceil ( expectedSize / LOAD_FACTOR ) ;
{ return FastMath . atan2 ( getImaginary () , getReal () ) ; }
FastMath . abs ( c ) < FastMath . abs ( d )
{ singularValues [ i ] = FastMath . sqrt ( FastMath . abs ( singularValues [ i ] ) ) ; }
double sigma = FastMath . sqrt ( mean ) ;
{ return FastMath . sqrt ( getChiSquare () / rows ) ; }
double wi = FastMath . sqrt ( residualsWeights [ i ] ) ;
double range = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double range = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
{ return FastMath . atan2 ( x , y ) ; }
{ return FastMath . pow ( x , y ) ; }
return FastMath . sqrt ( dx * dx + dy * dy ) ;
assertTrue ( FastMath . sqrt ( m.length ) * estimator . getRMS ( problem ) > NUMBER_CONSTANT ) ;
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
FastMath . abs ( dt ) <= FastMath . ulp ( stepStart )
this . step = FastMath . abs ( step ) ;
double fl = FastMath . floor ( x ) ;
{ return cumulativeProbability ( ( int ) FastMath . floor ( x ) ) ; }
assertEquals ( ci , l40 [ i ] , FastMath . abs ( ci ) * NUMBER_CONSTANT ) ;
FastMath . abs ( Tk . value ( x ) ) < ( NUMBER_CONSTANT + NUMBER_CONSTANT )
{ return new HarmonicFunction ( a * omega , omega , phi + FastMath.PI / NUMBER_CONSTANT ) ; }
{ return a * FastMath . cos ( omega * x + phi ) ; }
assertTrue ( FastMath . abs ( generated [ NUMBER_CONSTANT ] - NUMBER_CONSTANT ) > NUMBER_CONSTANT ) ;
return a * FastMath . cos ( omega * x + phi ) ;
double [] y0 = { FastMath . sin ( a ) , FastMath . cos ( a ) } ;
{ ret = - mean * FastMath . log ( NUMBER_CONSTANT - p ) ; }
{ ret = NUMBER_CONSTANT - FastMath . exp ( - x / mean ) ; }
{ if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } return FastMath . exp ( - x / mean ) / mean ; }
Complex sqrtz = ComplexUtils . polar2Complex ( FastMath . sqrt ( r ) , theta / NUMBER_CONSTANT ) ;
TestUtils . assertEquals ( new Complex ( FastMath . acos ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) , Complex.ZERO . acos () , NUMBER_CONSTANT ) ;
{ if ( getN () > NUMBER_CONSTANT ) { stdDev = FastMath . sqrt ( getVariance () ) ; } else { stdDev = NUMBER_CONSTANT ; } }
assertTrue ( FastMath . sqrt ( problem.target.length ) * optimizer . getRMS () > NUMBER_CONSTANT ) ;
{ ret = median + scale * FastMath . tan ( FastMath.PI * ( p - NUMBER_CONSTANT ) ) ; }
return ( NUMBER_CONSTANT / FastMath.PI ) * ( scale / ( dev * dev + scale * scale ) ) ;
assertEquals ( NUMBER_CONSTANT , FastMath . sqrt ( circle . getN () ) * optimizer . getRMS () , NUMBER_CONSTANT ) ;
final double f = NUMBER_CONSTANT / FastMath . sqrt ( normSq ) ;
new Fraction ( FastMath.PI , NUMBER_CONSTANT )
{ new Fraction ( ( NUMBER_CONSTANT + FastMath . sqrt ( NUMBER_CONSTANT ) ) / NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
double delta = FastMath . abs ( getEntry ( i ) - v [ i ] ) ;
{ double delta = FastMath . abs ( getEntry ( i ) - v [ i ] ) ; max += delta ; }
return FastMath . sqrt ( res ) ;
return FastMath . sqrt ( res ) ;
{ return FastMath . abs ( value ) < epsilon ; }
{ return FastMath . sqrt ( variance . evaluate ( values , mean ) ) ; }
{ return FastMath . sqrt ( variance . evaluate ( values , mean , begin , length ) ) ; }
{ return FastMath . sqrt ( variance . evaluate ( values , begin , length ) ) ; }
{ return FastMath . sqrt ( variance . evaluate ( values ) ) ; }
@ Override public double getResult () { return FastMath . sqrt ( variance . getResult () ) ; }
@ Override public double value ( double d ) { return FastMath . ulp ( d ) ; }
@ Override public double value ( double d ) { return FastMath . signum ( d ) ; }
@ Override public double value ( double d ) { return FastMath . rint ( d ) ; }
@ Override public double value ( double d ) { return FastMath . cosh ( d ) ; }
@ Override public double value ( double d ) { return FastMath . acos ( d ) ; }
@ Override public double value ( double d ) { return FastMath . cos ( d ) ; }
@ Override public double value ( double d ) { return FastMath . log10 ( d ) ; }
@ Override public double value ( double d ) { return FastMath . log ( d ) ; }
@ Override public double value ( double d ) { return FastMath . floor ( d ) ; }
@ Override public double value ( double d ) { return FastMath . ceil ( d ) ; }
@ Override public double value ( double d ) { return FastMath . cbrt ( d ) ; }
@ Override public double value ( double d ) { return FastMath . tanh ( d ) ; }
@ Override public double value ( double d ) { return FastMath . tan ( d ) ; }
@ Override public double value ( double d ) { return FastMath . atan ( d ) ; }
@ Override public double value ( double d ) { return FastMath . asin ( d ) ; }
@ Override public double value ( double d ) { return FastMath . expm1 ( d ) ; }
@ Override public double value ( double d ) { return FastMath . exp ( d ) ; }
@ Override public double value ( double d ) { return FastMath . sinh ( d ) ; }
@ Override public double value ( double d ) { return FastMath . sqrt ( d ) ; }
@ Override public double value ( double d ) { return FastMath . sin ( d ) ; }
@ Override public double value ( double d ) { return FastMath . abs ( d ) ; }
widthSufficient = FastMath . min ( lowerBinMass , upperBinMass ) * sampleSize >= minExpectedCount ;
{ return FastMath . exp ( sumOfLogs . getResult () / sumOfLogs . getN () ) ; }
int k = FastMath . max ( N , seed.length )
final double s17 = FastMath . sqrt ( NUMBER_CONSTANT ) ;
{ assertTrue ( FastMath . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
{ assertTrue ( FastMath . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
{ stepStart = Double.NaN ; stepSize = FastMath . sqrt ( minStep * maxStep ) ; }
return FastMath . sqrt ( criterion / wm.length ) ;
double factor = - FastMath . sqrt ( wm . getWeight () ) ;
if ( deltaNorm > NUMBER_CONSTANT * FastMath . max ( NUMBER_CONSTANT , initialNorm ) ) { return false ; }
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * FastMath . sqrt ( NUMBER_CONSTANT ) ) , sample . getStandardDeviation () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * FastMath . sqrt ( NUMBER_CONSTANT ) ) , sample . getStandardDeviation () , NUMBER_CONSTANT ) ;
ret = FastMath . exp ( p1 + p2 - p3 ) ;
{ return FastMath . min ( k , m ) ; }
{ return FastMath . max ( NUMBER_CONSTANT , m - ( n - k ) ) ; }
{ assertTrue ( FastMath . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
FastFourierTransformer . scaleArray ( x2 , NUMBER_CONSTANT / FastMath . sqrt ( x2.length ) ) ;
double c = t2 + NUMBER_CONSTANT * ( FastMath . exp ( - NUMBER_CONSTANT * t2 ) - NUMBER_CONSTANT ) ;
return - mean * FastMath . log ( unif ) ;
double expected = FastMath . random () ;
double expected = FastMath . random () ;
public double end () { return FastMath . sqrt ( sum ) ; }
if ( FastMath . abs ( fn1 - fn ) <= threshold ) return o ;
this . convergence = FastMath . abs ( convergence ) ;
assertEquals ( n + STRING_CONSTANT + degree + STRING_CONSTANT + i , reference , result , NUMBER_CONSTANT * ( NUMBER_CONSTANT + FastMath . abs ( reference ) ) ) ;
{ if ( getN () > NUMBER_CONSTANT ) { stdDev = FastMath . sqrt ( getVariance () ) ; } else { stdDev = NUMBER_CONSTANT ; } }
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
long index = FastMath . round ( ( FastMath . random () ) * testArray.length ) ;
new double [] { - FastMath . sqrt ( NUMBER_CONSTANT ) , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT }
{ new BigReal ( NUMBER_CONSTANT ) , BigReal.ONE , BigReal.ZERO , new BigReal ( NUMBER_CONSTANT ) , new BigReal ( FastMath.PI ) , new BigReal ( - NUMBER_CONSTANT ) }
FastMath . log ( x ) - NUMBER_CONSTANT / x
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double invR3 = NUMBER_CONSTANT / ( r2 * FastMath . sqrt ( r2 ) ) ;
{ result [ i ] = FastMath . sqrt ( sigma * betaVariance [ i ] [ i ] ) ; }
final double dist = FastMath . abs ( z - x [ i ] ) ;
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
{ product *= FastMath . pow ( values [ i ] , weights [ i ] ) ; }
return FastMath . sqrt ( sum2 ) ;
final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , rows ) ;
final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , rows ) ;
accum3 /= variance * FastMath . sqrt ( variance ) ;
( n0 * moment.m3 ) / ( ( n0 - NUMBER_CONSTANT ) * ( n0 - NUMBER_CONSTANT ) * FastMath . sqrt ( variance ) * variance )
assertEquals ( FastMath . sqrt ( NUMBER_CONSTANT ) , Vector3D . distance ( v1 , v2 ) , NUMBER_CONSTANT ) ;
assertEquals ( FastMath . sqrt ( NUMBER_CONSTANT ) , new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getNorm () , NUMBER_CONSTANT ) ;
double tmp2 = FastMath . exp ( tmp1 ) ;
double tmp2 = FastMath . sqrt ( tmpSquare ) ;
assertEquals ( mi , vi , paramsAccuracy * ( NUMBER_CONSTANT + FastMath . abs ( mi ) ) ) ;
assertEquals ( theoreticalMinCost , FastMath . sqrt ( m ) * rms , threshold ) ;
double t = NUMBER_CONSTANT * FastMath.PI ;
double t = NUMBER_CONSTANT * FastMath.PI ;
Double pi = Double . valueOf ( FastMath.PI ) ;
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ;
double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( n ) ;
{ double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ; return scaleArray ( fft ( f , true ) , scaling_coefficient ) ; }
double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ;
double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( n ) ;
{ double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ; return scaleArray ( fft ( f , false ) , scaling_coefficient ) ; }
{ assertTrue ( FastMath . abs ( value - reference ) < NUMBER_CONSTANT ) ; }
double x = FastMath . random () ;
double absTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
{ values [ i ] = FastMath . pow ( values [ i ] , d ) ; }
assertNotSame ( v , new OpenMapRealVector ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT + FastMath . ulp ( NUMBER_CONSTANT ) } ) ) ;
double tmp2 = FastMath . exp ( tmp1 ) ;
double tmp2 = FastMath . sqrt ( tmpSquare ) ;
double c = FastMath . exp ( t0 - t ) ;
return FastMath . sqrt ( dx * dx + dy * dy ) ;
assertEquals ( NUMBER_CONSTANT , FastMath . sqrt ( circle . getM () ) * rms , NUMBER_CONSTANT ) ;
FastMath . abs ( dt ) <= FastMath . ulp ( stepStart )
new BigFraction ( FastMath.PI , NUMBER_CONSTANT )
{ new BigFraction ( ( NUMBER_CONSTANT + FastMath . sqrt ( NUMBER_CONSTANT ) ) / NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
( int ) ( FastMath . abs ( NUMBER_CONSTANT * x + NUMBER_CONSTANT * y ) ) % NUMBER_CONSTANT == NUMBER_CONSTANT
( int ) ( FastMath . abs ( NUMBER_CONSTANT * x + NUMBER_CONSTANT * y ) ) % NUMBER_CONSTANT == NUMBER_CONSTANT
step *= FastMath . max ( NUMBER_CONSTANT , yA / yB )
{ value += NUMBER_CONSTANT / FastMath . pow ( k , m ) ; }
return ( NUMBER_CONSTANT / FastMath . pow ( x , exponent ) ) / generalizedHarmonic ( numberOfElements , exponent ) ;
FastFourierTransformer . scaleArray ( x , FastMath . sqrt ( NUMBER_CONSTANT * ( x.length - NUMBER_CONSTANT ) ) ) ;
double sigma = NUMBER_CONSTANT + FastMath . random () ;
double mu = FastMath . random () ;
{ this . h = FastMath . abs ( h ) ; this . handler = handler ; reset () ; }
if ( unequalCounts ) { weight = FastMath . sqrt ( ( double ) countSum1 / ( double ) countSum2 ) ; }
if ( FastMath . abs ( sumExpected - sumObserved ) > NUMBER_CONSTANT ) { ratio = sumObserved / sumExpected ; rescale = true ; }
double tolerance = FastMath . max ( relativeAccuracy * z . abs () , absoluteAccuracy ) ;
{ double absError = FastMath . abs ( expected ) * relativeError ; Assert . assertEquals ( msg , expected , actual , absError ) ; }
double absAi = FastMath . abs ( coefficients [ i ] ) ;
{ return NUMBER_CONSTANT * ( NUMBER_CONSTANT - distribution . cumulativeProbability ( FastMath . abs ( getSlope () ) / getSlopeStdErr () ) ) ; }
{ return FastMath . sqrt ( getMeanSquareError () / sumXX ) ; }
double result = FastMath . sqrt ( getRSquare () ) ;
if ( FastMath . abs ( sumXX ) < NUMBER_CONSTANT * Double.MIN_VALUE ) { return Double.NaN ; }
double t = FastMath . abs ( rValues . getEntry ( i , j ) ) / stdErrors . getEntry ( i , j ) ;
assertNotSame ( v , new ArrayRealVector ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT + FastMath . ulp ( NUMBER_CONSTANT ) } ) ) ;
{ sumLog += FastMath . log ( values [ i ] ) ; }
{ value += FastMath . log ( d ) ; n ++ ; }
{ assertTrue ( FastMath . abs ( value - expected ) < NUMBER_CONSTANT ) ; }
FastMath . sin ( i * FastMath.PI / n ) * ( f [ i ] + f [ n - i ] )
double scaling_coefficient = FastMath . sqrt ( NUMBER_CONSTANT / n ) ;
{ double scaling_coefficient = FastMath . sqrt ( NUMBER_CONSTANT / f.length ) ; return FastFourierTransformer . scaleArray ( fst ( f ) , scaling_coefficient ) ; }
i < FastMath . min ( rows , columns )
final double inv = NUMBER_CONSTANT / FastMath . sqrt ( norm2 ) ;
{ if ( FastMath . abs ( value - searchArray [ i ] ) < tolerance ) { found = true ; } i ++ ; }
if ( FastMath . abs ( x1 - x0 ) <= absoluteAccuracy ) { setResult ( x1 , i ) ; return x1 ; }
max = FastMath . max ( max , FastMath . abs ( delta ) ) ;
max = FastMath . max ( max , FastMath . abs ( delta ) ) ;
{ final double delta = data [ i ] - v [ i ] ; sum += FastMath . abs ( delta ) ; }
sum += FastMath . abs ( delta ) ;
return FastMath . sqrt ( sum ) ;
return FastMath . sqrt ( sum ) ;
for ( double a : data ) { max = FastMath . max ( max , FastMath . abs ( a ) ) ; }
for ( double a : data ) { sum += FastMath . abs ( a ) ; }
return FastMath . sqrt ( sum ) ;
{ data [ i ] = FastMath . ulp ( data [ i ] ) ; }
{ data [ i ] = FastMath . signum ( data [ i ] ) ; }
{ data [ i ] = FastMath . rint ( data [ i ] ) ; }
{ data [ i ] = FastMath . floor ( data [ i ] ) ; }
{ data [ i ] = FastMath . ceil ( data [ i ] ) ; }
{ data [ i ] = FastMath . cbrt ( data [ i ] ) ; }
{ data [ i ] = FastMath . sqrt ( data [ i ] ) ; }
{ data [ i ] = FastMath . abs ( data [ i ] ) ; }
{ data [ i ] = FastMath . atan ( data [ i ] ) ; }
{ data [ i ] = FastMath . asin ( data [ i ] ) ; }
{ data [ i ] = FastMath . acos ( data [ i ] ) ; }
{ data [ i ] = FastMath . tan ( data [ i ] ) ; }
{ data [ i ] = FastMath . sin ( data [ i ] ) ; }
{ data [ i ] = FastMath . cos ( data [ i ] ) ; }
{ data [ i ] = FastMath . tanh ( data [ i ] ) ; }
{ data [ i ] = FastMath . sinh ( data [ i ] ) ; }
{ data [ i ] = FastMath . cosh ( data [ i ] ) ; }
{ data [ i ] = FastMath . log1p ( data [ i ] ) ; }
{ data [ i ] = FastMath . log10 ( data [ i ] ) ; }
{ data [ i ] = FastMath . log ( data [ i ] ) ; }
{ data [ i ] = FastMath . expm1 ( data [ i ] ) ; }
{ data [ i ] = FastMath . exp ( data [ i ] ) ; }
{ data [ i ] = FastMath . pow ( data [ i ] , d ) ; }
{ stdDev [ i ] = FastMath . sqrt ( matrix . getEntry ( i , i ) ) ; }
{ assertTrue ( FastMath . abs ( value - expected ) < NUMBER_CONSTANT ) ; }
{ length = list . size () - FastMath . max ( NUMBER_CONSTANT , list . size () - windowSize ) ; }
assertEquals ( FastMath . exp ( NUMBER_CONSTANT ) , u . getGeometricMean () , NUMBER_CONSTANT ) ;
ConvergenceChecker < RealPointValuePair > convergenceChecker
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
catch ( ConvergenceException ee ) {}
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
catch ( ConvergenceException e ) { assertTrue ( ( ! solvable ) && ( degree > NUMBER_CONSTANT ) ) ; }
public GoalType getGoalType () { return goal ; }
assertEquals ( NUMBER_CONSTANT , product . getResult () , NUMBER_CONSTANT ) ;
@ Override public void clear () { value = NUMBER_CONSTANT ; n = NUMBER_CONSTANT ; }
public SumOfSquares () { n = NUMBER_CONSTANT ; value = NUMBER_CONSTANT ; }
@ Override public void clear () { value = NUMBER_CONSTANT ; n = NUMBER_CONSTANT ; }
public Sum () { n = NUMBER_CONSTANT ; value = NUMBER_CONSTANT ; }
checkClearValue ( statistic ) ;
checkClearValue ( statistic ) ;
@ Override public void clear () { value = NUMBER_CONSTANT ; n = NUMBER_CONSTANT ; }
public Product () { n = NUMBER_CONSTANT ; value = NUMBER_CONSTANT ; }
assertEquals ( NUMBER_CONSTANT , sumSq . getResult () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , sum . getResult () , NUMBER_CONSTANT ) ;
{ return NUMBER_CONSTANT + ( sign < < NUMBER_CONSTANT ) + ( nans < < NUMBER_CONSTANT ) + exp + Arrays . hashCode ( mant ) ; }
@ Override protected int getNumberOfRegressors () { return x [ NUMBER_CONSTANT ] . length + NUMBER_CONSTANT ; }
@ Override protected int getNumberOfRegressors () { return x [ NUMBER_CONSTANT ] . length + NUMBER_CONSTANT ; }
final boolean isMinim = getGoalType () == GoalType.MINIMIZE ;
public Well44497b ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497b ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497b () { super ( K , M1 , M2 , M3 ) ; }
public Well19937c ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937c ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937c () { super ( K , M1 , M2 , M3 ) ; }
v [ indexRm2 ] &= NUMBER_CONSTANT ;
v [ indexRm2 ] &= NUMBER_CONSTANT ;
v [ indexRm2 ] &= NUMBER_CONSTANT ;
v [ indexRm2 ] &= NUMBER_CONSTANT ;
{ super ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ; dimension = expected ; }
if ( v.length != rows ) { throw new DimensionMismatchException ( v.length , rows ) ; }
if ( v.length != columns ) { throw new DimensionMismatchException ( v.length , columns ) ; }
if ( length != columns ) { throw new DimensionMismatchException ( columns , length ) ; }
if ( v . getDimension () != nRows ) { throw new DimensionMismatchException ( v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw new DimensionMismatchException ( v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw new DimensionMismatchException ( v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw new DimensionMismatchException ( v.length , nCols ) ; }
if ( v.length != rows ) { throw new DimensionMismatchException ( v.length , rows ) ; }
if ( v.length != columns ) { throw new DimensionMismatchException ( v.length , columns ) ; }
if ( length != columns ) { throw new DimensionMismatchException ( columns , length ) ; }
{ this ( p , DEFAULT_EPSILON , DEFAULT_MAX_ITERATIONS ) ; }
dist = new PoissonDistributionImpl ( NUMBER_CONSTANT ) ;
double density ( double x ) ;
distribution = new ChiSquaredDistributionImpl ( df ) ;
{ distribution = new ChiSquaredDistributionImpl ( expected.length - NUMBER_CONSTANT ) ; return NUMBER_CONSTANT - distribution . cumulativeProbability ( chiSquare ( expected , observed ) ) ; }
( FastMath . max ( FastMath . abs ( mij ) , FastMath . abs ( mji ) ) * eps )
FDistributionImpl fd = new FDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw new OutOfRangeException ( LocalizedFormats.SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( n > NUMBER_CONSTANT ) { distribution = new TDistributionImpl ( n - NUMBER_CONSTANT ) ; }
if ( n > NUMBER_CONSTANT ) { distribution = new TDistributionImpl ( n - NUMBER_CONSTANT ) ; }
protected AbstractContinuousDistribution () {}
@ SuppressWarnings ( STRING_CONSTANT ) private RandomAdaptor () { randomGenerator = null ; }
return a . dotrap ( DfpField.FLAG_INVALID , STRING_CONSTANT , a , a . newInstance ( ( byte ) NUMBER_CONSTANT , Dfp.QNAN ) ) ;
if ( ia > NUMBER_CONSTANT ) { return a . newInstance ( ( byte ) NUMBER_CONSTANT , Dfp.INFINITE ) ; }
protected AbstractIntegerDistribution () {}
public int [] getSizes () { return copyOf ( size , dimension ) ; }
this . size = copyOf ( size , dimension ) ;
public int [] getCounts () { return copyOf ( counter , dimension ) ; }
final double [] d = copyOf ( direc [ i ] , n ) ;
AbstractMultipleLinearRegression regression = createRegression () ;
{ try { new ExponentialDistributionImpl ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( NotStrictlyPositiveException e ) {} }
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ realVectorFormat . parseObject ( STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ UnivariateRealSolverUtils . solve ( sin , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
zb += za - temp2 ;
if ( v . getDimension () != nRows ) { throw new DimensionMismatchException ( v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw new DimensionMismatchException ( v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw new DimensionMismatchException ( v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw new DimensionMismatchException ( v.length , nCols ) ; }
{ setQuantile ( p ) ; cachedPivots = null ; }
if ( isDefaultValue ( norm ) ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
{ this ( n , NUMBER_CONSTANT ) ; }
public MultiDirectionalSimplex ( final int n ) { this ( n , NUMBER_CONSTANT ) ; }
{ this ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , wrong , expected ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
@ Test ( expected = NonPositiveDefiniteMatrixException . class )
@ Test ( expected = NonPositiveDefiniteMatrixException . class )
@ Test ( expected = NonSymmetricMatrixException . class )
catch ( NonSquareMatrixException ime ) {}
catch ( DimensionMismatchException ee ) { assertTrue ( shouldFail ) ; }
catch ( DimensionMismatchException oe ) {}
try { es . getInverse () ; fail ( STRING_CONSTANT ) ; } catch ( SingularMatrixException ime ) {}
catch ( NonSquareMatrixException ime ) {}
catch ( NonPositiveDefiniteMatrixException e ) { fail ( STRING_CONSTANT ) ; }
public LaguerreSolver () { super ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ return MessageFactory . buildMessage ( locale , specific , general , arguments ) ; }
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
{ try { return mapToSelf ( ComposableFunction.ULP ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TANH ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TAN ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SQRT ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SINH ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIN ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIGNUM ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.RINT ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
try { return mapToSelf ( BinaryFunction.POW . fix2ndArgument ( d ) ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; }
try { return mapToSelf ( BinaryFunction.MULTIPLY . fix1stArgument ( d ) ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; }
{ try { return mapToSelf ( ComposableFunction.LOG1P ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG10 ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.INVERT ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.FLOOR ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXPM1 ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXP ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
try { return mapToSelf ( BinaryFunction.DIVIDE . fix2ndArgument ( d ) ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; }
{ try { return mapToSelf ( ComposableFunction.COSH ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.COS ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CEIL ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CBRT ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ATAN ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ACOS ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ABS ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
try { finalizeStep () ; } catch ( MathUserException e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException fe ) { assertTrue ( exceptionExpected ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
try { finalizeStep () ; } catch ( MathUserException e ) { throw MathRuntimeException . createIOException ( e ) ; }
{ return f . value ( x , y ) ; }
CircleVectorial circle = new CircleVectorial () ;
CircleVectorial circle = new CircleVectorial () ;
CircleVectorial circle = new CircleVectorial () ;
assertEquals ( NUMBER_CONSTANT , handler . getMaximalValueError () , NUMBER_CONSTANT ) ;
NumberIsTooLargeException ex
public RealVector mapPowToSelf ( double d ) { return mapToSelf ( new Power ( d ) ) ; }
{ if ( d != NUMBER_CONSTANT ) { return mapToSelf ( FunctionUtils . fix2ndArgument ( new Add () , d ) ) ; } return this ; }
{ if ( ++ iterations > maxIterations ) { throw new OptimizationException ( new MaxCountExceededException ( maxIterations ) ) ; } }
{ throw new MaxCountExceededException ( maxIterations ) ; }
throw new MaxCountExceededException ( maximalIterationCount ) ;
if ( n >= maxIterations ) { throw new MaxCountExceededException ( LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION , maxIterations , x ) ; }
if ( dimension == NUMBER_CONSTANT ) { throw new NumberIsTooLargeException ( LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE , minSingularValue , singularValues [ NUMBER_CONSTANT ] , true ) ; }
{ return solve ( DEFAULT_MAX_EVALUATIONS , f , startValue ) ; }
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder msgBuffer = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder sb = new StringBuilder () ;
final StringBuilder buff = new StringBuilder ( STRING_CONSTANT ) ;
StringBuilder msgBuffer = new StringBuilder () ;
StringBuilder out = new StringBuilder ( msg ) ;
StringBuilder messageBuffer = new StringBuilder () ;
StringBuilder s = new StringBuilder () ;
StringBuilder buffer
StringBuilder outBuffer = new StringBuilder () ;
result = solver . solve ( NUMBER_CONSTANT , f , min , max ) ;
Assert . assertEquals ( FastMath.PI , solver . solve ( NUMBER_CONSTANT , f , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , solver . getAbsoluteAccuracy () ) ;
{ this ( new SimpleVectorialValueChecker () ) ; }
{ this ( new SimpleScalarValueChecker () ) ; }
try { StatUtils . min ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . max ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . mean ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new OutOfRangeException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw new OutOfRangeException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
{ if ( a < NUMBER_CONSTANT ) { ret = a - b ; } else { throw new MathArithmeticException ( msg ) ; } }
try { m . preMultiply ( new BlockRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . multiply ( new BlockRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . subtract ( new BlockRealMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
{ try { UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {} }
{ try { UnivariateRealSolverUtils . solve ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail () ; } catch ( MathIllegalArgumentException ex ) {} }
{ if ( numerator == Integer.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW_IN_FRACTION , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
if ( begin + length > values.length ) { throw new NumberIsTooLargeException ( LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END , begin + length , values.length , true ) ; }
try { m . preMultiply ( new Array2DRowRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . multiply ( new Array2DRowRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . subtract ( new Array2DRowRealMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
if ( x1 < x0 ) { throw new NumberIsTooSmallException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x1 , x0 , true ) ; }
if ( x1 < x0 ) { throw new NumberIsTooSmallException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x1 , x0 , true ) ; }
try { optimizer . getOptima () ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalStateException ise ) {}
@ Test ( expected = MathIllegalArgumentException . class )
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
catch ( NullArgumentException ex ) {}
catch ( NullArgumentException ex ) {}
catch ( NullArgumentException ex ) {}
@ Test ( expected = MathIllegalArgumentException . class )
catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
CompositeFormat . formatDouble ( vector . getEntry ( i ) , format , toAppendTo , pos ) ;
{ return new RealVectorFormat ( CompositeFormat . getDefaultNumberFormat ( locale ) ) ; }
{ this ( prefix , suffix , separator , CompositeFormat . getDefaultNumberFormat () ) ; }
{ NumberFormat f = CompositeFormat . getDefaultNumberFormat ( locale ) ; return new ComplexFormat ( f ) ; }
public ComplexFormat ( String imaginaryCharacter ) { this ( imaginaryCharacter , CompositeFormat . getDefaultNumberFormat () ) ; }
{ return new Vector3DFormat ( CompositeFormat . getDefaultNumberFormat ( locale ) ) ; }
{ this ( prefix , suffix , separator , CompositeFormat . getDefaultNumberFormat () ) ; }
if ( ! found ) { Assert . fail ( msg + STRING_CONSTANT + ( new ComplexFormat () ) . format ( z ) ) ; }
Class < > type
{ this ( imaginaryCharacter , format , format ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( s == NUMBER_CONSTANT ) { throw new MathArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
try { alg = MessageDigest . getInstance ( STRING_CONSTANT ) ; } catch ( NoSuchAlgorithmException ex ) { throw new MathInternalError ( ex ) ; }
throw new MathInternalError () ;
throw new MathInternalError () ;
denseOutput = requiresDenseOutput () || ( ! eventsStates . isEmpty () ) ;
{ super . addStepHandler ( handler ) ; denseOutput = requiresDenseOutput () || ( ! eventsStates . isEmpty () ) ; initializeArrays () ; }
denseOutput = requiresDenseOutput () || ( ! eventsStates . isEmpty () ) ;
denseOutput = requiresDenseOutput () || ( ! eventsStates . isEmpty () ) ;
stepStart = acceptStep ( interpolator , y , yDot , t ) ;
stepStart = acceptStep ( interpolator , y , yDot , t ) ;
final double temp = sinEpsA * HEX_40000000 ;
final double tmp = hiPrec [ NUMBER_CONSTANT ] * HEX_40000000 ;
if ( x >= TWO_POWER_52 || x <= - TWO_POWER_52 ) { return x ; }
if ( y >= TWO_POWER_52 || y <= - TWO_POWER_52 ) { return pow ( - x , y ) ; }
final double epsilon = xa - EIGHTHS [ idx ] ;
final double epsilon = xa - EIGHTHS [ idx ] ;
final boolean fatal = true ;
final boolean fatal = false ;
if ( invx == NUMBER_CONSTANT ) { if ( x > NUMBER_CONSTANT ) { return y ; } else { return copySign ( Math.PI , y ) ; } }
if ( xa == NUMBER_CONSTANT ) { return leftPlane ? copySign ( Math.PI , xa ) : xa ; }
@ Ignore
{ return ( int ) floor ( x + NUMBER_CONSTANT ) ; }
public int [] getSizes () { return MathUtils . copyOf ( size ) ; }
this . size = MathUtils . copyOf ( size ) ;
public int [] getCounts () { return MathUtils . copyOf ( counter ) ; }
final double [] d = MathUtils . copyOf ( direc [ i ] ) ;
{ return ONE_WAY_ANANOVA . anovaTest ( categoryData , alpha ) ; }
{ return ONE_WAY_ANANOVA . anovaPValue ( categoryData ) ; }
{ return ONE_WAY_ANANOVA . anovaFValue ( categoryData ) ; }
{ return UNKNOWN_DISTRIBUTION_CHI_SQUARE_TEST . chiSquareTestDataSetsComparison ( observed1 , observed2 , alpha ) ; }
{ return UNKNOWN_DISTRIBUTION_CHI_SQUARE_TEST . chiSquareTestDataSetsComparison ( observed1 , observed2 ) ; }
{ return UNKNOWN_DISTRIBUTION_CHI_SQUARE_TEST . chiSquareDataSetsComparison ( observed1 , observed2 ) ; }
{ return CHI_SQUARE_TEST . chiSquareTest ( counts ) ; }
{ return CHI_SQUARE_TEST . chiSquareTest ( counts , alpha ) ; }
{ return CHI_SQUARE_TEST . chiSquareTest ( expected , observed ) ; }
{ return CHI_SQUARE_TEST . chiSquareTest ( expected , observed , alpha ) ; }
{ return CHI_SQUARE_TEST . chiSquare ( counts ) ; }
{ return CHI_SQUARE_TEST . chiSquare ( expected , observed ) ; }
{ return T_TEST . tTest ( sampleStats1 , sampleStats2 ) ; }
{ return T_TEST . tTest ( sampleStats1 , sampleStats2 , alpha ) ; }
{ return T_TEST . tTest ( sample1 , sample2 ) ; }
{ return T_TEST . tTest ( sample1 , sample2 , alpha ) ; }
{ return T_TEST . tTest ( mu , sampleStats ) ; }
{ return T_TEST . tTest ( mu , sampleStats , alpha ) ; }
{ return T_TEST . tTest ( mu , sample ) ; }
{ return T_TEST . tTest ( mu , sample , alpha ) ; }
{ return T_TEST . t ( sampleStats1 , sampleStats2 ) ; }
{ return T_TEST . t ( sample1 , sample2 ) ; }
{ return T_TEST . t ( mu , sampleStats ) ; }
{ return T_TEST . t ( mu , observed ) ; }
{ return T_TEST . pairedTTest ( sample1 , sample2 ) ; }
{ return T_TEST . pairedTTest ( sample1 , sample2 , alpha ) ; }
{ return T_TEST . pairedT ( sample1 , sample2 ) ; }
{ return T_TEST . homoscedasticTTest ( sampleStats1 , sampleStats2 ) ; }
{ return T_TEST . homoscedasticTTest ( sample1 , sample2 ) ; }
{ return T_TEST . homoscedasticTTest ( sample1 , sample2 , alpha ) ; }
{ return T_TEST . homoscedasticT ( sampleStats1 , sampleStats2 ) ; }
{ return T_TEST . homoscedasticT ( sample1 , sample2 ) ; }
private TestUtils () { super(); }
return y ;
RealMatrix arzneg = selectColumns ( arz , MathUtils . copyOf ( arReverseIndex , mu ) ) ;
setStateInitialized ( false ) ;
setStateInitialized ( false ) ;
setStateInitialized ( false ) ;
double numer = bits & NUMBER_CONSTANT ;
setStateInitialized ( false ) ;
setStateInitialized ( false ) ;
final ParametricUnivariateRealFunction f
final ParametricUnivariateRealFunction f
final ParametricUnivariateRealFunction f
ParametricUnivariateRealFunction sif = new SimpleInverseFunction () ;
ParametricUnivariateRealFunction sif = new SimpleInverseFunction () ;
final double g = Gaussian . value ( diff , norm , i2s2 ) ;
{ super ( optimizer ) ; ; }
final boolean fatal = true ;
{ this ( specific , LocalizedFormats.ILLEGAL_STATE , args ) ; }
{ super ( null , specific , general , args ) ; }
{ super ( null , null , LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
{ Assert . assertEquals ( reference , p . toString () ) ; }
Assert . assertEquals ( reference , p . multiply ( q ) . toString () ) ;
{ Assert . assertEquals ( reference , p . toString () ) ; }
oneOverN = NUMBER_CONSTANT / n ;
return _isMinimize ? penalty : - penalty ;
if ( _boundaries == null ) return true ;
return isMinimize ? penalty : - penalty ;
if ( boundaries == null ) return true ;
final FitnessFunction fitfun = new FitnessFunction () ;
{ super ( specific , wrong , expected ) ; dimension = expected ; }
public ZeroException ( Localizable specific ) { super ( specific , NUMBER_CONSTANT ) ; }
if ( result == - NUMBER_CONSTANT ) { throw new MathArithmeticException () ; }
super ( specific , lo , hi , fLo , fHi , args ) ;
{ this ( LocalizedFormats.SAME_SIGN_AT_ENDPOINTS , lo , hi , fLo , fHi ) ; }
{ addMessage ( LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
{ super ( specific , wrong , args ) ; }
{ this ( LocalizedFormats.NOT_FINITE_NUMBER , wrong , args ) ; }
public MathInternalError ( final Throwable cause ) { super ( cause , LocalizedFormats.INTERNAL_ERROR , REPORT_URL ) ; }
{ super ( specific , max , args ) ; this . max = max ; }
public MaxCountExceededException ( Number max ) { this ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; }
catch ( IOException ioe ) {}
super ( specific , wrong , min ) ;
{ this ( boundIsAllowed ? LocalizedFormats.NUMBER_TOO_SMALL : LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED , wrong , min , boundIsAllowed ) ; }
{ super ( specific , wrong , lo , hi ) ; this . lo = lo ; this . hi = hi ; }
{ this ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , wrong , lo , hi ) ; }
{ super ( cause ) ; addMessage ( LocalizedFormats.USER_EXCEPTION , null ) ; }
super ( specific , wrong , expected ) ;
{ this ( LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ; }
{ super ( specific , null ) ; }
super ( specific , wrong , max ) ;
{ this ( boundIsAllowed ? LocalizedFormats.NUMBER_TOO_LARGE : LocalizedFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED , wrong , max , boundIsAllowed ) ; }
{ ++ count ; Assert . assertEquals ( i + j / NUMBER_CONSTANT , value , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
{ Assert . assertEquals ( NUMBER_CONSTANT , l . getEntry ( i , j ) , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
{ ++ count ; Assert . assertEquals ( i + j / NUMBER_CONSTANT , value , NUMBER_CONSTANT ) ; }
{ Assert . assertEquals ( NUMBER_CONSTANT , m . getEntry ( i , j ) , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
@ Override protected void doFinalize ( ) throws MathUserException { throw new MathUserException () ; }
@ Override protected void doFinalize ( ) throws MathUserException { throw new MathUserException ( LocalizedFormats.SIMPLE_MESSAGE , STRING_CONSTANT ) ; }
catch ( IOException ioe ) { assertEquals ( NUMBER_CONSTANT , ioe . getMessage () . length () ) ; }
{ super ( cause ) ; addMessage ( LocalizedFormats.USER_EXCEPTION ) ; }
private Beta () {}
private Gamma () {}
private Erf () {}
@ Before public void setUp () { f = new Frequency () ; }
Assert . assertTrue ( bestFinal . compareTo ( bestInitial ) > NUMBER_CONSTANT ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
{ ComplexField field = ComplexField . getInstance () ; Assert . assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { Assert . assertEquals ( Complex.ONE , ComplexField . getInstance () . getOne () ) ; }
@ Test public void testZero () { Assert . assertEquals ( Complex.ZERO , ComplexField . getInstance () . getZero () ) ; }
{ Assert . assertEquals ( a1 , MathUtils . normalizeAngle ( a2 , a1 ) , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( p , TestUtils . serializeAndRecover ( p ) ) ;
@ Before
@ After public void tearDown () { pb = null ; integ = null ; }
@ Before
Assert . assertTrue ( FastMath . abs ( h ) < minStep ) ;
Assert . assertEquals ( STRING_CONSTANT , s . getN () , u . getN () ) ;
{ double variance = regression . estimateRegressandVariance () ; Assert . assertTrue ( variance > NUMBER_CONSTANT ) ; }
{ double [] [] variance = regression . estimateRegressionParametersVariance () ; Assert . assertEquals ( getNumberOfRegressors () , variance.length ) ; }
{ double [] e = regression . estimateResiduals () ; Assert . assertEquals ( getSampleSize () , e.length ) ; }
{ double [] beta = regression . estimateRegressionParameters () ; Assert . assertEquals ( getNumberOfRegressors () , beta.length ) ; }
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
Assert . assertEquals ( c3 , population . getFittestChromosome () ) ;
Assert . assertTrue ( uniquePointIsCenter ) ;
if ( isLast ) { Assert . assertTrue ( maxError > NUMBER_CONSTANT ) ; }
@ Before
Assert . assertEquals ( approYDot , yDot [ i ] , threshold ) ;
Assert . assertEquals ( NUMBER_CONSTANT , changes ) ;
try { new Fraction ( a , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( ConvergenceException ce ) {}
Assert . fail ( STRING_CONSTANT ) ;
{ DummyRandomKey drk = new DummyRandomKey ( RandomKey . randomPermutation ( NUMBER_CONSTANT ) ) ; Assert . assertNotNull ( drk ) ; }
catch ( FractionConversionException fce ) { Assert . fail ( fce . getMessage () ) ; }
catch ( FractionConversionException fce ) { Assert . fail ( fce . getMessage () ) ; }
Assert . assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
Assert . assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
Assert . assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
{ Assert . assertEquals ( y [ i ] , iResult [ i ] ) ; }
Assert . assertTrue ( maxError < NUMBER_CONSTANT ) ;
protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertTrue ( Double . isNaN ( statistic . getResult () ) ) ; }
if ( isLast ) { Assert . assertTrue ( maxError > NUMBER_CONSTANT ) ; }
{ BigRealField field = BigRealField . getInstance () ; Assert . assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { Assert . assertEquals ( BigReal.ONE , BigRealField . getInstance () . getOne () ) ; }
@ Test public void testZero () { Assert . assertEquals ( BigReal.ZERO , BigRealField . getInstance () . getZero () ) ; }
Assert . assertEquals ( STRING_CONSTANT + p , expected , actual , NUMBER_CONSTANT ) ;
Assert . assertEquals ( STRING_CONSTANT + x , expected , actual , NUMBER_CONSTANT ) ;
if ( isLast ) { Assert . assertTrue ( maxError > NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , numDifferent ) ;
Assert . assertTrue ( fitnessCalls <= neededCalls ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
@ After public void tearDown () { pb = null ; integ = null ; }
@ Before
{ FractionField field = FractionField . getInstance () ; Assert . assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { Assert . assertEquals ( Fraction.ONE , FractionField . getInstance () . getOne () ) ; }
@ Test public void testZero () { Assert . assertEquals ( Fraction.ZERO , FractionField . getInstance () . getZero () ) ; }
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( expected . getN () , observed . getN () ) ;
@ Before public void setUp () { tooShortStats = new SummaryStatistics () ; tooShortStats . addValue ( NUMBER_CONSTANT ) ; }
{ Assert . assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ Assert . assertEquals ( null , expected , actual , delta ) ; }
{ try { new DummyBinaryChromosome ( repr ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException e ) {} }
Assert . assertEquals ( NUMBER_CONSTANT , nextGeneration . getPopulationSize () ) ;
@ After public void tearDown () { refValues = null ; matrix = null ; }
@ Before
{ Assert . assertTrue ( isIncludedColumn ( eigenVector , ed . getV () , tolerance ) ) ; }
{ if ( column > row ) { Assert . assertEquals ( NUMBER_CONSTANT , value , entryTolerance ) ; } }
{ if ( column < row ) { Assert . assertEquals ( NUMBER_CONSTANT , value , entryTolerance ) ; } }
Assert . assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
Assert . assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
{ BigFractionField field = BigFractionField . getInstance () ; Assert . assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { Assert . assertEquals ( BigFraction.ONE , BigFractionField . getInstance () . getOne () ) ; }
@ Test public void testZero () { Assert . assertEquals ( BigFraction.ZERO , BigFractionField . getInstance () . getZero () ) ; }
Assert . assertEquals ( STRING_CONSTANT , s . getN () , u . getN () ) ;
public NoDataException ( Localizable specific ) { super ( specific ) ; }
double . . . param
double . . . param
double . . . param
double . . . param
double . . . param
double . . . param
double . . . doubles
double . . . parameters
double . . . param
double . . . param
double . . . param
double . . . param
final double . . . parameters
double . . . parameters
public void setMinimalIterationCount ( final int count ) { minimalIterationCount = count ; }
UnivariateRealIntegratorImpl integrator = new LegendreGaussIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final double [] z = concatenateSamples ( x , y ) ;
public Set < String > getContextKeys () { throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
public Object getContext ( String key ) { throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
{ throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
{ throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
public Set < String > getContextKeys () { throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
public Object getContext ( String key ) { throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
{ throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
{ throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
double getRelativeAccuracy ( ) ;
double getAbsoluteAccuracy ( ) ;
int getMaximalIterationCount ( ) ;
Assert . assertEquals ( PearsonsCorrelation . correlation ( x , y ) , corrInstance . getCorrelationMatrix () . getEntry ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , Double.MIN_VALUE ) ;
{ PearsonsCorrelation . correlation ( one , two ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertTrue ( Double . isNaN ( PearsonsCorrelation . correlation ( noVariance , values ) ) ) ;
Assert . assertEquals ( new PearsonsCorrelation () . correlation ( x , y ) , corrInstance . getCorrelationMatrix () . getEntry ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , Double.MIN_VALUE ) ;
{ new PearsonsCorrelation () . correlation ( one , two ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertTrue ( Double . isNaN ( new PearsonsCorrelation () . correlation ( noVariance , values ) ) ) ;
normps = ps . getFrobeniusNorm () ;
normps = ps . getFrobeniusNorm () ;
{ super ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; this . max = max ; }
final SimplexTableau tableau = new SimplexTableau ( function , linearConstraints , goal , nonNegative , epsilon , maxUlps ) ;
if ( MathUtils . compareTo ( entry , minValue , maxUlps ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
if ( MathUtils . compareTo ( entry , NUMBER_CONSTANT , maxUlps ) > NUMBER_CONSTANT ) { columnsToDrop . add ( i ) ; }
{ context . addMessage ( pattern , args ) ; }
{ context . addMessage ( pattern , args ) ; }
{ super ( cause ) ; context . addMessage ( pattern , args ) ; }
{ context . addMessage ( pattern , args ) ; }
{ getContext () . addMessage ( LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
{ context . addMessage ( pattern , args ) ; }
{ this ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; }
{ super ( max ) ; getContext () . addMessage ( LocalizedFormats.EVALUATIONS ) ; }
{ getContext () . addMessage ( pattern , args ) ; }
{ super ( cause ) ; context . addMessage ( pattern , arguments ) ; }
{ context . addMessage ( pattern , arguments ) ; }
{ super ( cause ) ; context . addMessage ( LocalizedFormats.USER_EXCEPTION ) ; }
this . field = field ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
{ this ( extractField ( d ) , d ) ; }
return new ArrayFieldVector < T > ( getField () , outData , false ) ;
return new ArrayFieldVector < T > ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix < T > ( field , d , false ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testData ) ;
Assert . assertEquals ( new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , fractionColMatrix ) , MatrixUtils . createFieldMatrix ( fractionColMatrix ) ) ;
return new Array2DRowFieldMatrix < T > ( field , bp , false ) ;
return new ArrayFieldVector < T > ( field , bp , false ) ;
return new Array2DRowFieldMatrix < BigFraction > ( BigFractionField . getInstance () , Hdata ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
{ return projection ( new ArrayFieldVector < T > ( getField () , v , false ) ) ; }
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testDataInv ) ) , identity , entryTolerance ) ;
final String source
{ super ( prefix , suffix , separator , CompositeFormat . getDefaultNumberFormat () ) ; }
public Vector3DFormat ( final NumberFormat format ) { super ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_SEPARATOR , format ) ; }
public Vector3DFormat () { super ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_SEPARATOR , CompositeFormat . getDefaultNumberFormat () ) ; }
Hyperplane < S > other
Vector < S > point
final BSPTreeVisitor < S > visitor
void visitLeafNode ( BSPTree < S > node ) ;
BSPTree < S > node
BSPTree < S > node
public Order visitOrder ( final BSPTree < Euclidean2D > node ) { return Order.MINUS_SUB_PLUS ; }
final BSPTree < Euclidean2D > tree
final Vector2D tmp = loop [ min ] ;
final Vector2D [] bLoop
final Hyperplane < Euclidean3D > other
final Vector < Euclidean3D > point
final Vector3D p
origin = new Vector3D ( - originOffset , w ) ;
public Order visitOrder ( final BSPTree < Euclidean3D > node ) { return Order.MINUS_SUB_PLUS ; }
public BoundaryProjector () { projected = new PolygonsSet ( new BSPTree < Euclidean2D > ( Boolean.FALSE ) ) ; }
final Vector2D p
final Hyperplane < Euclidean2D > other
final Vector2D p
public Order visitOrder ( final BSPTree < Euclidean3D > node ) { return Order.MINUS_SUB_PLUS ; }
final BSPTree < Euclidean3D > tree
final BSPTree < Euclidean1D > tree
Vector3D point = p . intersection ( l ) ;
Vector3D [] points
final Hyperplane < Euclidean1D > other
public abstract SplitSubHyperplane < S > split ( Hyperplane < S > hyper ) ;
public abstract Side side ( Hyperplane < S > hyper ) ;
{ if ( in [ i ] < NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX , i , in [ i ] ) ; } }
{ if ( val < NUMBER_CONSTANT || val > NUMBER_CONSTANT ) { throw new InvalidRepresentationException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , val , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
for ( int i : chromosomeRepresentation ) { if ( i < NUMBER_CONSTANT || i > NUMBER_CONSTANT ) throw new InvalidRepresentationException ( LocalizedFormats.INVALID_BINARY_DIGIT , i ) ; }
clusters = transformer . cluster ( Arrays . asList ( points ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
public RealVector getInitialStateEstimate () { return initialStateEstimateVector ; }
{ numElements -= i ; if ( front ) { startIndex += i ; } }
{ for ( Chromosome anotherChr : population ) { if ( this . isSame ( anotherChr ) ) { return anotherChr ; } } return null ; }
if ( remA > NUMBER_CONSTANT ) { break; }
if ( remA > NUMBER_CONSTANT ) { break; }
if ( remA > NUMBER_CONSTANT ) { break; }
if ( x * x == NUMBER_CONSTANT ) { return Double.NaN ; }
if ( t == NUMBER_CONSTANT && i >= j ) { continue; }
if ( boundaries == null ) { return x ; }
if ( boundaries == null ) { return x ; }
if ( negccov > negcovMax ) { negccov = negcovMax ; }
if ( y . equals ( py ) ) { break; }
if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; }
if ( ! forward ) { h = - h ; }
{ if ( maxGenerations <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . maxGenerations = maxGenerations ; }
{ super ( relativeAccuracy , absoluteAccuracy ) ; }
public SecantSolver ( final double absoluteAccuracy ) { super ( absoluteAccuracy ) ; }
{ this . allowed = allowedSolutions ; return super . solve ( maxEval , f , min , max , startValue ) ; }
{ super ( relativeAccuracy , absoluteAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ super ( absoluteAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ se [ i ] = FastMath . sqrt ( var ) ; continue; }
if ( ! Double . isNaN ( var ) && var > Double.MIN_VALUE ) { return FastMath . sqrt ( var ) ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
{ if ( isNaN ) { return NaN ; } return createComplex ( FastMath . log ( abs () ) , FastMath . atan2 ( imaginary , real ) ) ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN || rhs.isNaN ) { return NaN ; }
{ if ( isNaN ) { return NaN ; } return createComplex ( - real , - imaginary ) ; }
if ( isNaN || Double . isNaN ( rhs ) ) { return NaN ; }
if ( isNaN || rhs.isNaN ) { return NaN ; }
if ( isNaN ) { return NUMBER_CONSTANT ; }
if ( isNaN || rhs.isNaN ) { return NaN ; }
{ if ( isNaN ) { return NaN ; } return createComplex ( real , - imaginary ) ; }
if ( isNaN ) { return Double.NaN ; }
{ if ( rng . nextBoolean () ) { throw new MathIllegalStateException () ; } }
Assert . assertTrue ( Double . isNaN ( w . getReal () ) ) ;
{ include ( MathUtils . copyOf ( x , x.length ) , NUMBER_CONSTANT , y ) ; }
if ( index < NUMBER_CONSTANT || index >= this . parameters . length ) { throw new IndexOutOfBoundsException ( indexOutOfBound ) ; }
if ( index < NUMBER_CONSTANT || index >= this . parameters . length ) { throw new IndexOutOfBoundsException ( indexOutOfBound ) ; }
{ return outerProduct ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return getLInfDistance ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return getL1Distance ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return getDistance ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return dotProduct ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return ebeDivide ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return ebeMultiply ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return subtract ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return add ( ( ( ArrayRealVector ) v ) . data ) ; }
{ super ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , Method.REGULA_FALSI ) ; }
Assert . assertSame ( Complex.NaN , z ) ;
{ return node . getElement () . intValue () ; }
if ( numberOfVariables < NUMBER_CONSTANT ) { throw new ModelSpecificationException ( LocalizedFormats.NO_REGRESSORS ) ; }
{ addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , NUMBER_CONSTANT ) ) ; }
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolution.ABOVE_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolution.BELOW_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolution.RIGHT_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolution.LEFT_SIDE ) ;
this . allowed = AllowedSolution.ANY_SIDE ;
this . allowed = AllowedSolution.ANY_SIDE ;
this . allowed = AllowedSolution.ANY_SIDE ;
{ return solve ( maxEval , f , min , max , startValue , AllowedSolution.ANY_SIDE ) ; }
{ super ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy ) ; this . allowed = AllowedSolution.ANY_SIDE ; this . method = method ; }
{ super ( relativeAccuracy , absoluteAccuracy ) ; this . allowed = AllowedSolution.ANY_SIDE ; this . method = method ; }
{ super ( absoluteAccuracy ) ; this . allowed = AllowedSolution.ANY_SIDE ; this . method = method ; }
double x = randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double dot = v1 . dotProduct ( v2 ) ;
{ return new Solver ( singularValues , getUT () , getV () , getRank () == m ) ; }
tol = FastMath . max ( m * singularValues [ NUMBER_CONSTANT ] * EPS , FastMath . sqrt ( MathUtils.SAFE_MIN ) ) ;
{ super . setEntry ( row - INDEX_OFFSET , col - INDEX_OFFSET , value ) ; }
{ super . setEntry ( index - INDEX_OFFSET , value ) ; }
fsave = fval . getEntry ( INDEX_OFFSET ) ;
{ return point . dotProduct ( w ) + originOffset ; }
{ setNormal ( normal ) ; originOffset = - p . dotProduct ( w ) ; setFrame () ; }
final Vector3D n = new Vector3D ( NUMBER_CONSTANT , d , - d . dotProduct ( direction ) , direction ) ;
crossP . dotProduct ( otherPlane . getNormal () ) < NUMBER_CONSTANT
crossP . dotProduct ( otherPlane . getNormal () ) < NUMBER_CONSTANT
double scaled = area * facetB . dotProduct ( plane . getNormal () ) ;
public Line revert () { return new Line ( zero , zero . subtract ( direction ) ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS , nRows , nCols ) ; }
if ( ( delta <= rLimit ) || ( delta <= absoluteAccuracy ) ) { return t ; }
if ( ( delta <= rLimit ) || ( delta <= absoluteAccuracy ) ) { return s ; }
{ return t ; }
RealVector v = RealVector . unmodifiableRealVector ( u . copy () ) ;
RealVector v = RealVector . unmodifiableRealVector ( u . copy () ) ;
RealVector v = RealVector . unmodifiableRealVector ( u ) ;
RealVector v = RealVector . unmodifiableRealVector ( u ) ;
RealVector v = RealVector . unmodifiableRealVector ( u ) ;
RealVector v = RealVector . unmodifiableRealVector ( u ) ;
final double [] actual = x . toArray () ;
final double [] actual = z . toArray () ;
double [] d2 = w . toArray () ;
{ return coefficients . dotProduct ( new ArrayRealVector ( point , false ) ) + constantTerm ; }
final ArrayRealVector x = new ArrayRealVector ( dim ) ;
final ArrayRealVector x = new ArrayRealVector ( dim ) ;
dist = new EmpiricalDistributionImpl ( NUMBER_CONSTANT , ( RandomGenerator ) null ) ;
empiricalDistribution = new EmpiricalDistributionImpl ( binCount , randomData ) ;
public EmpiricalDistributionImpl ( int binCount ) { this ( binCount , new RandomDataImpl () ) ; }
return NUMBER_CONSTANT * ( NUMBER_CONSTANT + Erf . erf ( dev / ( standardDeviation * SQRT2 ) ) ) ;
{ this ( new SimpleScalarValueChecker ( rel , abs ) ) ; }
@ Test ( expected = ConvergenceException . class )
{ solver . solve ( b . getColumnVector ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ solver . solve ( b . getColumnVector ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ es . solve ( b . getColumnVector ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ solver . solve ( b . getColumnVector ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertEquals ( z , Complex.INF ) ;
Assert . assertEquals ( z , Complex.NaN ) ;
final ExceptionContext cOut = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
final ExceptionContext cOut = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
final ExceptionContext c = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
final ExceptionContext c = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
final ExceptionContext c = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
@ Test ( expected = MaxCountExceededException . class )
@ Test ( expected = MaxCountExceededException . class )
Exception e
Exception e
int i = FACT_LEN - NUMBER_CONSTANT
public double [] getStateEstimation () { return stateEstimation . toArray () ; }
assertClose ( m . preMultiply ( new ArrayRealVector ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
assertClose ( testVector , m . operate ( new ArrayRealVector ( testVector ) ) . toArray () , entryTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . toArray () , entryTolerance ) ;
double [] hatResiduals = I . subtract ( hat ) . operate ( model.Y ) . toArray () ;
TestUtils . assertEquals ( new double [] { - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , b . toArray () , NUMBER_CONSTANT ) ;
TestUtils . assertEquals ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , - NUMBER_CONSTANT , NUMBER_CONSTANT } , b . toArray () , NUMBER_CONSTANT ) ;
final double objectiveValue = computeObjectiveValue ( currentBest . toArray () ) ;
f = computeObjectiveValue ( currentBest . toArray () ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . toArray () , entryTolerance ) ;
if ( x instanceof ArrayRealVector ) { return ( ( ArrayRealVector ) x ) . getDataRef () ; } else { return x . toArray () ; }
return e . toArray () ;
{ RealVector b = calculateBeta () ; return b . toArray () ; }
double [] y = u . add ( x . operate ( b ) ) . toArray () ;
final double [] actual = x . toArray () ;
final double [] actual = x . toArray () ;
final double [] actual = x . combine ( a , b , y ) . toArray () ;
final double [] actual = x . combine ( a , b , y ) . toArray () ;
Assert . assertNotSame ( STRING_CONSTANT , v1.data , v_copy . toArray () ) ;
final double [] x = b . toArray () ;
{ double sum = NUMBER_CONSTANT ; for ( double coefficient : coefficients . toArray () ) { sum -= coefficient ; } return sum ; }
if ( ltI [ i ] < absolutePositivityThreshold ) { throw new NonPositiveDefiniteMatrixException ( ltI [ i ] , i , absolutePositivityThreshold ) ; }
{ return hasIntercept ? getIntercept ( getSlope () ) : NUMBER_CONSTANT ; }
int i = FACT.length - NUMBER_CONSTANT
int i = FACT.length - NUMBER_CONSTANT
int i = FACT.length - NUMBER_CONSTANT
CholeskyDecompositionImpl llt = new CholeskyDecompositionImpl ( matrix ) ;
CholeskyDecompositionImpl llt = new CholeskyDecompositionImpl ( matrix ) ;
DecompositionSolver solver = new CholeskyDecomposition ( s ) . getSolver () ;
DecompositionSolver solver = new CholeskyDecomposition ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = new CholeskyDecomposition ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
final RealMatrix matrix = EigenDecompositionTest . createTestMatrix ( new Random ( NUMBER_CONSTANT ) , refValues ) ;
EigenDecompositionImpl eig = new EigenDecompositionImpl ( C , NUMBER_CONSTANT ) ;
EigenDecomposition ed
EigenDecomposition ed
RealMatrix v = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) . getV () ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
EigenDecomposition eig = new EigenDecomposition ( C , NUMBER_CONSTANT ) ;
final int max = val.length ;
final int max = val.length ;
final int max = val.length ;
throw new MathInternalError () ;
throw new MathInternalError () ;
throw new MathInternalError () ;
throw new MathInternalError () ;
final double slope
final double slope
final double alpha
FieldDecompositionSolver < BigFraction > pSolver = new FieldLUDecomposition < BigFraction > ( bigP ) . getSolver () ;
{ return new FieldLUDecomposition < Fraction > ( m ) . getDeterminant () . doubleValue () ; }
solver = new FieldLUDecomposition < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
solver = new FieldLUDecomposition ( createFractionMatrix ( singular ) ) . getSolver () ;
solver = new FieldLUDecomposition < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
catch ( NonMonotonicSequenceException iae ) {}
@ Test ( expected = NonMonotonicSequenceException . class )
catch ( NonMonotonicSequenceException iae ) {}
@ Test ( expected = NonMonotonicSequenceException . class )
@ Test ( expected = NonMonotonicSequenceException . class )
@ Test ( expected = NonMonotonicSequenceException . class )
DecompositionSolver solver = useLU ? new LUDecomposition ( mA ) . getSolver () : new QRDecompositionImpl ( mA ) . getSolver () ;
return new LUDecomposition ( XTOIX ) . getSolver () . getInverse () ;
RealMatrix inverse = new LUDecomposition ( XTOIX ) . getSolver () . getInverse () ;
final DecompositionSolver solver = new LUDecomposition ( MatrixUtils . createRealMatrix ( jTj ) , threshold ) . getSolver () ;
DecompositionSolver solver = new LUDecomposition ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = new LUDecomposition ( MatrixUtils . createRealMatrix ( singular ) ) . getSolver () ;
DecompositionSolver solver = new LUDecomposition ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
RealMatrix Rinv = new LUDecomposition ( Raug ) . getSolver () . getInverse () ;
DecompositionSolver solver = useLU ? new LUDecomposition ( mA ) . getSolver () : new QRDecomposition ( mA ) . getSolver () ;
RealMatrix x = new QRDecomposition ( a ) . getSolver () . solve ( b ) ;
RealMatrix x = new QRDecomposition ( a ) . getSolver () . solve ( b ) ;
DecompositionSolver solver = new QRDecomposition ( MatrixUtils . createRealMatrix ( testData3x3Singular ) ) . getSolver () ;
DecompositionSolver solver = new QRDecomposition ( MatrixUtils . createRealMatrix ( testData3x3NonSingular ) ) . getSolver () ;
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( X ) ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( X ) ; }
final RectangularCholeskyDecomposition decomposition = new RectangularCholeskyDecomposition ( covariance , small ) ;
final RectangularCholeskyDecomposition decomposition = new RectangularCholeskyDecomposition ( covariance , small ) ;
SingularValueDecomposition svd = new SingularValueDecomposition ( rm ) ;
DecompositionSolver solver = new SingularValueDecomposition ( MatrixUtils . createRealMatrix ( testSquare ) ) . getSolver () ;
DecompositionSolver solver = new SingularValueDecomposition ( m ) . getSolver () ;
DecompositionSolver solver = new SingularValueDecomposition ( MatrixUtils . createRealMatrix ( testSquare ) ) . getSolver () ;
{ g0Positive = g0 >= NUMBER_CONSTANT ; nextAction = EventHandler.Action.CONTINUE ; }
nextAction = EventHandler.Action.CONTINUE ;
final ExpandableFirstOrderDifferentialEquations equations
final ExpandableFirstOrderDifferentialEquations equations
ExpandableFirstOrderDifferentialEquations equations
{ out . writeDouble ( polynomials [ k ] [ l ] ) ; }
final double e = polynomials [ currentDegree ] [ i ] / scale [ i ] ;
{ return ( T [] ) Array . newInstance ( field . getRuntimeClass () , length ) ; }
( T [] [] ) Array . newInstance ( field . getRuntimeClass () , new int [] { dimension , dimension } )
{ return ( T [] ) Array . newInstance ( field . getRuntimeClass () , length ) ; }
{ return ( T [] ) Array . newInstance ( field . getRuntimeClass () , length ) ; }
array = ( T [] ) Array . newInstance ( field . getRuntimeClass () , length )
Array . newInstance ( field . getRuntimeClass () , new int [] { m , nColB } )
bp = ( T [] ) Array . newInstance ( field . getRuntimeClass () , m )
bp = ( T [] ) Array . newInstance ( field . getRuntimeClass () , m )
{ return ( T [] ) Array . newInstance ( field . getRuntimeClass () , length ) ; }
solver . solve ( a , b ) ;
final RealVector x = solver . solve ( a , m , b ) ;
final RealVector x = solver . solve ( a , m , b ) ;
solver . solve ( a , m , b ) ;
solver . solve ( a , m , b ) ;
solver . solve ( a , m , b ) ;
final RealVector x = solver . solve ( a , b ) ;
final RealVector x = solver . solve ( a , b , x0 ) ;
final RealVector x = solver . solveInPlace ( a , b , x0 ) ;
final RealVector x = solver . solve ( a , b ) ;
solver . solve ( a , b , x ) ;
solver . solve ( a , b , x ) ;
solver . solve ( a , b , x ) ;
solver . solve ( a , b , x ) ;
if ( nSteps <= NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS , name ) ; }
throw new MathIllegalArgumentException ( LocalizedFormats.N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED , n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
catch ( MathIllegalArgumentException e ) {}
catch ( MathParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
catch ( MathParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
try { f1 . divide ( f2 ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( ZeroException ex ) {}
catch ( MathParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
catch ( MathParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
{ if ( getN () > NUMBER_CONSTANT ) { throw new MathIllegalStateException ( LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC , getN () ) ; } }
if ( i < NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.INDEX_NOT_POSITIVE , i ) ; }
{ throw new MathIllegalArgumentException ( LocalizedFormats.INITIAL_CAPACITY_NOT_POSITIVE , initialCapacity ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw new MathIllegalArgumentException ( LocalizedFormats.UNSUPPORTED_EXPANSION_MODE , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT ) { throw new ArrayIndexOutOfBoundsException ( index ) ; }
catch ( ClassCastException ex ) { throw new MathIllegalArgumentException ( LocalizedFormats.INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES , v . getClass () . getName () ) ; }
MathIllegalStateException cause = new MathIllegalStateException ( LocalizedFormats.SIMPLE_MESSAGE , inMsg ) ;
{ evaluations . incrementCount () ; expandable . computeDerivatives ( t , y , yDot ) ; }
{ this . expandable = equations ; }
allocateInterpolatedArrays ( y.length ) ;
allocateInterpolatedArrays ( - NUMBER_CONSTANT ) ;
catch ( Exception ex ) { Assert . fail ( STRING_CONSTANT + mean + STRING_CONSTANT + p + STRING_CONSTANT + ex . getMessage () ) ; }
catch ( Exception ex ) { Assert . fail ( STRING_CONSTANT + mean + STRING_CONSTANT + x + STRING_CONSTANT + ex . getMessage () ) ; }
@ Test ( expected = NonPositiveDefiniteOperatorException . class )
@ Test ( expected = NonSquareOperatorException . class )
@ Test ( expected = NonPositiveDefiniteOperatorException . class )
@ Test ( expected = NonSquareOperatorException . class )
if ( ( str = filePointer . readLine () ) == null ) { throw new MathIllegalStateException ( LocalizedFormats.URL_CONTAINS_NO_DATA , valuesFileURL ) ; }
if ( ( empiricalDistribution == null ) || ( empiricalDistribution . getBinStats () . size () == NUMBER_CONSTANT ) ) { throw new MathIllegalStateException ( LocalizedFormats.DIGEST_NOT_INITIALIZED ) ; }
if ( sampleStats . getN () == NUMBER_CONSTANT ) { throw new ZeroException ( LocalizedFormats.URL_CONTAINS_NO_DATA , url ) ; }
catch ( IOException e ) { throw new MathIllegalStateException ( e , LocalizedFormats.SIMPLE_MESSAGE , e . getLocalizedMessage () ) ; }
catch ( ZeroException ze ) {}
catch ( MathIllegalStateException mise ) {}
final List < BigFraction > coefficients
final List < BigFraction > coefficients
double y = x * F_1_3 - F_1_2 ;
{ Assert . assertTrue ( Precision . equals ( out [ i ] , expectedSample [ i ] , NUMBER_CONSTANT ) ) ; }
if ( Precision . compareTo ( entry , minValue , maxUlps ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
isLastStep = isLastStep || Precision . equals ( currentT , tEnd , NUMBER_CONSTANT ) ;
Assert . assertTrue ( Precision . equals ( NUMBER_CONSTANT , MathUtils . distanceInf ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( Precision . equals ( NUMBER_CONSTANT , MathUtils . distance ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( Precision . equals ( NUMBER_CONSTANT , MathUtils . distance ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( Precision . equals ( NUMBER_CONSTANT , MathUtils . distance1 ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( Precision . equals ( binomial , jacobi . value ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ) ;
if ( FastMath . abs ( m ) <= tol || Precision . equals ( fb , NUMBER_CONSTANT ) ) { return b ; }
if ( mode == StepNormalizerMode.MULTIPLES && Precision . equals ( nextTime , lastTime , NUMBER_CONSTANT ) ) { nextTime += h ; }
! Precision . equalsIncludingNaN ( expected [ i ] , observed [ i ] , tolerance )
for ( double value : values ) { if ( Precision . equals ( value , x , epsilon ) ) { return; } }
Precision . equalsIncludingNaN ( stat . getN () , getN () )
if ( Precision . compareTo ( entry , NUMBER_CONSTANT , epsilon ) < NUMBER_CONSTANT ) { return false ; }
if ( Precision . compareTo ( entry , NUMBER_CONSTANT , maxUlps ) > NUMBER_CONSTANT ) { columnsToDrop . add ( i ) ; }
MathArrays . checkOrder ( x ) ;
public int [] getOrderOfRegressors () { return MathArrays . copyOf ( vorder ) ; }
{ include ( MathArrays . copyOf ( x , x.length ) , NUMBER_CONSTANT , y ) ; }
{ if ( this . parameters == null ) { return null ; } return MathArrays . copyOf ( parameters ) ; }
MathArrays . checkOrder ( knots ) ;
{ this ( wrong , previous , index , MathArrays.OrderDirection.INCREASING , true ) ; }
public int [] getSizes () { return MathArrays . copyOf ( size ) ; }
this . size = MathArrays . copyOf ( size ) ;
public int [] getCounts () { return MathArrays . copyOf ( counter ) ; }
final double [] d = MathArrays . copyOf ( direc [ i ] ) ;
return MathArrays . checkOrder ( x , MathArrays.OrderDirection.INCREASING , true , abort ) ;
MathArrays . sortInPlace ( xNew , yNew ) ;
MathArrays . sortInPlace ( this . x , this . y ) ;
MathArrays . checkOrder ( xval ) ;
RealMatrix arzneg = selectColumns ( arz , MathArrays . copyOf ( arReverseIndex , mu ) ) ;
{ return MathArrays . distance ( point , p . getPoint () ) ; }
MathArrays . checkOrder ( x ) ;
Assert . assertEquals ( expectedValue () , variance . evaluate ( testArray , MathArrays . normalizeArray ( identicalWeightsArray , testArray.length ) , NUMBER_CONSTANT , testArray.length ) , getTolerance () ) ;
long lcm = FastMath . abs ( mulAndCheck ( a / ArithmeticsUtils . gcd ( a , b ) , b ) ) ;
int lcm = FastMath . abs ( mulAndCheck ( a / ArithmeticsUtils . gcd ( a , b ) , b ) ) ;
int gcd = ArithmeticsUtils . gcd ( numerator , denominator ) ;
final int d = ArithmeticsUtils . gcd ( num , den ) ;
double binomial = ArithmeticsUtils . binomialCoefficient ( v + i , i ) ;
{ coeff [ i ] [ j ] = ( int ) ArithmeticsUtils . binomialCoefficient ( i , j ) ; }
int gcd = ArithmeticUtils . gcd ( numerator , denominator ) ;
final int d = ArithmeticUtils . gcd ( num , den ) ;
double binomial = ArithmeticUtils . binomialCoefficient ( v + i , i ) ;
{ coeff [ i ] [ j ] = ( int ) ArithmeticUtils . binomialCoefficient ( i , j ) ; }
FastMath . signum ( y0 ) + FastMath . signum ( ym ) == NUMBER_CONSTANT
{ return FastMath . abs ( x ) < SHORTCUT ? NUMBER_CONSTANT : FastMath . sin ( x ) / x ; }
ed = new EigenDecomposition ( indefinite , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( distinct , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( repeated , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( m , Precision.SAFE_MIN ) ;
RealMatrix v = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) . getV () ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( createTestMatrix ( r , bigValues ) , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
if ( FastMath . abs ( tmp ) > Precision.EPSILON ) { w = ( di * w ) / dpi ; }
{ this ( numberOfVariables , includeConstant , Precision.EPSILON ) ; }
if ( FastMath . abs ( diag ) < Precision.SAFE_MIN ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
if ( FastMath . abs ( diag ) < Precision.SAFE_MIN ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
tol = FastMath . max ( m * singularValues [ NUMBER_CONSTANT ] * EPS , FastMath . sqrt ( Precision.SAFE_MIN ) ) ;
LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer ( initialStepBoundFactor , costRelativeTolerance , parRelativeTolerance , orthoTolerance , Precision.SAFE_MIN ) ;
if ( n < Precision.EPSILON ) { return zero ; }
if ( n < Precision.SAFE_MIN ) { return distance ( line.zero ) ; }
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
final double eps = NUMBER_CONSTANT * rows * columns * Precision.EPSILON ;
if ( d > - Precision.SAFE_MIN && d < Precision.SAFE_MIN ) { return d ; }
FastMath . abs ( sumXX ) > Precision.SAFE_MIN
@ Test ( expected = NumberIsTooLargeException . class )
{ this ( numberOfInterpolationPoints , DEFAULT_INITIAL_RADIUS , DEFAULT_STOPPING_RADIUS ) ; }
this . stopfitness = stopFitness ;
this . stopFitness = stopFitness ;
@ Override public boolean isInfinite () { throw unsupported () ; }
@ Override public boolean isNaN () { throw unsupported () ; }
@ Override public boolean isInfinite () { throw unsupported () ; }
@ Override public boolean isNaN () { throw unsupported () ; }
@ Override public boolean isInfinite () { throw unsupported () ; }
@ Override public boolean isNaN () { throw unsupported () ; }
@ Override public void unitize () { throw unsupported () ; }
@ Override public double getLInfNorm () { throw unsupported () ; }
@ Override public double getL1Norm () { throw unsupported () ; }
@ Override public double getNorm () { throw unsupported () ; }
double [] bounds = empiricalDistribution2 . getGeneratorUpperBounds () ;
FieldDecompositionSolver < Fraction > solver ;
double floatn = v.length ;
final double [] eventY = interpolator . getInterpolatedState () . clone () ;
final double [] yTmp = y0 . clone () ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new BetaDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
BetaDistribution betaDistribution = new BetaDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
BetaDistribution d = new BetaDistribution ( alpha , beta ) ;
BetaDistribution d = new BetaDistribution ( alpha , beta ) ;
setDistribution ( new BinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new BinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new CauchyDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new ChiSquaredDistribution ( NUMBER_CONSTANT ) ) ;
ChiSquaredDistribution d = new ChiSquaredDistribution ( df ) ;
setDistribution ( new ChiSquaredDistribution ( NUMBER_CONSTANT ) ) ;
@ Override public ChiSquaredDistribution makeDistribution () { return new ChiSquaredDistribution ( NUMBER_CONSTANT ) ; }
FDistribution fdist = new FDistribution ( a.dfbg , a.dfwg ) ;
@ Override public ExponentialDistribution makeDistribution () { return new ExponentialDistribution ( NUMBER_CONSTANT ) ; }
double [] quartiles = TestUtils . getDistributionQuartiles ( new FDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ gamma = new GammaDistribution ( degreesOfFreedom / NUMBER_CONSTANT , NUMBER_CONSTANT ) ; solverAbsoluteAccuracy = inverseCumAccuracy ; }
GammaDistribution distribution = new GammaDistribution ( a , b ) ;
GammaDistribution distribution = new GammaDistribution ( a , b ) ;
FDistribution fd = new FDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
HypergeometricDistribution dist = new HypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
setDistribution ( new HypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
normal = new NormalDistribution ( p , FastMath . sqrt ( p ) ) ;
NormalDistribution normal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
NormalDistribution distribution = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
NormalDistribution d = new NormalDistribution ( mean , sd ) ;
setDistribution ( new PascalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new PascalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
TDistribution distribution = new TDistribution ( degreesOfFreedom ) ;
TDistribution distribution = new TDistribution ( degreesOfFreedom ) ;
PoissonDistribution dist = new PoissonDistribution ( mean ) ;
PoissonDistribution dist = new PoissonDistribution ( mean ) ;
{ PoissonDistribution dist = new PoissonDistribution ( NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , dist . getMean () , NUMBER_CONSTANT ) ; }
@ Test ( expected = NotStrictlyPositiveException . class ) public void testNegativeMean () { new PoissonDistribution ( - NUMBER_CONSTANT ) ; }
PoissonDistribution dist = new PoissonDistribution ( DEFAULT_TEST_POISSON_PARAMETER ) ;
@ Override public IntegerDistribution makeDistribution () { return new PoissonDistribution ( DEFAULT_TEST_POISSON_PARAMETER ) ; }
double [] quartiles = TestUtils . getDistributionQuartiles ( new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new TDistribution ( NUMBER_CONSTANT ) ) ;
PoissonDistribution poissonDistribution = new PoissonDistribution ( mean ) ;
FastMath . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / n ) + ( xbar * xbar ) / sumXX ) )
TDistribution tDistribution = new TDistribution ( NUMBER_CONSTANT ) ;
TDistribution td = new TDistribution ( df ) ;
setDistribution ( new TDistribution ( NUMBER_CONSTANT ) ) ;
{ TDistribution td = new TDistribution ( NUMBER_CONSTANT ) ; td . cumulativeProbability ( NUMBER_CONSTANT ) ; td . cumulativeProbability ( NUMBER_CONSTANT ) ; }
@ Override public TDistribution makeDistribution () { return new TDistribution ( NUMBER_CONSTANT ) ; }
dist = new ZipfDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_WINDOW_SIZE , windowSize ) ; } }
if ( sign >= NUMBER_CONSTANT && magnitude == Long.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW ) ; } else { return - magnitude ; }
if ( sign >= NUMBER_CONSTANT && magnitude == Integer.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW ) ; } else { return - magnitude ; }
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction f = new Gaussian () ;
final UnivariateFunction f = new Gaussian () ;
final ParametricUnivariateFunction f
final ParametricUnivariateFunction f
final ParametricUnivariateFunction f
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f
UnivariateFunction func
UnivariateFunction f
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
public MonitoredFunction ( UnivariateFunction f ) { callsCount = NUMBER_CONSTANT ; this . f = f ; }
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f = new QuinticFunction () ;
final UnivariateFunction f
final UnivariateFunction f
DifferentiableUnivariateFunction f
DifferentiableUnivariateFunction f
UnivariateFunction dSpline = spline . derivative () ;
UnivariateFunction function
UnivariateFunction function
UnivariateFunction p = interpolator . interpolate ( x , y ) ;
UnivariateFunction f
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new XMinus5Function () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction dfdx = f . derivative () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
final UnivariateFunction f
final UnivariateFunction f
final UnivariateFunction f
final UnivariateFunction f
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction f = new Sigmoid () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
DifferentiableUnivariateFunction f = new QuinticFunction () ;
DifferentiableUnivariateFunction f = new SinFunction () ;
UnivariateFunction p = interpolator . interpolate ( x , y ) ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
ParametricUnivariateFunction sif = new SimpleInverseFunction () ;
ParametricUnivariateFunction sif = new SimpleInverseFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
@ Override public RealVector mapToSelf ( UnivariateFunction function ) { throw unsupported () ; }
@ Override public RealVector map ( UnivariateFunction function ) { throw unsupported () ; }
UnivariateFunction function
UnivariateFunction function
UnivariateFunction function
UnivariateFunction function
UnivariateFunction function
UnivariateFunction f
final UnivariateFunction f
final UnivariateFunction lsf = new LineSearchFunction ( searchDirection ) ;
if ( c . isAssignableFrom ( UnivariateFunction . class ) ) { return new Sin () ; } else { throw new IllegalArgumentException ( STRING_CONSTANT + c ) ; }
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f
UnivariateFunction f
@ Override public RealVector mapToSelf ( UnivariateFunction function ) { throw unsupported () ; }
@ Override public RealVector map ( UnivariateFunction function ) { throw unsupported () ; }
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
final DifferentiableUnivariateFunction f
UnivariateFunction function
UnivariateFunction function
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
final UnivariateFunction dfdx = f . derivative () ;
MultivariateFunction coll = FunctionUtils . collector ( bi , NUMBER_CONSTANT ) ;
final MultivariateFunction evaluationFunction
final MultivariateFunction evaluationFunction
DifferentiableMultivariateFunction func
DifferentiableMultivariateFunction func
final DifferentiableMultivariateFunction f
final MultivariateFunction evaluationFunction
MultivariateFunction func
final MultivariateFunction evaluationFunction
final MultivariateFunction evaluationFunction
MultivariateFunction func
MultivariateFunction func
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; }
evaluations . resetCount () ;
public KeplerStepHandler ( TestProblem3 pb ) { this . pb = pb ; }
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; }
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; maxError = NUMBER_CONSTANT ; }
public KeplerStepHandler ( TestProblem3 pb ) { this . pb = pb ; }
final DifferentiableMultivariateVectorFunction f
DifferentiableMultivariateVectorFunction problem
# optimize ( int , MultivariateVectorFunction , double [] , double [] , double [] )
final MultivariateVectorFunction function
final MultivariateVectorFunction function
final MultivariateVectorFunction function
double dResult [] = transformer . inverseTransform ( dY ) ;
result = transformer . inverseTransform ( f , min , max , N ) ;
if ( forward ) { temp = transform2 ( temp ) ; } else { temp = inverseTransform2 ( temp ) ; }
Object [] o
double [] d
Complex [] f
double [] f
Complex [] f
double [] f
double [] f
double [] f
double [] f
double [] f
int [] x
double [] x
int [] f
double [] f
double [] f
double [] f
double [] f
double [] f
double [] f
new Fraction ( ( ( Math . abs ( w ) * d ) + n ) * MathUtils . copySign ( NUMBER_CONSTANT , w ) , d )
int bits
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
catch ( Exception e ) { Assert . fail ( STRING_CONSTANT ) ; }
catch ( Exception e ) { Assert . fail ( STRING_CONSTANT ) ; }
int x
p = dist . cumulativeProbability ( ( int ) x ) ;
RealDistribution distribution
RealDistribution distribution
FastFourierTransformer transformer = FastFourierTransformer . create () ;
FastFourierTransformer transformer = FastFourierTransformer . create () ;
FastFourierTransformer transformer = FastFourierTransformer . create () ;
FastFourierTransformer transformer = FastFourierTransformer . create () ;
FastCosineTransformer transformer = FastCosineTransformer . create () ;
FastCosineTransformer transformer = FastCosineTransformer . create () ;
final DifferentiableMultivariateVectorOptimizer optimizer
final DifferentiableMultivariateVectorOptimizer optimizer
public HarmonicFitter ( final DifferentiableMultivariateVectorOptimizer optimizer ) { super ( optimizer ) ; }
public GaussianFitter ( DifferentiableMultivariateVectorOptimizer optimizer ) { super ( optimizer ) ; }
DifferentiableMultivariateVectorOptimizer optimizer
{ DifferentiableMultivariateVectorOptimizer optimizer = new GaussNewtonOptimizer ( true ) ; checkUnsolvableProblem ( optimizer , false ) ; }
final BaseMultivariateOptimizer < FUNC > optimizer
MultivariateOptimizer optim
final DifferentiableMultivariateOptimizer optimizer
final MultivariateOptimizer optimizer
@ Override public void setSeed ( int seed ) { ran . setSeed ( seed ) ; clear () ; }
{ if ( rand == null ) { initRan () ; } rand . setSeed ( seed ) ; }
FastSineTransformer transformer = FastSineTransformer . create () ;
FastSineTransformer transformer = FastSineTransformer . create () ;
{ return numberOfTrials * probabilityOfSuccess ; }
Assert . assertEquals ( NUMBER_CONSTANT , dist . inverseCumulativeProbability ( NUMBER_CONSTANT ) ) ;
setInverseCumulativeTestValues ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ;
setInverseCumulativeTestValues ( new int [] { Integer.MAX_VALUE , Integer.MAX_VALUE } ) ;
if ( ! ArithmeticUtils . isPowerOfTwo ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_PLUS_ONE , Integer . valueOf ( f.length ) ) ; }
if ( ! ArithmeticUtils . isPowerOfTwo ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , Integer . valueOf ( n ) ) ; }
if ( ! ArithmeticUtils . isPowerOfTwo ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , Integer . valueOf ( n ) ) ; }
{ if ( ! ArithmeticUtils . isPowerOfTwo ( o.length ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( o.length ) ) ; } }
{ if ( ! ArithmeticUtils . isPowerOfTwo ( d.length ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( d.length ) ) ; } }
{ final double [] data = FunctionUtils . sample ( f , min , max , n ) ; return inverseTransform ( data ) ; }
{ final double [] data = FunctionUtils . sample ( f , min , max , n ) ; return transform ( data ) ; }
final double [] unscaled = fht ( FunctionUtils . sample ( f , min , max , n ) ) ;
{ return fht ( FunctionUtils . sample ( f , min , max , n ) ) ; }
final double [] data = FunctionUtils . sample ( f , min , max , n ) ;
final double [] data = FunctionUtils . sample ( f , min , max , n ) ;
final double [] data = FunctionUtils . sample ( f , min , max , n ) ;
final double [] data = FunctionUtils . sample ( f , min , max , n ) ;
TransformUtils . scaleArray ( x , FastMath . sqrt ( x.length / NUMBER_CONSTANT ) ) ;
return TransformUtils . scaleArray ( fct ( f ) , s1 ) ;
return TransformUtils . scaleArray ( fct ( f ) , s ) ;
return TransformUtils . scaleArray ( unscaled , NUMBER_CONSTANT / n ) ;
{ return TransformUtils . scaleArray ( fht ( f ) , NUMBER_CONSTANT / f.length ) ; }
TransformUtils . scaleArray ( x2 , NUMBER_CONSTANT / FastMath . sqrt ( x2.length ) ) ;
return TransformUtils . scaleArray ( transformed , NUMBER_CONSTANT ) ;
return TransformUtils . scaleArray ( fft ( f ) , s ) ;
return TransformUtils . scaleArray ( fft ( data , true ) , s ) ;
return TransformUtils . scaleArray ( fft ( f , true ) , s ) ;
{ final double s = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ; return TransformUtils . scaleArray ( fft ( f ) , s ) ; }
return TransformUtils . scaleArray ( fft ( data , false ) , s ) ;
return TransformUtils . scaleArray ( fft ( f , false ) , s ) ;
return TransformUtils . scaleArray ( fst ( data ) , s ) ;
return TransformUtils . scaleArray ( fst ( f ) , s ) ;
{ final double s = FastMath . sqrt ( NUMBER_CONSTANT / n ) ; return TransformUtils . scaleArray ( fst ( data ) , s ) ; }
{ final double s = FastMath . sqrt ( NUMBER_CONSTANT / f.length ) ; return TransformUtils . scaleArray ( fst ( f ) , s ) ; }
{ for ( double diag : rDiag ) { if ( FastMath . abs ( diag ) <= threshold ) { return false ; } } return true ; }
public DecompositionSolver getSolver () { return new Solver ( qrt , rDiag , threshold ) ; }
@ Test ( expected = NumberIsTooLargeException . class )
final UnivariateSolver solver
UnivariateSolverUtils . verifyInterval ( lower , upper ) ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = new RiddersSolver () ;
UnivariateSolver solver = new RiddersSolver () ;
UnivariateSolver solver = new RiddersSolver () ;
UnivariateSolver solver = new RiddersSolver () ;
UnivariateSolver solver = new BrentSolver () ;
UnivariateSolver solver = new BrentSolver () ;
UnivariateSolver solver = new MullerSolver () ;
UnivariateSolver solver = new MullerSolver () ;
UnivariateSolver solver = new MullerSolver () ;
UnivariateSolver solver = new MullerSolver () ;
final UnivariateSolver solver
final UnivariateSolver solver = new RegulaFalsiSolver () ;
final UnivariateSolver solver
UnivariateSolver solver
UnivariateSolver solver = new MullerSolver2 () ;
UnivariateSolver solver = new MullerSolver2 () ;
UnivariateSolver solver = new MullerSolver2 () ;
UnivariateSolver solver = new MullerSolver2 () ;
double x = UnivariateSolverUtils . solve ( toSolve , lowerBound , upperBound , getSolverAbsoluteAccuracy () ) ;
final UnivariateSolver lineSearchSolver
final UnivariateSolver lineSearchSolver
{ return super . solve ( maxEval , f , UnivariateSolverUtils . midpoint ( min , max ) ) ; }
final int l
final List < Double > chromosomeRepresentation
final Chromosome another
final List < T > sequence
final Double [] representation
final Population current
final RandomGenerator random
final int populationLimit
final Chromosome chromosome
final List < Chromosome > chromosomes
final int arity
final Chromosome another
final Chromosome another
final Chromosome original
final Population population
if ( elitismRate < NUMBER_CONSTANT || elitismRate > NUMBER_CONSTANT ) { throw new OutOfRangeException ( LocalizedFormats.ELITISM_RATE , elitismRate , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( maxGenerations <= NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( maxGenerations , NUMBER_CONSTANT , true ) ; } this . maxGenerations = maxGenerations ; }
BivariateFunction div = new Divide () ;
BivariateFunction bi = new Add () ;
BivariateFunction bi = new Add () ;
partialDerivatives = new BivariateFunction [ [ [ NUMBER_CONSTANT ] [ lastI ] [ lastJ ] ;
final BivariateFunction f
final BivariateFunction f
final BivariateFunction combiner
final BivariateFunction combiner
final BivariateFunction combiner
final IterativeLinearSolverEvent event = new SymmLQEvent ( this , state ) ;
{ return x . ebeDivide ( diag ) ; }
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
roots . computeOmega ( f.length ) ;
roots . computeOmega ( - f.length ) ;
MultivariateInterpolator interpolator = new MicrosphereInterpolator () ;
MultivariateInterpolator interpolator = new MicrosphereInterpolator () ;
UnivariateInterpolator i = new LinearInterpolator () ;
UnivariateInterpolator i = new LinearInterpolator () ;
UnivariateInterpolator i = new LinearInterpolator () ;
UnivariateInterpolator i = new LinearInterpolator () ;
UnivariateInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
UnivariateInterpolator interpolator = new NevilleInterpolator () ;
UnivariateInterpolator interpolator = new NevilleInterpolator () ;
UnivariateInterpolator interpolator = new NevilleInterpolator () ;
TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator () ;
TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator () ;
TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator () ;
BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateGridInterpolator interpolator = new BicubicSplineInterpolator () ;
BivariateGridInterpolator interpolator = new BicubicSplineInterpolator () ;
BivariateGridInterpolator interpolator = new BicubicSplineInterpolator () ;
roots . computeRoots ( f.length ) ;
roots . computeRoots ( - f.length ) ;
UnivariateIntegrator integrator = new SimpsonIntegrator () ;
UnivariateIntegrator integrator = new SimpsonIntegrator () ;
UnivariateIntegrator integrator = new TrapezoidIntegrator () ;
UnivariateIntegrator integrator = new TrapezoidIntegrator () ;
UnivariateIntegrator integrator = new RombergIntegrator () ;
UnivariateIntegrator integrator = new RombergIntegrator () ;
LegendreGaussIntegrator integrator = new LegendreGaussIntegrator ( n , BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY , BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY , BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT , NUMBER_CONSTANT ) ;
final BaseAbstractUnivariateIntegrator baseIntegrator
{ setSeed ( seed ) ; }
public ISAACRandom ( long seed ) { setSeed ( seed ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw new MathIllegalStateException ( LocalizedFormats.CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS ) ; } }
final double fact2 = n / ( n - NUMBER_CONSTANT ) ;
final double fact2 = n / ( NUMBER_CONSTANT + n ) ;
public void init ( double t0 , double [] y0 , double time ) {}
try { t . transform ( input ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException e ) {}
catch ( MathIllegalArgumentException e ) { e . printStackTrace () ; }
if ( ( nvars + NUMBER_CONSTANT ) * nobs != data.length ) { throw new MathIllegalArgumentException ( LocalizedFormats.INVALID_REGRESSION_ARRAY , data.length , nobs , nvars ) ; }
EmpiricalDistribution dist = new EmpiricalDistribution ( NUMBER_CONSTANT ) ;
{ new EmpiricalDistribution () . load ( ( File ) null ) ; }
{ new EmpiricalDistribution () . load ( ( URL ) null ) ; }
{ new EmpiricalDistribution () . load ( ( double [] ) null ) ; }
EmpiricalDistribution dist = new EmpiricalDistribution () ;
new EmpiricalDistribution () . load ( x ) ;
empiricalDistribution = new EmpiricalDistribution ( binCount , randomData ) ;
{ computeDistribution ( EmpiricalDistribution.DEFAULT_BIN_COUNT ) ; }
dataRI = new double [] [] { MathArrays . copyOf ( f , f.length ) , new double [ f.length ] }
dataRI = new double [] [] { MathArrays . copyOf ( f , f.length ) , new double [ f.length ] }
final Collection < double [] > categoryData
final Collection < double [] > categoryData
final Collection < double [] > categoryData
final boolean exactPValue
double dResult [] = transformer . transform ( dY , TransformType.INVERSE ) ;
double dResult [] = transformer . transform ( dX , TransformType.FORWARD ) ;
public SimplexOptimizer ( ConvergenceChecker < PointValuePair > checker ) { super ( checker ) ; }
protected AbstractScalarDifferentiableOptimizer ( ConvergenceChecker < PointValuePair > checker ) { super ( checker ) ; }
ConvergenceChecker < UnivariatePointValuePair > checker
PointValuePair expected
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < UnivariatePointValuePair > checker
PointValuePair [] points
PointValuePair point
final Comparator < PointValuePair > comparator
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < PointValuePair > checker
protected BaseAbstractMultivariateSimpleBoundsOptimizer ( ConvergenceChecker < PointValuePair > checker ) { super ( checker ) ; }
UnivariatePointValuePair [] optima = optimizer . getOptima () ;
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < PointValuePair > checker
org.apache.commons.math.stat.inference.ChiSquareTest csti = new org.apache.commons.math.stat.inference.ChiSquareTest () ;
ChiSquareTest chiSquareTest = new ChiSquareTest () ;
org.apache.commons.math.stat.inference.ChiSquareTest csti = new org.apache.commons.math.stat.inference.ChiSquareTest () ;
ChiSquareTest chiSquareTest = new ChiSquareTest () ;
ConvergenceChecker < PointVectorValuePair > checker
ConvergenceChecker < PointVectorValuePair > checker
protected AbstractLeastSquaresOptimizer ( ConvergenceChecker < PointVectorValuePair > checker ) { super ( checker ) ; }
ConvergenceChecker < PointVectorValuePair > checker
ConvergenceChecker < PointVectorValuePair > checker
ConvergenceChecker < PointVectorValuePair > checker
PointVectorValuePair optimum
SimplexOptimizer optimizer = new SimplexOptimizer ( new SimplePointChecker < PointValuePair > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ this ( new SimpleValueChecker ( rel , abs ) ) ; }
NonLinearConjugateGradientOptimizer underlying = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver () , preconditioner ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ this ( lambda , inputSigma , boundaries , maxIterations , stopFitness , isActiveCMA , diagonalOnly , checkFeasableCount , random , generateStatistics , new SimpleValueChecker () ) ; }
SimplexOptimizer optimizer = new SimplexOptimizer ( new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
SimplexOptimizer underlying = new SimplexOptimizer ( new SimpleValueChecker ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
DifferentiableMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer ( true , new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
DifferentiableMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer ( true , new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ throw new MathUnsupportedOperationException () ; }
FastSineTransformer transformer = new FastSineTransformer ( DstNormalization.STANDARD_DST_I ) ;
FastSineTransformer transformer = new FastSineTransformer ( DstNormalization.STANDARD_DST_I ) ;
{ throw new NumberIsTooSmallException ( LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION , FastMath . abs ( h ) , minStep , true ) ; }
if ( variablesToInclude == null || variablesToInclude.length == NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.ARRAY_ZERO_LENGTH_OR_NULL_NOT_ALLOWED ) ; }
UnivariateOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
static double [] [] loadLnMant () { return LN_MANT ; }
static double [] loadExpFracB () { return EXP_FRAC_B ; }
static double [] loadExpFracA () { return EXP_FRAC_A ; }
static double [] loadExpIntB () { return EXP_INT_B ; }
static double [] loadExpIntA () { return EXP_INT_A ; }
@ Test ( expected = DimensionMismatchException . class )
@ Test ( expected = DimensionMismatchException . class )
StringBuffer imAppendTo ;
{ if ( this . fitness == NO_FITNESS ) { this . fitness = fitness () ; } return this . fitness ; }
setControlFactors ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
setControlFactors ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
( n * ( n + NUMBER_CONSTANT ) * moment . getResult () - NUMBER_CONSTANT * moment.m2 * moment.m2 * ( n - NUMBER_CONSTANT ) )
{ RealVector b = calculateBeta () ; return yVector . subtract ( xMatrix . operate ( b ) ) ; }
return residuals . dotProduct ( residuals ) / ( xMatrix . getRowDimension () - xMatrix . getColumnDimension () ) ;
RealVector e = yVector . subtract ( xMatrix . operate ( b ) ) ;
this . yVector = new ArrayRealVector ( y ) ;
final RealMatrix x = ols . getX () . copy () ;
double [] hatResiduals = I . subtract ( hat ) . operate ( model . getY () ) . toArray () ;
return t / ( getX () . getRowDimension () - getX () . getColumnDimension () ) ;
int p = getX () . getColumnDimension () ;
{ return qr . getSolver () . solve ( getY () ) ; }
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( getX () ) ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( getX () ) ; }
final int length = b . getDimension () ;
final double epsa = ( s + MACH_PREC ) * CBRT_MACH_PREC ;
@ Override public RealVector getRightHandSideVector () { return RealVector . unmodifiableRealVector ( state . getRightHandSideVector () ) ; }
this . xL . set ( NUMBER_CONSTANT ) ;
this . xL = x ;
solver = new SymmLQ ( maxIterations , NUMBER_CONSTANT , true ) ;
solver = new SymmLQ ( maxIterations , NUMBER_CONSTANT , true ) ;
double [] array
final double [] [] householderMatrix
{ this ( k , v , false ) ; }
{ this ( entry . getKey () , entry . getValue () ) ; }
{ key = k ; value = v ; }
throw new MathInternalError () ;
throw new MathInternalError () ;
if ( x <= NUMBER_CONSTANT ) { ret = NUMBER_CONSTANT ; } else { ret = Gamma . regularizedGammaP ( shape , x / scale ) ; }
{ return shape * scale ; }
v . walkInOptimizedOrder ( visitor , expectedStart , expectedEnd ) ;
{ ret = innerCumulativeProbability ( domain [ NUMBER_CONSTANT ] , x , NUMBER_CONSTANT ) ; }
{ tree . visit ( new BoundaryBuilder < S > () ) ; }
SimplexOptimizer optimizer = new SimplexOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
@ Override public RealVector create ( final double [] data ) { return new TestVectorImpl ( data ) ; }
TestVectorImpl ( double [] values ) { this . values = MathArrays . copyOf ( values ) ; }
catch ( MathArithmeticException e ) {}
T f
T f
final long n1n2prod = ( long ) n1 * n2 ;
{ create ( new double [ NUMBER_CONSTANT ] ) . addToEntry ( - NUMBER_CONSTANT , getPreferredEntryValue () ) ; }
{ create ( new double [ NUMBER_CONSTANT ] ) . setEntry ( - NUMBER_CONSTANT , getPreferredEntryValue () ) ; }
@ Override public RealVector createAlien ( final double [] data ) { return new RealVectorTestImpl ( data ) ; }
final RealVector x = new RealVectorTestImpl ( v . clone () ) ;
@ Override public RealVector createAlien ( double [] data ) { return new RealVectorTestImpl ( data ) ; }
@ Override public RealVector create ( final double [] data ) { return new RealVectorTestImpl ( data ) ; }
RealVectorTestImpl v7_i = new RealVectorTestImpl ( vec1 ) ;
@ Override public RealVector createAlien ( double [] data ) { return new RealVectorTestImpl ( data ) ; }
Assert . assertEquals ( dataU [ i ] + STRING_CONSTANT + dataV [ j ] , expected , actual , NUMBER_CONSTANT ) ;
private ComplexUtils () {}
Object other
final int n = coefficients.length - NUMBER_CONSTANT ;
ed = new EigenDecomposition ( indefinite ) ;
ed = new EigenDecomposition ( distinct ) ;
ed = new EigenDecomposition ( repeated ) ;
ed = new EigenDecomposition ( m ) ;
RealMatrix v = new EigenDecomposition ( matrix ) . getV () ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( symmetric ) ;
ed = new EigenDecomposition ( createTestMatrix ( r , bigValues ) ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
{ return ( int ) FastMath . min ( nextPoisson ( mean ) , Integer.MAX_VALUE ) ; }
{ final double n = random . nextGaussian () ; return FastMath . exp ( scale + shape * n ) ; }
EigenDecomposition eig = new EigenDecomposition ( C ) ;
BaseRuleFactory < ? extends Number > factory
final GaussIntegrator g = FACTORY . legendreHighPrecision ( numberOfPoints , a , b ) ;
{ this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ROW_PREFIX , DEFAULT_ROW_SUFFIX , DEFAULT_ROW_SEPARATOR , DEFAULT_COLUMN_SEPARATOR , format ) ; }
public RealMatrixFormat () { this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ROW_PREFIX , DEFAULT_ROW_SUFFIX , DEFAULT_ROW_SEPARATOR , DEFAULT_COLUMN_SEPARATOR , CompositeFormat . getDefaultNumberFormat () ) ; }
DecompositionSolver es = new EigenDecomposition ( m ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m ) . getSolver () ;
{ final double multiplier = tableau . getEntry ( i , pivotCol ) ; tableau . subtractRow ( i , pivotRow , multiplier ) ; }
if ( entry < minValue ) { minValue = entry ; minPos = i ; }
if ( p < NUMBER_CONSTANT ) { s = - s ; }
catch ( Exception e ) { throw new MathIllegalStateException ( LocalizedFormats.SIMPLE_MESSAGE , e . getMessage () ) ; }
{ if ( ! Precision . equals ( imagEigenvalues [ i ] , NUMBER_CONSTANT , EPSILON ) ) { return true ; } }
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , realMatrixFormat . parse ( source , pos ) ) ;
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , realMatrixFormat . parse ( source , pos ) ) ;
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , realMatrixFormat . parse ( source , pos ) ) ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
final UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
DifferentiableUnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
{ delegate . setSecureAlgorithm ( algorithm , provider ) ; }
{ return delegate . nextZipf ( numberOfElements , exponent ) ; }
{ return delegate . nextWeibull ( shape , scale ) ; }
{ return delegate . nextT ( df ) ; }
{ return delegate . nextPascal ( r , p ) ; }
{ return delegate . nextHypergeometric ( populationSize , numberOfSuccesses , sampleSize ) ; }
{ return delegate . nextF ( numeratorDf , denominatorDf ) ; }
{ return delegate . nextChiSquare ( df ) ; }
{ return delegate . nextCauchy ( median , scale ) ; }
{ return delegate . nextBinomial ( numberOfTrials , probabilityOfSuccess ) ; }
{ return delegate . nextBeta ( alpha , beta ) ; }
{ return delegate . nextUniform ( lower , upper ) ; }
{ delegate = new RandomDataGenerator ( rand ) ; }
double dotProduct = new IterativeLegendreGaussIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . integrate ( NUMBER_CONSTANT , f , a , b ) ;
FastMath . exp ( logGamma ( shape ) )
@ Override public int hashCode () { throw new MathUnsupportedOperationException () ; }
{ throw new MathUnsupportedOperationException () ; }
final double x = randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
fillBinStats ( new StreamDataAdapter ( in ) ) ;
final UnivariateDifferentiableFunction sPrime = new Sqrt () ;
final UnivariateDifferentiableFunction q = new QuinticFunction () ;
final UnivariateDifferentiableFunction f
final UnivariateDifferentiableFunction f
UnivariateDifferentiableFunction f
final UnivariateDifferentiableFunction f = new QuinticFunction () ;
UnivariateDifferentiableFunction f = new Sin () ;
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.INDEX , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.INDEX , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.INDEX , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.INDEX , i ) ; }
public CircleVectorial () { points = new ArrayList < Vector2D > () ; }
MultivariateDifferentiableVectorFunction problem
public CircleScalar () { points = new ArrayList < Vector2D > () ; }
{ gradient = f . gradient () ; return optimizeInternal ( maxEval , f , goalType , startPoint ) ; }
final MultivariateDifferentiableVectorFunction problem ;
{ return multiply ( this , q ) ; }
final Quaternion product = Quaternion . multiply ( inverseQ , q ) ;
final double normSquareRef = Quaternion . multiply ( q , q . getConjugate () ) . getScalarPart () ;
optimum = new PointValuePair ( fitfun . repairAndDecode ( bestArx . getColumn ( NUMBER_CONSTANT ) ) , isMinimize ? bestFitness : - bestFitness ) ;
final double tmp = wxi * xi / di ;
Iterator < Entry > it = v . iterator () ;
Iterator < Entry > it = v . iterator () ;
Iterator < Entry > it = iterator () ;
Iterator < Entry > it = iterator () ;
Iterator < Entry > it = iterator () ;
Iterator < Entry > it = iterator () ;
Iterator < Entry > it = iterator () ;
{ return super . optimizeInternal ( maxEval , f , goalType , new InitialGuess ( startPoint ) ) ; }
public double [] getUpperBound () { return super . getUpperBound () ; }
public double [] getLowerBound () { return super . getLowerBound () ; }
public double [] getStartPoint () { return start == null ? null : start . clone () ; }
Math . max ( NUMBER_CONSTANT , NUMBER_CONSTANT - dimension / ( NUMBER_CONSTANT + maxIterations ) )
final double [] [] out = new double [ [ sampleSize ] [ dimension ] ;
{ random = rng ; dimension = n ; }
final int dim = getDimension () ;
final int dim = getDimension () ;
final int dim = getDimension () ;
final int dim = d . getDimension () ;
final int dim = d . getDimension () ;
double [] insigma = point ( DIM + NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double [] insigma = point ( DIM , NUMBER_CONSTANT ) ;
double [] insigma = point ( DIM , NUMBER_CONSTANT ) ;
double [] insigma = point ( DIM , NUMBER_CONSTANT ) ;
final double . . . f
jF = f ;
{ distribution . get ( i ) . reseedRandomGenerator ( i + NUMBER_CONSTANT + seed ) ; }
FUNC f
FUNC f
final RealMatrix d = MatrixUtils . createRealDiagonalMatrix ( eigenValues ) ;
RealMatrix m = MatrixUtils . createRealDiagonalMatrix ( diagonal ) ;
{ x = list . remove ( list . size () - NUMBER_CONSTANT ) . getInf () ; }
final double [] sigma = optim . computeSigma ( regress , NUMBER_CONSTANT ) ;
final double [] currentPoint = getStartPoint () ;
final double [] [] covMatrix = optimizer . computeCovariances ( paramFound , NUMBER_CONSTANT ) ;
final double [] [] covarMatrix = optimizer . computeCovariances ( solution , NUMBER_CONSTANT ) ;
final RealMatrix j = computeWeightedJacobian ( params ) ;
qrDecomposition ( computeWeightedJacobian ( currentPoint ) ) ;
final RealMatrix weightedJacobian = computeWeightedJacobian ( currentPoint ) ;
try { testStatistic . gTest ( expected , observed , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( OutOfRangeException ex ) {}
try { testStatistic . gTest ( expected , observed ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NotStrictlyPositiveException ex ) {}
final double residual = currentResiduals [ i ] ;
{ super . testAdd1000 () ; Assert . assertEquals ( STRING_CONSTANT + STRING_CONSTANT , NUMBER_CONSTANT , ( ( ResizableDoubleArray ) da ) . getCapacity () ) ; }
final ResizableDoubleArray other = ( ResizableDoubleArray ) object ;
{ final ResizableDoubleArray result = new ResizableDoubleArray () ; copy ( this , result ) ; return result ; }
hashData [ NUMBER_CONSTANT ] = expansionMode . hashCode () ;
expansionMode == ExpansionMode.MULTIPLICATIVE
expansionMode == ExpansionMode.MULTIPLICATIVE
{ if ( initialDoubleArray != null ) { eDA = new StatArray ( initialDoubleArray ) ; } }
{ if ( initialDoubleArray != null ) { eDA = new ResizableDoubleArray ( initialDoubleArray ) ; } }
{ this ( DEFAULT_INITIAL_CAPACITY , DEFAULT_EXPANSION_FACTOR , DEFAULT_CONTRACTION_DELTA + DEFAULT_EXPANSION_FACTOR , ExpansionMode.MULTIPLICATIVE , initialArray ) ; }
hashData [ NUMBER_CONSTANT ] = new Float ( contractionCriterion ) . hashCode () ;
result = result && ( other.contractionCriterion == contractionCriterion ) ;
dest.contractionCriterion = source.contractionCriterion ;
{ checkContractExpand ( getContractionCriterion () , expansionFactor ) ; synchronized ( this ) { this . expansionFactor = expansionFactor ; } }
{ checkContractExpand ( contractionCriteria , getExpansionFactor () ) ; synchronized ( this ) { this . contractionCriterion = contractionCriteria ; } }
public double getContractionCriterion () { return contractionCriterion ; }
{ super ( relativeThreshold , absoluteThreshold ) ; maxIterationCount = ITERATION_CHECK_DISABLED ; }
@ Deprecated public SimpleVectorValueChecker () { maxIterationCount = ITERATION_CHECK_DISABLED ; }
{ super ( relativeThreshold , absoluteThreshold ) ; maxIterationCount = ITERATION_CHECK_DISABLED ; }
@ Deprecated public SimpleValueChecker () { maxIterationCount = ITERATION_CHECK_DISABLED ; }
{ super ( relativeThreshold , absoluteThreshold ) ; maxIterationCount = ITERATION_CHECK_DISABLED ; }
@ Deprecated public SimplePointChecker () { maxIterationCount = ITERATION_CHECK_DISABLED ; }
NaturalRanking ranking = new NaturalRanking ( NaNStrategy.MAXIMAL , TiesStrategy.MINIMUM ) ;
{ super ( relativeThreshold , absoluteThreshold ) ; maxIterationCount = ITERATION_CHECK_DISABLED ; }
@ Deprecated public SimpleUnivariateValueChecker () { maxIterationCount = ITERATION_CHECK_DISABLED ; }
logBeta ( a , b )
RandomDataGenerator randomData
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataGenerator () ) ; }
RandomDataGenerator randomData
this . q0 = scalar ;
if ( diagonalOnly <= NUMBER_CONSTANT ) { updateCovariance ( hsig , bestArx , arz , arindex , xold ) ; } else { updateCovarianceDiagonalOnly ( hsig , bestArz ) ; }
if ( diagonalOnly <= NUMBER_CONSTANT ) { updateCovariance ( hsig , bestArx , arz , arindex , xold ) ; } else { updateCovarianceDiagonalOnly ( hsig , bestArz ) ; }
final CodyWaite cw = new CodyWaite ( xa ) ;
final CodyWaite cw = new CodyWaite ( xa ) ;
final CodyWaite cw = new CodyWaite ( xa ) ;
@ Override public void reseedRandomGenerator ( long seed ) { reSeed ( seed ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , ( RandomGenerator ) null ) ; }
@ Override public void reseedRandomGenerator ( long seed ) { randomData . reSeed ( seed ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataImpl () ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataGenerator () ) ; }
filePointer = new BufferedReader ( new InputStreamReader ( valuesFileURL . openStream () , STRING_CONSTANT ) ) ;
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( problem . weight () )
new NonCorrelatedWeight ( circle . weight () )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( function . getWeight () )
new Weight ( w )
new Weight ( weights )
new Weight ( weights )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( weights )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( w )
new Weight ( problem . weight () )
new Weight ( circle . weight () )
new Weight ( weights )
new Weight ( w )
new Weight ( w )
new Weight ( w )
new Weight ( function . getWeight () )
{ this ( d , true ) ; }
public SimplexSolver ( final double epsilon ) { this ( epsilon , DEFAULT_ULPS , DEFAULT_CUT_OFF ) ; }
if ( FastMath . abs ( result ) < cutOff ) { result = NUMBER_CONSTANT ; }
{ this ( f , constraints , goalType , restrictToNonNegative , epsilon , SimplexSolver.DEFAULT_ULPS , SimplexSolver.DEFAULT_CUT_OFF ) ; }
final T [] out = MathArrays . buildArray ( field , data.length + NUMBER_CONSTANT ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
data = MathArrays . buildArray ( field , v1.length + v2.length ) ;
data = MathArrays . buildArray ( field , v1.length + v2.data.length ) ;
data = MathArrays . buildArray ( field , v1.data.length + v2.length ) ;
data = MathArrays . buildArray ( field , v1.data.length + v2.data.length ) ;
data = MathArrays . buildArray ( field , v . getDimension () ) ;
data = MathArrays . buildArray ( field , size ) ;
data = MathArrays . buildArray ( field , size ) ;
final T [] [] out = MathArrays . buildArray ( getField () , nRows , getColumnDimension () ) ;
final T [] out = MathArrays . buildArray ( getField () , nCols ) ;
final T [] out = MathArrays . buildArray ( getField () , nRows ) ;
data = MathArrays . buildArray ( getField () , subMatrix.length , nCols ) ;
final T [] [] outData = MathArrays . buildArray ( getField () , nRows , nCols ) ;
final T [] [] outData = MathArrays . buildArray ( getField () , rowCount , columnCount ) ;
final T [] [] outData = MathArrays . buildArray ( getField () , rowCount , columnCount ) ;
data = MathArrays . buildArray ( getField () , nRows , NUMBER_CONSTANT ) ;
{ super ( field , rowDimension , columnDimension ) ; data = MathArrays . buildArray ( field , rowDimension , columnDimension ) ; }
final T [] out = MathArrays . buildArray ( getField () , columns ) ;
final T [] out = MathArrays . buildArray ( getField () , rows ) ;
final T [] out = MathArrays . buildArray ( getField () , rows ) ;
final T [] out = MathArrays . buildArray ( getField () , columns ) ;
final T [] outData = MathArrays . buildArray ( getField () , rows ) ;
final T [] outData = MathArrays . buildArray ( getField () , columns ) ;
final T [] [] data = MathArrays . buildArray ( getField () , getRowDimension () , getColumnDimension () ) ;
{ blocks = MathArrays . buildArray ( getField () , blockRows * blockColumns , - NUMBER_CONSTANT ) ; }
final T [] out = MathArrays . buildArray ( field , nCols ) ;
final T [] out = MathArrays . buildArray ( field , nCols ) ;
final T [] out = MathArrays . buildArray ( field , nRows ) ;
final T [] out = MathArrays . buildArray ( field , nRows ) ;
final T [] out = MathArrays . buildArray ( field , nRows ) ;
final T [] out = MathArrays . buildArray ( field , nCols ) ;
final T [] [] data = MathArrays . buildArray ( field , getRowDimension () , getColumnDimension () ) ;
T [] res = MathArrays . buildArray ( field , virtualSize ) ;
int exponent = ( int ) ( y . intLog10 () * NUMBER_CONSTANT ) ;
{ return new Decimal64 ( FastMath . IEEEremainder ( value , a.value ) ) ; }
{ return new Decimal64 ( FastMath . IEEEremainder ( value , a ) ) ; }
return ePlus . subtract ( eMinus ) . divide ( ePlus . add ( eMinus ) ) ;
DerivativeStructure ref = dsX . subtract ( x - FastMath . IEEEremainder ( x , y ) ) ;
DerivativeStructure sAccurate = FieldVector3D . dotProduct ( u1 , u2 ) ;
Assert . assertEquals ( - NUMBER_CONSTANT , FieldVector3D . dotProduct ( r . getAxis () , reverted . getAxis () ) . getReal () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( - NUMBER_CONSTANT , FieldVector3D . dotProduct ( r . getAxis () , reverted . getAxis () ) . getReal () , NUMBER_CONSTANT ) ;
randomData = new RandomDataGenerator ( randomGenerator ) ;
{ super(); this . tiesStrategy = TiesStrategy.RANDOM ; nanStrategy = DEFAULT_NAN_STRATEGY ; randomData = new RandomDataGenerator ( randomGenerator ) ; }
{ super(); this . nanStrategy = nanStrategy ; this . tiesStrategy = tiesStrategy ; randomData = new RandomDataGenerator () ; }
{ super(); this . tiesStrategy = tiesStrategy ; nanStrategy = DEFAULT_NAN_STRATEGY ; randomData = new RandomDataGenerator () ; }
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
@ Test ( expected = NumberIsTooLargeException . class )
{ return getKernel ( stats ) . sample () ; }
{ getRandomGenerator () . setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ getRandomGenerator () . setSeed ( seed ) ; }
final RandomGenerator generator = getRandomGenerator () ;
{ return new FDistribution ( getRandomGenerator () , numeratorDf , denominatorDf , FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ChiSquaredDistribution ( getRandomGenerator () , df , ChiSquaredDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new CauchyDistribution ( getRandomGenerator () , median , scale , CauchyDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new BinomialDistribution ( getRandomGenerator () , numberOfTrials , probabilityOfSuccess ) . sample () ; }
{ return new BetaDistribution ( getRandomGenerator () , alpha , beta , BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ZipfDistribution ( getRandomGenerator () , numberOfElements , exponent ) . sample () ; }
{ return new WeibullDistribution ( getRandomGenerator () , shape , scale , WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new TDistribution ( getRandomGenerator () , df , TDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new PascalDistribution ( getRandomGenerator () , r , p ) . sample () ; }
{ return new HypergeometricDistribution ( getRandomGenerator () , populationSize , numberOfSuccesses , sampleSize ) . sample () ; }
{ return new GammaDistribution ( getRandomGenerator () , shape , scale , GammaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ExponentialDistribution ( getRandomGenerator () , mean , ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
return sigma * getRandomGenerator () . nextGaussian () + mu ;
{ return new PoissonDistribution ( getRandomGenerator () , mean , PoissonDistribution.DEFAULT_EPSILON , PoissonDistribution.DEFAULT_MAX_ITERATIONS ) . sample () ; }
RandomGenerator ran = getRandomGenerator () ;
@ Test public void testReciprocalZero () { Assert . assertEquals ( Complex.ZERO . reciprocal () , Complex.INF ) ; }
{ return ( ( Float . floatToRawIntBits ( f ) > > > NUMBER_CONSTANT ) & NUMBER_CONSTANT ) - NUMBER_CONSTANT ; }
final long bits = Double . doubleToRawLongBits ( d ) ;
final long bits = Double . doubleToRawLongBits ( d ) ;
return abs ( x - Double . longBitsToDouble ( Double . doubleToRawLongBits ( x ) ^ NUMBER_CONSTANT ) ) ;
{ long bits = Double . doubleToRawLongBits ( x ) ; if ( bits < NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
{ long bits = Double . doubleToRawLongBits ( x ) ; if ( bits < NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
long inbits = Double . doubleToRawLongBits ( x ) ;
long bits = Double . doubleToRawLongBits ( x ) ;
long bits = Double . doubleToRawLongBits ( x ) ;
long xl = Double . doubleToRawLongBits ( d ) ;
File file = new File ( url . toURI () ) ;
{ return Double . longBitsToDouble ( MASK_NON_SIGN_LONG & Double . doubleToRawLongBits ( x ) ) ; }
{ return Float . intBitsToFloat ( MASK_NON_SIGN_INT & Float . floatToRawIntBits ( x ) ) ; }
final double [] [] matrix
{ this ( new Well19937c () , lower , upper ) ; }
{ fit ( initialMixture , DEFAULT_MAX_ITERATIONS , DEFAULT_THRESHOLD ) ; }
sum += FastMath . pow ( distA / distB , NUMBER_CONSTANT / ( fuzziness - NUMBER_CONSTANT ) ) ;
final double u = FastMath . pow ( membershipMatrix [ i ] [ j ] , fuzziness ) ;
final long grayCode = i ^ ( i > > NUMBER_CONSTANT ) ;
int count = samples / centers ;
{ this . a [ i ] [ j ] = a [ i * N + j ] ; }
Assert . assertArrayEquals ( expected , actual , NUMBER_CONSTANT ) ;
{ double tEnd = test ( NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , tEnd , NUMBER_CONSTANT ) ; }
{ double tEnd = test ( NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , tEnd , NUMBER_CONSTANT ) ; }
{ final double midPoint = min + NUMBER_CONSTANT * diff ; return diff * computeObjectiveValue ( midPoint ) ; }
{ new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
incrementValue ( entry . getKey () , entry . getValue () . longValue () ) ;
Assert . assertFalse ( random . nextBoolean () ) ;
{ result [ i ] = r . call () . doubleValue () ; }
final int uniDimIndex = iter . next () . intValue () ;
{ super ( specific , INTEGER_ZERO , arguments ) ; }
{ super ( specific , value , INTEGER_ZERO , false ) ; }
public NotStrictlyPositiveException ( Number value ) { super ( value , INTEGER_ZERO , false ) ; }
{ super ( specific , Integer . valueOf ( wrong ) , Integer . valueOf ( expected ) ) ; dimension = expected ; }
{ return expected [ index ] . intValue () ; }
{ return wrong [ index ] . intValue () ; }
{ super ( specific , value , INTEGER_ZERO , true ) ; }
public NotPositiveException ( Number value ) { super ( value , INTEGER_ZERO , true ) ; }
{ secRand = RandomGeneratorFactory . createRandomGenerator ( SecureRandom . getInstance ( algorithm , provider ) ) ; }
final RandomGenerator secRan = getSecRan () ;
T withConvergenceChecker ( ConvergenceChecker < PAIR > checker ) ;
double binomial = CombinatoricsUtils . binomialCoefficient ( v + i , i ) ;
long expected = CombinatoricsUtils . binomialCoefficient ( i + j , i ) ;
double inv = NUMBER_CONSTANT / CombinatoricsUtils . factorial ( i ) ;
double refDer = - CombinatoricsUtils . factorial ( n - NUMBER_CONSTANT ) / FastMath . pow ( - x , n ) ;
ArithmeticUtils . pow ( - NUMBER_CONSTANT , i ) * CombinatoricsUtils . factorial ( i ) / FastMath . pow ( x , i + NUMBER_CONSTANT )
{ coeff [ i ] [ j ] = ( int ) CombinatoricsUtils . binomialCoefficient ( i , j ) ; }
RandomDataGenerator randomData = new RandomDataGenerator () ;
{ term *= FastMath . pow ( delta [ k ] , orders [ k ] ) / CombinatoricsUtils . factorial ( orders [ k ] ) ; }
AbstractOptimizer < PAIR , OPTIM > other
{ return Double . parseDouble ( o . toString () ) ; }
{ val = Double . parseDouble ( str ) ; sampleStats . addValue ( val ) ; }
return Double . parseDouble ( str ) ;
final List < Segment > segments = new ArrayList < Segment > ( list . size () ) ;
final List < Segment > segments = new ArrayList < Segment > ( list . size () ) ;
List < Edge > edges = new ArrayList < Edge > ( n ) ;
final List < EventHandler > list = new ArrayList < EventHandler > ( eventsStates . size () ) ;
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > ( originalConstraints . size () ) ;
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > ( originalConstraints . size () ) ;
List < int [] > row = new ArrayList < int [] > ( dRow.length * NUMBER_CONSTANT ) ;
final double [] vectorData ;
{ this ( value , DEFAULT_EPSILON , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , f . getCount ( THREE ) ) ;
f . addValue ( THREE ) ;
{ return new Combinations ( n , k ) . iterator () ; }
int [] index = MathArrays . natural ( n ) ;
{ final int [] natural = MathArrays . natural ( NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , natural.length ) ; }
AbstractLeastSquaresOptimizer < OPTIM > other
if ( FastMath . abs ( a0 ) > overflow ) { throw new FractionConversionException ( value , a0 , NUMBER_CONSTANT ) ; }
mult . multiplyInPlace ( var1 ) ;
{ return NUMBER_CONSTANT + NUMBER_CONSTANT * MathUtils . hash ( value ) + NUMBER_CONSTANT * derivatives . hashCode () ; }
{ return MathArrays . verifyValues ( values , weights , begin , length , allowEmpty ) ; }
{ return MathArrays . verifyValues ( values , weights , begin , length , false ) ; }
{ return MathArrays . verifyValues ( values , begin , length , allowEmpty ) ; }
{ return MathArrays . verifyValues ( values , begin , length , false ) ; }
den += NUMBER_CONSTANT ;
den += NUMBER_CONSTANT ;
trial *= NUMBER_CONSTANT ;
xx += NUMBER_CONSTANT / NUMBER_CONSTANT ;
for ( final T a : data ) { h ^= a . hashCode () ; }
if ( result == NUMBER_CONSTANT ) { result *= x ; }
za *= ya ;
e > > = NUMBER_CONSTANT ;
z *= lnb ;
xl &= MASK_30BITS ;
if ( i > NUMBER_CONSTANT ) { randInt > > = NUMBER_CONSTANT ; }
coeff1 /= pc2 ;
r *= rnd ;
e > > = NUMBER_CONSTANT ;
e > > = NUMBER_CONSTANT ;
e > > = NUMBER_CONSTANT ;
coeff1 /= pc2 ;
k += m ;
{ m > > = NUMBER_CONSTANT ; ++ k ; }
{ data [ i ] /= d ; }
{ data [ i ] *= d ; }
{ data [ i ] -= d ; }
{ data [ i ] += d ; }
rhs [ m ] /= X ;
{ while ( NUMBER_CONSTANT == n % p ) { n /= p ; factors . add ( p ) ; } }
{ c [ NUMBER_CONSTANT ] ++ ; return ret ; }
n |= NUMBER_CONSTANT ;
bits &= NUMBER_CONSTANT ;
v *= v ;
w -= NUMBER_CONSTANT ;
{ bytes [ i ++ ] = ( byte ) ( random & NUMBER_CONSTANT ) ; random > > = NUMBER_CONSTANT ; }
num %= den ;
extra -= rh * RADIX ;
coeff1 /= pc2 ;
iter ++ ;
{ ret = scale * FastMath . pow ( - FastMath . log1p ( - p ) , NUMBER_CONSTANT / shape ) ; }
( a * FastMath . log ( x ) ) + ( b * FastMath . log1p ( - x ) )
return ( FastMath . expm1 ( ss ) ) * FastMath . exp ( NUMBER_CONSTANT * scale + ss ) ;
{ correct ( new ArrayRealVector ( z , false ) ) ; }
{ predict ( new ArrayRealVector ( u , false ) ) ; }
minadj /= divisor.mant [ mant.length - NUMBER_CONSTANT ] + NUMBER_CONSTANT ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= FastMath . sqrt ( sp ) ;
{ double f = FastMath . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= FastMath . sqrt ( sp ) ;
{ double f = FastMath . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
final double max = FastMath.PI ;
{ FunctionUtils . sample ( new Sin () , NUMBER_CONSTANT , FastMath.PI , NUMBER_CONSTANT ) ; }
{ FunctionUtils . sample ( new Sin () , NUMBER_CONSTANT , FastMath.PI , - NUMBER_CONSTANT ) ; }
{ FunctionUtils . sample ( new Sin () , FastMath.PI , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
double x = FastMath . random () * NUMBER_CONSTANT ;
double x = FastMath . random () ;
- NUMBER_CONSTANT / ( a * a ) - NUMBER_CONSTANT + FastMath . cos ( a )
minDiff = FastMath . min ( minDiff , boundDifference [ i ] ) ;
minDiff = FastMath . min ( minDiff , boundDifference [ i ] ) ;
{ d [ r ] [ c ] = FastMath . sqrt ( m . getEntry ( r , c ) ) ; }
{ d [ r ] [ c ] = FastMath . log ( m . getEntry ( r , c ) ) ; }
double diff = FastMath . abs ( x [ i ] - repaired [ i ] ) ;
( NUMBER_CONSTANT - ccovmu ) * NUMBER_CONSTANT * mueff / ( FastMath . pow ( dimension + NUMBER_CONSTANT , NUMBER_CONSTANT ) + NUMBER_CONSTANT * mueff )
{ d [ r ] [ c ] = FastMath . sqrt ( m . getEntry ( r , c ) ) ; }
{ d [ r ] [ c ] = FastMath . log ( m . getEntry ( r , c ) ) ; }
double diff = FastMath . abs ( x [ i ] - repaired [ i ] ) ;
( NUMBER_CONSTANT - ccovmu ) * NUMBER_CONSTANT * mueff / ( FastMath . pow ( dimension + NUMBER_CONSTANT , NUMBER_CONSTANT ) + NUMBER_CONSTANT * mueff )
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= FastMath . sqrt ( sp ) ;
{ double f = FastMath . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , FastMath . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , FastMath . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , FastMath . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
double diff = FastMath . abs ( constantValue - filter . getStateEstimation () [ NUMBER_CONSTANT ] ) ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= FastMath . sqrt ( sp ) ;
{ double f = FastMath . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
a1 = FastMath . sqrt ( FastMath.PI * twolpd ) * FastMath . exp ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * lambda ) )
ret += c [ i ] * ArithmeticUtils . pow ( n , i ) ;
public double estimateRegressionStandardError () { return FastMath . sqrt ( estimateErrorVariance () ) ; }
for ( int i = NUMBER_CONSTANT ; i < length ; i ++ ) { sample [ i ] = FastMath . random () ; }
int k = ( int ) FastMath . ceil ( n * d ) ;
final int k = ( int ) FastMath . ceil ( n * d ) ;
final int k = ( int ) FastMath . ceil ( n * d ) ;
{ return NUMBER_CONSTANT - NUMBER_CONSTANT * FastMath . pow ( NUMBER_CONSTANT - d , n ) ; }
final double originalDelta = FastMath . random () ;
h += p_i * FastMath . log ( p_i ) ;
h += p_ij * FastMath . log ( p_ij ) ;
if ( FastMath . abs ( sumExpected - sumObserved ) > NUMBER_CONSTANT ) { ratio = sumObserved / sumExpected ; rescale = true ; }
System . arraycopy ( seed , NUMBER_CONSTANT , v , NUMBER_CONSTANT , FastMath . min ( seed.length , v.length ) ) ;
double denom = FastMath . abs ( val ) < EPS_MIN ? NUMBER_CONSTANT * EPS_MIN : NUMBER_CONSTANT * val ;
double err = FastMath . abs ( actual - expected ) / Math . ulp ( expected ) ;
final int shift = FastMath . min ( aTwos , bTwos ) ;
{ public double value ( double x ) { return NUMBER_CONSTANT / ( NUMBER_CONSTANT * FastMath . sqrt ( x ) ) ; } }
f = new UnivariateFunction () { public double value ( double x ) { return FastMath . sqrt ( x ) ; } }
Assert . assertTrue ( STRING_CONSTANT , FastMath . abs ( v - randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) > NUMBER_CONSTANT ) ;
int shift = FastMath . max ( numerator . bitLength () , denominator . bitLength () ) - FastMath . getExponent ( Float.MAX_VALUE ) ;
int shift = FastMath . max ( numerator . bitLength () , denominator . bitLength () ) - FastMath . getExponent ( Double.MAX_VALUE ) ;
FastMath . sqrt ( d [ col ] ) < tol [ col ]
FastMath . sqrt ( d [ i ] ) < tol [ i ]
double denom = FastMath . abs ( val ) < EPS_MIN ? NUMBER_CONSTANT * EPS_MIN : NUMBER_CONSTANT * val ;
{ return FastMath . exp ( x ) - FastMath . pow ( Math.PI , NUMBER_CONSTANT ) ; }
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double gn = factor1 * FastMath . log ( qExp1 ) * oneOverN ;
System . arraycopy ( seed , NUMBER_CONSTANT , rsl , NUMBER_CONSTANT , FastMath . min ( seedLen , rslLen ) ) ;
expected = FastMath . abs ( period ) - delta ;
double xabs = FastMath . abs ( v [ i ] ) ;
final double result = NUMBER_CONSTANT * Erf . erfc ( ref [ i ] [ NUMBER_CONSTANT ] / FastMath . sqrt ( NUMBER_CONSTANT ) ) ;
new Fraction ( ( ( FastMath . abs ( w ) * d ) + n ) * MathUtils . copySign ( NUMBER_CONSTANT , w ) , d )
num = FastMath . abs ( num ) ;
{ minValue = entry ; minPos = i ; if ( pivotSelection == PivotSelectionRule.BLAND && isValidPivotColumn ( tableau , i ) ) { break; } }
this . pivotSelection = PivotSelectionRule.DANTZIG ;
solution = new SimplexSolver () . optimize ( DEFAULT_MAX_ITER , f , new LinearConstraintSet ( constraints ) , GoalType.MINIMIZE , new NonNegativeConstraint ( true ) , PivotSelectionRule.BLAND )
{ this ( f , constraints , goalType , restrictToNonNegative , epsilon , SimplexSolver.DEFAULT_ULPS ) ; }
if ( Precision . compareTo ( entry , NUMBER_CONSTANT , cutOff ) > NUMBER_CONSTANT ) { return true ; }
final Point < Euclidean3D > point
final Point < Euclidean3D > point
final Point < S > barycenter
final Point < S > point
final Point < S > point
final Point < Euclidean1D > point
final Point < Euclidean2D > point
final Point < Euclidean1D > point
final Point < Euclidean3D > point
Point < S > point
final Point < S > point
{ final Vector2D v2 = ( Vector2D ) v ; return MathArrays . linearCombination ( x , v2.x , y , v2.y ) ; }
final Point < Euclidean2D > point
final Point < Euclidean2D > point
final Point < Euclidean1D > point
final Point < Euclidean2D > point
final Point < S > point
{ return Vector3D . angle ( pole , direction ) - NUMBER_CONSTANT * FastMath.PI ; }
public SphericalPolygonsSet wholeSpace () { return new SphericalPolygonsSet ( tolerance ) ; }
public SubCircle wholeHyperplane () { return new SubCircle ( this , new ArcsSet ( tolerance ) ) ; }
{ this ( circle.pole , circle.x , circle.y , circle.tolerance ) ; }
public ArcsSet wholeSpace () { return new ArcsSet ( tolerance ) ; }
{ return new ArcsSet ( tree , tolerance ) ; }
final double offset = plane . getOffset ( ( Point < Euclidean3D > ) point ) ;
final Vector1D x = thisLine . toSubSpace ( ( Point < Euclidean2D > ) crossing ) ;
final Vector1D x = thisLine . toSubSpace ( ( Point < Euclidean2D > ) crossing ) ;
final Vector3D point = line . toSpace ( ( Point < Euclidean1D > ) Vector1D.ZERO ) ;
Point < Euclidean1D > p
Point < Euclidean2D > p
Point < Euclidean3D > v
public SubChord copySelf () { return new SubChord ( chord . copySelf () , limits ) ; }
{ this . upper = MathUtils.TWO_PI + lower ; }
Arc arc = new Arc ( NUMBER_CONSTANT , FastMath . nextAfter ( NUMBER_CONSTANT , Double.POSITIVE_INFINITY ) , Precision.EPSILON ) ;
{ return buildNew ( hyperplane . copySelf () , remainingRegion ) ; }
{ return new PolyhedronsSet ( tree , getTolerance () ) ; }
final BSPTree < S > cell = node . getCell ( point , tolerance ) ;
public IntervalsSet wholeSpace () { return new IntervalsSet ( tolerance ) ; }
return getRemainingRegion () . side ( new OrientedPoint ( x , direct , thisLine . getTolerance () ) ) ;
public PolyhedronsSet wholeSpace () { return new PolyhedronsSet ( tolerance ) ; }
public SubPlane wholeHyperplane () { return new SubPlane ( this , new PolygonsSet ( tolerance ) ) ; }
final Plane plane = new Plane ( origin . add ( translation ) , w , tolerance ) ;
{ return new PolygonsSet ( tree , getTolerance () ) ; }
if ( line == null ) { line = new Line ( start . getLocation () , end . getLocation () , hyperplaneThickness ) ; }
final BoundaryProjector projector = new BoundaryProjector ( polyhedronsSet . getTolerance () ) ;
public SubLine wholeLine () { return new SubLine ( this , new IntervalsSet ( tolerance ) ) ; }
{ return distance ( p ) < tolerance ; }
Segment segment = new Segment ( start , end , new Line ( start , end , NUMBER_CONSTANT ) ) ;
Segment segment = new Segment ( p1 , p2 , new Line ( p1 , p2 , NUMBER_CONSTANT ) ) ;
{ return new Line ( start , end , NUMBER_CONSTANT ) . wholeHyperplane () ; }
return new PolygonsSet ( edges , NUMBER_CONSTANT ) ;
return new OrientedPoint ( newLoc , op . isDirect () , originalLine.tolerance ) . wholeHyperplane () ;
{ return FastMath . abs ( getOffset ( p ) ) < tolerance ; }
public PolygonsSet wholeSpace () { return new PolygonsSet ( tolerance ) ; }
public SubLine wholeHyperplane () { return new SubLine ( this , new IntervalsSet ( tolerance ) ) ; }
if ( FastMath . abs ( d ) < tolerance ) { return null ; }
{ return new ArcsSet ( tree , getTolerance () ) ; }
{ return new LimitAngle ( new S1Point ( alpha ) , true , getTolerance () ) . wholeHyperplane () ; }
{ return new LimitAngle ( new S1Point ( alpha ) , false , getTolerance () ) . wholeHyperplane () ; }
{ super ( boundary , tolerance ) ; }
{ super ( tree , tolerance ) ; }
public ArcsSet ( final double tolerance ) { super ( tolerance ) ; }
final EdgesBuilder visitor = new EdgesBuilder ( root , getTolerance () ) ;
{ return new SphericalPolygonsSet ( tree , getTolerance () ) ; }
{ super ( boundary , tolerance ) ; }
{ super ( tree , tolerance ) ; }
public SphericalPolygonsSet ( final double tolerance ) { super ( tolerance ) ; }
{ add ( new NestedLoops ( bLoop , tolerance ) ) ; }
{ return new IntervalsSet ( tree , getTolerance () ) ; }
PolyhedronsSet tree = new PolyhedronsSet ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
boundary . add ( new LimitAngle ( new S1Point ( MathUtils.TWO_PI - NUMBER_CONSTANT ) , true , NUMBER_CONSTANT ) . wholeHyperplane () ) ;
( Boolean ) getFirstLeaf ( getTree ( false ) ) . getAttribute ()
Assert . assertTrue ( projection . getOriginal () == v ) ;
Iterable < P > points
final Iterable < P > points
ConvexHull2D hull = generator . generate ( reducePoints ( points ) ) ;
GrahamScan generator = new GrahamScan () ;
RandomGenerator random = new MersenneTwister () ;
@ Before public void setUp () { generator = createConvexHullGenerator ( false ) ; random = new MersenneTwister ( NUMBER_CONSTANT ) ; }
final Iterable < Vector2D > points
Assert . assertTrue ( hull . getVertices () . length == NUMBER_CONSTANT ) ;
ConvexHullGenerator2D generator = new MonotoneChain ( true ) ;
public Segment [] getLineSegments () { return retrieveLineSegments () . clone () ; }
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.PLUS_I ) . ballOnSupport ( support ) ;
cap = new SphericalCapGenerator ( new Vector3D ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ) . ballOnSupport ( support )
cap = new SphericalCapGenerator ( new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . ballOnSupport ( support )
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.PLUS_K ) . ballOnSupport ( support ) ;
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.PLUS_K ) . ballOnSupport ( support ) ;
{ return new EnclosingBall < Sphere2D , S2Point > ( new S2Point ( inside ) , - NUMBER_CONSTANT ) ; }
@ Override protected ConvexHullGenerator2D createConvexHullGenerator ( boolean includeCollinearPoints ) { return new MonotoneChain ( includeCollinearPoints ) ; }
{ return getOptimizer () . optimize ( getProblem ( points ) ) . getPoint () ; }
final boolean useLU
optimizer = new LevenbergMarquardtOptimizer () . withInitialStepBoundFactor ( initialStepBoundFactor ) . withCostRelativeTolerance ( costRelativeTolerance ) . withParameterRelativeTolerance ( parRelativeTolerance ) . withOrthoTolerance ( orthoTolerance ) . withRankingThreshold ( Precision.SAFE_MIN )
{ return new LevenbergMarquardtOptimizer () ; }
{ return new LeastSquaresProblemImpl ( model , jacobian , observed , start , checker , maxEvaluations , maxIterations ) ; }
public RealMatrix computeJacobian () { return this . jacobian ; }
public double [] computeValue () { return this . values . toArray () ; }
@ Test public void testGaussNewtonQR ( ) throws Exception { check ( new GaussNewtonOptimizer ( Decomposition.QR ) ) ; }
@ Test public void testGaussNewtonLU ( ) throws Exception { check ( new GaussNewtonOptimizer ( Decomposition.LU ) ) ; }
{ return new LeastSquaresBuilder () . checkerPair ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . maxEvaluations ( NUMBER_CONSTANT ) . maxIterations ( getMaxIterations () ) ; }
final ConvergenceChecker < Evaluation > checker
final ConvergenceChecker < Evaluation > checker
builder ( circle ) . checkerPair ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . maxIterations ( Integer.MAX_VALUE )
final ConvergenceChecker < Evaluation > checker
final ConvergenceChecker < Evaluation > checker
final ConvergenceChecker < Evaluation > checker
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
final RealVector point
function . checkTheoreticalMinParams ( optimum . getPoint () . toArray () ) ;
final RealVector point
RealVector computeValue ( ) ;
RealVector point
RealVector getStart ( ) ;
RealVector point
final RealVector start
final RealVector target
public RealVector computeValue () { return this . weightSqrt . operate ( unweighted . computeValue () ) ; }
catch ( NonPositiveDefiniteMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM , e ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM , e ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM , e ) ; }
final double actual = lsp . evaluate ( lsp . getStart () ) . getRMS () ;
final double cost = lsp . evaluate ( lsp . getStart () ) . getCost () ;
Assert . assertArrayEquals ( evaluation . getResiduals () . toArray () , new double [] { NUMBER_CONSTANT , - NUMBER_CONSTANT } , Precision.EPSILON ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertTrue ( optimum . getRMS () > NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
final double cost = lsp . evaluate ( params ) . getCost () ;
final RealVector sigma = lsp . evaluate ( regress ) . getSigma ( NUMBER_CONSTANT ) ;
final RealVector sigma = lsp . evaluate ( init ) . getSigma ( NUMBER_CONSTANT ) ;
final double [] asymptoticStandardErrorFound = optimum . getSigma ( NUMBER_CONSTANT ) . toArray () ;
final RealMatrix covarMatrix = optimum . getCovariances ( NUMBER_CONSTANT ) ;
function . checkTheoreticalMinCost ( optimum . getRMS () ) ;
RealVector getValue ( ) ;
Assert . assertNotSame ( STRING_CONSTANT , v1 . getDataRef () , v_copy . toArray () ) ;
{ return new LocalLeastSquaresProblem ( model , observed , start , checker , maxEvaluations , maxIterations ) ; }
assertEquals ( TOl , optimum . getResiduals () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
line = new LineSearch ( this , lineRel , lineAbs ) ;
line = new LineSearch ( this , lineRel , lineAbs , NUMBER_CONSTANT ) ;
{ this ( updateFormula , checker , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , new IdentityPreconditioner () ) ; }
penalty += diff ;
public FitnessFunction () { isRepairMode = true ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( getX () , threshold ) ; }
public RealVector getResiduals () { return residuals ; }
public RealVector getPoint () { return point ; }
public RealMatrix getJacobian () { return jacobian ; }
super ( randomData . getRandomGenerator () ) ;
@ Override protected RealDistribution getKernel ( SummaryStatistics bStats ) { return new ConstantRealDistribution ( bStats . getMean () ) ; }
return new Median () . withEstimationType ( type ) . withNaNStrategy ( strategy ) ;
double result = new Percentile ( p ) . withEstimationType ( e ) . withNaNStrategy ( nanStrategy ) . evaluate ( data ) ;
{ new Percentile ( NUMBER_CONSTANT ) . withEstimationType ( Percentile.EstimationType.LEGACY ) . withNaNStrategy ( null ) ; Assert . fail ( STRING_CONSTANT + STRING_CONSTANT ) ; }
new Percentile ( NUMBER_CONSTANT ) . withEstimationType ( Percentile.EstimationType.R_9 ) . withNaNStrategy ( NaNStrategy.FAILED ) . evaluate ( specialValues , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new Percentile ( quantile ) . withEstimationType ( type ) . withNaNStrategy ( nanStrategy ) . withPivotingStrategy ( pivotingStrategy ) ; }
final BicubicSplineInterpolator bsi = new BicubicSplineInterpolator ( true ) ;
return new BicubicSplineInterpolatingFunction ( xval , yval , fval , dFdX , dFdY , d2FdXdY , initializeDerivatives ) ;
final FieldMatrix < BigFraction > H = this . createExactH ( d , n ) ;
{ return new Median ( getEstimationType () , newNaNStrategy , getKthSelector () ) ; }
{ return new Median ( newEstimationType , getNaNStrategy () , getKthSelector () ) ; }
final Percentile p = getUnivariateStatistic () ;
final Percentile p = getUnivariateStatistic () ;
final Percentile p = getUnivariateStatistic () ;
{ for ( final Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testWeightedConsistency () ; } }
{ for ( final Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testEvaluateArraySegment () ; } }
{ for ( final Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testEvaluateArraySegmentWeighted () ; } }
final UnivariateStatistic percentile = getUnivariateStatistic () ;
final UnivariateStatistic percentile = getUnivariateStatistic () ;
final Percentile percentile = new Percentile ( NUMBER_CONSTANT ) ;
return work.length == NUMBER_CONSTANT ? Double.NaN : estimationType . evaluate ( work , pivotsHeap , p , kthSelector ) ;
kthSelector = original . getKthSelector () ;
final double Umin = ( long ) x.length * y.length - Umax ;
{ return new LazyUnweightedEvaluation ( ( ValueAndJacobianFunction ) model , target , p ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , ( ( ResizableDoubleArray ) da ) . getContractionCriterion () , NUMBER_CONSTANT ) ;
ResizableDoubleArray testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ExpansionMode.ADDITIVE ) ;
testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ExpansionMode.ADDITIVE ) ;
ResizableDoubleArray testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ExpansionMode.ADDITIVE ) ;
empiricalDistribution = new EmpiricalDistribution ( binCount , randomData . getRandomGenerator () ) ;
{ this . randomData = new RandomDataGenerator ( generator ) ; }
{ this . randomData = randomData . getDelegate () ; }
RandomDataGenerator random = new RandomDataGenerator () ;
{ return ( MathUtils.PI_SQUARED / NUMBER_CONSTANT ) * ( NUMBER_CONSTANT / ( s * s ) ) ; }
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
final FDistribution fdist = new FDistribution ( null , a.dfbg , a.dfwg ) ;
final NormalDistribution standardNormal = new NormalDistribution ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final BinomialDistribution distribution = new BinomialDistribution ( null , numberOfTrials , probability ) ;
final NormalDistribution standardNormal = new NormalDistribution ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( getX () , threshold ) ; }
t . insertInTree ( parentTree , isPlusChild , new VanishingToLeaf ( true ) ) ;
return MathArrays . linearCombination ( sin , otherL.sin , cos , otherL.cos ) >= NUMBER_CONSTANT ;
tree = region1 . getTree ( false ) . merge ( region2 . getTree ( false ) , new DifferenceMerger ( region1 , region2 ) )
{ unlinkReverse () ; originOffset = offset ; }
if ( p == NUMBER_CONSTANT ) { return Double.NEGATIVE_INFINITY ; } else if ( p == NUMBER_CONSTANT ) { return Double.POSITIVE_INFINITY ; }
{ vals = MathArrays . copyOf ( b , b.length ) ; nVals = n ; }
cachedTransform = org.apache.commons.math4.geometry.euclidean.twod.Line . getTransform ( at ) ;
cachedTransform = org.apache.commons.math4.geometry.euclidean.twod.Line . getTransform ( at ) ;
@ Test ( expected = org.apache.commons.math4.linear.SingularMatrixException . class )
org.apache.commons.math4.stat.inference.ChiSquareTest csti = new org.apache.commons.math4.stat.inference.ChiSquareTest () ;
org.apache.commons.math4.stat.inference.ChiSquareTest csti = new org.apache.commons.math4.stat.inference.ChiSquareTest () ;
( numIterations < maximumIterations ) && ( a > lowerBound || b < upperBound )
public Well1024a ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well1024a ( int seed ) { super ( K , seed ) ; }
public Well44497b ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well44497b ( int seed ) { super ( K , seed ) ; }
public Well19937a ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well19937a ( int seed ) { super ( K , seed ) ; }
public Well512a ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well512a ( int seed ) { super ( K , seed ) ; }
public Well19937c ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well19937c ( int seed ) { super ( K , seed ) ; }
public Well44497a ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well44497a ( int seed ) { super ( K , seed ) ; }
TestUtils . assertEquals ( m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . toArray () ) , preMultTest ) ;
TestUtils . assertEquals ( m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . toArray () ) , preMultTest ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI ) ;
x = new UniformRealDistribution ( rng , lo , hi ) ;
x = new UniformRealDistribution ( rng , lo , hi ) ;
x = new UniformRealDistribution ( rng , lo , hi ) ;
{ double actual = getDistribution () . probability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , actual , NUMBER_CONSTANT ) ; }
distribution . probability ( lower [ i ] , upper [ i ] )
final double withinBinKernelMass = kernel . probability ( lower , upper ) ;
try { distribution . probability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
distribution . logDensity ( cumulativeTestPoints [ i ] )
try { distribution . probability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
try { StatUtils . min ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
try { StatUtils . max ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
try { StatUtils . mean ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
@ Test ( expected = NullArgumentException . class ) public void testNullFunction () { UnivariateSolverUtils . bracket ( null , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test ( expected = NullArgumentException . class )
tournamentPopulation = new ListPopulation ( this . arity ) { @ Override public Population nextGeneration () { return null ; } }
delta = ( max - min ) / ( binCount ) ;
@ Override T reciprocal ( ) ;
delta = ( max - min ) / binCount ;
protected double getSolverAbsoluteAccuracy () { return SOLVER_DEFAULT_ABSOLUTE_ACCURACY ; }
SparseGradient sgY2 = sgX . compose ( poly . value ( x ) , poly . polynomialDerivative () . value ( x ) ) ;
Assert . assertEquals ( f . polynomialDerivative () . polynomialDerivative () . value ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , tolerance ) ;
UnivariateFunction dSpline = spline . polynomialSplineDerivative () ;
{ return FastMath . abs ( getOffset ( p ) ) < tolerance ; }
if ( direction . getNorm () < tolerance ) { return null ; }
MathArrays . verifyValues ( values , begin , length ) ;
ptile . incrementAll ( d ) ;
MathArrays . verifyValues ( values , begin , length , true )
MathArrays . verifyValues ( values , weights , begin , length )
MathArrays . verifyValues ( values , begin , length )
MathArrays . verifyValues ( values , begin , length , true )
m . incrementAll ( values ) ;
m . incrementAll ( values ) ;
MathArrays . verifyValues ( values , begin , length )
MathArrays . verifyValues ( values , start , length ) ;
MathArrays . verifyValues ( values , weights , begin , length )
MathArrays . verifyValues ( values , begin , length )
MathArrays . verifyValues ( values , weights , begin , length , true )
MathArrays . verifyValues ( values , begin , length ) && length > NUMBER_CONSTANT
MathArrays . verifyValues ( values , begin , length )
{ MathArrays . verifyValues ( values , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
MathArrays . verifyValues ( values , weights , begin , length , true )
MathArrays . verifyValues ( values , begin , length , true )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
catch ( MathIllegalArgumentException iae ) {}
try { stats . setWindowSize ( - NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException iae ) {}
{ try { new DummyBinaryChromosome ( repr ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException e ) {} }
@ Test ( expected = MathIllegalArgumentException . class )
catch ( MathIllegalArgumentException iae ) { return true ; }
catch ( MathIllegalArgumentException iae ) {}
final double Hs = nthHarmonic ;
final double Hs = nthHarmonic ;
return generalizedHarmonic ( x , exponent ) / nthHarmonic ;
return - FastMath . log ( x ) * exponent - FastMath . log ( nthHarmonic ) ;
if ( Double . isNaN ( x ) ) { return x ; }
if ( Double . isNaN ( x ) ) { return x ; }
if ( Double . isNaN ( x ) ) { return Double.NaN ; }
if ( Double . isNaN ( x ) ) { return Double.NaN ; }
if ( Double . isNaN ( x ) || Double . isNaN ( y ) ) { return Double.NaN ; }
if ( Double . isNaN ( x ) || x == NUMBER_CONSTANT ) { return x ; }
if ( Double . isNaN ( x ) ) { return x ; }
if ( Double . isNaN ( x ) ) { return x ; }
if ( Double . isNaN ( x ) ) { return x ; }
{ super ( LocalizedFormats.UNKNOWN_PARAMETER , name ) ; this . name = name ; }
final double exponent
double brightnessExponent
MultivariateInterpolator interpolator = new MicrosphereInterpolator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return ( numerator . signum () == NUMBER_CONSTANT ) ? this : negate () ; }
final long numCalls = numberOfCalls . incrementAndGet () - NUMBER_CONSTANT ;
final Gaussian neighbourhoodDecay = new Gaussian ( currentLearning , NUMBER_CONSTANT , currentNeighbourhood ) ;
{ return divide ( new Fraction ( i ) ) ; }
{ return multiply ( new Fraction ( i ) ) ; }
TestUtils . assertRelativelyEquals ( expected , ZipfRejectionInversionSampler . helper2 ( testValue ) * testValue , tol ) ;
this . maxEvaluations = maxEvaluations ;
final int rowOffset ;
long swaps = NUMBER_CONSTANT ;
{ if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return FastMath . exp ( log1mProbabilityOfSuccess * x ) * probabilityOfSuccess ; } }
SQRT_TWO_PI / absX * FastMath . pow ( y , absX + NUMBER_CONSTANT ) * FastMath . exp ( - y )
return new CorrelatedRandomVectorGenerator ( new double [ cov.length ] , matrix , small , new GaussianRandomGenerator ( new Well1024a ( NUMBER_CONSTANT ) ) ) ;
BigFractionMatrixConverter () { super ( BigFraction.ZERO ) ; }
FractionMatrixConverter () { super ( Fraction.ZERO ) ; }
final RealFieldUnivariateFunction < T > f
final RealFieldUnivariateFunction < T > f
RealFieldUnivariateFunction < Dfp > f
final EnumeratedRealDistribution dist = new EnumeratedRealDistribution ( rng , combined ) ;
public JDKRandomGenerator ( long seed ) { setSeed ( seed ) ; }
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
starter . addStepHandler ( new NordsieckInitializer ( ( nSteps + NUMBER_CONSTANT ) / NUMBER_CONSTANT , y0.length ) ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ evaluations . increment () ; expandable . computeDerivatives ( t , y , yDot ) ; }
evaluations = evaluations . withStart ( NUMBER_CONSTANT ) ;
catch ( InitializationCompletedMarkerException icme ) { getCounter () . increment ( starter . getEvaluations () ) ; }
Vector3D axis = r . getAxis ( RotationConvention.VECTOR_OPERATOR ) ;
FieldVector3D < DerivativeStructure > axis = r . getAxis ( RotationConvention.VECTOR_OPERATOR ) ;
FieldVector3D < Dfp > axis = r . getAxis ( RotationConvention.VECTOR_OPERATOR ) ;
final Rotation composite = r1 . compose ( r2 . compose ( r3 , RotationConvention.FRAME_TRANSFORM ) , RotationConvention.FRAME_TRANSFORM ) ;
{ return r1 . composeInverseInternal ( r2 ) . getAngle () ; }
{ return r1 . composeInverseInternal ( r2 ) . getAngle () ; }
{ try { return delegate . nextInt ( n ) ; } catch ( IllegalArgumentException e ) { throw new NotStrictlyPositiveException ( n ) ; } }
{ delegate . setSeed ( RandomGeneratorFactory . convertToLong ( seed ) ) ; }
{ delegate . setSeed ( ( long ) seed ) ; }
setSeedInternal ( seed ) ;
{ setSeedInternal ( seed ) ; }
public ISAACRandom ( long seed ) { setSeedInternal ( seed ) ; }
{ setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ bits = nextInt () > > > NUMBER_CONSTANT ; val = bits % n ; }
if ( seed == null ) { setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
if ( seed == null ) { setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ setSeedInternal ( new int [] { seed } ) ; }
return computeInterpolatedStateAndDerivatives ( mapper , time , theta , oneMinusThetaH ) ;
mapper = null ;
yDotK [ NUMBER_CONSTANT ] = equations . getMapper () . mapDerivative ( stepStart ) ;
mainSetDimension = eqn . getStateDimension () ;
BracketedRealFieldUnivariateSolver < T > solver
final BracketedRealFieldUnivariateSolver < T > solver
final BracketedRealFieldUnivariateSolver < T > solver
public TestProblem5 () { setFinalConditions ( NUMBER_CONSTANT * t0 - t1 ) ; }
for ( int i = NUMBER_CONSTANT ; i < getDimension () ; ++ i ) { y [ i ] = c ; }
i < getDimension ()
i < getDimension ()
i < getDimension ()
i < getDimension ()
currentState = y ;
super ( field , METHOD_NAME , NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
super ( field , METHOD_NAME , NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
start . subtract ( problem . getInitialState () . getTime () ) . divide ( integrator . getCurrentSignedStepsize () ) . abs () . getReal () > NUMBER_CONSTANT
super ( field , METHOD_NAME , - NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , - NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
{ super ( field ) ; setFinalConditions ( getInitialState () . getTime () . multiply ( NUMBER_CONSTANT ) . subtract ( getFinalTime () ) ) ; }
{ return getField () . getOne () . multiply ( p ) . divide ( q ) ; }
d = MathArrays . buildArray ( getField () , NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
{ return doCopy () ; }
{ return new EulerFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new DormandPrince54FieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new DormandPrince853FieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
final T one = getField () . getOne () ;
{ return new MidpointFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new HighamHall54FieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
final T coeffDot1 = getField () . getOne () . subtract ( coeffDot2 ) ;
{ return new ClassicalRungeKuttaFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new GillFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
final T one = getField () . getOne () ;
{ return new LutherFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new ThreeEighthesFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
final T two = getField () . getZero () . add ( NUMBER_CONSTANT ) ;
{ return getField () . getZero () . add ( p ) . divide ( q ) ; }
{ return new EulerFieldStepInterpolator < T > ( field , forward , mapper ) ; }
integ . integrate ( new FieldExpandableODE < T > ( equations ) , new FieldODEState < T > ( t0 , y0 ) , t ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
mapper = new FieldEquationsMapper < T > ( mapper , secondary . getDimension () ) ;
integrator . integrate ( new FieldExpandableODE < T > ( problem ) , problem . getInitialState () , problem . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
FieldFirstOrderDifferentialEquations < T > eqn = new SinCos < T > ( field ) ;
setUpInterpolator ( field , new SinCos < T > ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
setUpInterpolator ( field , new SinCos < T > ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
steps . add ( interpolator ) ;
for ( FieldStepInterpolator < T > interpolator : model.steps ) { steps . add ( interpolator ) ; }
while ( ++ index < getNumberOfEquations () ) { insertEquationData ( index , state . getSecondaryDerivative ( index ) , yDot ) ; }
while ( ++ index < getNumberOfEquations () ) { insertEquationData ( index , state . getSecondaryState ( index ) , y ) ; }
{ System . arraycopy ( mapper.start , NUMBER_CONSTANT , start , NUMBER_CONSTANT , index + NUMBER_CONSTANT ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override
@ Override
@ Override
@ Override
@ Override
@ Override
@ Override
@ Override
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
FirstOrderFieldIntegrator < T > integrator
final FirstOrderFieldDifferentialEquations < T > primary
final FirstOrderFieldIntegrator < T > integrator
final FirstOrderFieldDifferentialEquations < T > equations
final FirstOrderFieldDifferentialEquations < T > eqn
final FirstOrderFieldDifferentialEquations < T > eqn
{ return taylor ( reference , time , scalingH , scaled , nordsieck ) ; }
@ Test ( expected = MaxCountExceededException . class ) public void exceedMaxEvaluations () { doExceedMaxEvaluations ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ setSeed ( new int [] { seed } ) ; }
{ bits = ( nextInt () > > > NUMBER_CONSTANT ) ; val = bits % n ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ setSeed ( seed ) ; }
public ISAACRandom ( long seed ) { setSeed ( seed ) ; }
{ setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
setSeed ( seed ) ;
{ return timeAndReport ( title , DEFAULT_MAX_NAME_WIDTH , DEFAULT_REPEAT_CHUNK , DEFAULT_REPEAT_STAT , false , methods ) ; }
@ Deprecated double sample ( ) ;
random = RandomSource . create ( RandomSource.WELL_1024_A , seed ) ;
{ this ( cityList , numNeuronsPerCity , RandomSource . createLong () ) ; }
final TDistribution distribution = new TDistribution ( degreesOfFreedom ) ;
final TDistribution distribution = new TDistribution ( degreesOfFreedom ) ;
final TDistribution distribution = new TDistribution ( n - NUMBER_CONSTANT ) ;
return empiricalDistribution . createSampler ( randomData . getRandomProvider () ) . sample () ;
empiricalDistribution = new EmpiricalDistribution ( binCount ) ;
{ this . value = value ; }
final NormalDistribution standardNormal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final NormalDistribution standardNormal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final FDistribution fdist = new FDistribution ( a.dfbg , a.dfwg ) ;
final FDistribution fdist = new FDistribution ( a.dfbg , a.dfwg ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
{ final double u = rng . nextDouble () ; return u * upper + ( NUMBER_CONSTANT - u ) * lower ; }
final BinomialDistribution distribution = new BinomialDistribution ( numberOfTrials , probability ) ;
{ rand = new Well19937c () ; }
return complexSolver . solve ( ComplexUtils . real2Complex ( coefficients ) , new Complex ( initial , NUMBER_CONSTANT ) ) ;
return complexSolver . solveAll ( ComplexUtils . real2Complex ( coefficients ) , new Complex ( initial , NUMBER_CONSTANT ) ) ;
final Complex c [] = ComplexUtils . real2Complex ( getCoefficients () ) ;
UniformRandomProvider rng = RandomSource . create ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
RealDistribution.Sampler distribution
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
for ( int i = NUMBER_CONSTANT ; i < dim ; i ++ ) { normalVals [ i ] = gauss . sample () ; }
cachedD = MatrixUtils . createRealMatrixWithDiagonal ( realEigenvalues ) ;
ComplexFormat cf = ComplexFormat . getInstance ( getLocale () ) ;
ComplexFormat cf = ComplexFormat . getInstance ( getLocale () ) ;
UniformRandomProvider randomGenerator
public NaturalRanking ( UniformRandomProvider randomGenerator ) { this ( DEFAULT_NAN_STRATEGY , TiesStrategy.RANDOM , randomGenerator ) ; }
{ this ( nanStrategy , tiesStrategy , RandomSource . create ( RandomSource.WELL_19937_C ) ) ; }
{ this ( DEFAULT_NAN_STRATEGY , tiesStrategy , RandomSource . create ( RandomSource.WELL_19937_C ) ) ; }
final UniformRandomProvider random
final UniformRandomProvider random
{ this ( k , maxIterations , measure , RandomSource . create ( RandomSource.MT_64 ) ) ; }
final UniformRandomProvider random = RandomSource . create ( RandomSource.MT_64 ) ;
final UniformRandomProvider random
{ this ( k , fuzziness , maxIterations , measure , DEFAULT_EPSILON , RandomSource . create ( RandomSource.MT_64 ) ) ; }
final UniformRandomProvider random
final UniformRandomProvider random = GeneticAlgorithm . getRandomGenerator () ;
UniformRandomProvider randGen = getRandomGenerator () ;
final UniformRandomProvider random
final UniformRandomProvider random = GeneticAlgorithm . getRandomGenerator () ;
final UniformRandomProvider random = GeneticAlgorithm . getRandomGenerator () ;
{ d [ r ] [ c ] = random . sample () ; }
for ( int i = NUMBER_CONSTANT ; i < size ; i ++ ) { randn [ i ] = random . sample () ; }
final UniformRandomProvider generator
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UnitSphereRandomVectorGenerator random = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) ;
UnitSphereRandomVectorGenerator random = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) ;
final double comp = rand . sample () ;
{ this ( dimension , RandomSource . create ( RandomSource.MT_64 ) ) ; }
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider generator = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider generator = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
{ field = new DfpField ( NUMBER_CONSTANT ) ; generator = RandomSource . create ( RandomSource.MT , NUMBER_CONSTANT ) ; }
UniformRandomProvider random = RandomSource . create ( RandomSource.XOR_SHIFT_1024_S , NUMBER_CONSTANT ) ;
UniformRandomProvider rng = RandomSource . create ( RandomSource.TWO_CMRES , NUMBER_CONSTANT ) ;
final UniformRandomProvider r
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider rng = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
new PivotingStrategyInterface [] { new MedianOf3PivotingStrategy () , new CentralPivotingStrategy () , new RandomPivotingStrategy ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) }
kthSelector = new KthSelector ( new RandomPivotingStrategy ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) ;
final RandomGenerator rng = new RngAdaptor ( RandomSource.MT ) ;
return InferenceTestUtils . gTest ( expected , observed ) ;
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( random ) . getState () ) ; }
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( delegate ) . getState () ) ; }
this . rng = new GaussianRandomGenerator ( RandomSource . create ( RandomSource.WELL_19937_C , seed ) ) ;
final UniformRandomProvider random = GeneticAlgorithm . getRandomGenerator () ;
rng = new GaussianRandomGenerator ( RandomSource . create ( RandomSource.WELL_19937_C , seed ) ) ;
final UniformRandomProvider random = RandomSource . create ( RandomSource.MT ) ;
List < Integer > baseSequence = new ArrayList <> ( l ) ;
List < S > origDataCopy = new ArrayList <> ( originalData ) ;
List < S > sortedData = new ArrayList <> ( data ) ;
List < Double > repr = new ArrayList <> ( l ) ;
List < Double > repr = new ArrayList <> ( l ) ;
List < Double > sortedRepr = new ArrayList <> ( getRepresentation () ) ;
this . hParam = new HashMap <> () ;
BlockFieldMatrix < Fraction > m = new BlockFieldMatrix <> ( testData ) ;
BlockFieldMatrix < Fraction > m = new BlockFieldMatrix <> ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
return new ArrayFieldVector <> ( data , false ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
{ Assert . assertEquals ( new BlockFieldMatrix <> ( reference ) , sub ) ; }
{ Assert . assertEquals ( new BlockFieldMatrix <> ( reference ) , sub ) ; }
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( testData ) ;
final List < double [] > paramsAndChi2 = new ArrayList <> ( gridSize * gridSize ) ;
FirstOrderFieldDifferentialEquations < T > eqn = new SinCos <> ( field ) ;
setUpInterpolator ( field , new SinCos <> ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
setUpInterpolator ( field , new SinCos <> ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
return new FieldODEStateAndDerivative <> ( time , y , yDot ) ;
this . interpolator = new PerfectInterpolator <> ( problem ) ;
boundary = new ArrayList <> ()
{ return new BSPTree <> ( Boolean.FALSE ) ; }
final List < Neuron > neuronList = new ArrayList <> () ;
final List < Neuron > neurons = new ArrayList <> () ;
{ copy.linkMap . put ( e . getKey () , new HashSet <> ( e . getValue () ) ) ; }
return new Array2DRowFieldMatrix <> ( pData , false ) ;
{ return new ArrayList <> ( observations ) ; }
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( fData , false ) ;
FieldMatrix < BigFraction > m = new Array2DRowFieldMatrix <> ( bfData , false ) ;
List < CentroidCluster < T > > newClusters = new ArrayList <> () ;
final Collection < Neuron > exclude = new ArrayList <> () ;
List < Number > components = new ArrayList <> () ;
return new FieldODEStateAndDerivative <> ( time , estimatedState , estimatedDerivatives ) ;
this . nordsieck = new Array2DRowFieldMatrix <> ( nordsieck . getData () , false ) ;
List < Chromosome > popList = new LinkedList <> () ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
{ return new ThreeEighthesFieldIntegrator <> ( field , step ) ; }
{ innerDistribution = new EnumeratedDistribution <> ( createDistribution ( singletons , probabilities ) ) ; }
{ return new Pair <> ( k , v ) ; }
{ return new ClassicalRungeKuttaFieldIntegrator <> ( field , field . getOne () ) ; }
return new Array2DRowFieldMatrix <> ( field , d , false ) ;
List < Vector2D > support = new ArrayList <> () ;
{ return new ArrayList <> () ; }
{ points = new ArrayList <> () ; sigma = error ; }
ArrayFieldVector < T > out = new ArrayFieldVector <> ( field , n ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
{ return new ArrayFieldVector <> ( this , v ) ; }
final FieldMatrix < T > out = new Array2DRowFieldMatrix <> ( field , m , n ) ;
final FieldMatrix < T > out = new Array2DRowFieldMatrix <> ( field , m , n ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
{ return new ArrayFieldVector <> ( this , true ) ; }
List < Comparable < > > modeList = new ArrayList <> () ;
TestFieldProblem3 < T > pb = new TestFieldProblem3 <> ( field ) ;
return new Pair <> ( normal , jTr ) ;
{ return new FieldODEState <> ( t0 , y0 ) ; }
final Set < City > unique = new HashSet <> () ;
final List < Future < > > execOutput = new ArrayList <> () ;
{ return new EulerFieldIntegrator <> ( field , step ) ; }
{ return new ThreeEighthesFieldIntegrator <> ( field , field . getOne () ) ; }
{ return new SparseFieldMatrix <> ( getField () , rowDimension , columnDimension ) ; }
{ return new SparseFieldMatrix <> ( this ) ; }
entries = new OpenIntToFieldHashMap <> ( getField () ) ;
entries = new OpenIntToFieldHashMap <> ( other.entries ) ;
entries = new OpenIntToFieldHashMap <> ( field ) ;
entries = new OpenIntToFieldHashMap <> ( field ) ;
singletons = new ArrayList <> ( pmf . size () ) ;
final FuzzyKMeansClusterer < DoublePoint > clusterer = new FuzzyKMeansClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final HashSet < Double > values = new HashSet <> () ;
return new Array2DRowFieldMatrix <> ( BigFractionField . getInstance () , Hdata ) ;
Collection < Neuron > exclude = new HashSet <> () ;
Collection < Neuron > exclude = new HashSet <> () ;
final List < Long > linkEnd = new ArrayList <> () ;
final List < BigFraction > list = new ArrayList <> () ;
final List < Segment > segments = new ArrayList <> ( list . size () ) ;
binStats = new ArrayList <> () ;
final Set < T > oneSet = new HashSet <> ( one ) ;
final List < T > neighbors = new ArrayList <> () ;
List < T > seeds = new ArrayList <> ( neighbors ) ;
final List < Object > orig = new ArrayList <> () ;
context = new HashMap <> () ;
final Set < Integer > usedBasicRows = new HashSet <> () ;
final Set < Integer > columnsToDrop = new TreeSet <> () ;
List < LinearConstraint > normalized = new ArrayList <> ( originalConstraints . size () ) ;
this . derivatives = new HashMap <> () ;
this . derivatives = new HashMap <> () ;
final FieldODEStateAndDerivative < T > state0 = new FieldODEStateAndDerivative <> ( t0 , y0 , y0Dot ) ;
return new Array2DRowFieldMatrix <> ( out ) ;
Array2DRowFieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
return new ArrayFieldVector <> ( data , false ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
{ Assert . assertEquals ( new Array2DRowFieldMatrix <> ( reference ) , sub ) ; }
{ Assert . assertEquals ( new Array2DRowFieldMatrix <> ( reference ) , sub ) ; }
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( testData ) ;
@ Before public void setUp () { evaluator = new SumOfClusterVariances <> ( new EuclideanDistance () ) ; }
final List < WeightedObservedPoint > observations = new ArrayList <> ( unsorted ) ;
RegionFactory < Sphere1D > factory = new RegionFactory <> () ;
List < SubHyperplane < Sphere1D > > boundary = new ArrayList <> () ;
List < Integer > newRepr = new ArrayList <> ( origChrom . getRepresentation () ) ;
this . representation = Collections . unmodifiableList ( copyList ? new ArrayList <> ( representation ) : representation ) ;
final RegionFactory < Euclidean2D > factory = new RegionFactory <> () ;
final List < EventHandler > list = new ArrayList <> ( eventsStates . size () ) ;
final List < double [] > coordinatesList = new ArrayList <> () ;
final List < Neuron > list = new ArrayList <> () ;
final List < City > cityList = new ArrayList <> () ;
final ArrayList < Double > list = new ArrayList <> () ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , nCols , nRows ) ;
return new ArrayFieldVector <> ( getField () , outData , false ) ;
return new ArrayFieldVector <> ( getField () , outData , false ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , NUMBER_CONSTANT ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , NUMBER_CONSTANT , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , m.columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
{ return new BlockFieldMatrix <> ( getField () , rowDimension , columnDimension ) ; }
List < Vector2D > points = new ArrayList <> ( size ) ;
List < Vector2D > points = new ArrayList <> () ;
List < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList <> () , transformers ) ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList <> () , transformers ) ;
DescriptiveStatistics u = new ListUnivariateImpl ( new ArrayList <> () , transformers ) ;
List < Object > externalList = new ArrayList <> () ;
List < Chromosome > popList = new LinkedList <> () ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
{ map = new HashMap <> () ; defaultTransformer = new DefaultTransformer () ; }
return new SparseFieldVector <> ( field , t ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
SparseFieldVector < Fraction > v1 = new SparseFieldVector <> ( field , vec1 ) ;
SparseFieldVector < Fraction > v1 = new SparseFieldVector <> ( field , vec1 ) ;
BSPTree < Sphere1D > tree = new BSPTree <> ( Boolean.FALSE ) ;
final List < Arc > list = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
final ArrayList < Object [] > parameters = new ArrayList <> () ;
this . listeners = new CopyOnWriteArrayList <> () ;
this . listeners = new CopyOnWriteArrayList <> () ;
close = new ArrayList <> ()
ArrayList < Integer > out = new ArrayList <> () ;
steps = new ArrayList <> () ;
List < Vector2D > quadrilateral = new ArrayList <> () ;
final List < Vector2D > reducedPoints = new ArrayList <> ( quadrilateral ) ;
final ArrayList < Integer > nonZeroPositions = new ArrayList <> () ;
List < Integer > minRatioPositions = new ArrayList <> () ;
ArrayList < SubHyperplane < Euclidean2D > > edges = new ArrayList <> () ;
RegionFactory < Euclidean2D > factory = new RegionFactory <> () ;
final List < Segment > segments = new ArrayList <> ( list . size () ) ;
loops = new ArrayList <> () ;
{ return new FieldLUDecomposition <> ( m ) . getDeterminant () . doubleValue () ; }
solver = new FieldLUDecomposition <> ( createFractionMatrix ( singular ) ) . getSolver () ;
solver = new FieldLUDecomposition <> ( createFractionMatrix ( testData ) ) . getSolver () ;
final FieldODEStateAndDerivative < T > stateTmp = new FieldODEStateAndDerivative <> ( stepEnd , yTmp , yDotTmp ) ;
return new Array2DRowFieldMatrix <> ( pData , false ) ;
final List < Complex > result = new ArrayList <> () ;
return new FieldRotation <> ( mds , threshold ) ;
FieldRotation < DerivativeStructure > quat = new FieldRotation <> ( u1 , u2 , v1 , v2 ) ;
public ListUnivariateImpl () { this ( new ArrayList <> () ) ; }
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
tasks = new ArrayList <> ()
NPointCrossover < Integer > npc = new NPointCrossover <> ( order ) ;
RegionFactory < Sphere1D > factory = new RegionFactory <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
List < Vector2D > reducedSupport = new ArrayList <> () ;
List < Vector2D > list = new ArrayList <> ( coordinates.length / NUMBER_CONSTANT ) ;
List < Vector2D > points = new ArrayList <> () ;
WelzlEncloser < Euclidean2D , Vector2D > encloser = new WelzlEncloser <> ( NUMBER_CONSTANT , generator ) ;
WelzlEncloser < Euclidean2D , Vector2D > encloser = new WelzlEncloser <> ( NUMBER_CONSTANT , generator ) ;
Collection < SummaryStatistics > aggregate = new ArrayList <> () ;
Collection < SummaryStatistics > aggregate = new ArrayList <> () ;
Collection < StatisticalSummary > aggregate = new ArrayList <> () ;
Collection < SummaryStatistics > aggregate = new ArrayList <> () ;
List < Chromosome > chromosomes = new ArrayList <> ( population . getChromosomes () ) ;
ContinuousOutputFieldModel < T > otherCm = new ContinuousOutputFieldModel <> () ;
ContinuousOutputFieldModel < T > cm = new ContinuousOutputFieldModel <> () ;
edges = new ArrayList <> ()
final List < Field > fields = new ArrayList <> () ;
output = new ArrayList <> () ;
{ return new GillFieldIntegrator <> ( field , field . getOne () ) ; }
return new Array2DRowFieldMatrix <> ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix <> ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix <> ( getField () , outData , false ) ;
{ return new Array2DRowFieldMatrix <> ( getField () , rowDimension , columnDimension ) ; }
{ return new LutherFieldIntegrator <> ( field , step ) ; }
this . convexCellsInsidePoints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
List < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
List < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
return new ArrayList <> ( edgeToNode . keySet () ) ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
List < Vector3D > support = new ArrayList <> () ;
return new ArrayFieldVector <> ( t ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( vec1 ) ;
ArrayFieldVector < Fraction > v1 = new ArrayFieldVector <> ( vec1 ) ;
return new FieldVectorTestImpl <> ( out ) ;
final BoundarySizeVisitor < S > visitor = new BoundarySizeVisitor <> () ;
final BoundaryProjector < S , T > projector = new BoundaryProjector <> ( point ) ;
{ tree = new BSPTree <> ( Boolean.FALSE ) ; }
{ this . tree = new BSPTree <> ( Boolean.TRUE ) ; this . tolerance = tolerance ; }
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
RegionFactory < Sphere1D > factory = new RegionFactory <> () ;
RegionFactory < Sphere2D > factory = new RegionFactory <> () ;
RegionFactory < Sphere2D > factory = new RegionFactory <> () ;
List < SubHyperplane < Sphere2D > > boundary = new ArrayList <> () ;
List < SubHyperplane < Sphere2D > > boundary = new ArrayList <> () ;
RegionFactory < Sphere2D > factory = new RegionFactory <> () ;
RegionFactory < Sphere2D > factory = new RegionFactory <> () ;
final ArrayList < Object [] > parameters = new ArrayList <> () ;
TestFieldProblem3 < T > pb = new TestFieldProblem3 <> ( field ) ;
RegionFactory < Euclidean3D > factory = new RegionFactory <> () ;
newClusters = new ArrayList <> ( k )
HashSet < Object > sampSet = new HashSet <> () ;
{ return new FieldVector3D <> ( NUMBER_CONSTANT , this , factor , v ) ; }
microsphereData = new ArrayList <> ( size ) ;
OnePointCrossover < Integer > opc = new OnePointCrossover <> () ;
{ return new MidpointFieldIntegrator <> ( field , field . getOne () ) ; }
KMeansPlusPlusClusterer < DoublePoint > transformer = new KMeansPlusPlusClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
{ return new ClassicalRungeKuttaFieldIntegrator <> ( field , step ) ; }
final ArrayList < String > lines = new ArrayList <> () ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList <> () ) ;
List < Object > list = new ArrayList <> () ;
List < Object > externalList = new ArrayList <> () ;
mapper = new FieldEquationsMapper <> ( mapper , secondary . getDimension () ) ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
DBSCANClusterer < DoublePoint > clusterer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > clusterer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
List < Vector3D > reducedSupport = new ArrayList <> () ;
List < Vector3D > points = new ArrayList <> () ;
WelzlEncloser < Euclidean3D , Vector3D > encloser = new WelzlEncloser <> ( NUMBER_CONSTANT , generator ) ;
WelzlEncloser < Euclidean3D , Vector3D > encloser = new WelzlEncloser <> ( NUMBER_CONSTANT , generator ) ;
regions = new ArrayList <> ( NUMBER_CONSTANT )
return new BoundaryProjection <> ( original , projected , offset ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
Map < Integer , Fraction > generated = new HashMap <> () ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
Set < Integer > keysInMap = new HashSet <> ( javaMap . keySet () ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field , NUMBER_CONSTANT ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
Map < Integer , Fraction > map = new HashMap <> () ;
integrator . integrate ( new FieldExpandableODE <> ( problem ) , problem . getInitialState () , problem . getFinalTime () ) ;
{ return new GillFieldIntegrator <> ( field , step ) ; }
{ components = new ArrayList <> () ; firstIndex = primary . getDimension () ; }
this . components = new ArrayList <> () ;
{ return new EulerFieldIntegrator <> ( field , field . getOne () ) ; }
{ this . tolerance = tolerance ; this . segments = new ArrayList <> () ; }
final List < Segment > loop = new ArrayList <> () ;
loops = new ArrayList <> ()
this . lines = new ArrayList <> () ;
List < Frequency > coll = new ArrayList <> () ;
List < Double > valuesList = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final HashMap < Neuron , Integer > hit = new HashMap <> () ;
final List < PairNeuronDouble > list = new ArrayList <> () ;
this . circles = new ArrayList <> () ;
this . jacobianProviders = new ArrayList <> () ;
{ return new LutherFieldIntegrator <> ( field , field . getOne () ) ; }
this . chromosomes = new ArrayList <> ( populationLimit ) ;
{ innerDistribution = new EnumeratedDistribution <> ( createDistribution ( singletons , probabilities ) ) ; }
steps = new ArrayList <> () ;
public CircleVectorial () { points = new ArrayList <> () ; }
final List < Interval > list = new ArrayList <> () ;
return new FieldRotation <> ( mds , threshold ) ;
FieldRotation < Dfp > quat = new FieldRotation <> ( u1 , u2 , v1 , v2 ) ;
final ArrayList < Object [] > parameters = new ArrayList <> () ;
List < Object [] > list = new ArrayList <> () ;
List < Chromosome > popList = new ArrayList <> () ;
final ArrayList < Double > integrationTestPoints = new ArrayList <> () ;
root = new BSPTree <> () ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
public Cluster () { points = new ArrayList <> () ; }
List < Integer > rList = new ArrayList <> ( length ) ;
{ return new MidpointFieldIntegrator <> ( field , step ) ; }
Map < String , String > referenceRules = new HashMap <> () ;
Map < String , String > referenceRules = new HashMap <> () ;
return new FieldODEState <> ( state . getTime () , y ) ;
SparseFieldVector < T > res = new SparseFieldVector <> ( this ) ;
FieldMatrix < T > res = new SparseFieldMatrix <> ( field , virtualSize , n ) ;
SparseFieldMatrix < T > res = new SparseFieldMatrix <> ( field , virtualSize , n ) ;
SparseFieldVector < T > res = new SparseFieldVector <> ( field , n ) ;
SparseFieldVector < T > res = new SparseFieldVector <> ( this ) ;
SparseFieldVector < T > res = new SparseFieldVector <> ( this ) ;
{ return new SparseFieldVector <> ( this ) ; }
FieldVector < T > res = new SparseFieldVector <> ( this , NUMBER_CONSTANT ) ;
FieldVector < T > res = new SparseFieldVector <> ( this , n ) ;
entries = new OpenIntToFieldHashMap <> ( v . getEntries () ) ;
entries = new OpenIntToFieldHashMap <> ( field ) ;
entries = new OpenIntToFieldHashMap <> ( field , expectedSize ) ;
entries = new OpenIntToFieldHashMap <> ( v.entries ) ;
entries = new OpenIntToFieldHashMap <> ( field ) ;
final Collection < Vector2D > points = new ArrayList <> () ;
{ new SparseFieldMatrix <> ( field , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
return new ArrayFieldVector <> ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector <> ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayFieldVector <> ( testVector ) ) . toArray () , entryTolerance ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix <> ( FractionField . getInstance () , testDataInv ) ) , identity , entryTolerance ) ;
Map < Integer , Double > generated = new HashMap <> () ;
Set < Integer > keysInMap = new HashSet <> ( javaMap . keySet () ) ;
Map < Integer , Double > map = new HashMap <> () ;
final List < Integer > factors = new ArrayList <> ( NUMBER_CONSTANT ) ;
final List < WeightedObservedPoint > observations = new ArrayList <> ( unsorted ) ;
final FieldODEStateAndDerivative < T > stateTmp = new FieldODEStateAndDerivative <> ( stepEnd , yTmp , yDotTmp ) ;
certifiedValues = new HashMap <> () ;
final Collection < SummaryStatistics > categoryDataSummaryStatistics = new ArrayList <> ( categoryData . size () ) ;
distribution = new ArrayList <> () ;
List < Chromosome > popChr = new ArrayList <> () ;
final List < WeightedObservedPoint > points = new ArrayList <> () ;
final List < Object > list = new ArrayList <> () ;
final SimplePointChecker < PointValuePair > checker = new SimplePointChecker <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final SimplePointChecker < PointValuePair > checker = new SimplePointChecker <> ( NUMBER_CONSTANT , NUMBER_CONSTANT , max ) ;
{ parametersNames = new ArrayList <> () ; parametersNames . addAll ( names ) ; }
parametersNames = new ArrayList <> () ;
final Set < Neuron > list = new HashSet <> () ;
p2 = new Pair <> ( STRING_CONSTANT , NUMBER_CONSTANT )
FieldMatrix < T > identity = new Array2DRowFieldMatrix <> ( field , m , m ) ;
return new Array2DRowFieldMatrix <> ( field , bp , false ) ;
return new ArrayFieldVector <> ( bp , false ) ;
return new ArrayFieldVector <> ( field , bp , false ) ;
{ return new Solver <> ( field , lu , pivot , singular ) ; }
cachedP = new Array2DRowFieldMatrix <> ( field , m , m ) ;
cachedU = new Array2DRowFieldMatrix <> ( field , m , m ) ;
cachedL = new Array2DRowFieldMatrix <> ( field , m , m ) ;
FieldBracketingNthOrderBrentSolver < Dfp > solver = new FieldBracketingNthOrderBrentSolver <> ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ;
FieldBracketingNthOrderBrentSolver < Dfp > solver = new FieldBracketingNthOrderBrentSolver <> ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ;
{ new FieldBracketingNthOrderBrentSolver <> ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ; }
RegionFactory < Euclidean2D > factory = new RegionFactory <> () ;
{ this . surrounded = new ArrayList <> () ; this . tolerance = tolerance ; }
points = new ArrayList <> () ;
public CircleScalar () { points = new ArrayList <> () ; }
RegionFactory < Euclidean1D > factory = new RegionFactory <> () ;
this . features = new AtomicReference <> ( features . clone () ) ;
List < Double > newRepr = new ArrayList <> ( repr ) ;
TreeSet < Double > values = new TreeSet <> () ;
final List < PairDoubleInteger > list = new ArrayList <> ( len ) ;
final Chromosome p1c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
@ Override public StepInterpolator copy () { return this ; }
final Chromosome p1c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
population = new ListPopulation ( chromosomes , NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
new ListPopulation ( chromosomes , NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } } ;
new ListPopulation ( chromosomes , - NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } } ;
{ new ListPopulation ( - NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } } ; }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
final Chromosome p1c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
@ Override public StepInterpolator copy () { return this ; }
final Chromosome p1c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
for ( int val : this . getRepresentation () ) { if ( val != NUMBER_CONSTANT ) { num ++ ; } }
if ( counts [ i ] == - NUMBER_CONSTANT ) { continue; }
if ( count ++ > NUMBER_CONSTANT ) { break; }
if ( count ++ > NUMBER_CONSTANT ) { break; }
random . restoreState ( state ) ;
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomSource.State ) random . saveState () ) . getState () ) ; }
delegate . restoreState ( state ) ;
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomSource.State ) delegate . saveState () ) . getState () ) ; }
{ double n = upperMinusLower + NUMBER_CONSTANT ; return ( n * n - NUMBER_CONSTANT ) / NUMBER_CONSTANT ; }
{ return NUMBER_CONSTANT * upperPlusLower ; }
return ( x - lower + NUMBER_CONSTANT ) / ( upperMinusLower + NUMBER_CONSTANT ) ;
return NUMBER_CONSTANT / ( upperMinusLower + NUMBER_CONSTANT ) ;
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomProviderDefaultState ) random . saveState () ) . getState () ) ; }
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomProviderDefaultState ) delegate . saveState () ) . getState () ) ; }
if ( shuffle ) { ListSampler . shuffle ( rng , points ) ; }
if ( shuffle ) { ListSampler . shuffle ( rng , points ) ; }
if ( shuffle ) { ListSampler . shuffle ( rng , points ) ; }
TranslationTransform ( final Coordinates3D translation ) { this . translation = translation ; }
final Coordinates3D translation
final Coordinates3D center
final Coordinates3D center
final Coordinates3D point
{ setSize ( NUMBER_CONSTANT ) ; setBarycenter ( ( Point < Euclidean3D > ) new Coordinates3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final List < Coordinates3D > vertices
final List < Coordinates3D > vertices
final Coordinates2D p2 = ( Coordinates2D ) vector ;
Collection < Coordinates2D > points
{ final Circle otherC = ( Circle ) other ; return Coordinates3D . dotProduct ( pole , otherC.pole ) >= NUMBER_CONSTANT ; }
final Coordinates3D direction
final Coordinates3D pole
Coordinates1D expected = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = Coordinates1D.NEGATIVE_INFINITY ;
Coordinates1D c = Coordinates1D.POSITIVE_INFINITY ;
Coordinates1D c = Coordinates1D.NaN ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( - NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
final Coordinates2D [] vertices
{ final Coordinates1D p1 = ( Coordinates1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
final Collection < Coordinates2D > points
final Collection < Coordinates2D > points
final Collection < Coordinates2D > points
ConvexHull2D hull = generator . generate ( Collections . < Coordinates2D > emptyList () ) ;
final double angle = Coordinates3D . angle ( thisCircle . getPole () , otherCircle . getPole () ) ;
{ return new SphericalCoordinates ( new Coordinates3D ( x , y , z ) ) ; }
final Coordinates3D v
final Coordinates3D pole
{ return Coordinates2D . angle ( p1.vector , p2.vector ) ; }
final Coordinates2D vector
Circle circle = new Circle ( Coordinates3D.PLUS_K , NUMBER_CONSTANT ) ;
this . summedBarycenter = Coordinates3D.ZERO ;
{ return Coordinates3D . angle ( p1.vector , p2.vector ) ; }
final Coordinates3D vector
final Coordinates3D p
final double angle = Coordinates3D . angle ( direction , line.direction ) ;
final Coordinates3D point
Coordinates3D v
{ new Coordinates3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Coordinates3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
Coordinates2D expected = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = Coordinates2D.NEGATIVE_INFINITY ;
Coordinates2D c = Coordinates2D.POSITIVE_INFINITY ;
Coordinates2D c = Coordinates2D.NaN ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return ( ( Coordinates3D ) point ) . dotProduct ( w ) + originOffset ; }
final Coordinates3D p
final Coordinates3D translation
final double angle = Coordinates3D . angle ( w , plane.w ) ;
final Coordinates3D tmp = u ;
final Coordinates3D normal
final Coordinates3D p = h . toSpace ( Coordinates2D.ZERO ) ;
final Coordinates2D p = h . toSpace ( Coordinates1D.ZERO ) ;
Coordinates3D [] points
final List < Coordinates3D > vertices
Arrays . asList ( Coordinates3D.ZERO , Coordinates3D.PLUS_I , Coordinates3D.PLUS_J , Coordinates3D.PLUS_K )
try { ps . checkPoint ( Coordinates3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D u
for ( Coordinates2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Coordinates2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
Coordinates3D c = Coordinates3D.NEGATIVE_INFINITY ;
Coordinates3D c = Coordinates3D.POSITIVE_INFINITY ;
Coordinates3D c = Coordinates3D.NaN ;
final Coordinates2D point
final Coordinates2D location
final Coordinates2D . . . vertices
final Coordinates2D . . . vertices
final Coordinates3D u
final Coordinates3D u
final double x = ( ( Coordinates1D ) point ) . getX () ;
{ return new Line ( new Coordinates2D ( getNumber () , getNumber () ) , getNumber () , getNumber () ) ; }
{ return new OrientedPoint ( new Coordinates1D ( getNumber () ) , getBoolean () , getNumber () ) ; }
{ return new Circle ( new Coordinates3D ( getNumber () , getNumber () , getNumber () ) , getNumber () ) ; }
Coordinates1D v
Coordinates1D v = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D v = new Coordinates1D ( NUMBER_CONSTANT ) ;
{ Space space = new Coordinates1D ( NUMBER_CONSTANT ) . getSpace () ; Assert . assertEquals ( NUMBER_CONSTANT , space . getDimension () ) ; }
final double delta = ( ( Coordinates1D ) point ) . getX () - location . getX () ;
final Coordinates1D location
try { FieldVector3D . angle ( v1 , Coordinates3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
Coordinates2D oneTwo = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ new Coordinates2D ( v ) ; }
final Coordinates2D tmp = loop [ min ] ;
final Coordinates2D [] bLoop
final Coordinates3D axis
Coordinates3D axis
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Coordinates1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
final Coordinates2D p
final Coordinates2D p
final Coordinates2D p
Coordinates2D p2 = ( Coordinates2D ) point ;
final Coordinates2D p
final Coordinates2D p
TranslationTransform ( final Cartesian3D translation ) { this . translation = translation ; }
final Cartesian3D translation
final Cartesian3D center
final Cartesian3D center
final Cartesian3D point
{ setSize ( NUMBER_CONSTANT ) ; setBarycenter ( ( Point < Euclidean3D > ) new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final List < Cartesian3D > vertices
final List < Cartesian3D > vertices
final Cartesian2D p2 = ( Cartesian2D ) vector ;
Collection < Cartesian2D > points
{ final Circle otherC = ( Circle ) other ; return Cartesian3D . dotProduct ( pole , otherC.pole ) >= NUMBER_CONSTANT ; }
final Cartesian3D direction
final Cartesian3D pole
Cartesian1D expected = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = Cartesian1D.NEGATIVE_INFINITY ;
Cartesian1D c = Cartesian1D.POSITIVE_INFINITY ;
Cartesian1D c = Cartesian1D.NaN ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( - NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
final Cartesian2D [] vertices
{ final Cartesian1D p1 = ( Cartesian1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
final Collection < Cartesian2D > points
final Collection < Cartesian2D > points
final Collection < Cartesian2D > points
ConvexHull2D hull = generator . generate ( Collections . < Cartesian2D > emptyList () ) ;
final double angle = Cartesian3D . angle ( thisCircle . getPole () , otherCircle . getPole () ) ;
{ return new SphericalCoordinates ( new Cartesian3D ( x , y , z ) ) ; }
final Cartesian3D v
final Cartesian3D pole
{ return Cartesian2D . angle ( p1.vector , p2.vector ) ; }
final Cartesian2D vector
Circle circle = new Circle ( Cartesian3D.PLUS_K , NUMBER_CONSTANT ) ;
this . summedBarycenter = Cartesian3D.ZERO ;
{ return Cartesian3D . angle ( p1.vector , p2.vector ) ; }
final Cartesian3D vector
final Cartesian3D p
final double angle = Cartesian3D . angle ( direction , line.direction ) ;
final Cartesian3D point
Cartesian3D v
{ new Cartesian3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
Cartesian2D expected = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = Cartesian2D.NEGATIVE_INFINITY ;
Cartesian2D c = Cartesian2D.POSITIVE_INFINITY ;
Cartesian2D c = Cartesian2D.NaN ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return ( ( Cartesian3D ) point ) . dotProduct ( w ) + originOffset ; }
final Cartesian3D p
final Cartesian3D translation
final double angle = Cartesian3D . angle ( w , plane.w ) ;
final Cartesian3D tmp = u ;
final Cartesian3D normal
final Cartesian3D p = h . toSpace ( Cartesian2D.ZERO ) ;
final Cartesian2D p = h . toSpace ( Cartesian1D.ZERO ) ;
Cartesian3D [] points
final List < Cartesian3D > vertices
Arrays . asList ( Cartesian3D.ZERO , Cartesian3D.PLUS_I , Cartesian3D.PLUS_J , Cartesian3D.PLUS_K )
try { ps . checkPoint ( Cartesian3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D u
for ( Cartesian2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Cartesian2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
Cartesian3D c = Cartesian3D.NEGATIVE_INFINITY ;
Cartesian3D c = Cartesian3D.POSITIVE_INFINITY ;
Cartesian3D c = Cartesian3D.NaN ;
final Cartesian2D point
final Cartesian2D location
final Cartesian2D . . . vertices
final Cartesian2D . . . vertices
final Cartesian3D u
final Cartesian3D u
final double x = ( ( Cartesian1D ) point ) . getX () ;
{ return new Line ( new Cartesian2D ( getNumber () , getNumber () ) , getNumber () , getNumber () ) ; }
{ return new OrientedPoint ( new Cartesian1D ( getNumber () ) , getBoolean () , getNumber () ) ; }
{ return new Circle ( new Cartesian3D ( getNumber () , getNumber () , getNumber () ) , getNumber () ) ; }
Cartesian1D v
Cartesian1D v = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D v = new Cartesian1D ( NUMBER_CONSTANT ) ;
{ Space space = new Cartesian1D ( NUMBER_CONSTANT ) . getSpace () ; Assert . assertEquals ( NUMBER_CONSTANT , space . getDimension () ) ; }
final double delta = ( ( Cartesian1D ) point ) . getX () - location . getX () ;
final Cartesian1D location
try { FieldVector3D . angle ( v1 , Cartesian3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
Cartesian2D oneTwo = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ new Cartesian2D ( v ) ; }
final Cartesian2D tmp = loop [ min ] ;
final Cartesian2D [] bLoop
final Cartesian3D axis
Cartesian3D axis
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Cartesian1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
final Cartesian2D p
final Cartesian2D p
final Cartesian2D p
final Cartesian2D p
final Cartesian2D p
{ centered [ i ] = values [ i ] - means [ i ] ; }
private final ContinuousSampler sampler = new MarsagliaLogNormalSampler ( rng , scale , shape ) ;
private final ContinuousSampler sampler = new GaussianSampler ( new MarsagliaNormalizedGaussianSampler ( rng ) , mean , standardDeviation ) ;
public Plot ( final List < Cartesian2D > points ) { this . points = points ; }
List < Cartesian2D > points = null ;
Cartesian3D p
rings = new ChineseRings ( new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
Vector1D actual = vector1DFormat . parse ( source ) ;
Vector1D actual = vector1DFormat . parse ( source ) ;
Vector1D actual = vector1DFormat . parse ( source ) ;
Vector1D expected = new Cartesian1D ( NUMBER_CONSTANT ) ;
{ final Vector1D p1 = ( Vector1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
final Vector2D p2 = ( Vector2D ) vector ;
Vector2D actual = vector2DFormat . parse ( source ) ;
Vector2D actual = vector2DFormat . parse ( source ) ;
Vector2D actual = vector2DFormat . parse ( source ) ;
Vector3D actual = vector3DFormat . parse ( source ) ;
Vector3D actual = vector3DFormat . parse ( source ) ;
Vector3D actual = vector3DFormat . parse ( source ) ;
int j = minor
Assert . assertFalse ( STRING_CONSTANT + level , new KolmogorovSmirnovTest () . kolmogorovSmirnovTest ( betaDistribution , observed ) < level ) ;
Assert . assertEquals ( test . exactP ( d , sampleSize1 , sampleSize2 , strict ) , test . monteCarloP ( d , sampleSize1 , sampleSize2 , strict , MONTE_CARLO_ITERATIONS , rng ) , tol )
final double tol = NUMBER_CONSTANT ;
final double tol = NUMBER_CONSTANT ;
Cartesian3D p
rings = new ChineseRings ( new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
final Cartesian2D [] vertices
final Collection < Cartesian2D > points
final Collection < Cartesian2D > points
final Collection < Cartesian2D > points
ConvexHull2D hull = generator . generate ( Collections . < Cartesian2D > emptyList () ) ;
final Cartesian3D p
final double angle = Cartesian3D . angle ( direction , line.direction ) ;
final Cartesian3D point
Cartesian3D v
{ new Cartesian3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D u
for ( Cartesian2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Cartesian2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
final Cartesian2D point
final Cartesian2D location
final Cartesian2D . . . vertices
final Cartesian2D . . . vertices
final double x = ( ( Cartesian1D ) point ) . getX () ;
try { FieldVector3D . angle ( v1 , Cartesian3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Cartesian1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
LogGamma . value ( z + NUMBER_CONSTANT ) - ( z + NUMBER_CONSTANT ) * FastMath . log ( z ) + z - HALF_LOG_2_PI
( sc * sc ) * FastMath . exp ( LogGamma . value ( NUMBER_CONSTANT + ( NUMBER_CONSTANT / sh ) ) )
return sc * FastMath . exp ( LogGamma . value ( NUMBER_CONSTANT + ( NUMBER_CONSTANT / sh ) ) ) ;
if ( x <= NUMBER_CONSTANT ) { ret = NUMBER_CONSTANT ; } else { ret = RegularizedGamma.P . value ( shape , x / scale ) ; }
final double expected = LogGamma . value ( i + NUMBER_CONSTANT ) ;
{ return RegularizedGamma.P . value ( mu , mu * x * x / omega ) ; }
NUMBER_CONSTANT * FastMath . pow ( mu , mu ) / ( Gamma . value ( mu ) * FastMath . pow ( omega , mu ) )
return LogGamma . value ( n + NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , Gamma . value ( t ) / s , tol ) ;
LogBeta . value ( nhalf , mhalf )
{ ret = NUMBER_CONSTANT - RegularizedBeta . value ( probabilityOfSuccess , x + NUMBER_CONSTANT , numberOfTrials - x ) ; }
if ( x >= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return RegularizedBeta . value ( x , alpha , beta ) ; }
{ ret = RegularizedBeta . value ( probabilityOfSuccess , numberOfSuccesses , x + NUMBER_CONSTANT ) ; }
return NUMBER_CONSTANT * ErfDifference . value ( v0 , v1 ) ;
return NUMBER_CONSTANT + NUMBER_CONSTANT * Erf . value ( dev / ( shape * SQRT2 ) ) ;
return NUMBER_CONSTANT * ErfDifference . value ( v0 , v1 ) ;
return mean + standardDeviation * SQRT2 * InverseErf . value ( NUMBER_CONSTANT * p - NUMBER_CONSTANT ) ;
return NUMBER_CONSTANT * Erfc . value ( - dev / ( standardDeviation * SQRT2 ) ) ;
final double t = InverseErfc . value ( p ) ;
double refDer = - Factorial . value ( n - NUMBER_CONSTANT ) / FastMath . pow ( - x , n ) ;
ArithmeticUtils . pow ( - NUMBER_CONSTANT , i ) * Factorial . value ( i ) / FastMath . pow ( x , i + NUMBER_CONSTANT )
BinomialCoefficientDouble . value ( n + m , m )
{ coeff [ i ] [ j ] = ( int ) BinomialCoefficient . value ( i , j ) ; }
final int numCombinations = ( int ) BinomialCoefficient . value ( arraySize , numberOfTrueValues ) ;
long expected = BinomialCoefficient . value ( i + j , i ) ;
{ term *= FastMath . pow ( delta [ k ] , orders [ k ] ) / FACTORIAL . value ( orders [ k ] ) ; }
double binomial = BinomialCoefficient . value ( v + i , i ) ;
Assert . assertEquals ( BinomialCoefficient . value ( n , NUMBER_CONSTANT ) , CombinatoricsUtils . stirlingS2 ( n , n - NUMBER_CONSTANT ) ) ;
return LinearCombination . value ( x1 , y1 , - x2 , y2 ) ;
{ final Cartesian2D v2 = ( Cartesian2D ) v ; return LinearCombination . value ( x , v2.x , y , v2.y ) ; }
final double n = FastMath . abs ( LinearCombination . value ( v1.x , v2.y , - v1.y , v2.x ) ) ;
out.value = LinearCombination . value ( a1 , b1.value , a2 , b2.value , a3 , b3.value ) ;
out.value = LinearCombination . value ( a1.value , b1.value , a2.value , b2.value , a3.value , b3.value ) ;
out.value = LinearCombination . value ( a1 , b1.value , a2 , b2.value ) ;
out.value = LinearCombination . value ( a1.value , b1.value , a2.value , b2.value ) ;
out.value = LinearCombination . value ( a , bDouble ) ;
out.value = LinearCombination . value ( aDouble , bDouble ) ;
{ return new Decimal64 ( LinearCombination . value ( a1 , b1.value , a2 , b2.value , a3 , b3.value ) ) ; }
{ return new Decimal64 ( LinearCombination . value ( a1.value , b1.value , a2.value , b2.value , a3.value , b3.value ) ) ; }
{ return new Decimal64 ( LinearCombination . value ( a1 , b1.value , a2 , b2.value ) ) ; }
{ return new Decimal64 ( LinearCombination . value ( a1.value , b1.value , a2.value , b2.value ) ) ; }
return new Decimal64 ( LinearCombination . value ( a , bDouble ) ) ;
return new Decimal64 ( LinearCombination . value ( aDouble , bDouble ) ) ;
packed [ i + NUMBER_CONSTANT ] = LinearCombination . value ( dv , partials ) ;
final double cos = CosAngle . value ( n , sampleDirection ) ;
final double diffNorm = SafeNorm . value ( diff ) ;
final double r = LinearCombination . value ( coeff [ i ] , pY ) ;
final double accurateValue = LinearCombination . value ( a , bDouble ) ;
final double accurateValue = LinearCombination . value ( aDouble , bDouble ) ;
{ return FastMath . abs ( LinearCombination . value ( sin , line.cos , - cos , line.sin ) ) < tolerance ; }
return LinearCombination . value ( sin , otherL.sin , cos , otherL.cos ) >= NUMBER_CONSTANT ;
{ return originOffset + ( LinearCombination . value ( cos , line.cos , sin , line.sin ) > NUMBER_CONSTANT ? - line.originOffset : line.originOffset ) ; }
checkRelative ( LinearCombination . value ( aD , bD ) , bF [ NUMBER_CONSTANT ] . linearCombination ( aD , bF ) ) ;
checkRelative ( LinearCombination . value ( aD , bD ) , aF [ NUMBER_CONSTANT ] . linearCombination ( aF , bF ) ) ;
final double lB = PlaneAngleRadians . normalize ( limits . get ( j ) , lA ) ;
final double syncedStart = PlaneAngleRadians . normalize ( a [ NUMBER_CONSTANT ] , reference ) - arc . getInf () ;
final double normalizedLower = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( lower ) ;
{ Assert . assertEquals ( a1 . getReal () , PlaneAngleRadians . normalize ( a2 , a1 . getReal () ) , NUMBER_CONSTANT ) ; }
final double arcRelativeStart = PlaneAngleRadians . normalize ( arc . getInf () , edgeStart + FastMath.PI ) - edgeStart ;
{ this ( PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( alpha ) , new Cartesian2D ( FastMath . cos ( alpha ) , FastMath . sin ( alpha ) ) ) ; }
final double normalizedPoint = PlaneAngleRadians . normalize ( point , middle ) ;
this . lower = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( lower ) ;
{ Assert . assertEquals ( a1 . getReal () , PlaneAngleRadians . normalize ( a2 , a1 . getReal () ) , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( p , PlaneAngleRadians . normalize ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , PlaneAngleRadians . normalize ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , PlaneAngleRadians . normalize ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , PlaneAngleRadians . normalize ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
this . angle = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( angle ) ;
this . angle = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( alpha ) ;
angle = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( line.angle ) ;
if ( knots.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION , knots.length , NUMBER_CONSTANT , true ) ; }
if ( knots.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION , knots.length , NUMBER_CONSTANT , true ) ; }
UnitSphereSampler g = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
UnitSphereSampler g = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
UnitSphereSampler rand
UnitSphereSampler g = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
UnitSphereSampler g = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
this ( new InterpolatingMicrosphere ( dimension , elements , maxDarkFraction , darkThreshold , background , new UnitSphereSampler ( dimension , RandomSource . create ( RandomSource.MT_64 ) ) ) , exponent , sharedSphere , noInterpolationTolerance ) ;
UnitSphereSampler sphRandom = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
{ sampler = new MarsagliaNormalizedGaussianSampler ( generator ) ; }
private final ContinuousSampler sampler = new LogNormalSampler ( new ZigguratNormalizedGaussianSampler ( rng ) , scale , shape ) ;
final ContinuousDistribution.Sampler random
{ return randomize ( new UniformContinuousDistribution ( min , max ) . createSampler ( rng ) , function ( new Constant ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
ContinuousDistribution.Sampler sampler
ContinuousDistribution distribution
ContinuousDistribution distribution
ContinuousDistribution distribution
ContinuousDistribution distribution
final NormalDistribution normalDistribution = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final ContinuousDistribution expectedDistribution
final NormalDistribution normalDistribution = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
DiscreteDistribution.Sampler sampler
final NormalDistribution normalDistribution = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
this . random = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . createSampler ( rng ) ;
final ContinuousDistribution kernel = findKernel ( lower , upper ) ;
final ContinuousDistribution kernel = findKernel ( lower , upper ) ;
tP = new UniformContinuousDistribution ( NUMBER_CONSTANT , MathUtils.TWO_PI ) . createSampler ( rng ) ;
x = new UniformContinuousDistribution ( lo , hi ) . createSampler ( rng ) ;
@ Override public double getMean () { return NUMBER_CONSTANT ; }
final double offset = plane . getOffset ( point ) ;
{ Assert . assertEquals ( x , v . getX () , TEST_TOLERANCE ) ; }
Assert . assertFalse ( pt . isDirect () ) ;
Assert . assertTrue ( copy . isDirect () ) ;
Assert . assertTrue ( pt . isDirect () ) ;
assertContains ( result , expected , tolerance ) ;
TestUtils . assertContains ( result , expected , tolerance ) ;
for ( float d : imaginary ) { c [ index ] = Complex . ofCartesian ( NUMBER_CONSTANT , d ) ; index ++ ; }
for ( double d : imaginary ) { c [ index ] = Complex . ofCartesian ( NUMBER_CONSTANT , d ) ; index ++ ; }
for ( float d : real ) { c [ index ] = Complex . ofCartesian ( d ) ; index ++ ; }
for ( double d : real ) { c [ index ] = Complex . ofCartesian ( d ) ; index ++ ; }
{ return Complex . ofCartesian ( NUMBER_CONSTANT , imaginary [ index ] ) ; }
{ return Complex . ofCartesian ( NUMBER_CONSTANT , imaginary [ index ] ) ; }
{ return Complex . ofCartesian ( real [ index ] ) ; }
{ return Complex . ofCartesian ( real [ index ] ) ; }
y [ i ] = Complex . ofCartesian ( yr , yi ) ;
data [ i ] = Complex . ofCartesian ( re , im ) ;
Object expected = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = Complex . ofCartesian ( Double.NEGATIVE_INFINITY , Double.NEGATIVE_INFINITY ) ;
Complex expected = Complex . ofCartesian ( Double.POSITIVE_INFINITY , Double.POSITIVE_INFINITY ) ;
Complex expected = Complex . ofCartesian ( Double.NaN , Double.NaN ) ;
Complex expected = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( Double.NEGATIVE_INFINITY , Double.NEGATIVE_INFINITY ) ;
Complex c = Complex . ofCartesian ( Double.POSITIVE_INFINITY , Double.POSITIVE_INFINITY ) ;
Complex c = Complex . ofCartesian ( Double.NaN , Double.NaN ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
for ( Complex cc : c ) { TestUtils . assertEquals ( Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , cc , NUMBER_CONSTANT ) ; }
for ( float d : real ) { c [ index ] = Complex . ofReal ( d ) ; index ++ ; }
for ( double d : real ) { c [ index ] = Complex . ofReal ( d ) ; index ++ ; }
{ return Complex . ofReal ( real [ index ] ) ; }
{ return Complex . ofReal ( real [ index ] ) ; }
x [ i ] = Complex . ofReal ( f . value ( t ) ) ;
{ final int value = count ; count += increment ; return value ; }
{ new SimpsonIntegrator ( NUMBER_CONSTANT , SimpsonIntegrator.SIMPSON_MAX_ITERATIONS_COUNT + NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
expr . setLineno ( expr . getLineno () + templateLineno ) ;
if ( definitionNodes . contains ( useSite ) ) { return null ; }
FeatureSet features = ast . getFeatures ( compiler ) ;
if ( tags == FALSY_MASK ) { return builder . append ( STRING_CONSTANT ) ; } else { return builder . append ( STRING_CONSTANT ) . append ( tags ) ; }
output.compiledCode = writeOutput ( compiler , flags.outputWrapper ) ;
options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.OFF ) ;
resultPair = analyzeCastFwd ( expr , inEnv , specializedType ) ;
options . setWarningLevel ( DiagnosticGroups.MISSING_PROVIDE , CheckLevel.WARNING ) ;
resultPair = analyzeCastFwd ( expr , inEnv ) ;
resultPair = analyzeCastFwd ( expr , inEnv , specializedType ) ;
public void testEs6ONoEs6 () { allowExternsChanges ( true ) ; testSame ( STRING_CONSTANT ) ; }
options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.OFF ) ;
public final Node getNext () { return next ; }
public final Token getToken () { return token ; }
this . commonTypes . STRING . isSubtypeOf ( this ) && this . commonTypes . getNumberInstance () . mayHaveProp ( pname )
if ( type == null && isConstant ) { type = this . commonTypes . UNKNOWN ; }
if ( isUnknown () ) { return this . commonTypes . UNKNOWN ; }
if ( isBottom () || isUnknown () || hasTruthyMask () ) { return this . commonTypes . UNKNOWN ; }
if ( this . isUnknown () ) { return this . commonTypes . TRUTHY ; }
{ globalThisType = this . commonTypes . TOP_OBJECT . withLoose () ; }
if ( type == null && isConstant ) { type = this . commonTypes . UNKNOWN ; }
return scope . getCommonTypes () . UNKNOWN ;
@ Deprecated public AssertionFunctionSpec ( String functionName ) { this ( functionName , null ) ; }
{ Preconditions . checkState ( function . isFunction () ) ; expandedDefinitions . add ( functionSideEffectMap . get ( function ) ) ; }
n . hasOneChild () && t . inGlobalScope ()
initializer . isVar () && initializer . hasOneChild ()
if ( n . hasOneChild () && NodeUtil . isStatement ( n ) ) { processName ( n . getFirstChild () , n ) ; }
if ( ! currentStatement . hasChildren () ) { return; }
typeNode != null && typeNode . isString ()
n . hasOneChild () && parent == googScopeBlock
if ( varNode . hasMoreThanOneChild () && varType != null ) { warnings . add ( JSError . make ( varNode , ONE_TYPE_FOR_MANY_VARS ) ) ; }
if ( inputId == null ) { setInputId ( NodeUtil . getInputId ( node ) , getSourceName ( node ) ) ; }
if ( inputId == null ) { setInputId ( NodeUtil . getInputId ( node ) , getSourceName ( node ) ) ; }
String name = getQualifiedName ( node ) ;
options.rewritePolyfills = flags.rewritePolyfills && options . getLanguageIn () . isEs6OrHigher () ;
JSType t = getTypeFromComment ( jsdoc , registry , typeParameters ) ;
builder . append ( paramType . toNonNullString ( forAnnotations ) ) . append ( STRING_CONSTANT ) ;
builder . append ( STRING_CONSTANT ) . append ( paramType . toNonNullString ( forAnnotations ) ) ;
{ b . append ( p . getJSType () . toNonNullString ( forAnnotations ) ) ; }
b . append ( call.returnType . toNonNullString ( forAnnotations ) ) ;
sb . append ( getPropertyType ( property ) . toNonNullString ( forAnnotations ) ) ;
if ( n . isFromExterns () ) { this . recordPropertyName . apply ( propName ) ; }
recordPropertyName ( getProp . getLastChild () . getString () , getProp ) ;
if ( NodeUtil . isPropertyTest ( compiler , n ) || isPropertyAbsentTest ( n ) ) { recordPropertyName ( n . getLastChild () . getString () , n ) ; }
recordPropertyName ( pname , qnameNode ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
compiler . getOptions () . setUseTypesForLocalOptimization ( true ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
if ( ! allDefinitionsEquivalent ( singleSiteDefinitions ) ) { return false ; }
NodeTraversal . traverseChangedFunctions ( compiler , new FunctionVisitor ( blacklistedPropNames ) ) ;
@ Override void endCaseBody () { super . endCaseBody () ; indent -- ; }
assertThat ( compiler . getErrors () ) . isEmpty () ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
options . setLanguage ( LanguageMode.ECMASCRIPT8 ) ;
JSType objectWithBadKey = findObjectWithNonStringifiableKey ( realType , new HashSet < JSType > () ) ;
Config config = findMatching ( name , n . getSourceFileName () ) ;
if ( currentScript.defaultExportLocalName != null ) { assignNode . getParent () . detach () ; return; }
boolean nameIsExported = name . equals ( currentScript.defaultExportLocalName ) ;
TypeI jsType
TypeI jsType
public J2clCheckPassTest () { super ( DEFAULT_EXTERNS ) ; enableTypeCheck () ; }
void setMask ( int mask ) { bitmask |= mask ; }
if ( info . isNoSideEffects () ) {} else { sideEffectInfo . setTaintsGlobalState () ; }
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
( config.parseTypeSyntax && peek ( TokenType.OPEN_PAREN ) ) || peek ( TokenType.OPEN_ANGLE )
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
JSDocInfo info = NodeUtil . getBestJSDocInfo ( node ) ;
FunctionInformation sideEffectInfo = new FunctionInformation () ;
FunctionInformation representativeNode = new FunctionInformation () ;
if ( modulePath == null ) { t . makeError ( typeNode , COMMON_JS_MODULE_LOAD_ERROR , moduleName ) ; return; }
if ( modulePath == null ) { compiler . report ( t . makeError ( require , COMMON_JS_MODULE_LOAD_ERROR , requireName ) ) ; return; }
assertPasses ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String treeDiff = node . checkTreeEquals ( actual () ) ;
public ImmutableMap < String , Stats > getStats () { calcTotalStats () ; return this . summary ; }
maybeWarnForInvalidDestructuring ( t , lhs . getParent () , legacyNamespace ) ;
{ options . setWarningLevel ( DiagnosticGroups.MISSING_OVERRIDE , value ? CheckLevel.WARNING : CheckLevel.OFF ) ; }
this . output . print ( Joiner . on ( STRING_CONSTANT ) . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
NodeTraversal . traverseEs6 ( compiler , scriptRoot , new Es6RenameReferences ( renameTable ) ) ;
NodeTraversal . traverseEs6 ( compiler , root , new Es6RenameReferences ( renameTable ) ) ;
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode ) ;
this . functionSideEffectMap = ArrayListMultimap . create () ;
return IR . exprResult ( assign ) . useSourceInfoIfMissingFromForTree ( var ) ;
{ if ( Matchers . googRequire () . matches ( child . getFirstChild () , metadata ) ) { return true ; } }
Matchers . googRequire () . matches ( child . getFirstChild () , metadata )
{ eatPredefinedString ( PredefinedName.FROM ) ; moduleSpecifier = ( LiteralToken ) eat ( TokenType.STRING ) ; }
public void testRequireUseStrict1 () { configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
testWarning ( STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT ) ;
testWarning ( STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
madeChange = true ;
{ parent . removeChild ( node ) ; madeChange = true ; }
Pattern argPattern = Pattern . compile ( STRING_CONSTANT , Pattern.DOTALL ) ;
new ByteArrayInputStream ( inputString . getBytes ( UTF_8 ) )
new ByteArrayInputStream ( inputString . getBytes ( UTF_8 ) )
new ByteArrayInputStream ( inputString . getBytes ( UTF_8 ) )
new ByteArrayInputStream ( inputString . getBytes ( UTF_8 ) )
inputSourceMaps . put ( jsonFile . getPath () , new SourceMapInput ( sourceMap ) ) ;
{ if ( child != n . getFirstChild () ) { cc . listSeparator () ; } add ( child ) ; }
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; break; } }
final Node extendsClause = n . getSecondChild () ;
{ test ( createCompilerOptions () , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; } }
NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.INCOMPATIBLE_STRICT_COMPARISON ) ;
builder . setTagAsStrict ( firstOutput && options . isEmitUseStrict () && options . getLanguageOut () . isStrict () ) ;
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; break; } }
com.google.javascript.jscomp.parsing.parser.Parser.Config es6config = newParserConfig ( config ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , WARNING ) ;
@ Override protected CodingConvention getCodingConvention () { return codingConvention ; }
{ super . setUp () ; codingConvention = new GoogleCodingConvention () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT8 ) ; }
Config config = ParserRunner . createConfig ( mode , Config.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , Config.RunMode.KEEP_GOING , null , true , StrictMode.SLOPPY ) ;
if ( config.languageMode != LanguageMode.TYPESCRIPT ) { errorReporter . warning ( STRING_CONSTANT + feature , sourceName , lineno ( node ) , charno ( node ) ) ; }
builder . setTagAsStrict ( firstOutput && shouldEmitUseStrict () ) ;
if ( expectStrictModeInput () ) { options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.ERROR ) ; }
options . setEmitUseStrict ( flags.emitUseStrict ) ;
public void testDoWhileLoopBranch ( ) throws Exception { compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
{ googRequireNode = IR . constNode ( IR . name ( shortName ) , googRequireNode ) ; }
return getConstJSDoc ( oldJSDoc , expr ) ;
if ( ! hasConstructor ) { addSyntheticConstructor ( t , n ) ; }
! NodeUtil . isCallTo ( value , STRING_CONSTANT ) && ! ( info != null && info . isConstructorOrInterface () )
if ( NodeUtil . isCallTo ( destructuringLhsNode . getLastChild () , STRING_CONSTANT ) ) { return; }
var != null && var . getInitialValue () != null && ! NodeUtil . isCallTo ( var . getInitialValue () , STRING_CONSTANT )
if ( aliasVarNodeRhs == null || ! NodeUtil . isCallTo ( aliasVarNodeRhs , STRING_CONSTANT ) ) { t . report ( call , INVALID_GET_ALIAS ) ; return; }
String exportedNamespace = currentScript . getExportedNamespace () ;
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) ;
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) ;
if ( isExportPropertyAssignment ( n ) ) { recordExportsPropertyAssignment ( t , n ) ; }
IR . call ( IR . getprop ( IR . superNode () , IR . string ( STRING_CONSTANT ) ) , IR . thisNode () , IR . name ( STRING_CONSTANT ) )
{ typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; typeCheck ( STRING_CONSTANT , JSTypeCreatorFromJSDoc.INHERITANCE_CYCLE , NewTypeInference.UNDEFINED_SUPER_CLASS ) ; }
assertNull ( LanguageMode . fromString ( STRING_CONSTANT ) ) ;
sourceMap . appendTo ( out , outputFile . getName () ) ;
{ if ( n . isSuper () ) { visitSuper ( t , n , parent ) ; } }
add ( last ) ;
assertValidOrderForChecks ( checks ) ;
assertValidOrderForChecks ( passes ) ;
CompilerPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeFoldConstants ( late , useTypes ) ) ;
if ( ! ( rval >= NUMBER_CONSTANT && rval < NUMBER_CONSTANT ) ) { return n ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , EARLY_REFERENCE ) ; }
declaresFunctionOrClass ( n )
public DeclaredTypeRegistry getScope () { return this . scope ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , VariableReferenceCheck.EARLY_REFERENCE ) ; }
if ( isCallInLoop ) { fixUnitializedVarDeclarations ( newBlock , newBlock ) ; }
{ super . setUp () ; codingConvention = new GoogleCodingConvention () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ; }
if ( ! targetType . getGreatestSubtype ( type ) . isBottom () ) { unusedMethodPolyfills . remove ( method ) ; }
new PeepholeReplaceKnownMethods ( late , useTypesForOptimization )
new PeepholeReplaceKnownMethods ( late , false )
new PeepholeReplaceKnownMethods ( late , useTypesForOptimization )
return this . commonTypes . getEmptyObjectLiteral () ;
public boolean isBuiltinObject () { return this . rawType . isBuiltinObject () ; }
boolean isClassy () { return ! isFunction () && ! isBuiltinObject () && ! isLiteralObject () ; }
if ( this . equals ( proto ) ) { Preconditions . checkState ( this . isUnknownObject () , STRING_CONSTANT , this ) ; return null ; }
return isUnknown () || ( isUnknownObject () && isLoose () ) || ( ft != null && ft . isTopFunction () ) ;
if ( this == other || other . isBuiltinObject () ) { return true ; }
if ( ! isBuiltinObject () ) { this . subtypes . add ( subtype ) ; }
return nt . isBuiltinObject () || nt . isPropDefinedOnSubtype ( pname ) ;
Preconditions . checkArgument ( name . equals ( JSTypes.OBJLIT_CLASS_NAME ) || name . equals ( STRING_CONSTANT ) || name . equals ( STRING_CONSTANT ) , STRING_CONSTANT , name ) ;
public RemoveUnusedPolyfillsTest () { super ( EXTERNS ) ; }
{ result = Ascii . toUpperCase ( result . toString () ) ; }
{ CompilerOptions.J2clPassMode j2clPassMode = CompilerOptions.J2clPassMode . valueOf ( Ascii . toUpperCase ( flags.j2clPassMode ) ) ; options . setJ2clPass ( j2clPassMode ) ; }
String lowerParam = Ascii . toLowerCase ( param ) ;
compilationLevelParsed = COMPILATION_LEVEL_MAP . get ( Ascii . toUpperCase ( compilationLevel ) ) ;
return Ascii . toUpperCase ( Long . toString ( nonnegativeHash , NUMBER_CONSTANT ) ) ;
addParserWarning ( STRING_CONSTANT , Ascii . toLowerCase ( visibility . toString () ) ) ;
String canonicalizedName = Ascii . toUpperCase ( value . trim () ) . replaceFirst ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ Node parent = n . getParent () ; return NodeUtil . wasCasted ( n ) || isAssertionCall ( parent ) ; }
! t . isSubtypeOf ( this . commonTypes . getTopObject () ) && ( ! t . hasTypeVariable () || t . hasScalar () )
return getTopObject () ;
JSType objLitType = commonTypes . getEmptyObjectLiteral () ;
{ globalThisType = this . commonTypes . getTopObject () . withLoose () ; }
this == other || other.ns != null || ! other.nominalType . equals ( this . commonTypes . getObjectType () )
boolean isInhabitable () { return this != this . commonTypes . getBottomObject () ; }
objType != null && ! objType.nominalType . isClassy () && ! objType . isLoose ()
if ( nameNode == null ) { return; }
{ return false ; }
if ( name != null ) { this . definitionNodeByDefinitionSite . remove ( node ) ; this . nameDefinitionMultimap . remove ( name , def ) ; }
callNode . replaceWith ( replacement . useSourceInfoIfMissingFrom ( callNode ) ) ;
{ oldRoot . replaceWith ( newRoot ) ; }
n . replaceWith ( stringNode ) ;
callNode . replaceWith ( objNode ) ;
callNode . replaceWith ( objNode ) ;
{ forCondition . replaceWith ( IR . empty () ) ; reportCodeChange () ; }
n . replaceWith ( whileNode ) ;
condition . replaceWith ( replacementConditionNode ) ;
n . replaceWith ( replacement ) ;
n . replaceWith ( caseBlock . detach () ) ;
{ if ( result . getParent () != null ) { result . detach () ; } n . replaceWith ( result ) ; }
{ subtree . replaceWith ( right . detach () ) ; reportCodeChange () ; return right ; }
node . replaceWith ( replacement ) ;
n . replaceWith ( newNode ) ;
subtree . replaceWith ( replacement ) ;
subtree . replaceWith ( replacement ) ;
n . replaceWith ( placeholder ) ;
n . replaceWith ( replacement ) ;
n . replaceWith ( replacement ) ;
pattern . replaceWith ( IR . name ( tempVarName ) ) ;
patternParam . replaceWith ( newParam ) ;
first . replaceWith ( name ) ;
callNode . replaceWith ( objNode ) ;
assignNode . replaceWith ( rhs ) ;
n . replaceWith ( call ) ;
statement . replaceWith ( newStatement ) ;
loadModuleStatement . replaceWith ( moduleBlockNode ) ;
n . replaceWith ( legacyQname ) ;
exprResultNode . replaceWith ( exportsObjectCreationNode ) ;
call . replaceWith ( exportedNamespaceName ) ;
n . replaceWith ( replacement ) ;
n . replaceWith ( elem ) ;
n . replaceWith ( elem ) ;
n . replaceWith ( lengthNode ) ;
n . replaceWith ( newNode ) ;
n . replaceWith ( newNumber ) ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; reportCodeChange () ; return result ; }
n . replaceWith ( newStringNode ) ;
n . replaceWith ( replacement ) ;
n . replaceWith ( newNode ) ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; reportCodeChange () ; return replacementNode ; }
originalTypeofNode . replaceWith ( newNode ) ;
n . replaceWith ( replacement ) ;
obj . replaceWith ( result ) ;
if ( replaceParent ) { parent . replaceWith ( replacement ) ; } else { parent . replaceChild ( n , replacement ) ; }
candidateDefinition . replaceWith ( varNode ) ;
parent . replaceWith ( replacement ) ;
if ( enclosing != null && enclosing . isGeneratorFunction () ) { n . replaceWith ( IR . name ( GENERATOR_THIS ) ) ; }
{ original . replaceWith ( replacement ) ; return replacement ; }
enclosingCall . replaceWith ( baseCall ) ;
{ Node parent = n . getParent () ; parent . replaceWith ( fncBlock ) ; }
n . replaceWith ( replacement ) ;
callNode . replaceWith ( replacement ) ;
superCall . replaceWith ( superErrorExpr ) ;
{ newValue . useSourceInfoIfMissingFromForTree ( msgNode ) ; msgNode . replaceWith ( newValue ) ; compiler . reportCodeChange () ; }
callNode . replaceWith ( replacementNode . detach () ) ;
target . replaceWith ( value . cloneTree () ) ;
{ aliasReference . replaceWith ( replacement ) ; }
expressionWithScopeCall . replaceWith ( scopeClosureBlock ) ;
{ parent . replaceWith ( IR . empty () ) ; }
n . replaceWith ( call ) ;
n . replaceWith ( not ) ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
n . replaceWith ( replacement ) ;
member . replaceWith ( memberVariable ) ;
n . replaceWith ( attachTypeExpr ) ;
msgNode . replaceWith ( newValue ) ;
n . replaceWith ( var ) ;
grandparent . replaceWith ( functionNode ) ;
public void testNgInjectSetVisibility ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ;
Node scopeMethodCall = findScopeMethodCall ( t . getScopeRoot () ) ;
Node n = t . getScopeRoot () ;
return list . isEmpty () ? null : list ;
return list ;
public abstract Node getRoot ( ) ;
String getContent ( ) ;
String getName ( ) ;
{ return Strings . nullToEmpty ( sourceMapCache . get ( path ) ) ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate , CacheBuilder . newBuilder () ) ; }
{ return STRING_CONSTANT ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate ) ; }
String output = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
if ( ! n . hasXChildren ( NUMBER_CONSTANT ) ) { return n ; }
if ( castType . restrictByNotNullOrUndefined () . isSubtype ( exprType ) || expr . isObjectLit () ) { expr . setJSType ( castType ) ; }
{ return Strings . nullToEmpty ( sourceMapCache . get ( path ) ) ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate , CacheBuilder . newBuilder () ) ; }
options . setLanguageOut ( LanguageMode.ECMASCRIPT5 ) ;
return new RawNominalType ( commonTypes , defSite , name , typeParameters , Kind.RECORD , objKind , false ) ;
return new RawNominalType ( commonTypes , defSite , name , typeParameters , Kind.INTERFACE , objKind , false ) ;
ImmutableCollection < ExportInfo > exports
if ( isUnknownType () ) { return true ; }
return list . isEmpty () ? null : list ;
if ( ! hasConstructor ) { addSyntheticConstructor ( n ) ; }
IR . comma ( IR . comma ( IR . comma ( getTmpError , copyMessage ) , setStack ) , IR . thisNode () ) . useSourceInfoIfMissingFromForTree ( superCall )
{ compiler . report ( JSError . make ( constructor , CANNOT_CONVERT , STRING_CONSTANT + superClassQName ) ) ; }
this . ancestorInterfaces = new HashMap <> () ;
script . addChildToFront ( googProvide . useSourceInfoIfMissingFromForTree ( script ) ) ;
require . useSourceInfoIfMissingFromForTree ( importDecl ) ;
newChild . useSourceInfoWithoutLengthIfMissingFrom ( child ) ;
{ node . useSourceInfoWithoutLengthIfMissingFromForTree ( basisNode ) ; node . setOriginalName ( originalName ) ; }
newNode . useSourceInfoWithoutLengthIfMissingFromForTree ( sourceInfoNode ) ;
expr . useSourceInfoWithoutLengthIfMissingFromForTree ( parent ) ;
newChild . useSourceInfoIfMissingFrom ( child ) ;
Node name
if ( strictMismatch ) { mismatches . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordImplicitInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( caseType , switchType ) ; }
if ( strictMismatch ) { implicitStructuralInterfaceUses . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordStructuralInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
{ recordStructuralInterfaceUses ( caseType , switchType ) ; }
@ Override Iterable < TypeMismatch > getImplicitInterfaceUses () { return getTypeValidator () . getImplicitInterfaceUses () ; }
if ( strictMismatch ) { implicitInterfaceUses . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordImplicitInterfaceUses ( n , argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( n , rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; }
if ( options . getTracerMode () . isOn () && tracker != null ) { tracker . recordPassStop ( passName , result ) ; }
if ( options . getTracerMode () . isOn () && tracker != null ) { tracker . recordPassStart ( passName , true ) ; }
{ return compilerExecutor . runInCompilerThread ( callable , options != null && options . getTracerMode () . isOn () ) ; }
options . setTracerMode ( config.tracerMode ) ;
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExport5 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
for ( Reference ref : refCollection ) { processReference ( collector , ref , info , v ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
Map < String , DependencyInfo > parsedFiles = new LinkedHashMap <> () ;
Map < String , DependencyInfo > depsFiles = new LinkedHashMap <> () ;
Map < String , DependencyInfo > providesMap = new LinkedHashMap <> () ;
( ! allowLoosePropertyAccessOnNode ( n ) || objectType . isStruct () )
{ if ( canCreate ) { return createName ( name ) ; } return allNames . get ( name ) ; }
if ( ! Double . isNaN ( d ) ) { cc . addNumber ( d , n ) ; } else { addJsString ( n ) ; }
assertThat ( result.sourceMap ) . isEmpty () ;
catch ( IOException e ) { compiler . report ( JSError . make ( REPORT_PATH_IO_ERROR , reportPath , e . getMessage () ) ) ; }
catch ( IOException e ) { compiler . report ( JSError . make ( REPORT_PATH_IO_ERROR , reportPath , e . getMessage () ) ) ; }
Preconditions . checkState ( current . isGetProp () , STRING_CONSTANT , current ) ;
static boolean isEnhancedFor ( Node n ) { return n . isForOf () || n . isForIn () ; }
return newNode ( Token.FOR_IN , initializer , transform ( loopNode.collection ) , transformBlock ( loopNode.body ) ) ;
return new Node ( Token.FOR_IN , target , cond , body ) ;
validateNodeType ( Token.ROOT , n ) ;
validateNodeType ( Token.ROOT , n ) ;
TranspileResult result = transpiler . transpile ( Paths . get ( path ) , s ) ;
Path path
Path path
BaseTranspiler.CompileResult result = compiler . compile ( SOURCE_JS , STRING_CONSTANT ) ;
BaseTranspiler.CompileResult result = compiler . compile ( SOURCE_JS , STRING_CONSTANT ) ;
Path path
Path path
TranspileResult transpile ( Path path , String code ) ;
Path path
! n . isForIn ()
parent . isFor () && ! parent . isForIn ()
if ( n . isForIn () ) { return n ; }
if ( ! node . isForIn () ) { tryJoinForCondition ( node ) ; tryMinimizeCondition ( NodeUtil . getConditionExpression ( node ) ) ; }
( parent . isForIn () )
c . isForIn ()
parent . isFor () && ! parent . isForIn () && NodeUtil . getConditionExpression ( parent ) != n
if ( ! n . isForIn () ) { tryRemoveAssignment ( t , NodeUtil . getConditionExpression ( n ) , state ) ; }
boolean lhsOfForInLoop = gp . isForIn () && gp . getFirstFirstChild () == declNode ;
Preconditions . checkState ( expr . isForIn () ) ;
Preconditions . checkState ( expr . getParent () . isForIn () ) ;
Preconditions . checkState ( lvalue . getParent () . isForIn () ) ;
n . isForIn ()
Node expr = n . isForIn () ? n . getFirstChild () : NodeUtil . getConditionExpression ( n ) ;
loopNode . isVanillaFor ()
srcDeclaration . isConst () && ! ( srcParent . isForIn () && srcDeclaration == srcParent . getFirstChild () )
if ( ! parent . isForIn () && child == parent . getFirstChild () ) { return parent ; }
parent . isForIn ()
if ( ! parent . isForIn () ) { return ( parent . getSecondChild () == expr ) ; }
( parent . isForIn () && parent . getFirstChild () == n )
return n . isForIn () ? null : n . getSecondChild () ;
( parent . isForIn () && parent . getFirstChild () == n )
if ( parent . isForIn () ) { return; }
if ( enclosingFunc == null || ! enclosingFunc . isGeneratorFunction () || n . isForIn () ) { return; }
if ( currentStatement . isForIn () ) { visitForIn () ; return false ; }
nextSibling . isForIn ()
source . isForIn ()
if ( parent . isForIn () ) { return n != parent . getFirstChild () ; } else { return NodeUtil . getConditionExpression ( parent ) != n ; }
parent . isForIn ()
! n . isForIn ()
! n . isForIn ()
if ( parent . isForIn () && parent . getFirstChild () == n ) { return false ; }
n . isForIn ()
! n . isForIn ()
var . getParentNode () . isVar () && ! var . getParentNode () . getParent () . isForIn ()
if ( n . isForOf () || n . isForIn () ) { return n . getSecondChild () ; }
if ( parent . isForIn () ) { return parent ; } else { return parent . getSecondChild () . getNext () ; }
if ( cur . isVanillaFor () ) { iter = cur . getChildAtIndex ( NUMBER_CONSTANT ) ; }
forNode . isForIn () || forNode . isForOf ()
control . isForIn ()
n . isForIn ()
n . isAssign () && ! ( parent . isVanillaFor () || parent . isForIn () )
n . isAssign () && ( parent . isExprResult () || parent . isVanillaFor () || parent . isReturn () )
grandparent . isForIn ()
( declaration . getParent () . isVar () && ! NodeUtil . isLoopStructure ( declaration . getGrandparent () ) )
Node initializer = NodeUtil . isAnyFor ( n ) ? n . getFirstChild () : IR . empty () ;
Preconditions . checkState ( ! NodeUtil . isLoopStructure ( parent ) ) ;
currentStatement . isVanillaFor ()
nextSibling . isVanillaFor () && nextSibling . getFirstChild () . isEmpty ()
if ( ! parent . isVanillaFor () ) { assign = NodeUtil . newExpr ( assign ) ; }
{ appendFieldStart ( out , name , false ) ; }
Preconditions . checkNotNull ( scope , STRING_CONSTANT , t . getScopeRoot () ) ;
parent . isNormalBlock () || NodeUtil . isAnyFor ( parent ) || parent . isScript () || parent . isModuleBody () || parent . isLabel ()
boolean scanInnerBlocks = n . isRoot () || NodeUtil . isFunctionBlock ( n ) || n . isModuleBody () ;
TypedScope s = new TypedScopeCreator ( compiler , CodingConventions . getDefault () ) . createInitialScope ( new Node ( Token.ROOT ) ) ;
boolean preserveBlock = n . isNormalBlock () && ! n . isSyntheticBlock () ;
testMissingRequireStrict ( js , STRING_CONSTANT ) ;
testMissingRequireStrict ( js , STRING_CONSTANT ) ;
testMissingRequireStrict ( js , STRING_CONSTANT ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckRequiresForConstructors ( compiler , mode ) ; }
if ( this . optimizePropertyIndex && isObjectLiteralThatCanBeSkipped ( type ) ) { type = getSentinelObjectLiteral () ; }
new PeepholeMinimizeConditions ( late , useTypesForOptimization , options.assumeAccurateNullUndefinedTypes )
new PeepholeMinimizeConditions ( late , false , false )
new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false , false ) , new PeepholeFoldConstants ( true , false ) )
new PeepholeMinimizeConditions ( late , false , false )
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeMinimizeConditions ( late , useTypes , assumeAccurateNullUndefinedTypes ) ) ;
getInvalidationsErrors () . get ( t )
throw new RuntimeException ( cause ) ;
try { TextFormat . merge ( textProto , builder ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; }
if ( exception [ NUMBER_CONSTANT ] != null ) { throw new RuntimeException ( exception [ NUMBER_CONSTANT ] ) ; }
{ try { initialize ( metadata . getCompiler () ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableUnusedLocalAssignmentCheck = false ; }
{ CompilerOptions options = super . getOptions () ; if ( enableUnusedLocalAssignmentCheck ) { options . setWarningLevel ( DiagnosticGroups.UNUSED_LOCAL_VARIABLE , CheckLevel.WARNING ) ; } return options ; }
invalidationMap . get ( t )
private String getNewName () { return paramPrefix + uniqueId ++ ; }
{ this . compiler = Preconditions . checkNotNull ( compiler ) ; this . paramPrefix = Preconditions . checkNotNull ( paramPrefix ) ; }
new PeepholeMinimizeConditions ( late , useTypesForOptimization )
new PeepholeMinimizeConditions ( late , false )
new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false ) , new PeepholeFoldConstants ( true , false ) )
new PeepholeMinimizeConditions ( late , false )
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeMinimizeConditions ( late , useTypes ) ) ;
( new NodeTraversal ( compiler , this , scopeCreator ) ) . traverseAtScope ( scope ) ;
{ addLibrary ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; setLanguage ( ES6 , ES5 ) ; testDoesNotInject ( STRING_CONSTANT ) ; }
{ addLibrary ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; setLanguage ( ES6 , ES5 ) ; testDoesNotInject ( STRING_CONSTANT ) ; }
validateBlock ( n . getLastChild () ) ;
{ validateNodeType ( Token.DEFAULT_CASE , n ) ; validateChildCount ( n ) ; validateBlock ( n . getLastChild () ) ; }
block . setIsAddedBlock ( true ) ;
block . setIsAddedBlock ( true ) ;
{ Preconditions . checkState ( body . isBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
body . setIsAddedBlock ( true ) ;
public void testNgInjectToArrowFunctions () { testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; }
testSame ( STRING_CONSTANT ) ;
public void testEmpty () { this . instrumentationPb = STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
testSame ( fullJsCode ) ;
{ foldSame ( STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; foldSame ( STRING_CONSTANT ) ; }
public void testDivision () { foldSame ( STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
{ testSame ( STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ testLocal ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testSameLocal ( STRING_CONSTANT ) ; }
testSameLocal ( STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
public void testSwitchCase () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveDo () { testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
public void testReturnType () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testRestParameter () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
testSame ( STRING_CONSTANT ) ;
testSameWithInversion ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
testSame ( js ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( src ) ;
public void testForIn () { inFunction ( STRING_CONSTANT ) ; inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ if ( ! isClinitMethod ( node ) ) { return; } trySubstituteEmptyFunction ( node ) ; }
{ tryRemovingClinit ( node , parent ) ; if ( isNewControlBranch ( parent ) ) { clinitsCalledAtBranch = clinitsCalledAtBranch.parent ; } }
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode , definitionProvider , representativeNodesByName ) ;
this . functionSideEffectMap = new LinkedHashMap <> () ;
PropertyType pt = getPropTypeHelper ( jsdoc , getProp , rawType ) ;
{ lint ( Paths . get ( filename ) , new Compiler ( System.out ) ) ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , EARLY_REFERENCE ) ; }
testSame ( STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
options . setProtectHiddenSideEffects ( true ) ;
NodeTraversal outOfBandTraversal = new NodeTraversal ( compiler , this , scopeCreator ) ;
{ Preconditions . checkState ( mayBeExpression ( expr ) , expr ) ; return new Node ( Token.EXPR_RESULT , expr ) ; }
{ Node root = compiler . parseTestCode ( js ) ; assertThat ( compiler . getErrors () ) . isEmpty () ; return root ; }
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler , new DuplicateDeclarationHandler () ) ;
if ( isConstructor ( n ) ) { markConstructorToProcess ( n ) ; return false ; }
new RemoveCode ( compiler ) . process ( externs , root ) ;
handleStubDefinition ( t , n ) ;
Node memberType = parseTypeExpressionList ( typeName , next () ) ;
Node memberType = parseTypeExpressionList ( next () ) ;
lastIndex = replacement . getEndPosition () ;
{ return compilerExecutor . runInCompilerThread ( callable , options != null && options . getTracerMode () == TracerMode.ALL ) ; }
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode ) ;
this . functionSideEffectMap = ArrayListMultimap . create () ;
@ Nullable Object object
{ checkState ( token == Token.BLOCK ) ; putBooleanProp ( SYNTHETIC_BLOCK_PROP , val ) ; }
public void setTypeI ( @ Nullable TypeI type ) { this . typei = type ; }
@ Nullable public TypeI getTypeI () { return typei ; }
public void setJSType ( @ Nullable JSType jsType ) { this . typei = jsType ; }
checkNotNull ( target , STRING_CONSTANT ) ;
{ checkNotNull ( parent ) ; parent . removeChild ( this ) ; return this ; }
public AncestorIterable getAncestors () { return new AncestorIterable ( checkNotNull ( this . getParent () ) ) ; }
@ Nullable public Node getParent () { return parent ; }
void setPropListHead ( @ Nullable PropListItem propListHead ) { this . propListHead = propListHead ; }
@ Nullable PropListItem getPropListHeadForTesting () { return propListHead ; }
public void setStaticSourceFile ( @ Nullable StaticSourceFile file ) { this . putProp ( STATIC_SOURCE_FILE , file ) ; }
@ Nullable PropListItem next
@ Nullable PropListItem next
@ Nullable Object value
{ checkState ( this . propListHead == null , STRING_CONSTANT ) ; this . propListHead = other.propListHead ; return this ; }
checkNotNull ( target , STRING_CONSTANT ) ;
{ checkNotNull ( prevChild.next , STRING_CONSTANT ) ; replaceChild ( prevChild.next , newChild ) ; }
{ checkArgument ( child.parent == null ) ; child.parent = this ; }
@ Nullable public Node getSecondChild () { return first.next ; }
@ Nullable public Node getFirstChild () { return first ; }
@ Nullable PropListItem next
@ Nullable PropListItem next
@ Nullable PropListItem next
@ Nullable PropListItem next
@ Override public abstract PropListItem chain ( @ Nullable PropListItem next ) ;
@ Nullable PropListItem next
PropListItem chain ( @ Nullable PropListItem next ) ;
@ Nullable PropListItem getNext ( ) ;
Node memberType = parseTypeExpressionList ( typeName , next () ) ;
checkState ( n . hasTwoChildren () , n ) ;
condition . isCall () && condition . hasTwoChildren ()
Preconditions . checkState ( left . hasTwoChildren () ) ;
Preconditions . checkState ( node . hasTwoChildren () , node ) ;
Preconditions . checkState ( n . hasTwoChildren () , n ) ;
Preconditions . checkState ( node . hasTwoChildren () ) ;
callName . matchesQualifiedName ( STRING_CONSTANT ) && n . hasTwoChildren ()
boolean isDeprecatedCall = callNode . hasTwoChildren () && callName . isGetProp () ;
if ( createSourceMap ) { mcp . generateSourceMap ( code , sourceMap ) ; }
setReferencedType ( new NoResolvedType ( registry , getReferenceName () ) ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope , true ) ; }
assertThat ( templateTypes ) . isEmpty () ;
String shortName = getShortNameForRequire ( namespaceToRequire ) ;
String shortName = getShortNameForRequire ( namespace ) ;
String shortName = getShortNameForRequire ( namespace ) ;
setReferencedType ( registry . getNativeObjectType ( JSTypeNative.NO_RESOLVED_TYPE ) ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope ) ; }
Ascii . toUpperCase ( rightmostName )
{ checkState ( isAnalyzableObjectDefinePropertiesDefinition ( n ) ) ; return ImmutableList . of ( n . getLastChild () ) ; }
checkArgument ( parent . isVanillaFor () , STRING_CONSTANT , parent ) ;
checkNotNull ( reportPath ) ;
@ Nullable NameInformation referring
@ Nullable NameInformation referring
checkNotNull ( ns , STRING_CONSTANT , n ) ;
{ checkNotNull ( name ) ; scopes . put ( node , name ) ; }
checkState ( node . isCall () ) ;
{ super ( name , node ) ; checkState ( node . isCall () ) ; }
{ super ( name , parent . getFirstChild () ) ; checkState ( parent . isAssign () ) ; }
{ checkLocalityOfMarkedCalls ( source , expected , LanguageMode.ECMASCRIPT_2015 ) ; checkLocalityOfMarkedCalls ( source , expected , LanguageMode.ECMASCRIPT5 ) ; }
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
assertNoPureCalls ( source ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
assertNoPureCalls ( source ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
assertNoPureCalls ( templateSrc . replace ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
JSType recvType = simpleInferExprTypeRecur ( recv ) ;
JSType t = simpleInferExprTypeRecur ( argNode ) ;
{ String name = NodeUtil . getName ( n ) ; noSideEffectExterns . add ( name ) ; }
qname != null && noSideEffectExterns . contains ( qname ) && ! isDefinedInSrc
Map < ParamGroup , CompilationParam [] > compilationParamsByGroup = new EnumMap <> ( ParamGroup . class ) ;
Preconditions . checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
statement . isNormalBlock ()
assertTrue ( functionA . getBodyNode () . isNormalBlock () ) ;
assertTrue ( mainFunction . getAstNode () . isRoot () ) ;
assertTrue ( mainFunction . getBodyNode () . isRoot () ) ;
{ return n . isNormalBlock () && n . hasChildren () && isReturnTypeNullable ( n . getParent () ) && ! hasSingleThrow ( n ) ; }
currentFile . markNameProcessed ( nameNode . getQualifiedName () ) ;
Preconditions . checkState ( root . isRoot () ) ;
if ( ! subtree . isScript () && ! subtree . isNormalBlock () ) { return subtree ; }
body . isNormalBlock () && ! body . hasChildren ()
{ return ( n . isNormalBlock () && n . isSyntheticBlock () ) || n . isScript () ; }
Preconditions . checkState ( block . isNormalBlock () ) ;
! target . getParent () . isScript () && ! target . getParent () . isNormalBlock ()
Preconditions . checkArgument ( block . isNormalBlock () , STRING_CONSTANT ) ;
n . isNormalBlock ()
n . isNormalBlock ()
n . isNormalBlock ()
n . isNormalBlock ()
parent != null && ( parent . isNormalBlock () || parent . isScript () )
parent . isScript () || ( parent . isNormalBlock () && parent . getParent () . isFunction () )
{ Preconditions . checkArgument ( blockNode . isNormalBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
if ( n . isNormalBlock () ) { visitBlock ( n ) ; }
node . isFunction () && ! NodeUtil . getFunctionBody ( node ) . isNormalBlock ()
if ( ! n . isScript () && ! n . isNormalBlock () ) { return; }
if ( body . isNormalBlock () ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
{ Preconditions . checkArgument ( n . isNormalBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
Preconditions . checkState ( addingRoot . isNormalBlock () || addingRoot . isModuleBody () || addingRoot . isScript () ) ;
{ return n . isNormalBlock () && n . getParent () != null && n . getParent () . isFunction () ; }
Preconditions . checkState ( block . isNormalBlock () ) ;
node . isNormalBlock ()
if ( n . isEmpty () || ( n . isNormalBlock () && ! n . hasChildren () ) ) { return; }
next != null && next . isNormalBlock ()
if ( ! n . isFunction () || ! n . getLastChild () . isNormalBlock () ) { return; }
currentStatement . isNormalBlock ()
c . isNormalBlock ()
c . isNormalBlock ()
Preconditions . checkState ( caseBody . isNormalBlock () ) ;
! labeledStatement . isNormalBlock ()
last . isNormalBlock ()
NodeUtil . isControlStructureCodeBlock ( n , c ) && ! c . isNormalBlock ()
if ( ! body . isNormalBlock () || ! body . hasOneChild () || ! body . getFirstChild () . isReturn () ) { return; }
s . isFunctionScope () && s . getRootNode () . getLastChild () . isNormalBlock ()
if ( maybeAssign . isNormalBlock () || maybeAssign . isScript () || NodeUtil . isStatement ( maybeAssign ) ) { return; }
if ( n . isExprResult () || n . isNormalBlock () ) { return; }
umdPattern.activeBranch . isNormalBlock () && umdPattern.activeBranch . getChildCount () == NUMBER_CONSTANT
Preconditions . checkState ( n . isNormalBlock () , n ) ;
if ( ! originalBody . isNormalBlock () ) { originalBody = IR . block ( IR . returnNode ( originalBody ) ) . useSourceInfoFromForTree ( originalBody ) ; }
for ( Node child : node . children () ) { if ( child . isNormalBlock () ) { blocks . add ( child ) ; } }
checkState ( body . isNormalBlock () , body ) ;
boolean isVar = NodeUtil . isNameDeclaration ( parent ) && parent . getParent () . isNormalBlock () ;
isGoogScopeFunctionBody ( enclosingFunctionBody ) && scopeRoot . isNormalBlock () && ! scopeRoot . getParent () . isFunction ()
! n . getParent () . isScript () && ! n . getParent () . isNormalBlock ()
return expectedBlock . isNormalBlock () ? expectedBlock : null ;
if ( newChild . isNormalBlock () ) { NodeUtil . tryMergeBlock ( newChild ) ; }
Preconditions . checkState ( block . isNormalBlock () ) ;
! body . isNormalBlock ()
Preconditions . checkState ( body . getNext () == null && body . isNormalBlock () , body ) ;
for ( ; ! currentParent . isScript () && ! currentParent . isNormalBlock () ; current = currentParent , currentParent = currentParent . getParent () ) {}
Preconditions . checkArgument ( node . isNormalBlock () ) ;
! setFunction . hasChildren () || ! setFunction . getLastChild () . isNormalBlock () || ! setFunction . getSecondChild () . isParamList ()
if ( ! getFunction . hasChildren () || ! getFunction . getLastChild () . isNormalBlock () ) { return false ; }
if ( ! favorsCommaOverSemiColon && ! block . isNormalBlock () ) { return false ; }
if ( ! n . isNormalBlock () || ! n . hasChildren () ) { return; }
if ( ! ( parent . isScript () || grandparent != null && grandparent . isFunction () && parent . isNormalBlock () ) ) { return; }
n . isNormalBlock () && ! loneBlocks . isEmpty () && loneBlocks . peek () == n
Preconditions . checkState ( collectionRoot . isScript () || collectionRoot . isRoot () ) ;
Preconditions . checkState ( externs . isRoot () ) ;
assertNode ( functionA . getBodyNode () ) . hasType ( Token.BLOCK ) ;
assertNode ( mainFunction . getAstNode () ) . hasType ( Token.ROOT ) ;
assertNode ( mainFunction . getBodyNode () ) . hasType ( Token.ROOT ) ;
! isArrow && ! isSignature && ! bodyNode . isNormalBlock ()
! irNode . isNormalBlock ()
{ assertTrue ( mainRoot . isRoot () && ! mainRoot . hasChildren () ) ; }
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( finallyBody . isNormalBlock () ) ;
Preconditions . checkState ( tryBody . isNormalBlock () ) ;
{ Preconditions . checkState ( body . isNormalBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( then . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
n . hasChildren () && n . getFirstChild () . isNormalBlock ()
return ImmutableList . of ( qmark , bang ) ;
( parent . isScript () || ( parent . isNormalBlock () && ! parent . isSyntheticBlock () && ! parent . isAddedBlock () ) )
return scopeRoot . isNormalBlock () && scopeRoot . getParent () != null && scopeRoot . getParent () . isFunction () ;
n . isNormalBlock ()
block . isNormalBlock () && block . getParent () . isTry () && block . getParent () . getFirstChild () == block
node . isNormalBlock () && parent != null && parent . isTry () && NodeUtil . getCatchBlock ( parent ) == node
if ( ! n . isNormalBlock () || ! n . hasChildren () || ! isGoogModuleCall ( n . getFirstChild () ) ) { return false ; }
if ( ! block . isNormalBlock () ) { return false ; }
if ( node . isNormalBlock () ) { node . setToken ( Token.SCRIPT ) ; }
boolean needsSemicolon = parent != null && ( parent . isExprResult () || parent . isNormalBlock () || parent . isScript () ) ;
deleteWhitespaceBefore && parent != null && ( parent . isScript () || parent . isNormalBlock () )
Preconditions . checkState ( parentNode . isNormalBlock () , STRING_CONSTANT ) ;
endPass ( STRING_CONSTANT ) ;
endPass ( STRING_CONSTANT ) ;
endPass ( STRING_CONSTANT ) ;
endPass ( STRING_CONSTANT ) ;
! currentScope . hasThis () && NodeUtil . containsType ( fn . getLastChild () , Token.SUPER , NodeUtil.MATCH_NOT_FUNCTION )
Renamer createForChildScope ( boolean hoisted ) ;
{ renamer = nameStack . peek () . createForChildScope ( ! NodeUtil . createsBlockScope ( declarationRoot ) ) ; }
testWarning ( STRING_CONSTANT , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
if ( isInferrableConst ( jsdoc , name , false ) ) { jsdoc = pullJsdocTypeFromAst ( compiler , jsdoc , name ) ; }
if ( ! isInferrableConst ( jsdoc , nameNode , false ) ) { return; }
warnings . add ( JSError . make ( propAccessNode , ABSTRACT_SUPER_METHOD_NOT_CALLABLE , funName ) ) ;
{ Preconditions . checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
throw new MalformedException ( STRING_CONSTANT + node , fnChild ) ;
Node argList = NodeUtil . getFunctionParameters ( function ) ;
Node argList = NodeUtil . getFunctionParameters ( function ) ;
findDeclaredNames ( functionBody , renamer , false ) ;
if ( ! declarationRoot . isFunction () ) { findDeclaredNames ( declarationRoot , renamer , false ) ; }
if ( isCallInLoop ) { fixUninitializedVarDeclarations ( newBlock , newBlock ) ; }
void clear () { providedNamespaces . clear () ; seenNames . clear () ; constructorsToProcess . clear () ; }
for ( String prefix : Iterables . concat ( seenNames , providedNamespaces ) ) { if ( fullyQualifiedName . startsWith ( prefix ) ) { return true ; } }
Preconditions . checkArgument ( declaration . isName () || declaration . isStringKey () ) ;
if ( instrumentationData . get ( fileName ) != null ) { node . addChildrenToFront ( newHeaderNode ( traversal , node ) . removeChildren () ) ; }
{ node . addChildrenToFront ( newHeaderNode ( traversal , node ) . removeChildren () ) ; instrumentBranchCoverage ( traversal , instrumentationData . get ( fileName ) ) ; }
if ( isInterface () ) { return getInstanceType () . getTopDefiningInterface ( propertyName ) ; }
{ return isUnionType () ? this . toMaybeUnionType () . getAlternatesWithoutStructuralTyping () : null ; }
if ( lvalueType . isEnumElement () ) { lvalueType = lvalueType . getEnumeratedTypeOfEnumElement () ; }
JSType enumeratedType = requiredType . getProp ( new QualifiedName ( pname ) ) . getEnumeratedTypeOfEnumElement () ;
JSType enumeratedType = requiredType . getProp ( new QualifiedName ( pname ) ) . getEnumeratedTypeOfEnumElement () ;
TypeI type
TypeI type = getType ( typeObj ) ;
TypeI type = getType ( n ) ;
this . BOTTOM_OBJECT = this . registry . getNativeType ( JSTypeNative.NO_OBJECT_TYPE ) . toMaybeObjectType () ;
TypeI type
TypeI type
{ objectType = objectType . getTopDefiningInterface ( propName ) ; }
NominalType nominal = NominalType . join ( nt1 , nt2 ) ;
{ NominalType tmp = NominalType . join ( n1 , n2 ) ; if ( tmp != null ) { return tmp . getInstanceAsJSType () ; } }
@ Override public CompilerPass getProcessor ( final Compiler compiler ) { return new ClosureOptimizePrimitives ( compiler , propertyRenamingEnabled ) ; }
{ Preconditions . checkState ( n . isName () , n ) ; n . removeFirstChild () ; }
parent . removeFirstChild () ;
! currentScript.declareLegacyNamespace && currentScript.defaultExportRhs == null && namedExport . hasInlinableName ( currentScript.exportsToInline . keySet () )
this . registry = compiler . getTypeIRegistry () ;
Preconditions . checkArgument ( o instanceof JSType , STRING_CONSTANT , o ) ;
test ( DEFAULT_EXTERNS + externs , js , expected , null , warning , description ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = STRING_CONSTANT ;
testSets ( js , output , STRING_CONSTANT ) ;
{ super . setUp () ; super . enableNormalize () ; this . mode = TypeInferenceMode.OTI_ONLY ; }
public DisambiguatePropertiesTest () { super ( DEFAULT_EXTERNS ) ; parseTypeInfo = true ; }
if ( ! ( t . inGlobalHoistScope () || t . inModuleScope () ) ) { return false ; }
{ assertError ( e ) . hasType ( type ) ; assertEquals ( e.lineNumber , lineNumber ) ; }
assertError ( result.errors [ NUMBER_CONSTANT ] ) . hasType ( errorType ) ;
assertThat ( result.success ) . isTrue () ;
assertThat ( compiler . getResult () . success ) . isTrue () ;
currentModule.importsByLongRequiredName . put ( extractFirstArgumentName ( callNode ) , parent ) ;
options . setPolymerVersion ( NUMBER_CONSTANT ) ;
if ( options.deadAssignmentElimination ) { passes . add ( deadAssignmentsElimination ) ; if ( options.polymerVersion == null ) { passes . add ( deadPropertyAssignmentElimination ) ; } }
if ( options.polymerVersion != null ) { checks . add ( polymerPass ) ; }
options . setPolymerVersion ( NUMBER_CONSTANT ) ;
polymerVersion = null ;
if ( other . isGeneric () ) { other = other . instantiateGenericsWithUnknown () ; }
{ if ( this . equals ( other ) ) { return true ; } return instantiateGenericsWithUnknown () . isSubtypeOfHelper ( other , checkThisType , subSuperMap , boxedInfo ) ; }
if ( isGeneric () ) { return instantiateGenericsWithUnknown () . transformByApplyProperty () ; }
Preconditions . checkArgument ( rootNode != parent.rootNode , STRING_CONSTANT , rootNode ) ;
public void testDontCrashCtorAliasWithEnum () { test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testGlobalObjectDeclaredToPreserveItsPreviousValue2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testObjLitAssignmentDepth2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; }
public boolean isConstDeclaration () { return getParent () . isConst () ; }
public boolean isVarDeclaration () { return getParent () . isVar () ; }
{ traverseClass ( n ) ; }
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
options . setPrettyPrint ( true ) ;
this . prettyPrint = options . isPrettyPrint () ;
String zipEntryPath = JAR_URL_PREFIX + absoluteZipPath + BANG_SLASH + entryPath ;
options.prettyPrint = true ;
this . prettyPrint = options.prettyPrint ;
public void testJqueryExpandedEachExpansionEs6ComputedProp () { testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ExpandJqueryAliases.JQUERY_UNABLE_TO_EXPAND_INVALID_NAME ) ; }
options . setPrettyPrint ( true ) ;
this . prettyPrint = options . isPrettyPrint () ;
{ options . setPolymerVersion ( value ? NUMBER_CONSTANT : null ) ; }
fix . getReplacements () . keySet ()
nameDefinitionMultimap . keySet ()
nameDefinitionMultimap . keys ()
nameDefinitionMultimap . keySet ()
{ checkState ( scope . isGlobal () , scope ) ; scanVars ( n , true , true ) ; }
testSame ( STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
public void testTypeParsingOnWithVerbose () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ; test ( STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ; }
testSame ( DEFAULT_EXTERNS , STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
{ CompilerOptions options = createCompilerOptions () ; options . setCheckTypes ( true ) ; test ( options , STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ; }
markConstAndCopyJsDoc ( assignNode , jsdocNode ) ;
markConstAndCopyJsDoc ( target , target ) ;
markConstAndCopyJsDoc ( jsdocNode , jsdocNode ) ;
super . setCode ( cachedCode , Objects . equals ( this . getCharset () , StandardCharsets.UTF_8 ) ) ;
super . setCode ( cachedCode , Objects . equals ( this . getCharset () , StandardCharsets.UTF_8 ) ) ;
{ return Iterables . getLast ( list ) ; }
if ( this . ns != null ) { builder . append ( this . ns ) ; }
{ if ( inheritedPropDef.methodType != null ) { propMethodTypesToProcess . put ( pname , inheritedPropDef.methodType ) ; } }
{ Preconditions . checkState ( this . rawType . isFinalized () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
this . functionContextStack . addLast ( initialGeneratorContext ? FunctionFlavor.GENERATOR : FunctionFlavor.NORMAL ) ;
Node namespaceArg = crDefineCallNode . getSecondChild () ;
Node pathArg = crExportPathNode . getSecondChild () ;
String target = call . getSecondChild () . getQualifiedName () ;
{ int result = BASE64_DECODE_MAP [ c ] ; assert ( result != - NUMBER_CONSTANT ) : STRING_CONSTANT ; return result ; }
ParseTree arrowFunctionBody = parseArrowFunctionBody ( expressionIn , FunctionFlavor.ASYNCHRONOUS ) ;
ParseTree arrowFunctionBody = parseArrowFunctionBody ( expressionIn , FunctionFlavor.NORMAL ) ;
parseFunctionTail ( builder , FunctionFlavor.GENERATOR ) ;
parseFunctionTail ( builder , FunctionFlavor.NORMAL ) ;
parseFunctionTail ( builder , FunctionFlavor.ASYNCHRONOUS ) ;
parseFunctionTail ( builder , FunctionFlavor.ASYNCHRONOUS ) ;
parseFunctionTail ( builder , isGenerator ? FunctionFlavor.GENERATOR : FunctionFlavor.NORMAL ) ;
parseFunctionTail ( builder , isGenerator ? FunctionFlavor.GENERATOR : FunctionFlavor.NORMAL ) ;
parseFunctionTail ( builder , isGenerator ? FunctionFlavor.GENERATOR : FunctionFlavor.NORMAL ) ;
recvType = recvType . removeType ( commonTypes.NULL_OR_UNDEFINED ) ;
if ( isCallTo ( destructuringLhsNode . getLastChild () , GOOG_REQUIRE ) ) { return; }
if ( aliasVarNodeRhs == null || ! isCallTo ( aliasVarNodeRhs , GOOG_FORWARDDECLARE ) ) { t . report ( call , INVALID_GET_ALIAS ) ; return; }
return call != null && isCallTo ( call , GOOG_LOADMODULE ) && call . getLastChild () . isFunction () ;
reset ( reservedNames , prefix , reservedCharacters , reservedCharacters ) ;
{ return new AmbiguateProperties ( compiler , options . getPropertyReservedNamingFirstChars () , options . getPropertyReservedNamingNonFirstChars () ) ; }
NameGenerator nameGen = new DefaultNameGenerator ( reservedNames . build () , STRING_CONSTANT , reservedFirstCharacters , reservedNonFirstCharacters ) ;
nameGenerator . reset ( reservedNames , STRING_CONSTANT , reservedFirstCharacters , reservedNonFirstCharacters ) ;
{ this ( compiler , generatePseudoNames , prevUsedPropertyMap , null , null , nameGenerator ) ; }
{ this ( compiler , generatePseudoNames , null , null , null , nameGenerator ) ; }
if ( isBottom () || isUnknown () || isTheTruthyType () ) { return this . commonTypes . UNKNOWN ; }
private boolean isTheFalsyType () { return FALSY_MASK == getMask () ; }
private boolean isTheTruthyType () { return TRUTHY_MASK == getMask () ; }
Preconditions . checkState ( this . isFinalized , STRING_CONSTANT , this ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; recordImplicitUseOfNativeObject ( n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; recordImplicitUseOfNativeObject ( n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ; return options ; }
for ( TypedScope s : scopes . values () ) { Iterables . addAll ( vars , s . getVarIterable () ) ; }
for ( Var v : globalExternsScope . getVarIterable () ) { considerVar ( v , null ) ; }
scope . getVarIterable ()
parse ( STRING_CONSTANT ) ;
for ( TypedScope s : scopes . values () ) { Iterables . addAll ( vars , s . getAllSymbols () ) ; }
for ( Var v : globalExternsScope . getAllSymbols () ) { considerVar ( v , null ) ; }
scope . getAllSymbols ()
{ return NodeUtil . isLoopStructure ( target ) && matchLabel ( target . getParent () , label ) ; }
{ if ( leftOfArrow.type == ParseTreeType.CALL_EXPRESSION ) { return completeAssignmentExpressionParseAtArrow ( leftOfArrow . asCallExpression () ) ; } else { return completeArrowFunctionParseAtArrow ( leftOfArrow , expressionIn ) ; } }
if ( topInterface != null && topInterface . getConstructor () != null ) { foundType = topInterface . getPrototypeObject () ; }
{ ObjectType obj = getObjTypeIfSingletonObj () ; return obj != null && obj . hasOwnProperty ( new QualifiedName ( propertyName ) ) ; }
if ( this . equals ( proto ) ) { Preconditions . checkState ( isBuiltinObjectPrototype () , STRING_CONSTANT , this ) ; return null ; }
if ( ! sourceType . isSubtypeWithoutStructuralTyping ( targetType ) ) { TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , sourceType , targetType ) ; }
TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , argType , paramType ) ;
TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , rightType , leftType ) ;
TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , rightType , leftType ) ;
TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , caseType , switchType ) ;
if ( isPrototypeObject () ) { return builder . append ( getOwnerFunction () . getThisType () ) . append ( STRING_CONSTANT ) ; }
test ( DEFAULT_EXTERNS + externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
testSets ( js , output , STRING_CONSTANT ) ;
NodeUtil . isNameDeclaration ( n ) && n . getFirstFirstChild () != null && n . getFirstFirstChild () . isFunction ()
return builder () . withCharset ( inputCharset ) . withOriginalPath ( originalZipPath + BANG_SLASH + entryPath ) . buildFromUrl ( zipEntryUrl ) ;
assertPasses ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
isNameDeclaration ( parent ) || parent . isExprResult ()
println ( STRING_CONSTANT , funType ) ;
reportCodeChange () ;
reportCodeChange () ;
@ Override public void setUp () { enableNormalize () ; }
@ Override protected void setUp () { style = RELAX ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendStringPart ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED ) ;
{ if ( options == null ) { initOptions ( new CompilerOptions () ) ; } return errorManager ; }
inputsById . clear () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
{ if ( options == null ) { initOptions ( newCompilerOptions () ) ; } return errorManager ; }
inputsById = new HashMap <> () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = errorManager ; }
Preconditions . checkState ( ! areSubtypes , STRING_CONSTANT , obj1 , obj2 ) ;
{ switch ( ch ) { case CHAR_CONS : case CHAR_CONS : return true ; default: return ch == NUMBER_CONSTANT || Character . isLetter ( ch ) ; } }
{ if ( options == null ) { initOptions ( new CompilerOptions () ) ; } return errorManager ; }
inputsById . clear () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
Preconditions . checkArgument ( callNode . isCall () , STRING_CONSTANT , callNode ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ; return options ; }
Node root = compiler . getJsRoot () ;
{ assertThat ( aggregateWarnings ) . named ( STRING_CONSTANT ) . isEmpty () ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; compareJsDoc = true ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; }
public void testTaggedTemplateError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED ; }
public void testAsyncFunction () { setLanguage ( LanguageMode.ECMASCRIPT_NEXT , LanguageMode.ECMASCRIPT5 ) ; testError ( STRING_CONSTANT , CANNOT_CONVERT_YET ) ; testError ( STRING_CONSTANT , CANNOT_CONVERT_YET ) ; }
public void testExponentiationAssignmentOperator () { setLanguage ( LanguageMode.ECMASCRIPT_2016 , LanguageMode.ECMASCRIPT5 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExponentiationOperator () { setLanguage ( LanguageMode.ECMASCRIPT_2016 , LanguageMode.ECMASCRIPT5 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; runTypeCheckAfterProcessing = true ; }
public void testWhileLoopBranch ( ) throws Exception { compareWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareWhileLoopBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDoWhileLoopMultiLineBranch ( ) throws Exception { compareDoWhileLoopMultiLineBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopMultiLineBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDoWhileLoopBranch ( ) throws Exception { compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testForLoopBranch ( ) throws Exception { compareForLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareForLoopBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testIfElseBranch ( ) throws Exception { compareIfElseBranch ( LanguageMode.ECMASCRIPT5 ) ; compareIfElseBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testIfBranch ( ) throws Exception { compareIfBranch ( LanguageMode.ECMASCRIPT5 ) ; compareIfBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testFunction ( ) throws Exception { compareFunctionOneMode ( LanguageMode.ECMASCRIPT5 ) ; compareFunctionOneMode ( LanguageMode.ECMASCRIPT_2015 ) ; }
{ setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
{ compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
public void testInlineIntoNestedNonHoistedNamedFunctions () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testInvalidVariableInScope () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_INVALID_VARIABLE ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_INVALID_VARIABLE ) ; }
public void testNonAliasLocal () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testJSDocCopiedForClasses () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectLiteralMethods () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectLiteralShorthand () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDefaultParameter () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition3 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition2 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition1 () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testArrowFunction () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testNonTopLevelDestructuring () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectDescructuringError2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testObjectDescructuringError1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testDestructuringError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testYieldExpression () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testScopedNoChanges ( aliases , code , LanguageMode.ECMASCRIPT3 ) ; testScopedNoChanges ( aliases , code , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testScoped ( code , expected , LanguageMode.ECMASCRIPT3 ) ; testScoped ( code , expected , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testError ( createFunction ( body ) ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testError ( createShorthandFunctionInObjLit ( body ) ) ; }
{ testOk ( createFunction ( body ) ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testOk ( createShorthandFunctionInObjLit ( body ) ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
{ testExternChanges ( extern , input , expectedExtern , LanguageMode.ECMASCRIPT_2015 ) ; testExternChanges ( extern , input , expectedExtern , LanguageMode.ECMASCRIPT5 ) ; }
{ testWarning ( js , expected , warning , LanguageMode.ECMASCRIPT_2015 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testWarning ( js , warning , warningMessage ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testWarning ( js , warning ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testWarning ( js , warning ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT_2015 ) ; testError ( js , error , LanguageMode.ECMASCRIPT5 ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT_2015 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testError ( js , es6Error ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testError ( js , es5Error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testError ( js , error ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testError ( js , error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( externs , js , diag , error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testSame ( externs , js , warning ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . test ( js , js ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . test ( js , js ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . test ( js , js ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
{ test ( js , expected , LanguageMode.ECMASCRIPT_2015 ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ test ( js , expected , LanguageMode.ECMASCRIPT_2015 ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; super . test ( js , expected ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . test ( js , expected ) ; }
setLanguage ( LanguageMode.ECMASCRIPT_NEXT , LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( LanguageMode.ECMASCRIPT_NEXT , LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( LanguageMode.ECMASCRIPT_NEXT , LanguageMode.ECMASCRIPT5 ) ;
public void testValidRestParameter () { setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; valid ( STRING_CONSTANT ) ; valid ( STRING_CONSTANT ) ; }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; allowExternsChanges ( true ) ; }
public void testNoRewriteIfNotInGlobalScope1 ( ) throws Exception { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT + NoRewriteIfNotInGlobalScopeTestInput.INPUT + STRING_CONSTANT ) ; }
options . setLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
private void testSameEs6Strict ( String js ) { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; test ( js , js , null , null ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; allowExternsChanges ( false ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; anchorUnusedVars = false ; canRemoveExterns = false ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testObjLit () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; assertUnreachable ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testForLoopsEs6 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; assertUnreachable ( STRING_CONSTANT ) ; assertUnreachable ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testConst () { testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testLet () { testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testRewriteWarning ( code , expected , warning , LanguageMode.ECMASCRIPT3 ) ; testRewriteWarning ( code , expected , warning , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testRewriteError ( js , error , LanguageMode.ECMASCRIPT3 ) ; testRewriteError ( js , error , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testRewrite ( code , expected , LanguageMode.ECMASCRIPT3 ) ; testRewrite ( code , expected , LanguageMode.ECMASCRIPT_2015 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; languageOut = LanguageMode.ECMASCRIPT3 ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrowFunction4 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testFailure ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrowFunction3 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testFailure ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrowFunction2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testFailure ( STRING_CONSTANT ) ; }
public void testArrowFunction1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testFailure ( STRING_CONSTANT ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( createShorthandFunctionInObjLit ( returnType , body ) ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; String js = createShorthandFunctionInObjLit ( returnType , body ) ; testWarning ( js , CheckMissingReturn.MISSING_RETURN_STATEMENT ) ; }
options . setLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
public void testFunctionNonMovement1 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; testSame ( createModuleStar ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testInlineEmptyFunction6 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
public void testEs6EnhancedObjLiteralsPropertyShorthand () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testEs6EnhancedObjLiteralsComputedValuesNotRemoved () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testES6ClassComputedProperty () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; }
public void testEs6GettersWithoutTranspilation () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageOut ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
public CheckUnusedPrivatePropertiesTest () { super ( EXTERNS ) ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; }
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_NEXT ;
languageMode = LanguageMode.ECMASCRIPT_NEXT ;
public void testAsyncArrowFunction () { languageMode = LanguageMode.ECMASCRIPT_NEXT ; assertPrintSame ( STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_NEXT ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testMemberGeneratorYield1 () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testNewTarget () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDefaultParametersWithRestParameters () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testRestParameters () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDefaultParameters () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testOctalNumericKey () { allowWarnings = true ; languageMode = LanguageMode.ECMASCRIPT5 ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testComputedPropertiesClassMethods () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
{ assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrettyPrinter_defaultValue ( ) throws Exception { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testPrettyPrinter_arrow ( ) throws Exception { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testForOf () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDestructuringForOfLoops2 () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrintDestructuringInRestParam () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrintMixedDestructuring () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testPrettyPrintObjectPattern () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrintNestedObjectPattern () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testPrettyPrintArrayPattern () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrintBlockScopedFunctions () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExponentiationAssignmentOperator () { languageMode = LanguageMode.ECMASCRIPT_2016 ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2016 ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; runTypeCheckAfterProcessing = true ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
{ CompilerOptions options = super . getOptions () ; options . setLanguageIn ( LanguageMode.ECMASCRIPT6_TYPED ) ; options . setLanguageOut ( LanguageMode.ECMASCRIPT_2015 ) ; return options ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; compiler = createCompiler () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; compareJsDoc = true ; }
return CompilerOptions.LanguageMode.ECMASCRIPT_2015 ;
this . languageIn = CompilerOptions.LanguageMode.ECMASCRIPT_2015 ;
public void testCodeMotionDoesntBreakFunctionHoisting ( ) throws Exception { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
return languageOutIsAtLeast ( LanguageMode.ECMASCRIPT_2015 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , VarCheck.VIOLATED_MODULE_DEP_ERROR ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , VarCheck.VIOLATED_MODULE_DEP_ERROR ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , VarCheck.MISSING_MODULE_DEP_ERROR ) ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , VarCheck.MISSING_MODULE_DEP_ERROR ) ; }
public void testLegalConstReferenceBetweenModules () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testLegalLetReferenceBetweenModules () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testNoMoveDeepFunctionDeclarations () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5_STRICT ) ;
{ setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
{ super . setUp () ; compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ; compilerOptions . setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
replaceSymbol ( t , n , name , t . getInput () ) ;
com.google.javascript.jscomp.newtypes.FunctionType ctorType = functionType == null ? null : functionType . getFunTypeIfSingletonObj () ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
checkState ( child.parent == this , STRING_CONSTANT , child , parent ) ;
{ checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
testSame ( STRING_CONSTANT ) ;
replaceSymbol ( n , name , t . getInput () ) ;
findDeclaredNames ( t , functionBody , renamer , false ) ;
if ( ! declarationRoot . isFunction () ) { findDeclaredNames ( t , declarationRoot , renamer , false ) ; }
testSameEs6 ( STRING_CONSTANT ) ;
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; enableTypeCheck () ; }
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
checkState ( child.parent == this ) ;
{ Preconditions . checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
checkState ( child.parent == this , STRING_CONSTANT , child , parent ) ;
{ checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
Preconditions . checkState ( this . rawType . isFrozen () ) ;
{ Preconditions . checkState ( this . rawType . isFrozen () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
Preconditions . checkState ( this . rawType . isFrozen () ) ;
public RawNominalType getRawNominalType () { Preconditions . checkState ( ! this . rawType . isFrozen () ) ; return this . rawType ; }
{ if ( isFrozen && externs . containsKey ( name ) ) { type = externs . get ( name ) ; } }
Preconditions . checkState ( isFrozen ) ;
Preconditions . checkArgument ( nominalType . isFrozen () ) ;
Preconditions . checkArgument ( nominalType . isFrozen () ) ;
Preconditions . checkState ( this . isFrozen , STRING_CONSTANT , this ) ;
{ Preconditions . checkState ( ! this . isFrozen ) ; super . addUndeclaredProperty ( pname , defSite , this . commonTypes . UNKNOWN , false ) ; }
{ Preconditions . checkState ( ! this . isFrozen ) ; super . addProperty ( pname , defSite , type , isConstant ) ; }
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( this . isFrozen ) ;
if ( ! this . isFrozen ) { return null ; }
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
public boolean isStruct () { Preconditions . checkState ( isFrozen () || isClass () ) ; return this . objectKind . isStruct () ; }
if ( ! thisNode . isEquivalentWithSideEffectsToShallow ( thatNode ) ) { return false ; }
ScopedChangeHandler () { this . lastCodeChangeQuery = compiler . getChangeStamp () ; }
maybeSanityCheck ( name , externs , root ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
@ Override protected void setUp () { super . enableLineNumberCheck ( false ) ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override protected void setUp () { nameGenerator = null ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { super . enableLineNumberCheck ( false ) ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override protected void setUp () { super . enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
public InlineVariablesConstantsTest () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; validateAstChangeMarking ( false ) ; }
globalScope = TypedScope . createGlobalScope ( rootNode ) ;
setReferencedType ( new NoResolvedType ( registry , getReferenceName () , getTemplateTypes () ) ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope , true ) ; }
@ Override public void setUp () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
{ Node grandparent = parent . getParent () ; replaceWithEmpty ( parent , grandparent ) ; compiler . reportChangeToEnclosingScope ( grandparent ) ; }
@ Override public final boolean isUnresolved () { return false ; }
final JSTypes getCommonTypes () { return this . commonTypes ; }
compiler . reportChangeToEnclosingScope ( block ) ;
compiler . reportChangeToEnclosingScope ( assign ) ;
compiler . reportChangeToEnclosingScope ( newBody ) ;
{ newBlockNode . useSourceInfoIfMissingFromForTree ( oldBlockNode ) ; functionNode . replaceChild ( oldBlockNode , newBlockNode ) ; compiler . reportChangeToEnclosingScope ( newBlockNode ) ; }
if ( ! origValueNode . getString () . equals ( newString ) ) { origValueNode . setString ( newString ) ; compiler . reportChangeToEnclosingScope ( origValueNode ) ; }
if ( newValue != msgNode ) { newValue . useSourceInfoIfMissingFromForTree ( msgNode ) ; msgNode . replaceWith ( newValue ) ; compiler . reportChangeToEnclosingScope ( newValue ) ; }
this . mode = TypeInferenceMode.BOTH ;
public void testCoercionSubstitution_boxedNumberVsZero () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
@ Override protected void setUp () { super . enableLineNumberCheck ( false ) ; }
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( stringNode ) ;
compiler . reportChangeToEnclosingScope ( objNode ) ;
compiler . reportChangeToEnclosingScope ( objNode ) ;
if ( ! collapses . isEmpty () ) { applyCollapses () ; }
if ( codeChanged ) { compiler . reportCodeChange () ; }
{ if ( NodeUtil . getPureBooleanValue ( forCondition ) == TernaryValue.TRUE ) { forCondition . replaceWith ( IR . empty () ) ; compiler . reportCodeChange () ; } }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; compiler . reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ maybeBreak . detach () ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; compiler . reportCodeChange () ; return right ; }
@ Override protected void setUp () { allowExternsChanges ( true ) ; }
compiler . reportCodeChange () ;
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; compiler . reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; compiler . reportCodeChange () ; return null ; }
for ( Node childToRemove : nodesToRemove ) { node . removeChild ( childToRemove ) ; compiler . reportCodeChange () ; }
t . getCompiler () . reportChangeToEnclosingScope ( n ) ;
{ n . setString ( newName ) ; t . getCompiler () . reportChangeToEnclosingScope ( n ) ; return; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ callTarget . getLastChild () . setString ( STRING_CONSTANT ) ; firstArg . getNext () . detach () ; compiler . reportCodeChange () ; return n ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; compiler . reportCodeChange () ; return newNode ; }
if ( rhs . isChanged () ) { compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . replaceChild ( placeholder , mNode . getNode () . removeFirstChild () ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detach () ; compiler . reportCodeChange () ; return null ; }
this . compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( propstmt ) ;
compiler . reportChangeToEnclosingScope ( callSite.parent ) ;
{ n . setString ( prop + fileid ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
void apply () { parent . replaceChild ( oldChild , newChild ) ; compiler . reportChangeToEnclosingScope ( newChild ) ; }
compiler . reportChangeToEnclosingScope ( addingRoot ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( rhs ) ;
compiler . reportChangeToEnclosingScope ( node ) ;
compiler . reportChangeToEnclosingScope ( newQualifiedNameNode ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( binaryNamespaceExportNode ) ;
compiler . reportChangeToEnclosingScope ( jsdocNode ) ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; compiler . reportCodeChange () ; return result ; }
compiler . reportCodeChange () ;
{ n . detachChildren () ; parent . replaceChild ( n , result ) ; compiler . reportCodeChange () ; return result ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; compiler . reportCodeChange () ; return replacementNode ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; compiler . reportCodeChange () ; }
compiler . reportChangeToEnclosingScope ( outerBlock ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( var ) ;
compiler . reportChangeToEnclosingScope ( var ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
{ Node retValue = returnedValue . cloneTree () ; parent . replaceChild ( call , retValue ) ; compiler . reportChangeToEnclosingScope ( retValue ) ; }
compiler . reportChangeToEnclosingScope ( getProp ) ;
compiler . reportChangeToEnclosingScope ( and ) ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; compiler . reportCodeChange () ; return newLiteralNode ; }
if ( canFoldStandardConstructors ( n ) ) { n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; }
{ parent . removeChild ( n ) ; compiler . reportChangeToEnclosingScope ( parent ) ; functions . put ( t . getModule () , n ) ; }
if ( node != null ) { n . setDeclaredTypeExpression ( node ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
{ attachTypeExpr = IR . rest ( n . getString () ) ; n . replaceWith ( attachTypeExpr ) ; compiler . reportChangeToEnclosingScope ( attachTypeExpr ) ; }
if ( ! p.newName . equals ( oldName ) ) { n . setString ( p.newName ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
public InlineVariablesConstantsTest () { enableNormalize () ; }
compiler . reportChangeToEnclosingScope ( classDeclaration ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( getKey . getParent () ) ;
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.ADDING_PROPERTY_TO_NON_OBJECT ) ;
notifyOfRemoval ( node , parent ) ;
{ parent . removeChild ( node ) ; notifyOfRemoval ( node , parent ) ; }
@ Override public void setUp () { enableNormalize () ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
for ( Node closureRequire : requiresToBeRemoved ) { compiler . reportChangeToEnclosingScope ( closureRequire ) ; closureRequire . detach () ; }
@ Override protected void setUp () { super . enableNormalize () ; }
compiler . reportChangeToEnclosingScope ( ref ) ;
compiler . reportChangeToEnclosingScope ( varNode ) ;
{ functionBody . removeChild ( current ) ; insertAfter = addToFront ( functionBody , current , insertAfter ) ; reportCodeChange ( functionBody , STRING_CONSTANT ) ; }
reportCodeChange ( n , STRING_CONSTANT ) ;
reportCodeChange ( n , STRING_CONSTANT ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
scope . isFunctionScope ()
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( global.root ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( varNode ) ;
if ( maybeNormalizeFunctionDeclaration ( n , compiler ) ) { reportCodeChange ( n , STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( var ) ;
compiler . reportChangeToEnclosingScope ( result ) ;
compiler . reportChangeToEnclosingScope ( newBlock ) ;
compiler . reportChangeToEnclosingScope ( newFor ) ;
compiler . reportChangeToEnclosingScope ( name ) ;
compiler . reportChangeToEnclosingScope ( stringKey ) ;
compiler . reportChangeToEnclosingScope ( init ) ;
compiler . reportChangeToEnclosingScope ( assign ) ;
compiler . reportChangeToEnclosingScope ( mathDotPowCall ) ;
compiler . reportChangeToEnclosingScope ( initSymbol ) ;
compiler . reportChangeToEnclosingScope ( genBlock ) ;
{ return new DevirtualizePrototypeMethods ( compiler ) ; }
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
n . isName () && NodeUtil . isNameDeclaration ( n . getParent () )
Iterable < JSModule > getAllModules () { return modules ; }
initTraversal ( root ) ;
initTraversal ( scopeRoot ) ;
initTraversal ( root ) ;
compiler . setChangeScope ( null ) ;
@ Override public void setUp () { enableNormalize () ; }
{ Node dollarChildProp = n . getGrandparent () ; dollarChildProp . setToken ( Token.GETELEM ) ; compiler . reportChangeToEnclosingScope ( dollarChildProp ) ; }
compiler . reportChangeToEnclosingScope ( stmt ) ;
compiler . reportChangeToEnclosingScope ( assign ) ;
@ Override public void setUp () { super . enableLineNumberCheck ( false ) ; }
compiler . reportChangeToEnclosingScope ( fnNameNode ) ;
compiler . reportChangeToEnclosingScope ( stmts ) ;
@ Override public void setUp () { enableNormalize () ; }
compiler . reportChangeToEnclosingScope ( stmts ) ;
compiler . reportChangeToEnclosingScope ( exportCall ) ;
compiler . reportChangeToEnclosingScope ( expression ) ;
compiler . reportChangeToEnclosingScope ( objLit ) ;
compiler . reportChangeToEnclosingScope ( expression ) ;
{ c . setQuotedString () ; compiler . reportChangeToEnclosingScope ( c ) ; }
t . reportCodeChange () ;
t . reportCodeChange () ;
{ if ( NodeUtil . getPureBooleanValue ( forCondition ) == TernaryValue.TRUE ) { forCondition . replaceWith ( IR . empty () ) ; reportCodeChange () ; } }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
{ maybeBreak . detach () ; reportCodeChange () ; }
reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; reportCodeChange () ; return right ; }
reportCodeChange () ;
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; reportCodeChange () ; return null ; }
for ( Node childToRemove : nodesToRemove ) { node . removeChild ( childToRemove ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ callTarget . getLastChild () . setString ( STRING_CONSTANT ) ; firstArg . getNext () . detach () ; reportCodeChange () ; return n ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; reportCodeChange () ; return newNode ; }
if ( rhs . isChanged () ) { reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( placeholder , mNode . getNode () . removeFirstChild () ) ; reportCodeChange () ; }
reportCodeChange () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detach () ; reportCodeChange () ; return null ; }
this . reportCodeChange () ;
reportCodeChange () ;
t . reportCodeChange () ;
t . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( lastAncestor ) ;
compiler . reportChangeToEnclosingScope ( injectionPointParent ) ;
compiler . reportChangeToEnclosingScope ( expressionRoot ) ;
t . reportCodeChange () ;
if ( tryReplaceArguments ( traversal . getScope () ) ) { traversal . reportCodeChange () ; }
t . reportCodeChange () ;
t . reportCodeChange () ;
if ( newJsdoc != null ) { jsdocNode . setJSDocInfo ( newJsdoc ) ; t . reportCodeChange () ; }
t . reportCodeChange () ;
if ( isGoogLoadModuleStatement ( n ) ) { updateGoogLoadModuleLate ( t , n ) ; }
{ n . putBooleanProp ( Node.GOOG_MODULE , true ) ; inlineModuleIntoGlobal ( n ) ; t . reportCodeChange () ; checkAndSetStrictModeDirective ( t , n ) ; }
visitClass ( t , n , parent ) ;
visitRestParam ( t , n , parent ) ;
t . reportCodeChange () ;
t . reportCodeChange () ;
{ parent . replaceChild ( n , declaringNode . getFirstFirstChild () . cloneTree () ) ; t . reportCodeChange () ; }
{ if ( isUtilGetDefineCall ( n ) ) { substituteUtilGetDefine ( t , n ) ; } }
{ if ( NodeUtil . isDestructuringDeclaration ( n ) ) { splitDeclaration ( t , n , parent ) ; } }
compiler . reportChangeToEnclosingScope ( newNode ) ;
t . reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
if ( canFoldStandardConstructors ( n ) ) { n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
t . reportCodeChange () ;
{ visitArrowFunction ( t , n , checkNotNull ( thisContext ) ) ; }
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( newValue ) ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
t . reportCodeChange () ;
JSTypeExpression typeExpr = getTypeFromGetterOrSetter ( member ) . copy () ;
{ if ( expr != null ) { return cloneTypeNodes ? expr . copy () : expr ; } return null ; }
if ( foundObj . isGenericObjectType () ) { foundType = foundObj . getRawType () ; }
if ( foundType != null && foundType . isGenericObjectType () ) { foundType = foundType . getRawType () ; }
ImmutableMap < String , TypeI > typeVars
if ( obj != null && obj . isGenericObjectType () ) { return obj . instantiateGenericsWithUnknown () ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new PropagateConstJsdoc () ) ; new RemoveCode ( compiler ) . process ( externs , root ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
@ Override public void setUp () { enableNormalize () ; }
TypeI type = n . getTypeI () ;
TypeI type = n . getTypeI () ;
if ( extractionInfo . shouldExtract () ) { doExtraction ( extractionInfo ) ; }
compiler . reportChangeToEnclosingScope ( objectLit ) ;
compiler . reportChangeToEnclosingScope ( addingRoot ) ;
compiler . reportChangeToEnclosingScope ( body ) ;
{ if ( logger . isLoggable ( Level.FINE ) ) { logger . fine ( STRING_CONSTANT + callName ) ; } inlineEmptyMethod ( t , parent , callNode ) ; }
compiler . reportChangeToEnclosingScope ( inheritsExpressionResult ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
for ( Definition def : definitionsGatherer.definitions ) { def . remove ( compiler ) ; }
if ( codeChanged ) { reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; reportCodeChange () ; return result ; }
reportCodeChange () ;
{ n . detachChildren () ; parent . replaceChild ( n , result ) ; reportCodeChange () ; return result ; }
reportCodeChange () ;
reportCodeChange () ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; reportCodeChange () ; return replacementNode ; }
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; reportCodeChange () ; }
if ( options . getInstrumentForCoverageOnly () ) { instrumentForCoverage ( options.instrumentBranchCoverage ) ; return; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
if ( Keywords . isKeyword ( idToken.value ) && ! Keywords . isTypeScriptSpecificKeyword ( idToken.value ) ) { reportError ( STRING_CONSTANT , name ) ; }
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null ) ;
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null ) ;
optimizer = new PhaseOptimizer ( compiler , tracker ) ;
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null ) ;
if ( typeWithBannedProp . isSubtypeWithoutStructuralTyping ( foundType ) ) { if ( matchesPrototype ( typeWithBannedProp , foundType ) ) { return ConformanceResult.VIOLATION ; } else if ( reportLooseTypeViolations ) { return ConformanceResult.POSSIBLE_VIOLATION_DUE_TO_LOOSE_TYPES ; } }
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
t . reportCodeChange () ;
t . reportCodeChange () ;
t . reportCodeChange () ;
t . reportCodeChange () ;
reportChangeToEnclosingScope ( parent ) ;
t . reportCodeChange () ;
t . reportCodeChange () ;
{ clazz . replaceChild ( clazz . getFirstChild () , IR . empty () . useSourceInfoFrom ( clazz . getFirstChild () ) ) ; t . reportCodeChange () ; }
t . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( root ) ;
t . reportCodeChange () ;
if ( n . getLineno () == NUMBER_CONSTANT ) { n . setCharno ( n . getCharno () - NUMBER_CONSTANT ) ; t . reportCodeChange () ; }
AbstractCompiler compiler
{ n . setString ( newName ) ; t . reportCodeChange () ; return; }
maybeRewriteClassDefinition ( t , n ) ;
{ if ( isMethodOrCtorCallThatTriggersRemoval ( t , n , parent ) ) { replaceHighestNestedCallWithNull ( t , n , parent ) ; } }
if ( parent . getFirstChild () == n && isReferenceToRemovedVar ( t , n ) ) { replaceHighestNestedCallWithNull ( t , parent , parent . getParent () ) ; }
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , InliningMode.DIRECT ) ;
this . mode = TypeInferenceMode.OTI_ONLY ;
public PeepholeFoldConstantsTest () { super ( DEFAULT_EXTERNS ) ; }
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
@ Override public void setUp () { setLanguage ( ECMASCRIPT_NEXT , ECMASCRIPT_NEXT ) ; behavior = null ; }
Iterable < JSModule > getAllModules () { return modules ; }
tightenNameTypeAndDontWarn ( varName , expr , declType , inferredType , requiredType )
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT , STRING_CONSTANT ) , InliningMode.DIRECT ) ;
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
List < TypeMismatch > actual = ImmutableList . copyOf ( getLastCompiler () . getTypeMismatches () ) ;
JSTypeRegistry registry = getLastCompiler () . getTypeRegistry () ;
JSTypeRegistry registry = getLastCompiler () . getTypeRegistry () ;
JSTypeRegistry registry = getLastCompiler () . getTypeRegistry () ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
{ currentLocationAbstractionIdentifier = locationAbstractionIdentifier ; testSame ( SHARED_EXTERNS , js , null ) ; currentJsRoot = getLastCompiler () . jsRoot ; return currentAnalysis ; }
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , findFunction ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , findParameter ) ;
if ( NodeUtil . isCompoundAssignmentOp ( n ) ) { normalizeAssignShorthand ( n ) ; }
NodeUtil . isCompoundAssignmentOp ( n ) || n . isInc () || n . isDec ()
sourceMapOriginalSources . putIfAbsent ( path , originalSourcesLoader . loadSource ( path ) ) ;
ExternalSourceLoader originalSourcesLoader
bundler . appendTo ( out , input , input . getSourceFile () . getCode () ) ;
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
readInputs () ;
{ ensureRequirementIsMutable () ; com.google.protobuf.AbstractMessageLite.Builder . addAll ( values , requirement_ ) ; onChanged () ; }
catch ( com.google.protobuf.InvalidProtocolBufferException e ) { parsedMessage = ( com.google.javascript.jscomp.ConformanceConfig ) e . getUnfinishedMessage () ; throw e . unwrapIOException () ; }
private void maybeForceBuilderInitialization () { if ( com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ) { getRequirementFieldBuilder () ; } }
private Builder ( com.google.protobuf.GeneratedMessageV3.BuilderParent parent ) { super ( parent ) ; maybeForceBuilderInitialization () ; }
com.google.protobuf.GeneratedMessageV3.BuilderParent parent
{ return com.google.protobuf.GeneratedMessageV3 . parseWithIOException ( PARSER , input , extensionRegistry ) ; }
{ return com.google.protobuf.GeneratedMessageV3 . parseDelimitedWithIOException ( PARSER , input , extensionRegistry ) ; }
{ return com.google.protobuf.GeneratedMessageV3 . parseWithIOException ( PARSER , input , extensionRegistry ) ; }
public void testInlineInFunction1 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( n . isAsyncFunction () ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT ) , InliningMode.DIRECT ) ;
NodeUtil . isNameDeclaration ( declaration ) && declaredVarOrProp . isName ()
assertGetNameResult ( parent . getLastChild () , STRING_CONSTANT ) ;
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; assertGetNameResult ( parent . getFirstChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; assertGetNameResult ( parent . getLastChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; assertGetNameResult ( parent . getFirstChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) ; assertGetNameResult ( parent . getFirstChild () , STRING_CONSTANT ) ; }
if ( sanityCheck != null ) { changeVerifier = new ChangeVerifier ( compiler ) . snapshot ( jsRoot ) ; }
{ sanityCheck . create ( compiler ) . process ( externs , root ) ; changeVerifier . checkRecordedChanges ( passName , jsRoot ) ; }
if ( n . getFirstChild () . matchesQualifiedName ( Es6RewriteClass.INHERITS ) ) { inheritsCalls . add ( n ) ; }
parent . replaceChild ( node , NodeUtil . newUndefinedNode ( node ) ) ;
compiler . performOptimizations () ;
n . isName () && NodeUtil . isNameDeclaration ( searchIt . currentParent () ) && n . getString () . equals ( STRING_CONSTANT )
( NodeUtil . isNameDeclaration ( declaration . getParent () ) && ! NodeUtil . isLoopStructure ( declaration . getGrandparent () ) )
public HierarchicalSet ( HierarchicalSet < T > parent ) { this . parent = parent ; }
clinitsCalledAtBranch = new HierarchicalSet <> ( clinitsCalledAtBranch ) ;
JSType declType = this . currentScope . getDeclaredTypeOf ( name ) ;
NTIScope innerScope = this . currentScope . getScope ( fnName ) ;
lhs . isName () && this . currentScope . isConstVar ( lhs . getString () )
if ( ! this . currentScope . hasThis () ) { return new EnvTypePair ( inEnv , UNKNOWN ) ; }
return expr . isNew () || ( expr . isCall () && this . currentScope . isConstructor () && expr . getFirstChild () . isSuper () ) ;
JSType declType = this . currentScope . getDeclaredTypeOf ( name ) ;
JSType declRetType = this . currentScope . getDeclaredFunctionType () . getReturnType () ;
guardA . addGuard ( visibilityOff ) ;
checkState ( val . isObjectLit () , val ) ;
checkState ( object . isObjectLit () , object ) ;
checkState ( parent . getFirstChild () == name ) ;
Preconditions . checkState ( val . isObjectLit () ) ;
Preconditions . checkState ( object . isObjectLit () ) ;
Preconditions . checkState ( parent . getFirstChild () == name ) ;
checkState ( val . isObjectLit () , val ) ;
checkState ( object . isObjectLit () , object ) ;
checkState ( parent . getFirstChild () == name ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( ! t . getScope () . isHoistScope () ) { return; }
public InlineVariablesTest () { enableNormalize () ; setAcceptedLanguage ( ECMASCRIPT_NEXT ) ; }
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
@ Override void reportChangeToEnclosingScope ( Node n ) { recordChange ( getChangeScopeForNode ( n ) ) ; notifyChangeHandlers () ; }
{ return precedence ( n ) < minPrecedence ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
{ return NodeUtil . precedence ( n . getToken () ) < minPrecedence ; }
{ invalidatingPropRef = ! isValidCandidateDefinition ( t , n , parent ) ; }
TypeI type
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
checkArgument ( child.parent == null , STRING_CONSTANT , child , parent , this ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
checkState ( ! maybeDecl . isInitializingDeclaration () ) ;
checkState ( references . get ( NUMBER_CONSTANT ) . isDeclaration () ) ;
{ deepestModule = graph . getSmallestCoveringDependency ( ImmutableList . of ( m , deepestModule ) ) ; }
{ return precedence ( n ) < minPrecedence ; }
checkNotNull ( js ) ;
checkState ( collectionRoot . isScript () || collectionRoot . isRoot () ) ;
{ checkNotNull ( options ) ; return warningsGuard . level ( error ) ; }
{ checkState ( changeScopeRoot . isScript () || changeScopeRoot . isFunction () ) ; recordChange ( changeScopeRoot ) ; notifyChangeHandlers () ; }
if ( currentChangeScope != null ) { checkState ( currentChangeScope . isScript () || currentChangeScope . isFunction () ) ; recordChange ( currentChangeScope ) ; }
checkState ( passes instanceof DefaultPassConfig , STRING_CONSTANT ) ;
checkState ( input . isExtern () , STRING_CONSTANT , input . getName () ) ;
checkState ( currentTracer != null , STRING_CONSTANT ) ;
checkState ( currentTracer == null ) ;
{ checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
if ( ! compiler . hasErrors () ) { compiler . stage1AndStage2Passes () ; compiler . completeCompilation () ; }
if ( ! compiler . hasErrors () ) { compiler . stage1AndStage2Passes () ; compiler . completeCompilation () ; }
blockStack . get ( i ) . getRoot () == containingScope . getRootNode ()
if ( clone == null ) { verifyNewNode ( passNameMsg , n ) ; } else { verifyNodeChange ( passNameMsg , n , clone ) ; }
grandparent == null || ( ! isPrototypePropertyDeclaration ( grandparent ) && ! isPropertyDeclarationOnThis ( parent . getFirstChild () , currentScope ) )
Reference aliasRef = aliasRefs.references . get ( i ) ;
Reference ref
maybeTemporarilyLiveNodes . add ( expr ) ;
node . matchesQualifiedName ( name )
@ Nullable String newName
public InlineObjectLiteralsTest () { enableNormalize () ; setAcceptedLanguage ( ECMASCRIPT_NEXT ) ; }
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
{ return fromFile ( file , UTF_8 ) ; }
{ n . detach () ; }
if ( defined ) { compiler . reportChangeToEnclosingScope ( vnode . getParent () ) ; vnode . detach () ; }
{ parent . detach () ; }
return enclosingNode != null && ! enclosingNode . isFunction () ;
Node block = t . getScopeRoot () ;
return parent != null && parent . isAssign () && parent . getFirstChild () == n ;
parent . detach () ;
{ if ( isNamespacePlaceholder ( parent ) ) { compiler . reportChangeToEnclosingScope ( parent ) ; parent . detach () ; } }
{ parent . removeChild ( n ) ; if ( ! parent . hasChildren () ) { parent . detach () ; } }
assignmentParent . detach () ;
boolean isInClass = n . getParent () . isClassMembers () ;
@ Override public boolean isPropertyTestFunction ( Node call ) { return call . getFirstChild () . matchesQualifiedName ( STRING_CONSTANT ) ; }
{ parent . detach () ; }
qNameRoot != null && qNameRoot . matchesQualifiedName ( EXPORTS ) && NodeUtil . isLValue ( qNameRoot )
callbackBlock . detach () ;
onlyExport . detach () ;
if ( ! anc . getFirstChild () . matchesQualifiedName ( name ) ) { return Ref.Type.ALIASING_GET ; }
isASTNormalized () && constructorNameNode . isName ()
{ if ( alreadyRemoved ( n ) ) { continue; } compiler . reportChangeToEnclosingScope ( n ) ; n . detach () ; }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
checkState ( ! name . equals ( ARGUMENTS ) ) ;
checkArgument ( ! idPrefix . isEmpty () ) ;
{ checkState ( n . isName () , n ) ; n . setString ( newName ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
if ( currentScript.isModule ) { rewriteShortObjectKey ( t , n ) ; }
{ testWarning ( js , warning , LanguageMode.ECMASCRIPT_2015 ) ; }
shouldRemove ( t , nameNode )
if ( isConstToBeInferred ( jsdoc , name , false ) ) { jsdoc = pullJsdocTypeFromAst ( compiler , jsdoc , name ) ; }
CrossModuleReferenceCollector collector
CrossModuleReferenceCollector collector
CrossModuleReferenceCollector collector
public void testNgInjectAddsInjectToClassConstructor ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
{ if ( null == str ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . str = str . intern () ; }
this . quoteKeywordProperties = options . shouldQuoteKeywordProperties () ;
options . assumeStrictThis () || options . getLanguageIn () == ECMASCRIPT5_STRICT
if ( options . shouldAmbiguateProperties () && options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED ) { passes . add ( ambiguateProperties ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
@ Override public void setUp () { setLanguage ( ECMASCRIPT_NEXT , ECMASCRIPT_NEXT ) ; }
CrossModuleReferenceCollector collector = new CrossModuleReferenceCollector ( compiler , new Es6SyntacticScopeCreator ( compiler ) ) ;
builder . setTagAsStrict ( firstOutput && options . shouldEmitUseStrict () ) ;
public CompilerOptions setEmitUseStrict ( boolean emitUseStrict ) { this . emitUseStrict = Optional . of ( emitUseStrict ) ; return this ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT , error.description ) ;
assertEquals ( STRING_CONSTANT , error.description ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal t = new NodeTraversal ( compiler , finder , SyntacticScopeCreator . makeUntyped ( compiler ) ) ;
NodeTraversal t = new NodeTraversal ( compiler , null , new Es6SyntacticScopeCreator ( compiler ) ) ;
checkState ( reference . isName () ) ;
if ( checkUnusedLocals && unusedAssignment != null && ! isRead && ! hasErrors ) { checkForUnusedLocalVar ( v , unusedAssignment ) ; }
options . assumeStrictThis () || options . isStrictModeInput ()
ObjectsBuilder newObjs = new ObjectsBuilder () ;
public RemoveSuperMethodsPassTest () { super ( DEFAULT_EXTERNS ) ; }
while ( s.parent != null ) { if ( s . isDefinedLocally ( varName , false ) ) { return false ; } s = s.parent ; }
catch ( IllegalStateException e ) { assertEquals ( FixedPointGraphTraversal.NON_HALTING_ERROR_MSG , e . getMessage () ) ; }
catch ( MaxIterationsExceededException e ) { assertEquals ( STRING_CONSTANT + MAX_STEP + STRING_CONSTANT , e . getMessage () ) ; }
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , builder ) ; }
options . assumeStrictThis () || options . getLanguageIn () == ECMASCRIPT5_STRICT
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , registry , builder ) ; }
catch ( IOException e ) { compiler . report ( JSError . make ( COULD_NOT_DESERIALIZE_AST , filename ) ) ; }
options . assumeStrictThis () || options . isStrictModeInput ()
! NodeUtil . isValidQualifiedName ( compiler . getOptions () . getLanguageOut () , name )
key . isStringKey () && ! key . isQuotedString () && NodeUtil . isValidPropertyName ( compiler . getOptions () . getLanguageOut () , key . getString () )
Config.StrictMode strictMode = options . expectStrictModeInput () ? Config.StrictMode.STRICT : Config.StrictMode.SLOPPY ;
if ( options . expectStrictModeInput () ) { options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.ERROR ) ; }
return new InlineFunctions ( compiler , compiler . getUniqueNameIdSupplier () , options.inlineFunctions , options.inlineLocalFunctions , true , options . assumeStrictThis () || options . expectStrictModeInput () , options.assumeClosuresOnlyCaptureReferences , options.maxFunctionSizeAfterInlining ) ;
public CompilerOptions setStrictModeInput ( boolean isStrictModeInput ) { this . isStrictModeInput = Optional . of ( isStrictModeInput ) ; return this ; }
! NodeUtil . isValidQualifiedName ( compiler . getLanguageMode () , name )
Pattern . compile ( STRING_CONSTANT )
! NodeUtil . isValidQualifiedName ( compiler . getOptions () . getLanguageIn () , name )
key . isStringKey () && ! key . isQuotedString () && NodeUtil . isValidPropertyName ( compiler . getOptions () . getLanguageIn () , key . getString () )
String finalMessage = STRING_CONSTANT + message ;
STRING_CONSTANT + number + ( ! supported ? STRING_CONSTANT : STRING_CONSTANT ) + ( es6Modules ? STRING_CONSTANT : STRING_CONSTANT ) + ( typeScript ? STRING_CONSTANT : STRING_CONSTANT ) + STRING_CONSTANT
( ( FeatureSet ) other ) . supported == supported
this . number >= other.number && ( ! this . supported || other.supported )
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
{ if ( mockToString ) { return STRING_CONSTANT ; } return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
{ parent . replaceChild ( assignNode , IR . number ( NUMBER_CONSTANT ) . srcref ( assignNode ) ) ; }
builder . append ( STRING_CONSTANT ) ;
MemoizedTypedScopeCreator typedScopeCreator = getTypedScopeCreator () ;
MemoizedTypedScopeCreator getTypedScopeCreator () { return typedScopeCreator ; }
typedScopeCreator = new MemoizedTypedScopeCreator ( internalScopeCreator ) ;
scopeCreator = new MemoizedTypedScopeCreator ( new TypedScopeCreator ( compiler ) ) ;
MemoizedTypedScopeCreator scopeCreator
MemoizedTypedScopeCreator scopeCreator
{ foundNodes . add ( name ) ; }
{ this . names = names ; foundNodes = new HashSet <> () ; }
checkState ( inputs.length > NUMBER_CONSTANT ) ;
List < SourceFile > externsInputs = maybeCreateSources ( STRING_CONSTANT , externs ) ;
test ( compiler , null , createSources ( STRING_CONSTANT , expected ) , error , warning ) ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; disableMultistageCompilation () ; }
setFeatureSet ( options . getLanguageIn () . toFeatureSet () ) ;
this . setFeatureSet ( options . getLanguageIn () . toFeatureSet () ) ;
{ Compiler compiler = new Compiler () ; compiler . setFeatureSet ( acceptedLanguage . toFeatureSet () ) ; return compiler ; }
validateFeature ( Feature.NAMESPACE_DECLARATION , n ) ;
{ validateFeature ( Feature.AMBIENT_DECLARATION , n ) ; validateNodeType ( Token.DECLARE , n ) ; validateAmbientDeclarationHelper ( n . getFirstChild () ) ; }
{ validateFeature ( Feature.TYPE_ALIAS , n ) ; validateNodeType ( Token.TYPE_ALIAS , n ) ; validateChildCount ( n ) ; }
validateFeature ( Feature.ARROW_FUNCTIONS , n ) ;
validateFeature ( Feature.CLASSES , n ) ;
validateFeature ( Feature.INTERFACE , n ) ;
validateFeature ( Feature.TEMPLATE_LITERALS , n ) ;
validateFeature ( Feature.TEMPLATE_LITERALS , n ) ;
validateFeature ( Feature.MODULES , n ) ;
{ validateFeature ( Feature.ASYNC_FUNCTIONS , n ) ; validateNodeType ( Token.AWAIT , n ) ; validateWithinAsyncFunction ( n ) ; }
validateFeature ( Feature.GENERATORS , n ) ;
{ if ( options.skipNonTranspilationPasses ) { whitespaceOnlyPasses () ; if ( options . needsTranspilationFrom ( FeatureSet.ES6 ) ) { transpileAndDontCheck () ; } } else { check () ; } }
compiler . getOptions () . needsTranspilationFrom ( FeatureSet.ES6 )
compiler . getOptions () . needsTranspilationFrom ( FeatureSet.ES6 )
Node root2 = compiler . parseSyntheticCode ( STRING_CONSTANT , source ) ;
if ( options.dartPass && ! options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
options.rewritePolyfills = flags.rewritePolyfills && options . getLanguageIn () . toFeatureSet () . contains ( FeatureSet.ES6 ) ;
return replaceNode ( n , minCond . getMinimized ( MinimizationStyle.PREFER_UNNEGATED ) ) ;
int precedence
expectFeatures ( Feature.DESTRUCTURING , Feature.ARRAY_PATTERN_REST ) ;
! forTranspileOnly || ( compiler . getOptions () . getLanguageIn () . toFeatureSet () . contains ( FeatureSet.ES6 ) && TranspilationPasses . isScriptEs6OrHigher ( scriptRoot ) )
{ for ( Node singleRoot : root . children () ) { if ( TranspilationPasses . isScriptEs6OrHigher ( singleRoot ) ) { return true ; } } }
{ Preconditions . checkState ( script . isScript () ) ; if ( TranspilationPasses . isScriptEs6OrHigher ( script ) ) { return true ; } }
isScriptEs6OrHigher ( scriptRoot )
isScriptEs6OrHigher ( singleRoot )
{ if ( isScriptEs6OrHigher ( scriptRoot ) ) { for ( Callback callback : callbacks ) { NodeTraversal . traverseEs6 ( compiler , scriptRoot , callback ) ; } } }
{ if ( isScriptEs6OrHigher ( singleRoot ) ) { for ( Callback callback : callbacks ) { NodeTraversal . traverseEs6 ( compiler , singleRoot , callback ) ; } } }
return isConst && ! JsdocUtil . hasAnnotatedType ( jsdoc ) && ! NodeUtil . isNamespaceDecl ( nameNode ) ;
rhs . replaceWith ( IR . cast ( IR . number ( NUMBER_CONSTANT ) , JsdocUtil . getQmarkTypeJSDoc () ) . srcrefTree ( rhs ) ) ;
new Es6RewriteModules ( this ) . processFile ( root , forceRewrite ) ;
performPostCompilationTasks () ;
performPostCompilationTasks () ;
{ compiler . stage1Passes () ; if ( ! compiler . hasErrors () ) { compiler . stage2Passes () ; } compiler . performPostCompilationTasks () ; }
{ compiler . restoreState ( serializedInputStream ) ; if ( ! compiler . hasErrors () ) { compiler . stage2Passes () ; } compiler . performPostCompilationTasks () ; }
setFeatureSet ( featureSet . without ( Feature.MODULES ) ) ;
features . has ( Feature.MODULES )
STRING_CONSTANT + featureSet . version ()
for ( LanguageMode mode : LanguageMode . values () ) { if ( mode.featureSet . has ( feature ) ) { return mode ; } }
if ( expectedFeatures != null ) { assertFS ( result.features ) . contains ( expectedFeatures ) ; }
if ( expectedFeatures != null ) { assertFS ( result.features ) . contains ( expectedFeatures ) ; }
expectFeatures ( Feature.DESTRUCTURING ) ;
expectFeatures ( Feature.CLASSES , Feature.MEMBER_DECLARATIONS , Feature.CONST_DECLARATIONS , Feature.LET_DECLARATIONS ) ;
m.featureSet . has ( Feature.ASYNC_FUNCTIONS )
expectFeatures ( Feature.DESTRUCTURING , Feature.DEFAULT_PARAMETERS ) ;
expectFeatures ( Feature.MEMBER_DECLARATIONS ) ;
{ if ( ! compiler . getFeatureSet () . has ( feature ) ) { violation ( STRING_CONSTANT + feature , n ) ; } }
{ if ( isValidSimpleName ( name ) ) { return true ; } else { return mode . has ( Feature.KEYWORDS_AS_PROPERTIES ) && TokenStream . isKeyword ( name ) ; } }
features = features . with ( Feature.STRING_CONTINUATION ) ;
features = features . with ( feature ) ;
features = features . with ( feature ) ;
features = features . with ( Feature.SETTER ) ;
features = features . with ( Feature.GETTER ) ;
features = features . with ( Feature.KEYWORDS_AS_PROPERTIES ) ;
features = features . union ( factory . getFeatures () ) ;
{ features = features . union ( FeatureSet.TYPESCRIPT ) ; return nextToken () . type ; }
features = features . with ( Feature.DESTRUCTURING ) ;
features = features . with ( Feature.DESTRUCTURING ) ;
features = features . with ( Feature.ARRAY_PATTERN_REST ) ;
features = features . with ( Feature.DESTRUCTURING ) ;
features = features . with ( Feature.NEW_TARGET ) ;
features = features . with ( Feature.EXPONENT_OP ) ;
features = features . with ( Feature.ARROW_FUNCTIONS , Feature.ASYNC_FUNCTIONS ) ;
features = features . with ( Feature.ARROW_FUNCTIONS ) ;
if ( TokenType.STAR_STAR_EQUAL . equals ( operator.type ) ) { features = features . with ( Feature.EXPONENT_OP ) ; }
{ features = features . with ( Feature.TRAILING_COMMA ) ; if ( config.warnTrailingCommas ) { errorReporter . reportWarning ( commaToken.location.start , STRING_CONSTANT ) ; } }
features = features . with ( Feature.REST_PARAMETERS ) ;
features = features . with ( Feature.DEFAULT_PARAMETERS ) ;
features = features . with ( Feature.ASYNC_FUNCTIONS ) ;
features = features . with ( Feature.ASYNC_FUNCTIONS ) ;
features = features . with ( Feature.ASYNC_FUNCTIONS ) ;
if ( Keywords . isKeyword ( name.value ) ) { features = features . with ( Feature.KEYWORDS_AS_PROPERTIES ) ; }
{ if ( hasConditionalAncestor ( parent . getParent () ) ) { info . disallowMovement () ; } }
BitSet modules
Preconditions . checkArgument ( root . isRoot () , STRING_CONSTANT , root . getToken () ) ;
assertPrettyPrintSame ( STRING_CONSTANT + String . format ( STRING_CONSTANT , NUMBER_CONSTANT ) + STRING_CONSTANT ) ;
Node parse ( String js ) { return parse ( js , TypeInferenceMode.NEITHER ) ; }
String [] parts = path . split ( MODULE_SLASH ) ;
public void testConstTarget () { disableTypeCheck () ; testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , POLYMER_INVALID_DECLARATION ) ; }
private void assertNoWarningEs6 ( String js ) { testSame ( js ) ; }
private void assertAmbiguousEs6 ( String js ) { testSame ( js ) ; }
public void testAliasInModule () { enableUnusedLocalAssignmentCheck = true ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSame ( STRING_CONSTANT ) ;
public void testEs6Class_testMethod () { test ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExtractableExport4 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testExtractableExport3 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ test ( wrapInFunction ( original ) , wrapInFunction ( expected ) ) ; }
public void testGoogScopeClassOutput () { test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportEs6ArrowFunction () { test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportConst () { test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportLet () { test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
public void testRemoveRepeatedProperties () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveUnnecessaryBodies () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testConstPropagationPrivateProperties2 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testConstructorAlias4 () { testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorAlias3 () { testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGoogModuleWithEmptyDestructuringRequire () { testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , EXTRA_REQUIRE_WARNING ) ; }
testSame ( STRING_CONSTANT ) ;
testWarning ( STRING_CONSTANT , UNUSED_LABEL ) ;
testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ReplaceIdGenerators.CONDITIONAL_ID_GENERATOR_CALL ) ;
public void testClass () { testSame ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ReplaceIdGenerators.INVALID_GENERATOR_PARAMETER ) ; }
public void testRemovalMultipleAssignment3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemovalMultipleAssignment2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testDuplicate_destructuring () { testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , DUPLICATE_REQUIRE ) ; }
public void testDuplicate_shorthand () { testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , DUPLICATE_REQUIRE ) ; }
@ Override public void setUp () { injectNamespace = false ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testPassModule () { testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; mode = CheckRequiresForConstructors.Mode.FULL_COMPILE ; }
{ testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
{ testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
public void testBadObjectLiteralCast1 () { testWarning ( STRING_CONSTANT + STRING_CONSTANT , ClosureCodingConvention.OBJECTLIT_EXPECTED ) ; }
testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
public void testNullUndefined () { testWarning ( STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ; assertMismatches ( Collections . < TypeMismatch > emptyList () ) ; }
testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ;
testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ;
{ testWarning ( STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ; assertMismatches ( ImmutableList . of ( fromNatives ( STRING_TYPE , NUMBER_TYPE ) ) ) ; }
testWarning ( declarations + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
{ testWarning ( STRING_CONSTANT + params + STRING_CONSTANT + arguments + STRING_CONSTANT , type ) ; }
testWarning ( fooDfn + STRING_CONSTANT , WRONG_ARGUMENT_COUNT ) ;
public void testPathologicalCaseThatsOkAnyway () { testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , NAME_DEFINED_LATE_WARNING ) ; }
{ return ! found && ! n . isFunction () ; }
test ( STRING_CONSTANT , STRING_CONSTANT , null , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , null , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testNoWarning ( typedefExterns , code ) ;
testNoWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT , value ( STRING_CONSTANT ) ) ; testNoWarning ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testCustomBanUnknownThisProp2 () { configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testNoWarning ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testCustomRestrictThrow2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
{ allowSourcelessWarnings () ; configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
testNoWarning ( EXTERNS + STRING_CONSTANT , code + STRING_CONSTANT ) ;
testNoWarning ( code + STRING_CONSTANT ) ;
{ configuration = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
testNoWarning ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ) ) ;
testWarning ( input , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
testNoWarning ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ) ) ;
public void testViolationWhitelisted2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
public void testViolationWhitelisted1 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
testNoWarning ( STRING_CONSTANT ) ;
public void testNotViolation2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
{ testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
NodeTraversal unusedT
Node export = n . getFirstFirstChild () ;
public void testObjLit () { assertUnreachable ( STRING_CONSTANT ) ; }
if ( options . needsTranspilationFrom ( ES6 ) && ! options.skipTranspilationAndCrash ) { checks . add ( convertStaticInheritance ) ; }
catch ( IOException e ) { report ( JSError . make ( AbstractCompiler.READ_ERROR , input . getName () , e . getMessage () ) ) ; }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2017 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2017 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
defUse = new MustBeReachingVariableDef ( cfg , scope , compiler , scopeCreator ) ;
liveness = new LiveVariablesAnalysis ( cfg , functionScope , compiler , SyntacticScopeCreator . makeUntyped ( compiler ) ) ;
useDef = new MaybeReachingVariableUse ( cfg , scope , compiler , scopeCreator ) ;
LiveVariablesAnalysis liveness = new LiveVariablesAnalysis ( cfg , scope , compiler , t . getScopeCreator () ) ;
public void testObjectDestructuringDefaultVals () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringAssignNewVarNames () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringAssignWithoutDeclaration () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringBasicAssign () { testSame ( STRING_CONSTANT ) ; }
public void testArrayDestructuringVarAssign () { testSame ( STRING_CONSTANT ) ; }
public void testArrayDestructuringSwap () { testSame ( STRING_CONSTANT ) ; }
{ new GraphReachability <> ( controlFlowGraph , REACHABLE ) . compute ( controlFlowGraph . getEntry () . getValue () ) ; }
inheritsCall . useSourceInfoIfMissingFromForTree ( metadata.superClassNameNode ) ;
Node lp = scope . getParentScope () . getRootNode () . getSecondChild () ;
assertThat ( cssNames ) . isEqualTo ( expected ) ;
assertThat ( cssNames ) . isEqualTo ( expected ) ;
assertThat ( cssNames ) . isEqualTo ( expected ) ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; }
catch ( IOException | ClassNotFoundException e ) { compiler . report ( JSError . make ( COULD_NOT_DESERIALIZE_AST , filename ) ) ; }
public void testVarArguments () { testConsts ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; enableRunTypeCheckAfterProcessing () ; }
allowExternsChanges () ;
allowExternsChanges () ;
allowExternsChanges () ;
enableCheckAccessControls () ;
enableCheckAccessControls () ;
if ( transpileEnabled && ! compiler . hasErrors () ) { transpileToEs5 ( compiler , externsRoot , mainRoot ) ; }
public final String getFilename () { return filename ; }
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; }
disableCompareJsDoc () ;
public GatherRawExportsTest () { super ( EXTERNS ) ; }
public void testEs6ONoEs6 () { allowExternsChanges () ; testSame ( STRING_CONSTANT ) ; }
public Es6ExternsCheckTest () { super ( EXTERNS_BASE ) ; }
peepholePass . setRetraverseOnChange ( retraverseOnChange ) ;
public ProcessDefinesTest () { super ( DEFAULT_EXTERNS + STRING_CONSTANT ) ; }
{ enableTypeCheck () ; allowExternsChanges () ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT , POSSIBLE_INEXISTENT_PROPERTY ) ; }
public RemoveUnusedClassPropertiesTest () { super ( EXTERNS ) ; }
public RemoveUnusedVarsTest () { super ( STRING_CONSTANT ) ; }
this . runSmartNameRemoval = true ;
allowExternsChanges () ;
{ allowExternsChanges () ; test ( STRING_CONSTANT , STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , null , null ) ; }
{ declarationCheck = ! sanityCheck ; disableCompareAsTree () ; testExternChanges ( extern , input , expectedExtern ) ; }
allowExternsChanges () ;
public void testIssue () { allowExternsChanges () ; test ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
allowExternsChanges () ;
public void testProvideInExterns () { allowExternsChanges () ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public J2clCheckPassTest () { super ( DEFAULT_EXTERNS ) ; }
disableValidateAstChangeMarking () ;
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
allowExternsChanges () ;
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ disableCompareAsTree () ; super . testExternChanges ( input , expectedExtern ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; useGoogleCodingConvention = true ; }
Node assign = IR . assign ( windowPropAccess , nameNode . removeFirstChild () ) ;
{ value = key . removeFirstChild () ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
binaryNamespaceName . setOriginalName ( currentScript.legacyNamespace ) ;
binaryNamespaceName . setOriginalName ( currentScript.legacyNamespace ) ;
exportedNamespaceName . setOriginalName ( legacyNamespace ) ;
binaryNamespaceName . setOriginalName ( legacyNamespace ) ;
Node initializer = n . removeFirstChild () ;
Node extern = externs . removeFirstChild () ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
{ ModulesTestUtils . testModules ( this , input , STRING_CONSTANT + expected ) ; }
if ( caught . isArrayPattern () ) { validateArrayPattern ( Token.CATCH , caught ) ; } else { validateObjectPattern ( Token.CATCH , caught ) ; }
public void testNotStringLiteralConstantArgument3 () { testError ( CLOSURE_DEFS + STRING_CONSTANT , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ; }
public void testNotStringLiteralConstantArgument2 () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ; }
public void testNotStringLiteralConstantArgument1 () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ; }
public void testNotConstantArgument () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ; }
test ( options , source , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ;
shadowedVar != null && ! shadowedVar . getScope () . isModuleScope ()
shadowedVar != null && shadowedVar . isLocal ()
this . redeclarationHandler = DEFAULT_REDECLARATION_HANDLER ;
ScopeScanner ( AbstractCompiler compiler , Scope scope ) { this ( compiler , DEFAULT_REDECLARATION_HANDLER , scope ) ; }
public Es6SyntacticScopeCreator ( AbstractCompiler compiler , ScopeFactory scopeFactory ) { this ( compiler , DEFAULT_REDECLARATION_HANDLER , scopeFactory ) ; }
{ this . random = random ; reset ( ImmutableSet . < String > of () , STRING_CONSTANT , null ) ; }
int count = RandomNameGenerator.FIRST_CHAR . size () * ( RandomNameGenerator.NONFIRST_CHAR . size () + NUMBER_CONSTANT ) ;
int count = RandomNameGenerator.FIRST_CHAR . size () * ( RandomNameGenerator.NONFIRST_CHAR . size () + NUMBER_CONSTANT ) ;
NodeUtil . isNameDeclaration ( var . getParentNode () ) && ! var . getParentNode () . getParent () . isForIn ()
Scope scope = scopeCreator . createScope ( root , null ) ;
this . changeProxy = new AstChangeProxy ( compiler ) ;
NodeTraversal . traverseEs6 ( compiler , root , new RemoveNonDeclarations ( compiler ) ) ;
clonesByCurrent . clear () ;
for ( Assign assign : assignsByVar . get ( var ) ) { compiler . reportChangeToEnclosingScope ( assign.assignNode ) ; assign . remove ( compiler ) ; }
if ( hasExternsRoot () && n == externsRoot ) { externsScope = t . getScope () ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
if ( options . isChromePassEnabled () ) { checks . add ( chromePass ) ; }
options . setChromePass ( flags.chromePass ) ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
if ( visitFunction ( n , compiler ) ) { reportCodeChange ( n , STRING_CONSTANT ) ; }
{ if ( n . isFunction () ) { NormalizeStatements . visitFunction ( n , compiler ) ; } }
public void testRenameWithExterns1 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ; }
testSame ( externs , code ) ;
test ( modules , expected ( expected ) , warning ( warning ) ) ;
{ test ( srcs ( js ) , expected ( js ) ) ; }
{ test ( modules , expected ( expected ) , null ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( js ) , warning ( warning , description ) ) ; }
{ test ( srcs ( js ) , expected ( expected ) ) ; }
{ testSame ( externs , source ) ; assertEquals ( expected , found ) ; found . clear () ; }
testSame ( externs , js ) ;
{ testSame ( CompilerTestCase.ACTIVE_X_OBJECT_DEF , STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
testSame ( CompilerTypeTestCase.DEFAULT_EXTERNS , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , warning ( ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , warning ( ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ) ;
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR , message ) ) ;
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR , message ) ) ;
{ String externs = STRING_CONSTANT ; String code = STRING_CONSTANT ; testSame ( externs , code ) ; }
{ String externs = STRING_CONSTANT ; String code = STRING_CONSTANT ; testSame ( externs , code ) ; }
testError ( googModule , MISSING_MODULE_OR_PROVIDE , warning ) ;
public void testNamespaceResetInLocalScope2 () { test ( STRING_CONSTANT , STRING_CONSTANT , warning ( NAMESPACE_REDEFINED_WARNING ) ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
public void testNamespaceResetInLocalScope1 () { test ( STRING_CONSTANT , STRING_CONSTANT , warning ( NAMESPACE_REDEFINED_WARNING ) ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
public void testNamespaceResetInGlobalScope1 () { test ( STRING_CONSTANT , STRING_CONSTANT , warning ( NAMESPACE_REDEFINED_WARNING ) ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
{ setAcceptedLanguage ( lang ) ; test ( code , expected , warning ( warning ) ) ; }
{ test ( code , addLibraries ( code , libraries ) , warning ( warning ) ) ; }
{ testSame ( externs , STRING_CONSTANT ) ; assertEquals ( ImmutableSet . copyOf ( properties ) , getLastCompiler () . getExternProperties () ) ; }
testSame ( STRING_CONSTANT , STRING_CONSTANT ) ;
testWarning ( externs , js , ConstCheck.CONST_REASSIGNED_VALUE_ERROR ) ;
testSame ( externs , js ) ;
{ overrides . put ( STRING_CONSTANT , new Node ( Token.TRUE ) ) ; test ( STRING_CONSTANT , STRING_CONSTANT , warning ( ProcessDefines.UNKNOWN_DEFINE_WARNING ) ) ; }
{ overrides . put ( STRING_CONSTANT , new Node ( Token.TRUE ) ) ; test ( STRING_CONSTANT , STRING_CONSTANT , warning ( ProcessDefines.UNKNOWN_DEFINE_WARNING ) ) ; }
testSame ( OBJECT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( OBJECT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT ) ;
test . testError ( inputs , error ) ;
{ currentLocationAbstractionIdentifier = locationAbstractionIdentifier ; testSame ( SHARED_EXTERNS , js ) ; currentJsRoot = getLastCompiler () . jsRoot ; return currentAnalysis ; }
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
testSame ( ALL_NATIVE_EXTERN_TYPES , STRING_CONSTANT ) ;
{ testSame ( kExterns + extraExterns , source ) ; assertEquals ( expected , noSideEffectCalls ) ; noSideEffectCalls . clear () ; }
public void testIssue2508576_1 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testExternFunction () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testObjectLitExtern () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT , warning ( Es6TypedToEs6Converter.CANNOT_CONVERT_BOUNDED_GENERICS ) ) ;
testSame ( externs , STRING_CONSTANT ) ;
tester . testSame ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testGlobalAliasWithProperties5 () { testSame ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
testErrorExterns ( jsdoc + STRING_CONSTANT ) ;
public void testProvideInExterns () { allowExternsChanges () ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; }
{ test ( createModuleStar ( moduleInputs ) , expected ( expected ) , null ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
public void testEnum () { testSame ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSame ( METHOD_DEFS , STRING_CONSTANT ) ;
test ( externs , input , expected ) ;
test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ;
public void testRenameWithExterns2 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRenameWithExterns1 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ; }
testSame ( externs , js ) ;
testSame ( externs , js ) ;
testSame ( externs , js ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
{ testNoWarning ( js ) ; assertEquals ( fieldTypes , mapToString ( lastPass . getRenamedTypesForTesting () ) ) ; }
test ( DEFAULT_EXTERNS + externs , STRING_CONSTANT , STRING_CONSTANT ) ;
public void testSkipNativeFunctionMethod () { String js = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( js ) ; }
public void testJSDocDescInExterns () { testWarning ( STRING_CONSTANT , MISPLACED_MSG_ANNOTATION ) ; testSame ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( Es6RewriteModules . isEs6ModuleRoot ( root ) ) { moduleRewriter . processFile ( root ) ; }
Preconditions . checkState ( exportsNameNode . getString () . equals ( STRING_CONSTANT ) , exportsNameNode ) ;
Preconditions . checkArgument ( importNode . getFirstChild () . isDestructuringLhs () , importNode ) ;
Preconditions . checkState ( currentScript.defaultExportRhs == null , currentScript.defaultExportRhs ) ;
Preconditions . checkArgument ( n . isStringKey () , n ) ;
Preconditions . checkState ( scriptRoot . isScript () , scriptRoot ) ;
Preconditions . checkState ( c . isScript () , c ) ;
public void testES6VarAliasClassDeclarationWithoutNew () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testES6VarAliasClassDeclarationWithNew () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
if ( NodeUtil . isEnhancedFor ( parent ) ) { return; }
public void testSimpleConstAliasInCode () { testSame ( STRING_CONSTANT ) ; }
{ checkState ( error.node . getParent () . isStringKey () , error.node . getParent () ) ; fix . delete ( error.node . getParent () ) ; }
checkState ( regexMatcher . matches () , STRING_CONSTANT , error.description ) ;
checkState ( regexMatcher . matches () , STRING_CONSTANT , error.description ) ;
checkState ( fullNameMatcher . matches () , error.description ) ;
checkState ( name . isName () , name ) ;
mayWarnAboutGlobalThis ( expr ) ;
mayWarnAboutGlobalThis ( expr ) ;
T o
public HierarchicalSet ( @ Nullable HierarchicalSet < T > parent ) { this . parent = parent ; }
if ( isObjectLitOrCastOfObjectLit ( n ) && n . getParent () . isArrowFunction () ) { return true ; } else { return precedence ( n ) < minPrecedence ; }
{ for ( Var var : computeLiveness ( src ) . getEscapedLocals () ) { assertThat ( var.name ) . isNotEqualTo ( name ) ; } }
public void visitCallSite ( NodeTraversal t , Node callNode , FunctionState functionState ) ;
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
throw new IllegalStateException ( STRING_CONSTANT ) ;
Map < String , Node > map = new HashMap <> ( stringLiteralMatches ) ;
ScopeCreator creator = new MemoizedScopeCreator ( new Es6SyntacticScopeCreator ( compiler ) ) ;
ScopeCreator creator = new MemoizedScopeCreator ( new Es6SyntacticScopeCreator ( compiler ) ) ;
{ Preconditions . checkState ( expected == null ) ; expected = fromSources ( ( Sources ) part ) ; }
protected Sources srcs ( List < SourceFile > files ) { return new FlatSources ( files ) ; }
protected Sources srcs ( String [] srcTexts ) { return new FlatSources ( createSources ( STRING_CONSTANT , srcTexts ) ) ; }
protected Sources srcs ( String srcText ) { return new FlatSources ( maybeCreateSources ( filename , srcText ) ) ; }
{ test ( srcs ( modules ) , expected ( modules ) ) ; }
{ test ( srcs ( modules ) , expected ( expected ) ) ; }
{ test ( createModuleStar ( moduleInputs ) , expected ) ; }
builder . setTypeRegistry ( getTypeIRegistry () ) ;
validateChildCount ( n ) ;
@ Override protected FeatureSet featureSet () { return ES7_MODULES ; }
public Es6RewriteModules ( AbstractCompiler compiler ) { this . compiler = compiler ; }
@ Override protected FeatureSet featureSet () { return ES6_MODULES ; }
ModulesTestUtils . testModulesError ( this , STRING_CONSTANT , Es6RewriteModules.NAMESPACE_IMPORT_CANNOT_USE_STAR ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.ERROR ) ;
TypeI getEnumeratedTypeOfEnumObject ( ) ;
{ return STRING_CONSTANT + type . toMaybeObjectType () . getEnumeratedTypeOfEnumObject () . toNonNullAnnotationString () + STRING_CONSTANT ; }
@ Override public TypeI getEnumeratedTypeOfEnumObject () { return null ; }
if ( forAnnotations ) { return sb . append ( getReferenceName () ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
checkState ( sum > NUMBER_CONSTANT ) ;
checkState ( s instanceof TypedScope , STRING_CONSTANT ) ;
checkState ( curNode != null ) ;
checkNotNull ( parent ) ;
checkState ( s . isGlobal () || s . isModuleScope () ) ;
type = Name.Type.OTHER ;
{ super . setUp () ; compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6_TYPED ) ; this . mode = InputLanguageMode.TRANSPILATION ; }
if ( current . isDeclaredSloppy ( oldName , false ) ) { return; } else { current = current . getParent () ; }
if ( ! functionScope . isDeclaredSloppy ( name , false ) ) { return; }
{ return n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ! jsScope . isDeclaredSloppy ( ARGUMENT_ARRAY_ALIAS , false ) ; }
if ( ! jsScope . isDeclaredSloppy ( name , false ) ) { return; }
{ this . warningsGuard = new ComposeWarningsGuard ( new SuppressDocWarningsGuard ( this , getDiagnosticGroups () . getRegisteredGroups () ) , warningsGuard ) ; }
ScopeScanner ( AbstractCompiler compiler , Scope scope ) { this ( compiler , DEFAULT_REDECLARATION_HANDLER , scope , null ) ; }
new ScopeScanner ( compiler , redeclarationHandler , scope , null ) . populate () ;
undeclareInteral ( var ) ;
Es6SyntacticScopeCreator createInternalScopeCreator ( AbstractCompiler compiler ) { return new Es6SyntacticScopeCreator ( compiler , factory , factory ) ; }
NodeUtil . isAnyFor ( n )
{ logger . fine ( STRING_CONSTANT + scopeRoot ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopeNodes , this , false ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler , true ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () , true ) ; }
{ return new J2clClinitPrunerPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true , true ) ; }
checkArgument ( nameNode . isQualifiedName () ) ;
checkArgument ( functionNode . isFunction () ) ;
checkArgument ( nameNode . isQualifiedName () ) ;
checkState ( NodeUtil . isStatement ( statement ) , statement ) ;
checkState ( functionBody . isNormalBlock () ) ;
checkArgument ( paramList . isParamList () ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) { processRequire ( expr ) ; } else { checkState ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) ; }
void markConstructorToProcess ( Node ctorNode ) { checkArgument ( ctorNode . isFunction () , ctorNode ) ; constructorsToProcess . add ( ctorNode ) ; }
index < funType . getMaxArity ()
int getMaxArity ( ) ;
int getMinArity ( ) ;
{ if ( currentType . getMaxArity () <= expectedType . getMaxArity () ) { return expectedType ; } }
{ this ( res , new NumberValue ( op1 ) , o , op2 ) ; }
{ this ( res , op1 , o , new NumberValue ( op2 ) ) ; }
checkNotNull ( typeParameters ) ;
{ checkState ( this . nominalType == null ) ; this . nominalType = t ; return this ; }
{ checkState ( returnType == null ) ; returnType = t ; return this ; }
{ checkState ( restFormals == null ) ; restFormals = t ; return this ; }
checkArgument ( ! t . isBottom () ) ;
public FunctionTypeBuilder ( JSTypes commonTypes ) { this . commonTypes = checkNotNull ( commonTypes ) ; }
checkState ( noCycles ) ;
{ checkState ( parentClass . isInterface () ) ; warnings . add ( JSError . make ( funNode , CONFLICTING_EXTENDED_TYPE , STRING_CONSTANT , functionName ) ) ; }
checkState ( thisRoot . getToken () == Token.BANG ) ;
checkArgument ( params != null || jsdoc != null ) ;
checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
checkState ( e != null , STRING_CONSTANT + STRING_CONSTANT ) ;
checkState ( td != null , STRING_CONSTANT + STRING_CONSTANT ) ;
checkNotNull ( n ) ;
checkNotNull ( commonTypes ) ;
{ checkState ( isInterface () ) ; isStructuralInterface = flag ; }
checkArgument ( isConstructor () || isInterface () ) ;
checkNotNull ( that ) ;
checkArgument ( interfaceType . isInterface () ) ;
checkState ( scriptRoot . isScript () ) ;
{ checkState ( n . getParent () . getFirstChild () == n ) ; return n . getParent () . cloneTree () . getFirstChild () ; }
checkState ( parent . isCall () ) ;
checkState ( parent . isObjectLit () ) ;
{ checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ; this . compiler = compiler ; }
checkState ( child . hasOneChild () ) ;
{ checkState ( n . isName () , n ) ; n . removeFirstChild () ; }
checkState ( ! typeMap . isEmpty () ) ;
public JSType getRestFormalsType () { checkState ( restFormals != null ) ; return restFormals ; }
checkNotNull ( inputId ) ;
checkArgument ( n . isDo () ) ;
checkArgument ( n . isVanillaFor () ) ;
checkArgument ( n . isWhile () ) ;
{ checkState ( isExprConditional ( n ) ) ; return n . getFirstFirstChild () ; }
{ checkState ( isSimpleAssignment ( n ) ) ; return n . getFirstChild () . getLastChild () ; }
checkState ( isSimpleAssignment ( n ) ) ;
checkState ( n . isSwitch () , n ) ;
checkState ( subtree . isAssign () ) ;
checkState ( n . isTry () , n ) ;
checkNotNull ( paramType , STRING_CONSTANT ) ;
checkState ( n . isAssign () ) ;
checkNotNull ( name ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( callOrNew . isCall () || callOrNew . isNew () ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkArgument ( qName != null && ownerName != null ) ;
checkArgument ( ! variableName . isEmpty () ) ;
{ checkNotNull ( inputId ) ; sourceName = NodeUtil . getSourceName ( n ) ; }
checkState ( cycleCount != maxIterations , NON_HALTING_ERROR_MSG ) ;
checkState ( defParent . isExprResult () ) ;
checkArgument ( use . isName () ) ;
checkState ( t . getScopeRoot () . isFunction () ) ;
checkState ( options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED ) ;
{ checkArgument ( ! callbacks . isEmpty () ) ; return new CombinedCompilerPass ( compiler , callbacks ) ; }
if ( checks . contains ( closureGoogScopeAliases ) ) { checkState ( checks . contains ( checkVariableReferences ) , STRING_CONSTANT ) ; }
if ( pass1Index != - NUMBER_CONSTANT && pass2Index != - NUMBER_CONSTANT ) { checkState ( pass1Index < pass2Index , msg ) ; }
{ for ( PassFactory pass : passes ) { checkState ( ! pass . isOneTimePass () ) ; } }
{ for ( PassFactory pass : passes ) { checkState ( pass . isOneTimePass () ) ; } }
checkState ( behaviorObjLit . isObjectLit () ) ;
checkState ( behaviorObjLit . isObjectLit () ) ;
checkArgument ( objectType . isUnknownType () ) ;
checkNotNull ( errorRoot ) ;
checkArgument ( scriptNodeCount == NUMBER_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ;
checkState ( moduleNode . isModuleBody () ) ;
checkArgument ( parent . isModuleBody () , parent ) ;
checkArgument ( parent . isModuleBody () , parent ) ;
{ checkArgument ( isEs6ModuleRoot ( root ) , root ) ; clearState () ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
checkArgument ( scriptNode . isScript () ) ;
checkState ( objLit . isObjectLit () ) ;
checkState ( objLit . isObjectLit () ) ;
checkState ( DEFAULT_EXTERNS . length () != externs . length () ) ;
checkArgument ( n . isCall () ) ;
checkArgument ( subtree . isCall () ) ;
checkArgument ( subtree . isCall () ) ;
{ checkNotNull ( original ) ; return original != this . node || this . isChanged () ; }
{ checkState ( this . isNot () ) ; return ( normalizeChildren ( node , children ) [ NUMBER_CONSTANT ] ) . change () ; }
checkNotNull ( n . getParent () ) ;
checkState ( n . getParent () != null ) ;
{ checkNotNull ( edgeAnnotationStack , STRING_CONSTANT ) ; popAnnotations ( edgeAnnotationStack ) ; }
{ checkNotNull ( nodeAnnotationStack , STRING_CONSTANT ) ; popAnnotations ( nodeAnnotationStack ) ; }
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
checkNotNull ( name ) ;
checkArgument ( n . isFunction () ) ;
checkArgument ( NodeUtil . isCallOrNew ( call ) , STRING_CONSTANT ) ;
checkArgument ( function . isFunction () , STRING_CONSTANT ) ;
checkState ( value . getParent () == null ) ;
checkState ( DefinitionUseSiteFinder . isCallOrNewSite ( site ) ) ;
checkState ( compiler . getLifeCycleStage () == LifeCycleStage.NORMALIZED ) ;
{ checkState ( isVarBlock ( n ) ) ; return n . getFirstChild () ; }
{ checkState ( isReturnExpressBlock ( n ) ) ; return n . getFirstFirstChild () ; }
{ checkState ( isFoldableExpressBlock ( n ) ) ; return n . getFirstChild () ; }
checkArgument ( n . isNot () ) ;
checkState ( fnNode . isFunction () || type . isFunctionType () ) ;
checkNotNull ( registry ) ;
{ checkArgument ( ! ( scope instanceof TypedScope ) ) ; return new Arguments ( scope ) ; }
checkNotNull ( lValue ) ;
{ checkState ( parent == scope . getParent () ) ; }
checkState ( currentInfo != null ) ;
{ super ( source ) ; checkNotNull ( source ) ; this . excerpt = excerpt ; }
checkState ( newExpr . isNew () ) ;
checkState ( newExpr . isNew () ) ;
checkArgument ( fnNode . isFunction () ) ;
checkArgument ( unsafe != null ) ;
{ checkState ( ! NodeUtil . isFunctionObjectApply ( callNode ) ) ; argMap . put ( THIS_MARKER , NodeUtil . newUndefinedNode ( callNode ) ) ; }
checkNotNull ( thisType ) ;
checkState ( namespace . hasExternsRoot () ) ;
{ checkArgument ( namespace . hasExternsRoot () ) ; this . namespace = namespace ; return this ; }
checkState ( TokenStream . isJSIdentifier ( tempVarName ) ) ;
checkNotNull ( sourceString ) ;
checkState ( ! member . isStaticMember () ) ;
checkNotNull ( constructor ) ;
{ checkState ( hasProcessBeenRun , STRING_CONSTANT ) ; return definitionNodeByDefinitionSite . values () ; }
checkNotNull ( site ) ;
checkState ( ! hasProcessBeenRun , STRING_CONSTANT ) ;
{ checkState ( grandparent . isLabel () ) ; throw new IllegalStateException ( STRING_CONSTANT ) ; }
checkState ( functionBody . getParent () . isFunction () ) ;
checkArgument ( n . isLabel () ) ;
checkState ( n . isFunction () , n ) ;
checkState ( t . getScope () . isFunctionBlockScope () ) ;
{ checkState ( this . knownConstants . isEmpty () ) ; this . knownConstants = knownConstants ; }
{ checkState ( ! NodeUtil . isFunctionObjectApply ( callNode ) ) ; }
checkArgument ( callSiteType != CallSiteType.UNSUPPORTED ) ;
if ( type == DecompositionType.DECOMPOSABLE ) { return CallSiteType.DECOMPOSABLE_EXPRESSION ; } else { checkState ( type == DecompositionType.UNDECOMPOSABLE ) ; }
checkState ( this != callSiteType ) ;
checkState ( this != callSiteType ) ;
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
checkState ( fnRecursionName != null ) ;
checkArgument ( ! Iterables . isEmpty ( options ) , STRING_CONSTANT ) ;
{ checkNotNull ( realSource ) ; this . realSource = realSource ; this . reportParseErrors = reportParseErrors ; }
checkState ( initialization . getGrandparent () . isExprResult () ) ;
checkState ( value != null ) ;
checkState ( NodeUtil . isNameDeclaration ( varNode ) , varNode ) ;
checkArgument ( o instanceof DeferredCheck ) ;
checkArgument ( pname . isIdentifier () ) ;
checkState ( insideQualifiedName ) ;
checkNotNull ( type ) ;
checkArgument ( pname == null || pname . isIdentifier () ) ;
checkNotNull ( type ) ;
{ checkArgument ( ! varName . contains ( STRING_CONSTANT ) ) ; return env . putType ( varName , type ) ; }
{ checkArgument ( ! pname . contains ( STRING_CONSTANT ) ) ; return env . getType ( pname ) ; }
checkArgument ( expr . isNew () || expr . isCall () ) ;
checkArgument ( callNode . isCall () || callNode . isNew () ) ;
checkNotNull ( type ) ;
checkArgument ( thisExpr . isThis () ) ;
checkState ( propAccessNode . isGetProp () || propAccessNode . isGetElem () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( propAccessNode . isGetProp () || propAccessNode . isGetElem () ) ;
checkNotNull ( funType ) ;
checkState ( receiver == null || isFwd ) ;
checkState ( ! formalType . isBottom () ) ;
checkArgument ( call . isCall () ) ;
checkState ( logicalOp == Token.AND ) ;
checkState ( n != null , STRING_CONSTANT ) ;
TypeEnv outEnv = checkNotNull ( getOutEnv ( dn ) ) ;
if ( fnType . getFunType () == null ) { checkState ( fnType . isUnknown () ) ; return this . commonTypes . qmarkFunction () ; }
checkState ( qnameRoot . isName () ) ;
{ checkArgument ( usingNameNode . isName () ) ; return referencesByNameNode . get ( usingNameNode ) ; }
checkArgument ( otherLocation instanceof VisibilityBasedEffectLocation ) ;
checkArgument ( otherLocation instanceof VisibilityBasedEffectLocation ) ;
{ checkArgument ( isStorageNode ( node ) ) ; return NodeUtil . isLValue ( node ) ; }
checkArgument ( isStorageNode ( node ) ) ;
checkArgument ( variableReference . isName () ) ;
{ checkNotNull ( internalScopeCreator ) ; internalScopeCreator . patchGlobalScope ( topScope , scriptRoot ) ; }
checkArgument ( n . isFunction () ) ;
checkState ( variableNode != null ) ;
checkArgument ( n . getChildCount () > NUMBER_CONSTANT ) ;
{ checkNotNull ( isDisposalStack ) ; if ( ! isDisposalStack . isEmpty () ) { return isDisposalStack . peek () ; } return null ; }
{ checkNotNull ( isConstructorStack ) ; if ( ! isDisposalStack . isEmpty () ) { return isConstructorStack . peek () ; } return null ; }
checkArgument ( checkingPolicy != DisposalCheckingPolicy.OFF ) ;
{ checkState ( call . isCall () ) ; call . putBooleanProp ( Node.FREE_CALL , true ) ; return call ; }
{ checkState ( parent . isCall () ) ; compiler . report ( JSError . make ( parent , GOOG_CLASS_DESCRIPTOR_NOT_VALID ) ) ; }
checkNotNull ( reader ) ;
{ checkNotNull ( whitelist ) ; this . whitelist = normalizeWhitelist ( whitelist ) ; }
checkState ( isRegistered () ) ;
boolean isCorrectRegisterFunction ( TweakFunction registerFunction ) { checkNotNull ( registerFunction ) ; return this . registerFunction == registerFunction ; }
checkState ( firstScript . isScript () ) ;
Property nameProp = checkNotNull ( getOrCreateProperty ( n ) ) ;
{ checkArgument ( blockNode . isNormalBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
checkArgument ( assignedAt . isQualifiedName () ) ;
{ checkArgument ( lhs . isQualifiedName () ) ; writes . addLast ( new PropertyWrite ( lhs ) ) ; }
checkState ( this . namespaceType == null ) ;
checkArgument ( parent . isExprResult () ) ;
checkState ( ! NodeUtil . isObjectLitKey ( n ) ) ;
checkState ( expressionRoot != null ) ;
checkNotNull ( qualifiedName ) ;
checkArgument ( lastLink.nextLink == null ) ;
checkState ( parametersList . isParamList () ) ;
checkNotNull ( traversal ) ;
checkNotNull ( traversal ) ;
void setIn ( L in ) { checkNotNull ( in ) ; this . in = in ; }
checkState ( outBefore . size () == state.out . size () ) ;
void setOut ( L out ) { checkNotNull ( out ) ; this . out = out ; }
void setIn ( L in ) { checkNotNull ( in ) ; this . in = in ; }
{ this . compilerOptions = checkNotNull ( compilerOptions ) ; return this ; }
checkState ( fnNode . isFunction () ) ;
checkState ( callNode . isCall () ) ;
{ super ( registry , null , null , isNativeType , constructor . getTemplateTypeMap () ) ; checkNotNull ( constructor ) ; this . constructor = constructor ; }
{ checkState ( parent . isVar () ) ; parent . removeChild ( nameNode ) ; }
{ checkState ( NodeUtil . createsBlockScope ( root ) , scope ) ; symbolStack . push ( new NameContext ( anonymousNode , scope ) ) ; }
checkArgument ( object != null , STRING_CONSTANT ) ;
checkNotNull ( data ) ;
{ checkState ( fileName . equals ( file . getName () ) ) ; sourceFile = file ; }
checkState ( first . isString () ) ;
checkArgument ( nameNode . isName () ) ;
checkArgument ( ancestors.length > NUMBER_CONSTANT ) ;
checkNotNull ( t ) ;
public JSTypeExpression getTypeExprForErrorReporting () { checkState ( state == State.DURING_RESOLUTION ) ; return typeExpr ; }
checkState ( state != State.RESOLVED ) ;
public JSType getType () { checkState ( state == State.RESOLVED ) ; return type ; }
checkNotNull ( typeExpr ) ;
checkState ( compiler . getLifeCycleStage () == LifeCycleStage.NORMALIZED ) ;
checkState ( null == m . put ( type , top ) ) ;
checkState ( exportDefinition . hasInlinableName ( currentScript.exportsToInline . keySet () ) ) ;
checkState ( n . isScript () , n ) ;
checkState ( currentScript.willCreateExportsObject || currentScript.hasCreatedExportObject ) ;
checkArgument ( importNode . getFirstChild () . isDestructuringLhs () , importNode ) ;
checkState ( currentScript.defaultExportRhs == null , currentScript.defaultExportRhs ) ;
checkArgument ( n . isStringKey () , n ) ;
checkState ( scriptRoot . isScript () , scriptRoot ) ;
checkState ( c . isScript () , c ) ;
checkState ( returnNode . isReturn () , returnNode ) ;
{ checkArgument ( containsModule ( legacyNamespace ) ) ; return scriptDescriptionsByGoogModuleNamespace . get ( legacyNamespace ) . declareLegacyNamespace ; }
checkArgument ( NodeUtil . isGet ( n ) ) ;
checkState ( left . isString () ) ;
checkArgument ( n . isGetElem () ) ;
checkArgument ( n . isNew () ) ;
checkArgument ( n . isCall () ) ;
{ checkArgument ( n . isNew () ) ; if ( inForcedStringContext ( n ) ) { return tryFoldInForcedStringContext ( n ) ; } return n ; }
checkArgument ( node . isAdd () ) ;
checkArgument ( n . isAssign () ) ;
checkArgument ( n . isInstanceOf () ) ;
checkState ( n . hasOneChild () , n ) ;
checkArgument ( originalTypeofNode . isTypeOf () ) ;
checkState ( objLit . isObjectLit () ) ;
checkState ( objLit . isObjectLit () ) ;
checkState ( n . isScript () ) ;
checkState ( passName . equals ( logStats.pass ) ) ;
checkArgument ( mode != TracerMode.OFF , STRING_CONSTANT ) ;
checkArgument ( declaration . isName () || declaration . isStringKey () ) ;
{ checkState ( isCallOrNew ( call ) ) ; return getNthSibling ( call . getSecondChild () , index ) ; }
{ checkState ( function . isFunction () ) ; return getNthSibling ( function . getSecondChild () . getFirstChild () , index ) ; }
{ checkArgument ( fnNode . isFunction () ) ; return fnNode . getSecondChild () ; }
{ checkArgument ( n . isNormalBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
{ checkArgument ( n . isTry () ) ; return n . getSecondChild () ; }
{ checkArgument ( n . isTry () ) ; return n . getChildCount () == NUMBER_CONSTANT ; }
checkArgument ( NodeUtil . isObjectDefinePropertiesDefinition ( definePropertiesCall ) ) ;
{ checkState ( isLValue ( n ) ) ; lhsNodes . add ( n ) ; }
{ checkArgument ( function . isFunction () ) ; return isNameReferenced ( function . getLastChild () , STRING_CONSTANT , MATCH_NOT_THIS_BINDING ) ; }
{ checkArgument ( fn . isFunction () , fn ) ; return fn . getLastChild () ; }
checkState ( block . isNormalBlock () ) ;
checkState ( tryNode . isTry () ) ;
checkState ( n . isName () , n ) ;
checkState ( objlit . isObjectLit () ) ;
checkState ( n . isObjectLit () || n . isClassMembers () ) ;
{ checkState ( n . isNew () , n ) ; return n . isOnlyModifiesThisCall () ; }
{ checkState ( n . isCall () , n ) ; return ( n . getSideEffectFlags () & Node.FLAG_LOCAL_RESULTS ) > NUMBER_CONSTANT ; }
checkState ( node . hasTwoChildren () , node ) ;
{ checkArgument ( n . isClass () ) ; return n . getLastChild () ; }
checkState ( n . isFunction () || n . isClass () ) ;
checkState ( n . isFunction () || n . isClass () ) ;
checkArgument ( obj . isObjectLit () ) ;
{ checkState ( this . declaration == null ) ; this . declaration = ref ; }
if ( otherScopeParent == null ) { checkState ( globalScope == null , STRING_CONSTANT ) ; }
checkNotNull ( declNode ) ;
checkState ( fn . isConstructor () || fn . isInterface () ) ;
checkState ( fn . isConstructor () || fn . isInterface () ) ;
checkArgument ( NodeUtil . isVarDeclaration ( node ) ) ;
{ super ( IR . getprop ( IR . objectlit () , name . cloneNode () ) , true ) ; checkArgument ( name . isString () ) ; }
{ super ( inExterns ) ; checkArgument ( node . isAssign () ) ; assignment = node ; }
{ super ( node , inExterns ) ; checkArgument ( NodeUtil . isFunctionExpression ( node ) ) ; }
{ super ( inExterns ) ; checkArgument ( node . isFunction () ) ; function = node ; }
checkNotNull ( lValue ) ;
checkArgument ( destructuringLhs . isDestructuringLhs () ) ;
{ checkState ( lhs . isName () ) ; checkShortName ( t , lhs , callNode . getLastChild () . getString () ) ; }
checkState ( callNode . isCall () ) ;
checkState ( currentModule == null ) ;
checkState ( script . isScript () ) ;
checkState ( newReachable . getAnnotation () != REACHABLE ) ;
checkState ( n . isGetProp () , n ) ;
checkState ( isNamespacePlaceholder ( decl ) ) ;
checkState ( isNamespacePlaceholder ( decl ) ) ;
{ checkState ( newModule == minimumModule , STRING_CONSTANT ) ; }
checkArgument ( explicitNode != node ) ;
checkState ( n . isCall () ) ;
checkNotNull ( providedModule , n ) ;
checkState ( parent . isExprResult () ) ;
checkState ( n . isGetProp () , n ) ;
{ checkNotNull ( dep ) ; Preconditions . checkState ( dep != this , STRING_CONSTANT , this ) ; deps . add ( dep ) ; }
checkState ( inputs . contains ( other ) ) ;
checkState ( matches . size () == NUMBER_CONSTANT , matches ) ;
checkState ( currentStatement . isDo () ) ;
checkNotNull ( compiler ) ;
{ super ( registry , templateTypeMap ) ; setReferencedType ( checkNotNull ( referencedType ) ) ; }
{ checkState ( hasReferenceName () ) ; return getReferenceName () . hashCode () ; }
checkState ( caseBody . isNormalBlock () ) ;
checkState ( first . getString () . isEmpty () ) ;
checkState ( n . isName () , n ) ;
checkNotNull ( inputId ) ;
checkState ( other instanceof NominalType ) ;
{ checkArgument ( pname . isIdentifier () ) ; return this . rawType . getSubtypesWithProperty ( pname . getLeftmostName () ) ; }
{ checkArgument ( pname . isIdentifier () ) ; return this . rawType . isPropDefinedOnSubtype ( pname . getLeftmostName () ) ; }
checkState ( nt1.rawType . equals ( nt2.rawType ) ) ;
checkState ( this . rawType . equals ( other.rawType ) ) ;
checkState ( this . inheritsFromIObjectReflexive () && other . inheritsFromIObjectReflexive () ) ;
checkArgument ( other . isStructuralInterface () ) ;
checkState ( typeMap . size () == NUMBER_CONSTANT ) ;
checkState ( this . rawType . isFrozen () ) ;
{ checkState ( this . rawType . isFrozen () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
checkState ( this . rawType . isFrozen () ) ;
checkState ( isUninstantiatedGenericType () ) ;
checkState ( types . size () == typeParams . size () ) ;
public RawNominalType getRawNominalType () { checkState ( ! this . rawType . isFrozen () ) ; return this . rawType ; }
{ checkState ( n . isFunction () , n ) ; return true ; }
checkNotNull ( value ) ;
if ( invalidatingPropRef ) { checkNotNull ( propName ) ; invalidateProperty ( propName ) ; }
checkArgument ( ! values . isEmpty () ) ;
checkState ( n . isCall () , n ) ;
{ checkState ( child . getParent () == n ) ; normalizeNodeTypes ( child ) ; }
checkNotNull ( reference ) ;
public JSTypeExpression getTypeExprForErrorReporting () { checkState ( this . state == State.DURING_RESOLUTION ) ; return typeExpr ; }
checkState ( this . state != State.RESOLVED ) ;
public JSType getPropType () { checkState ( this . state == State.RESOLVED ) ; return enumPropType ; }
public JSType getEnumeratedType () { checkState ( this . state == State.RESOLVED ) ; return declaredType ; }
checkNotNull ( typeExpr ) ;
checkNotNull ( colorToNodeMap , STRING_CONSTANT ) ;
checkArgument ( propertyName . isString () ) ;
checkArgument ( superSet . isAssign () ) ;
private int getMaskForBitIndex ( int bitIndex ) { checkArgument ( bitIndex >= NUMBER_CONSTANT , STRING_CONSTANT ) ; return NUMBER_CONSTANT < < bitIndex ; }
checkArgument ( node . isGetProp () ) ;
checkNotNull ( preservedNamespaces , STRING_CONSTANT ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkState ( ! isDefined ( qnameNode ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkState ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkState ( s != null ) ;
{ checkArgument ( ! fnName . contains ( STRING_CONSTANT ) ) ; return getScopeHelper ( new QualifiedName ( fnName ) ) != null ; }
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( qnameNode . isQualifiedName () ) ;
{ checkState ( this . isTopLevel () ) ; this . unknownTypeNames = ImmutableSet . copyOf ( names ) ; }
boolean isPrototypeMethod () { checkArgument ( root != null ) ; return NodeUtil . isPrototypeMethod ( root ) ; }
checkNotNull ( declaredType ) ;
Node getBody () { checkArgument ( root . isFunction () ) ; return NodeUtil . getFunctionBody ( root ) ; }
checkNotNull ( commonTypes ) ;
checkNotNull ( clinitName ) ;
checkNotNull ( typei ) ;
checkArgument ( callSite . isCall () || callSite . isNew () ) ;
checkArgument ( callType == Token.CALL || callType == Token.NEW ) ;
checkArgument ( NodeUtil . isNameDeclaration ( node . getParent () ) ) ;
{ checkNotNull ( sideEffectInfo ) ; updateSideEffectsForNode ( sideEffectInfo , traversal , node , enclosingFunction ) ; }
checkNotNull ( functionInfo ) ;
checkNotNull ( cacheCall ) ;
this . compiler = checkNotNull ( compiler ) ;
checkArgument ( userOrderedInputs . containsAll ( rootInputs ) ) ;
checkState ( msgBuilder != null ) ;
checkState ( ! STRING_CONSTANT . equals ( projectId ) ) ;
checkState ( nameNode . isName () ) ;
checkArgument ( n . isAnd () || n . isOr () ) ;
checkNotNull ( replacementFnType ) ;
checkNotNull ( type ) ;
checkNotNull ( resultType ) ;
checkNotNull ( var ) ;
protected boolean isASTNormalized () { checkNotNull ( compiler ) ; return compiler . getLifeCycleStage () . isNormalized () ; }
{ checkNotNull ( compiler ) ; return compiler . areNodesEqualForInlining ( n1 , n2 ) ; }
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( result != null ) ;
checkState ( n . isNew () || n . isCall () ) ;
checkNotNull ( templateType , STRING_CONSTANT ) ;
checkState ( index >= NUMBER_CONSTANT ) ;
checkNotNull ( type ) ;
checkState ( node . isSuper () ) ;
checkArgument ( arrowFunction . isArrowFunction () ) ;
checkArgument ( ! envs . isEmpty () ) ;
{ checkArgument ( ! n . contains ( STRING_CONSTANT ) ) ; return typeMap . get ( n ) ; }
checkState ( typeMap . size () >= SIZE_THRESHOLD ) ;
{ checkState ( root . isRoot () ) ; if ( root . getChangeTime () != NUMBER_CONSTANT ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
if ( n . isScript () ) { checkState ( this . script == null ) ; this . script = n ; }
checkState ( root . isScript () ) ;
checkState ( root . isScript () ) ;
checkState ( script . isScript () ) ;
checkState ( script . isScript () ) ;
checkState ( script . isScript () ) ;
checkState ( script . isScript () ) ;
checkState ( ORDER_CODE_REPLACEMENTS . isOrdered ( replacements ) ) ;
checkState ( ORDER_CODE_REPLACEMENTS . isOrdered ( replacements ) ) ;
checkState ( options.sourceMapDetailLevel != null ) ;
checkState ( n . isNormalBlock () , n ) ;
checkState ( line >= NUMBER_CONSTANT ) ;
checkState ( sourceMapDetailLevel != null ) ;
checkState ( this . namespaceType == null ) ;
{ checkState ( m == null ) ; }
checkState ( line < nextLine || col <= nextCol ) ;
{ checkNotNull ( part , STRING_CONSTANT ) ; parts . add ( part ) ; return this ; }
checkNotNull ( name , STRING_CONSTANT ) ;
checkState ( scope . isFunctionScope () , scope ) ;
checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ;
checkNotNull ( compiler ) ;
checkNotNull ( name ) ;
checkState ( hasProcessBeenRun , STRING_CONSTANT ) ;
if ( doSanityChecks && sourceFile != null ) { checkState ( sourceFile . equals ( n . getSourceFileName () ) ) ; }
checkState ( token == JsDocToken.PIPE ) ;
checkArgument ( token == JsDocToken.LEFT_CURLY ) ;
checkArgument ( token == JsDocToken.LEFT_CURLY ) ;
checkState ( annotation == Annotation.IMPLEMENTS ) ;
checkNotNull ( inputId ) ;
checkNotNull ( inputId ) ;
checkNotNull ( data ) ;
{ super ( symbolName , value ) ; this . exportPath = checkNotNull ( exportPath ) ; }
checkArgument ( fn . isFunction () ) ;
{ checkState ( pathDefinition . isVar () ) ; pathDefinition . setJSDocInfo ( jsdoc ) ; }
{ checkState ( valueToExport . isObjectLit () ) ; initializer = createExternObjectLit ( valueToExport ) ; }
checkState ( node . isName () ) ;
public boolean isLive ( Var v ) { checkNotNull ( v ) ; return liveSet . get ( v.index ) ; }
checkNotNull ( other ) ;
{ checkNotNull ( other ) ; this . liveSet = ( BitSet ) other.liveSet . clone () ; }
Time ( String name ) { checkNotNull ( name ) ; this . name = name ; }
Event ( T value ) { checkNotNull ( value ) ; this . value = value ; }
checkArgument ( newSourceInd < sources . size () ) ;
checkArgument ( token.type == TokenType.STRING ) ;
{ checkState ( config.keepGoing == Config.RunMode.KEEP_GOING ) ; bodyNode = IR . block () ; }
checkArgument ( scriptNode . isScript () ) ;
checkState ( ret . isString () ) ;
checkState ( work . isEmpty () ) ;
checkState ( ! frozen ) ;
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
public ConstParamCheck ( AbstractCompiler compiler ) { this . compiler = checkNotNull ( compiler ) ; }
checkState ( meaning != null ) ;
{ super ( commonTypes ) ; this . objs = checkNotNull ( objs ) ; }
{ super ( commonTypes ) ; this . objs = checkNotNull ( objs ) ; }
@ Override protected ImmutableSet < EnumType > getEnums () { return checkNotNull ( enums ) ; }
@ Override protected ImmutableSet < ObjectType > getObjs () { return checkNotNull ( objs ) ; }
@ Override public final Iterable < TypeI > getParameterTypes () { return checkNotNull ( getFunType () ) . getParameterTypes () ; }
{ checkState ( this . isSingletonObj () ) ; return this . getNominalTypeIfSingletonObj () . isClassy () ; }
checkState ( this . isSingletonObj () ) ;
{ checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getPropertyDefSite ( propertyName ) ; }
{ checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getOwnPropertyDefSite ( propertyName ) ; }
checkState ( this . isSingletonObj () ) ;
checkState ( this . isSingletonObj () ) ;
{ checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getReturnType () ; }
{ checkState ( this . isFunctionType () ) ; return this . getFunTypeIfSingletonObj () . getMinArity () ; }
checkState ( this . isFunctionType () ) ;
{ checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getThisType () ; }
checkState ( this . isFunctionType () ) ;
{ checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getInstanceTypeOfCtor () != null ; }
checkState ( this . isFunctionType () ) ;
checkArgument ( pname . isIdentifier () ) ;
checkArgument ( pname . isIdentifier () ) ;
checkState ( ! getObjs () . isEmpty () ) ;
checkArgument ( type != null ) ;
checkNotNull ( arrayType ) ;
checkArgument ( pname . isIdentifier () ) ;
if ( getObjs () . isEmpty () ) { checkState ( ! getEnums () . isEmpty () ) ; return this ; }
checkState ( ! areSubtypes ) ;
checkNotNull ( type ) ;
checkState ( this . isSingletonObj () ) ;
checkState ( ! getObjs () . isEmpty () ) ;
private JSType ( JSTypes commonTypes ) { checkNotNull ( commonTypes ) ; this . commonTypes = commonTypes ; }
checkState ( node . isName () , node ) ;
public boolean isLive ( Var v ) { checkNotNull ( v ) ; return liveSet . get ( v.index ) ; }
checkNotNull ( other ) ;
{ checkNotNull ( other ) ; this . liveSet = ( BitSet ) other.liveSet . clone () ; }
checkNotNull ( keys ) ;
checkNotNull ( namedType ) ;
{ checkNotNull ( name ) ; nonNullableTypeNames . add ( name ) ; }
checkArgument ( source == null || source . isFunction () ) ;
checkState ( source . isFunction () , source ) ;
{ checkState ( namesToTypes . containsKey ( name ) ) ; register ( t , name ) ; }
{ checkArgument ( ! name . contains ( STRING_CONSTANT ) , STRING_CONSTANT ) ; namesToTypes . put ( name , type ) ; }
public TemplateType getObjectIndexKey () { checkNotNull ( iObjectIndexTemplateKey ) ; return this . iObjectIndexTemplateKey ; }
checkState ( NodeUtil . isNameDeclaration ( n ) ) ;
checkArgument ( ! members . isEmpty () , STRING_CONSTANT ) ;
checkArgument ( nt . isGeneric () , nt ) ;
checkArgument ( nameNode . getParent () . isVar () ) ;
checkArgument ( funNode . isFunction () ) ;
checkState ( n . isOr () || n . isAnd () ) ;
checkState ( n . isGetElem () ) ;
return checkNotNull ( funType ) . toFunctionType () ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkState ( declNode . isGetProp () ) ;
checkArgument ( fn . isFunction () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkNotNull ( lendsName ) ;
checkState ( qnameNode . isName () || qnameNode . isGetProp () ) ;
checkState ( qnameNode . isName () || qnameNode . isGetProp () ) ;
checkArgument ( fn . isFunction () ) ;
checkState ( ! fnName . contains ( STRING_CONSTANT ) ) ;
checkState ( qnameNode . isQualifiedName () ) ;
checkState ( qnameNode . isQualifiedName () ) ;
{ if ( maybeAssign . isAssign () ) { maybeAssign . putBooleanProp ( Node.ANALYZED_DURING_GTI , true ) ; } else { checkState ( maybeAssign . isExprResult () ) ; } }
checkState ( ! currentScope . isNamespace ( qname ) ) ;
{ PropertyDef propdef = checkNotNull ( getPropDefFromClass ( superType , pname ) ) ; inheritedPropDefs = ImmutableSet . of ( propdef ) ; }
{ JSType t = castTypes . get ( n ) ; checkNotNull ( t ) ; return t ; }
{ checkState ( renameStrategy == RenameStrategy.MAPPED ) ; return new MappedNameSupplier ( mappings ) ; }
checkNotNull ( refNode ) ;
checkState ( moduleSpecifier . isString () ) ;
{ checkState ( root . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
checkNotNull ( declaration ) ;
checkState ( parent . isClassMembers () ) ;
checkState ( parent . isObjectLit () ) ;
checkState ( obj instanceof AstChange ) ;
{ checkArgument ( value . isInterface () ) ; return new SubtypeCache ( this . m . with ( key , value ) ) ; }
{ checkState ( mayBeExpression ( expr ) ) ; return new Node ( token , expr ) ; }
checkState ( function . isFunction () ) ;
{ checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.SPREAD , expr ) ; }
checkState ( mayBeExpression ( value ) ) ;
{ checkState ( expr . isString () ) ; return new Node ( Token.REGEXP , expr ) ; }
for ( Node expr : exprs ) { checkState ( mayBeExpressionOrEmpty ( expr ) ) ; arraylit . addChildToBack ( expr ) ; }
checkState ( mayBeExpression ( target ) ) ;
for ( Node arg : args ) { checkState ( mayBeExpression ( arg ) ) ; newcall . addChildToBack ( arg ) ; }
for ( Node arg : args ) { checkState ( mayBeExpression ( arg ) , arg ) ; call . addChildToBack ( arg ) ; }
{ checkState ( name . isLabelName () ) ; return new Node ( Token.CONTINUE , name ) ; }
{ checkState ( name . isLabelName () ) ; return new Node ( Token.BREAK , name ) ; }
checkState ( finallyBody . isNormalBlock () ) ;
{ checkState ( ! name . isEmpty () ) ; return Node . newString ( Token.LABEL_NAME , name ) ; }
{ checkState ( body . isNormalBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
{ checkState ( mayBeExpression ( expr ) , expr ) ; return new Node ( Token.EXPR_RESULT , expr ) ; }
{ checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.RETURN , expr ) ; }
for ( Node stmt : stmts ) { checkState ( mayBeStatementNoReturn ( stmt ) ) ; paramList . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { checkState ( mayBeStatementNoReturn ( stmt ) ) ; block . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { checkState ( mayBeStatement ( stmt ) ) ; paramList . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { checkState ( mayBeStatement ( stmt ) ) ; block . addChildToBack ( stmt ) ; }
{ checkState ( mayBeStatement ( stmt ) ) ; Node block = new Node ( Token.BLOCK , stmt ) ; return block ; }
{ checkState ( param . isName () || param . isRest () ) ; paramList . addChildToBack ( param ) ; }
{ checkState ( param . isName () || param . isRest () ) ; return new Node ( Token.PARAM_LIST , param ) ; }
String aliasExpanded = checkNotNull ( aliasDefinition . getQualifiedName () ) ;
{ checkState ( ! aliasReference . hasChildren () ) ; aliasReference . addChildToFront ( replacement ) ; }
checkState ( subns.namespaceType != null ) ;
checkState ( this . namespaceType == null ) ;
checkState ( this . namespaceType == null ) ;
checkState ( ! prop . isOptional () ) ;
this . defSite = checkNotNull ( defSite ) ;
{ checkState ( templateJs == null , STRING_CONSTANT ) ; this . templateJs = refasterJsTemplate ; }
checkState ( templateJs == null , STRING_CONSTANT ) ;
checkArgument ( ctorType . isConstructor () ) ;
{ checkState ( parent . isFunction () ) ; parent . setJSType ( varType ) ; }
checkState ( n . isGetElem () , n ) ;
checkNotNull ( n ) ;
{ checkState ( nameNode . isQualifiedName () ) ; return nameNode . getLastChild () . getString () . startsWith ( STRING_CONSTANT ) ; }
checkState ( nameNode != null ) ;
checkState ( ! name . isEmpty () ) ;
checkState ( ! current.renameMap . containsKey ( name ) ) ;
checkNotNull ( interfaceType ) ;
checkNotNull ( node ) ;
checkArgument ( ! isIdentifier () ) ;
{ checkArgument ( ! isIdentifier () ) ; return new QualifiedName ( parts . subList ( NUMBER_CONSTANT , parts . size () ) ) ; }
checkArgument ( n . isCast () ) ;
checkState ( first . getParent () == last . getParent () ) ;
{ checkState ( n . getParent () . isGetProp () , n ) ; nodeToRename = n ; }
checkState ( parentNode . isNormalBlock () , STRING_CONSTANT ) ;
checkArgument ( mode != TypeInferenceMode.BOTH ) ;
checkArgument ( getCfg () . hasNode ( useNode ) ) ;
checkArgument ( n . isCall () || n . isNew () ) ;
checkState ( n . isNew () ) ;
checkState ( n . isCall () ) ;
checkState ( n . isCall () , n ) ;
checkArgument ( NodeUtil . isAssociative ( n . getToken () ) ) ;
checkArgument ( node . isGetProp () ) ;
checkState ( block . isNormalBlock () ) ;
checkArgument ( isZipEntry ( zipURL ) ) ;
checkState ( notAlreadyOutstanding ) ;
checkState ( Thread . currentThread () == startThread ) ;
checkArgument ( type instanceof TypeDeclarationNode ) ;
checkArgument ( functionName != null ) ;
checkArgument ( parameterName != null ) ;
checkState ( labeledVariable . isVar () ) ;
int exitCodeValue = checkNotNull ( exitCode ) ;
{ checkNotNull ( entryPoints ) ; this . entryPoints = entryPoints ; return this ; }
{ checkState ( NUMBER_CONSTANT == Iterables . size ( inputs ) ) ; return; }
checkState ( compiler . getOptions () . outputJs == OutputJs.NORMAL ) ;
checkState ( specs != null ) ;
checkState ( zipEntryName . contains ( filename ) ) ;
checkNotNull ( input ) ;
{ this . exitCodeReceiver = checkNotNull ( newExitCodeReceiver ) ; }
checkArgument ( inputsSupplier == null ^ modulesSupplier == null ) ;
checkState ( this . namespaceType == null ) ;
{ NominalType builtinObj = checkNotNull ( this . commonTypes . getObjectType () , STRING_CONSTANT ) ; protoNT = builtinObj ; }
checkState ( ! this . isFrozen ) ;
{ checkState ( ! this . isFrozen ) ; super . addProperty ( pname , defSite , type , isConstant ) ; }
checkState ( ! this . isFrozen ) ;
checkState ( ! this . isFrozen ) ;
checkState ( ! this . isFrozen ) ;
checkState ( ! this . isFrozen ) ;
checkState ( ! this . isFrozen ) ;
if ( isClass () ) { checkState ( this . name . equals ( STRING_CONSTANT ) ) ; return getAllPropsOfClass () ; }
checkState ( isInterface () ) ;
checkState ( isClass () ) ;
checkState ( ancestor . isInterface () ) ;
checkState ( ! this . isFrozen ) ;
checkState ( ancestor . isClass () ) ;
{ checkState ( ! this . isFrozen ) ; this . ctorFn = ctorFn ; }
public boolean isStruct () { checkState ( isFrozen () || isClass () ) ; return this . objectKind . isStruct () ; }
JSType getPrototypeObject () { checkState ( this . isFrozen ) ; return this . protoObject ; }
checkNotNull ( objectKind ) ;
checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
checkNotNull ( var ) ;
checkState ( function . isFunction () ) ;
checkState ( function . isFunction () ) ;
if ( modifyCallSites ) { checkNotNull ( defFinder ) ; callSiteOptimizer = new CallSiteOptimizer ( compiler , defFinder ) ; }
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
checkNotNull ( ref . getTwin () ) ;
checkState ( isObjKey || isQName ) ;
checkState ( ref.node . getParent () . isExprResult () ) ;
{ checkState ( languageIn != LanguageMode.NO_TRANSPILE ) ; this . languageIn = languageIn ; }
{ checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
checkNotNull ( entryPoints ) ;
{ checkArgument ( funAstSize > NUMBER_CONSTANT ) ; this . maxFunctionSizeAfterInlining = funAstSize ; }
checkState ( value instanceof String ) ;
checkState ( oldName . equals ( p.oldName ) ) ;
Map < String , String > getRenamingMap () { checkNotNull ( renamingMap ) ; return renamingMap ; }
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
checkArgument ( n . isScript () ) ;
checkState ( ! compiler . hasErrors () ) ;
{ checkArgument ( classNode . isClass () ) ; return classNode . getFirstChild () . isName () && parent . isName () ; }
{ checkArgument ( classByAlias . containsKey ( original ) ) ; classByAlias . put ( alias , classByAlias . get ( original ) ) ; }
checkState ( subclassMember . isAssign () , subclassMember ) ;
checkState ( staticGetProp . isGetProp () ) ;
checkArgument ( o instanceof ObjectType ) ;
checkArgument ( pname . isIdentifier () ) ;
checkArgument ( qname . isIdentifier () ) ;
checkArgument ( qname . isIdentifier () ) ;
{ checkArgument ( qname . isIdentifier () ) ; Property p = getLeftmostProp ( qname ) ; return p != null ; }
{ checkState ( p != null ) ; return p . getType () . getProp ( qname . getAllButLeftmost () ) ; }
checkNotNull ( this . ns ) ;
checkState ( isLoose || other.isLoose ) ;
checkNotNull ( pname ) ;
checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ;
checkNotNull ( resultNominalType ) ;
checkNotNull ( nominalType ) ;
{ return new ObjectType ( commonTypes , commonTypes . getObjectType () , checkNotNull ( commonTypes.BOTTOM_PROPERTY_MAP ) , null , null , false , ObjectKind.UNRESTRICTED ) ; }
checkNotNull ( dNode ) ;
checkNotNull ( dNode ) ;
checkState ( NodeUtil . isStatementBlock ( parent ) ) ;
checkArgument ( ret . isReturn () ) ;
checkArgument ( node . isNormalBlock () ) ;
checkArgument ( o instanceof Property ) ;
checkArgument ( inferredType != null ) ;
checkNotNull ( compiler ) ;
checkState ( isGeneric () ) ;
{ checkState ( isGeneric () ) ; return substituteParametricGenerics ( typeMap ) ; }
{ for ( String typeParam : this . typeParameters ) { checkState ( ! typeMap . containsKey ( typeParam ) ) ; } }
checkState ( this . isLoose () || f2 . isLoose () ) ;
{ checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ; f1 . isSubtypeOfHelper ( f2 , true , subSuperMap , boxedInfo ) ; }
checkArgument ( f1 . isLoose () || f2 . isLoose () ) ;
checkArgument ( ! isTopFunction () ) ;
{ checkState ( ! isTopFunction () ) ; return requiredFormals . size () ; }
{ checkState ( ! isTopFunction () ) ; return outerVarPreconditions . get ( name ) ; }
checkState ( ! isTopFunction () ) ;
public JSType getRestFormalsType () { checkNotNull ( restFormals ) ; return restFormals ; }
checkState ( isUniqueConstructor () ) ;
checkNotNull ( commonTypes ) ;
checkArgument ( call . isCall () ) ;
{ checkState ( script . isScript () ) ; visit ( script ) ; }
{ checkArgument ( groupIndex >= NUMBER_CONSTANT && groupIndex <= NUMBER_CONSTANT ) ; this . groupIndex = groupIndex ; }
{ Integer priority = priorities . get ( n ) ; checkNotNull ( priority ) ; return priority ; }
checkState ( handler . isTry () ) ;
checkState ( cur . getParent () != null , STRING_CONSTANT ) ;
{ checkState ( next . isCase () ) ; createEdge ( node , Branch.ON_FALSE , next ) ; }
{ checkState ( exceptionHandler . peek () == parent ) ; exceptionHandler . pop () ; }
checkArgument ( keyValPairs.length % NUMBER_CONSTANT == NUMBER_CONSTANT ) ;
checkArgument ( objectLit . isObjectLit () ) ;
checkState ( rootNode . isFunction () ) ;
checkNotNull ( prevUsedRenameMap . getNewNameToOriginalNameMap () ) ;
{ checkState ( this . newName == null ) ; this . newName = newName ; }
{ checkState ( this . fn == null ) ; this . fn = fn ; }
checkArgument ( changed != null ) ;
checkState ( functionState . hasExistingFunctionDefinition () ) ;
checkState ( n . isName () , n ) ;
checkState ( name . isName () ) ;
checkState ( NodeUtil . isGet ( child ) ) ;
checkArgument ( fn . isFunction () ) ;
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
{ checkState ( c . isScript () ) ; hotSwapScript ( c , null ) ; }
{ checkState ( ownerFunction == null || type == null ) ; ownerFunction = type ; }
checkArgument ( before . isExprResult () , STRING_CONSTANT ) ;
checkState ( descriptor . isObjectLit () ) ;
checkArgument ( js.length == NUMBER_CONSTANT , STRING_CONSTANT ) ;
{ JSModule module = input . getModule () ; checkNotNull ( module ) ; entryPointInputsPerModule . put ( module , input ) ; }
checkState ( n . isSwitch () ) ;
checkState ( allCatchNodes . hasOneChild () ) ;
checkState ( n . hasOneChild () , n ) ;
{ checkArgument ( compiler . getLifeCycleStage () . isNormalized () ) ; this . compiler = compiler ; }
public int getArgIndex () { checkState ( this . argIndex >= NUMBER_CONSTANT ) ; return this . argIndex ; }
public JSType getExpectedType () { return checkNotNull ( this . expected ) ; }
public JSType getFoundType () { return checkNotNull ( this . found ) ; }
public String getPropName () { return checkNotNull ( this . propName ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () ) ; }
{ return new J2clClinitPrunerPass ( compiler ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels () ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true ) ; }
EnvTypePair pair = analyzeExprFwd ( prop , recvLvalue.env , firstNonBottom ( indexType , UNKNOWN ) ) ;
builder . put ( typeParam , firstNonBottom ( t , UNKNOWN ) ) ;
pair = analyzeExprFwd ( index , pair.env , firstNonBottom ( indexType , UNKNOWN ) ) ;
{ builder . addRetType ( firstNonBottom ( actualRetType , TOP ) ) ; }
moduleResolutionMode = ModuleLoader.ResolutionMode.BROWSER ;
public void testEs6ThisWithImportModule () { testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , Es6CheckModule.ES6_MODULE_REFERENCES_THIS ) ; }
String result = STRING_CONSTANT ;
String result = STRING_CONSTANT + STRING_CONSTANT ;
if ( forAnnotations ) { return sb . append ( this . primitiveType ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler ) ; }
{ @ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler ) ; } }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new UnreachableCodeElimination ( compiler ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopeNodes , this , false ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler , true ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () , true ) ; }
{ return new J2clClinitPrunerPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true , true ) ; }
Node objectLit = n . getFirstChild () . getFirstFirstChild () ;
return new ParseResult ( root , comments , features , p . getSourceMapURL () ) ;
{ this ( config , errorReporter , source , offset , false ) ; }
@ Override MustDef createEntryLattice () { return new MustDef ( returnAllVars () ) ; }
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , builder ) ; }
{ if ( interf . inheritsFromIObjectReflexive () ) { result . add ( interf . substituteGenerics ( typeMap ) ) ; } }
for ( NominalType interf : this . rawType . getInterfaces () ) { result . add ( interf . substituteGenerics ( typeMap ) ) ; }
return this . rawType . getSuperClass () . substituteGenerics ( typeMap ) ;
return JSType . fromObjectType ( ObjectType . fromNominalType ( tmp . substituteGenerics ( typeMap ) ) ) ;
return nominal == null ? null : nominal . substituteGenerics ( this . commonTypes . MAP_TO_UNKNOWN ) . getInstanceAsJSType () ;
! invalidatingTypes . isInvalidating ( dest )
! props . containsKey ( propName ) && ! invalidatingTypes . isInvalidating ( type ) && NodeUtil . isImmutableValue ( value ) && NodeUtil . isExecutedExactlyOnce ( value )
{ fn = fn == null ? null : fn . withLoose () ; props = joinPropsLoosely ( obj1.props , obj2.props ) ; }
{ props = joinPropsLoosely ( obj1.props , obj2.props ) ; }
if ( doSlicing ) { pair.env = envPutType ( pair.env , name , firstNonNull ( declType , UNKNOWN ) ) ; }
preciseType = firstNonNull ( declType , requiredType ) ;
{ JSType result = ft . getSuperPrototype () ; pair.type = firstNonNull ( result , UNDEFINED ) ; return pair ; }
{ JSType tmp = t . getIndexedType () ; return firstNonNull ( tmp , UNKNOWN ) ; }
declRetType = firstNonNull ( declRetType , UNKNOWN ) ;
throw new IllegalStateException ( STRING_CONSTANT + name . getToken () ) ;
{ return new InstrumentFunctions ( compiler , compiler . getFunctionNames () , options.instrumentationTemplate , options.appNameStr ) ; }
{ compiler . setVariableMap ( runVariableRenaming ( compiler , prevVariableMap , externs , root ) ) ; }
compiler . setPropertyMap ( rprop . getPropertyMap () ) ;
compiler . setAnonymousFunctionNameMap ( naf . getFunctionMap () ) ;
{ return new CrossModuleMethodMotion ( compiler , compiler . getCrossModuleIdGenerator () , options.removeUnusedPrototypePropertiesInExterns , options.crossModuleCodeMotionNoStubMethods ) ; }
compiler . setStringMap ( pass . getStringMap () ) ;
compiler . setIdGeneratorMap ( pass . getSerializedIdMappings () ) ;
compiler . setFunctionNames ( pass . getFunctionNames () ) ;
compiler . setCssNames ( newCssNames ) ;
{ return new CrossModuleMethodMotion ( compiler , new IdGenerator () , canMoveExterns , noStubs ) ; }
public static Matcher googModuleOrProvide () { return anyOf ( googModule () , functionCall ( STRING_CONSTANT ) ) ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives || this . shouldGenerateTypedExterns () ; }
preserveClosurePrimitives = false ;
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
parseWarning ( STRING_CONSTANT , STRING_CONSTANT ) ;
skipStringLiteralEscapeSequence ( true ) ;
private boolean skipStringLiteralChar () { if ( peek ( CHAR_CONS ) ) { return skipStringLiteralEscapeSequence ( false ) ; } nextChar () ; return true ; }
objType == null || types . contains ( objType ) || objType . isAmbiguousObject () || objType . isUnknownType () || objType . isBottom ()
return objType . isAmbiguousObject () || ( ft != null && ft . isConstructor () && isInvalidatingType ( ft . getInstanceType () ) ) ;
return isUnknown () || ( isAmbiguousObject () && isLoose () ) || ( ft != null && ft . isTopFunction () ) ;
TypeI type
TypeI type
TypeI type
boolean mustReplaceThisAndArguments () { return isAsyncContext () || thisAndArgumentsContext . isAsyncContext () ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
checkArgument ( expr . isCall () || expr . isTaggedTemplateLit () ) ;
checkArgument ( n . isFunction () || ( n . isName () && NodeUtil . isInvocationTarget ( n ) ) ) ;
return analyzeInvocationArgsFwdWhenError ( call , inEnv ) ;
parent . getParent () . isCall () && NodeUtil . isInvocationTarget ( parent )
{ checkArgument ( ! pname . contains ( STRING_CONSTANT ) , pname ) ; return env . getType ( pname ) ; }
for ( FunctionTypeI impl : constructor . getDirectSubTypes () ) { list . add ( impl . getInstanceType () ) ; }
if ( constructor != null ) { for ( FunctionTypeI subType : constructor . getDirectSubTypes () ) { addRelatedInstance ( subType , related ) ; } }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveGoogProvidesAndRequires || this . shouldGenerateTypedExterns () ; }
preserveGoogProvidesAndRequires = false ;
options . setWarningLevel ( DiagnosticGroups.UNNECESSARY_ESCAPE , CheckLevel.WARNING ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.TEMPLATE_ARGUMENT_MISSING ) ;
testSame ( TEST_EXTERNS + externs , STRING_CONSTANT , GlobalTypeInfoCollector.REDECLARED_PROPERTY ) ;
testSame ( TEST_EXTERNS + externs , STRING_CONSTANT , GlobalTypeInfoCollector.REDECLARED_PROPERTY ) ;
globalTypeInfo = compilerState.globalTypeInfo ;
this . globalTypeInfo = compiler.globalTypeInfo ;
return getGlobalTypeInfo () . getImplicitInterfaceUses () ;
return getGlobalTypeInfo () . getMismatches () ;
globalTypeInfo = null ;
@ Override protected CompilerPass create ( final AbstractCompiler compiler ) { return new GlobalTypeInfoCollector ( compiler ) ; }
passes . add ( makePassFactory ( STRING_CONSTANT , new GlobalTypeInfoCollector ( compiler ) ) ) ;
this . symbolTable = ( GlobalTypeInfo ) compiler . getGlobalTypeInfo () ;
testSame ( DEFAULT_EXTERNS , STRING_CONSTANT , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ;
test ( options , STRING_CONSTANT , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ;
typeCheck ( js , GlobalTypeInfoCollector.CTOR_IN_DIFFERENT_SCOPE , NewTypeInference.MISTYPED_ASSIGN_RHS ) ;
typeCheck ( js , GlobalTypeInfoCollector.ANONYMOUS_NOMINAL_TYPE , GlobalTypeInfoCollector.ANONYMOUS_NOMINAL_TYPE , NewTypeInference.MISTYPED_ASSIGN_RHS ) ;
typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.INEXISTENT_PARAM ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfoCollector.WRONG_PARAMETER_COUNT ) ;
public void testUnknownTypeReferenceDoesntCrash () { typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ; }
typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.INEXISTENT_PARAM ) ;
public void testVarDecls () { typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.ONE_TYPE_FOR_MANY_VARS ) ; typeCheck ( STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; typeCheck ( STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; }
typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ;
typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ;
ignoreWarnings ( GlobalTypeInfoCollector.INTERFACE_METHOD_NOT_IMPLEMENTED , TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfoCollector.INVALID_PROP_OVERRIDE ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) , getRequiresEs6Message ( Feature.ARRAY_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) , getRequiresEs6Message ( Feature.ARRAY_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.TRAILING_COMMA ) ) ;
parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.TRAILING_COMMA ) ) ;
parseWarning ( js , warning ) ;
@ Nullable Node ast
features = factory . getFeatures () ;
ImmutableMap . < Pattern , DiagnosticType > builder () . put ( Pattern . compile ( STRING_CONSTANT + STRING_CONSTANT ) , TRAILING_COMMA )
{ features = features . with ( Feature.ACCESSIBILITY_MODIFIER ) ; return nextToken () . type ; }
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) ) ;
parseWarning ( STRING_CONSTANT , TRAILING_COMMA_MESSAGE ) ;
parseWarning ( STRING_CONSTANT , TRAILING_COMMA_MESSAGE ) ;
parseWarning ( js , warning , warning ) ;
Node ast
features = features . union ( factory . getFeatures () ) ;
ImmutableMap . < Pattern , DiagnosticType > builder () . put ( Pattern . compile ( STRING_CONSTANT ) , TRAILING_COMMA )
{ features = features . union ( FeatureSet.TYPESCRIPT ) ; return nextToken () . type ; }
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new CheckMissingAndExtraRequires ( compiler , CheckMissingAndExtraRequires.Mode.FULL_COMPILE ) ; }
new CheckMissingAndExtraRequires ( compiler , CheckMissingAndExtraRequires.Mode.SINGLE_FILE )
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckMissingAndExtraRequires ( compiler , CheckMissingAndExtraRequires.Mode.FULL_COMPILE ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new CheckMissingAndExtraRequires ( compiler , CheckMissingAndExtraRequires.Mode.SINGLE_FILE ) ; }
public void testFailGoogArray () { mode = CheckMissingAndExtraRequires.Mode.SINGLE_FILE ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testFailConstant () { mode = CheckMissingAndExtraRequires.Mode.SINGLE_FILE ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckMissingAndExtraRequires ( compiler , mode ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; mode = CheckMissingAndExtraRequires.Mode.FULL_COMPILE ; }
if ( current . isDeclared ( oldName , false ) ) { return; } else { current = current . getParent () ; }
if ( ! functionBlockScope . isDeclaredInFunctionBlockOrParameter ( name ) ) { return; }
{ return n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ! jsScope . isDeclared ( ARGUMENT_ARRAY_ALIAS , false ) ; }
if ( ! jsScope . isDeclared ( name , false ) ) { return; }
n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ( ! jsScope . isDeclared ( ARGUMENT_ARRAY_ALIAS , false ) || ! childDeclared )
assertTrue ( fBlockScope . isDeclaredInFunctionBlockOrParameter ( STRING_CONSTANT ) ) ;
assertTrue ( fBlockScope . isDeclaredInFunctionBlockOrParameter ( STRING_CONSTANT ) ) ;
assertTrue ( fBlockScope . isDeclaredInFunctionBlockOrParameter ( STRING_CONSTANT ) ) ;
public static Matcher googModuleOrProvide () { return anyOf ( googModule () , functionCall ( STRING_CONSTANT ) ) ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives || this . shouldGenerateTypedExterns () ; }
preserveClosurePrimitives = false ;
maybeProcessAccessibilityModifier ( tree , member , tree.access ) ;
maybeProcessAccessibilityModifier ( tree , n , tree.access ) ;
maybeProcessAccessibilityModifier ( functionTree , member , functionTree.access ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; enableTranspile () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; enableTranspile () ; }
{ env = analyzeExprBwd ( prop , env , enumeratedType ) . env ; }
EnvTypePair pair = analyzeExprBwd ( prop , env , reqPtype ) ;
EnvTypePair pair = analyzeExprFwd ( prop , env , enumeratedType ) ;
EnvTypePair pair = analyzeExprFwd ( prop , env , reqPtype , specPtype ) ;
PropertyDef propdef = checkNotNull ( getPropDefFromClass ( superType , pname ) , STRING_CONSTANT , superType , pname ) ;
return state . getOut () . mayUseMap . get ( allVarsInFn . get ( name ) ) ;
return state . getIn () . reachingDef . get ( allVarsInFn . get ( name ) ) ;
Var dep = allVarsInFn . get ( n . getString () ) ;
@ Override MustDef createEntryLattice () { return new MustDef ( allVarsInFn . values () ) ; }
Collection < Var > vars
{ Pattern pattern = new Pattern () ; pattern.regExp = new RegExp ( string ) ; return pattern ; }
node = new Node < E > ( e ) ;
Map < Node < E > , ImmutableSet.Builder < E > > groupsTmp = Maps . newLinkedHashMap () ;
@ Nullable E e
@ Override public void add ( @ Nullable E e ) { union ( e , e ) ; }
{ for ( E elem : other . elements () ) { union ( other . find ( elem ) , elem ) ; } }
public void testUnusedLocalConst_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; }
public void testUnusedLocalConst () { enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; }
public void testUnusedLocalLet_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; }
{ enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; assertUnused ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
assertUnused ( STRING_CONSTANT ) ;
public void testDefaultParam_withES6Modules () { assertEarlyReferenceError ( STRING_CONSTANT ) ; assertNoWarning ( STRING_CONSTANT ) ; }
public void testES6Module_destructuring () { enableUnusedLocalAssignmentCheck = true ; assertNoWarning ( STRING_CONSTANT ) ; }
public void testUnusedCompoundAssign_withES6Modules () { assertNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testUsedInShorthandObjLit_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUndeclared ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
assertUndeclared ( STRING_CONSTANT ) ;
public void testForOf () { assertEarlyReferenceError ( STRING_CONSTANT ) ; assertNoWarning ( STRING_CONSTANT ) ; }
public void testRedeclare_withES6Modules () { assertRedeclare ( STRING_CONSTANT ) ; assertNoWarning ( STRING_CONSTANT ) ; }
assertNoWarning ( STRING_CONSTANT ) ;
NodeUtil . isNameDeclaration ( parent )
@ Nullable Pattern includeFilePattern
{ overrideDefines ( collectDefines ( externs , root ) ) ; }
new ProcessDefines ( compiler , ImmutableMap . copyOf ( replacements ) , options.checksOnly ) . injectNamespace ( namespaceForChecks ) . process ( externs , jsRoot ) ;
Set < String > defines = new ProcessDefines ( compiler , null , false ) . collectDefines ( externs , root ) . keySet () ;
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
ImmutableSet . of ( TokenType.IDENTIFIER , TokenType.TYPE , TokenType.DECLARE , TokenType.MODULE , TokenType.NAMESPACE ) . contains ( type )
! peekId () && ! ImmutableSet . of ( TokenType.VOID , TokenType.OPEN_PAREN , TokenType.OPEN_CURLY , TokenType.TYPEOF ) . contains ( peekType () )
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.ES3 ; }
Function < Node , Void > recordPropertyName
recordPropertyName ( getProp . getLastChild () ) ;
recordPropertyName ( prop ) ;
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
new ProcessDefines ( compiler , ImmutableMap . copyOf ( replacements ) , ! options.checksOnly ) . injectNamespace ( namespaceForChecks ) . process ( externs , jsRoot ) ;
new ProcessDefines ( compiler , overrides , doReplacements ) . injectNamespace ( namespace ) . process ( externs , js ) ;
Set < String > defines = new ProcessDefines ( compiler , null , true ) . collectDefines ( externs , root ) . keySet () ;
n . isName () && isDeclaration ( n )
public boolean isAsyncFunction () { return isFunction () && getBooleanProp ( ASYNC_FN ) ; }
public boolean isArrowFunction () { return isFunction () && getBooleanProp ( ARROW_FN ) ; }
if ( key . isEmpty () || key . isComputedProp () ) { continue; }
invalidatingTypes . isInvalidating ( recvType ) || isStructuralInterfacePrototype ( recv )
{ if ( invalidatingTypes . isInvalidating ( type ) ) { invalidate () ; return false ; } rootTypesByNode . put ( node , type ) ; }
if ( invalidatingTypes . isInvalidating ( top ) ) { invalidate () ; return; }
new PolymerPass ( compiler , NUMBER_CONSTANT , true ) . process ( externs , root ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerPassStaticUtils . extractProperties ( behaviorValue , PolymerClassDefinition.DefinitionType.ObjectLiteral , compiler )
List < MemberDefinition > properties = PolymerPassStaticUtils . extractProperties ( behaviorValue , PolymerClassDefinition.DefinitionType.ObjectLiteral , compiler ) ;
new PolymerPass ( compiler , NUMBER_CONSTANT , false ) . process ( externsRoot , mainRoot ) ;
rhs . matchesQualifiedName ( ABSTRACT_METHOD_NAME ) || ( GlobalTypeInfoCollector . isCtorDefinedByCall ( lhs ) && ! isFunctionBind ( rhs . getFirstChild () , inEnv , true ) )
( GlobalTypeInfoCollector . isCtorDefinedByCall ( nameNode ) && ! isFunctionBind ( rhs . getFirstChild () , inEnv , true ) )
Property p = this . rawType . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
Property p = this . rawType . getOwnProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
if ( maybeWin != null ) { return maybeWin . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ; }
( ns . hasStaticProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , propDeclType , previousPropType ) )
isCtorDefinedByCall ( getProp )
classType . hasStaticProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , propDeclType , previousPropType )
isCtorDefinedByCall ( nameNode )
Property p = getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
Property p = getPropFromClass ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
return this . nominalType . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
if ( nom != null ) { return nom . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ; }
{ return new PeepholeOptimizationsPass ( compiler , getName () , new ExploitAssigns () ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return createPeepholeOptimizationsPass ( compiler , getName () ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return createPeepholeOptimizationsPass ( compiler , getName () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeRemoveDeadCode () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , getName () , new ExploitAssigns () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeCollectPropertyAssignments () ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeSubstituteAlternateSyntax ( late ) ) ;
final CompilerPass simplifier = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeSimplifyRegExp () ) ;
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeRemoveDeadCode () ) ;
{ return new PeepholeOptimizationsPass ( compiler , getName () , new ReorderConstantExpression () ) ; }
{ PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new StatementFusion ( favorsCommas ) ) ; return peepholePass ; }
computeEscapedEs6 ( jsScope , escaped , compiler , scopeCreator ) ;
computeEscapedEs6 ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
computeEscapedEs6 ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
if ( isObjLit ) { declareVariablesForObjLitValues ( n , alias , rvalue , varNode , varNode . getPrevious () , varParent ) ; }
super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( node ) ) ;
super ( isExtern , NameBasedDefinitionProvider . getSimplifiedName ( getLValue ( name ) ) ) ;
{ super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( node . getFirstChild () ) ) ; checkArgument ( node . isAssign () ) ; assignment = node ; }
{ super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( node . getFirstChild () ) ) ; Preconditions . checkArgument ( node . isClass () ) ; c = node ; }
{ super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( node . getFirstChild () ) ) ; checkArgument ( node . isFunction () ) ; function = node ; }
super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( lValue ) ) ;
Property p = this . rawType . getProp ( pname , PropAccess.EXCLUDE_STRAY_PROPS ) ;
if ( maybeWin != null ) { return maybeWin . getProp ( pname , PropAccess.EXCLUDE_STRAY_PROPS ) ; }
superType . isInterface () && current . isClass () && ! isCtorDefinedByCall ( current ) && ! current . mayHaveNonStrayProp ( pname )
superClass . isAbstractClass () && superClass . hasAbstractMethod ( pname ) && ! rawType . isAbstractClass () && ! rawType . mayHaveOwnNonStrayProp ( pname )
@ Override public boolean apply ( Node n ) { return isFunctionDeclaration ( n ) || NodeUtil . isNameDeclaration ( n ) ; }
NodeUtil . isNameDeclaration ( parent )
NodeUtil . isNameDeclaration ( n . getParent () )
NodeUtil . isNameDeclOrSimpleAssignLhs ( n , parent )
if ( NodeUtil . isNameDeclOrSimpleAssignLhs ( n , parent ) ) { if ( referring != null ) { recordReference ( referringName , name , RefType.REGULAR ) ; } return; }
{ if ( NodeUtil . isNameDeclOrSimpleAssignLhs ( parent , grandparent ) ) { validProperties . add ( propName ) ; } else { return false ; } }
NodeUtil . isNameDeclOrSimpleAssignLhs ( n , n . getParent () )
! NodeUtil . isNameDeclOrSimpleAssignLhs ( callNode , parent )
if ( NodeUtil . isNameDeclOrSimpleAssignLhs ( n , parent ) ) { return; }
dest . isString () && NodeUtil . isExprAssign ( grandParent ) && NodeUtil . isNameDeclOrSimpleAssignLhs ( n , parent )
{ if ( nextParent == null || ! NodeUtil . isNameDeclOrSimpleAssignLhs ( nextNode , nextParent ) ) { readsState = true ; } }
! NodeUtil . isNameDeclOrSimpleAssignLhs ( name , name . getParent () )
public void testEs6EnhancedObjLiteralsPropertyShorthand () { testSame ( STRING_CONSTANT ) ; }
public void testES6ClassComputedProperty () { testSame ( STRING_CONSTANT ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; }
byte propType
byte propType
byte propType
public void putBooleanProp ( byte propType , boolean value ) { putIntProp ( propType , value ? NUMBER_CONSTANT : NUMBER_CONSTANT ) ; }
byte propType
byte propType
byte propType
public boolean getBooleanProp ( byte propType ) { return getIntProp ( propType ) != NUMBER_CONSTANT ; }
byte propType
byte propType
byte propType
byte propType
byte propType
byte propType
@ Override public byte getType () { return propType ; }
byte propType
byte propType
final byte prop
Set < ? extends Var > escaped
Set < N > entrySet = new LinkedHashSet <> () ;
Set < N > nodes = new LinkedHashSet <> () ;
String lValueName = NodeUtil . getBestLValueName ( lValue ) ;
isStatementBlock ( parent ) || isSwitchCase ( node ) || node . isMemberFunctionDef ()
assertThat ( computeEscapedLocals ( STRING_CONSTANT ) ) . hasSize ( NUMBER_CONSTANT ) ;
validateChildCount ( n , NUMBER_CONSTANT ) ;
{ validateChildCount ( n , NUMBER_CONSTANT ) ; validateExpression ( n . getFirstChild () ) ; validateExpression ( n . getLastChild () ) ; }
private void validateUnaryOp ( Node n ) { validateChildCount ( n , NUMBER_CONSTANT ) ; validateExpression ( n . getFirstChild () ) ; }
new PeepholeReorderConstantExpression ()
{ if ( parent . isParamList () ) { return true ; } else if ( NodeUtil . isNameDeclaration ( parent ) ) { return n . hasChildren () ; } }
List < Scope > allScopes = liveness . getAllScopesInFunction () ;
assertThat ( statements . get ( NUMBER_CONSTANT ) . isMovableDeclaration () ) . isFalse () ;
{ if ( parent . isParamList () ) { return true ; } else if ( parent . isVar () ) { return n . hasChildren () ; } }
QualifiedName setterPname = new QualifiedName ( commonTypes . createSetterPropName ( pname . getLeftmostName () ) ) ;
QualifiedName getterPname = new QualifiedName ( commonTypes . createGetterPropName ( pname ) ) ;
thisProps = ! thisNt . isBuiltinObject () && thisNt . isStructuralInterface () ? thisNt . getPropertyNames () : this . props . keySet ()
{ otherPropNames = otherNt . getPropertyNames () ; if ( otherPropNames == null ) { return false ; } }
scopeRoots . add ( node ) ;
{ validateChildCount ( n ) ; validateLHS ( n . getToken () , n . getFirstChild () ) ; validateExpression ( n . getLastChild () ) ; }
{ validateLHS ( n . getParent () . getToken () , n ) ; }
public void testInvalidAnnotation5 ( ) throws Exception { testError ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
public void testInvalidAnnotation4 ( ) throws Exception { testError ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
if ( ! t . isHoistScope () ) { return; }
{ if ( t . isHoistScope () ) { pop ( blockStack ) ; } }
if ( t . isHoistScope () ) { blockStack . add ( new BasicBlock ( parent , n ) ) ; }
if ( t . isHoistScope () ) { pop ( blockStack ) ; }
if ( t . isHoistScope () ) { blockStack . add ( new BasicBlock ( parent , n ) ) ; }
Node hoistRoot = t . getClosestHoistScopeRoot () ;
{ if ( n . isVar () && t . getScopeRoot () != t . getClosestHoistScopeRoot () ) { hoistVarIfNeeded ( t , n , parent ) ; } }
if ( scopeType == ScopeType.EXEC_CONTEXT ) { return t . getClosestHoistScopeRoot () == currentScript.rootNode ; } else { return n . getParent () == currentScript.rootNode ; }
Node scopeRoot = t . getClosestHoistScopeRoot () ;
if ( ! n . hasChildren () ) { rewriteEs6ObjectLiteralShorthandPropertySyntax ( n ) ; reportCodeChange ( n , STRING_CONSTANT ) ; }
if ( n . isYieldAll () ) { checkNotNull ( first ) ; add ( STRING_CONSTANT ) ; }
yield . setYieldAll ( tree.isYieldAll ) ;
if ( isGlobal () || isModuleScope () ) { return null ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new ClosureOptimizePrimitives ( compiler , propertyRenamingEnabled , canUseEs6Syntax ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
Diagnostic warning
{ super . setUp () ; this . mode = TypeInferenceMode.NEITHER ; enableRunTypeCheckAfterProcessing () ; }
this . mode = TypeInferenceMode.BOTH ;
test ( srcs ( STRING_CONSTANT ) , warningOtiNti ( TOO_MANY_TEMPLATE_PARAMS , INVALID_GENERICS_INSTANTIATION ) ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( srcs ( STRING_CONSTANT ) , warningOtiNti ( TOO_MANY_TEMPLATE_PARAMS , INVALID_GENERICS_INSTANTIATION ) ) ; }
{ if ( parent . isParamList () ) { return true ; } else if ( NodeUtil . isNameDeclaration ( parent ) ) { return n . hasChildren () ; } }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
if ( hasParamWithInvalidPropertyNameIdentifier ( fnNode ) ) { functionState . setInline ( false ) ; }
if ( NodeUtil . tryMergeBlock ( n , false ) ) { reportCodeChange () ; return null ; }
NodeUtil . tryMergeBlock ( moduleBody , true ) ;
NodeUtil . tryMergeBlock ( callbackBlock , false ) ;
NodeUtil . tryMergeBlock ( scopeClosureBlock , false ) ;
if ( newChild . isNormalBlock () ) { NodeUtil . tryMergeBlock ( newChild , false ) ; }
NodeUtil . tryMergeBlock ( moduleBody , true ) ;
Throwable cause
catch ( Error | Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Error | Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Error | Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Error | Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
Throwable unexpectedException
abstract void throwInternalError ( String msg , Throwable cause ) ;
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isGeneric () ? nt . getRawNominalType () . getInstanceAsJSType () : null ; }
if ( ! init . isEmpty () && ! NodeUtil . isNameDeclaration ( init ) ) { init = trySimplifyUnusedResult ( init , false ) ; }
if ( NodeUtil . isNameDeclaration ( n ) && n . hasOneChild () && n . getFirstFirstChild () != null ) { return true ; }
{ TemplatizedType t = toMaybeTemplatizedType () ; return t == null ? this : t . getReferencedType () ; }
JSType declRetType = this . currentScope . getDeclaredTypeForOwnBody () . getReturnType () ;
JSType declRetType = this . currentScope . getDeclaredTypeForOwnBody () . getReturnType () ;
DeclaredFunctionType dft = this . currentScope . getDeclaredTypeForOwnBody () ;
if ( STRING_CONSTANT . equals ( name ) ) { if ( ! hasThis () ) { return null ; } return getDeclaredTypeForOwnBody () . getThisType () ; }
return this . registry . evaluateTypeExpression ( expr , this . typeEnv ) ;
TypeI type = typeEnv . getNamespaceType ( name ) ;
Node mapFunctionBody = NodeUtil . getFunctionBody ( mapFunction ) ;
this . registry = compiler . getTypeIRegistry () ;
List < String > names
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isGeneric () ? nt . getRawNominalType () . getInstanceAsJSType () : this ; }
return this . globalScope . getInstanceType ( typeName ) ;
EnumSet . of ( TokenType.IDENTIFIER , TokenType.TYPE , TokenType.DECLARE , TokenType.MODULE , TokenType.NAMESPACE ) . contains ( type )
! peekId () && ! EnumSet . of ( TokenType.VOID , TokenType.OPEN_PAREN , TokenType.OPEN_CURLY , TokenType.TYPEOF ) . contains ( peekType () )
compiler = CompilerTestCaseUtils . multistageSerializeAndDeserialize ( this , compiler , inputs , recentChange ) ;
{ functionBody . removeChild ( current ) ; insertAfter = addToFront ( functionBody , current , insertAfter ) ; reportCodeChange ( STRING_CONSTANT , functionBody ) ; }
reportCodeChange ( STRING_CONSTANT , n ) ;
reportCodeChange ( STRING_CONSTANT , n ) ;
boolean isFull () { return numUnfilledTemplateKeys () == NUMBER_CONSTANT ; }
compiler . getOptions () . setStrictModeInput ( true ) ;
public abstract Object getObjectValue ( ) ;
compiler . addToDebugLog ( STRING_CONSTANT , defineName ) ;
catch ( RuntimeException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
compiler . addToDebugLog ( STRING_CONSTANT , name , STRING_CONSTANT , newName ) ;
compiler . addToDebugLog ( STRING_CONSTANT , var.name ) ;
t . getCompiler () . addToDebugLog ( STRING_CONSTANT , fn . getName () ) ;
{ return new IntPropListItem ( propType , intValue , next ) ; }
{ return new ObjectPropListItem ( propType , objectValue , next ) ; }
public void testRestParamWithoutContext () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
var . setStaticSourceFileFrom ( name ) ;
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
assertPassOrder ( checks , chromePass , checkJsDocAndEs6Modules , STRING_CONSTANT ) ;
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
TypeParameters typeParameters
TypeParameters typeParameters
public List < String > getTypeParameters () { return this . typeParameters . asList () ; }
builder . addTypeParameters ( TypeParameters . make ( nt . getTypeParameters () ) ) ;
this . typeParameters = TypeParameters.EMPTY ;
TypeParameters typeParameters
public final boolean isDeleted () { return getBooleanProp ( DELETED ) ; }
@ Nullable final PropListItem getPropListHeadForTesting () { return propListHead ; }
public final int getSourcePosition () { return sourcePosition ; }
public final int getCharno () { return extractCharno ( sourcePosition ) ; }
public final int getLineno () { return extractLineno ( sourcePosition ) ; }
public final int getLength () { return this . length ; }
public final boolean hasProps () { return propListHead != null ; }
public final boolean hasChildren () { return first != null ; }
NodeUtil . isNameDeclaration ( parent )
{ validateLHS ( n . getLastChild () . getToken () , n . getLastChild () ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; enableNormalize () ; }
public void toStringIsEqualTo ( String typeString ) { assertEquals ( typeString , actual () . toString () ) ; }
if ( n . isParamList () ) { return; }
checks . add ( createEmptyPass ( PassNames.AFTER_STANDARD_CHECKS ) ) ;
passName . equals ( PassNames.PARSE_INPUTS )
checks . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
passName . equals ( Compiler.PARSING_PASS_NAME )
n . isName () && parent . isVar ()
checkState ( e != null , STRING_CONSTANT ) ;
TypeI type = typeEnv . getNamespaceOrTypedefType ( name ) ;
Typedef td = Typedef . make ( qnameNode , jsdoc . getTypedefType () ) ;
options . setPackageJsonEntryNames ( ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
packageJsonEntryNames = ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
checks . add ( createEmptyPass ( PassNames.AFTER_STANDARD_CHECKS ) ) ;
passName . equals ( PassNames.PARSE_INPUTS )
{ Node nameNode = n . getFirstChild () ; renamer . addDeclaredName ( nameNode . getString () , false ) ; }
{ ObjectType obj = getObjTypeIfSingletonObj () ; return obj != null && obj . hasNonInheritedProperty ( new QualifiedName ( propertyName ) ) ; }
{ checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getNonInheritedPropertyDefSite ( propertyName ) ; }
classType . mayHaveNonInheritedProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , typeInJsdoc , previousPropType )
if ( this . instanceProps . containsKey ( pname ) || this . protoProps . containsKey ( pname ) ) { return; }
this . allProps = builder . addAll ( instanceProps . keySet () ) . addAll ( protoProps . keySet () ) . build () ;
Property p = getNonInheritedProp ( pname , propAccess ) ;
Property p = getNonInheritedProp ( pname , propAccess ) ;
this . externs = makeExternInputs ( externs ) ;
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
{ for ( Var var : scriptToVarMap . removeAll ( script ) ) { super . undeclareInteral ( var ) ; } }
visitForOf ( t , n , parent ) ;
preloadEs6RuntimeFunction ( compiler , function ) ;
CompilerInput newInput = ( CompilerInput ) deserialize ( compiler , serialize ( input ) ) ;
@ Override public FeatureSet featureSet () { return ES8_MODULES ; }
newEmptyClinitMethod = true ;
visitForOf ( n , parent ) ;
compiler . ensureLibraryInjected ( STRING_CONSTANT + function . toLowerCase ( Locale.US ) , false ) ;
@ Override public FeatureSet featureSet () { return ES8 ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
JSType t = getType ( typeName ) ;
return this . globalScope . getType ( typeName ) ;
{ tmpEnv = collectTypesForEscapedVarsFwd ( callee , tmpEnv ) ; }
TypeEnv outEnv = collectTypesForEscapedVarsFwd ( expr , inEnv ) ;
TypeEnv exitEnv = getExitTypeEnv () ;
public void testTypeTransformationNoneType () { inFunction ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; verify ( STRING_CONSTANT , JSTypeNative.UNKNOWN_TYPE ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
handleGet ( module , scope , n , parent , prefix , Ref.Type.PROTOTYPE_GET , true ) ;
handleGet ( module , scope , n , parent , name , type , true ) ;
{ if ( n . isEmpty () && parent . isClassMembers () ) { reportCodeChange ( STRING_CONSTANT , n ) ; n . detach () ; } }
NodeTraversal . traverseEs6 ( compiler , root , new RemoveEmptyClassMembers () ) ;
preloadEs6RuntimeFunction ( compiler , function ) ;
visitForOf ( t , n , parent ) ;
{ builder . addRetType ( firstNonBottom ( actualRetType , UNKNOWN ) ) ; }
for ( ObjectTypeI interfaceType : funType . getAncestorInterfaces () ) { interfaces . add ( interfaceType . toAnnotationString ( Nullability.IMPLICIT ) ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT , record . toAnnotationString ( Nullability.EXPLICIT ) ) ;
assertEquals ( STRING_CONSTANT , record . toAnnotationString ( Nullability.EXPLICIT ) ) ;
if ( ! runOptimizeCalls ) { passes . add ( getRemoveUnusedVars ( PassNames.REMOVE_UNUSED_VARS , false ) ) ; }
checks . add ( createEmptyPass ( PassNames.BEFORE_TYPE_CHECKING ) ) ;
NodeUtil . markFunctionsDeleted ( nameNode , compiler ) ;
if ( ! n . hasOneChild () ) { return false ; }
grandparent . isStringKey () && NodeUtil . isObjectDefinePropertiesDefinition ( grandparent . getGrandparent () )
Node statementNode = rhsNode . getGrandparent () ;
if ( ! call . hasTwoChildren () || ! legacyNamespaceNode . isString () ) { t . report ( legacyNamespaceNode , INVALID_GET_NAMESPACE ) ; return; }
if ( ! call . hasTwoChildren () || ! namespaceNode . isString () ) { t . report ( namespaceNode , INVALID_FORWARD_DECLARE_NAMESPACE ) ; return; }
NodeTraversal . traverseEs6 ( compiler , fnName . getGrandparent () , uniquifier ) ;
if ( entry . isObjectLit () ) { checkState ( entryName . equals ( STRING_CONSTANT ) , entryName ) ; processBrowserFieldAdvancedUsage ( dirName , entry ) ; }
if ( line . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT ) { return line . indexOf ( CHAR_CONS ) ; }
if ( parent . isVar () ) { parent . detach () ; reportCodeChange () ; return null ; }
{ node . detach () ; reportCodeChange () ; return null ; }
{ checkState ( this . setUpRan , STRING_CONSTANT ) ; Collections . addAll ( ignoredWarnings , warnings ) ; }
{ @ Override public boolean apply ( Node n ) { return n . matchesQualifiedName ( name ) ; } }
assertNull ( noInline ) ;
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . isEqualTo ( FixedPointGraphTraversal.NON_HALTING_ERROR_MSG ) ; }
Node fNode = root . getFirstFirstChild () ;
{ testSame ( EXTERNS + extraExterns , source ) ; assertEquals ( expected , noSideEffectCalls ) ; noSideEffectCalls . clear () ; }
Node classNode = root . getFirstChild () . getFirstFirstChild () ;
Node fNode = root . getFirstChild () . getFirstFirstChild () ;
catch ( IllegalArgumentException expected ) { assertThat ( expected ) . hasMessageThat () . contains ( STRING_CONSTANT + STRING_CONSTANT ) ; }
js = RENAME_FUNCTION_DEFINITION + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
js = RENAME_FUNCTION_DEFINITION + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
js = RENAME_FUNCTION_DEFINITION + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
checkState ( n . isName () || n . isStringKey () || n . isImportStar () , STRING_CONSTANT , n ) ;
public void testImportedNameCollision () { testSame ( STRING_CONSTANT ) ; }
@ Override public FeatureSet featureSet () { return ES5 ; }
{ checkArgument ( n . isTry () ) ; return n . hasXChildren ( NUMBER_CONSTANT ) ; }
{ iterableType = iterable . getTypeI () . autobox () . toMaybeObjectType () ; typeParam = iterableType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ; }
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; allowExternsChanges () ; this . mode = TypeInferenceMode.BOTH ; enableRunTypeCheckAfterProcessing () ; }
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node , parent ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node ) ;
emptiedClinitMethods . add ( fnQualifiedName ) ;
if ( options . getNewTypeInference () && options . getRunOTIafterNTI () && ! options.checksOnly ) { addOldTypeCheckerPasses ( checks , options ) ; }
Renamer renamer = renamerStack . peek () ;
{ if ( NodeUtil . isFunctionBlock ( t . getScopeRoot () ) ) { return; } if ( ! t . inGlobalScope () ) { renamerStack . pop () ; } }
new PureFunctionIdentifier.DriverInJ2cl ( compiler , null ) . process ( externs , root ) ;
new PureFunctionIdentifier.Driver ( compiler , null ) . process ( externs , root ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( returnType != null ) { builder . append ( STRING_CONSTANT ) ; returnType . appendTo ( builder , ctx ) ; }
if ( options . getNewTypeInference () && options . getRunOTIafterNTI () ) { addOldTypeCheckerPasses ( checks , options ) ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
{ super . setUp () ; enableNormalize () ; this . mode = TypeInferenceMode.BOTH ; }
lit . setTypeI ( exportedObjectLit . getTypeI () ) ;
{ super . setUp () ; allowExternsChanges () ; this . mode = TypeInferenceMode.BOTH ; enableRunTypeCheckAfterProcessing () ; enableParseTypeInfo () ; }
this . mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; assertExternProperties ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.NEITHER ;
public void tagAsStrict () { add ( STRING_CONSTANT ) ; cc . endLine () ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { this . mode = TypeInferenceMode.BOTH ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties4 () { this . mode = TypeInferenceMode.BOTH ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty2 () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testConstructorProperty1 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
v != null || ! isShadowingAllowed ( name , s )
if ( options.j2clPassMode . shouldAddJ2clPasses () ) { passes . add ( j2clConstantHoisterPass ) ; passes . add ( j2clClinitPass ) ; }
boolean shouldPrintExterns () { return this . printExterns || incrementalCheckMode == IncrementalCheckMode.GENERATE_IJS ; }
return check () . about ( types () ) . that ( actualPropType ) ;
t . inGlobalScope () && NodeUtil . isDeclaration ( n ) && ! n . getBooleanProp ( Node.IS_NAMESPACE ) && ! isWhitelisted ( n )
assertTrue ( NodeUtil . isFunctionDeclaration ( getFunctionNode ( STRING_CONSTANT ) ) ) ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
warningOtiNti ( TYPE_MISMATCH_WARNING , MISTYPED_ASSIGN_RHS )
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.BOTH ;
checkNotNull ( curNode ) ;
boolean isFunctionExpression = parent != null && NodeUtil . isFunctionExpression ( n ) ;
checkState ( s . isGlobal () || s . isModuleScope () , s ) ;
checkArgument ( child.parent == null , STRING_CONSTANT , child , child.parent , this ) ;
passes . add ( createEmptyPass ( PassNames.BEFORE_MAIN_OPTIMIZATIONS ) ) ;
public void testJSDocCopiedForClasses () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testObjectLiteralMethods () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testObjectLiteralShorthand () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testDefaultParameter () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testClassDefinition3 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testClassDefinition2 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testClassDefinition1 () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testArrowFunction () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testNonTopLevelDestructuring () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testObjectDescructuringError2 () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testObjectDescructuringError1 () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testDestructuringError () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testYieldExpression () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testInlineEmptyFunction6 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
NodeTraversal . traverseEs6ScopeRoots ( compiler , null , ImmutableList . of ( fooFunction , barFunction , bazFunction ) , callback , callback , false ) ;
testSame ( STRING_CONSTANT ) ;
if ( NodeUtil . isBleedingFunctionName ( n ) ) { renameBleedingFunctionName ( t , n ) ; }
public void testMakeLocalNamesUniqueWithContext10 () { this . useDefaultRenamer = true ; testSame ( STRING_CONSTANT ) ; }
public void testMakeLocalNamesUniqueWithContext9 () { this . useDefaultRenamer = true ; testSame ( STRING_CONSTANT ) ; }
{ newNode = IR . assign ( getprop , rhs . cloneTree () ) ; }
{ FunctionType getterType = typeRegistry . createFunctionType ( objectType ) ; codingConvention . applySingletonGetter ( PROPERTY_DECLARER , functionType , getterType , objectType ) ; }
if ( superCtor != null && subCtor != null ) { codingConvention . applySubclassRelationship ( PROPERTY_DECLARER , superCtor , subCtor , relationship.type ) ; }
when ( mockCompiler . compile ( FOO_JS , STRING_CONSTANT ) ) . thenReturn ( new BaseTranspiler.CompileResult ( STRING_CONSTANT , false , STRING_CONSTANT ) ) ;
when ( mockCompiler . compile ( FOO_JS , STRING_CONSTANT ) ) . thenReturn ( new BaseTranspiler.CompileResult ( STRING_CONSTANT , true , STRING_CONSTANT ) ) ;
inFunction ( STRING_CONSTANT ) ;
{ replacement = replacement . useSourceInfoIfMissingFrom ( node ) ; node . replaceWith ( replacement ) ; compiler . reportChangeToEnclosingScope ( replacement ) ; }
if ( codeChanged ) { compiler . reportChangeToEnclosingScope ( subtree ) ; }
compiler . reportChangeToEnclosingScope ( whileNode ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( replacementConditionNode ) ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; compiler . reportChangeToEnclosingScope ( parent ) ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; compiler . reportChangeToEnclosingScope ( switchNode ) ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( caseBlock ) ;
{ compiler . reportChangeToEnclosingScope ( maybeBreak ) ; maybeBreak . detach () ; }
compiler . reportChangeToEnclosingScope ( parent ) ;
{ subtree . replaceWith ( right . detach () ) ; compiler . reportChangeToEnclosingScope ( right ) ; return right ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( firstArg ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( newNode ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
{ Node replacement = measuredNodeReplacement . applyTo ( original ) ; compiler . reportChangeToEnclosingScope ( replacement ) ; return replacement ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( subtree ) ;
compiler . reportChangeToEnclosingScope ( elem ) ;
compiler . reportChangeToEnclosingScope ( elem ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( newStringNode ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( newNode ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
compiler . reportChangeToEnclosingScope ( stringNode ) ;
compiler . reportChangeToEnclosingScope ( call ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; compiler . reportChangeToEnclosingScope ( newLiteralNode ) ; return newLiteralNode ; }
{ n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( parentNode ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compileFiles ( STRING_CONSTANT , zipFile1 , zipFile2 ) ;
if ( options.j2clPassMode . shouldAddJ2clPasses () ) { checks . add ( j2clSourceFileChecker ) ; }
j2clPassMode = J2clPassMode.AUTO ;
checkState ( child.parent == this , STRING_CONSTANT , this , child ) ;
checkState ( child.parent == this , STRING_CONSTANT , this , child ) ;
assertThat ( result.transformed ) . isFalse () ;
assertThat ( result.transformed ) . isTrue () ;
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new Transpiler ( mockCompiler , STRING_CONSTANT ) ; compiler = Transpiler . compilerSupplier () ; }
Files . asCharSink ( jsFile , UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , UTF_8 ) . write ( code ) ;
{ this . def = checkNotNull ( def ) ; this . use = use ; }
if ( ! rewriteState . containsModule ( legacyNamespace ) ) { unrecognizedRequires . add ( new UnrecognizedRequire ( call , legacyNamespace , false , false ) ) ; }
inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ;
this . analyzer = new AnalyzePrototypeProperties ( compiler , moduleGraph , canModifyExterns , false , noStubFunctions ) ;
AnalyzePrototypeProperties analyzer = new AnalyzePrototypeProperties ( compiler , null , canModifyExterns , anchorUnusedVars , false ) ;
compilationLevelParsed = CompilationLevel . fromString ( Ascii . toUpperCase ( compilationLevel ) ) ;
if ( cacheEntry.input == null ) { cacheEntry.input = CompilerInput . makePersistentInput ( source ) ; }
boolean transformed = transformed ( result ) ;
@ Override public FeatureSet featureSet () { return FeatureSet . latest () ; }
public void testInlineIntoNestedNonHoistedNamedFunctions () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
jsDoc != null && jsDoc . hasConstAnnotation () && jsDoc . getType () == null
newNode . useSourceInfoIfMissingFromForTree ( sourceInfoNode ) ;
expr . useSourceInfoIfMissingFromForTree ( parent ) ;
checkState ( n . isFunction () || n . isClass () , n ) ;
public boolean shouldAmbiguateProperties () { return this . ambiguateProperties ; }
public boolean shouldDisambiguateProperties () { return this . disambiguateProperties ; }
public boolean shouldInlineProperties () { return inlineProperties ; }
{ return new Es6RewriteClass ( compiler , ! compiler . getOptions () . inIncrementalCheckMode () ) ; }
decl . simplify ( compiler ) ;
NodeUtil . isEnhancedFor ( n )
public void testForIn () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
typeCheck ( LINE_JOINER . join ( CLOSURE_BASE , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.NULLABLE_DEREFERENCE ) ;
typeCheck ( LINE_JOINER . join ( CLOSURE_DEFS , STRING_CONSTANT ) ) ;
typeCheck ( LINE_JOINER . join ( CLOSURE_BASE , STRING_CONSTANT ) ) ;
Iterable < Node > replacements
if ( ! isPrettyPrint () || this == registry . getNativeType ( JSTypeNative.FUNCTION_INSTANCE_TYPE ) ) { return sb . append ( forAnnotations ? STRING_CONSTANT : STRING_CONSTANT ) ; }
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
if ( hasReferenceName () ) { return sb . append ( forAnnotations ? getNormalizedReferenceName () : getReferenceName () ) ; }
{ checkArgument ( qnameNode . isQualifiedName () , qnameNode ) ; declarations . add ( PotentialDeclaration . from ( qnameNode , scope ) ) ; }
boolean isImport = isImportRhs ( rhs ) ;
ignoreWarnings ( NewTypeInference.INEXISTENT_PROPERTY ) ;
public void testInherits4 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testInherits3 () { testSame ( STRING_CONSTANT ) ; }
public void testInherits2 () { testSame ( STRING_CONSTANT ) ; }
public void testInherits1 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
! callClassType . isBottom () && ! callClassType . isSomeUnknownType ()
public void testLoggerOnObject3b () { ignoreWarnings ( NewTypeInference.GLOBAL_THIS ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
! validityCheck
if ( devMode ) { runValidityCheck () ; if ( hasErrors () ) { return null ; } }
maybeRunValidityCheck () ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new ValidityCheck ( compiler ) ; }
if ( options.devMode == DevMode.EVERY_PASS ) { phaseOptimizer . setValidityCheck ( validityCheck ) ; }
if ( options.devMode == DevMode.START_AND_END ) { runValidityCheck () ; }
if ( checkAnnotated && sourceFile != null ) { checkState ( sourceFile . equals ( n . getSourceFileName () ) ) ; }
{ declarationCheck = ! validityCheck ; disableCompareAsTree () ; testExternChanges ( extern , input , expectedExtern ) ; }
validityCheck = true ;
public void testViolatedModuleDependencyNonStrictNotPromoted () { validityCheck = true ; strictModuleDepErrorLevel = CheckLevel.ERROR ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testMissingModuleDependencySkipNonStrictNotPromoted () { validityCheck = true ; strictModuleDepErrorLevel = CheckLevel.ERROR ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public void testViolatedModuleDependencySkipNonStrict () { validityCheck = true ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testMissingModuleDependencySkipNonStrict () { validityCheck = true ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
validityCheck = false ;
@ Override public ObjectType prototypeOrInstance () { return prototype ; }
@ Override public ObjectType instance () { return instance ; }
@ Override public FunctionType constructor () { return constructor ; }
convention . applySingletonGetter ( new NominalTypeBuilderNti ( rawType . getAsNominalType () ) , getInstanceType ) ;
new FunctionTypeBuilder ( getCommonTypes () ) . addReqFormal ( getCommonTypes () . qmarkFunction () )
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ reportBadBaseMethodUse ( t , n , clazz . getFirstChild () . getString () , STRING_CONSTANT ) ; }
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
if ( initializer != null ) { inferredType = simpleInferExpr ( initializer , this . currentScope ) ; }
return bindComponents.thisValue == null ? null : simpleInferExpr ( bindComponents.thisValue , this . currentScope ) ;
this . currentScope . isConstructor ()
JSType rhsType = simpleInferExpr ( rhs , this . currentScope ) ;
JSType newPropType = rhs == null ? null : simpleInferExpr ( rhs , this . currentScope ) ;
JSType recvType = simpleInferExpr ( recv , this . currentScope ) ;
JSType t = initializer == null ? null : simpleInferExpr ( initializer , this . currentScope ) ;
if ( initializer != null ) { inferredType = simpleInferExpr ( initializer , this . currentScope ) ; }
JSType t = simpleInferExpr ( prop . getFirstChild () , this . currentScope ) ;
checkState ( n . isName () || n . isImportStar () , n ) ;
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this ) ; cjs . process ( null , root ) ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
String requireName = ProcessCommonJSModules . getCommonJsImportPath ( require ) ;
{ this . compiler = compiler ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this , true ) ; cjs . process ( null , root ) ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT , } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
String requireName = require . getSecondChild () . getString () ;
{ this ( compiler , true ) ; }
if ( type . isEquivalentTo ( domHelperType ) ) { return true ; }
case SIMPLIFY_RHS :
void markProvided ( String providedName ) { checkNotNull ( providedName ) ; providedNamespaces . add ( providedName ) ; }
void markNameProcessed ( String fullyQualifiedName ) { checkNotNull ( fullyQualifiedName ) ; seenNames . add ( fullyQualifiedName ) ; }
{ return new ObjectLiteralPropertyDefinition ( n , n . getFirstChild () , isExtern ) ; }
List < Var > orderedVars = new ArrayList <> () ;
List < Var > orderedVars = new ArrayList <> () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this ) ; cjs . process ( null , root ) ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
String requireName = ProcessCommonJSModules . getCommonJsImportPath ( require ) ;
{ this . compiler = compiler ; }
public void testDontPreserveUnknownTypeDeclarations () { testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
if ( isUnknown () || isUnresolved () ) { return this ; }
typeCheck ( LINE_JOINER . join ( CLOSURE_BASE , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
checkArgument ( nameNode . isQualifiedName () || nameNode . isStringKey () , nameNode ) ;
options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) || options.transformAMDToCJSModules || options.processCommonJSModules
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
caseMatches = PeepholeFoldConstants . evaluateComparison ( Token.SHEQ , cond , caseLabel ) ;
new PeepholeMinimizeConditions ( late )
optimizations . add ( new PeepholeMinimizeConditions ( late ) ) ;
new PeepholeMinimizeConditions ( late )
new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true ) , new PeepholeFoldConstants ( true , false ) )
TernaryValue result = evaluateComparison ( n . getToken () , left , right ) ;
Double rightValObj = NodeUtil . getNumberValue ( right ) ;
Double result = NodeUtil . getNumberValue ( n ) ;
new PeepholeMinimizeConditions ( late )
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
testSame ( STRING_CONSTANT ) ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeMinimizeConditions ( late ) ) ;
Node n = parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.STRING_CONTINUATION ) , STRING_CONSTANT + STRING_CONSTANT ) ;
replacement . setTypeI ( call . getTypeI () ) ;
{ checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ; f1 . isSubtypeOfHelper ( f2 , false , subSuperMap , boxedInfo ) ; }
{ return isSubtypeOfHelper ( other , false , subSuperMap , null ) ; }
{ return isSubtypeOfHelper ( other , true , SubtypeCache . create () , null ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false ) ; }
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
void process ( Node externs , Node root , ReferenceMap references ) ;
public void testCallOrApply ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false , false ) ; }
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
void process ( Node externs , Node root , DefinitionUseSiteFinder definitions ) ;
public void testCallOrApply ( ) throws Exception { testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = newlineJoin ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
options . setEmitUseStrict ( false ) ;
passes = new ArrayList <> () ;
passes = new ArrayList <> () ;
{ passes = new ArrayList <> () ; addInlineVariables () ; addPeephole () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
passes = new ArrayList <> () ;
passes = new ArrayList <> () ;
passes = new ArrayList <> () ;
{ passes = new ArrayList <> () ; addDeadCodeElimination () ; addInlineVariables () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
passes = new ArrayList <> () ;
{ passes = new ArrayList <> () ; addInlineVariables () ; addPeephole () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ messages = new ArrayList <> () ; mode = JsMessage.Style.LEGACY ; compilerOptions = null ; renameMessages = false ; }
return getTopObject () . getNominalTypeIfSingletonObj () . getPrototypeObject () ;
JSType proto = getNominalTypeIfSingletonObj () . getPrototypeObject () ;
return superClass == null ? null : superClass . getPrototypeObject () ;
checkState ( n . isCall () || n . isTaggedTemplateLit () , n ) ;
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalArgumentException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
ref.scope . getClosestHoistScope () . isGlobal ()
ref.scope . isGlobal ()
Result result = compiler . compile ( testExterns , inputs , options ) ;
try { compiler . compile ( EXTVAR_EXTERNS , inputs , options ) ; } catch ( RuntimeException e ) { fail ( STRING_CONSTANT ) ; }
Result result = compiler . compile ( EXTVAR_EXTERNS , inputs , options ) ;
Result result = compiler . compile ( EXTVAR_EXTERNS , inputs , options ) ;
if ( type . contains ( STRING_CONSTANT ) ) { type = type . substring ( NUMBER_CONSTANT , type . lastIndexOf ( CHAR_CONS ) ) ; } else { return; }
String shortName = parent . getQualifiedName () . substring ( parent . getQualifiedName () . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
suffixes . add ( polyfillName . substring ( polyfillName . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ) ;
{ return STRING_CONSTANT + cls.target . getQualifiedName () . replace ( STRING_CONSTANT , STRING_CONSTANT ) + STRING_CONSTANT ; }
Map < Node < E > , ImmutableSet.Builder < E > > groupsTmp = new LinkedHashMap <> () ;
Map < String , Integer > map = new HashMap <> () ;
NodeUtil . findLhsNodesInNode ( n )
NodeUtil . findLhsNodesInNode ( n )
{ for ( Node lhs : NodeUtil . findLhsNodesInNode ( n ) ) { declareVar ( s , lhs ) ; } }
names = NodeUtil . findLhsNodesInNode ( c ) ;
NodeUtil . findLhsNodesInNode ( decl )
NodeUtil . findLhsNodesInNode ( varNode )
NodeUtil . findLhsNodesInNode ( declaration )
checkNotNull ( sideEffectInfo , STRING_CONSTANT , function ) ;
if ( NodeUtil . findLhsNodesInNode ( nameDecl ) . size () > NUMBER_CONSTANT ) { continue; }
Iterable < Node > allVars = NodeUtil . findLhsNodesInNode ( n ) ;
NodeUtil . findLhsNodesInNode ( paramList )
ref.scope . getClosestHoistScope () . isGlobal ()
public void testLocalAliasWithLet3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalAliasWithLet2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageIn = LanguageMode.ECMASCRIPT_2017 ;
List < Node > arrayFoldedChildren = new ArrayList <> () ;
List < Var > orderedVars = new ArrayList <> () ;
Deque < ScriptDescription > scriptDescriptions = new ArrayDeque <> () ;
List < Var > orderedVars = new ArrayList <> () ;
this . orderedVars = new ArrayList <> () ;
this . orderedVars = new ArrayList <> () ;
this . orderedVars = new ArrayList <> () ;
List < Node > newVars = new ArrayList <> () ;
languageIn = LanguageMode.ECMASCRIPT3 ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false ) ; }
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
void process ( Node externs , Node root , ReferenceMap references ) ;
public void testCallOrApply ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
languageIn = LanguageMode.ECMASCRIPT_2017 ;
public void testConst1 () { inFunction ( STRING_CONSTANT ) ; }
languageIn = LanguageMode.ECMASCRIPT3 ;
rewriteDeclsToVars () ;
rewriteDeclsToVars () ;
@ Nullable Node varName
checkLocalityOfMarkedCalls ( source , ImmutableList . < String > of ( STRING_CONSTANT ) ) ;
checkLocalityOfMarkedCalls ( source , ImmutableList . < String > of ( STRING_CONSTANT ) ) ;
assertTrue ( NodeUtil . evaluatesToLocalValue ( n ) ) ;
languageIn = LanguageMode.ECMASCRIPT_2017 ;
languageIn = LanguageMode.ECMASCRIPT3 ;
return STRING_CONSTANT + fnName + STRING_CONSTANT + sourceName ;
String fullExportedName = currentScript . getBinaryNamespace () . get () + exportDefinition . getExportPostfix () ;
Node binaryNamespaceName = IR . name ( currentScript . getBinaryNamespace () . get () ) ;
if ( ! currentScript . isModule () ) { return; }
if ( ! currentScript . isModule () ) { return; }
if ( ! currentScript . isModule () ) { return; }
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) . get () ;
checkState ( currentScript . isModule () , currentScript ) ;
if ( ! currentScript . isModule () || ! n . getString () . equals ( STRING_CONSTANT ) || ! isAssignTarget ( n ) ) { return; }
languageIn = LanguageMode.ECMASCRIPT_2017 ;
if ( et != null && et . enumLiteralHasKey ( pname ) ) { return et . getPropType () ; }
{ type = locals . get ( name ) . getDeclaredType () ; }
{ locals . put ( name , TaggedType . makeDeclared ( newDeclType ) ) ; }
String fullExportedName = currentScript . getBinaryNamespace () + exportDefinition . getExportPostfix () ;
Node binaryNamespaceName = IR . name ( currentScript . getBinaryNamespace () ) ;
if ( ! currentScript.isModule ) { return; }
if ( ! currentScript.isModule ) { return; }
if ( ! currentScript.isModule ) { return; }
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) ;
checkState ( currentScript.isModule , currentScript ) ;
if ( ! currentScript.isModule || ! n . getString () . equals ( STRING_CONSTANT ) || ! isAssignTarget ( n ) ) { return; }
checkState ( n . isName () || n . isGetProp () , n ) ;
finder . visitTree ( root ) ;
{ return STRING_CONSTANT + cls.target . getQualifiedName () . replace ( CHAR_CONS , CHAR_CONS ) + STRING_CONSTANT ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; }
NodeUtil . isNameDeclaration ( statementNode )
checkState ( declNode . isGetProp () , declNode ) ;
{ getGlobalScope () . addNamespaceLit ( new QualifiedName ( WINDOW_INSTANCE ) , qnameNode ) ; return true ; }
compilerOptions . setPreserveClosurePrimitives ( true ) ;
compilerOptions . setPreserveClosurePrimitives ( true ) ;
keyNode . isStringKey () || keyNode . isGetProp ()
Node externsRoot = parse ( compiler , STRING_CONSTANT ) ;
Node externsRoot = parse ( compiler , STRING_CONSTANT ) ;
{ helperExposeExpression ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; helperExposeExpression ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
return ( JSType ) n . getTypeI () ;
JSType jsdocType = ( JSType ) prop . getTypeI () ;
pair.type = ( JSType ) expr . getTypeI () ;
JSType jsdocType = ( JSType ) prop . getTypeI () ;
JSType toType = ( JSType ) expr . getTypeI () ;
visitNamespacePropertyDeclaration ( getProp , QualifiedName . fromNode ( recv ) , pname ) ;
JSType propDeclType = ( JSType ) prop . getTypeI () ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.TOO_MANY_TYPE_PARAMS , CheckLevel.WARNING ) ; return options ; }
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ; }
{ String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ; }
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String body = lines ( STRING_CONSTANT , STRING_CONSTANT ) ;
String body = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , js ) ;
String fileoverview = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; assertThat ( getLastCompiler () . injected ) . isEmpty () ; }
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ testFunctionNamesAndIds ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } ) ; }
{ testFunctionNamesAndIds ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } ) ; }
{ testFunctionNamesAndIds ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , } ) ; }
assertEarlyReferenceError ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEarlyReferenceError ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String legacyScript = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Node script = compiler . parseSyntheticCode ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testReference ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , false ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
testWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
testWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
testWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
test ( modules , new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT , STRING_CONSTANT , } ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
foldSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( createModuleChain ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT } )
test ( createModuleStar ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( modules , new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) } ) ;
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
typeCheck ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { STRING_CONSTANT , STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) }
test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testError ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , VarCheck.UNDEFINED_VAR_ERROR ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
{ test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String externs = lines ( DEFAULT_EXTERNS , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
String localVar = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSets ( STRING_CONSTANT , js , output , STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
Preconditions . checkState ( ! isFunctionDeclaration ( n ) ) ;
return checkForNewObjects || isFunctionDeclaration ( n ) ;
t . inGlobalHoistScope () && NodeUtil . isFunctionDeclaration ( n )
if ( Es6RewriteModules . isEs6ModuleRoot ( root ) ) { return true ; }
if ( Es6RewriteModules . isEs6ModuleRoot ( root ) ) { moduleType = ModuleType.ES6 ; }
testModules ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new ProcessCommonJSModules ( compiler ) ; }
if ( NodeUtil . isFunctionExpression ( parent ) ) { return; }
{ FindStaticMembers findStaticMembers = new FindStaticMembers () ; TranspilationPasses . processTranspile ( compiler , scriptRoot , findStaticMembers ) ; processInherits ( findStaticMembers ) ; }
processInherits ( findStaticMembers ) ;
String src = CompilerTestCase . lines ( lines ) ;
String src = CompilerTestCase . lines ( lines ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertChangesRecorded ( code , new NameChangingCallback () ) ; }
{ String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertChangesRecorded ( code , new NameChangingCallback () ) ; }
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( ! fn . isFromExterns () ) { GlobalTypeInfoCollector . this . scopes . add ( fnScope ) ; }
useSourceInfoForNewQName ( node , basisNode ) ;
{ return assertAbout ( JSErrorSubject : : new ) . that ( error ) ; }
{ return assertAbout ( NodeSubject : : new ) . that ( node ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , features , this ) ; }
TranspilationPasses . processTranspile ( compiler , externs , transpiledFeatures , this ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , checkedFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , checkedFeatures , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , checkedFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , features , this , new SelfReferenceRewriter () ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , features , this , new SelfReferenceRewriter () ) ; }
TranspilationPasses . processTranspile ( compiler , scriptRoot , transpiledFeatures , findStaticMembers ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ if ( allowMethodCallDecomposing ) { return DecompositionType.DECOMPOSABLE ; } else { return DecompositionType.UNDECOMPOSABLE ; } }
checkState ( allowMethodCallDecomposing , STRING_CONSTANT ) ;
Node name = NodeUtil . newQName ( compiler , PROTOTYPE_ALIAS + STRING_CONSTANT + declar.memberName , declar.node , declar.memberName ) ;
Node var = NodeUtil . newVarNode ( PROTOTYPE_ALIAS , null ) . useSourceInfoIfMissingFromForTree ( injectionPoint ) ;
isAssignmentOp ( declNode )
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isLiteralObject () || nt . isBuiltinObject () || nt . isIObject () ; }
boolean isPropertyRemovable ( String propertyName ) { return isEntirelyRemovable || ( unreferencedPropertiesMayBeRemoved && ! referencedPropertyNames . contains ( propertyName ) ) ; }
resultPair = analyzeCastFwd ( expr , inEnv ) ;
Name superclassNameObj = getOrCreateName ( superclassName , true ) ;
void verify ( Compiler compiler ) ;
currentArgumentsAccess = new ArrayList <> () ;
cur = instance.declarations . get ( instance.declarations . size () - NUMBER_CONSTANT ) . node ;
PrototypeMemberDeclaration first = instance.declarations . get ( NUMBER_CONSTANT ) ;
List < SourceFile > files = new ArrayList <> () ;
List < SourceFile > files = new ArrayList <> () ;
List < SourceFile > files = new ArrayList <> () ;
List < String > entryPoints = new ArrayList <> () ;
List < MemberDefinition > allProperties = new ArrayList <> () ;
if ( lValue . isRest () ) { lValue = lValue . getOnlyChild () ; }
VarInfo varInfo = traverseVar ( classScope . getVar ( classNameNode . getString () ) ) ;
{ VarInfo varInfo = traverseVar ( var ) ; varInfo . addRemovable ( new RemovableBuilder () . buildDestructuringAssign ( c , c ) ) ; }
VarInfo varInfo = traverseVar ( var ) ;
VarInfo varInfo = traverseVar ( var ) ;
VarInfo varInfo = traverseVar ( checkNotNull ( scope . getVar ( nameNode . getString () ) ) ) ;
VarInfo varInfo = traverseVar ( scope . getVar ( nameNode . getString () ) ) ;
VarInfo exceptionVarInfo = traverseVar ( scope . getVar ( exceptionNameNode . getString () ) ) ;
{ VarInfo varInfo = traverseVar ( var ) ; varInfo . addRemovable ( new RemovableBuilder () . buildDestructuringAssign ( restNode , target ) ) ; }
VarInfo classVarInfo = traverseVar ( classVar ) ;
{ throw new IllegalStateException ( STRING_CONSTANT + ref ) ; }
throw new IllegalStateException ( STRING_CONSTANT + expr ) ;
checkState ( ! NodeUtil . isObjectLitKey ( n ) , n ) ;
checkState ( isCallOrNew ( invocation ) , invocation ) ;
@ Nullable Scope scope
checkState ( current . isGetProp () , STRING_CONSTANT , current ) ;
checkState ( current . isLabel () , current ) ;
checkState ( isControlStructure ( parent ) , parent ) ;
checkState ( n . isClassMembers () || n . isObjectLit () , n ) ;
checkState ( n . isClassMembers () || n . isObjectLit () , n ) ;
checkArgument ( callNode . isNew () , STRING_CONSTANT , callNode . getToken () ) ;
boolean isMarkedConst = n . getParent () . isConst () || ( jsdoc != null && jsdoc . isConstant () ) ;
Queue < Property > propertyQueue = new ArrayDeque <> ( propertiesSet ) ;
{ if ( n . isFunction () ) { break; } this . ancestors . addFirst ( n ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; }
assertNoPureCalls ( source ) ;
@ Nullable Var v
@ Nullable Node definitionRValue
isStaticCtorProp ( getProp )
@ Nullable JSModule module
{ if ( inExterns ) { visitExterns ( traversal , node ) ; } else { visitCode ( traversal , node ) ; } }
@ Nullable JSModule module
NameBasedDefinitionProvider definitionProvider
if ( defs . isEmpty () ) { return; }
@ VisibleForTesting Multimap < String , UseSite > getUseSitesByName () { return ImmutableMultimap . copyOf ( useSitesByName ) ; }
public void testAnnotationInExterns_new5 ( ) throws Exception { assertPureCallsMarked ( STRING_CONSTANT , ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
return new RemoveUnusedVars ( compiler , ! removeOnlyLocals , preserveAnonymousFunctionNames , false ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false , false ) ; }
new RemoveUnusedVars ( compiler , true , false , false ) . process ( externs , root ) ;
{ new RemoveUnusedVars ( compiler , removeGlobal , preserveFunctionExpressionNames , false ) . process ( externs , root ) ; }
{ visitScript ( t , n ) ; }
assertThat ( packageJsonMainEntries ) . containsEntry ( STRING_CONSTANT , ModuleLoader.JSC_BROWSER_BLACKLISTED_MARKER ) ;
checkArgument ( fnNode . isFunction () , fnNode ) ;
LinkedHashMap < String , Node > actualMap = getFunctionCallParameterMap ( fn , call , getNameSupplier () ) ;
public void testFindModifiedParameters12 () { assertThat ( findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters2 () { assertThat ( findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters1 () { assertThat ( findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters0 () { assertThat ( findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
boolean replaceParent = true ;
tracer = new Tracer ( STRING_CONSTANT , name ) ;
{ if ( edgeAnnotationStack == null ) { edgeAnnotationStack = new ArrayDeque <> () ; } pushAnnotations ( edgeAnnotationStack , getEdges () ) ; }
{ if ( nodeAnnotationStack == null ) { nodeAnnotationStack = new ArrayDeque <> () ; } pushAnnotations ( nodeAnnotationStack , getNodes () ) ; }
if ( LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE < t . getScope () . getVarCount () ) { return; }
if ( LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE < blockScope . getVarCount () + functionScope . getVarCount () ) { return; }
i < LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE + NUMBER_CONSTANT
if ( var . getParentNode () . isParamList () ) { varInfo.propertyAssignmentsWillPreventRemoval = true ; }
exceptionVarInfo . setIsExplicitlyNotRemovable () ;
canonicalTotallyUnremovableVarInfo . setIsExplicitlyNotRemovable () ;
ImmutableSet < String > namesToAlias
ImmutableSet < String > needAliases
ImmutableMap < String , Node > argMap
if ( LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t . getScope () . getVarCount () ) { return; }
return LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE > orderedVars . size () ;
i < LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE + NUMBER_CONSTANT
if ( ! NodeUtil . isNameDeclaration ( n ) ) { return; }
NodeUtil . isNameDeclaration ( parent ) && nameNode . hasOneChild ()
NodeUtil . isNameDeclaration ( parent )
removeUnusedProperties && r . isPrototypeObjectNamedPropertyAssignment () && ! referencedPropertyNames . contains ( r . getPropertyName () )
removeUnusedProperties && removable . isPrototypeObjectNamedPropertyAssignment () && ! referencedPropertyNames . contains ( removable . getPropertyName () )
! n . isString () && ! isConstantNameNode ( n )
if ( rValue == null || ! rValue . isFunction () || NodeUtil . doesFunctionReferenceOwnArgumentsObject ( rValue ) ) { return false ; }
if ( NodeUtil . doesFunctionReferenceOwnArgumentsObject ( fnc ) ) { return false ; }
computeEscaped ( jsScope , escaped , compiler , scopeCreator ) ;
computeEscaped ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
computeEscaped ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
funType . isSomeConstructorOrInterface ()
private Scope newScope () { return Scope . createGlobalScope ( new Node ( Token.ROOT ) ) ; }
@ Override public void setUp () { allowMethodCallDecomposing = false ; knownConstants . clear () ; }
testModules ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) )
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
{ test ( createCompilerOptions () , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testES6Modules () { testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testB3473189 () { testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
options . setErrorHandler ( new BlackHoleErrorManager () ) ;
String classAndItsMethodAliasedAsExtern = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String getPropertyName () { return checkNotNull ( propertyName ) ; }
if ( toRemove . isParamList () ) {} else { throw new IllegalStateException ( STRING_CONSTANT + toRemove . toStringTree () ) ; }
@ Override public boolean isApplied ( CompilerOptions options ) { return options . shouldCollapseProperties () ; }
assertTrue ( options . shouldCollapseProperties () ) ;
assertTrue ( options . shouldCollapseProperties () ) ;
assertTrue ( options . shouldCollapseProperties () ) ;
assertTrue ( options . shouldCollapseProperties () ) ;
@ Override public FeatureSet featureSet () { return ES8_MODULES ; }
public void testNoGlobalScopeChanges () { testSame ( STRING_CONSTANT ) ; }
return ! NodeUtil . isNameDeclaration ( n . getFirstChild () ) ;
return new RemoveUnusedVars ( compiler , ! removeOnlyLocals , preserveAnonymousFunctionNames , options.removeUnusedPrototypeProperties ) ;
( getTypeDeprecationInfo ( getTypeOfThis ( scopeRoot ) ) != null )
Var var
Var var
@ Override boolean isClassOrPrototypeNamedProperty () { return true ; }
boolean isIndependentlyRemovableNamedProperty () { return isPrototypeObjectNamedPropertyAssignment () || isClassOrPrototypeNamedProperty () ; }
boolean isClassOrPrototypeNamedProperty () { return false ; }
isGlobal && ! removeGlobals && ! removeUnusedPrototypeProperties
removeUnusedPrototypeProperties && removable . isNamedProperty ()
if ( removeUnusedPrototypeProperties ) { removeUnreferencedProperties () ; }
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedCode () ) ; }
{ passes . add ( flowSensitiveInlineVariables ) ; if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedCodeOnce () ) ; } }
new RemoveUnusedCode.Builder ( compiler ) . removeGlobals ( true ) . build () . process ( externs , root ) ;
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( removeUnusedCode ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new RewriteGlobalClassFunctionDeclarationsToVarAssignmentsCallback () ) ;
SimpleDependencyInfo . builder ( closureRelativePath , filePath ) . setProvides ( provides ) . setRequires ( requires ) . setWeakRequires ( weakRequires ) . setLoadFlags ( loadFlags ) . build ()
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedCode () ) ; }
atLeast8 = mode == Mode.ES8_OR_GREATER || mode == Mode.ES_NEXT ;
ImmutableList < String > getWeakRequires ( ) ;
ImmutableList < String > getRequires ( ) ;
ImmutableList < String > getProvides ( ) ;
public void testDefaultParam_argIsUnknown () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testDefaultParam_argIsUndefined () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrayPatternParam () { testSame ( STRING_CONSTANT ) ; }
visitParamList ( n , parent ) ;
Annotation annotation = annotations . get ( annotationName ) ;
config . languageMode () != LanguageMode.TYPESCRIPT
if ( config . languageMode () == LanguageMode.ECMASCRIPT3 ) { errorReporter . error ( SETTER_ERROR_MESSAGE , sourceName , lineno ( node ) , NUMBER_CONSTANT ) ; return true ; }
if ( config . languageMode () == LanguageMode.ECMASCRIPT3 ) { errorReporter . error ( GETTER_ERROR_MESSAGE , sourceName , lineno ( node ) , NUMBER_CONSTANT ) ; return true ; }
if ( config . languageMode () == LanguageMode.ECMASCRIPT3 ) { errorReporter . warning ( INVALID_ES3_PROP_NAME , sourceName , node . getLineno () , node . getCharno () ) ; }
{ checkState ( config . runMode () == Config.RunMode.KEEP_GOING ) ; bodyNode = IR . block () ; }
if ( shouldRunRemoveUnusedCode () ) { passes . add ( removeUnusedCode ) ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . removeLocalVars ( true ) . build () ; }
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new CollapseProperties ( compiler , options . getPropertyCollapseLevel () ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new CollapseProperties ( compiler , propertyCollapseLevel ) ; }
@ Override public void apply ( CompilerOptions options , boolean value ) { options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ; }
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
new CollapseProperties ( compiler , PropertyCollapseLevel.ALL ) . process ( externs , js ) ;
if ( p != null && ! canCollapse ( p ) ) { continue; }
if ( ! canCollapseChildNames || ! canCollapse ( n ) ) { return; }
if ( ! canCollapseChildNames || ! canCollapse ( n ) ) { return; }
isObjLit && canEliminate ( n )
isObjLit && canEliminate ( n )
if ( canCollapse ( n ) ) { updateGlobalNameDeclaration ( n , alias , canCollapseChildNames ) ; }
collapsePropertiesLevel = PropertyCollapseLevel.NONE ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CollapseProperties ( compiler , PropertyCollapseLevel.ALL ) ; }
CollapseProperties collapseProperties = new CollapseProperties ( compiler , PropertyCollapseLevel.ALL ) ;
if ( options.removeUnusedPrototypeProperties ) { passes . add ( removeUnusedPrototypeProperties ) ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . build () ; }
if ( NodeUtil . isNameDeclaration ( parent ) || parent . isFunction () ) { return true ; }
if ( shouldRunRemoveUnusedCode () ) { passes . add ( removeUnusedCode ) ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . removeLocalVars ( true ) . build () ; }
{ options . setCollapsePropertiesLevel ( value ? PropertyCollapseLevel.ALL : PropertyCollapseLevel.NONE ) ; }
for ( String filename : files ) { if ( fix ) { fixRepeatedly ( filename ) ; } else { lint ( filename ) ; } }
passes . add ( removeUnusedCodeOnce ) ;
String qualifiedName = getAliasedNamespace ( aliasVar . getInitialValue () ) ;
String aliasExpanded = checkNotNull ( getAliasedNamespace ( aliasDefinition ) ) ;
this . inliningReach = Reach.LOCAL_ONLY ;
public void testLocalFunctionInliningOnly4 () { this . inliningReach = Reach.LOCAL_ONLY ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalFunctionInliningOnly3 () { this . inliningReach = Reach.LOCAL_ONLY ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalFunctionInliningOnly2 () { this . inliningReach = Reach.LOCAL_ONLY ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
inliningReach = Reach.ALL ;
{ options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2017 ) ; options . setLanguageOut ( value ? CompilerOptions.LanguageMode.ECMASCRIPT5 : CompilerOptions.LanguageMode.NO_TRANSPILE ) ; }
public boolean includesGlobals () { return this == ALL ; }
logger . finest ( STRING_CONSTANT + file . getName () ) ;
checkArgument ( NodeUtil . isAssignmentOp ( assignNode ) , assignNode ) ;
Node superClassNameNode = metadata.superClassNameNode . cloneTree () ;
public void testIssue618_2 () { this . removeGlobal = false ; testSame ( STRING_CONSTANT ) ; }
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
VarInfo varInfo = traverseNameNode ( classNameNode , classScope ) ;
VarInfo varInfo = traverseNameNode ( classNameNode , scope ) ;
VarInfo varInfo = traverseNameNode ( nameNode , scope ) ;
VarInfo varInfo = traverseNameNode ( nameNode , scope ) ;
VarInfo exceptionVarInfo = traverseNameNode ( exceptionNameNode , scope ) ;
rhs == null || PotentialDeclaration . isTypedRhs ( rhs ) || NodeUtil . isCallTo ( rhs , STRING_CONSTANT ) || isImportRhs ( rhs )
getAllSymbols ()
public Iterable < Symbol > getAllSymbols () { return ImmutableList . copyOf ( symbols . values () ) ; }
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
getAllSymbols ()
getAllSymbols ()
{ validateEnumStringKey ( c ) ; }
if ( parent . isObjectPattern () ) { return ! n . isStringKey () ; }
if ( node . isStringKey () && node . isShorthandProperty () ) { t . report ( node , SHORTHAND_ASSIGNMENT_IN_ENUM ) ; }
if ( key . isShorthandProperty () ) { maybeWarn = true ; }
passes . add ( extraSmartNamePass ) ;
options . setInlineFunctions ( Reach.NONE ) ;
options . setInlineFunctions ( Reach.ALL ) ;
options . setInlineFunctions ( Reach.ALL ) ;
options . setInlineFunctions ( Reach.ALL ) ;
{ this . setInlineFunctions ( inlineFunctions ? Reach.ALL : Reach.NONE ) ; }
allSymbols . addAll ( table . getAllSymbols () ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; }
boolean isPrototypeProperty () { return isPrototypeObjectNamedPropertyAssignment () || isClassOrPrototypeNamedProperty () ; }
if ( isClassMethod ( functionNode ) ) { return STRING_CONSTANT . equals ( functionNode . getParent () . getString () ) ; }
isClassMethod ( functionNode )
{ if ( isImport ) { currentFile . recordImport ( name . getString () ) ; } else { currentFile . recordNameDeclaration ( name , t . getScope () ) ; } }
String name = ClassUtil . getPrototypeNameOfMethod ( functionNode ) ;
if ( ClassUtil . isConstructor ( n ) && n . getLastChild () . hasChildren () ) { currentFile . markConstructorToProcess ( n ) ; }
newJsdoc == null && ClassUtil . isThisProp ( nameNode )
if ( ClassUtil . isClassMethod ( n ) ) { currentFile . recordMethod ( n , t . getScope () ) ; }
! ClassUtil . isConstructor ( n )
{ if ( isTypeCompatible ( receiverType , method . type () ) ) { unusedMethodPolyfills . remove ( method ) ; } }
checkArgument ( ClassUtil . isClassMethod ( functionNode ) ) ;
private boolean isAssignmentToPrototype ( Node n ) { return n . isAssign () && isDotPrototype ( n . getFirstChild () ) ; }
long nodeCount = graph . getNodeCount () ;
checkState ( n . isName () || n . isImportStar () , STRING_CONSTANT , n ) ;
if ( NodeUtil . isLValue ( n ) ) { return n ; }
if ( NodeUtil . isLValue ( n ) ) { return n ; }
if ( NodeUtil . isLValue ( n ) ) { return n ; }
boolean isPrototypeProperty () { return isPrototypeDotPropertyReference () || isClassOrPrototypeNamedProperty () ; }
removeUnusedThisProperties && removable . isThisDotPropertyReference ()
RemovableBuilder builder = new RemovableBuilder () . setIsThisDotPropertyReference ( true ) ;
{ fsCalled . setRemove ( false ) ; if ( ! minimizeCost ( fsCalled ) ) { fsCalled . disallowInlining () ; } }
{ Node rootNode = scopeRoots . get ( i - NUMBER_CONSTANT ) ; if ( isHoistScopeRootNode ( rootNode ) ) { return rootNode ; } }
public boolean isHoistScope () { return isHoistScopeRootNode ( getScopeRoot () ) ; }
checkState ( ( NodeUtil . isNameDeclaration ( parent ) && var . isGlobal () ) || NodeUtil . isFunctionDeclaration ( parent ) ) ;
if ( aliasVar != null ) { return aliasVar . isGlobal () ; }
Node name = importSpec . getSecondChild () ;
validateChildCount ( n , NUMBER_CONSTANT ) ;
validateChildCount ( n , NUMBER_CONSTANT ) ;
test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
Builder removeUnusedConstructorProperties ( boolean value ) { this . removeUnusedStaticProperties = value ; return this ; }
this . removeUnusedStaticProperties = builder.removeUnusedStaticProperties ;
Scope s = getAbstractScope () ;
refinedScope != null && getAbstractScope () != refinedScope
checkArgument ( ! name . isEmpty () ) ;
String name = ClassUtil . getFullyQualifiedNameOfMethod ( functionNode ) ;
NodeUtil . deleteNode ( getRemovableNode () , compiler ) ;
Node oldStatement = getRemovableNode () ;
Node getRemovableNode () { return NodeUtil . getEnclosingStatement ( lhs ) ; }
@ Override public boolean hasReferenceName () { checkNotNull ( referencedObjType ) ; return referencedObjType . hasReferenceName () ; }
passes . add ( removeUnusedCodeOnce ) ;
testModules ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( NodeUtil . mayHaveSideEffects ( objExpression ) ) { replaceNodeWith ( incOrDecNode , objExpression . detach () ) ; } else { removeExpressionCompletely ( incOrDecNode ) ; }
if ( NodeUtil . mayHaveSideEffects ( objExpression ) ) { replaceNodeWith ( referenceNode , objExpression . detach () ) ; } else { removeExpressionCompletely ( referenceNode ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
Arguments ( Scope scope ) { super ( ARGUMENTS , null , scope , - NUMBER_CONSTANT , null ) ; }
@ Override public TypedScope getScope ( TypedVar var ) { return ( TypedScope ) var.scope ; }
Es6SyntacticScopeCreator scopeCreator = createScopeCreator () ;
AbstractScope < , > s
private void pushScope ( AbstractScope < , > s ) { pushScope ( s , false ) ; }
AbstractScope < , > refinedScope
AbstractScope < , > scope
AbstractScope < , > s
AbstractScope < , > parent
Es6SyntacticScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Var var = new Var ( name , nameNode , this , getVarCount () , input ) ;
{ ( ( Scope ) scope ) . declare ( name , n , input ) ; }
Es6SyntacticScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Scope hoistedScope = t . getClosestHoistScope () . untyped () ;
AbstractScope < , > parent
Es6SyntacticScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ return new FeatureSet ( union ( features , other.features ) ) ; }
public FeatureSet withoutTypes () { return new FeatureSet ( difference ( features , LangVersion.TYPESCRIPT . features () ) ) ; }
private FeatureSet ( EnumSet < Feature > features ) { this . features = ImmutableSet . copyOf ( features ) ; }
{ test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
! scope . isDeclared ( name , false ) && ! ( scope . isLocal () && name . equals ( Var.ARGUMENTS ) )
if ( Var.ARGUMENTS . equals ( name ) && NodeUtil . isVanillaFunction ( scope . getRootNode () ) ) { return scope . getArgumentsVar () ; }
@ Override public TypedScope getScope ( TypedVar var ) { return var.scope ; }
public final S getScope () { return scope ; }
if ( ! isFunctionScope () || rootNode . isArrowFunction () ) { return getParent () . getArgumentsVar () ; }
optimizations . add ( new MinimizeExitPoints () ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , ( String ) null ) ;
assertChanges ( externs , originalCode , template , ( String ) null ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( STRING_CONSTANT , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( STRING_CONSTANT , originalCode , template , expectedCode ) ;
public void clearTemplates () { templates = null ; matchedTemplates = null ; }
checkNotNull ( funType , STRING_CONSTANT , recvType , setterPname ) ;
this . moduleLoader = new ModuleLoader ( null , options.moduleRoots , inputs , ModuleLoader.PathResolver.RELATIVE , options.moduleResolutionMode , inputPathByWebpackId ) ;
options . setModuleResolutionMode ( resolutionMode ) ;
if ( isCommonJsImport ( n ) ) { visitRequireCall ( t , n , parent ) ; }
public JsonFileSpec ( String src , String path ) { this ( src , path , null , null ) ; }
if ( var . getParentNode () . isParamList () ) { varInfo.hasNonLocalOrNonLiteralValue = true ; }
catch ( RuntimeException e ) { throw new AssertionError ( STRING_CONSTANT , e ) ; }
@ Override public boolean preventsRemovalOfVariableWithNonLocalValueOrPrototype () { return true ; }
foldSame ( STRING_CONSTANT ) ;
public void testNewOperator3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNewOperator2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNewOperator1 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
return JSType . getLeastSupertype ( this , that ) ;
checkState ( n . hasOneChild () , n ) ;
Node newDeclaration = NodeUtil . newDeclaration ( lhsToSplit . detach () , rhs , n . getToken () ) . srcref ( n ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
Map < String , TypeI > props = new LinkedHashMap <> () ;
checkState ( mayBeStatement ( stmt ) , STRING_CONSTANT , stmt . getToken () ) ;
NameDeclarationStatement removable = builder . buildNameDeclarationStatement ( declarationStatement ) ;
( NodeUtil . isEnhancedFor ( parent ) )
public void testLoggerMethodCallByVariableType_var () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( grandparent != null && NodeUtil . isNameDeclaration ( grandparent ) ) { return false ; }
ParseTree right = parseExponentiationExpression () ;
return findModifiedParameters ( fnNode . getLastChild () , names , unsafeNames , false ) ;
public void testDirectPrototypeAssignment2 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRICT_INEXISTENT_PROPERTY ) ; }
public void testPropertyInference6 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRICT_INEXISTENT_PROPERTY ) ; }
catch ( IOException e ) { compiler . report ( JSError . make ( AbstractCompiler.READ_ERROR , sourceFile . getName () , e . getMessage () ) ) ; }
{ compiler . getErrorManager () . report ( CheckLevel.ERROR , JSError . make ( AbstractCompiler.READ_ERROR , getName () , e . getMessage () ) ) ; return SimpleDependencyInfo.EMPTY ; }
{ testClosureTypesMultipleWarnings ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , ImmutableList . of ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ) ; }
boolean allowDupe = VarCheck . hasDuplicateDeclarationSuppression ( compiler , referenceNode , v . getNameNode () ) ;
public void testMissingProperty30 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
TemplateAstMatcher astMatcher = new TemplateAstMatcher ( compiler . getTypeIRegistry () , templateRoot , typeMatchingStrategy ) ;
return fnThisType == null ? null : fnThisType . toObjectType () ;
IR . string ( t . getInput () . getName () )
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new CheckSuper ( compiler ) ; }
checks . add ( checkSuper ) ;
passes . add ( checkSuper ) ;
{ visitInterfaceGetprop ( t , assign , object , rvalue ) ; }
visitGetProp ( t , n ) ;
checkArgument ( scriptNode . isScript () , scriptNode ) ;
{ Node enclosingNode = NodeUtil . getEnclosingNode ( n , isLoopOrFunction ) ; return enclosingNode != null && ! enclosingNode . isFunction () ; }
{ return new Es6RewriteClass ( compiler , true ) ; }
assertTypeEquals ( typeRegistry . getNativeType ( BOOLEAN_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
suppressors . put ( STRING_CONSTANT , new DiagnosticGroupWarningsGuard ( new DiagnosticGroup ( DiagnosticGroups.CHECK_TYPES , DiagnosticGroups.STRICT_CHECK_TYPES ) , CheckLevel.OFF ) ) ;
if ( ! rewriteState . containsModule ( legacyNamespace ) ) { unrecognizedRequires . add ( new UnrecognizedRequire ( call , legacyNamespace , false ) ) ; }
@ Deprecated boolean inIncrementalCheckMode () { return incrementalCheckMode != IncrementalCheckMode.OFF ; }
Node originalFunction = checkNotNull ( functionContext.function ) ;
if ( getRhs () == null || shouldPreserve () ) { return; }
{ for ( PotentialDeclaration decl : currentFile . getDeclarations () . get ( name ) ) { processDeclaration ( name , decl ) ; } }
jsdoc == null || ! jsdoc . containsDeclaration () || isConstToBeInferred ( jsdoc , jsdocNode )
if ( ! PotentialDeclaration . isConstToBeInferred ( originalJsdoc , nameNode ) ) { return; }
boolean isImport = PotentialDeclaration . isImportRhs ( rhs ) ;
lhsToSplit . isDestructuringLhs () && ! PotentialDeclaration . isImportRhs ( lhsToSplit . getLastChild () )
PotentialDeclaration . isConstToBeInferred ( jsdoc , nameNode ) && ! nameNode . isFromExterns () && ! JsdocUtil . isPrivate ( jsdoc )
checkState ( caseBody . isNormalBlock () , caseBody ) ;
checkState ( first . getString () . isEmpty () , first ) ;
testSame ( externs ( externs ) , srcs ( code ) ) ;
testSame ( externs ( EXTERNS ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( CompilerTypeTestCase.DEFAULT_EXTERNS ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( externs ) , srcs ( code ) ) ;
testSame ( externs ( externs ) , srcs ( code ) ) ;
testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ;
{ testSame ( externs ( externs ) , srcs ( source ) ) ; assertEquals ( expected , found ) ; found . clear () ; }
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( SHARED_EXTERNS ) , srcs ( js ) ) ;
testSame ( externs ( ALL_NATIVE_EXTERN_TYPES ) , srcs ( STRING_CONSTANT ) ) ;
public void testIssue2508576_1 () { String externs = STRING_CONSTANT ; testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ; }
public void testClassExtern () { String externs = STRING_CONSTANT ; testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ; }
public void testObjectLitExtern2 () { String externs = STRING_CONSTANT ; testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ; }
public void testObjectLitExtern1 () { String externs = STRING_CONSTANT ; testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ; }
testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ;
tester . testSame ( externs ( STRING_CONSTANT ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( METHOD_DEFS ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
private void testSameEs6Strict ( String js ) { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( js ) ; }
testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String externs = DEFAULT_EXTERNS . replace ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Map < String , StaticTypedSlot < JSType > > slots = new HashMap <> () ;
NodeUtil . isNameDeclaration ( parent )
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil : : isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil : : isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil : : isNameDeclaration ) ;
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil.isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil.isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil.isNameDeclaration ) ;
addExpr ( first . getNext () , NUMBER_CONSTANT , Context.OTHER ) ;
{ return parent . getParent () ; }
public void testFindExpressionRoot5 () { assertNode ( findExpressionRoot ( STRING_CONSTANT , STRING_CONSTANT ) ) . hasType ( Token.FOR ) ; }
if ( that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL ) ) ) { return UNKNOWN ; } else { return FALSE ; }
{ registerMismatchAndReport ( n , INVALID_OPERAND_TYPE , msg , type , getNativeType ( NUMBER_STRING ) , null , null ) ; }
this . allBitwisableValueTypes = typeRegistry . createUnionType ( STRING_TYPE , NUMBER_TYPE , BOOLEAN_TYPE , NULL_TYPE , VOID_TYPE ) ;
{ return ! isReasonableObjectPropertyKey ( templatizedType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ) ; }
allDeps . addAll ( input . getRequiredSymbols () ) ;
input . getKnownRequiredSymbols ()
public abstract Builder setRequires ( Collection < Require > requires ) ;
writeJsArray ( out , Require . asSymbolList ( info . getRequires () ) ) ;
ImmutableList < Require > getRequires ( ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) ) )
ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) , googRequireSymbol ( STRING_CONSTANT ) )
userOrderedInput . getRequiredSymbols ()
input . getRequiredSymbols ()
{ input . addOrderedRequire ( Require . compilerModule ( require ) ) ; }
public void addRequire ( Require require ) { extraRequires . add ( require ) ; }
Require require
requires . addAll ( deps . getRequiredSymbols () ) ;
for ( String require : dependency . getRequiredSymbols () ) { addDependency ( require , seen , list ) ; }
rootInput . getRequiredSymbols ()
public void testGithubIssue2818 () { noInline ( STRING_CONSTANT ) ; noInline ( STRING_CONSTANT ) ; noInline ( STRING_CONSTANT ) ; }
{ assertNotNull ( warning ) ; test ( externs ( externs ) , srcs ( js ) , warning ( warning ) . withMessage ( description ) ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( inputs ) , warning ( warning ) . withMessage ( description ) ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( js ) , warning ( warning ) . withMessage ( description ) ) ; }
{ assertNotNull ( error ) ; test ( srcs ( inputs ) , error ( error ) . withMessage ( description ) ) ; }
{ assertNotNull ( error ) ; test ( srcs ( js ) , error ( error ) . withMessage ( description ) ) ; }
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR ) . withMessage ( message ) ) ;
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR ) . withMessage ( message ) ) ;
test ( externs ( externs ) , srcs ( STRING_CONSTANT ) , expected ( STRING_CONSTANT ) , warning ( e ) . withMessage ( STRING_CONSTANT + STRING_CONSTANT ) ) ;
testError ( srcs ( js ) , error ( BAD_PRIVATE_PROPERTY_ACCESS ) . withMessage ( STRING_CONSTANT ) ) ;
error ( BAD_PRIVATE_PROPERTY_ACCESS ) . withMessage ( STRING_CONSTANT )
error ( BAD_PRIVATE_PROPERTY_ACCESS ) . withMessage ( STRING_CONSTANT )
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING ) . withMessage ( warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING ) . withMessage ( warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING ) . withMessage ( warning ) ) ;
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_FOR_GOOG_SCOPE ) . withMessage ( warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_WARNING ) . withMessage ( warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_WARNING ) . withMessage ( warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_STRICT_WARNING ) . withMessage ( warningText ) ) ; }
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , expected ( expected ) , warning ( warning ) . withMessage ( description ) ) ;
allDeps . addAll ( input . getRequires () ) ;
input . getKnownRequires ()
public abstract Builder setRequires ( Collection < String > requires ) ;
writeJsArray ( out , info . getRequires () ) ;
ImmutableList < String > getRequires ( ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( STRING_CONSTANT ) )
ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT )
userOrderedInput . getRequires ()
input . getRequires ()
{ input . addOrderedRequire ( require ) ; }
public void addRequire ( String require ) { extraRequires . add ( require ) ; }
String require
requires . addAll ( deps . getRequires () ) ;
for ( String require : dependency . getRequires () ) { addDependency ( require , seen , list ) ; }
rootInput . getRequires ()
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks , preprocessorSymbolTableFactory ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes , preprocessorSymbolTableFactory ) ; }
TranspilationPasses . addEs6ModulePass ( factories , new PreprocessorSymbolTable.CachedInstanceFactory () ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null ) ; }
n . putBooleanProp ( Node.MODULE_ALIAS , true ) ;
noInline ( STRING_CONSTANT ) ;
noInline ( STRING_CONSTANT ) ;
for ( TemplateType unused : obj . getTemplateTypeMap () . getTemplateKeys () ) { unknowns . add ( getNativeType ( UNKNOWN_TYPE ) ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
public void testIssue70b () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.LANGUAGE_FEATURE ) ; }
public void testIssue70a () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.LANGUAGE_FEATURE ) ; }
rewriteGeneratorBody ( STRING_CONSTANT , lines ( STRING_CONSTANT ) ) ;
if ( node . hasTwoChildren () && node . getLastChild () . isString () ) { info.importedModules . add ( node . getLastChild () . getString () ) ; }
TypedScopeCreator typedScopeCreator = getTypedScopeCreator () ;
TypedScopeCreator getTypedScopeCreator () { return typedScopeCreator ; }
scopeCreator = new TypedScopeCreator ( compiler ) ;
TypedScopeCreator scopeCreator
TypedScopeCreator scopeCreator
allDeps . addAll ( input . getRequiredSymbols () ) ;
input . getKnownRequiredSymbols ()
public abstract Builder setRequires ( Collection < Require > requires ) ;
writeJsArray ( out , Require . asSymbolList ( info . getRequires () ) ) ;
ImmutableList < Require > getRequires ( ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) ) )
ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) , googRequireSymbol ( STRING_CONSTANT ) )
userOrderedInput . getRequiredSymbols ()
input . getRequiredSymbols ()
{ input . addOrderedRequire ( Require . compilerModule ( require ) ) ; }
public void addRequire ( Require require ) { extraRequires . add ( require ) ; }
Require require
requires . addAll ( deps . getRequiredSymbols () ) ;
for ( String require : dependency . getRequiredSymbols () ) { addDependency ( require , seen , list ) ; }
rootInput . getRequiredSymbols ()
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives ; }
noInline ( STRING_CONSTANT ) ;
public void testNoInlineGetElem () { noInline ( STRING_CONSTANT ) ; }
public void testNoInlineGetProp1 () { noInline ( STRING_CONSTANT ) ; }
@ Override public StaticTypedScope < JSType > getParentScope () { throw new UnsupportedOperationException () ; }
final Scope usageScope
List < String > provides = new ArrayList <> ( depInfo . getProvides () ) ;
disableStrictMissingPropertyChecks () ;
disableStrictMissingPropertyChecks () ;
disableStrictMissingPropertyChecks () ;
{ disableStrictMissingPropertyChecks () ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
disableStrictMissingPropertyChecks () ;
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
disableStrictMissingPropertyChecks () ;
disableStrictMissingPropertyChecks () ;
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
disableStrictMissingPropertyChecks () ;
{ return testForEquality ( that ) . equals ( TernaryValue.UNKNOWN ) ; }
this . nullOrUndefined = typeRegistry . getNativeType ( JSTypeNative.NULL_VOID ) ;
rewriteGeneratorBodyWithVars ( STRING_CONSTANT , STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
context . writeGeneratedNode ( IR . ifNode ( condition , context . createJumpToBlock ( startCase , false , n ) ) . useSourceInfoFrom ( n ) ) ;
IR . ifNode ( IR . not ( condition ) . useSourceInfoFrom ( condition ) , context . createJumpToBlock ( endCase , true , n ) ) . useSourceInfoFrom ( n )
IR . ifNode ( IR . not ( condition ) . useSourceInfoFrom ( condition ) , context . createJumpToBlock ( endCase , true , n ) ) . useSourceInfoFrom ( n )
if ( options . needsTranspilationFrom ( ES2018 ) ) { TranspilationPasses . addEs2018Passes ( passes ) ; passes . add ( setFeatureSet ( ES8 ) ) ; }
parseWarning ( STRING_CONSTANT , getRequiresEs2018Message ( Feature.OBJECT_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs2018Message ( Feature.OBJECT_PATTERN_REST ) ) ;
if ( options . needsTranspilationFrom ( ES2018 ) ) { TranspilationPasses . addEs2018Passes ( checks ) ; checks . add ( setFeatureSet ( ES8 ) ) ; }
return isValidAliasRhs ( rhs ) ;
if ( this . isNoOp () ) { return STRING_CONSTANT ; }
allJsDocParams = ( info == null ) ? new HashSet <> () : new HashSet <> ( info . getParameterNames () )
domHelperType = compiler . getTypeIRegistry () . getGlobalType ( STRING_CONSTANT ) ;
{ super ( compiler , requirement ) ; errorObjType = compiler . getTypeIRegistry () . getGlobalType ( STRING_CONSTANT ) ; }
TypeI methodClassType = registry . getGlobalType ( r.type ) ;
TypeI typeWithBannedProp = registry . getGlobalType ( prop.type ) ;
{ TypeI type = registry . getGlobalType ( typeName ) ; if ( type != null ) { types . add ( type ) ; } }
{ return metadata . getCompiler () . getTypeRegistry () . getGlobalType ( type ) ; }
TypeI mathType = compiler . getTypeIRegistry () . getGlobalType ( STRING_CONSTANT ) ;
JSType type = typeRegistry . getGlobalType ( dottedName ) ;
TypeI methodClassType = registry . getGlobalType ( className ) ;
JSType type = compiler . getTypeRegistry () . getType ( STRING_CONSTANT ) ;
{ return registry . getGlobalType ( typeName ) ; }
final Scope scope = t . getScope () ;
ImmutableList.Builder < Callback > callbacks = ImmutableList . builder () ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
Predicates . alwaysTrue ()
parent . isAssign () && parent . getFirstChild () == getProp && getProp . getLastChild () . getString () . equals ( STRING_CONSTANT )
parent . isAssign () && parent . getFirstChild () == getProp && parent . getFirstChild () . getLastChild () . getString () . equals ( STRING_CONSTANT )
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil : : isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil : : isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil : : isNameDeclaration ) ;
Streams . stream ( fixChoices ) . map ( choices - > choices . getAlternatives () . get ( choiceIndex ) )
Streams . stream ( fixChoices ) . map ( f - > f . getAlternatives () . size () )
newVar = declare ( scopeToDeclareIn , variableName , n , type , input , inferred ) ;
testNotEs6TypedFullError ( STRING_CONSTANT , STRING_CONSTANT ) ;
testNotEs6TypedFullError ( STRING_CONSTANT , STRING_CONSTANT ) ;
testNotEs6TypedFullError ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ parse ( STRING_CONSTANT ) ; expectErrors ( STRING_CONSTANT ) ; parse ( STRING_CONSTANT ) ; testNotEs6TypedFullError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( isKeyword ( importedName.value ) ) { reportError ( importedName , STRING_CONSTANT , importedName.value ) ; }
if ( isKeyword ( importedName.value ) ) { reportExpectedError ( null , PredefinedName.AS ) ; }
this . scanner = new Scanner ( config.parseTypeSyntax , errorReporter , commentRecorder , source , offset ) ;
checkState ( nameNode . isName () , nameNode ) ;
for ( Case currentCase : allCases ) { switchNode . addChildToBack ( currentCase . createCaseNode () ) ; }
{ currentCase.embedInto . replaceWith ( currentCase.caseBlock ) ; it . remove () ; continue; }
this . context = new TranspilationContext () ;
ImmutableSortedSet . copyOf ( comparingByKey () , map . entrySet () )
{ this . cache = builder . build ( CacheLoader . from ( delegate : : transform ) ) ; }
{ return this : : transform ; }
{ return function : : apply ; }
this . modulePaths = resolvePaths ( Iterables . transform ( Iterables . transform ( inputs , DependencyInfo : : getName ) , pathResolver ) , moduleRootPaths ) ;
{ maybeAddUsage ( t , n , typeNode , false , Predicates . alwaysTrue () ) ; }
Predicates . alwaysTrue ()
reserved = previousMap != null ? previousMap . getNewNameToOriginalNameMap () . keySet () : Collections . emptySet ()
Arrays . sort ( arr , Ordering . natural () ) ;
Predicates . alwaysTrue ()
return NodeUtil . has ( callNode , hasSpreadCallArgumentPredicate , Predicates . alwaysTrue () ) ;
return ! referencesArguments && ! NodeUtil . has ( block , p , Predicates . alwaysTrue () ) ;
for ( Node typeNode : info . getTypeNodes () ) { NodeUtil . visitPreOrder ( typeNode , fixJsdocTypeNodes , Predicates . alwaysTrue () ) ; }
{ return chars == null ? ImmutableSet . of () : ImmutableSet . copyOf ( Chars . asList ( chars ) ) ; }
invalidations = FluentIterable . from ( invalidationMap . get ( t ) ) . transform ( Suppliers . supplierFunction () ) . limit ( MAX_INVALIDATION_WARNINGS_PER_PROPERTY )
this . invalidationMap = propertiesToErrorFor . isEmpty () ? null : LinkedHashMultimap . create () ;
for ( Node typeNode : info . getTypeNodes () ) { NodeUtil . visitPreOrder ( typeNode , replaceJsDocRefs ) ; }
return invocation . hasOneChild () ? ImmutableList . of () : invocation . getSecondChild () . siblings () ;
{ return getCount ( node , new MatchNameNode ( name ) , Predicates . alwaysTrue () ) ; }
return result == null ? ImmutableList . of () : ImmutableList . of ( result ) ;
{ return eval ( ttlAst , typeVars , ImmutableMap . of () ) ; }
ImmutableSet . of ()
Predicates . alwaysTrue ()
List < Ref > getRefs () { return refs == null ? ImmutableList . of () : refs ; }
if ( customPasses == null ) { customPasses = LinkedHashMultimap . create () ; }
{ this ( compiler , behavior , creator , Predicates . alwaysTrue () ) ; }
return NodeUtil . has ( node , pred , Predicates . alwaysTrue () ) ;
return new JSTypeExpression ( typeNode , VIRTUAL_FILE ) ;
TypeI type = registry . getGlobalType ( target . getFirstFirstChild () . getQualifiedName () ) ;
JSType type = compiler . getTypeRegistry () . getGlobalType ( STRING_CONSTANT ) ;
{ final JSType voidType = compiler . getTypeRegistry () . getNativeType ( JSTypeNative.VOID_TYPE ) ; return voidType . isSubtype ( returnType ) ; }
TypeI type = compiler . getTypeIRegistry () . getGlobalType ( typeName ) ;
{ return isTheObjectType () || isStringObjectType () || isDateType () || isRegexpType () || isArrayType () || isNumberObjectType () || isBooleanObjectType () || hasOverriddenNativeProperty ( STRING_CONSTANT ) ; }
@ Override public boolean matchesNumberContext () { return isNumberObjectType () || isDateType () || isBooleanObjectType () || isStringObjectType () || hasOverriddenNativeProperty ( STRING_CONSTANT ) ; }
public void testMissingProperty33 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty22 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty21 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty18 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty15 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty12 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty11 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty10 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty9 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
JSTypeExpression expr = new JSTypeExpression ( getCallArgument ( ttlAst , NUMBER_CONSTANT ) , VIRTUAL_FILE ) ;
compiler . getOptions () . getLanguageOut () . toFeatureSet () . contains ( ES6 )
if ( options . getLanguageOut () . toFeatureSet () . contains ( ES6 ) ) { passes . add ( optimizeToEs6 ) ; }
if ( options.dartPass && ! options . getLanguageOut () . toFeatureSet () . contains ( ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
{ CompilerOptions options = super . getDefaultOptions () ; options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ; options . setLanguageOut ( LanguageMode.ECMASCRIPT5 ) ; return options ; }
return ( nameNode . hasChildren () || isLhsOfEnhancedForExpression ( nameNode ) ) ;
if ( node . isQuotedString () || ! node . hasChildren () ) { return; }
{ if ( pos >= js . length () ) { return null ; } else { return js . substring ( pos ) ; } }
declList . sort ( DECLARATIONS_FIRST ) ;
{ JSType newType = objType . getTemplateTypeMap () . getResolvedTemplateType ( registry . getIterableTemplate () ) ; redeclareSimpleVar ( informed , item , newType ) ; }
abstract JSType resolveInternal ( ErrorReporter reporter , StaticTypedScope < JSType > scope ) ;
@ Override JSType resolveInternal ( ErrorReporter reporter , StaticTypedScope < JSType > scope ) { return this ; }
@ Override JSType resolveInternal ( ErrorReporter reporter , StaticTypedScope < JSType > scope ) { return this ; }
@ Override JSType resolveInternal ( ErrorReporter reporter , StaticTypedScope < JSType > scope ) { return this ; }
ErrorReporter reporter
private String transpileEs6Module ( String s ) { return transpile ( s , es6ModuleTranspiler ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModulesToCommonJsModules ( compiler , STRING_CONSTANT ) ; }
! type . isSubtypeOf ( typeRegistry . getNativeType ( OBJECT_TYPE ) )
! jsType . isUnknownType () && ! jsType . isAllType () && jsType . isSubtypeOf ( providedJsType )
if ( that . isUnknownType () || that . isSubtypeOf ( getNativeType ( JSTypeNative.NUMBER_STRING_BOOLEAN ) ) || that . isObject () ) { return UNKNOWN ; }
assertFalse ( arrayOfString . isSubtypeOf ( createUnionType ( arrayOfNumber , NULL_VOID ) ) ) ;
if ( that . isSubtypeOf ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL ) ) ) { return UNKNOWN ; }
if ( isEmptyType () || that . isEmptyType () ) { return isSubtypeOf ( that ) || that . isSubtypeOf ( this ) ; }
{ JSType alternate = alternatesList . get ( i ) ; if ( alternate . isSubtypeOf ( arrayType ) ) { return true ; } }
public final boolean isSymbol () { return isSubtypeOf ( getNativeType ( JSTypeNative.SYMBOL_VALUE_OR_OBJECT_TYPE ) ) ; }
public final boolean isNumber () { return isSubtypeOf ( getNativeType ( JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE ) ) ; }
public final boolean isString () { return isSubtypeOf ( getNativeType ( JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE ) ) ; }
assertTrue ( x . isSubtypeOf ( windowCtor . getInstanceType () ) ) ;
assertTrue ( x . isSubtypeOf ( windowCtor . getInstanceType () ) ) ;
assertTrue ( y . isSubtypeOf ( getNativeType ( STRING_TYPE ) ) ) ;
{ return type . isSubtypeOf ( getNativeType ( ARRAY_TYPE ) ) ? null : type ; }
{ JSType arrayType = getNativeType ( ARRAY_TYPE ) ; return arrayType . isSubtypeOf ( type ) ? arrayType : null ; }
if ( resultEqualsValue ) { return ctorType . getGreatestSubtype ( type ) ; } else { return type . isSubtypeOf ( ctorType ) ? null : type ; }
assertTrue ( unknown . isSubtypeOf ( STRING_TYPE ) ) ;
assertTrue ( NULL_TYPE . isSubtypeOf ( nullOrUnknown ) ) ;
assertTrue ( STRING_CONSTANT + varType + STRING_CONSTANT + name + STRING_CONSTANT + type + STRING_CONSTANT , varType . isSubtypeOf ( type ) ) ;
return thisType . isSubtypeOf ( thatType ) || thatType . isSubtypeOf ( thisType ) ;
{ if ( thisType . isFunctionType () ) { return true ; } else { return thisType . isSubtypeOf ( functionType ) || functionType . isSubtype ( thisType ) ; } }
if ( isStructural && ! thisUnresolved && ! thatUnresolved ) { return rightType . isSubtypeOf ( leftType ) ; } else { return rightType . isSubtypeWithoutStructuralTyping ( leftType ) ; }
return new BooleanOutcomePair ( jsType . getPossibleToBooleanOutcomes () , registry . getNativeType ( BOOLEAN_TYPE ) . isSubtypeOf ( jsType ) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY , flowScope , flowScope ) ;
outcome.booleanValues == BooleanLiteralSet.EMPTY && getNativeType ( BOOLEAN_TYPE ) . isSubtypeOf ( type )
argObjectType . isSubtypeOf ( referencedParamType )
{ if ( this . isSubtype ( rawThat ) ) { return this ; } else if ( rawThat . isSubtypeOf ( this ) ) { return filterNoResolvedType ( rawThat ) ; } }
@ Override public boolean isSubtype ( JSType that ) { return this . isSubtype ( that , ImplCache . create () , SubtypingMode.NORMAL ) ; }
if ( that . isUnknownType () || that . isSubtypeOf ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; }
{ final JSType voidType = compiler . getTypeRegistry () . getNativeType ( JSTypeNative.VOID_TYPE ) ; return voidType . isSubtypeOf ( returnType ) ; }
! argType . isSubtypeOf ( paramType )
! rightType . isSubtypeOf ( leftType )
! leftType . isNoType () && ! rightType . isSubtypeOf ( leftType )
! switchType . canTestForShallowEqualityWith ( caseType ) && ( caseType . autoboxesTo () == null || ! caseType . autoboxesTo () . isSubtypeOf ( switchType ) )
! type . isNoType () && ! type . isUnknownType () && type . isSubtypeOf ( nullOrUndefined ) && ! containsForwardDeclaredUnresolvedName ( type )
! type . isSubtypeOf ( getNativeType ( NUMBER_STRING_SYMBOL ) )
! type . isSubtypeOf ( getNativeType ( NUMBER_STRING ) )
! type . matchesNumberContext () && ! type . isSubtypeOf ( allBitwisableValueTypes )
! type . isSubtypeOf ( getNativeType ( NUMBER_TYPE ) )
if ( ! anyObjectType . isSubtypeOf ( type ) && ! type . isEmptyType () ) { mismatch ( t , n , msg , type , anyObjectType ) ; }
if ( ! objType . isNoType () && ! objType . isUnknownType () && objType . isSubtypeOf ( getNativeType ( NULL_VOID ) ) ) { return; }
if ( castType . restrictByNotNullOrUndefined () . isSubtypeOf ( exprType ) || expr . isObjectLit () ) { expr . setJSType ( castType ) ; }
if ( funcTarget . hasInstanceType () ) { if ( type . isSubtypeOf ( funcTarget . getInstanceType () ) ) { return null ; } return type ; }
if ( t . isUnknownType () || t . isNoResolvedType () || ! t . isSubtypeOf ( type ) ) { restricted . addAlternate ( t ) ; }
if ( ! alternate . isUnknownType () && that . isSubtypeOf ( alternate ) ) { return this ; }
if ( that . isUnknownType () || that . isSubtypeOf ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_NEXT ) ;
boolean isConstToBeInferred () { return isConstToBeInferred ( getLhs () ) ; }
maybeWarnForConstWithoutExplicitType ( compiler , decl ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clPass ( compiler ) ; }
if ( astValidationEnabled ) { new AstValidator ( compiler ) . setTypeValidationEnabled ( typeInfoValidationEnabled ) . validateRoot ( root ) ; }
new PureFunctionIdentifier.Driver ( compiler , null ) . process ( externs , root ) ;
exportedNameToLocalQName . put ( name , new LocalQName ( name , export ) ) ;
exportedNameToLocalQName . put ( name , new LocalQName ( name , lhs ) ) ;
exportedNameToLocalQName . put ( STRING_CONSTANT , new LocalQName ( name , export ) ) ;
Map.Entry < String , LocalQName > entry
functionNames = compilerState.functionNames ;
this . functionNames = compiler.functionNames ;
assertScope ( moduleScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( moduleScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( blockScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( fooScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( forOfScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( functionBlockScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( functionScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( functionBlockScope ) . declares ( STRING_CONSTANT ) . directly () ;
catch ( FlagUsageException e ) { assertThat ( e ) . hasMessageThat () . isEqualTo ( STRING_CONSTANT ) ; }
return s != null ? s : createScope ( n , createScope ( NodeUtil . getEnclosingNode ( n . getParent () , NodeUtil : : isValidCfgRoot ) ) ) ;
TypeInference dfa = new TypeInference ( compiler , cfg , rai , assumedScope , scopeCreator , ASSERTION_FUNCTION_MAP ) ;
return v != null && v . isLocal () && v . isMarkedEscaped () && v . getScope () . getClosestNonBlockScope () == cfgRootScope ;
if ( isUnflowable ( currentScope . getVar ( varName ) ) ) { return; }
isLocallyInferred = ( var != currentScope . getSlot ( qualifiedName ) ) ;
ttlObj = new TypeTransformation ( compiler , currentScope ) ;
TypedVar var = currentScope . getVar ( qKeyName ) ;
TypedVar var = currentScope . getVar ( qName ) ;
TypedVar var = currentScope . getVar ( varName ) ;
{ type = info . getType () . evaluate ( currentScope , registry ) ; }
if ( info != null && info . hasType () ) { n . setJSType ( info . getType () . evaluate ( currentScope , registry ) ) ; }
if ( rename ) { NodeTraversal . traverseEs6 ( compiler , js , new Renamer () ) ; }
registry . createNullableType ( registry . getGlobalType ( STRING_CONSTANT ) )
assertTrue ( findNameType ( STRING_CONSTANT , lastLocalScope ) . isEquivalentTo ( registry . getType ( null , STRING_CONSTANT ) ) ) ;
{ super ( null , registry , reference , sourceName , lineno , charno ) ; }
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , jsdoc . getImplementedInterfaces () . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , types . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , interfaces . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , NUMBER_CONSTANT , NUMBER_CONSTANT ) , jsdoc . getBaseType () ) ;
{ assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , parse ( STRING_CONSTANT ) . getBaseType () ) ; }
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , interfaces . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( createNullableType ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
unresolvedNamedTypes . removeAll ( scope ) ;
public void clearNamedTypes () { unresolvedNamedTypes . clear () ; }
{ checkTypeName ( name ) ; namesToTypes . put ( name , type ) ; }
{ return ! checkEquivalenceHelper ( that , EquivalenceMethod.DATA_FLOW , EqCache . create () ) ; }
{ if ( constructorI . isEquivalentTo ( constructorJ ) ) { shouldCheck = false ; } }
{ assertTypeEquals ( expected , resolve ( actual ) ) ; }
! newType . isEquivalentTo ( varType , true )
{ this ( Functions . identity () , errorManager ) ; }
Node ast = parseSyntheticCode ( SYNTHETIC_CODE_PREFIX + resourceName + STRING_CONSTANT , originalCode ) ;
if ( scope . hasOwnSlot ( qName ) ) { continue; }
! scope . hasOwnSlot ( qName ) && n . isUnscopedQualifiedName ()
if ( ! name . isEmpty () && ! usageScope . hasSlot ( name ) ) { return true ; }
if ( current . hasOwnSlot ( oldName ) ) { return; } else { current = current . getParent () ; }
varsInFunctionBody . contains ( refName ) && ! scope . hasSlot ( refName )
n . isName () && ! t . getScope () . hasSlot ( n . getString () )
return v != null && v . isLocal () && v . isMarkedEscaped () && v . getScope () . getClosestContainerScope () == containerScope ;
this . containerScope = syntacticScope ;
curScope . hasSlot ( assignment.oldName )
while ( t . getScope () . hasSlot ( pseudoName ) ) { pseudoName += STRING_CONSTANT ; }
assertScope ( fooScope ) . declares ( STRING_CONSTANT ) . directly () ;
if ( ! scope . hasSlot ( NodeUtil.JSC_PROPERTY_NAME_FN ) ) { scope . declare ( NodeUtil.JSC_PROPERTY_NAME_FN , null , null ) ; }
AbstractVar < , > var = getVar ( name ) ;
AbstractVar < , > var = getVar ( name ) ;
if ( t . getScope () . hasSlot ( alias ) ) { compiler . report ( JSError . make ( n , TYPE_ALIAS_ALREADY_DECLARED , alias ) ) ; }
if ( ! getRootNode () . isFunction () ) { return getClosestContainerScope () . getTypeOfThis () ; }
if ( isUnflowable ( getDeclaredVar ( scope , varName ) ) ) { return; }
isLocallyInferred = ( var != getDeclaredVar ( scope , qualifiedName ) ) ;
backwardsInferenceFromCallSite ( n , ct , scope ) ;
backwardsInferenceFromCallSite ( n , fnType , scope ) ;
TypedVar var = getDeclaredVar ( scope , qKeyName ) ;
boolean unflowable = isInferred && isUnflowable ( getDeclaredVar ( scope , varName ) ) ;
{ type = info . getType () . evaluate ( scope . getDeclarationScope () , registry ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null , false , ResolutionMode.BROWSER ) ; }
return getBinaryModuleNamespace ( legacyNamespace ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , MODULE_USES_GOOG_MODULE_GET ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null ) ; }
return MODULE_EXPORTS_PREFIX + this . legacyNamespace . replace ( CHAR_CONS , CHAR_CONS ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , GOOG_MODULE_USES_GOOG_MODULE_GET ) ; }
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , error ( INVALIDATION_ON_TYPE ) . withMessageContaining ( STRING_CONSTANT ) ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , error ( INVALIDATION_ON_TYPE ) . withMessageContaining ( STRING_CONSTANT ) ) ;
{ test ( srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , error ( INVALIDATION ) . withMessageContaining ( STRING_CONSTANT ) ) ; }
{ test ( srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , error ( INVALIDATION ) . withMessageContaining ( STRING_CONSTANT ) ) ; }
TypedVar fnVar = currentScope . getVar ( fnName ) ;
Node rootNode = currentHoistScope . getClosestContainerScope () . getRootNode () ;
GlobalScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
if ( currentScope . hasOwnSlot ( qName ) ) { continue; }
TypedVar ownerVar = currentScope . getVar ( slotName ) ;
TypedVar slot = currentScope . getVar ( name ) ;
{ return rValueInfo . getType () . evaluate ( currentScope , typeRegistry ) ; }
{ return createEnumTypeFromNodes ( rValue , lValue . getQualifiedName () , info , isLValueRootedInGlobalScope ( lValue ) ) ; }
return isLValueRootedInGlobalScope ( lValue ) || ! type . isReturnTypeInferred () ;
parent == null || ! parent . isFunction () || n == parent . getFirstChild () || parent == currentScope . getRootNode ()
if ( this . cache . functionScope != that.cache.functionScope ) { return false ; }
return slot != null ? slot : syntacticScope . getSlot ( var . getName () ) ;
{ return getSlot ( getVarFromSyntacticScope ( name ) ) ; }
ScopedName var = getVarFromSyntacticScope ( symbol ) ;
{ return new LinkedFlowScope ( new FlatFlowScopeCache ( scope ) , scope ) ; }
{ if ( type != null ) { this . type = type . resolve ( errorReporter , scope ) ; } }
public TemplateType getObjectIndexKey () { checkNotNull ( iObjectIndexTemplateKey ) ; return iObjectIndexTemplateKey ; }
public TemplateType getObjectElementKey () { return iObjectElementTemplateKey ; }
new InvalidatingTypes.Builder ( registry ) . writeInvalidationsInto ( this . invalidationMap ) . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () )
Node root = NodeUtil . getEnclosingScopeRoot ( n ) ;
AbstractScope ( Node rootNode ) { this . rootNode = checkNotNull ( rootNode ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null , false , ResolutionMode.BROWSER ) ; }
return getBinaryModuleNamespace ( legacyNamespace ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , MODULE_USES_GOOG_MODULE_GET ) ; }
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ if ( moduleType == ModuleType.GOOG_MODULE ) { moduleType = ModuleType.LEGACY_GOOG_MODULE ; } else { compiler . report ( JSError . make ( declaresLegacyNamespace , DECLARE_LEGACY_NAMESPACE_OUTSIDE_GOOG_MODULE ) ) ; } }
if ( Keywords . isKeyword ( name.value , false ) ) { features = features . with ( Feature.KEYWORDS_AS_PROPERTIES ) ; }
{ if ( moduleType == ModuleType.GOOG_MODULE ) { moduleType = ModuleType.LEGACY_GOOG_MODULE ; } else { compiler . report ( JSError . make ( declaresLegacyNamespace , DECLARE_LEGACY_NAMESPACE_IN_NON_MODULE ) ) ; } }
NodeUtil . isNameDeclaration ( n )
if ( NodeUtil . isNameDeclaration ( n ) ) { return n . getFirstChild () ; } else if ( NodeUtil . isExprAssign ( n ) ) { return n . getFirstFirstChild () ; }
if ( ! NodeUtil . isNameDeclaration ( child ) && ! NodeUtil . isExprAssign ( child ) ) { continue; }
parent != null && NodeUtil . isNameDeclaration ( parent )
Node node = withType ( IR . number ( id ) , numberType ) . useSourceInfoFrom ( sourceNode ) ;
sourceNode . replaceWith ( createBreakNodeFor ( sourceNode ) ) ;
IR . block ( callContextMethodResult ( sourceNode , STRING_CONSTANT , section . getNumber ( sourceNode ) ) , createBreakNodeFor ( sourceNode ) ) . useSourceInfoFrom ( sourceNode )
{ writeGeneratedNode ( n ) ; writeGeneratedNode ( createBreakNodeFor ( n ) ) ; currentCase.mayFallThrough = false ; }
var != null && var . getScope () == actual ()
{ checkState ( scope != actual () , STRING_CONSTANT ) ; expectScope ( STRING_CONSTANT , scope , scope ) ; }
private DeclarationSubject ( AbstractVar < , > var ) { this . var = checkNotNull ( var ) ; }
ImmutableList < AbstractVar < , > > declared = ImmutableList . copyOf ( actual () . getAllAccessibleVariables () ) ;
if ( NodeUtil . isNameDeclaration ( replace ) ) { replace . replaceWith ( NodeUtil . newExpr ( replacement ) ) ; } else { replace . replaceWith ( replacement ) ; }
NodeUtil . isNameDeclaration ( ref . getParent () )
NodeUtil . isNameDeclaration ( parent )
{ return ( NodeUtil . isNameDeclaration ( n ) || n . isFunction () ) && isWhitelistedName ( n . getFirstChild () . getString () ) ; }
if ( parent . isFunction () || NodeUtil . isNameDeclaration ( parent ) || parent . isNew () ) { return; }
checkArgument ( returnNode . isReturn () , returnNode ) ;
{ return ! isValidIndex ( index + offset ) ? CHAR_CONS : contents . charAt ( index + offset ) ; }
private char nextChar () { if ( isAtEnd () ) { return CHAR_CONS ; } return contents . charAt ( index ++ ) ; }
String value = this . contents . substring ( startOffset , index ) ;
NodeTraversal . traverse ( compiler , root , finder ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverse ( this , n , sia ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , new Callback () ) ; }
{ FindPrimitives pass = new FindPrimitives () ; NodeTraversal . traverse ( compiler , root , pass ) ; }
NodeTraversal . traverse ( compiler , root , new GatherCollapses () ) ;
{ mode = Mode.SINGLE_FILE ; reset () ; NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ reset () ; NodeTraversal . traverseRoots ( compiler , this , externs , root ) ; }
NodeTraversal . traverse ( compiler , originalRoot , cb ) ;
NodeTraversal . traverseRoots ( compiler , pass , externs , root ) ;
NodeTraversal . traverse ( compiler , function . getLastChild () , finder ) ;
{ NodeTraversal . traverse ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
NodeTraversal . traverse ( compiler , cfgNode , gatherCb ) ;
NodeTraversal . traverse ( compiler , n , gatherCb ) ;
NodeTraversal . traverse ( compiler , cfgNode , gatherCb ) ;
NodeTraversal . traverse ( compiler , t . getScopeRoot () , new GatherCandidates () ) ;
{ checkArgument ( isEs6ModuleRoot ( root ) , root ) ; clearState () ; NodeTraversal . traverse ( compiler , root , this ) ; }
if ( isEs6ModuleRoot ( scriptNode ) ) { processFile ( scriptNode ) ; } else { NodeTraversal . traverse ( compiler , scriptNode , new RewriteRequiresForEs6Modules () ) ; }
NodeTraversal . traverse ( compiler , root , namingCallback ) ;
{ symbolMap = getCssRenamingMap () ; NodeTraversal . traverse ( compiler , root , new Traversal () ) ; }
{ NodeTraversal . traverse ( compiler , js , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , scriptRoot , this ) ;
NodeTraversal . traverse ( compiler , root , findExportableNodes ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ checkArgument ( scriptNode . isScript () ) ; NodeTraversal . traverse ( compiler , scriptNode , this ) ; }
{ if ( ! rules . isEmpty () ) { NodeTraversal . traverseRoots ( compiler , this , externs , root ) ; } }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , enclosingFunction , checkAssigns ) ;
if ( renameMessages ) { RenameMessagesVisitor renameMessagesVisitor = new RenameMessagesVisitor () ; NodeTraversal . traverse ( compiler , root , renameMessagesVisitor ) ; }
NodeTraversal . traverse ( compiler , root , new LabelFinder () ) ;
NodeTraversal . traverseScopeRoots ( compiler , null , changedScopeRoots , cb , cb , false ) ;
NodeTraversal . traverse ( compiler , root , definitionsGatherer ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverseRoots ( compiler , this , externs , root ) ;
NodeTraversal . traverse ( compiler , js , new Normalize.NormalizeStatements ( compiler , false ) ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , new ReductionGatherer ( reducers , reductionMap ) ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , root , pass ) ;
{ NodeTraversal . traverseScopeRoots ( compiler , root , changedScopeNodes , new PeepCallback () , false ) ; if ( ! retraverseOnChange ) { break; } }
NodeTraversal . traverse ( compiler , NodeUtil . getLoopCodeBlock ( loopNode ) , continueStatementUpdater ) ;
NodeTraversal . traverse ( compiler , body , traversal ) ;
NodeTraversal . traverse ( compiler , root , getterSetterCollector ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , new SourceInformationAnnotator ( STRING_CONSTANT , false ) ) ; }
{ NodeTraversal . traverse ( compiler , checkNotNull ( root ) , this ) ; }
NodeTraversal . traverse ( compiler , NodeUtil . getFunctionBody ( constructor ) , finder ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , namingCallback ) ;
{ NodeTraversal . traverse ( compiler , externs , this ) ; compiler . setExternProperties ( ImmutableSet . copyOf ( externProperties ) ) ; }
NodeTraversal . traverse ( compiler , root , extractionInfo ) ;
{ NodeTraversal . traverse ( compiler , js , new DeadAssignmentsElimination ( compiler ) ) ; }
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
do { codeChanged = false ; NodeTraversal . traverse ( compiler , root , new EliminationPass ( cfg ) ) ; } while ( codeChanged ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , externs , findExternsCallback ) ;
NodeTraversal . traverseRoots ( compiler , this , externs , root ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , block , new UnmarkedNodeTranspiler () ) ;
{ YieldFinder yieldFinder = new YieldFinder () ; NodeTraversal . traverse ( compiler , n , yieldFinder ) ; return yieldFinder . getYieldNode () ; }
NodeTraversal . traverse ( compiler , wrapper , context . new UnmarkedNodeTranspiler () ) ;
NodeTraversal . traverse ( compiler , originalGeneratorBody , new YieldNodeMarker () ) ;
NodeTraversal . traverse ( compiler , body , this ) ;
{ if ( Es6RewriteModules . isEs6ModuleRoot ( script ) ) { NodeTraversal . traverse ( compiler , script , new Rewriter ( compiler , script ) ) ; } }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , this ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , superSet . getLastChild () , this ) ;
NodeTraversal . traverseScopeRoots ( compiler , root , changedScopes , new EmptyClinitPruner () , false ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , originalRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , tree , test ) ;
NodeTraversal . traverse ( compiler , tree , test ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , scriptRoot , this ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , externs , this ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverseScopeRoots ( compiler , null , changedScopeRoots , new UseSiteGatheringCallback () , false ) ;
{ super . process ( externs , source ) ; NodeTraversal . traverse ( compiler , source , new UseSiteGatheringCallback () ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , this ) ;
{ PolymerPassSuppressBehaviors suppressBehaviorsCallback = new PolymerPassSuppressBehaviors ( compiler ) ; NodeTraversal . traverse ( compiler , root , suppressBehaviorsCallback ) ; }
{ requiresLineNumbers = false ; NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , originalRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ CheckProvidesCallback callback = new CheckProvidesCallback ( codingConvention ) ; NodeTraversal . traverse ( compiler , scriptRoot , callback ) ; }
{ NodeTraversal . traverse ( compiler , callback , new RenameCallback ( aliasName , renamed ) ) ; aliasName = renamed ; break; }
NodeTraversal . traverse ( compiler , callbackBlock , new DefineCallbackReturnCallback () ) ;
{ NodeTraversal . traverse ( compiler , root , new TransformAMDModulesCallback () ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , script , this ) ;
NodeTraversal . traverse ( compiler , googRoot , this ) ;
NodeTraversal . traverse ( compiler , constructorBody , replaceThisWithSuperThis ) ;
NodeTraversal . traverse ( compiler , functionBody , checkForDefinedReturnValue ) ;
NodeTraversal . traverse ( compiler , parsed.ast , new Traverser ( info ) ) ;
{ checkState ( root . isScript () ) ; NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , new Callback () ) ;
NodeTraversal . traverse ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
NodeTraversal . traverse ( compiler , root , traversal ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , callbacks . get ( NUMBER_CONSTANT ) ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
{ requiresTypes = false ; NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , externs , this ) ; addWindowProperties () ; }
NodeTraversal . traverseRoots ( compiler , renamer , externs , root ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverse ( compiler , body , updater ) ;
NodeTraversal . traverse ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
NodeTraversal . traverse ( getLastCompiler () , getLastCompiler () . jsRoot , findFunction ) ;
NodeTraversal . traverse ( getLastCompiler () , getLastCompiler () . jsRoot , findParameter ) ;
NodeTraversal . traverse ( compiler , externs , externsCallback ) ;
NodeTraversal . traverse ( compiler , root , new Strip () ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , scriptRoot , traverser ) ;
NodeTraversal . traverse ( compiler , root , new ProcessProperties () ) ;
for ( Callback callback : callbacks ) { scriptRoot . putBooleanProp ( Node.TRANSPILED , true ) ; NodeTraversal . traverse ( compiler , scriptRoot , callback ) ; }
for ( Callback callback : callbacks ) { singleRoot . putBooleanProp ( Node.TRANSPILED , true ) ; NodeTraversal . traverse ( compiler , singleRoot , callback ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , root , collector ) ;
NodeTraversal . traverse ( compiler , scriptRoot , finder ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , new ProcessProperties () ) ;
{ new InferConsts ( compiler ) . process ( externs , root ) ; NodeTraversal . traverse ( compiler , root , constFinder ) ; }
NodeTraversal . traverse ( compiler , tree , cb ) ;
{ NodeTraversal . traverse ( compiler , root , new ExportTestFunctionsNodes () ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , externs , findExternsCallback ) ; }
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverse ( compiler , script , test ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverse ( compiler , root , new ProcessVars () ) ;
{ checkNotNull ( root ) ; checkState ( root . isScript () ) ; NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
return new IdentifierToken ( getTokenRange ( beginToken ) , value ) ;
NodeTraversal . traverse ( compiler , rootNode , callback ) ;
NodeTraversal . traverse ( compiler , script , cb ) ;
NodeTraversal . traverse ( metadata . getCompiler () , script , callback ) ;
{ checkArgument ( parent . isFunction () || NodeUtil . isNameDeclaration ( parent ) || parent . isParamList () || parent . isCatch () ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new IdentifyGlobalEnumsAndTypedefsAsNonNullable ( typeRegistry ) ) ;
assertType ( x . getType () ) . toStringIsEqualTo ( STRING_CONSTANT ) ;
assertType ( bar . getType () ) . toStringIsEqualTo ( STRING_CONSTANT ) ;
assertType ( f . getPropertyType ( STRING_CONSTANT ) ) . toStringIsEqualTo ( STRING_CONSTANT ) ;
if ( NodeUtil . isNameDeclaration ( item ) ) { item = item . getFirstChild () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
NodeTraversal . traverse ( compiler , root , new IdentifyGlobalEnumsAndTypedefsAsNonNullable ( typeRegistry ) ) ;
ReferenceCollectingCallback refCollector = new ReferenceCollectingCallback ( this , ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR , new Es6SyntacticScopeCreator ( this ) ) ;
private TypeCheckResult parseAndTypeCheckWithScope ( String js ) { return parseAndTypeCheckWithScope ( STRING_CONSTANT , js ) ; }
private Node parseAndTypeCheck ( String js ) { return parseAndTypeCheck ( STRING_CONSTANT , js ) ; }
{ testTypesWithExterns ( DEFAULT_EXTERNS + STRING_CONSTANT + externs , js , diag , false ) ; }
{ testTypesWithExterns ( externs , js , ( String ) null , false ) ; }
{ testTypesWithExterns ( STRING_CONSTANT , js , description , isError ) ; }
public void testCovariantIThenable3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testSymbol2 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testSymbol1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch6 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch5 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch4 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch2 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeCovariant2 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeCovariant1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
Node js1Node = parseAndTypeCheck ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
Node js1Node = parseAndTypeCheck ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT ) ;
{ TypeCheckResult p = parseAndTypeCheckWithScope ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testAddingMethodsUsingPrototypeIdiomComplexNamespace ( p ) ; }
{ TypeCheckResult p = parseAndTypeCheckWithScope ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testAddingMethodsUsingPrototypeIdiomComplexNamespace ( p ) ; }
Node js1Node = parseAndTypeCheck ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT ) ;
public void testFunctionBind5 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind4 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind3 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind2 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind1 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall8 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall7 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall6 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall5 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall3 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall2 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall1 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testAbstractMethodCall13 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall12 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall10 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall8 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall7 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall5 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testIssue1201b () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testThis14 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess9 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess8 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess7 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess6 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess4 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess3 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess2 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess1 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testGetelemStruct_noErrorForGettingWellKnownSymbol () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testGetelemStruct_noErrorForSettingWellKnownSymbol () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testForOf8 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf6 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf5 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf4 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
assertTypeEquals ( type , getNativeObjectType () ) ;
{ Node n = parseAndTypeCheck ( STRING_CONSTANT ) ; assertTypeEquals ( getNativeErrorType () , n . getFirstFirstChild () . getJSType () ) ; }
assertTypeEquals ( getNativeNumberType () , type ) ;
assertTypeEquals ( getNativeNumberType () , type ) ;
assertTypeEquals ( STRING_CONSTANT , getNativeNumberType () , googFooGetprop2ObjectType . getPropertyType ( STRING_CONSTANT ) ) ;
public void testName5 () { assertTypeEquals ( getNativeRegexpConstructorType () , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName4 () { assertTypeEquals ( getNativeDateConstructorType () , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName3 () { assertTypeEquals ( getNativeArrayConstructorType () , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName2 () { assertTypeEquals ( getNativeObjectConstructorType () , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName1 () { assertTypeEquals ( getNativeVoidType () , testNameNode ( STRING_CONSTANT ) ) ; }
assertTypeEquals ( getNativeArrayType () , a . getType () ) ;
assertTypeEquals ( getNativeVoidType () , n . getJSType () ) ;
{ Node falseNode = typeCheck ( new Node ( Token.FALSE ) ) ; assertTypeEquals ( getNativeBooleanType () , falseNode . getJSType () ) ; }
{ Node trueNode = typeCheck ( new Node ( Token.TRUE ) ) ; assertTypeEquals ( getNativeBooleanType () , trueNode . getJSType () ) ; }
{ Node n = typeCheck ( Node . newString ( STRING_CONSTANT ) ) ; assertTypeEquals ( getNativeStringType () , n . getJSType () ) ; }
{ Node n = typeCheck ( Node . newNumber ( NUMBER_CONSTANT ) ) ; assertTypeEquals ( getNativeNumberType () , n . getJSType () ) ; }
{ TypeCheckResult p = parseAndTypeCheckWithScope ( STRING_CONSTANT ) ; assertTypeEquals ( getNativeNumberType () , p.scope . getVar ( STRING_CONSTANT ) . getType () ) ; }
{ Node number = createUntypedNumber ( n ) ; number . setJSType ( getNativeNumberType () ) ; return number ; }
{ Node n = new Node ( Token.NULL ) ; n . setJSType ( getNativeNullType () ) ; return n ; }
public void testTransformationWithUnionInMaprecord () { testTTL ( getNativeUnknownType () , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithInvalidMaprecord () { testTTL ( getNativeUnknownType () , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithInvalidNestedMapunion () { testTTL ( getNativeUnknownType () , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testTransformationWithNestedMapunionInMapFunctionBody () { testTTL ( getNativeStringType () , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithNestedExpressionInBooleanSecondParam () { testTTL ( getNativeStringType () , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithNestedExpressionInBooleanFirstParam () { testTTL ( getNativeStringType () , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
child . inferSlotType ( STRING_CONSTANT , getNativeNumberType () ) ;
JSDocInfo jsDoc = NodeUtil . isNameDeclaration ( node . getParent () ) ? node . getParent () . getJSDocInfo () : node . getJSDocInfo () ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks , options ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes , options ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes , compiler . getOptions () ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories , compiler . getOptions () ) ;
shouldAddTypes ? contextType . getPropertyType ( fieldName ) : null
String embedded = transpiled + STRING_CONSTANT + ESCAPER . escape ( sourceMap ) + STRING_CONSTANT ;
var . getParentNode () != null && var . getType () == null && NodeUtil . isNameDeclaration ( var . getParentNode () )
assertTypeEquals ( typeRegistry . getNativeType ( GENERATOR_TYPE ) , typeRegistry . getGlobalType ( STRING_CONSTANT ) ) ;
assertTypeEquals ( typeRegistry . getNativeType ( ITERATOR_TYPE ) , typeRegistry . getGlobalType ( STRING_CONSTANT ) ) ;
assertTypeEquals ( typeRegistry . getNativeType ( ITERABLE_TYPE ) , typeRegistry . getGlobalType ( STRING_CONSTANT ) ) ;
JSType type = registry . getType ( resolutionScope , reference ) ;
ObjectType regType = ObjectType . cast ( registry . getType ( scope . getDeclarationScope () , qualifiedName ) ) ;
{ warnImplicitlyNullable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; warnImplicitlyNullable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
options . setPreserveClosurePrimitives ( true ) ;
JSType windowType = getTypeInternal ( null , STRING_CONSTANT ) ;
private void registerGlobalType ( JSType type ) { register ( null , type , type . toString () ) ; }
{ typesIndexedByProperty . clear () ; eachRefTypeIndexedByProperty . clear () ; initializeBuiltInTypes () ; scopedNameTable . clear () ; initializeRegistry () ; }
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories ) ;
NodeUtil . isLoopStructure ( scopeRoot )
actualYieldType = actualYieldType . autobox () . getTemplateTypeMap () . getResolvedTemplateType ( typeRegistry . getIterableTemplate () ) ;
var . getParentNode () != null && var . getType () == null && var . getParentNode () . isVar ()
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.OTI_ONLY ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = STRING_CONSTANT ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
warning ( TYPE_MISMATCH_WARNING )
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefinePropertiesQuotesPreventRemoval () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty1 () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.DISABLED ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; late = false ; useTypes = true ; numRepetitions = NUMBER_CONSTANT ; mode = TypeInferenceMode.DISABLED ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
this . mode = TypeInferenceMode.CHECKED ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; }
public void testClassWithEmptyMembers () { this . mode = TypeInferenceMode.DISABLED ; testError ( STRING_CONSTANT , StrictModeCheck.DUPLICATE_CLASS_METHODS ) ; }
public void testStaticAndNonstaticSetterWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticGetterWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticMethodWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testComputedPropInClass () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
public void testArguments6 () { this . mode = TypeInferenceMode.DISABLED ; testSame ( STRING_CONSTANT ) ; }
public void testUnknownVariable4 () { this . mode = TypeInferenceMode.DISABLED ; testSameEs6Strict ( STRING_CONSTANT ) ; testSameEs6Strict ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
{ super . setUp () ; late = true ; useTypes = true ; this . mode = TypeInferenceMode.DISABLED ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.CHECKED ; }
{ this . mode = TypeInferenceMode.DISABLED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.DISABLED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
public void disable_testClassMethodUnused2 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassPropUnused1 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; }
new CodePrinter.Builder ( parse ( js , TypeInferenceMode.CHECKED ) )
Node parse ( String js ) { return parse ( js , TypeInferenceMode.DISABLED ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
testSame ( externs ( lines ( MINIMAL_EXTERNS , STRING_CONSTANT , STRING_CONSTANT ) ) , srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , warning ( TypeValidator.TYPE_MISMATCH_WARNING ) )
test ( srcs ( STRING_CONSTANT ) , warning ( TOO_MANY_TEMPLATE_PARAMS ) ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( srcs ( STRING_CONSTANT ) , warning ( TOO_MANY_TEMPLATE_PARAMS ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_boxedNumberVsZero () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_while () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; late = true ; this . mode = TypeInferenceMode.DISABLED ; ignoreWarnings ( DiagnosticGroups.NEW_CHECK_TYPES_EXTRA_CHECKS ) ; }
for ( DeferredSetType deferred : deferredSetTypes ) { deferred . resolve () ; }
a . resolve ( null ) ;
{ if ( type != null ) { this . type = type . resolve ( errorReporter ) ; } }
activeXObject . resolve ( null ) ;
namedA . resolve ( null ) ;
for ( NamedType type : unresolvedNamedTypes . get ( scope ) ) { type . resolve ( reporter ) ; }
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks , options ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes , options ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes , compiler . getOptions () ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories , compiler . getOptions () ) ;
disableTypeCheck () ;
disableTypeCheck () ;
{ disableTypeCheck () ; String source = STRING_CONSTANT ; assertNoPureCalls ( source ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
{ disableTypeCheck () ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
disableTypeCheck () ;
{ disableTypeCheck () ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
{ disableTypeCheck () ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
public void testAbstractClass () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT , warning ( INSTANTIATE_ABSTRACT_CLASS ) ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ super . setUp () ; disableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; enableTranspile () ; }
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefinePropertiesQuotesPreventRemoval () { enableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { enableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
enableTypeCheck () ;
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties1 () { enableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testES6StaticProperty2 () { disableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
public void testES6StaticProperty () { disableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testConstructorProperty2 () { enableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty1 () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; disableTypeCheck () ; }
disableTypeCheck () ;
disableTypeCheck () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; enableTypeCheck () ; }
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
enableTypeCheck () ;
public void testClassWithEmptyMembers () { disableTypeCheck () ; testError ( STRING_CONSTANT , StrictModeCheck.DUPLICATE_CLASS_METHODS ) ; }
public void testStaticAndNonstaticSetterWithSameName () { disableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticGetterWithSameName () { disableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticMethodWithSameName () { disableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testComputedPropInClass () { disableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
public void testArguments6 () { disableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
public void testUnknownVariable4 () { disableTypeCheck () ; testSameEs6Strict ( STRING_CONSTANT ) ; testSameEs6Strict ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ super . setUp () ; disableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
{ super . setUp () ; late = true ; useTypes = true ; disableTypeCheck () ; }
{ disableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ disableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; disableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
public void disable_testClassMethodUnused2 () { disableTypeCheck () ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { disableTypeCheck () ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassPropUnused1 () { disableTypeCheck () ; unused ( STRING_CONSTANT ) ; }
new CodePrinter.Builder ( parse ( js , true ) )
Node parse ( String js ) { return parse ( js , false ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTranspile () ; enableTypeCheck () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_boxedNumberVsZero () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_while () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
enableTypeCheck () ;
public void testCoercionSubstitution_expression () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
public void testCoercionSubstitution_booleanResult0 () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
return getTypeRegistry () ;
this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ;
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ; }
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ; }
this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ;
public boolean isTypecheckingEnabled () { return this . checkTypes ; }
DiagnosticGroup ignored = new DiagnosticGroup ( TypeCheck.INEXISTENT_PROPERTY , TypeValidator.TYPE_MISMATCH_WARNING ) ;
ignoreWarnings ( TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED ) ;
public void testTypeMismatch () { ignoreWarnings ( TypeValidator.TYPE_MISMATCH_WARNING ) ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
validator . expectCanAssignTo ( t , loopVarNode , actualType , declaredType , STRING_CONSTANT ) ;
checkArgument ( setKey == null || setKey . isSetterDef () , setKey ) ;
hoistNode ( varStatement ) ;
hoistNode ( n ) ;
if ( prop != null ) { if ( NodeUtil . isSomeCompileTimeConstStringValue ( prop ) ) { continue; } return violation ; }
NodeUtil . isLhsOfAssign ( propAccess ) && ( NodeUtil . isLiteralValue ( propAccess . getNext () , false ) || NodeUtil . isSomeCompileTimeConstStringValue ( propAccess . getNext () ) )
if ( NodeUtil . isSomeCompileTimeConstStringValue ( ast ) ) { paramNodeMatches . set ( paramIndex , ast ) ; return true ; }
{ return NodeUtil . isSomeCompileTimeConstStringValue ( ast ) ; }
{ if ( ! isSafeValue ( traversal . getScope () , argument ) ) { compiler . report ( traversal . makeError ( argument , CONST_NOT_STRING_LITERAL_ERROR ) ) ; } }
String lastPart = typeString . substring ( typeString . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
int index = name . indexOf ( CHAR_CONS ) ;
checkArgument ( setKey . isSetterDef () , setKey ) ;
List < ? extends LocationMapping > sourceMapLocationMappings
{ locationMappings . add ( new SourceMap.PrefixLocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
URI path
URI path
URI path
URI path
URI path
URI path
URI path
public void setSourceMapLocationMappings ( List < ? extends SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
{ switch ( n . getToken () ) { case FOR_OF : visitForOf ( n , parent ) ; break; default: break; } }
this . registry = compiler . getTypeRegistry () ;
JSType type
public JSType getReturnType () { return call.returnType ; }
builder . setTypeRegistry ( getTypeRegistry () ) ;
newName . setJSType ( child . getJSType () ) ;
n . setJSType ( type ) ;
JSType type = srcObj . getJSType () ;
JSType attrsType = attrs . getJSType () ;
JSType type = srcObj . getJSType () ;
ObjectType targetType = target . getJSType () . toMaybeObjectType () ;
String typeName = n . getFirstChild () . getJSType () . toString () ;
JSType type = n . getJSType () ;
JSType type = n . getJSType () ;
{ return n . getJSType () != null && isKnown ( n ) && invalidDeref ( n ) && ! isWhitelistedType ( n ) ; }
JSType thrown = n . getFirstChild () . getJSType () ;
{ super ( compiler , requirement ) ; errorObjType = compiler . getTypeRegistry () . getGlobalType ( STRING_CONSTANT ) ; }
TemplateAstMatcher astMatcher = new TemplateAstMatcher ( compiler . getTypeRegistry () , templateRoot , typeMatchingStrategy ) ;
FunctionType restrictedCallType
FunctionType restrictedCallType
FunctionType functionType
JSType type = n . getJSType () ;
{ return isAssertionCall ( n . getParent () ) || n . getJSTypeBeforeCast () != null ; }
{ JSType type = n . getJSType () ; return ( type == null || type . isSomeUnknownType () ) ; }
{ JSType type = n . getJSType () ; return ( type == null || type . isUnknownType () ) ; }
{ JSType type = n . getJSType () ; return type != null && type . isTop () ; }
nativeObjectType = compiler . getTypeRegistry () . getNativeType ( JSTypeNative.OBJECT_TYPE ) ;
public TypeSubject ( FailureMetadata failureMetadata , JSType type ) { super ( failureMetadata , type ) ; }
JSType type
{ JSType type = n . getJSType () ; return ( type != null && type . isFunctionType () ) ; }
replacement . setJSType ( getNativeStringType () ) ;
ObjectType prototypeOrInstance ( ) ;
void declarePrototypeProperty ( String name , JSType type , Node defSite ) ;
void declareInstanceProperty ( String name , JSType type , Node defSite ) ;
void declareConstructorProperty ( String name , JSType type , Node defSite ) ;
private String formatTypeVar ( JSType var ) { return var . toAnnotationString ( Nullability.IMPLICIT ) ; }
JSTypeRegistry registry
public FunctionType getOwnerFunction () { return null ; }
public boolean isPrototypeObject () { return isFunctionPrototypeType () ; }
Builder ( JSTypeRegistry registry ) { this . registry = registry ; }
FunctionType getterType
replacement . setJSType ( call . getJSType () ) ;
for ( Node n : nodeList ) { n.jstype = ( JSType ) in . readObject () ; }
for ( Node n : nodeList ) { out . writeObject ( n.jstype ) ; }
dst . setJSType ( this . jstype ) ;
@ Nullable public final JSType getJSTypeBeforeCast () { return ( JSType ) getProp ( TYPE_BEFORE_CAST ) ; }
JSType type = expr . getJSType () ;
JSType type = n . getJSType () ;
Node stringKey = withType ( IR . stringKey ( name , n . getFirstChild () . detach () ) , n . getJSType () ) ;
this . registry = compiler . getTypeRegistry () ;
@ Nullable JSType typeI
n . getJSType () == null
JSType type
JSType type = getType ( typeObj ) ;
JSType type = getType ( obj ) ;
JSType objlitType = getType ( n ) ;
JSType type = getType ( n . getFirstChild () ) ;
return n . isGetProp () && n . getLastChild () . getString () . equals ( STRING_CONSTANT ) && n . getFirstChild () . getJSType () . isStructuralInterface () ;
JSType recvType = getType ( recv ) ;
JSType type
JSType type
mathDotPowCall = withType ( IR . call ( mathPow . get () . cloneTree () , left , right ) , n . getJSType () ) . useSourceInfoIfMissingFromForTree ( n )
JSType type = fnNode . getJSType () ;
JSType type = n . getJSType () ;
JSType type = n . getJSType () ;
JSType jsType
JSType jsType
Node assign = withType ( IR . assign ( copiedVarName , varName . removeFirstChild () ) , varName . getJSType () ) . useSourceInfoFrom ( varName ) ;
Node newThis = withType ( context . getScopedName ( GENERATOR_THIS ) , n . getJSType () ) ;
IR . returnNode ( withType ( IR . call ( createGenerator , withType ( genFuncName . cloneNode () , generatorFunction . getJSType () ) , program ) , originalGenReturnType ) )
JSTypeRegistry registry
JSTypeRegistry registry
FunctionType getterType
JSType type
new InvalidatingTypes.Builder ( compiler . getTypeRegistry () ) . disallowGlobalThis () . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () ) . build ()
JSType type
ImmutableMap < String , JSType > typeVars
JSTypeRegistry registry
this . registry = compiler . getTypeRegistry () ;
JSTypeRegistry typeRegistry
ObjectType objectType
ObjectType objectType
JSType type = n . getJSType () ;
this . typeRegistry = compiler . getTypeRegistry () ;
public Builder setTypeRegistry ( JSTypeRegistry registry ) { this . registry = registry ; return this ; }
CodePrinter.Builder builder = new CodePrinter.Builder ( externsRoot ) . setPrettyPrint ( true ) . setOutputTypes ( true ) . setTypeRegistry ( compiler . getTypeRegistry () ) ;
lit . setJSType ( exportedObjectLit . getJSType () ) ;
JSType type = n . getJSType () ;
StaticTypedScope < ? extends JSType > scope
@ Override public JSType getType () { return null ; }
lastCompiler . getTypeRegistry ()
lastCompiler . getTypeRegistry ()
JSType typeI = getPropLhs . getJSType () ;
JSTypeRegistry typeRegistry
actual = new CodePrinter.Builder ( script ) . setCompilerOptions ( options ) . setTypeRegistry ( compiler . getTypeRegistry () ) . build () . trim ()
if ( n . getJSType () == null ) { throw new IllegalStateException ( STRING_CONSTANT + n + STRING_CONSTANT + STRING_CONSTANT ) ; }
TemplateAstMatcher matcher = new TemplateAstMatcher ( lastCompiler . getTypeRegistry () , templateRoot . getFirstChild () , typeMatchingStrategy ) ;
ObjectType objectType
@ Nullable ObjectType referenceType
JSType type = name . getJSType () ;
JSType type
JSType type
JSType type
JSType type
new InvalidatingTypes.Builder ( compiler . getTypeRegistry () ) . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () ) . addAllTypeMismatches ( compiler . getImplicitInterfaceUses () ) . build ()
JSType receiverType = determineReceiverType ( n ) ;
JSTypeRegistry typeRegistry
JSType type = firstArg . getJSType () ;
FunctionType getterType
JSTypeRegistry registry
public void applySingletonGetter ( NominalTypeBuilder classType , FunctionType getterType ) ;
List < LocationMapping > sourceMapLocationMappings
{ locationMappings . add ( new SourceMap.LocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
Path path
Path path
Path path
Path path
Path path
Path path
Path path
public void setSourceMapLocationMappings ( List < SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
if ( c . getString () . equals ( WINDOW_NAME ) ) { windowInExterns = true ; continue; }
typeCheckingHasRun = compilerState.typeCheckingHasRun ;
this . typeCheckingHasRun = compiler.typeCheckingHasRun ;
this . compiler . setTypeCheckingHasRun ( true ) ;
compiler . setTypeCheckingHasRun ( true ) ;
this . addTypes = compiler . hasTypeCheckingRun () ;
compiler . setTypeCheckingHasRun ( true ) ;
abstract boolean hasTypeCheckingRun ( ) ;
{ this . compiler = compiler ; this . addTypes = compiler . hasTypeCheckingRun () ; }
{ this . compiler = compiler ; this . addTypes = compiler . hasTypeCheckingRun () ; }
this . addTypes = compiler . hasTypeCheckingRun () ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
if ( c . getString () . equals ( STRING_CONSTANT ) ) { windowInExterns = true ; continue; }
{ super . setUp () ; compiler . getOptions () . setWarningLevel ( DiagnosticGroups.MISSING_OVERRIDE , CheckLevel.WARNING ) ; compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_CHECK_TYPES , CheckLevel.WARNING ) ; }
if ( prevUsedRenameMap != null ) { reusePreviouslyUsedVariableMap ( varsByFrequency ) ; }
if ( ! validator . expectAutoboxesToIterable ( t , n , actualYieldType , STRING_CONSTANT ) ) { return; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
if ( c . getString () . equals ( WINDOW_NAME ) ) { windowInExterns = true ; continue; }
public ResolutionMode getModuleResolutionMode () { return this . moduleResolutionMode ; }
JSType objectType
JSType objectType
if ( iterableType != null ) { typeParam = iterableType . getInstantiatedTypeArgument ( registry . getNativeType ( JSTypeNative.ITERABLE_TYPE ) ) ; }
JSType newType = objType . getInstantiatedTypeArgument ( getNativeType ( ITERABLE_TYPE ) ) ;
defineSlot ( astParameter , paramType , inferred ) ;
{ defineSlot ( fnNameNode , fnNode . getJSType () , false ) ; }
if ( candidate . isGetProp () ) { defineSlot ( candidate , getNativeType ( NO_TYPE ) , false ) ; }
defineSlot ( n , valueType , inferred ) ;
if ( NodeUtil . isFunctionDeclaration ( n ) ) { defineSlot ( n . getFirstChild () , functionType ) ; }
{ boolean inferred = keyType == null ; defineSlot ( keyNode , qualifiedName , keyType , inferred ) ; }
! type . matchesNumberContext () && ! type . matchesStringContext () && ! type . matchesSymbolContext ()
{ return isSubtype ( that , ImplCache . createWithoutStructuralTyping () , SubtypingMode.NORMAL ) ; }
FunctionType makeIteratorType = registry . createFunctionType ( iteratorType , paramBuilder . build () ) ;
List < ? extends LocationMapping > sourceMapLocationMappings
{ locationMappings . add ( new SourceMap.PrefixLocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
URI path
URI path
URI path
URI path
URI path
URI path
URI path
public void setSourceMapLocationMappings ( List < ? extends SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , es6ModuleTranspiler , newMode , sourceUrl , path , sourceMapCache ) ; }
visitImport ( t . getInput () . getPath () , n ) ;
return tightenTypeAfterDereference ( n . getFirstChild () , scope ) ;
return dereferencePointer ( n . getFirstChild () , scope ) ;
{ testTypes ( externs , js , description , false ) ; }
{ testTypes ( STRING_CONSTANT , js , diagnosticType , isError ) ; }
{ testTypes ( STRING_CONSTANT , js , description , isError ) ; }
public void testGenerator_yieldAll_string () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_yieldAll1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_return2 () { testTypesWithCommonExterns ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_noDeclaredReturnType3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_returnsIterator2 () { testTypesWithCommonExterns ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_returnsIterable2 () { testTypesWithCommonExterns ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator3 () { testTypesWithCommonExterns ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_StringObject2 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_StringObject1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_string1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_array3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType6a () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType5 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType4a () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrayLitSpread () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
StaticTypedScope getDeclarationScope ( ) ;
FlowScope createChildFlowScope ( StaticTypedScope scope ) ;
{ if ( sym instanceof StaticTypedSlot ) { return ( ( StaticTypedSlot ) sym ) . isTypeInferred () ; } return true ; }
{ if ( s instanceof StaticTypedScope ) { return ( ( StaticTypedScope ) s ) . getTypeOfThis () ; } return null ; }
{ if ( sym instanceof StaticTypedSlot ) { return ( ( StaticTypedSlot ) sym ) . getType () ; } return null ; }
StaticTypedSlot slot
StaticTypedScope scope
StaticTypedScope typeEnv
@ Override StaticTypedScope getScope ( ) ;
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
@ Override public JSType getTypeOfThis () { return null ; }
JSType getTypeOfThis ( ) ;
StaticTypedScope scope
if ( n . isAssignAdd () ) { updateScopeForAssignment ( scope , left , leftType , type ) ; }
visitArgumentList ( t , n , functionType ) ;
visitArgumentList ( t , n , fnType ) ;
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
while ( current.parent != null && current.scopes == current.parent.scopes ) { current = current.parent ; }
NodeUtil . isInvocation ( n ) || n . isYield ()
return tightenTypeAfterDereference ( n . getFirstChild () , scope ) ;
updateTypeOfArguments ( n , fnType ) ;
updateTypeOfParameters ( n , fnType ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6InjectRuntimeLibraries ( compiler ) ; }
updateTypeOfArguments ( n , fnType ) ;
if ( ! options.checksOnly ) {}
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( decl . isAliasDefinition () ) { return; }
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
if ( n . isAssignAdd () ) { scope = updateScopeForAssignment ( scope , left , leftType , type ) ; }
child = child . inferSlotType ( STRING_CONSTANT , getNativeNumberType () ) ;
flowScope = flowScope . inferSlotType ( STRING_CONSTANT , type ) ;
if ( this == that ) { return true ; }
FlowScope output = input . withSyntacticScope ( scopeCreator . createScope ( root ) ) ;
FlowScope informed = blindScope ;
assign . useSourceInfoIfMissingFromForTree ( method ) ;
{ scope = traverseChildren ( name , scope ) ; }
List < String > moduleNameRegexList = options.chunksToPrintAfterEachPassRegexList ;
{ return new CrossModuleMethodMotion ( compiler , compiler . getCrossModuleIdGenerator () , options.removeUnusedPrototypePropertiesInExterns , options.crossChunkCodeMotionNoStubMethods ) ; }
{ return new CrossModuleCodeMotion ( compiler , compiler . getModuleGraph () , options.parentChunkCanSeeSymbolsDeclaredInChildren ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RescopeGlobalSymbols ( compiler , options.renamePrefixNamespace , options.renamePrefixNamespaceAssumeCrossChunkNames ) ; }
parentChunkCanSeeSymbolsDeclaredInChildren = false ;
assertFalse ( REGEXP_TYPE . canBeCalled () ) ;
public final boolean isAbstract () { return isAbstract ; }
return shouldTreatThisTypesAsCovariant ( other , implicitImplCache ) && this . call . isSubtype ( other.call , implicitImplCache , subtypingMode ) ;
public final ObjectType getPrototypeProperty () { return getPrototype () ; }
public final boolean isReturnTypeInferred () { return call.returnTypeInferred ; }
public final JSType getReturnType () { return call.returnType ; }
@ Override public final boolean canBeCalled () { return true ; }
public final void setDict () { propAccess = PropAccess.DICT ; }
public final void setStruct () { propAccess = PropAccess.STRUCT ; }
if ( ft != null ) { functionNode . setJSType ( convertMethodToFunction ( ft ) ) ; }
type == null || type . isUnknownType () || type . isUnresolved () || type . isAllType ()
return ! type . isAllType () && ( type . isNullable () || type . isVoidable () ) ;
targetType . isUnknownType () || targetType . isUnresolved () || targetType . isAllType () || targetType . isEquivalentTo ( registry . getNativeType ( JSTypeNative.OBJECT_TYPE ) )
{ JSType type = n . getJSType () . restrictByNotNullOrUndefined () ; return type . isEmptyType () ; }
{ JSType type = n . getJSType () ; return type != null && type . isAllType () ; }
obj != null && obj . isFunctionPrototypeType ()
return restricted . isEmptyType () ? type : restricted ;
retType != null && ! retType . isEmptyType () && ! funType . isInterface ()
type . isEnumElementType ()
if ( objType . isFunctionPrototypeType () ) { constructor = objType . getOwnerFunction () ; } else { constructor = objType . getConstructor () ; }
type . isEnumElementType ()
{ return type . isEnumType () || type . isBoxableScalar () ; }
if ( type . isEnumElementType () ) { return getTypesToSkipForType ( type . getEnumeratedTypeOfEnumElement () ) ; }
if ( ! t . isObjectType () || t . isAllType () ) { return; }
type . isAllType () || type . isUnknownType ()
type . isAllType () || type . isUnknownType ()
final ObjectType getReferencedObjTypeInternal () { return referencedObjType ; }
final JSType getReferencedTypeInternal () { return referencedType ; }
return subtype . isEmptyType () ;
if ( body . isEmptyType () || body . isEquivalentTo ( getObjectType () ) ) { continue; }
return result . isEmptyType () ? getUnknownType () : result ;
if ( type . isEnumElementType () ) { return type . getEnumeratedTypeOfEnumElement () ; }
! callClassType . isEmptyType () && ! callClassType . isSomeUnknownType ()
if ( type == null || type . isUnknownType () || type . isAllType () ) { return allowLooseMatches ? MatchResult.LOOSE_MATCH : MatchResult.NO_MATCH ; }
{ return type == null ? null : type . dereference () ; }
@ Override public final boolean matchesStringContext () { return true ; }
@ Override public final boolean matchesSymbolContext () { return true ; }
@ Override public final boolean matchesObjectContext () { return true ; }
@ Override public final boolean matchesNumberContext () { return true ; }
@ Override public final boolean isConstructor () { return false ; }
@ Override public final boolean isVoidable () { return true ; }
@ Override public final boolean isNullable () { return true ; }
@ Override public final boolean isNoObjectType () { return false ; }
type . isFunctionPrototypeType ()
if ( ! receiverType . meetWith ( type ) . isEmptyType () ) { return true ; }
return type != null && containsArray ( type ) ;
propdef . setJSType ( stringType ) ;
visitImport ( n ) ;
@ Override public boolean isApplied ( CompilerOptions options ) { return options . shouldRunCrossChunkMethodMotion () ; }
@ Override public boolean isApplied ( CompilerOptions options ) { return options . shouldRunCrossChunkCodeMotion () ; }
ensureTyped ( n ) ;
{ ensureTyped ( name , valueType ) ; }
ensureTyped ( n ) ;
ensureTyped ( n ) ;
ensureTyped ( n , type ) ;
ensureTyped ( iterableNode ) ;
if ( ! options.checksOnly ) {}
if ( topScope == null ) { regenerateGlobalTypedScope ( compiler , root . getParent () ) ; } else { compiler . getTypeRegistry () . resolveTypes () ; }
if ( recordUnresolvedTypes ) { unresolvedNamedTypes . add ( namedType ) ; }
{ whitespaceOnlyPasses () ; if ( options . needsTranspilationFrom ( options . getLanguageIn () . toFeatureSet () ) ) { transpileAndDontCheck () ; } }
FeatureSet features = NodeUtil . getFeatureSetOfScript ( script ) ;
n . isBlock () && ! loneBlocks . isEmpty () && loneBlocks . peek () == n
( parent . isScript () || ( parent . isBlock () && ! parent . isSyntheticBlock () && ! parent . isAddedBlock () ) )
if ( ! subtree . isScript () && ! subtree . isBlock () ) { return subtree ; }
body . isBlock () && ! body . hasChildren ()
{ return ( n . isBlock () && n . isSyntheticBlock () ) || n . isScript () ; }
checkState ( block . isBlock () ) ;
if ( ! block . isBlock () ) { return null ; }
stmt . isEmpty () || ( stmt . isBlock () && ! stmt . hasChildren () )
n . isBlock ()
! n . isBlock ()
statement . isBlock ()
! target . getParent () . isScript () && ! target . getParent () . isBlock () && ! target . getParent () . isModuleBody ()
n . isBlock ()
n . isBlock ()
n . isBlock ()
n . isBlock ()
parent != null && ( parent . isBlock () || parent . isScript () )
! body . isBlock ()
n . isFunction () && ! NodeUtil . getFunctionBody ( n ) . isBlock ()
{ checkArgument ( blockNode . isBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
if ( n . isBlock () ) { visitBlock ( n ) ; }
node . isFunction () && ! NodeUtil . getFunctionBody ( node ) . isBlock ()
if ( ! n . isScript () && ! n . isBlock () ) { return; }
if ( body . isBlock () ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
if ( ! n . isBlock () || ! n . hasChildren () || ! isGoogModuleCall ( n . getFirstChild () ) ) { return false ; }
{ checkArgument ( n . isBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
n . isBlock ()
checkState ( addingRoot . isBlock () || addingRoot . isModuleBody () || addingRoot . isScript () ) ;
{ return n . isBlock () && n . getParent () != null && n . getParent () . isFunction () ; }
checkState ( block . isBlock () ) ;
node . isBlock ()
{ return n . isRoot () || n . isScript () || n . isBlock () || n . isModuleBody () ; }
if ( ! block . isBlock () ) { return false ; }
if ( n . isEmpty () || ( n . isBlock () && ! n . hasChildren () ) ) { return; }
next != null && next . isBlock ()
! body . isBlock () || body . hasChildren ()
if ( ! n . isFunction () || ! n . getLastChild () . isBlock () ) { return; }
checkState ( jumpBlock . isBlock () ) ;
checkState ( block . isBlock () ) ;
checkState ( catchBody . isBlock () ) ;
context . transpileUnmarkedBlock ( n . isBlock () || n . isAddedBlock () ? n : IR . block ( n ) ) ;
checkState ( newGeneratorHoistBlock . isBlock () , newGeneratorHoistBlock ) ;
c . isBlock ()
c . isBlock ()
checkState ( caseBody . isBlock () , caseBody ) ;
! labeledStatement . isBlock ()
last . isBlock ()
scopeRoot . isBlock () && scopeRoot . getParent () . isFunction ()
NodeUtil . isControlStructureCodeBlock ( n , c ) && ! c . isBlock ()
n . isFunction () && parent != null && parent . isBlock () && ! parent . getParent () . isFunction ()
if ( ! body . isBlock () || ! body . hasOneChild () || ! body . getFirstChild () . isReturn () ) { return; }
s . isFunctionScope () && s . getRootNode () . getLastChild () . isBlock ()
if ( n . isExprResult () || n . isBlock () ) { return; }
checkState ( n . isBlock () , n ) ;
! originalBody . isBlock ()
for ( Node child : node . children () ) { if ( child . isBlock () ) { blocks . add ( child ) ; } }
! isArrow && ! isSignature && ! bodyNode . isBlock ()
! irNode . isBlock ()
n . isFunction () && n . getParent () . isBlock () && ! n . getGrandparent () . isFunction ()
{ return n . isBlock () && n . hasChildren () && isReturnTypeNullable ( n . getParent () ) && ! hasSingleThrow ( n ) ; }
{ return node . getParent () . isExprResult () && node . getGrandparent () . isBlock () && isClinitMethod ( node . getGrandparent () . getParent () ) ; }
checkState ( body . isBlock () , body ) ;
{ checkState ( expr . isName () ) ; checkState ( body . isBlock () ) ; return new Node ( Token.CATCH , expr , body ) ; }
checkState ( finallyBody . isBlock () ) ;
checkState ( tryBody . isBlock () ) ;
{ checkState ( body . isBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
checkState ( body . isBlock () ) ;
checkState ( body . isBlock () ) ;
checkState ( body . isBlock () ) ;
{ checkState ( body . isBlock () ) ; checkState ( mayBeExpression ( cond ) ) ; return new Node ( Token.WHILE , cond , body ) ; }
{ checkState ( body . isBlock () ) ; checkState ( mayBeExpression ( cond ) ) ; return new Node ( Token.DO , body , cond ) ; }
{ checkState ( mayBeExpression ( cond ) ) ; checkState ( then . isBlock () ) ; return new Node ( Token.IF , cond , then ) ; }
checkState ( body . isBlock () || mayBeExpression ( body ) ) ;
checkState ( body . isBlock () ) ;
checkState ( body . getNext () == null && body . isBlock () , body ) ;
{ Node functionBody = NodeUtil . getFunctionBody ( n ) ; if ( ! functionBody . isBlock () ) { return; } }
boolean isVar = NodeUtil . isNameDeclaration ( parent ) && parent . getParent () . isBlock () ;
isGoogScopeFunctionBody ( enclosingFunctionBody ) && scopeRoot . isBlock () && ! scopeRoot . getParent () . isFunction ()
! n . getParent () . isScript () && ! n . getParent () . isBlock ()
if ( newChild . isBlock () ) { NodeUtil . tryMergeBlock ( newChild , false ) ; }
if ( node . isBlock () ) { node . setToken ( Token.SCRIPT ) ; }
deleteWhitespaceBefore && parent != null && ( parent . isScript () || parent . isBlock () )
checkState ( parentNode . isBlock () , STRING_CONSTANT ) ;
checkState ( block . isBlock () ) ;
! body . isBlock ()
for ( ; ! currentParent . isScript () && ! currentParent . isBlock () ; current = currentParent , currentParent = currentParent . getParent () ) {}
checkState ( ifBlock . isBlock () , ifBlock ) ;
checkState ( block . isBlock () , block ) ;
checkState ( block . isBlock () , block ) ;
checkState ( block . isBlock () , block ) ;
checkState ( innerBlock . isBlock () , innerBlock ) ;
checkState ( block . isBlock () , block ) ;
checkState ( block . isBlock () , block ) ;
checkState ( block . isBlock () , block ) ;
checkState ( block . isBlock () ) ;
checkArgument ( node . isBlock () ) ;
{ return getRootNode () . isBlock () && getRootNode () . hasOneChild () && getRootNode () . getFirstChild () . isCatch () ; }
block . isBlock () && block . getParent () . isTry () && block . getParent () . getFirstChild () == block
if ( parent . getParent () != null && parent . getParent () . isArrowFunction () && ! parent . isBlock () ) { return false ; }
! setFunction . hasChildren () || ! setFunction . getLastChild () . isBlock () || ! setFunction . getSecondChild () . isParamList ()
if ( ! getFunction . hasChildren () || ! getFunction . getLastChild () . isBlock () ) { return false ; }
block . isBlock ()
if ( ! favorsCommaOverSemiColon && ! block . isBlock () ) { return false ; }
if ( ! n . isBlock () || ! n . hasChildren () ) { return; }
! ( parent . isScript () || ( grandparent != null && grandparent . isFunction () && parent . isBlock () ) )
JSType calleeTypeI = checkNotNull ( callee . getJSType () , STRING_CONSTANT , callNode . toStringTree () ) ;
assertFalse ( numbers . isSubtype ( sub1 ) ) ;
if ( options . getOutputFeatureSet () . contains ( ES6 ) ) { passes . add ( optimizeToEs6 ) ; }
if ( options.dartPass && ! options . getOutputFeatureSet () . contains ( ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
checkState ( options . getOutputFeatureSet () . contains ( FeatureSet.ES5 ) , STRING_CONSTANT ) ;
{ if ( outputTypes ) { return Format.TYPED ; } if ( prettyPrint || options . getOutputFeatureSet () . contains ( FeatureSet.TYPESCRIPT ) ) { return Format.PRETTY ; } return Format.COMPACT ; }
if ( ! options . getOutputFeatureSet () . contains ( FeatureSet.ES5 ) ) { throw new InvalidOptionsException ( STRING_CONSTANT ) ; }
if ( ! languageOutIsAtLeast ( polyfill.polyfillVersion ) ) { traversal . report ( node , INSUFFICIENT_OUTPUT_VERSION_ERROR , name , compiler . getOptions () . getOutputFeatureSet () . version () ) ; }
{ if ( incrementalCheckMode == IncrementalCheckMode.GENERATE_IJS ) { return false ; } return this . quoteKeywordProperties || FeatureSet.ES3 . contains ( getOutputFeatureSet () ) ; }
{ return getLanguageIn () . toFeatureSet () . has ( feature ) && ! getOutputFeatureSet () . has ( feature ) ; }
{ return getLanguageIn () . toFeatureSet () . contains ( languageLevel ) && ! getOutputFeatureSet () . contains ( languageLevel ) ; }
{ checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . setLanguageOut ( language ) ; }
FeatureSet languageOutFeatures = compiler . getOptions () . getOutputFeatureSet () ;
FeatureSet languageOutFeatures = compiler . getOptions () . getOutputFeatureSet () ;
public void testNestingArrow () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testAssigningArrowToObjectLiteralField_ExpressionBody () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . compiler = compiler ; this . contextStack = new ArrayDeque <> () ; }
private LocalScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
assertThat ( compiler . getErrors () ) . isEmpty () ;
{ if ( inTypeSummary ( error ) ) { return CheckLevel.OFF ; } return null ; }
{ this . outputFeatureSet = Optional . of ( featureSet ) ; }
@ JsOverlay public final List < T > asList () { return new JsArrayList ( this ) ; }
{ asPropertyMap () . set ( key , value ) ; return this ; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es7RewriteExponentialOperator ( compiler ) ; }
FunctionScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
NormalScopeBuilder scopeBuilder = new NormalScopeBuilder ( globalScope ) ;
String path = pathEscaper . escape ( moduleAddress ) ;
String path = pathEscaper . escape ( moduleAddress ) ;
{ return new ModulePath ( normalize ( pathEscaper . escape ( pathResolver . apply ( path ) ) , moduleRootPaths ) ) ; }
visitImport ( t . getInput () . getPath () , n ) ;
private void skipOctalDigits () { while ( peekOctalDigit () ) { nextChar () ; } }
if ( ! currentInfo . hasConstAnnotation () ) { currentInfo . setConstant ( true ) ; populated = true ; return true ; } else { return false ; }
isConst = nameNode . getParent () . isConst () || isExportLhs ( nameNode ) || ( jsdoc != null && jsdoc . isConstant () )
assertThat ( jsdoc . isConstant () ) . isTrue () ;
return shouldDescend ( n , parent ) ;
@ Nullable JSType ownerType
Token type
String name
String name
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . googNamespaces () ) . isEmpty () ;
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
{ currentModule . moduleType ( ModuleType.COMMON_JS , t , n ) ; return; }
return parent == null || ! NodeUtil . createsScope ( n ) ;
JSType ownerType
final Token type
final String name
final String name
assertTypeEquals ( STRING_TYPE , info . getParameterType ( STRING_CONSTANT ) ) ;
{ JSDocInfo info = parse ( STRING_CONSTANT ) ; assertTypeEquals ( NUMBER_TYPE , info . getParameterType ( STRING_CONSTANT ) ) ; }
{ if ( expandObjectLitAssignment ( t , root , export.scope ) ) { return; } }
@ JsMethod ( namespace = STRING_CONSTANT )
{ validator . expectStringOrNumber ( t , n , rightType , STRING_CONSTANT ) ; }
return shouldDescend ( n , parent ) ;
@ Nullable JSType ownerType
Token type
String name
String name
@ JsMethod ( name = STRING_CONSTANT , namespace = STRING_CONSTANT )
@ JsMethod ( namespace = STRING_CONSTANT )
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , newMode , sourceUrl , path , sourceMapCache ) ; }
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , es6ModuleTranspiler , newMode , sourceUrl , path , sourceMapCache ) ; }
Node restRhs = newName ( this . restDeletionVarName ) ;
{ int baseHash = super . hashCode () ; if ( isSpecializedOnlyWithUnknown ) { return baseHash ; } return Objects . hash ( templateTypes , baseHash ) ; }
{ NodeTraversal . traverse ( compiler , rootNode , new CoverageInstrumentationCallback ( instrumentationData , reach ) ) ; }
abstract ImmutableMultiset.Builder < String > es6ImportSpecifiersBuilder ( ) ;
abstract ImmutableMultiset.Builder < String > requiredGoogNamespacesBuilder ( ) ;
abstract ImmutableMultiset.Builder < String > requiredTypesBuilder ( ) ;
public void testSettersForbidden2 () { mode = LanguageMode.ECMASCRIPT3 ; parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden4 () { mode = LanguageMode.ECMASCRIPT3 ; parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden3 () { mode = LanguageMode.ECMASCRIPT3 ; parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden2 () { mode = LanguageMode.ECMASCRIPT3 ; parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; mode = LanguageMode.ES_NEXT ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
validateDefaultValue ( n ) ;
testSame ( STRING_CONSTANT ) ;
options . setEs6ModuleTranspilation ( Es6ModuleTranspilation.TO_COMMON_JS_LIKE_MODULES ) ;
@ Override public boolean isVarArgsParameter ( Node parameter ) { return parameter . isRest () || parameter . isVarArgs () ; }
Node originalRoot = checkNotNull ( input . getAstRoot ( this ) ) ;
return checkNotNull ( input . getAstRoot ( this ) ) ;
findDeps . process ( checkNotNull ( input . getAstRoot ( this ) ) ) ;
Node root = checkNotNull ( input . getAstRoot ( this ) ) ;
return checkNotNull ( root ) ;
{ if ( ! isParsed () ) { parse ( compiler ) ; root . setInputId ( inputId ) ; } return checkNotNull ( root ) ; }
this . root = checkNotNull ( root ) ;
if ( ! options.checksOnly ) {}
{ matchedNodeInfo = MatchedNodeInfo . create ( node , RefactoringUtils . isInClosurizedFile ( node , new NodeMetadata ( compiler ) ) ) ; return this ; }
validateObjectPatternRest ( type , c ) ;
validateArrayPatternRest ( type , c ) ;
{ validateRestParameters ( Token.PARAM_LIST , c ) ; }
public void testForOf4 () { testTypes ( STRING_CONSTANT ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) AbstractCommandLineRunner () { this ( System.in , System.out , System.err ) ; }
boolean shouldDeclareOnGlobalThis = isGlobalVar && ( parent . isVar () || parent . isFunction () ) ;
JSType maybeThisType = info . getThisType () . evaluate ( templateScope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( templateScope , typeRegistry ) ; returnTypeInferred = false ; }
JSType maybeThisType = info . getThisType () . evaluate ( scope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( scope , typeRegistry ) ; returnTypeInferred = false ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
if ( ! compiler . hasHaltingErrors () ) { TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , features ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , new GeneratorFunctionsTranspiler () ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , new GeneratorFunctionsTranspiler () ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
checkState ( source . isFunction () || source . isClass () , source ) ;
JSType returnType = getExplicitReturnTypeIfExpected ( n ) ;
case RELATIVIZE_IMPORT_PATHS :
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new Es6RelativizeImportPaths ( compiler ) ; }
SourceFile expectedEs6 = SourceFile . fromCode ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
public void testSpreadLibInjection () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; assertThat ( getLastCompiler () . injected ) . containsExactly ( STRING_CONSTANT ) ; }
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new Es6RewriteClass ( compiler ) ; }
if ( areIdentical ( this , that ) ) { return true ; }
public final boolean isGlobalThisType () { return areIdentical ( this , registry . getNativeType ( JSTypeNative.GLOBAL_THIS ) ) ; }
public final boolean isUnresolvedOrResolvedUnknown () { return isNoResolvedType () || ( isNamedType () && isUnknownType () ) ; }
assertSame ( objectType . getImplicitPrototype () , OBJECT_TYPE ) ;
{ JSType referencedType = getReferencedType () ; if ( areIdentical ( referencedType , this ) ) { handleTypeCycle ( reporter ) ; } }
defineVars ( n ) ;
defineVar ( n ) ;
if ( context . isAsyncContext () ) { convertAsyncFunction ( t , context ) ; }
JSType maybeThisType = info . getThisType () . evaluate ( templateScope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( templateScope , typeRegistry ) ; returnTypeInferred = false ; }
MockControl < T > mockControl = new MockControl < T > ( mockitoState , new MatchersBinder () ) ;
VerifyingRecorderTest . class
public void andThrows ( Throwable throwable ) { verifyingRecorder . eraseLastInvocation () ; stubber . addThrowable ( throwable ) ; }
public void andReturn ( T value ) { verifyingRecorder . eraseLastInvocation () ; stubber . addReturnValue ( value ) ; }
NumberOfInvocationsVerifierTest . class
OngoingVerifyingModeTest . class
{ stub ( mock . simpleMethod () ) . andThrow ( null ) ; }
{ stub ( mock . simpleMethod () ) . andThrow ( new Exception () ) ; }
OngoingVerifyingMode mode
{ return verify ( mock , OngoingVerifyingMode . times ( wantedNumberOfInvocations ) ) ; }
< T > T verify ( T mock , OngoingVerifyingMode ongoingVerifyingMode ) ;
stub ( mock . size () ) . andThrow ( new RuntimeException () ) ;
stub ( mock . size () ) . andThrow ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( error ) ;
stub ( reader . read () ) . andThrow ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( expected ) ;
stub ( mock . simpleMethod () ) . andThrow ( new RuntimeException () ) ;
state . verifyingStarted ( OngoingVerifyingMode . atLeastOnce () ) ;
assertNull ( Mockito.mockitoState . pullStubable () ) ;
MockingProgressImplTest . class
state = new MockingProgressImpl () ;
{ MockControl < T > control = MockUtil . getControl ( mock ) ; mockingProgress . stubbingStarted () ; return control ; }
mockingProgress . validateState () ;
mockingProgress . validateState () ;
{ MockUtil . validateMock ( mock ) ; mockingProgress . verifyingStarted ( mode ) ; return mock ; }
MockControl < T > mockControl = new MockControl < T > ( mockingProgress , new MatchersBinder () ) ;
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable ) ) ; }
public void addReturnValue ( Object value ) { mockingProgress . stubbingCompleted () ; addResult ( Result . createReturnResult ( value ) ) ; }
MockingProgressImpl state = new MockingProgressImpl () ;
assertNull ( Mockito.mockingProgress . pullStubable () ) ;
void verify ( InvocationsCalculator calculator , InvocationMatcher wanted , OngoingVerifyingMode mode ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT ) ) ;
{ setStackTrace ( STRING_CONSTANT ) ; setCauseStackTrace ( STRING_CONSTANT ) ; remove () ; assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder () ) ; }
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
@ Test ( expected = TooLittleActualInvocationsError . class )
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . oneArg ( true ) ; fail () ; } catch ( TooLittleActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooLittleActualInvocationsError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooLittleActualInvocationsError e ) {}
@ Test ( expected = TooLittleActualInvocationsError . class )
@ Test ( expected = TooManyActualInvocationsError . class )
verifyingRecorder . recordInvocation ( invocationMatcher . getInvocation () ) ;
verifyingRecorder = new VerifyingRecorder < T > () ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk ( null ) ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk ( null ) ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk ( null ) ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk ( null ) ;
InvocationsCalculator calculator = new InvocationsCalculator ( invocations ) ;
verifyingRecorder = createRecorder () ;
Invocation differentMethod = new InvocationBuilder () . differentMethod () . toInvocation () ;
Invocation differentMethod = new InvocationBuilder () . differentMethod () . toInvocation () ;
simpleMethod = new InvocationBuilder () . simpleMethod () . toInvocation () ;
VerificationModeTest . class
VerificationMode mode
void verify ( InvocationsCalculator calculator , InvocationMatcher wanted , VerificationMode mode ) ;
public void reset () { stubbingInProgress = false ; verificationMode = null ; invocationSequenceNumber = NUMBER_CONSTANT ; }
{ calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ; }
{ calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ; }
HasStackTrace firstUndesired = calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ;
{ return verify ( mock , VerificationMode . times ( wantedNumberOfInvocations ) ) ; }
< T > T verify ( T mock , VerificationMode verificationMode ) ;
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( VerificationMode . times ( NUMBER_CONSTANT ) ) ) ;
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( VerificationMode . times ( NUMBER_CONSTANT ) ) ) ;
VerificationMode mode
VerificationMode mode
VerificationMode mode
VerificationMode mode
VerificationMode mode
VerificationMode mode = VerificationMode . atLeastOnce () ;
VerificationMode mode = VerificationMode . atLeastOnce () ;
VerificationMode mode
VerificationMode mode
for ( Object mock : mocks ) { MockUtil . validateMock ( mock ) ; strictOrderVerifier . addMockToBeVerifiedStrictly ( mock ) ; }
if ( i . isVerifiedStrictly () ) { continue; }
{ if ( mode . isStrict () ) { return chunker . getFirstUnverifiedInvocationChunk ( mode . getAllMocksToBeVerifiedInSequence () ) ; } else { return registeredInvocations ; } }
public boolean isStrict () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
if ( mocks.length == NUMBER_CONSTANT ) { reporter . mocksHaveToBePassedWhenCreatingStrictly () ; }
if ( stubable == null ) { reporter . missingMethodInvocation () ; }
if ( ! mocksToBeVerifiedSrictly . contains ( mock ) ) { reporter . strictlyRequiresFamiliarMock () ; }
if ( unverified != null ) { reporter . zeroInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
if ( unverified != null ) { reporter . noMoreInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
List < Verifier > verifiers = Arrays . asList ( new MissingInvocationVerifier () , new NumberOfInvocationsVerifier ( new Reporter () ) ) ;
IAnswer result
for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( wanted ) ) { return s . answer () ; } }
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( times ( NUMBER_CONSTANT ) ) ) ;
assertThat ( chunk , collectionHasExactlyInOrder ( invocationOneChunkOne , invocationTwoChunkOne ) ) ;
VerificationMode mode = new VerificationModeBuilder () . strict () ;
strictly . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . varargsObject ( NUMBER_CONSTANT , textOne , textOne ) ;
strictly . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod ( textOne ) ;
strictly . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
{ strictly . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; }
{ strictly . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
{ strictly . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
strictly . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
strictly . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
{ strictly . verify ( two , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
strictly . verify ( two , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
verify ( map , times ( NUMBER_CONSTANT ) ) . put ( anyObject () , anyObject () ) ;
verify ( list , times ( NUMBER_CONSTANT ) ) . add ( STRING_CONSTANT ) ;
verify ( mock , times ( NUMBER_CONSTANT ) ) . add ( STRING_CONSTANT ) ;
Mockito . verify ( mock , times ( NUMBER_CONSTANT ) ) . add ( STRING_CONSTANT ) ;
{ Mockito . verify ( mock , times ( NUMBER_CONSTANT ) ) . clear () ; fail () ; }
verify ( mockOne , times ( NUMBER_CONSTANT ) ) . varargsObject ( NUMBER_CONSTANT , textOne , textOne ) ;
verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod ( textOne ) ;
verify ( mock , times ( NUMBER_CONSTANT ) ) . oneArg ( two ) ;
{ return new VerificationMode ( wantedNumberOfInvocations , mocksToBeVerifiedStrictly , Verification.EXPLICIT ) ; }
assertNotNull ( STRING_CONSTANT , verifierStub.calculator ) ;
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationMode mode ) ;
verifier . verify ( asList ( wanted . getInvocation () ) , wanted , mode ) ;
verifier . verify ( asList ( wanted . getInvocation () ) , wanted , mode ) ;
verifiers = Arrays . asList ( new MissingInvocationVerifier () , new NumberOfInvocationsVerifier () , new NoMoreInvocationsVerifier () )
assertNotNull ( STRING_CONSTANT , verifierStub.invocations ) ;
assertThat ( verifierStub.invocations , collectionHasExactlyInOrder ( differentMethod . getInvocation () ) ) ;
assertThat ( verifierStub.invocations , collectionHasExactlyInOrder ( simpleMethod ) ) ;
{ this . invocations = invocations ; return invocationToReturn ; }
{ calculator.invocationToReturn = null ; verifier . verify ( null , null , VerificationMode . noMoreInteractions () ) ; }
{ times ( - NUMBER_CONSTANT ) ; fail () ; }
if ( ! mode . exactNumberOfInvocationsMode () ) { return; }
if ( mode . explicitMode () ) { return; }
{ if ( mode . strictMode () ) { return chunker . getFirstUnverifiedInvocationChunk ( mode . getAllMocksToBeVerifiedInSequence () ) ; } else { return registeredInvocations ; } }
if ( mode . explicitMode () ) { marker . markInvocationsAsVerified ( invocations , wanted , mode ) ; }
public boolean exactNumberOfInvocationsMode () { return ! atLeastOnceMode () && explicitMode () ; }
public boolean missingMethodMode () { return explicitMode () && ( atLeastOnceMode () || wantedInvocationCount == NUMBER_CONSTANT ) ; }
public boolean explicitMode () { return verification == Verification.EXPLICIT ; }
public boolean strictMode () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
public boolean atLeastOnceMode () { return wantedInvocationCount == null && verification == Verification.EXPLICIT ; }
if ( mode . strictMode () ) { markVerifiedStrictly ( invocations ) ; } else { markVerified ( wanted , invocations ) ; }
void say ( String message ) ;
void say ( Object message ) ;
String throwsError ( int count ) ;
String throwsIOException ( int count ) throws IOException ;
String throwsNothing ( boolean value ) ;
boolean withBooleanVarargs ( int value , boolean . . . b ) ;
if ( mocks.length == NUMBER_CONSTANT ) { REPORTER . mocksHaveToBePassedWhenCreatingStrictly () ; }
{ MockControl < T > control = MockUtil . getControl ( mock ) ; MOCKING_PROGRESS . stubbingStarted () ; return control ; }
{ MockUtil . validateMock ( mock ) ; MOCKING_PROGRESS . verificationStarted ( mode ) ; return mock ; }
MockControl < T > mockControl = new MockControl < T > ( MOCKING_PROGRESS , new MatchersBinder () ) ;
assertNull ( Mockito.MOCKING_PROGRESS . pullStubable () ) ;
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
MockHandlerTest . class
for ( Object mock : mocks ) { MockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions () ; }
{ List < Invocation > invocationsOfSingleMock = MockUtil . getMockHandler ( mock ) . getRegisteredInvocations () ; allInvocations . addAll ( invocationsOfSingleMock ) ; }
@ Test ( expected = MockitoException . class ) public void shouldScreamWhenNullPassed () { getMockHandler ( null ) ; }
@ Test ( expected = NotAMockException . class ) public void shouldScreamWhenNotAMockPassed () { getMockHandler ( STRING_CONSTANT ) ; }
try { getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
{ mock . clear () ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {} }
{ mock . clear () ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {} }
NoInteractionsWantedError e
NoInteractionsWantedError e
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
{ UndesiredInvocation cause = buildUndesiredInvocationCause ( actualInvocationStackTrace , STRING_CONSTANT , undesired ) ; throw new NoInteractionsWantedError ( join ( STRING_CONSTANT ) , cause ) ; }
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
Invocation unverified = analyzer . getFirstUnverified ( invocations ) ;
public NoMoreInvocationsVerifier () { this ( new InvocationsAnalyzer () , new Reporter () ) ; }
Invocation actual = analyzer . findActualInvocation ( invocations , wanted ) ;
int actualCount = analyzer . countActual ( invocations , wanted ) ;
public MissingInvocationVerifier () { this ( new InvocationsAnalyzer () , new Reporter () ) ; }
{ analyzer.invocationToReturn = null ; verifier . verify ( null , null , VerificationMode . noMoreInteractions () ) ; }
{ verifier . verify ( invocations , wanted , times ( NUMBER_CONSTANT ) ) ; assertSame ( wanted , analyzerStub.wanted ) ; }
@ Test public void shouldPassBecauseActualInvocationFound () { analyzerStub.actualCountToReturn = NUMBER_CONSTANT ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsAnalyzer () ) ; }
Invocation unverified = analyzer . findFirstUnverified ( invocations ) ;
return actualbyName != null ? actualbyName : findFirstUnverified ( invocations ) ;
{ verify ( sub ) . say ( contains ( STRING_CONSTANT ) ) ; fail () ; }
mockingProgress . reportStubbable ( this ) ;
OngoingStubbing pullStubbable ( ) ;
void reportStubbable ( OngoingStubbing ongoingStubbing ) ;
VerificationModeImpl mode
VerificationModeImplTest . class
VerificationModeImpl mode
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationModeImpl mode ) ;
verifier . verify ( invocations , null , VerificationModeImpl . noMoreInteractions () ) ;
VerificationModeImpl mode
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
{ return VerificationModeImpl . times ( wantedNumberOfInvocations ) ; }
{ return VerificationModeImpl . atLeastOnce () ; }
state . verificationStarted ( VerificationModeImpl . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ;
VerificationModeImpl mode = VerificationModeImpl . times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode
public void verify ( VerificationModeImpl mode ) { verify ( null , mode ) ; }
VerificationModeImpl mode
VerificationModeImpl mode
{ analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ; }
{ analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ; }
HasStackTrace firstUndesired = analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ;
VerificationModeImpl mode
VerificationModeImpl mode
{ VerificationModeImpl mode = VerificationModeImpl . noMoreInteractions () ; recorder . verify ( mode ) ; assertNull ( markerStub.mode ) ; }
VerificationModeImpl mode = new VerificationModeBuilder () . strict () ;
VerificationModeImpl mode = VerificationModeImpl . atLeastOnce () ;
VerificationModeImpl mode = VerificationModeImpl . atLeastOnce () ;
VerificationModeImpl mode
VerificationModeImpl verificationMode = mockingProgress . pullVerificationMode () ;
VerificationModeImpl mode = new VerificationModeBuilder () . strict () ;
VerificationModeImpl mode = new VerificationModeBuilder () . strict () ;
public MissingInvocationVerifier () { this ( new InvocationsAnalyzer () , new ActualInvocationsFinder () , new Reporter () ) ; }
{ setStackTrace ( STRING_CONSTANT ) ; setCauseStackTrace ( STRING_CONSTANT ) ; remove () ; assertTrue ( methodsOnTraceAfterRemoving . isEmpty () ) ; }
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsAnalyzer () , new ActualInvocationsFinder () ) ; }
assertSame ( verifierStub.mode , mode ) ;
three . simpleMethod ( NUMBER_CONSTANT ) ;
public VerificationModeImpl strict () { return VerificationModeImpl . strict ( times , Arrays . asList ( new Object () ) ) ; }
StackTraceFilteringTest . class
{ verify ( mock , times ( NUMBER_CONSTANT ) ) . clear () ; fail () ; }
@ Before public void setup () { mock = mock ( LinkedList . class ) ; }
catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
catch ( WantedButNotInvoked e ) {}
wantedInvocation . differsWithArgumentTypes ( actualInvocation )
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
{ mock . clear () ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {} }
{ mock . clear () ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {} }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
try { verifyNoMoreInteractions ( mockTwo ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
@ Test ( expected = InvocationDiffersFromActual . class )
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
NoInteractionsWanted e
NoInteractionsWanted e
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
InvocationDiffersFromActual e
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooManyActualInvocations e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooManyActualInvocations e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooLittleActualInvocations e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
catch ( NoInteractionsWanted e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { verifyNoMoreInteractions ( mockTwo ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { verifyNoMoreInteractions ( mockThree ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocations e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
InvocationDiffersFromActual error
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
TooManyActualInvocations e
TooLittleActualInvocations e
catch ( InvocationDiffersFromActual e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
catch ( InvocationDiffersFromActual e ) {}
@ Test ( expected = WantedButNotInvoked . class )
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
throw new NoInteractionsWanted ( join ( STRING_CONSTANT ) , cause ) ;
public void wantedButNotInvoked ( String wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted ) ) ; }
throw new InvocationDiffersFromActual ( join ( STRING_CONSTANT , STRING_CONSTANT , wanted ) , cause ) ;
WantedButNotInvoked e
InvocationDiffersFromActual e
@ Test ( expected = TooLittleActualInvocations . class )
try { verify ( mock ) . oneArg ( same ( three ) ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { verify ( mock ) . clear () ; fail () ; } catch ( TooManyActualInvocations e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual expected ) {}
@ Test ( expected = WantedButNotInvoked . class ) public void shouldFailVerification ( ) throws Exception { verify ( mock ) . clear () ; }
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
@ Test ( expected = InvocationDiffersFromActual . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = InvocationDiffersFromActual . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooLittleActualInvocations e ) {}
@ Test ( expected = TooLittleActualInvocations . class )
@ Test ( expected = TooManyActualInvocations . class )
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( WantedButNotInvoked e ) {}
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
TooLittleActualInvocations e
TooManyActualInvocations e
TooManyActualInvocations e
WantedButNotInvoked e
InvocationDiffersFromActual e
chunked = chunker . chunk ( Collections . < Integer > emptyList () , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
List < ObjectsChunk < Integer > > chunked = chunker . chunk ( asList ( NUMBER_CONSTANT ) , new EqualityBasedDistributor () ) ;
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
try { strictly . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
strictly . verify ( mockOne , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
@ Test ( expected = StrictVerificationFailure . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = StrictVerificationFailure . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
@ Test ( expected = StrictVerificationFailure . class )
@ Test ( expected = StrictVerificationFailure . class )
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
public NumberOfInvocationsVerifier () { this ( new Reporter () , new ActualInvocationsFinder () ) ; }
public boolean strictMode () { return ! mocksToBeVerifiedStrictly . isEmpty () && explicitMode () ; }
Invocation unverified = finder . findFirstUnverified ( invocations ) ;
public NoMoreInvocationsVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
{ Invocation similar = finder . findSimilarInvocation ( invocations , wanted , mode ) ; reportMissingInvocationError ( wanted , similar ) ; }
public MissingInvocationVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
{ finder.firstUnverifiedToReturn = null ; verifier . verify ( null , null , VerificationModeImpl . noMoreInteractions () ) ; }
finderStub.similarToReturn = actualInvocation ;
finderStub.similarToReturn = null ;
{ verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ; assertSame ( invocations , finderStub.invocations ) ; }
List < Invocation > chunk = finder . findFirstUnverifiedChunk ( invocations , wanted ) ;
List < Invocation > chunk = finder . findFirstUnverifiedChunk ( invocations , wanted ) ;
InvocationsFinder finder
public NoMoreInvocationsVerifier () { this ( new InvocationsFinder () , new Reporter () ) ; }
InvocationsFinder finder
public MissingInvocationVerifier () { this ( new InvocationsFinder () , new Reporter () ) ; }
finder = new InvocationsFinderStub () ;
finderStub = new InvocationsFinderStub () ;
finderStub = new InvocationsFinderStub () ;
InvocationsFinder finder
public StrictlyNumberOfInvocationsVerifier () { this ( new InvocationsFinder () , new Reporter () ) ; }
if ( mode . strictMode () ) { invocations = globalInvocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedStrictly () ) ; } else { invocations = registeredInvocations ; }
InvocationsFinder finder
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsFinder () ) ; }
InvocationsFinder finder
public StrictlyMissingInvocationVerifier () { this ( new InvocationsFinder () , new Reporter () ) ; }
List < ? extends Object > mocksToBeVerifiedStrictly
List < ? extends Object > mocksToBeVerifiedStrictly
HasStackTrace lastInvocation = finder . getLastStackTrace ( chunk ) ;
HasStackTrace lastInvocation = finder . getLastStackTrace ( actualInvocations ) ;
stub ( mock . booleanReturningMethod ( NUMBER_CONSTANT ) ) . toReturn ( true ) ;
stub ( mock . simpleMethod () ) . toThrow ( new RuntimeException () ) ;
{ stub ( mock . simpleMethod () ) . toThrow ( null ) ; }
{ stub ( mock . simpleMethod () ) . toThrow ( new Exception () ) ; }
return handler . voidMethodStubbable () ;
stub ( mock . size () ) . toThrow ( new RuntimeException () ) ;
stub ( mock . size () ) . toThrow ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( error ) ;
stub ( reader . read () ) . toThrow ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( expected ) ;
stub ( mock . oneArg ( anyString () ) ) . toReturn ( STRING_CONSTANT ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . toReturn ( Boolean.FALSE ) ;
mockingProgress . reportOngoingStubbing ( new OngoingStubbingImpl () ) ;
OngoingStubbing pullOngoingStubbing ( ) ;
void reportOngoingStubbing ( OngoingStubbing ongoingStubbing ) ;
strictly = strictly ( mock , mockTwo ) ;
strictly = strictly ( mockOne , mockTwo , mockThree ) ;
{ Strictly strictly = strictly ( mock ) ; strictly . verify ( null ) ; fail () ; }
{ strictly () ; fail () ; }
Strictly strictly = strictly ( mock ) ;
{ Strictly strictly = strictly ( mock ) ; strictly . verify ( mockTwo ) . simpleMethod () ; }
@ Test ( expected = MockitoException . class ) public void shouldNotCreateStrictlyWithoutMocks () { strictly () ; }
Strictly strictly = strictly ( mockTwo , mockThree ) ;
Strictly strictly = strictly ( mockTwo , mockThree ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockOne ) ;
Strictly strictly = strictly ( mockOne ) ;
Strictly strictly = strictly ( mockOne ) ;
Strictly strictly = strictly ( mockOne , mockThree ) ;
Strictly strictly = strictly ( mockTwo , mockThree ) ;
Strictly strictly = strictly ( mockOne , mockTwo , mockThree ) ;
Strictly strictly = strictly ( mock ) ;
Strictly strictly = strictly ( mockDatabase ) ;
strictly = strictly ( mockOne ) ;
strictly = strictly ( mockOne ) ;
strictly = strictly ( mockOne , mockThree ) ;
strictly = strictly ( mock , mockTwo ) ;
strictly = strictly ( mockOne , mockTwo , mockThree ) ;
strictly = strictly ( mockOne ) ;
strictly = strictly ( mockOne , mockTwo , mockThree ) ;
strictly = strictly ( one , two , three ) ;
T actual
T argument
{ for ( ArgumentMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
List < ArgumentMatcher > matchers
public Not ( ArgumentMatcher first ) { this . first = first ; }
public void reportMatcher ( ArgumentMatcher matcher ) { matcherStack . push ( matcher ) ; }
{ for ( ArgumentMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
List < ArgumentMatcher > matchers
List < ArgumentMatcher > matchers
return null ;
{ return reportMatcher ( matcher ) . < T > nullValue () ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . < String > nullValue () ; }
public static String anyString () { return isA ( String . class ) ; }
{ return LastArguments . instance () . reportNot () . returnFalse () ; }
{ return LastArguments . instance () . reportNot () . returnChar () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnNull () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnChar () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnNull () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnFalse () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnNull () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnChar () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnFalse () ; }
{ return reportMatcher ( matcher ) . < T > returnNull () ; }
public static double doubleThat ( CustomMatcher < Double > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static float floatThat ( CustomMatcher < Float > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static long longThat ( CustomMatcher < Long > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static int intThat ( CustomMatcher < Integer > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static short shortThat ( CustomMatcher < Short > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static byte byteThat ( CustomMatcher < Byte > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static boolean booleanThat ( CustomMatcher < Boolean > matcher ) { return reportMatcher ( matcher ) . returnFalse () ; }
public static char charThat ( CustomMatcher < Character > matcher ) { return reportMatcher ( matcher ) . returnChar () ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . < String > returnNull () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . < String > returnNull () ; }
{ return reportMatcher ( new Matches ( regex ) ) . < String > returnNull () ; }
{ return reportMatcher ( new Contains ( substring ) ) . < String > returnNull () ; }
public static Object notNull () { return reportMatcher ( NotNull.NOT_NULL ) . returnNull () ; }
public static Object isNull () { return reportMatcher ( Null.NULL ) . returnNull () ; }
{ return reportMatcher ( new Same ( value ) ) . returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnChar () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnFalse () ; }
{ return reportMatcher ( new InstanceOf ( clazz ) ) . returnNull () ; }
public static Object anyObject () { return reportMatcher ( Any.ANY ) . returnNull () ; }
public static short anyShort () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static double anyDouble () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static float anyFloat () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static long anyLong () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static int anyInt () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static char anyChar () { return reportMatcher ( Any.ANY ) . returnChar () ; }
public static byte anyByte () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static boolean anyBoolean () { return reportMatcher ( Any.ANY ) . returnFalse () ; }
public boolean returnFalse () { return false ; }
public < T > T returnNull () { return null ; }
public char returnChar () { return NUMBER_CONSTANT ; }
public byte returnZero () { return NUMBER_CONSTANT ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnChar () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnNull () ; }
{ return LastArguments . instance () . reportOr () . returnFalse () ; }
{ return LastArguments . instance () . reportAnd () . returnNull () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnChar () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnFalse () ; }
{ return LastArguments . instance () . reportNot () . < T > returnNull () ; }
{ return LastArguments . instance () . reportOr () . < T > returnNull () ; }
{ return LastArguments . instance () . reportAnd () . < T > returnNull () ; }
{ return reportMatcher ( new Find ( regex ) ) . < String > returnNull () ; }
{ return reportMatcher ( new Same ( value ) ) . < T > returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . < T > returnNull () ; }
{ return reportMatcher ( new InstanceOf ( clazz ) ) . < T > returnNull () ; }
inOrder = inOrder ( mock , mockTwo ) ;
assertFalse ( inOrder ( NUMBER_CONSTANT , asList ( new Object () ) ) . exactNumberOfInvocationsMode () ) ;
List < Invocation > unverified = ListUtil . filter ( invocations , new RemoveVerifiedInOrder () ) ;
inOrder = inOrder ( mock , mockTwo ) ;
detects ( new OnVerifyInOrder () , UnfinishedVerificationException . class ) ;
detects ( new OnVerifyInOrder () , UnfinishedStubbingException . class ) ;
detects ( new OnVerifyInOrder () , UnfinishedStubbingException . class ) ;
inOrder . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod () ;
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
@ Test ( expected = VerifcationInOrderFailed . class )
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
@ Test ( expected = WantedButNotInvoked . class )
@ Override public void wantedButNotInvoked ( Object wanted ) { this . wanted = wanted ; }
@ Test ( expected = WantedButNotInvoked . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { inOrder . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = WantedButNotInvoked . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
finderStub.allMatchingUnverifiedChunksToReturn . add ( invocation ) ;
finderStub.allMatchingUnverifiedChunksToReturn . addAll ( asList ( first , second ) ) ;
finderStub.allMatchingUnverifiedChunksToReturn . addAll ( asList ( first , second ) ) ;
finderStub.allMatchingUnverifiedChunksToReturn . add ( differentMethod ) ;
assertTrue ( finderStub.allMatchingUnverifiedChunksToReturn . isEmpty () ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , wanted , mode ) ;
{ reporter . wantedButNotInvoked ( wanted ) ; }
@ Override public void wantedButNotInvoked ( Printable wanted ) { this . wanted = wanted ; }
assertEquals ( wanted , reporterStub.wanted ) ;
Printable wanted
public void wantedButNotInvoked ( Printable wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted . toString () ) ) ; }
@ Override public void wantedButNotInvoked ( Printable wanted ) { this . wanted = wanted ; }
Printable wanted
if ( unverified != null ) { reporter . noMoreInteractionsWanted ( unverified , unverified . getStackTrace () ) ; }
Printable undesired
assertEquals ( firstUnverified , reporterStub.undesired ) ;
Printable wanted
Printable wanted
assertEquals ( wanted , reporterStub.wanted ) ;
assertEquals ( wanted , reporterStub.wanted ) ;
Printable previous
Printable previous
Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( invocations ) ;
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
try { inOrder . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
@ Test ( expected = VerifcationInOrderFailure . class )
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
public String toString () { return actual ; }
public String toString () { return wanted ; }
stub ( mockCalculator . countArticlesInPolish ( anyString () ) ) . toReturn ( NUMBER_CONSTANT ) ;
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { REPORTER . mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
Matcher < T > matcher
{ for ( Matcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < Matcher > matchers ) { this . matchers = matchers ; }
List < Matcher > matchers
public Not ( Matcher first ) { this . first = first ; }
public ReturnValues reportMatcher ( Matcher matcher ) { matcherStack . push ( matcher ) ; return new ReturnValues () ; }
{ for ( Matcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < Matcher > matchers ) { this . matchers = matchers ; }
private static ReturnValues reportMatcher ( Matcher < > matcher ) { return LastArguments . instance () . reportMatcher ( matcher ) ; }
Matcher < Double > matcher
Matcher < Float > matcher
Matcher < Long > matcher
Matcher < Integer > matcher
Matcher < Short > matcher
Matcher < Byte > matcher
Matcher < Boolean > matcher
Matcher < Character > matcher
List < Matcher > matchers
Object actual
List < Matcher > matchers
if ( mode . neverWanted () && noMatchFound ) { return; }
catch ( NeverWantedButInvoked e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NeverWantedButInvoked e ) {}
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
catch ( ArgumentsAreDifferentException e ) {}
catch ( ArgumentsAreDifferentException e ) {}
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferentException e
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( ArgumentsAreDifferentException expected ) {}
OverloadingPuzzleTest . class
PrintableInvocation undesired
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
@ Override public void wantedButNotInvoked ( PrintableInvocation wanted ) { this . wanted = wanted ; }
PrintableInvocation undesired
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
public void wantedButNotInvoked ( PrintableInvocation wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted . toString () ) ) ; }
@ Override public void wantedButNotInvoked ( PrintableInvocation wanted ) { this . wanted = wanted ; }
if ( matchers == null ) { this . matchers = invocation . argumentsToMatchers () ; } else { this . matchers = matchers ; }
mock . simpleMethod ( null , ( Integer ) null ) ;
argumentsMatch ( actual )
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
@ Test ( expected = ArgumentsAreDifferent . class )
@ Test ( expected = ArgumentsAreDifferent . class )
@ Test ( expected = ArgumentsAreDifferent . class )
@ Test ( expected = ArgumentsAreDifferent . class )
catch ( ArgumentsAreDifferent e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) {}
catch ( ArgumentsAreDifferent e ) {}
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferent e
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( ArgumentsAreDifferent expected ) {}
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
assertTrue ( invocation . hasSimilarMethod ( overloadedInvocation ) ) ;
assertFalse ( invocation . hasSimilarMethod ( overloadedInvocation ) ) ;
assertFalse ( simpleMethod . hasSimilarMethod ( onDifferentMock ) ) ;
assertFalse ( simpleMethod . hasSimilarMethod ( verified ) ) ;
invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && argumentsMatch ( actual )
assertTrue ( STRING_CONSTANT + cause . getMessage () + STRING_CONSTANT + text , cause . getMessage () . contains ( text ) ) ;
assertTrue ( STRING_CONSTANT + text + STRING_CONSTANT + value . getMessage () , ( ( Throwable ) value ) . getMessage () . contains ( text ) ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
if ( verificationMode != null ) { verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . emptyValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
if ( mode . inOrderMode () ) { invocations = globalInvocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedInOrder () ) ; } else { invocations = getRegisteredInvocations () ; }
DefaultReturnValuesTest . class
return MockitoConfiguration . defaultReturnValues () . valueFor ( invocation ) ;
if ( verificationMode != null ) { verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . defaultReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
ExampleTest . class
@ After public void resetDefaultReturnValues () { MockitoConfiguration . resetCustomReturnValues () ; }
return MockitoConfiguration . instance () . getReturnValues () . valueFor ( invocation ) ;
@ Before public void configureDefaultReturnValues () { myDefaultReturnValues = new MyDefaultReturnValues () ; MockitoConfiguration . instance () . setReturnValues ( myDefaultReturnValues ) ; }
{ verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . instance () . getReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
@ Before public void configureDefaultReturnValues () { MockitoConfiguration . instance () . setReturnValues ( new MyDefaultReturnValues () ) ; }
Invocation . isToString ( invocation )
InvocationOnMock invocation
InvocationOnMock invocation
InvocationOnMock invocation
InvocationOnMock invocation
return returnValueFor ( returnType ) ;
assertEquals ( ( char ) NUMBER_CONSTANT , mock . charReturningMethod ( NUMBER_CONSTANT ) ) ;
{ FakeReturnValues fakeReturnValues = getFakeReturnValues () ; fakeReturnValues . addMocks ( mocks ) ; }
assertThat ( methodsOnTraceAfterRemoving , hasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , hasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , hasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , hasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
catch ( MockitoException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
assertThat ( m . getMatchers () , hasExactlyInOrder ( new Equals ( STRING_CONSTANT ) ) ) ;
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
{ return MockUtil . createMock ( classToMock , null , MOCKING_PROGRESS ) ; }
String mockDescription = STRING_CONSTANT + ClassNameFinder . classNameForMock ( mock ) + STRING_CONSTANT + mock . hashCode () ;
MockHandler handler = new MockHandler ( null , state , new ExceptionThrowingBinder () ) ;
assertThat ( filtered , hasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
stub ( mock . oneArg ( not ( Matchers . contains ( STRING_CONSTANT ) ) ) ) . toReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( and ( Matchers . contains ( STRING_CONSTANT ) , Matchers . contains ( STRING_CONSTANT ) ) ) ) . toReturn ( STRING_CONSTANT ) ;
try { MockUtil . getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List mock = Mockito . mock ( List . class ) ; assertNotNull ( MockUtil . getMockHandler ( mock ) ) ; }
{ f . set ( testClass , Mockito . mock ( f . getType () , f . getName () ) ) ; }
assertThat ( verifierStub.invocations , hasExactlyInOrder ( simpleMethod , differentMethod . getInvocation () ) ) ;
assertThat ( verifierStub.invocations , hasExactlyInOrder ( simpleMethod ) ) ;
assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ;
if ( mode . inOrderMode () ) { invocations = invocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedInOrder () ) ; } else { invocations = getRegisteredInvocations () ; }
{ return ! Modifier . isFinal ( clazz . getModifiers () ) ; }
{ if ( mocksReturningFakes . contains ( invocation . getMock () ) ) { return returnFake ( invocation ) ; } else { return ConfigurationSupport . defaultValueFor ( invocation ) ; } }
return Configuration . instance () . getReturnValues () . valueFor ( invocation ) ;
MockitoConfiguration config = ConfigurationSupport . getConfiguration () ;
{ verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return Configuration . instance () . getReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
{ super . run ( notifier ) ; ConfigurationSupport . getConfiguration () . resetReturnValues () ; }
{ Object test = super . createTest () ; ConfigurationSupport . getConfiguration () . setReturnValues ( new FriendlyReturnValues () ) ; return test ; }
{ super ( invocation . getInvocation () , invocation . getMatchers () ) ; this . answers . add ( result ) ; }
private Result ( Answer value ) { this . value = value ; }
public void addConsecutiveReturnValue ( Object value ) { stubbed . getFirst () . addAnswer ( Result . createReturnResult ( value ) ) ; }
AnswerFactoryTest . class
{ validateThrowable ( throwable ) ; stubbed . getFirst () . addAnswer ( AnswerFactory . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
Answer result
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( AnswerFactory . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
Answer result = AnswerFactory . createThrowingAnswer ( new RuntimeException () , filterStub ) ;
{ AnswerFactory . createThrowingAnswer ( new RuntimeException () , new StackTraceFilter () ) . answer () ; }
{ Answer result = AnswerFactory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
{ validateThrowable ( throwable ) ; stubbed . getFirst () . addAnswer ( AnswerFactory . createThrowingAnswer ( throwable , new StackTraceFilter () ) ) ; }
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( AnswerFactory . createThrowingAnswer ( throwable , new StackTraceFilter () ) ) ; }
assertEquals ( null , mock . oneArg ( ( Object ) null ) ) ;
assertEquals ( null , mock . oneArg ( ( Object ) null ) ) ;
{ Answer result = factory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
Answer answer = answerFactory . createReturningAnswer ( value ) ;
{ return ( String ) anyObject () ; }
public String toString () { return toString ( argumentsToMatchers () , false ) ; }
{ result . answer ( null ) ; fail () ; }
{ factory . createThrowingAnswer ( new RuntimeException () , null ) . answer ( null ) ; }
{ Answer result = factory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer ( null ) ) ; }
for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) { return s . answer ( invocation ) ; } }
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , not ( isNotNull () ) , eq ( STRING_CONSTANT ) ) ) . toReturn ( STRING_CONSTANT ) ;
{ try { stubber . addAnswer ( new ThrowsException ( null ) ) ; fail () ; } catch ( MockitoException e ) {} }
stubber . addAnswer ( new Returns ( STRING_CONSTANT ) ) ;
{ state . stubbingStarted () ; stubber . addAnswer ( new Returns ( STRING_CONSTANT ) ) ; state . validateState () ; }
{ stubber . addAnswer ( new ThrowsException ( new Exception () ) ) ; fail () ; }
Answer < > answer
Answer < > answer
Answer < > answer
{ stubber . addConsecutiveAnswer ( new ThrowsException ( throwable ) ) ; return this ; }
{ stubber . addConsecutiveAnswer ( new Returns ( value ) ) ; return this ; }
Answer < > answer
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( new ThrowsException ( throwable ) ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( new Returns ( value ) ) ; return new ConsecutiveStubbing () ; }
{ stubber . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
try { stubber . getResultFor ( simpleMethod ) ; fail () ; } catch ( MyException e ) {}
public void setInstance ( Object mock ) {}
ClassWithDodgyConstructor mock = factory . createMock ( ClassWithDodgyConstructor . class , new MockAwareStub () , null ) ;
ClassWithoutConstructor proxy = factory . createMock ( ClassWithoutConstructor . class , new MockAwareStub () , null ) ;
SomeInterface proxy = factory . createMock ( SomeInterface . class , new MockAwareStub () , null ) ;
void setInstance ( T mock ) ;
{ return mock ( classToMock , null ) ; }
return delegate . intercept ( proxy , method , args , methodProxy ) ;
this . stubber = new Stubber ( mockingProgress ) ;
{ MOCKING_PROGRESS . stubbingStarted () ; return new MethodSelectorImpl ( new ThrowsException ( toBeThrown ) ) ; }
{ MOCKING_PROGRESS . stubbingStarted () ; return new MethodSelectorImpl ( new Returns ( toBeReturned ) ) ; }
@ Before public void setUp () { StateMaster . reset () ; mock = Mockito . mock ( IMethods . class ) ; }
{ StateMaster . reset () ; mock = mock ( IMethods . class ) ; }
{ doReturn ( STRING_CONSTANT ) . when ( ( Object ) null ) . toString () ; fail () ; }
{ mockitoStubber . addConsecutiveAnswer ( answer ) ; return this ; }
{ mockitoStubber . addConsecutiveAnswer ( new ThrowsException ( throwable ) ) ; return this ; }
{ mockitoStubber . addConsecutiveAnswer ( new Returns ( value ) ) ; return this ; }
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( new ThrowsException ( throwable ) ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( new Returns ( value ) ) ; return new ConsecutiveStubbing () ; }
{ mockitoStubber . addAnswerForVoidMethod ( answer ) ; return this ; }
public VoidMethodStubbable < T > toReturn () { mockitoStubber . addAnswerForVoidMethod ( new Returns () ) ; return this ; }
{ mockitoStubber . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
this . mockitoStubber = new MockitoStubber ( mockingProgress ) ;
return handler . voidMethodStubbable ( mock ) ;
try { mockitoStubber . setMethodForStubbing ( new InvocationMatcher ( simpleMethod ) ) ; fail () ; } catch ( MockitoException e ) {}
mockitoStubber . setMethodForStubbing ( new InvocationMatcher ( simpleMethod ) ) ;
@ SuppressWarnings ( STRING_CONSTANT ) public void setAnswersForStubbing ( List < Answer > answers ) { mockitoStubber . setAnswersForStubbing ( answers ) ; }
{ return MockUtil . createMock ( classToMock , MOCKING_PROGRESS , name , null ) ; }
doNothing () . doNothing () . doThrow ( new RuntimeException () ) . when ( mock ) . voidMethod () ;
{ validator . validate ( new DoesNothing () , new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ; }
{ validator . validate ( new DoesNothing () , new InvocationBuilder () . simpleMethod () . toInvocation () ) ; }
Stubber doNothing ( ) ;
DoesNothing answer
if ( answer instanceof DoesNothing ) { validateDoNothing ( ( DoesNothing ) answer , invocation ) ; }
detects ( new OnDoAnswer () , UnfinishedVerificationException . class ) ;
detects ( new OnDoAnswer () , UnfinishedStubbingException . class ) ;
detects ( new OnDoAnswer () , UnfinishedStubbingException . class ) ;
enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( toMock ) ) ;
AtLeastXVerificationTest . class
InvocationOnMock invocation
try { mockitoStubber . answerTo ( simpleMethod ) ; fail () ; } catch ( MyException e ) {}
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
mockingProgress . reportOngoingStubbing ( new DeprecatedOngoingStubbingImpl () ) ;
mode . atLeastMode () || ! mode . matchesActualCount ( firstChunk . size () )
public boolean neverWanted () { return ! atLeastMode () && wantedInvocationCount == NUMBER_CONSTANT ; }
public boolean tooManyActualInvocations ( int actualCount ) { return ! atLeastMode () && wantedInvocationCount < actualCount ; }
public boolean tooLittleActualInvocations ( int actualCount ) { return ! atLeastMode () && wantedInvocationCount > actualCount ; }
public boolean missingMethodMode () { return explicitMode () && ( atLeastMode () || wantedInvocationCount > NUMBER_CONSTANT ) ; }
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new VerificationModeImpl ( wantedNumberOfInvocations , null , mocksToBeVerifiedInOrder , Verification.EXPLICIT ) ; }
when ( mockTwo . toString () ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . booleanReturningMethod () ) . thenReturn ( true ) ;
{ when ( mock . simpleMethod () ) . thenThrow ( null ) ; }
{ when ( mock . simpleMethod () ) . thenThrow ( new Exception () ) ; }
when ( mock . size () ) . thenThrow ( new RuntimeException () ) ;
when ( mock . size () ) . thenThrow ( new RuntimeException () ) ;
{ when ( mock . add ( STRING_CONSTANT ) ) . thenThrow ( null ) ; }
when ( mock . add ( STRING_CONSTANT ) ) . thenThrow ( error ) ;
when ( reader . read () ) . thenThrow ( ioException ) ;
when ( mock . add ( STRING_CONSTANT ) ) . thenThrow ( expected ) ;
when ( mock . oneArg ( anyString () ) ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . add ( STRING_CONSTANT ) ) . thenReturn ( Boolean.FALSE ) ;
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
mockingProgress . reportOngoingStubbing ( new OngoingStubbingImpl () ) ;
when ( mock . simpleMethod () ) . thenThrow ( new RuntimeException () ) ;
Mockito . when ( mock . add ( STRING_CONSTANT ) ) . thenReturn ( true ) ;
catch ( AssertionError e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( AssertionError expected ) {}
AssertionError e
catch ( AssertionError e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
if ( mode . explicitMode () || mode . atLeastMode () ) { return; }
boolean atLeast = atLeastMode () && actualCount >= wantedInvocationCount ;
public boolean exactNumberOfInvocationsMode () { return ! inOrderMode () && ( explicitMode () || atLeastMode () ) ; }
public static VerificationModeImpl noMoreInteractions () { return new VerificationModeImpl ( NUMBER_CONSTANT , Collections . emptyList () , Verification.NO_MORE_WANTED ) ; }
{ HasStackTrace lastInvocation = finder . getLastStackTrace ( actualInvocations ) ; reporter . tooLittleActualInvocationsInAtLeastMode ( mode . wantedCount () , actualCount , wanted , lastInvocation ) ; }
ClassImposterizerTest . class
@ Test public void shouldNeverVerifyWhenVerificationIsInAtLeastMode ( ) throws Exception { assertFalse ( verifier . appliesTo ( VerificationModeImpl . atLeastOnce () ) ) ; }
@ Test public void shouldNeverVerifyWhenVerificationIsExplicit ( ) throws Exception { assertFalse ( verifier . appliesTo ( VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ) ; }
new VerificationModeDecoder ( mode ) . atLeastMode ()
new VerificationModeDecoder ( mode ) . inOrderMode ()
VerificationMode mode
VerificationMode mode
VerificationMode mode
public boolean appliesTo ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) . inOrderMode () ; }
VerificationMode mode
public boolean appliesTo ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) . missingMethodMode () ; }
VerificationMode mode
VerificationMode mode
VerificationMode mode
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationMode mode ) ;
VerificationMode mode
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
VerificationMode mode
VerificationMode mode
VerificationMode mode
VerificationMode mode = atLeastOnce () ;
private VerificationModeDecoder decode ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) ; }
VerificationMode mode = atLeastOnce () ;
public VerificationModeDecoder ( VerificationMode mode ) { this . mode = mode ; }
VerificationMode mode = VerificationModeImpl . times ( NUMBER_CONSTANT ) ;
VerificationMode mode
public void verify ( VerificationMode mode ) { verify ( null , mode ) ; }
VerificationMode mode
public boolean appliesTo ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) . exactNumberOfInvocationsMode () ; }
VerificationMode mode
public boolean appliesTo ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) . missingMethodInOrderMode () ; }
VerificationMode mode
VerificationMode inOrderMode = new VerificationModeBuilder () . inOrder () ;
VerificationMode mode = VerificationModeImpl . atLeastOnce () ;
VerificationMode verificationMode = mockingProgress . pullVerificationMode () ;
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new InOrderVerificationMode ( minNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.AT_LEAST ) ; }
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new InOrderVerificationMode ( wantedNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.EXPLICIT ) ; }
verifyingRecorder = new VerifyingRecorder () ;
MockitoVerificationMode mode
MockitoVerificationMode mode
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedDifferentMethod ) , VerificationModeFactory . atLeastOnce () ) ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedSimpleMethod ) , VerificationModeFactory . atLeastOnce () ) ;
MockitoVerificationMode mode
private VerificationModeDecoder decode ( MockitoVerificationMode mode ) { return new VerificationModeDecoder ( mode ) ; }
{ return VerificationModeFactory . atLeast ( minNumberOfInvocations ) ; }
{ return VerificationModeFactory . atLeastOnce () ; }
{ return VerificationModeFactory . times ( wantedNumberOfInvocations ) ; }
MockitoVerificationModeTest . class
state . verificationStarted ( VerificationModeFactory . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ; }
VerificationMode mode = VerificationModeFactory . atLeastOnce () ;
public VerificationModeDecoder ( MockitoVerificationMode mode ) { this . mode = mode ; }
VerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode
{ mode . verify ( new VerificationDataImpl ( getRegisteredInvocations () , wanted ) ) ; }
public InvocationMatcher getWanted () { return wanted ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . returnString () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . returnString () ; }
{ return reportMatcher ( new Matches ( regex ) ) . returnString () ; }
{ return reportMatcher ( new Contains ( substring ) ) . returnString () ; }
{ return reportMatcher ( Any.ANY ) . returnList () ; }
{ return reportMatcher ( Any.ANY ) . returnMap () ; }
{ return reportMatcher ( Any.ANY ) . returnList () ; }
{ return reportMatcher ( Any.ANY ) . returnString () ; }
verifier . verify ( invocations , wanted ) ;
verifier . verify ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted ) ; }
{ missingInvocation . verify ( data . getAllInvocations () , data . getWanted () ) ; }
@ Override public String toString () { return STRING_CONSTANT + wantedCount () ; }
AtMostXVerificationTest . class
{ registeredInvocations . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
{ registeredInvocations . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
this . registeredInvocations = new RegisteredInvocations () ;
RegisteredInvocationsTest . class
{ VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll () , null ) ; VerificationModeFactory . noMoreInteractions () . verify ( data ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll () , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoAssertionError e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
if ( ! ( mode instanceof VerificationInOrderMode ) ) { throw new MockitoException ( mode . getClass () . getSimpleName () + STRING_CONSTANT ) ; }
public boolean neverWanted () { return mode . wantedCount () == NUMBER_CONSTANT ; }
public boolean tooManyActualInvocations ( int actualCount ) { return mode . wantedCount () < actualCount ; }
public boolean tooLittleActualInvocations ( int actualCount ) { return mode . wantedCount () > actualCount ; }
public static MockitoVerificationMode times ( int wantedNumberOfInvocations ) { return new MockitoVerificationMode ( wantedNumberOfInvocations ) ; }
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode
Times atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
Times mode
private VerificationModeDecoder decode ( Times mode ) { return new VerificationModeDecoder ( mode ) ; }
TimesTest . class
public VerificationModeDecoder ( Times mode ) { this . mode = mode ; }
Times mode
Times mode
return Mockito . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ;
int wantedCount
List < Invocation > chunk = finder . findMatchingChunk ( invocations , wanted , mode . wantedCount () ) ;
{ if ( wantedNumberOfInvocations < NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedCount = wantedNumberOfInvocations ; }
{ if ( wantedNumberOfInvocations <= NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedCount = wantedNumberOfInvocations ; }
numberOfCalls . verify ( allInvocations , wanted , wantedCount ) ;
wantedCount > NUMBER_CONSTANT
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted ) ;
verifier . check ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . check ( invocations , wanted ) ; }
verifier . check ( invocations , wanted ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
if ( wantedCount == NUMBER_CONSTANT ) { missingInvocation . check ( allInvocations , wanted , this ) ; }
if ( wantedCount == NUMBER_CONSTANT ) { missingInvocation . check ( data . getAllInvocations () , data . getWanted () ) ; }
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
checker . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
checker . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
checker . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
checker = new MissingInvocationInOrderChecker ( finderStub , reporterStub ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; checker . check ( invocations , wanted ) ; }
checker . check ( invocations , wanted ) ;
checker = new MissingInvocationChecker ( finderStub , reporterStub ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker = new NumberOfInvocationsChecker ( reporterStub , finderStub ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
checker = new NumberOfInvocationsInOrderChecker ( finderStub , reporter ) ;
numberOfCalls . check ( allInvocations , wanted , wantedCount ) ;
numberOfInvocations . check ( data . getAllInvocations () , data . getWanted () , wantedCount ) ;
if ( stubbing == null ) { MOCKING_PROGRESS . reset () ; REPORTER . missingMethodInvocation () ; }
Object value
T value
public DeprecatedOngoingStubbing < T > toReturn ( T value ) { return toAnswer ( new Returns ( value ) ) ; }
public NewOngoingStubbing < T > thenReturn ( T value ) { return thenAnswer ( new Returns ( value ) ) ; }
{ return mock ( classToMock , name , null , USING_GLOBAL_CONFIG ) ; }
{ return mock ( classToMock , null , null , USING_GLOBAL_CONFIG ) ; }
MockHandler handler = new MockHandler ( null , state , new ExceptionThrowingBinder () , null ) ;
{ return returnValues . valueFor ( invocation ) ; }
if ( mockedType . getSigners () != null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy.INSTANCE ) ; }
MockingProgress state = new MockingProgressImpl () ;
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnFalse () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnFalse () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnFalse () ; }
public void reset () { stubbingInProgress = false ; verificationMode = null ; getLastArguments () . reset () ; }
getLastArguments () . validateState () ;
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnFalse () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnFalse () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnFalse () ; }
public void reset () { stubbingInProgress = false ; verificationMode = null ; getArgumentMatcherStorage () . reset () ; }
getArgumentMatcherStorage () . validateState () ;
ArgumentMatcherStorage argumentMatcherStorage
private boolean shouldPrint () { return ! unusedStubs . isEmpty () || ! unstubbedInvocations . isEmpty () ; }
public void stubbingCompleted ( Invocation invocation ) { debuggingHelper . addStubbedInvocation ( invocation ) ; stubbingInProgress = false ; }
public ExperimentalMockitoJUnitRunner ( Class < > klass ) throws InitializationError { super ( klass ) ; logger = new MockitoLoggerImpl () ; }
public void addUnstubbedInvocation ( InvocationMatcher invocation ) { unstubbedInvocations . add ( invocation ) ; }
public byte [] naughtyMethodUnderTestWhichDoesNotFailBecauseItReturnsAValue ( String filename ) { return null ; }
if ( ! invocation . isVoid () && answer == null ) { mockingProgress . getDebuggingHelper () . addPotentiallyUnstubbed ( invocationMatcher ) ; }
public void stubbingCompleted ( Invocation invocation ) { debuggingInfo . addStubbedInvocation ( invocation ) ; stubbingInProgress = false ; }
public void println () { System.out . println () ; }
void println ( Object what ) ;
if ( ! invocation . isVoid () && answer == null ) { mockingProgress . getDebuggingInfo () . addPotentiallyUnstubbed ( invocationMatcher ) ; }
public ExperimentalMockitoJUnitRunner ( Class < > klass ) throws InitializationError { super ( klass ) ; }
void log ( Object what ) ;
{ if ( hasData () ) { WarningsPrinter warningsPrinter = new WarningsPrinter ( unusedStubs , unstubbedInvocations ) ; warningsPrinter . print ( logger ) ; } }
public void addPotentiallyUnstubbed ( InvocationMatcher invocationMatcher ) { if ( ! collectingData ) { return; } unstubbedInvocations . add ( invocationMatcher ) ; }
public ExperimentalMockitoJUnitRunnerPMStub ( ) throws InitializationError { super ( ExperimentalMockitoJUnitRunnerPMTest . class , loggerStub ) ; }
String loggedInfo = loggerStub . getLoggedInfo () ;
String loggedInfo = loggerStub . getLoggedInfo () ;
String loggedInfo = loggerStub . getLoggedInfo () ;
String loggedInfo = loggerStub . getLoggedInfo () ;
public void log ( Object what ) { super . log ( what ) ; loggedInfo . append ( what ) ; }
{ return DEFAULT_RETURN_VALUES . valueFor ( invocation ) ; }
{ someUnusedStubbingThatQualifiesForWarning () ; notifier . fireTestFailure ( null ) ; assertTrue ( debuggingInfo . hasData () ) ; }
HandyReturnValues reportMatcher ( Matcher matcher ) ;
{ return mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
EmptyReturnValuesTest . class
Foo mock = mock ( Foo . class , RETURNS_SMART_NULLS ) ;
Foo mock = mock ( Foo . class , RETURNS_SMART_NULLS ) ;
@ Before public void setup () { mock = mock ( IMethods . class , Mockito.RETURNS_SMART_NULLS ) ; }
MockName mockName
catch ( NoSuchMethodException e ) { throw new RuntimeException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ validateState () ; resetOngoingStubbing () ; verificationMode = new Localized ( verify ) ; }
unfinishedVerificationHere () ;
verify ( mock ) ;
{ mock ( IMethods . class ) ; fail () ; }
this . firstTraceElement = filter . filterStackTrace ( stackTrace ) [ NUMBER_CONSTANT ] ;
if ( callback instanceof MethodInterceptorFilter ) { return ( MethodInterceptorFilter < MockHandler < T > > ) callback ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
ClickableStackTracesTest . class
STRING_CONSTANT + pluralize ( actualCount ) + STRING_CONSTANT
{ matcherStack . push ( new LocalizedMatcher ( matcher ) ) ; return new HandyReturnValues () ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( expectedMessage , actualMessage ) ;
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NeverWantedButInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
reporter . tooLittleActualInvocations ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ;
reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ;
STRING_CONSTANT + Pluralizer . pluralize ( wantedCount ) + STRING_CONSTANT
reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ;
reporter . tooLittleActualInvocationsInOrder ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ;
catch ( SmartNullPointerException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
@ Test ( expected = VerificationInOrderFailure . class )
catch ( VerificationInOrderFailure e ) {}
@ Test ( expected = VerificationInOrderFailure . class )
try { inOrder . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( spy ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure f ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
@ Test ( expected = VerificationInOrderFailure . class )
@ Test ( expected = VerificationInOrderFailure . class )
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
{ String message = createTooLittleInvocationsMessage ( discrepancy , wanted , lastActualStackTrace ) ; throw new VerificationInOrderFailure ( join ( STRING_CONSTANT + message ) ) ; }
throw new VerificationInOrderFailure ( join ( STRING_CONSTANT + message ) ) ;
VerificationInOrderFailure e
VerificationInOrderFailure e
VerificationInOrderFailure e
VerificationInOrderFailure e
catch ( VerificationInOrderFailure e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
private void misplacedArgumentMatcherHere () { anyString () ; }
if ( stubbingInProgress ) { stubbingInProgress = false ; reporter . unfinishedStubbing ( debuggingInfo . getLastInvocationLocation () ) ; }
assertContains ( expectedMessage , actualMessage ) ;
mockitoStubber . setInvocationForPotentialStubbing ( new InvocationBuilder () . toInvocationMatcher () , null ) ;
{ return new VoidMethodStubbableImpl < T > ( mock , mockitoStubber ) ; }
if ( stubbingInProgress ) { stubbingInProgress = false ; reporter . unfinishedStubbing () ; }
mockitoStubber . setInvocationForPotentialStubbing ( new InvocationBuilder () . toInvocationMatcher () ) ;
{ return new VoidMethodStubbableImpl ( mock ) ; }
public void reset () { stubbingInProgress = null ; verificationMode = null ; getArgumentMatcherStorage () . reset () ; }
public void stubbingCompleted ( Invocation invocation ) { debuggingInfo . addStubbedInvocation ( invocation ) ; stubbingInProgress = null ; }
assertEquals ( invocation . getLocation () , reporterStub.location ) ;
assertSame ( third . getLocation () , reporterStub.location ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.location ) ; }
assertSame ( second . getLocation () , reporterStub.location ) ;
Throwable hasStackTrace
reporter . argumentsAreDifferent ( syncingPrinter . getWanted () , syncingPrinter . getActual () , similar . getLocation () ) ;
if ( unverified != null ) { new Reporter () . noMoreInteractionsWanted ( unverified , unverified . getLocation () ) ; }
assertSame ( actualInvocation . getLocation () , reporterStub.actualLocation ) ;
assertNull ( reporterStub.actualLocation ) ;
assertSame ( previous . getLocation () , reporterStub.previousLocation ) ;
{ Throwable filtered = throwable . fillInStackTrace () ; filter . filterStackTrace ( filtered ) ; throw filtered ; }
Location firstUndesired
Location firstUndesired
if ( previousInOrder == null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder , previousInOrder . getLocation () ) ; }
int expectedMatchersSize = invocation . getArgumentsCount () ;
final boolean overloadedButSameArgs = ! methodEquals && argumentsMatch ( candidate . getArguments () ) ;
Location lastLocation = finder . getLastLocation ( actualInvocations ) ;
Location lastInvocation = finder . getLastLocation ( actualInvocations ) ;
Location lastInvocation = finder . getLastLocation ( chunk ) ;
Location lastLocation = finder . getLastLocation ( chunk ) ;
if ( unverified != null ) { new Reporter () . noMoreInteractionsWanted ( unverified ) ; }
if ( previousInOrder == null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder ) ; }
@ Override public String toString () { return STRING_CONSTANT + this . firstTraceElement . toString () ; }
if ( matcherStack . isEmpty () ) { return Collections . emptyList () ; }
{ return MockitoCore . doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return MockitoCore . doAnswer ( new DoesNothing () ) ; }
{ return MockitoCore . doAnswer ( new ThrowsException ( toBeThrown ) ) ; }
{ MockitoCore . verifyNoMoreInteractions ( mocks ) ; }
{ return MockitoCore . verify ( mock , times ( NUMBER_CONSTANT ) ) ; }
{ return MockitoCore . mock ( classToMock , null , ( T ) null , returnValues ) ; }
{ return MockitoCore . mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return MockitoCore . mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
assertTrue ( ret . getClass () . isArray () ) ;
assertNull ( new ThreadSafeMockingProgress () . pullOngoingStubbing () ) ;
{ return MOCKITO_CORE . inOrder ( mocks ) ; }
{ return MOCKITO_CORE . doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return MOCKITO_CORE . doAnswer ( new DoesNothing () ) ; }
{ return MOCKITO_CORE . doAnswer ( answer ) ; }
{ return MOCKITO_CORE . doAnswer ( new ThrowsException ( toBeThrown ) ) ; }
{ return MOCKITO_CORE . stubVoid ( mock ) ; }
{ MOCKITO_CORE . verifyNoMoreInteractions ( mocks ) ; }
{ MOCKITO_CORE . verifyNoMoreInteractions ( mocks ) ; }
{ return MOCKITO_CORE . verify ( mock , mode ) ; }
{ MOCKITO_CORE . reset ( mock ) ; }
{ return MOCKITO_CORE . verify ( mock , times ( NUMBER_CONSTANT ) ) ; }
{ return MOCKITO_CORE . when ( methodCall ) ; }
{ return MOCKITO_CORE . stub ( methodCall ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , ( T ) null , returnValues ) ; }
{ return MOCKITO_CORE . mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
return mockitoCore . mock ( ( Class ) class1 , null , null , this ) ;
for ( T m : mocks ) { MockUtil . resetMock ( m , MOCKING_PROGRESS ) ; }
mockingProgress . stubbingStarted () ;
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { reporter . mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
{ mockingProgress . stubbingStarted () ; return ( NewOngoingStubbing ) stub () ; }
{ mockingProgress . stubbingStarted () ; return ( DeprecatedOngoingStubbing ) stub () ; }
super . makeStackTracesClean () ;
super . makeStackTracesClean () ;
{ mock = mock ( IMethods . class , Mockito.RETURNS_SMART_NULLS ) ; super . makeStackTracesClean () ; }
{ super . makeStackTracesClean () ; first () ; second () ; third () ; fourth () ; }
@ Before public void init () { new StateMaster () . validate () ; MockitoAnnotations . initMocks ( this ) ; }
new StateMaster () . validate () ;
{ return anyObject () ; }
{ unfilteredStackTrace = getStackTrace () ; StackTraceFilter filter = new StackTraceFilter () ; filter . filterConditionally ( this ) ; }
filter . filterConditionally ( this ) ;
filter . filterConditionally ( t ) ;
filter . filterConditionally ( this ) ;
this . firstTraceElement = filter . filter ( stackTrace ) [ NUMBER_CONSTANT ] ;
public void cleanStackTraces () { super . makeStackTracesClean () ; }
filter . filter ( t ) ;
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NeverWantedButInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( AssertionError e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( InvalidUseOfMatchersException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertContains ( STRING_CONSTANT , mockTwo . toString () ) ;
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
final boolean overloadedButSameArgs = ! methodEquals && safelyArgumentsMatch ( candidate . getArguments () ) ;
{ return ( T ) anyObject () ; }
Invocation i = new Invocation ( mock , method , args , sequenceNumber , null ) ;
TestedObject mock = mock ( TestedObject . class ) ;
public Person ( Integer age ) { this . age = age ; }
if ( arguments . isEmpty () ) { new Reporter () . noArgumentValueWasCaptured () ; } else { return ( T ) arguments . getLast () ; }
{ anyObject () ; try { Mockito . validateMockitoUsage () ; fail () ; } catch ( InvalidUseOfMatchersException e ) {} }
try { Mockito . validateMockitoUsage () ; fail () ; } catch ( UnfinishedStubbingException e ) {}
{ verify ( mock ) ; try { Mockito . validateMockitoUsage () ; fail () ; } catch ( UnfinishedVerificationException e ) {} }
{ return this . capturingMatcher . getAllValues () ; }
{ Mockito . argThat ( capturingMatcher ) ; return null ; }
{ notifier . addListener ( new FrameworkUsageValidator ( notifier ) ) ; legacyRunner . run ( notifier ) ; }
{ if ( classProvider . isJUnit45OrHigherAvailable () ) { return classProvider . newInstance ( STRING_CONSTANT , klass ) ; } else { return classProvider . newInstance ( STRING_CONSTANT , klass ) ; } }
RunnerFactory ( RunnerProvider classProvider ) { this . classProvider = classProvider ; }
{ this . runner = new JUnit44RunnerImpl ( klass ) ; }
runner . run ( notifier ) ;
catch ( Throwable t ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , t ) ; }
@ Test public void shouldCallRealMethdsEvenDelegatedToOtherSelfMethod () { String name = spy . getName () ; assertEquals ( STRING_CONSTANT , name ) ; }
Name guessName () { return defaultName ; }
public String getName () { return guessName () . name ; }
{ try { new ShallowCopyTool () . copyToMock ( optionalInstance , mock ) ; } catch ( UnableToCopyFieldValue e ) {} }
if ( MockUtil . isMock ( instance ) ) { return returnValues . valueFor ( invocation ) ; } else { return methodProxy . invokeSuper ( proxy , args ) ; }
{ return new VoidMethodStubbableImpl < T > ( mock , mockitoStubber ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , name , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , null , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , configureWith () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
assertTrue ( new MockUtil () . isMock ( classMock ) ) ;
assertTrue ( new MockUtil () . isMock ( interfaceMock ) ) ;
MockName name = new MockUtil () . getMockName ( mock ) ;
try { mockUtil . getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List mock = Mockito . mock ( List . class ) ; assertNotNull ( mockUtil . getMockHandler ( mock ) ) ; }
MockHandler < T > handler = mockUtil . getMockHandler ( mock ) ;
if ( mock == null ) { reporter . nullPassedWhenCreatingInOrder () ; } else if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder () ; }
{ if ( mock == null ) { reporter . nullPassedToVerifyNoMoreInteractions () ; } mockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions () ; }
for ( T m : mocks ) { mockUtil . resetMock ( m , mockingProgress ) ; }
if ( mock == null ) { reporter . nullPassedToVerify () ; } else if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify () ; }
{ mockingProgress . validateState () ; mockingProgress . resetOngoingStubbing () ; return mockUtil . createMock ( classToMock , mockingProgress , ( MockSettingsImpl ) mockSettings ) ; }
new MockUtil () . getMockHandler ( withFinal ) ;
List < Invocation > fromSingleMock = new MockUtil () . getMockHandler ( mock ) . getRegisteredInvocations () ;
if ( new MockUtil () . isMock ( throwable ) ) { throw throwable ; }
new MockUtil () . isMock ( instance )
{ mock ( IMethods . class , withSettings () . extraInterfaces ( ( Class [] ) null ) ) ; }
@ Test public void shouldScreamWhenExtraIsTheSame () { mock ( IMethods . class , withSettings () . extraInterfaces ( IMethods . class ) ) ; }
@ Test public void shouldScreamWhenNonInterfacePassed () { mock ( IMethods . class , withSettings () . extraInterfaces ( LinkedList . class ) ) ; }
{ mock ( IMethods . class , withSettings () . extraInterfaces ( List . class , null ) ) ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultBehavior ( RETURNS_DEFAULTS ) )
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . defaultBehavior ( returnValues ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . name ( name ) . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ mock ( IMethods . class , withSettings () . extraInterfaces ( IMethods . class ) ) ; fail () ; }
{ mock ( Foo . class , withSettings () . extraInterfaces ( Foo . class ) ) ; fail () ; }
{ mock ( Foo . class , withSettings () . extraInterfaces ( ( Class [] ) null ) ) ; fail () ; }
{ mock ( Foo . class , withSettings () . extraInterfaces () ) ; fail () ; }
{ mock ( Foo . class , withSettings () . extraInterfaces ( IFoo . class , null ) ) ; fail () ; }
Foo mock = mock ( Foo . class , withSettings () . extraInterfaces ( IFoo . class , IBar . class ) ) ;
{ return mock ( classToMock , withSettings () . defaultBehavior ( returnValues ) ) ; }
{ return mock ( classToMock , withSettings () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ assertEquals ( STRING_CONSTANT , values . answer ( invocationOf ( StringMethods . class , STRING_CONSTANT ) ) ) ; }
ret = ( String [] ) values . answer ( invocationOf ( StringMethods . class , STRING_CONSTANT ) )
IMethods mock = mock ( IMethods . class , withSettings () . defaultAnswer ( RETURNS_SMART_NULLS ) . name ( STRING_CONSTANT ) ) ;
public static MockSettings withSettings () { return new MockSettingsImpl () . defaultAnswer ( RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . doAnswer ( new CallsRealMethods () ) ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultAnswer ( RETURNS_DEFAULTS ) )
{ return mock ( classToMock , withSettings () . name ( name ) . defaultAnswer ( RETURNS_DEFAULTS ) ) ; }
{ return mock ( classToMock , withSettings () . defaultAnswer ( RETURNS_DEFAULTS ) ) ; }
{ return mockSettings . getDefaultAnswer () . answer ( invocation ) ; }
{ MockSettingsImpl settings = ( MockSettingsImpl ) Mockito . withSettings () ; assertEquals ( Mockito.RETURNS_DEFAULTS , settings . getDefaultAnswer () ) ; }
ReturnsEmptyValuesTest . class
{ ConfigurationAccess . getConfig () . overrideCleansStackTrace ( false ) ; ConfigurationAccess . getConfig () . overrideDefaultAnswer ( null ) ; }
runner = new ConsoleSpammingMockitoJUnitRunner ( DummyTest . class ) ;
public Object answer ( InvocationOnMock invocation ) throws Throwable { return invocation . callRealMethod () ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultAnswer ( CALLS_REAL_METHODS ) )
catch ( Throwable t ) { throw t ; }
this . firstTraceElement = filter . filter ( stackTrace , NUMBER_CONSTANT ) [ NUMBER_CONSTANT ] ;
StackTraceElement [] filtered = filter . filter ( throwable . getStackTrace () , true ) ;
this . firstTraceElement = filter . filter ( stackTrace , false ) [ NUMBER_CONSTANT ] ;
StackTraceElement [] filtered = filter . filter ( new StackTraceElement [ NUMBER_CONSTANT ] , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
line = printer . getArgumentsLine ( ( List ) Arrays . asList ( new Equals ( NUMBER_CONSTANT ) , NotNull.NOT_NULL ) , PrintSettings . verboseMatchers () )
printer . getArgumentsBlock ( ( List ) Arrays . asList ( new Equals ( NUMBER_CONSTANT ) , new Equals ( NUMBER_CONSTANT ) ) , PrintSettings . verboseMatchers () )
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseSelfDescribing () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseSelfDescribing () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
Integer . . . toBePrintedVerbosely
public void setMatchersToBePrintedVerbosely ( Integer [] toBePrintedVerbosely ) { this . verboseMatchers = Arrays . asList ( toBePrintedVerbosely ) ; }
Integer . . . verboselyPrinted
{ withPrintSettings . add ( ( ( CanPrintArgumentVerbosely ) matcher ) . getSelfDescribingVerbosely () ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getSelfDescribingVerbosely () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getSelfDescribingVerbosely () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
SelfDescribing getSelfDescribingVerbosely ( ) ;
ContainsExtraTypeInformation equals = new Equals ( NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , describe ( m . withExtraTypeInfo () ) ) ;
try { verify ( withFinal ) ; fail () ; } catch ( UnfinishedVerificationException e ) {}
public BDDOngoingStubbingImpl ( OngoingStubbing < T > ongoingStubbing ) { this . mockitoOngoingStubbing = ongoingStubbing ; }
Field createInfoField = reflectOnCreateInfo ( methodProxy ) ;
{ return getInterceptor ( mock ) . getMockHandler () ; }
{ Mockito . argThat ( capturingMatcher ) ; return new HandyReturnValues () . returnFor ( clazz ) ; }
{ Mockito . argThat ( capturingMatcher ) ; return handyReturnValues . returnFor ( clazz ) ; }
ArgumentCaptor < String > captor = ArgumentCaptor . forClass ( String . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < String > argument = ArgumentCaptor . forClass ( String . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < Person > person = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < String > argument = ArgumentCaptor . forClass ( String . class ) ;
newMessage += STRING_CONSTANT + debuggingInfo . getWarnings () + STRING_CONSTANT ;
newMessage += STRING_CONSTANT + debuggingInfo . getWarnings ( false ) + STRING_CONSTANT ;
private String thisStubWasNotUsed ( Invocation i ) { return STRING_CONSTANT + i . getLocation () + STRING_CONSTANT ; }
{ this ( unusedStubs , unstubbedInvocations , false ) ; }
invocationMarker . markVerified ( actualInvocations , wanted ) ;
{ if ( wantedNumberOfInvocations < NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedCount = wantedNumberOfInvocations ; }
for ( T m : mocks ) { mockUtil . resetMock ( m ) ; }
private int hashCodeForMock ( Object mock ) { return System . identityHashCode ( mock ) ; }
{ return ( MockHandler ) getInterceptor ( mock ) . getMockHandler () ; }
if ( ObjectMethodsGuru . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
public static boolean isToString ( InvocationOnMock invocation ) { return ObjectMethodsGuru . isToString ( invocation . getMethod () ) ; }
objectMethodsGuru . isEqualsMethod ( method )
if ( objectMethodsGuru . isHashCodeMethod ( method ) ) { return hashCodeForMock ( proxy ) ; }
MethodInterceptorFilter newFilter = new MethodInterceptorFilter ( newMockHandler ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHandler ) ;
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
public static boolean isToString ( InvocationOnMock invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
marker . markVerified ( chunk . get ( NUMBER_CONSTANT ) , wantedMatcher ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( STRING_CONSTANT ) , capturingMatcher ) ) ;
{ try { return new ArgumentsComparator () . argumentsMatch ( this , actualArgs ) ; } catch ( Throwable t ) { return false ; } }
{ return methodProxy . getMethodProxy () . invokeSuper ( target , arguments ) ; }
public CGLIBProxyRealMethod ( MockitoMethodProxy methodProxy ) { this . methodProxy = methodProxy ; }
public FilteredCGLIBProxyRealMethod ( MockitoMethodProxy methodProxy ) { this ( new CGLIBProxyRealMethod ( methodProxy ) ) ; }
proxy . setCallbacks ( new Callback [] { interceptor , SerializableNoOp.SERIALIZABLE_INSTANCE } ) ;
{ return methodProxy . invokeSuper ( target , arguments ) ; }
MockitoMethod method
Any mock = mock ( Any . class , withSettings () . serializable () ) ;
public MockitoMethod getMethod () { return invocation . getMethod () ; }
MockitoMethod getMethod ( ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHandler , settings ) ;
Invocation i = new Invocation ( mock , new SerializableMockitoMethod ( method ) , args , sequenceNumber , null ) ;
{ new ObjectOutputStream ( new ByteArrayOutputStream () ) . writeObject ( new MethodInterceptorFilter ( null , null ) ) ; }
assertFalse ( new MockitoMethod ( testBaseToStringMethod ) . equals ( mockMethod ) ) ;
mockMethod = new MockitoMethod ( toStringMethod ) ;
public Class < > getReturnType () { return returnType ; }
MockitoMethod mockitoMethod = new MockitoMethod ( method ) ;
Invocation i = new Invocation ( mock , new MockitoMethod ( method ) , args , sequenceNumber , null ) ;
assertFalse ( new SerializableMethod ( testBaseToStringMethod ) . equals ( mockMethod ) ) ;
mockMethod = new SerializableMethod ( toStringMethod ) ;
SerializableMethod method
public SerializableMethod getMethod () { return invocation . getMethod () ; }
SerializableMethod getMethod ( ) ;
Invocation i = new Invocation ( mock , new SerializableMethod ( method ) , args , sequenceNumber , null ) ;
{ if ( invocation . isDeclaredOnInterface () ) { reporter . cannotCallRealMethodOnInterface () ; } }
public Method getMethod () { return invocation . getMethod () ; }
Method getMethod ( ) ;
{ if ( isDeclaredOnInterface () ) { new Reporter () . cannotCallRealMethodOnInterface () ; } return realMethod . invoke ( mock , rawArguments ) ; }
MockitoMethod method
{ if ( isPrimitiveWrapper ( clazz ) ) { return primitiveWrapperOf ( clazz ) ; } return primitiveValueOrNullFor ( clazz ) ; }
public MethodProxy getMethodProxy () { return methodProxy ; }
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
List < Invocation > allInvocations = ongoingStubbing . getRegisteredInvocations () ;
{ mockitoStubber . getRegisteredInvocations () . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing < T > ( mockitoStubber ) ; }
{ mockitoStubber . getRegisteredInvocations () . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing < T > ( mockitoStubber ) ; }
OngoingStubbingImpl < T > ongoingStubbing = new OngoingStubbingImpl < T > ( mockitoStubber ) ;
public void addAnswer ( Answer answer ) { registeredInvocations . removeLast () ; addAnswer ( answer , false ) ; }
public MockHandler ( MockHandler < T > oldMockHandler ) { this ( oldMockHandler.mockingProgress , oldMockHandler.matchersBinder , oldMockHandler.mockSettings ) ; }
return handler . handle ( invocation ) ;
{ return ( MockHandler ) getInterceptor ( mock ) . getHandler () ; }
MethodInterceptorFilter filter = new MethodInterceptorFilter ( handler , ( MockSettingsImpl ) withSettings () ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( handler , ( MockSettingsImpl ) withSettings () ) ;
Mockito . verify ( handler , never () ) . handle ( any ( Invocation . class ) ) ;
Mockito . verify ( handler , never () ) . handle ( any ( Invocation . class ) ) ;
{ mockingProgress . validateState () ; mockingProgress . resetOngoingStubbing () ; return mockUtil . createMock ( classToMock , ( MockSettingsImpl ) mockSettings ) ; }
public MockName getMockName ( Object mock ) { return getMockHandler ( mock ) . getMockSettings () . getMockName () ; }
MockHandler () { this ( new MockSettingsImpl () ) ; }
{ invocationContainerImpl . addAnswerForVoidMethod ( answer ) ; return this ; }
public VoidMethodStubbable < T > toReturn () { invocationContainerImpl . addAnswerForVoidMethod ( new DoesNothing () ) ; return this ; }
{ invocationContainerImpl . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
{ try { invocationContainerImpl . addAnswer ( new ThrowsException ( null ) ) ; fail () ; } catch ( MockitoException e ) {} }
{ state . stubbingStarted () ; invocationContainerImpl . addAnswer ( new Returns ( STRING_CONSTANT ) ) ; state . validateState () ; }
{ invocationContainerImpl . addAnswer ( new ThrowsException ( new Exception () ) ) ; fail () ; }
@ SuppressWarnings ( STRING_CONSTANT ) public void setAnswersForStubbing ( List < Answer > answers ) { invocationContainerImpl . setAnswersForStubbing ( answers ) ; }
{ return new VoidMethodStubbableImpl < T > ( mock , invocationContainerImpl ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl . getInvocations () , null ) ; VerificationModeFactory . noMoreInteractions () . verify ( data ) ; }
this . invocationContainerImpl = new InvocationContainerImpl ( mockingProgress ) ;
{ invocationContainerImpl . addConsecutiveAnswer ( answer ) ; return this ; }
{ invocationContainerImpl . addConsecutiveAnswer ( answer ) ; return this ; }
if ( i . stubInfo () != null ) { System.out . println ( STRING_CONSTANT + i . stubInfo () . stubbedAt () ) ; }
String printInvocations ( Object . . . mocks ) ;
{ return MOCKITO_CORE . mock ( classToMock , mockSettings ) ; }
int varargs ( String . . . string ) ;
int varargs ( Object . . . object ) ;
List < Invocation > invocations = finder . find ( asList ( mockOne , mockOne , mockOne ) ) ;
List < Invocation > invocations = finder . find ( asList ( mockOne , mockTwo ) ) ;
List < Invocation > allInvocations = new AllInvocationsFinder () . find ( mocksToBeVerifiedInOrder ) ;
public void log ( Object what ) { System.out . print ( what . toString () ) ; }
public void stubbingCompleted ( Invocation invocation ) { stubbingInProgress = null ; }
void foundUnstubbed ( InvocationMatcher unstubbed ) ;
for ( InvocationMatcher i : allInvocations ) { findingsListener . foundUnstubbed ( i ) ; }
verify ( listener , only () ) . foundUnstubbed ( unstubbedInvocation ) ;
{ this ( new ConsoleMockitoLogger () , new RunnerFactory () . create ( klass ) ) ; }
@ Before public void cleanStackTraces () { super . makeStackTracesClean () ; }
public MockUtil ( MockCreationValidator creationValidator ) { this . creationValidator = creationValidator ; }
private boolean isEmpty ( String warnings ) { return warnings == null || STRING_CONSTANT . equals ( warnings ) ; }
SimpleTestCase test = new SimpleTestCase () ;
SimpleTestCase test = new SimpleTestCase () ;
@ Test ( expected = ArgumentsAreDifferent . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
if ( instance == null ) { throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
String log = NewMockito . debug () . printInvocations ( mock , mockTwo ) ;
String log = NewMockito . debug () . printInvocations ( mock , mockTwo ) ;
String log = NewMockito . debug () . printInvocations ( mock , mockTwo ) ;
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMocks @ Captor ArgumentCaptor captor ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMocks @ Mock List mock ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMocks @ Spy List mock ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMocks Object iAmNull = null ; } ) ; }
null != field . getAnnotation ( InjectMocks . class )
if ( field . isAnnotationPresent ( annotation ) ) { new Reporter () . unsupportedCombinationOfAnnotations ( annotation . getSimpleName () , InjectMocks . class . getSimpleName () ) ; }
field . isAnnotationPresent ( InjectMocks . class )
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
{ checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ; fail () ; }
{ checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ; }
return mockitoCore . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , this ) ) ;
if ( invocation . isVoid () ) { reporter . cannotStubVoidMethodWithAReturnValue ( invocation . getMethod () . getName () ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
{ try { Thread . sleep ( sleep ) ; } catch ( InterruptedException ie ) {} }
try { t . verify ( data ) ; fail () ; } catch ( MockitoAssertionError e ) {}
public InvocationMatcher getWanted () { return wanted ; }
public InOrderContext getOrderingContext () { return inOrder ; }
{ throw new MockitoException ( join ( STRING_CONSTANT + methodName + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnFor ( clazz ) ; }
Object instance = new FieldInitializer ( testClass , field ) . initialize () ;
{ throw new MockitoException ( STRING_CONSTANT + field . getType () . getSimpleName () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getType () . getSimpleName () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getType () . getSimpleName () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getType () . getSimpleName () + STRING_CONSTANT ) ; }
NestedClassWithNoArgConstructor ( String f ) {}
if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify ( mock . getClass () ) ; }
validateMostStuff () ;
new ObjectMethodsGuru () . isToString ( invocation . getMethod () )
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + formatMethodCall () + STRING_CONSTANT ; }
new Reporter () . smartNullPointerException ( invocation . toString () , location ) ;
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + invocation . toString () ; }
null != field . getAnnotation ( org.mockito.MockitoAnnotations.Mock . class )
final Object testClass
int index = filter . accept ( actualMethod , actualMethods ) ;
notifyAllInvocationListener ( invocation ) ;
MockHandler < > handler
{ given ( handler . getMockSettings () . getDefaultAnswer () ) . willReturn ( SOME_ANSWER ) ; stubOrdinaryInvocationWithInvocationMatcher ( handler , null ) ; }
doThrow ( SOME_EXCEPTION ) . when ( throwingListener )
{ return nextStrategy != null && nextStrategy . process ( field , fieldOwner , mockCandidates ) ; }
public OngoingMockInjection tryPropertyOrFieldInjection () { injectionStrategies . thenTry ( new PropertyAndSetterInjection () ) ; return this ; }
public OngoingMockInjection tryConstructorInjection () { injectionStrategies . thenTry ( new ConstructorInjection () ) ; return this ; }
{ assert wasAccessible != null : STRING_CONSTANT ; try { accessibleObject . setAccessible ( wasAccessible ) ; } catch ( Throwable t ) {} }
VerifiableInvocationsFinder finder = new VerifiableInvocationsFinder () ;
Foo foo = mock ( Foo . class , withSettings () . invocationListeners ( listener1 ) . invocationListeners ( listener2 ) ) ;
Foo foo = mock ( Foo . class , withSettings () . invocationListeners ( listener ) ) ;
Foo foo = mock ( Foo . class , withSettings () . invocationListeners ( listener1 ) . invocationListeners ( listener2 ) ) ;
Foo foo = mock ( Foo . class , withSettings () . invocationListeners ( listener ) ) ;
given ( handler . getMockSettings () . getInvocationListeners () ) . willReturn ( Arrays . asList ( listener ) ) ;
@ Test ( expected = MockitoException . class ) public void shouldThrowCorrectExceptionForNullInvocationListener ( ) throws Exception { new Reporter () . invocationListenerDoesNotAcceptNullParameters () ; }
{ for ( InvocationListener listener : mockSettings . getInvocationListeners () ) { notifyListenerOfInvocationWithException ( invocation , exception , listener ) ; } }
{ for ( InvocationListener listener : mockSettings . getInvocationListeners () ) { notifyListenerOfInvocationWithReturnValue ( invocation , returnValue , listener ) ; } }
{ assertFalse ( mockSettingsImpl . hasInvocationListeners () ) ; mockSettingsImpl . verboseLogging () ; assertContainsType ( mockSettingsImpl . getInvocationListeners () , VerboseMockInvocationLogger . class ) ; }
MethodInvocationReport mcr
public void invocationListenersRequiresAtLeastOneListener () { throw new MockitoException ( STRING_CONSTANT ) ; }
public void invocationListenerDoesNotAcceptNullParameters () { throw new MockitoException ( STRING_CONSTANT ) ; }
{ mockSettingsImpl . invocationListeners ( invocationListener , null ) ; fail () ; }
{ mockSettingsImpl . invocationListeners () ; fail () ; }
{ notifier . handle ( invocation ) ; fail () ; }
{ notifier . handle ( invocation ) ; fail () ; }
{ mapOngoingStubbing . thenReturn ( STRING_CONSTANT ) ; fail () ; }
{ super ( new URL [] { obtainClassPath () , obtainClassPath ( STRING_CONSTANT ) } , parentClassLoader ) ; this . reloadClassPredicate = reloadClassPredicate ; }
{ super ( new URL [] { obtainClassPath () , obtainClassPath ( STRING_CONSTANT ) } ) ; this . reloadClassPredicate = reloadClassPredicate ; }
return report . fieldWasInitializedUsingContructorArgs () ;
mocks . addAll ( scanAndPrepareMocks ( testClassInstance , clazz ) ) ;
@ Test public void inject_mocks_even_in_declared_spy ( ) throws Exception { assertNotNull ( spiedReceiver.oldAntenna ) ; assertNotNull ( spiedReceiver.tuner ) ; }
new InjectMocksScanner ( clazz ) . addTo ( mockDependentFields ) ;
String canThrowException ( ) throws CharacterCodingException ;
{ return ( MockHandlerInterface ) mockMaker . getHandler ( mock ) ; }
MockSettingsInfo settings
MockSettingsInfo mockSettings
MockSettingsInfo settings
MockSettingsInfo settings
public void setTheField ( final File theField ) { theFieldSetterWasUsed = true ; this . theField = theField ; }
Class configClass ;
private void misplaced_anyBoolean_argument_matcher () { anyBoolean () ; }
private void misplaced_anyInt_argument_matcher () { anyInt () ; }
private void misplaced_anyObject_argument_matcher () { anyObject () ; }
List < LocalizedMatcher > pullLocalizedMatchers ( ) ;
Set < Object > mocks = newMockSafeHashSet () ;
Set < Object > mocks = newMockSafeHashSet () ;
{ this . delegatedInstance = delegatedInstance ; return defaultAnswer ( new ForwardsInvocations ( this . delegatedInstance ) ) ; }
public int getSequenceNumber () { return sequenceNumber ; }
int expectedMatchersSize = invocation . getArguments () . length ;
if ( this . getMethod () . getDeclaringClass () . isInterface () ) { new Reporter () . cannotCallRealMethodOnInterface () ; }
List matchers = Invocation . argumentsToMatchers ( i . getArguments () ) ;
public String toString () { return new PrintSettings () . print ( matchers , invocation ) ; }
{ this . matchers = Invocation . argumentsToMatchers ( invocation . getArguments () ) ; }
List matchers = ArgumentsProcessor . argumentsToMatchers ( i . getArguments () ) ;
{ this . matchers = ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) ; }
public String print ( Invocation invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
public String toString () { return new PrintSettings () . print ( ArgumentsProcessor . argumentsToMatchers ( getArguments () ) , this ) ; }
this . arguments = ArgumentsProcessor . expandVarArgs ( mockitoMethod . isVarArgs () , args ) ;
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl lastActualLocation
LocationImpl lastLocation = finder . getLastLocation ( actualInvocations ) ;
{ LocationImpl location = verificationMode . getLocation () ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; }
if ( stubbingInProgress != null ) { LocationImpl temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; }
LocationImpl last = finder . getLastLocation ( invocations ) ;
LocationImpl lastLocation = null ;
LocationImpl actualLocation
{ this . actualMatcher = actualMatcher ; this . location = new LocationImpl () ; }
String loc = new LocationImpl ( filterReturningEmptyArray ) . toString () ;
LocationImpl actualLocation
throw new NoInteractionsWanted ( join ( STRING_CONSTANT , new LocationImpl () , STRING_CONSTANT , undesired . getLocation () , scenario ) ) ;
LocationImpl lastActualLocation
LocationImpl lastActualLocation
LocationImpl firstUndesired
LocationImpl firstUndesired
join ( STRING_CONSTANT , STRING_CONSTANT , wanted . toString () , new LocationImpl () , STRING_CONSTANT , previous . toString () , previous . getLocation () , STRING_CONSTANT )
new LocationImpl ()
LocationImpl location
LocationImpl location
public LocationImpl getLocation () { return invocation . getLocation () ; }
public Localized ( T object ) { this . object = object ; location = new LocationImpl () ; }
LocationImpl lastLocation = finder . getLastLocation ( chunk ) ;
this . location = new LocationImpl () ;
{ s . markStubUsed ( invocation ) ; invocation . markStubbed ( new StubInfoImpl ( s ) ) ; return s ; }
{ out += line ( STRING_CONSTANT + i . stubInfo () . stubbedAt () . toString () ) ; }
invocation . markStubbed ( new StubInfoImpl ( stubbedInvocation ) ) ;
isMultiline () || ( ! matchers . isEmpty () && invocationString . length () > MAX_LINE_LENGTH )
InvocationImpl invocation
Object answerTo ( InvocationImpl invocation ) throws Throwable { return findAnswerFor ( invocation ) . answer ( invocation ) ; }
InvocationImpl invocation = invocationForStubbing . getInvocation () ;
InvocationImpl nullDereference
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl actual
InvocationImpl actual
InvocationImpl invocation
InvocationImpl actual
InvocationImpl compareTo = this . getLastInvocation () ;
List < InvocationImpl > allInvocations
InvocationImpl previous = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
assertNull ( finder . getLastLocation ( Collections . < InvocationImpl > emptyList () ) ) ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
List < InvocationImpl > unusedStubs
InvocationImpl invocation
InvocationImpl invocation
List < InvocationImpl > getAllInvocations ( ) ;
InvocationImpl invocation
public boolean isOut ( InvocationImpl invocation ) { return ! orderingContext . isVerified ( invocation ) ; }
public boolean isOut ( InvocationImpl invocation ) { return ! wanted . matches ( invocation ) ; }
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl actualInvocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
List < InvocationImpl > getInvocations ( ) ;
public void stubbingCompleted ( InvocationImpl invocation ) { threadSafely () . stubbingCompleted ( invocation ) ; }
WarningsFinder finder = new WarningsFinder ( Arrays . < InvocationImpl > asList () , Arrays . < InvocationMatcher > asList ( unstubbedInvocation ) ) ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
given ( handler.invocationContainerImpl . findAnswerFor ( any ( InvocationImpl . class ) ) ) . willReturn ( value ) ;
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocationOnClass = getLastInvocation () ;
InvocationImpl previous = new InvocationBuilder () . toInvocation () ;
InvocationImpl actual = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocationOnInterface = new InvocationBuilder () . toInvocation () ;
public void foundUnusedStub ( InvocationImpl unused ) { logger . log ( STRING_CONSTANT + unused . getLocation () + STRING_CONSTANT ) ; }
InvocationImpl unused
InvocationImpl undesired
InvocationImpl undesired
List < InvocationImpl > unusedStubs
List < InvocationImpl > unusedStubs
InvocationImpl i
InvocationImpl candidate
InvocationImpl candidate
InvocationImpl actual
public InvocationImpl getInvocation () { return this . invocation ; }
public InvocationMatcher ( InvocationImpl invocation ) { this ( invocation , Collections . < Matcher > emptyList () ) ; }
InvocationImpl invocation
public void markVerified ( InvocationImpl i ) { verified . add ( i ) ; }
public boolean isVerified ( InvocationImpl invocation ) { return verified . contains ( invocation ) ; }
public void markVerified ( InvocationImpl i ) { inOrderContext . markVerified ( i ) ; }
public boolean isVerified ( InvocationImpl i ) { return inOrderContext . isVerified ( i ) ; }
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation
public ExposedInvocation ( InvocationImpl toBeExposed ) { methodProxy = ( ( HasCGLIBMethodProxy ) toBeExposed.realMethod ) . getMethodProxy () ; }
public String print ( InvocationImpl invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
InvocationImpl invocation
Mockito . verify ( handler , never () ) . handle ( any ( InvocationImpl . class ) ) ;
Mockito . verify ( handler , never () ) . handle ( any ( InvocationImpl . class ) ) ;
public boolean isOut ( InvocationImpl invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
public void add ( InvocationImpl invocation ) { invocations . add ( invocation ) ; }
List < InvocationImpl > getAllInvocations ( ) ;
InvocationImpl invocation
Invocation theInvocation
public MethodInfo ( Invocation theInvocation ) { this . method = theInvocation . getMethod () ; }
Invocation invocation = invocationForStubbing . getInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation actual
Invocation actual
Invocation actual
Invocation compareTo = this . getLastInvocation () ;
List < Invocation > allInvocations
Invocation previous = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
List < Invocation > unusedStubs
Invocation invocation
Invocation invocation
List < Invocation > getAllInvocations ( ) ;
List < Invocation > chunk
Invocation invocation
public boolean isOut ( Invocation invocation ) { return ! orderingContext . isVerified ( invocation ) ; }
public boolean isOut ( Invocation invocation ) { return ! wanted . matches ( invocation ) ; }
List < Invocation > invocations
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation actualInvocation = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
List < Invocation > getInvocations ( ) ;
public void stubbingCompleted ( Invocation invocation ) { threadSafely () . stubbingCompleted ( invocation ) ; }
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
{ public InvocationMatcher bindMatchers ( ArgumentMatcherStorage argumentMatcherStorage , Invocation invocation ) { throw new InvalidUseOfMatchersException () ; } }
Invocation invocation
Invocation invocationOnClass = getLastInvocation () ;
Invocation actual = new InvocationBuilder () . toInvocation () ;
Invocation invocationOnInterface = new InvocationBuilder () . toInvocation () ;
public void foundUnusedStub ( Invocation unused ) { logger . log ( STRING_CONSTANT + unused . getLocation () + STRING_CONSTANT ) ; }
Invocation unused
Invocation undesired
Invocation undesired
List < Invocation > unusedStubs
List < Invocation > unusedStubs
Invocation i
Invocation candidate
Invocation candidate
Invocation actual
public Invocation getInvocation () { return this . invocation ; }
public InvocationMatcher ( Invocation invocation ) { this ( invocation , Collections . < Matcher > emptyList () ) ; }
Invocation invocation
public void markVerified ( Invocation i ) { verified . add ( i ) ; }
public boolean isVerified ( Invocation invocation ) { return verified . contains ( invocation ) ; }
public void markVerified ( Invocation i ) { inOrderContext . markVerified ( i ) ; }
public boolean isVerified ( Invocation i ) { return inOrderContext . isVerified ( i ) ; }
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation
public String print ( Invocation invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
Invocation invocation
public boolean isOut ( Invocation invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
public void add ( Invocation invocation ) { invocations . add ( invocation ) ; }
List < Invocation > getAllInvocations ( ) ;
Location firstUndesired
Location firstUndesired
Location lastActualLocation
Location lastLocation = finder . getLastLocation ( actualInvocations ) ;
{ Location location = verificationMode . getLocation () ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; }
if ( stubbingInProgress != null ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; }
Location last = finder . getLastLocation ( invocations ) ;
Location lastLocation = null ;
Location actualLocation
Location actualLocation
Location location
Location lastActualLocation
Location lastActualLocation
Location lastActualInvocation
Location firstUndesired
Location firstUndesired
Location firstUndesired
Location firstUndesired
Location actualLocation
Location location
Location location
public Location getLocation () { return invocation . getLocation () ; }
Location lastLocation = finder . getLastLocation ( chunk ) ;
Invocation invocation
Object answerTo ( Invocation invocation ) throws Throwable { return findAnswerFor ( invocation ) . answer ( invocation ) ; }
Invocation nullDereference
Invocation invocation
for ( Invocation i : unusedStubs ) { findingsListener . foundUnusedStub ( i ) ; }
{ markVerified ( chunk , wanted ) ; for ( Invocation i : chunk ) { context . markVerified ( i ) ; } }
Invocation invocation
Invocation invocation
Invocation invocation
Invocation invocation
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation
Invocation invocation
Invocation previous = new InvocationBuilder () . toInvocation () ;
Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
Invocation invocation
assertNull ( finder . getLastLocation ( Collections . < Invocation > emptyList () ) ) ;
WarningsFinder finder = new WarningsFinder ( Arrays . < Invocation > asList ( stub ) , Arrays . < InvocationMatcher > asList ( wrongArg ) ) ;
WarningsFinder finder = new WarningsFinder ( Arrays . < Invocation > asList () , Arrays . < InvocationMatcher > asList ( unstubbedInvocation ) ) ;
return new LinkedList < Invocation > ( invocationsInOrder ) ;
synchronized ( invocations ) { copiedList = new LinkedList < Invocation > ( invocations ) ; }
org.mockito.internal.reporting.Discrepancy discrepancy
org.mockito.internal.reporting.Discrepancy discrepancy
org.mockito.internal.reporting.Discrepancy discrepancy
org.mockito.internal.reporting.Discrepancy discrepancy
{ new Reporter () . tooLittleActualInvocations ( new org.mockito.internal.reporting.Discrepancy ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new InvocationBuilder () . toInvocation () , null ) ; }
STRING_CONSTANT + pluralize ( wantedCount ) + STRING_CONSTANT
DescribedInvocation invocation
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
public void markStubUsed ( DescribedInvocation usedAt ) { this . usedAt = usedAt ; }
@ Override public void wantedButNotInvoked ( DescribedInvocation wanted ) { this . wanted = wanted ; }
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
public void wantedButNotInvoked ( DescribedInvocation wanted ) { throw new WantedButNotInvoked ( createWantedButNotInvokedMessage ( wanted ) ) ; }
public StubInfoImpl ( DescribedInvocation stubbedAt ) { this . stubbedAt = stubbedAt ; }
{ return new DefaultMockingDetails ( toInspect , new MockUtil () ) ; }
Invocation invocationOnClass = new MockitoCore () . getLastInvocation () ;
InvocationImplTest . class
Mock annotation
new ReturnsArgumentAt ( NUMBER_CONSTANT )
{ validator . validate ( new ReturnsArgumentAt ( ReturnsArgumentAt.LAST_ARGUMENT ) , new InvocationBuilder () . simpleMethod () . toInvocation () ) ; fail () ; }
validator . validate ( new ReturnsArgumentAt ( NUMBER_CONSTANT ) , new InvocationBuilder () . method ( STRING_CONSTANT ) . arg ( STRING_CONSTANT ) . toInvocation () ) ;
{ return ( Answer < T > ) new ReturnsArgumentAt ( position ) ; }
{ ( ( Factory ) mock ) . setCallback ( NUMBER_CONSTANT , new MethodInterceptorFilter ( cast ( newHandler ) , settings ) ) ; }
MockHandlerInterface handler
InvocationNotifierHandler oldHandler = ( InvocationNotifierHandler ) getMockHandler ( mock ) ;
if ( isMockOrSpy ( instance ) ) { mockUtil . maybeRedefineMockName ( instance , field . getName () ) ; return instance ; }
Collection < Class > extraInterfaces
Set < Class > extraInterfaces
Set < Class > extraInterfaces
mockUtil . maybeRedefineMockName ( mock , STRING_CONSTANT ) ;
mockUtil . maybeRedefineMockName ( mock , STRING_CONSTANT ) ;
public void validateExtraInterfaces ( Class classToMock , Collection < Class > interfaces ) { extraInterfacesValidated = true ; }
T mock = mockUtil . createMock ( classToMock , mockSettings ) ;
public MockSettingsInfo getMockSettings () { return mockHandler . getMockSettings () ; }
MockSettingsInfo settings
@ SuppressWarnings ( STRING_CONSTANT ) MockHandler < > handler = new MockHandler ( new MockSettingsImpl () ) ;
MockSettingsInfo settings = oldHandler . getMockSettings () ;
MockSettingsInfo mockSettings
name . isDefault ()
{ if ( getMockName ( mock ) . isDefault () ) { getMockHandler ( mock ) . getMockSettings () . redefineMockName ( newName ) ; } }
{ this . mockName = toInstanceName ( classToMock ) ; this . defaultName = true ; }
IMethods methods = mock ( IMethods . class , delegatesTo ( new MethodsImpl () ) ) ;
List < String > mockedList = mock ( List . class , delegatesTo ( delegatedList ) ) ;
List < String > mock = mock ( List . class , delegatesTo ( delegatedList ) ) ;
List < String > mock = mock ( List . class , delegatesTo ( delegatedList ) ) ;
MockCreationSettings settings
MockCreationSettings settings
MockCreationSettings mockSettings
public MockCreationSettings getMockSettings () { return mockHandler . getMockSettings () ; }
MockCreationSettings settings
MockCreationSettings settings = oldHandler . getMockSettings () ;
MockCreationSettings mockSettings
mockingProgress . mockingStarted ( mock , typeToMock ) ;
{ mockingProgress . setListener ( null ) ; mockingProgress . mockingStarted ( null , null ) ; }
MockHandlerImplTest . class
MockHandlerImpl < T > mockHandler
newHandler = new InvocationNotifierHandler < T > ( new MockHandlerImpl < T > ( settings ) , settings )
InternalMockHandler mockitoHandler = cast ( handler ) ;
InternalMockHandler handler
MockHandler newHandler
MockHandler handler
MockHandler newHandler
given ( iMethods . varargsObject ( eq ( NUMBER_CONSTANT ) , anyVararg () ) ) . will ( returnsArgAt ( NUMBER_CONSTANT ) ) ;
InternalMockHandler < T > mockHandler
{ return Primitives . primitiveValueOrNullFor ( type ) ; }
result = NUMBER_CONSTANT * result + ( clazz != null ? clazz . hashCode () : NUMBER_CONSTANT ) ;
registerTypeParametersOn ( clazz . getTypeParameters () ) ;
< O extends K > O typeVar_with_type_params ( ) ;
< S , T extends S > T two_type_params ( ) ;
List < ? super Integer > returning_wildcard_with_class_lower_bound ( ) ;
return typeVariable . equals ( ( ( TypeVarBoundedType ) o ) . typeVariable ) ;
public MockSettings parameterizedInfo ( GenericMetadataSupport mockitoGenericMetadata ) { this . mockitoGenericMetadata = mockitoGenericMetadata ; return this ; }
GenericMetadataSupport returnTypeGenericMetadata
public void setMockitoGenericMetadata ( GenericMetadataSupport mockitoGenericMetadata ) { this . mockitoGenericMetadata = mockitoGenericMetadata ; }
{ VerificationDataImpl data = createVerificationData ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
this . invocationContainerImpl = new InvocationContainerImpl ( mockingProgress , mockSettings ) ;
RegisteredInvocationsAllTest . class
{ return mockSettings . isStubOnly () ? new RegisteredInvocationsStubOnly () : new DefaultRegisteredInvocations () ; }
DefaultRegisteredInvocationsTest . class
{ return mockSettings . isStubOnly () ? new SingleRegisteredInvocation () : new DefaultRegisteredInvocations () ; }
catch ( CannotVerifyStubOnlyMock e ) {}
@ After public void yes_I_know_some_matchers_are_misplaced () { resetState () ; }
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingOnPurposeBecauseWrongStubbingSyntaxInConfigurationMethod . class ) ;
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingOnPurposeBecauseIncorrectStubbingSyntax . class ) ;
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingOnPurposeBecauseIncorrectAnnotationUsage . class ) ;
GenericMetadataSupport genericMetadata = inferFrom ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = inferFrom ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = inferFrom ( StringBuilder . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , StringBuilder . class ) ) ;
GenericMetadataSupport genericMetadata = inferFrom ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = inferFrom ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
{ if ( mockitoGenericMetadata == null ) { this . mockitoGenericMetadata = GenericMetadataSupport . inferFrom ( typeToMock ) ; } return mockitoGenericMetadata ; }
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
return recordDeepStubMock ( createNewDeepStubMock ( returnTypeGenericMetadata ) , container ) ;
static MockMaker findPlatformMockMaker () { return findPluginImplementation ( MockMaker . class , DEFAULT_MOCK_MAKER_CLASS ) ; }
{ if ( ! mockUtil . isTypeMockable ( classToMock ) ) { new Reporter () . cannotMockFinalClass ( classToMock ) ; } }
{ return mockitoCore . mock ( returnTypeGenericMetadata . rawType () , withSettingsUsing ( returnTypeGenericMetadata ) ) ; }
if ( ! mockitoCore . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; }
if ( ! mockitoCore . isTypeMockable ( clazz ) ) { return null ; }
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + pluginType , e ) ; }
SerializableAndNoDefaultConstructor ( Observable o ) { super(); }
MockCreationSettings mockSettings = new MockUtil () . getMockSettings ( mockitoMock ) ;
public boolean isSpy ( Object mock ) { return mock instanceof MockitoSpy ; }
{ if ( mockUtil . isMock ( cl ) ) { return STRING_CONSTANT ; } else { return STRING_CONSTANT ; } }
{ return ! MOCKITO_PROXY_MARKER . equals ( marker ) ; }
public boolean isMock ( Object mock ) { return mock instanceof MockitoMock && isMockitoMock ( mock ) ; }
public boolean isSpy ( Object mock ) { return mock instanceof MockitoSpy ; }
public boolean isMock ( Object mock ) { return mock instanceof MockitoMock && isMockitoMock ( mock ) ; }
catch ( ObjectStreamException e ) { Assertions . assertThat ( e . toString () ) . contains ( STRING_CONSTANT ) ; }
{ SimpleSerializationUtil . serializeAndBack ( mockWithPrivateConstructor ) ; fail ( STRING_CONSTANT ) ; }
this . serializableMode = copy.serializableMode ;
AClassToBeMockedInThisTestOnlyAndInCallablesOnly mock = Mockito . mock ( AClassToBeMockedInThisTestOnlyAndInCallablesOnly . class , Mockito . withSettings () . serializable ( SerializableMode.ACROSS_CLASSLOADERS ) ) ;
{ if ( AcrossJVMMockitoMockSerializable . class . isAssignableFrom ( cl ) ) { return MOCKITO_PROXY_MARKER ; } else { return NOTHING ; } }
public boolean isMock ( Object mock ) { return isMockitoMock ( mock ) ; }
verify ( mock , timeout ( NUMBER_CONSTANT ) . atLeast ( NUMBER_CONSTANT ) ) . clear () ;
public VerificationMode never () { new Reporter () . atMostAndNeverShouldNotBeUsedWithTimeout () ; return null ; }
{ new Reporter () . atMostAndNeverShouldNotBeUsedWithTimeout () ; return null ; }
verify ( target , timeout ( TEST_TIMEOUT_MILLIS * NUMBER_CONSTANT ) . times ( TIMES * nThreads ) ) . targetMethod ( STRING_CONSTANT ) ;
public int getPollingPeriod () { return pollingPeriod ; }
{ return new After ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDelay () , verificationMode ) ; }
assertEquals ( expectedTimeout , ( ( Timeout ) t ) . wrappedVerification . getDuration () ) ;
{ return new Timeout ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDuration () , newVerificationMode ) ; }
{ super ( new VerificationOverTimeImpl ( pollingPeriod , millis , delegate , true ) ) ; }
{ return new After ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDuration () , verificationMode ) ; }
{ super ( new VerificationOverTimeImpl ( pollingPeriod , delayMillis , verificationMode , false ) ) ; }
{ if ( canRecoverFromFailure ( delegate ) ) { error = e ; sleep ( pollingPeriodMillis ) ; } else { throw e ; } }
ClassLoader cl = isolatedClassLoader () . withCurrentCodeSourceUrls () . withPrivateCopyOf ( CLASS_NAME_USING_INTERFACE ) . withPrivateCopyOf ( INTERFACE_NAME ) . build () ;
{ cl . loadClass ( STRING_CONSTANT ) ; fail () ; }
{ cl . loadClass ( CLASS_NAME_USING_INTERFACE ) ; fail () ; }
{ cl . loadClass ( CLASS_NAME_USING_INTERFACE ) ; fail () ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = new SerializableTypeVariable ( typeVariable ) ; }
{ Type actualType = getActualTypeArgumentFor ( typeParameter ) ; actualTypeArguments . put ( new SerializableTypeVariable ( typeParameter ) , actualType ) ; }
return new SerializableBoundedType ( wildCardBoundedType ) ;
return new SerializableBoundedType ( new TypeVarBoundedType ( typeParameter ) ) ;
{ for ( TypeVariable typeParameter : typeParameters ) { contextualActualTypeParameters . put ( new SerializableTypeVariable ( typeParameter ) , boundsOf ( typeParameter ) ) ; } }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = typeVariable ; }
{ Type actualType = getActualTypeArgumentFor ( typeParameter ) ; actualTypeArguments . put ( typeParameter , actualType ) ; }
return wildCardBoundedType ;
return new TypeVarBoundedType ( typeParameter ) ;
{ return mockitoCore () . mock ( returnTypeGenericMetadata . rawType () , withSettingsUsing ( returnTypeGenericMetadata ) ) ; }
private ReturnsDeepStubs returnsDeepStubsAnswerUsing ( final GenericMetadataSupport returnTypeGenericMetadata ) { return new ReturnsDeepStubsSerializationFallback ( returnTypeGenericMetadata ) ; }
return deepStub ( invocation , returnTypeGenericMetadata ) ;
{ return Mockito . verify ( mock , mode ) ; }
public T should () { return Mockito . verify ( mock ) ; }
{ return verify ( mock , mode ) ; }
public T should () { return verify ( mock ) ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnFalse () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . < T > returnNull () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . < T > returnNull () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnFalse () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . < T > returnNull () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnFalse () ; }
T
if ( ! CLEANER . isOut ( unfilteredStackTrace . get ( i ) ) ) { continue; }
{ return ( T ) PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES . get ( primitiveOrWrapperType ) ; }
{ return PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES . containsKey ( type ) ; }
{ if ( clazz . isPrimitive () ) { return clazz ; } return ( Class < T > ) PRIMITIVE_TYPES . get ( clazz ) ; }
{ if ( ! isEquals ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }
{ if ( ! isEquals ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }
if ( ! isEquals ) { return this ; }
long millis
long millis
long delayMillis
public long getDuration () { return durationMillis ; }
public long getPollingPeriod () { return pollingPeriodMillis ; }
long sleep
{ verifyNoMoreInteractions ( ( Object [] ) null ) ; }
{ inOrder ( ( Object [] ) null ) ; }
{ verifyNoMoreInteractions ( ( Object [] ) null ) ; }
String expectedCause = STRING_CONSTANT + STRING_CONSTANT + mock + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
String expectedCause = STRING_CONSTANT + STRING_CONSTANT + mock + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
@ Override public int hashCode () { return method . hashCode () ; }
timer . isUp ( startTime )
this . timer = new Timer ( durationMillis ) ;
when ( timer . isCounting () ) . thenReturn ( true , true , true , true , true , false ) ;
public void reset () { mockingProgress . reset () ; mockingProgress . resetOngoingStubbing () ; }
when ( clazzMock . isValid () ) . thenReturn ( true ) ;
catch ( CannotStubVoidMethodWithReturnValue e ) { Assertions . assertThat ( e . getMessage () ) . contains ( MockitoLimitations.NON_PUBLIC_PARENT ) ; }
{ return type == null ? STRING_CONSTANT : STRING_CONSTANT + type . getCanonicalName () + STRING_CONSTANT + type . getClassLoader () + STRING_CONSTANT ; }
ClassImposterizer imposterizer = new ClassImposterizer ( new CachingObjenesisInstantiator () ) ;
return new ClassImposterizer ( new CachingObjenesisInstantiator () ) . imposterise ( new MethodInterceptorFilter ( mockitoHandler , settings ) , settings . getTypeToMock () , settings . getExtraInterfaces () ) ;
imposterizer = new ClassImposterizer ( new ConstructorInstantiator () ) ;
Factory proxy = instantiator . newInstance ( proxyClass ) ;
STRING_CONSTANT + instantiator . getClass () . getSimpleName ()
ClassImposterizer imposterizer = new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () ) ;
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
new DefaultClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
DefaultClassImposterizerTest . class
new CglibClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
CglibClassImposterizerTest . class
ClassImposterizerTest . class
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
new CGLIBHacker () . setMockitoNamingPolicy ( methodProxy ) ;
{ return getMethodProxy () . invokeSuper ( target , arguments ) ; }
CleanTraceRealMethod realMethod = new CleanTraceRealMethod ( mockitoMethodProxy ) ;
{ sourceJarComparator . setPair ( left , right ) ; }
boolean jars = binaryComparator . areEqual () ;
mock = mock ( List . class , delegatesTo ( new FakeListWithWrongMethods < String > () ) )
mock = mock ( List . class , delegatesTo ( new FakeListWithWrongMethods < String > () ) )
mock = mock ( List . class , delegatesTo ( new FakeList < String > () ) )
mock = mock ( List . class , delegatesTo ( new FakeList < String > () ) )
mock = mock ( List . class , delegatesTo ( new FakeList < String > () ) )
{ return new ArrayList < T > () ; }
{ return new ArrayList < T > () ; }
ZipComparator.Result result = zipComparator . compareFiles () ;
{ zipComparator . setPair ( left , right ) ; }
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator ( settings ) )
ClassImposterizer imposterizer = new ClassImposterizer ( new InstantiatorProvider () . getInstantiator ( new CreationSettings () ) ) ;
{ if ( settings . isUsingConstructor () ) { return new ConstructorInstantiator ( settings . getOuterClassInstance () ) ; } else { return INSTANCE ; } }
imposterizer = new ClassImposterizer ( new ConstructorInstantiator ( null ) ) ;
catch ( InstantationException e ) { assertEquals ( STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
public String toString () { return commits . size () + STRING_CONSTANT + author ; }
{ authorId = commit . getAuthorId () ; author = commit . getAuthor () ; commits . add ( commit ) ; }
public String getAuthorId () { return email ; }
Commit commit
Commit commit
{ return new GitContributionsProvider ( new GitLogProvider ( runner ) ) ; }
{ return new GitContributionsProvider ( new GitLogProvider ( runner ) , new IgnoreCiSkip () ) ; }
DefaultContributionSet contributions = new DefaultContributionSet ( ignoredCommit ) ;
if ( ignoreCommit . isTrue ( commit ) ) { return; }
Map.Entry < String , Contribution > entry
if ( ! m . matches () ) { throw new ReleaseNotesException ( STRING_CONSTANT + releaseNotesContent , null ) ; }
if ( out == null ) { throw new ReleaseNotesException ( STRING_CONSTANT + envVariableName + STRING_CONSTANT , null ) ; }
long id
public GitHubImprovementsProvider ( String authToken ) { this . authToken = authToken ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return Answers.CALLS_REAL_METHODS . get () . answer ( invocation ) ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return Answers.RETURNS_DEFAULTS . get () . answer ( invocation ) ; }
String content = IOUtil . readFully ( response ) ;
catch ( NoSuchMethodException noDefaultConstructor ) { throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + type . getSimpleName () + STRING_CONSTANT ) ; }
{ return new ThenImpl < T > ( mock ) ; }
try { closeable . close () ; } catch ( IOException e ) { throw new MockitoException ( STRING_CONSTANT + closeable , e ) ; }
catch ( IOException e ) { throw new MockitoException ( STRING_CONSTANT + reader , e ) ; }
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + output , e ) ; }
assertEquals ( asList ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , IOUtil . readLines ( new FileInputStream ( file ) ) ) ;
if ( ! pluginSwitch . isEnabled ( pluginClassName ) ) { continue; }
String foundPluginClass = new PluginFinder ( pluginSwitch ) . findPluginClass ( Iterables . toIterable ( resources ) ) ;
LinkedList < ReleaseStep > targets = new LinkedList < ReleaseStep > ( attempted ) ;
{ jUnitRule . apply ( new ExceptionStatement () , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
{ injectTestCase = new InjectTestCase () ; jUnitRule = new JUnitRule () ; }
mockSettings . defaultAnswer ( annotation . answer () ) ;
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return RETURNS_DEFAULTS . answer ( invocation ) ; }
ReleaseStep getStep ( int stepNumber ) ;
return new DefaultGitAuthor ( currentLocalUser , currentLocalEmail , runner ) ;
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
{ return anyObject () ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnFor ( clazz ) ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnNull () ; }
public static VersionTool getVersionTool () { return new DefaultVersionTool ( new VersionBumper () ) ; }
long millis
public ClassLoader build () { return new InMemoryClassLoader ( parent , inMemoryClassObjects ) ; }
catch ( AssertionError e ) { error = handleVerifyException ( e ) ; }
if ( paramsMatch ( types , params ) ) { return invokeConstructor ( constructor , params ) ; }
catch ( InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + proxyClass . getSuperclass () . getSimpleName () + STRING_CONSTANT , e ) ; }
int result = mockedType . hashCode () ;
if ( ! mockedType . equals ( mockKey.mockedType ) ) return false ;
Class < T > mockedType
{ return ( Class < ? extends T > ) PREVIOUS_CLASSES . get ( mockKey ) ; }
@ Origin ( cacheMethod = true ) Method method
@ Origin ( cacheMethod = true ) Method method
@ Origin ( cacheMethod = true ) Method method
Class < > proxyClass = new ByteBuddyMockMaker () . getOrMakeMock ( typeToMock , extraInterfaces ) ;
{ return ( Class < ? extends T > ) PREVIOUSLY_GENERATED_MOCK_CLASSES . get ( mockKey ) ; }
PREVIOUSLY_GENERATED_MOCK_CLASSES . put ( mockKey , mockType ) ;
T mock = classInstantiator . instantiate ( mockedType ) ;
if ( ! ( handler instanceof InternalMockHandler ) ) { throw new MockitoException ( join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
Class < > proxyClass = new CachingBytecodeGenerator () . get ( typeToMock , extraInterfaces ) ;
Class < > proxyClass = new CachingMockBytecodeGenerator () . get ( typeToMock , extraInterfaces ) ;
assertThat ( cache ) . hasSize ( NUMBER_CONSTANT ) ;
assertThat ( cachingMockBytecodeGenerator.avoidingClassLeakageCache ) . hasSize ( NUMBER_CONSTANT ) ;
byteBuddy . subclass ( mockedType , ConstructorStrategy.Default.IMITATE_SUPER_TYPE ) . name ( nameFor ( mockedType ) )
{ return thiz . getMockitoInterceptor () . getSerializationSupport () . writeReplace ( thiz ) ; }
{ this . handler = handler ; this . mockCreationSettings = mockCreationSettings ; serializationSupport = new ByteBuddyCrossClassLoaderSerializationSupport () ; }
CachingMockBytecodeGeneratorTest . class
Collections . sort ( unsortedFields , cmp ) ;
Collections . sort ( unsortedFields , cmp ) ;
sortSuperTypesLast ( declaredFields ) ;
PropertyAndSetterInjection . sortSuperTypesLast ( unsortedFields ) ;
ArrayList < Improvement > pagedImprovements = new ArrayList < Improvement > () ;
STRING_CONSTANT + mockMethod + STRING_CONSTANT + safelyGetMockName ( mock )
STRING_CONSTANT + mockMethod + STRING_CONSTANT + safelyGetMockName ( mock )
STRING_CONSTANT + safelyGetMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT
STRING_CONSTANT + safelyGetMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT
@ Before public void setup () { mock = Mockito . mock ( IMethods . class , STRING_CONSTANT ) ; }
try { validator . validate ( new CallsRealMethods () , invocationOnInterface ) ; fail () ; } catch ( MockitoException expected ) {}
catch ( MockitoException expected ) {}
{ return new Timeout ( wrappedVerification . copyWithVerificationMode ( newVerificationMode ) ) ; }
{ this ( new VerificationOverTimeImpl ( pollingPeriodMillis , millis , delegate , true ) ) ; }
{ return new After ( wrappedVerification . copyWithVerificationMode ( verificationMode ) ) ; }
{ try { Thread . sleep ( sleep ) ; } catch ( InterruptedException ie ) { throw new RuntimeException ( STRING_CONSTANT , ie ) ; } }
{ this ( pollingPeriodMillis , delegate , returnOnSuccess , new Timer ( durationMillis ) ) ; }
@ Origin ( cache = true ) Method invokedMethod
@ Origin ( cache = true ) Method invokedMethod
@ Origin ( cache = true ) Method invokedMethod
ArrayList < Improvement > pagedImprovements = new ArrayList < Improvement > () ;
try { argument . getValue () ; fail () ; } catch ( MockitoException e ) { Assert . assertTrue ( true ) ; }
Mockito . verify ( c.invocationMarker ) . markVerified ( eq ( asList ( invocation ) ) , any ( CapturesArgumentsFromInvocation . class ) ) ;
CapturesArgumentsFromInvocation wanted
CapturesArgumentsFromInvocation wanted
CapturesArgumentsFromInvocation wanted
{ injectionOccurred |= injectMockCandidates ( fieldClass , fieldInstanceNeedingInjection , newMockSafeHashSet ( mockCandidates ) ) ; fieldClass = fieldClass . getSuperclass () ; }
if ( interceptor == null ) { return superCall . call () ; }
{ ( ( MockAccess ) mock ) . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( newHandler ) , settings ) ) ; }
MockAccess mockAccess = ( MockAccess ) mockInstance ;
{ return new MatchersPrinter () . print ( m ) . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( describe ( m ) , m . getTypedDescription () ) ; }
ContainsTypedDescription equals10 = new Equals ( NUMBER_CONSTANT ) ;
{ return HamcrestPrinter . print ( m ) . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
{ ContainsTypedDescription equals = new Equals ( NUMBER_CONSTANT ) ; assertFalse ( equals . typeMatches ( null ) ) ; }
{ ContainsTypedDescription equals = new Equals ( null ) ; assertFalse ( equals . typeMatches ( NUMBER_CONSTANT ) ) ; }
ContainsTypedDescription equals = new Equals ( NUMBER_CONSTANT ) ;
{ String descStr = new Equals ( NUMBER_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
Set < Class < > > interfaces
Set < Class < > > interfaces
Class < > classToMock
Class < > classToMock
Class < > classToMock
Class < > classToMock
Set < Class < > > extraInterfaces
Set < Class < > > interfaces
Set < Class < > > interfaces
the_mock_type = cachingMockBytecodeGenerator . get ( withMockFeatures ( classloader_with_life_shorter_than_cache . loadClass ( STRING_CONSTANT ) , Collections . < Class < > > emptySet () , false ) )
Set < Class < > > extraInterfaces
{ byteBuddy = new ByteBuddy () . withDefaultMethodAttributeAppender ( MethodAttributeAppender.ForInstrumentedMethod.INSTANCE ) . withAttribute ( TypeAttributeAppender.ForSuperType.INSTANCE ) ; random = new Random () ; }
private static HandyReturnValues reportMatcher ( MockitoMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
{ for ( MockitoMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < MockitoMatcher > matchers ) { this . matchers = matchers ; }
InvocationMatcher invocationWithMatchers = new InvocationMatcher ( invocation , ( List < MockitoMatcher > ) ( List ) lastMatchers ) ;
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( m . describe () , m . getTypedDescription () ) ; }
public Not ( MockitoMatcher first ) { this . first = first ; }
MockitoMatcher m
assertEquals ( name + STRING_CONSTANT , compareTo . describe () ) ;
{ for ( MockitoMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < MockitoMatcher > matchers ) { this . matchers = matchers ; }
if ( actualMatcher instanceof ContainsTypedDescription ) { return ( ( ContainsTypedDescription ) actualMatcher ) . getTypedDescription () ; } else { return actualMatcher . describe () ; }
MockitoMatcher actualMatcher
MockitoMatcher matcher
private static HandyReturnValues reportMatcher ( MockitoMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
MockitoMatcher < Double > matcher
MockitoMatcher < Float > matcher
MockitoMatcher < Long > matcher
MockitoMatcher < Integer > matcher
MockitoMatcher < Short > matcher
MockitoMatcher < Byte > matcher
MockitoMatcher < Boolean > matcher
MockitoMatcher < Character > matcher
MockitoMatcher m
MockitoMatcher m = matchers . get ( position ) ;
List < MockitoMatcher > matchers
{ String descStr = new Equals ( null ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( CHAR_CONS ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
List < MockitoMatcher > matchers
@ Test public void matchesToString () { assertEquals ( STRING_CONSTANT , new Matches ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void findToString () { assertEquals ( STRING_CONSTANT , new Find ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void containsToString () { assertEquals ( STRING_CONSTANT , new Contains ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void endsWithToString () { assertEquals ( STRING_CONSTANT , new EndsWith ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void startsWithToString () { assertEquals ( STRING_CONSTANT , new StartsWith ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void notToString () { assertEquals ( STRING_CONSTANT , new Not ( new Equals ( NUMBER_CONSTANT ) ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new Equals ( o ) . describe () ) ;
@ Test public void equalsToStringWithChar () { assertEquals ( STRING_CONSTANT , new Equals ( CHAR_CONS ) . describe () ) ; }
@ Test public void equalsToStringWithString () { assertEquals ( STRING_CONSTANT , new Equals ( STRING_CONSTANT ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new Same ( o ) . describe () ) ;
@ Test public void sameToStringWithChar () { assertEquals ( STRING_CONSTANT , new Same ( CHAR_CONS ) . describe () ) ; }
@ Test public void sameToStringWithString () { assertEquals ( STRING_CONSTANT , new Same ( STRING_CONSTANT ) . describe () ) ; }
{ return reportMatcher ( new Find ( regex ) ) . returnNull () ; }
public String toString () { return STRING_CONSTANT ; }
public String toString () { return STRING_CONSTANT ; }
public String toString () { return STRING_CONSTANT ; }
public String toString () { return STRING_CONSTANT ; }
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( m . toString () , m . toStringWithType () ) ; }
ContainsExtraTypeInfo equals10 = new Equals ( NUMBER_CONSTANT ) ;
{ return m . toString () . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
assertEquals ( name + STRING_CONSTANT , compareTo . toString () ) ;
Equals matcherWithBadDescription = new Equals ( NUMBER_CONSTANT ) { public String toString () { return STRING_CONSTANT ; } } ;
out . append ( new Equals ( array [ i ] ) . toString () ) ;
public String toString () { return STRING_CONSTANT ; }
{ ContainsExtraTypeInfo equals = new Equals ( NUMBER_CONSTANT ) ; assertFalse ( equals . typeMatches ( null ) ) ; }
{ ContainsExtraTypeInfo equals = new Equals ( null ) ; assertFalse ( equals . typeMatches ( NUMBER_CONSTANT ) ) ; }
ContainsExtraTypeInfo equals = new Equals ( NUMBER_CONSTANT ) ;
{ String descStr = new Equals ( null ) . toString () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . toString () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( CHAR_CONS ) . toString () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . toString () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . toStringWithType () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . toStringWithType () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . toStringWithType () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
public String toString () { return STRING_CONSTANT ; }
@ Test public void matchesToString () { assertEquals ( STRING_CONSTANT , new Matches ( STRING_CONSTANT ) . toString () ) ; }
@ Test public void findToString () { assertEquals ( STRING_CONSTANT , new Find ( STRING_CONSTANT ) . toString () ) ; }
@ Test public void containsToString () { assertEquals ( STRING_CONSTANT , new Contains ( STRING_CONSTANT ) . toString () ) ; }
@ Test public void endsWithToString () { assertEquals ( STRING_CONSTANT , new EndsWith ( STRING_CONSTANT ) . toString () ) ; }
@ Test public void startsWithToString () { assertEquals ( STRING_CONSTANT , new StartsWith ( STRING_CONSTANT ) . toString () ) ; }
assertEquals ( STRING_CONSTANT , new And ( matchers ) . toString () ) ;
@ Test public void notToString () { assertEquals ( STRING_CONSTANT , new Not ( new Equals ( NUMBER_CONSTANT ) ) . toString () ) ; }
assertEquals ( STRING_CONSTANT , new Or ( matchers ) . toString () ) ;
assertEquals ( STRING_CONSTANT , new Equals ( o ) . toString () ) ;
@ Test public void equalsToStringWithChar () { assertEquals ( STRING_CONSTANT , new Equals ( CHAR_CONS ) . toString () ) ; }
@ Test public void equalsToStringWithString () { assertEquals ( STRING_CONSTANT , new Equals ( STRING_CONSTANT ) . toString () ) ; }
assertEquals ( STRING_CONSTANT , new Same ( o ) . toString () ) ;
@ Test public void sameToStringWithChar () { assertEquals ( STRING_CONSTANT , new Same ( CHAR_CONS ) . toString () ) ; }
@ Test public void sameToStringWithString () { assertEquals ( STRING_CONSTANT , new Same ( STRING_CONSTANT ) . toString () ) ; }
public String toString () { return describe ( wanted ) ; }
{ out . add ( new FormattedText ( MatcherToString . toString ( matcher ) ) ) ; }
ArgumentMatcher matcher
private static HandyReturnValues reportMatcher ( ArgumentMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
{ for ( ArgumentMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , Arrays . < ArgumentMatcher > asList ( new Equals ( NUMBER_CONSTANT ) , m ) ) ;
List < ArgumentMatcher > matchers
List < ArgumentMatcher > matchers
public Not ( ArgumentMatcher first ) { this . first = first ; }
ArgumentMatcher m
ArgumentMatcher m
{ for ( ArgumentMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
ArgumentMatcher matcher
ArgumentMatcher matcher
private static HandyReturnValues reportMatcher ( ArgumentMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
ArgumentMatcher < Double > matcher
ArgumentMatcher < Float > matcher
ArgumentMatcher < Long > matcher
ArgumentMatcher < Integer > matcher
ArgumentMatcher < Short > matcher
ArgumentMatcher < Byte > matcher
ArgumentMatcher < Boolean > matcher
ArgumentMatcher < Character > matcher
ArgumentMatcher m
ArgumentMatcher m = matchers . get ( position ) ;
List < ArgumentMatcher > matchers
List < ArgumentMatcher > matchers
@ After public void reset_state () { super . resetState () ; }
Assertions . assertThat ( returnedMock ) . isEqualTo ( expectedMock ) ;
Assertions . assertThat ( dog . bark () ) . isEqualTo ( STRING_CONSTANT ) ;
Assertions . assertThat ( dog . bark () ) . isEqualTo ( STRING_CONSTANT ) ;
if ( throwables == null ) { return thenThrow ( ( Throwable ) null ) ; }
public ThrowsExceptionClass ( Class < ? extends Throwable > throwableClass ) { this . throwableClass = checkNonNullThrowable ( throwableClass ) ; }
{ return MOCKITO_CORE . stubber () . doReturn ( toBeReturned ) ; }
{ return MOCKITO_CORE . stubber () . doNothing () ; }
{ return MOCKITO_CORE . stubber () . doAnswer ( answer ) ; }
{ return MOCKITO_CORE . stubber () . doCallRealMethod () ; }
verify ( mock ) . simpleMethod ( ( Object ) anyObject () ) ;
when ( mock . oneArg ( ( Object ) anyObject () ) ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . oneArg ( ( Object ) anyObject () ) ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . oneArg ( ( Object ) any () ) ) . thenReturn ( STRING_CONSTANT ) ;
Instantiator instantiator = Plugins . getInstantiatorProvider () . getInstantiator ( settings ) ;
byteBuddy = new ByteBuddy () . withDefaultMethodAttributeAppender ( new MethodAttributeAppender.ForInstrumentedMethod ( AnnotationAppender.ValueFilter.AppendDefaults.INSTANCE ) ) . withAttribute ( new TypeAttributeAppender.ForInstrumentedType ( AnnotationAppender.ValueFilter.AppendDefaults.INSTANCE ) ) ;
for ( AllTestsRunner t : threads ) { t . join () ; failed |= t . isFailed () ; }
{ pomComparator = new PomComparator ( left , right ) ; }
ContributionsProvider contributionsProvider = Vcs . getGitProvider ( Exec.INSTANCE . getProcessRunner ( workDir ) ) ;
ContributionsProvider contributionsProvider = Vcs . getGitProvider ( Exec . getProcessRunner ( workDir ) ) ;
public MockBytecodeGenerator () { byteBuddy = new ByteBuddy () . with ( TypeValidation.DISABLED ) ; random = new Random () ; }
runner . addListener ( new TextListener ( DevNull.out ) ) ;
{ return invocation . getMock () == invocation . getArgument ( NUMBER_CONSTANT ) ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
{ return invocation . getArgument ( NUMBER_CONSTANT ) ; }
{ return invocation . getArgument ( NUMBER_CONSTANT ) ; }
{ return invocation . getArgument ( NUMBER_CONSTANT ) ; }
String arg = invocation . getArgument ( NUMBER_CONSTANT ) ;
ImportLogBean bean = invocation . getArgument ( NUMBER_CONSTANT ) ;
{ validateIndexWithinInvocationRange ( invocation ) ; return invocation . getArgument ( actualArgumentPosition ( invocation ) ) ; }
int secondArgument = invocationOnInterface . getArgument ( NUMBER_CONSTANT ) ;
{ ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgument ( position ) ) ; }
runner = new MockitoJUnitRunner ( DummyTest . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
{ try { AdditionalAnswers . returnsElementsOf ( null ) ; fail () ; } catch ( MockitoException e ) {} }
{ this . jUnitRule = new JUnitRule ( new ConsoleMockitoLogger () ) ; }
{ assertEquals ( STRING_CONSTANT , e . getMessage () ) ; assertTrue ( logger . getLoggedInfo () . contains ( STRING_CONSTANT ) ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , listener . getStubbingInfo () ) ;
{ ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgument ( position ) ) ; }
{ return CoreMatchers . isA ( ( Class ) type ) ; }
assertTrue ( runner instanceof JUnit45AndHigherRunnerImpl ) ;
assertTrue ( runner instanceof JUnit44RunnerImpl ) ;
assertTrue ( mock instanceof List ) ;
assertThat ( result ) . isSuccessful () ;
{ return new RunnerProvider () . newInstance ( STRING_CONSTANT , klass ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { filterRequested = true ; runner . filter ( filter ) ; }
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
{ return CoreMatchers . is ( ( Class ) type ) ; }
doThrow ( new RuntimeException () ) . when ( mock ) . clone () ;
doThrow ( new RuntimeException () ) . when ( mock ) . clone () ;
doThrow ( expected ) . when ( mock ) . clear () ;
{ return new JUnitRule ( new ConsoleMockitoLogger () ) ; }
doAnswer ( recordCall ) . when ( mock ) . voidMethod () ;
{ jUnitRule . apply ( new UnfinishedStubbingStatement () , null , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
{ jUnitRule . apply ( new ExceptionStatement () , null , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
jUnitRule . apply ( new DummyStatement () , null , injectTestCase ) . evaluate () ;
public void reportOngoingStubbing ( OngoingStubbing iOngoingStubbing ) { threadSafely () . reportOngoingStubbing ( iOngoingStubbing ) ; }
verify ( methods ) . simpleMethod () ;
{ IMethods methods = mock ( IMethods . class ) ; verify ( methods ) . simpleMethod () ; }
VerificationCollectorImpl () { this . resetBuilder () ; }
setField ( testClass , field , newFieldInstance ) ;
setField ( testClass , field , newFieldInstance ) ;
InternalMockHandler handler = createMockHandler ( settings ) ;
InternalMockHandler handler = createMockHandler ( settings ) ;
if ( ! new BeanPropertySetter ( injectee , candidateFieldToBeInjected ) . set ( matchingMock ) ) { setField ( injectee , candidateFieldToBeInjected , matchingMock ) ; }
setField ( descInstance , classNameField , proxyClass . getCanonicalName () ) ;
{ setField ( instance , field , value ) ; }
MockHandler newHandler = createMockHandler ( settings ) ;
MockHandler mockHandler = createMockHandler ( settings ) ;
{ setField ( testInstance , field , mock ) ; }
{ setField ( testClass , field , mock ) ; }
catch ( Throwable listenerThrowable ) { throw invocationListenerThrewException ( listener , listenerThrowable ) ; }
catch ( Throwable listenerThrowable ) { throw invocationListenerThrewException ( listener , listenerThrowable ) ; }
{ if ( method . isAbstract () ) { throw cannotCallAbstractRealMethod () ; } return realMethod . invoke ( mock , rawArguments ) ; }
if ( expectedMatchersSize != recordedMatchersSize ) { throw invalidUseOfMatchers ( expectedMatchersSize , lastMatchers ) ; }
public NonGreedyNumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () , new InvocationMarker () ) ; }
if ( ! invocationContainerImpl . hasInvocationForPotentialStubbing () ) { throw incorrectUseOfApi () ; }
public NumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () ) ; }
catch ( RuntimeException e ) { throw cannotInjectDependency ( candidateFieldToBeInjected , matchingMock , e ) ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . invocationListenerDoesNotAcceptNullParameters () ; }
{ if ( usingConstructor && mode == SerializableMode.ACROSS_CLASSLOADERS ) { throw usingConstructorWithFancySerializable ( mode ) ; } }
if ( delegatedInstance . getClass () . isAssignableFrom ( classToMock ) ) { throw mockedTypeIsInconsistentWithDelegatedInstanceType ( classToMock , delegatedInstance ) ; }
if ( ! classToMock . equals ( spiedInstance . getClass () ) ) { throw mockedTypeIsInconsistentWithSpiedInstanceType ( classToMock , spiedInstance ) ; }
for ( Class i : extraInterfaces ) { if ( classToMock == i ) { throw extraInterfacesCannotContainMockedType ( classToMock ) ; } }
if ( throwableClass == null || ! Throwable . class . isAssignableFrom ( throwableClass ) ) { throw notAnException () ; }
{ if ( mockSettings . isStubOnly () ) { throw stubPassedToVerify () ; } return new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; }
{ this . defaultAnswer = defaultAnswer ; if ( defaultAnswer == null ) { throw defaultAnswerDoesNotAcceptNullParameter () ; } return this ; }
if ( o . isToString ( wanted . getMethod () ) ) { throw cannotVerifyToString () ; }
{ if ( argumentPosition != LAST_ARGUMENT && argumentPosition < NUMBER_CONSTANT ) { throw invalidArgumentRangeAtIdentityAnswerCreationTime () ; } return argumentPosition ; }
if ( unverified != null ) { throw noMoreInteractionsWantedInOrder ( unverified ) ; }
{ if ( ! methodInfo . isVoid () ) { throw onlyVoidMethodsCanBeSetToDoNothing () ; } }
{ if ( methodInfo . isAbstract () ) { throw cannotCallAbstractRealMethod () ; } }
public MissingInvocationChecker () { this ( new InvocationsFinder () ) ; }
{ if ( ! superMethod . isInvokable () ) { throw cannotCallAbstractRealMethod () ; } return superMethod . invoke () ; }
{ if ( alreadyAssigned ) { throw moreThanOneAnnotationNotAllowed ( field . getName () ) ; } }
if ( foundSize > maxNumberOfInvocations ) { throw wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; }
{ if ( alreadyAssigned ) { throw moreThanOneAnnotationNotAllowed ( field . getName () ) ; } }
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { throw mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
if ( stubbing == null ) { mockingProgress . reset () ; throw missingMethodInvocation () ; }
for ( StackTraceElement element : target ) { if ( CLEANER . isOut ( element ) ) { filtered . add ( element ) ; } }
{ assertThat ( cleaner . isOut ( type ( className ) ) ) . describedAs ( STRING_CONSTANT , className ) . isFalse () ; }
{ assertThat ( cleaner . isOut ( type ( className ) ) ) . describedAs ( STRING_CONSTANT , className ) . isTrue () ; }
markVerified ( actualInvocations , wanted ) ;
markVerified ( next , wanted ) ;
public NonGreedyNumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () ) ; }
markVerifiedInOrder ( chunk , wanted , context ) ;
markVerified ( chunk . get ( NUMBER_CONSTANT ) , wantedMatcher ) ;
markVerified ( actualInvocations , wanted ) ;
markVerifiedInOrder ( chunk , wanted , orderingContext ) ;
markVerified ( found , wanted ) ;
{ Mockito . argThat ( capturingMatcher ) ; return defaultValue ( clazz ) ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return false ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ return Primitives . defaultValue ( type ) ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return false ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return null ; }
{ reportMatcher ( new StartsWith ( prefix ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new EndsWith ( suffix ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new Matches ( regex ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new Contains ( substring ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( NotNull.NOT_NULL ) ; return null ; }
{ reportMatcher ( NotNull.NOT_NULL ) ; return null ; }
{ reportMatcher ( Null.NULL ) ; return null ; }
{ reportMatcher ( Null.NULL ) ; return null ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return false ; }
{ reportMatcher ( AnyVararg.ANY_VARARG ) ; return null ; }
{ reportMatcher ( Any.ANY ) ; return null ; }
assertThat ( new ThreadSafeMockingProgress () . pullOngoingStubbing () ) . isNull () ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return false ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return false ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return false ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new Find ( regex ) ) ; return null ; }
void reportMatcher ( ArgumentMatcher matcher ) ;
{ if ( ENABLED && candidate . getMethodName () . contains ( STRING_CONSTANT ) ) { return true ; } return defaultCleaner . isOut ( candidate ) ; }
new ArgumentMatcher < String > () { public boolean matches ( String argument ) { return true ; } }
String argument
T argument
public void setAnswersForStubbing ( List < Answer < > > answers ) { answersForStubbing . addAll ( answers ) ; }
public void setAnswersForStubbing ( List < Answer < > > answers ) { mockHandler . setAnswersForStubbing ( answers ) ; }
MockCreationSettings < > settings
Long longPretendingAnInt = NUMBER_CONSTANT ;
Class < > clazz
verify ( mock ) . simpleMethod ( anyObject () ) ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( new HamcrestArgumentMatcher < T > ( matcher ) ) ; }
Map < , > map () { return null ; }
LinkedList < > linkedList () { return null ; }
List < > list () { return null ; }
public InOrderImpl ( List < ? extends Object > mocksToBeVerifiedInOrder ) { this . mocksToBeVerifiedInOrder . addAll ( mocksToBeVerifiedInOrder ) ; }
int compareTo ( HasCompare redHerring ) ;
int foo ( HasCompare other ) ;
int compareTo ( HasCompareToButDoesNotImplementComparable other ) ;
public NullResultGuardian ( InternalMockHandler < T > delegate ) { this . delegate = delegate ; }
assertFalse ( mockUtil . isSpy ( null ) ) ;
List < Answer < > > answers
assertEquals ( NUMBER_CONSTANT , captor . getValue () ) ;
assertNotNull ( readObject ) ;
void setAnswersForStubbing ( List < Answer < > > answers ) ;
catch ( Exception e ) { throw new IllegalStateException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + pluginType , e ) ; }
public ArgumentMatcher < > getMatcher () { return matcher ; }
ArgumentMatcher < > matcher
void mockingStarted ( Object mock , Class < > classToMock ) ;
createdMocks = new LinkedList < Object > () ;
Class < > classToMock
void mockingStarted ( Object mock , Class < > classToMock ) ;
OngoingStubbing < > pullOngoingStubbing ( ) ;
void reportOngoingStubbing ( OngoingStubbing < > ongoingStubbing ) ;
void reportMatcher ( ArgumentMatcher < > matcher ) ;
int secondArgument = ( Integer ) invocationOnInterface . getArgument ( NUMBER_CONSTANT ) ;
public void mockingStarted ( Object mock , Class < > classToMock ) { toBeFilled . add ( mock ) ; }
public CollectCreatedMocks ( List < Object > toBeFilled ) { this . toBeFilled = toBeFilled ; }
Class < > classToMock
public void reportOngoingStubbing ( OngoingStubbing < > iOngoingStubbing ) { threadSafely () . reportOngoingStubbing ( iOngoingStubbing ) ; }
{ copy ( from , to , from . getClass () ) ; }
Class < > lhsClass = lhs . getClass () ;
Class < > reflectUpToClass
Class < > expected
Iterable < > lines
Class < > actualType
Class < > typeToMock
Class < > type
Class < > [] argTypes
for ( Class < > anInterface : interfaces ) { types . add ( anInterface . getName () ) ; }
Class < > classToMock
Class < > mockedType
Class < > type
for ( Class < > i : extraInterfaces ) { if ( classToMock == i ) { throw extraInterfacesCannotContainMockedType ( classToMock ) ; } }
new SerializableMethod ( type . getMethod ( methodName , new Class < > [ NUMBER_CONSTANT ] ) )
{ mock ( IMethods . class , withSettings () . extraInterfaces ( ( Class < > [] ) null ) ) ; }
Class < > currentExploredClass = clazz
{ mock . oneArg ( ( char ) ( CHAR_CONS + i ) ) ; }
Answer < > answer
Answer < > answer
public BDDStubber will ( Answer < > answer ) { return new BDDStubberImpl ( mockitoStubber . doAnswer ( answer ) ) ; }
public BDDStubber willAnswer ( Answer < > answer ) { return new BDDStubberImpl ( mockitoStubber . doAnswer ( answer ) ) ; }
Answer < > answer
Answer < > answer
return matchers ;
Class < > . . . extraInterfaces
HoldingAReference ( WeakReference < Class < > > a ) { this . a = a ; }
Invocation next = findFirstMatchingUnverifiedInvocation ( invocations , wanted , context ) ;
List < Invocation > chunk = InvocationsFinder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = InvocationsFinder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = InvocationsFinder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
Invocation found = InvocationsFinder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedDifferentMethod ) ) ;
Invocation found = InvocationsFinder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedSimpleMethod ) ) ;
Invocation unverified = findFirstUnverifiedInOrder ( data . getOrderingContext () , invocations ) ;
Invocation unverified = findFirstUnverified ( data . getAllInvocations () ) ;
verify ( ( Iterable < String > ) iterable ) . iterator () ;
Assert . assertNotNull ( ( ( Iterable < String > ) iterable ) . iterator () ) ;
public int size ( Collection < > collection ) { return collection . size () ; }
public int size ( Map < , > map ) { return map . size () ; }
ConstructorInjection.SimpleArgumentResolver resolver = new ConstructorInjection.SimpleArgumentResolver ( newSetOf ( new HashSet < Float > () , new ByteArrayOutputStream () ) ) ;
notifier . setAnswersForStubbing ( new ArrayList < Answer < > > () ) ;
public Set < > getHistogram2 () { return histogram2 ; }
public Set < > getHistogram1 () { return histogram1 ; }
public TreeSet < > getSearchTree () { return searchTree ; }
public List < > getAList () { return aList ; }
FailingConstructor ( Set < > set ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
public some_class_with_parametered_constructor ( List < > collaborator ) { constructor_instantiation ++ ; }
public ByteBuddyMockMaker () { cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator ( false ) ; }
public GreaterOrEqual ( T value ) { super ( value ) ; }
public CompareTo ( T value ) { this . wanted = value ; }
UnmockableHashCodeAndEquals mock = mock1 ;
public GreaterThan ( T value ) { super ( value ) ; }
public LessOrEqual ( T value ) { super ( value ) ; }
public CompareEqual ( T value ) { super ( value ) ; }
T value
T value
T value
T value
T value
public LessThan ( T value ) { super ( value ) ; }
Transformer.ForMethod . withModifiers ( SynchronizationState.PLAIN )
Method getJavaMethod ( ) ;
Class < > [] getExceptionTypes ( ) ;
Class < > [] getParameterTypes ( ) ;
Class < > getReturnType ( ) ;
String getName ( ) ;
Object writeReplace ( ) ;
{ return false ; }
@ Before public void initialize_dependencies () { underTest = new ConstructorInjection () ; }
VerificationMode only ( ) ;
VerificationMode atLeastOnce ( ) ;
VerificationMode never ( ) ;
mockingProgress () . stubbingCompleted ( invocation ) ;
{ mockingProgress () . getArgumentMatcherStorage () . reportMatcher ( new HamcrestArgumentMatcher < T > ( matcher ) ) ; }
mockingProgress () . setVerificationStrategy ( MockingProgressImpl . getDefaultVerificationStrategy () ) ;
{ mockingProgress () . setVerificationStrategy ( MockingProgressImpl . getDefaultVerificationStrategy () ) ; }
assertThat ( mockingProgress () . pullOngoingStubbing () ) . isNull () ;
MockingProgress p = mockingProgress () ;
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return false ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return null ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return null ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return false ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return null ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return false ; }
InvocationContainerImpl invocations = new InvocationContainerImpl ( new MockSettingsImpl () ) ;
mockingProgress () . validateState () ;
mockingProgress () . validateState () ;
mockingProgress () . mockingStarted ( mock , typeToMock ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( null ) , ANY ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( NUMBER_CONSTANT ) , ANY ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( NUMBER_CONSTANT ) , ANY ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( ANY ) ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
public void filter ( Filter filter ) throws NoTestsRemainException { runner . filter ( filter ) ; }
FailureDetecter listener = new FailureDetecter () ;
assertThat ( result ) . isSuccessful () ;
{ return new RunnerProvider () . newInstance ( STRING_CONSTANT , klass ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { filterRequested = true ; runner . filter ( filter ) ; }
notifier . fireTestFailure ( new Failure ( unnecessaryStubbings , Reporter . formatUnncessaryStubbingException ( testClass , stubbings . values () ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
public void filter ( Filter filter ) throws NoTestsRemainException { runner . filter ( filter ) ; }
FailureDetecter listener = new FailureDetecter () ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
{ try { return argumentsMatch ( this , actualArgs ) ; } catch ( Throwable t ) { return false ; } }
return invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && argumentsMatch ( this , actual ) ;
! hasTestMethods ( klass )
MockCreationSettings < T > settings
MockCreationSettings < T > mockSettings
{ reportMatcher ( new InstanceOf ( Collection . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Map . class ) ) ; return new HashMap ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Set . class ) ) ; return new HashSet ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( List . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
Assertions . assertThat ( chunk ) . containsSequence ( simpleMethodInvocation , simpleMethodInvocationTwo , simpleMethodInvocationThree ) ;
Assertions . assertThat ( chunk ) . containsSequence ( simpleMethodInvocation , simpleMethodInvocationTwo , simpleMethodInvocationThree ) ;
Assertions . assertThat ( chunk ) . containsSequence ( simpleMethodInvocation , simpleMethodInvocationTwo ) ;
Assertions . assertThat ( filtered ) . containsSequence ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
Assertions . assertThat ( t ) . has ( onlyThoseClassesInStackTrace ( STRING_CONSTANT ) ) ;
Assertions . assertThat ( t ) . has ( onlyThoseClassesInStackTrace ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
JUnitResultAssert . assertThat ( result ) . isSuccessful () ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , UnfinishedStubbingException . class ) ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , TooLittleActualInvocations . class ) ;
{ Result result = runner . run ( SomeFeature . class ) ; JUnitResultAssert . assertThat ( result ) . isSuccessful () ; }
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT ) ) ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , MyAssertionError . class ) ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , UnnecessaryStubbingException . class ) ;
JUnitResultAssert . assertThat ( result ) . isSuccessful () ;
Assertions . assertThat ( timer . isCounting () ) . isFalse () ;
Assertions . assertThat ( timer . isCounting () ) . isTrue () ;
catch ( RuntimeException e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { Assertions . assertThat ( expected ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { Assertions . assertThat ( expected ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { Assertions . assertThat ( expected ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { Assertions . assertThat ( expected ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
{ reportMatcher ( new InstanceOf ( Iterable . class , STRING_CONSTANT ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Collection . class , STRING_CONSTANT ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Map . class , STRING_CONSTANT ) ) ; return new HashMap ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Set . class , STRING_CONSTANT ) ) ; return new HashSet ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( List . class , STRING_CONSTANT ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( String . class , STRING_CONSTANT ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Short . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Double . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Float . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Long . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Integer . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Character . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Byte . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Boolean . class , STRING_CONSTANT ) ) ; return false ; }
void save ( Person capture ) ;
MyIterator < T > iterator ( ) ;
Integer getValue ( Integer param ) ;
Object otherMethod ( Object param ) ;
Object someMethod ( Object param ) ;
String targetMethod ( String arg ) ;
public void setSpy ( List < > spy ) { this . spy = spy ; }
public List < > getList () { return list ; }
assertThat ( log ) . containsIgnoringCase ( STRING_CONSTANT ) ;
catch ( NeverWantedButInvoked e ) { assertThat ( e . getMessage () ) . doesNotContain ( STRING_CONSTANT ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e . getMessage () ) . doesNotContain ( STRING_CONSTANT ) ; }
assertThat ( mockTwo . toString () ) . contains ( STRING_CONSTANT ) ;
assertThat ( mockTwo . toString () ) . contains ( STRING_CONSTANT ) ;
assertThat ( mockTwo . toString () ) . contains ( STRING_CONSTANT ) ;
catch ( NeverWantedButInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( InstantiationException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT + STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( SmartNullPointerException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
assertThat ( out ) . contains ( STRING_CONSTANT ) ;
catch ( NoInteractionsWanted e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
assertThat ( name ) . contains ( STRING_CONSTANT ) ;
assertThat ( name ) . contains ( STRING_CONSTANT ) ;
assertThat ( name ) . contains ( STRING_CONSTANT ) ;
catch ( InvalidUseOfMatchersException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( NeverWantedButInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( AssertionError e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
{ String expected = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; assertThat ( e ) . hasMessageContaining ( expected ) ; }
catch ( UnfinishedVerificationException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
{ assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; e . getCause () . getMessage () . equals ( STRING_CONSTANT ) ; }
assertThat ( failure . getException () ) . hasMessageContaining ( STRING_CONSTANT ) ;
assertTrue ( MockUtil . isMock ( classMock ) ) ;
assertTrue ( MockUtil . isMock ( interfaceMock ) ) ;
Class < > mockType = MockUtil . getMockHandler ( mock ) . getMockSettings () . getTypeToMock () ;
InternalMockHandler < Object > handler = MockUtil . getMockHandler ( mock ) ;
{ if ( MockUtil . typeMockabilityOf ( aClass ) . mockable () ) { constructorMockableParamsSize ++ ; } }
assertTrue ( MockUtil . isMock ( subClass.list ) ) ;
InternalMockHandler < Object > handler = MockUtil . getMockHandler ( mock ) ;
MockCreationSettings < > mockSettings = MockUtil . getMockSettings ( mockitoMock ) ;
MockUtil . isMock ( instance )
assertNotNull ( MockUtil . getMockSettings ( mock ) ) ;
assertNotNull ( MockUtil . getMockHandler ( mock ) ) ;
TypeMockability typeMockability = MockUtil . typeMockabilityOf ( classToMock ) ;
String mockName = getMockName ( mocks . iterator () . next () ) . toString () ;
{ if ( candidateFieldToBeInjected . getName () . equals ( getMockName ( mock ) . toString () ) ) { mockNameMatches . add ( mock ) ; } }
if ( MockUtil . isMock ( throwable ) ) { throw throwable ; }
if ( isMockOrSpy ( instance ) ) { MockUtil . maybeRedefineMockName ( instance , field . getName () ) ; return instance ; }
{ assertNotNull ( notInitializedSpy ) ; assertNotNull ( notInitializedSpy . getAList () ) ; assertTrue ( MockUtil . isMock ( notInitializedSpy ) ) ; }
@ Test public void should_inject_mocks_in_spy () { assertNotNull ( initializedSpy . getAList () ) ; assertTrue ( MockUtil . isMock ( initializedSpy ) ) ; }
MockCreationSettings parentMockSettings = MockUtil . getMockSettings ( parentMock ) ;
InternalMockHandler < Object > handler = MockUtil . getMockHandler ( invocation . getMock () ) ;
String qualifiedName = MockUtil . getMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () ;
MockUtil . isMock ( instance )
public MockingDetails mockingDetails ( Object toInspect ) { return new DefaultMockingDetails ( toInspect ) ; }
InvocationContainer invocationContainer = getMockHandler ( m ) . getInvocationContainer () ;
{ if ( mock == null ) { throw nullPassedWhenCreatingInOrder () ; } if ( ! isMock ( mock ) ) { throw notAMockPassedWhenCreatingInOrder () ; } }
InvocationContainer invocations = getMockHandler ( mock ) . getInvocationContainer () ;
for ( T m : mocks ) { getMockHandler ( m ) . getInvocationContainer () . clearInvocations () ; }
for ( T m : mocks ) { resetMock ( m ) ; }
if ( ! isMock ( mock ) ) { throw notAMockPassedToVerify ( mock . getClass () ) ; }
T mock = createMock ( creationSettings ) ;
List < Invocation > invocations = AllInvocationsFinder . find ( asList ( mockOne , mockOne , mockOne ) ) ;
List < Invocation > invocations = AllInvocationsFinder . find ( asList ( mockOne , mockTwo ) ) ;
List < Invocation > invocations = VerifiableInvocationsFinder . find ( inOrder . getMocksToBeVerifiedInOrder () ) ;
List < Invocation > all = AllInvocationsFinder . find ( createdMocks ) ;
List < Invocation > invocations = AllInvocationsFinder . find ( asList ( mocks ) ) ;
assumeTrue ( ClassFileVersion . forThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
assumeTrue ( ClassFileVersion . forThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
when ( sorter . sort ( ArgumentMatchers . < String > anyList () ) ) . thenReturn ( null ) ;
verify ( mockHandler ) . setAnswersForStubbing ( ArgumentMatchers . < Answer < > > anyList () ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
{ results . add ( sortSuperTypesLast ( Arrays . asList ( o ) ) ) ; }
List < Field > sortedFields = sortSuperTypesLast ( unsortedFields ) ;
List < Field > l = sortSuperTypesLast ( Arrays . asList ( o1 , o2 ) ) ;
return sortSuperTypesLast ( declaredFields ) ;
isNullOrEmpty ( args )
public boolean isOut ( Invocation invocation ) { return isToStringMethod ( invocation . getMethod () ) ; }
@ Override public InvocationMatcher getWanted () { return wanted ; }
if ( isToStringMethod ( currentInvocation . getMethod () ) ) { return STRING_CONSTANT + unstubbedInvocation . toString () ; }
Iterable < > mocks
if ( ! filterRequested && listener . isSussessful () ) { reporter . validateUnusedStubs ( testClass , notifier ) ; }
@ Test public void shouldNotifyListenerSafely ( ) throws Exception { mockingProgress . addListener ( null ) ; mockingProgress . mockingStarted ( null , null ) ; }
mockingProgress () . mockingStarted ( mock , creationSettings ) ;
throw cannotInitializeForInjectMocksAnnotation ( field . getName () , e . getMessage () ) ;
{ if ( value == null ) { throw new IllegalArgumentException ( checkedValue + STRING_CONSTANT ) ; } return value ; }
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
public TypeVariable < > typeVariable () { return typeVariable ; }
public TypeVarBoundedType ( TypeVariable < > typeVariable ) { this . typeVariable = typeVariable ; }
TypeVariable < > [] typeParameters
if ( type instanceof TypeVariable ) { return new TypeVariableReturnType ( this , method . getTypeParameters () , ( TypeVariable < > ) type ) ; }
if ( wildCardBoundedType . firstBound () instanceof TypeVariable ) { return boundsOf ( ( TypeVariable < > ) wildCardBoundedType . firstBound () ) ; }
TypeVariable < > typeVariable
assertThat ( to.privateTransientField ) . isNotEqualTo ( NUMBER_CONSTANT ) ;
assertThat ( to.finalField ) . isNotEqualTo ( NUMBER_CONSTANT ) ;
Class < > classToMock
public int size () { return unused . size () ; }
assumeTrue ( ClassFileVersion . ofThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
assumeTrue ( ClassFileVersion . ofThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
String getAuthorName ( ) ;
String getAuthorEmail ( ) ;
public String toText () { return commits . size () + STRING_CONSTANT + authorName ; }
public String getAuthorName () { return author ; }
public String getAuthorEmail () { return email ; }
UnusedStubbings ( Collection < ? extends Stubbing > unused ) { this . unused = unused ; }
if ( type instanceof Class ) { return new NotGenericReturnTypeSupport ( this , type ) ; }
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT , MILLISECONDS ) ;
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT , MILLISECONDS ) ;
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT , MILLISECONDS ) ;
generatedMockClass = generator . generateMockClass ( features ) ;
@ Test public void shouldRunInMultipleThreads ( ) throws Exception { assertEquals ( STRING_CONSTANT , Collections . emptySet () , runInMultipleThreads ( NUMBER_CONSTANT ) ) ; }
Class < ? extends T > type = createMockType ( settings ) ;
Class < ? extends T > mockedProxyType = createMockType ( settings ) ;
dispatcher == null || ! dispatcher . isMocked ( mock , origin )
public AbstractByteBuddyMockMakerTest ( MM mockMaker ) { this . mockMaker = mockMaker ; }
generatedMockClass = bytecodeGenerator . mockClass ( features ) ;
{ return invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && argumentsMatch ( actual ) ; }
given ( mock ( ConstructorArgumentResolver . class ) . resolveTypeInstances ( any ( Class . class ) ) )
withModifiers ( SynchronizationState.PLAIN , Visibility.PUBLIC )
{ addStep ( task , config ) ; return this ; }
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation getWanted ( ) ;
private RemoveNotMatching ( MatchableInvocation wanted ) { this . wanted = wanted ; }
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted = data . getWanted () ;
MatchableInvocation wanted = data . getWanted () ;
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wantedMatcher = data . getWanted () ;
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted = data . getWanted () ;
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted = data . getWanted () ;
public String print ( MatchableInvocation invocationMatcher ) { return print ( invocationMatcher . getMatchers () , invocationMatcher . getInvocation () ) ; }
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
VerificationDataInOrderImpl dataInOrder = new VerificationDataInOrderImpl ( inOrder , invocations , data . getTarget () ) ;
MatchableInvocation wanted = data . getTarget () ;
{ Checks . checkNotNull ( listener , STRING_CONSTANT ) ; mockingProgress () . removeListener ( listener ) ; return this ; }
{ Checks . checkNotNull ( listener , STRING_CONSTANT ) ; mockingProgress () . addListener ( listener ) ; return this ; }
@ Before public void setUp () { delayedExecution = new DelayedExecution () ; stopWatch = createNotStarted () ; }
@ Advice.Return ( readOnly = false , typing = Assigner.Typing.DYNAMIC ) Object returned
@ Advice.AllArguments Object [] arguments
private ExcludeHandler ( Object root ) { this . root = root ; }
@ Override public Invocation getInvocation () { return invocation ; }
{ return isMock ( mock ) && getMockSettings ( mock ) . getDefaultAnswer () == Mockito.CALLS_REAL_METHODS ; }
isMock ( mock )
mockingProgress () . stubbingCompleted () ;
AnnotationEngine customizedEngine = new IndependentAnnotationEngine () {} ;
AnnotationEngine annotationEngine = new GlobalConfiguration () . tryGetPluginAnnotationEngine () ;
{ throw new IllegalArgumentException ( format ( STRING_CONSTANT , classLoader ) ) ; }
public ExcludingURLClassLoaderBuilder without ( String . . . privatePrefixes ) { excludedPrefixes . addAll ( asList ( privatePrefixes ) ) ; return this ; }
ClassLoader cl = isolatedClassLoader () . withCurrentCodeSourceUrls () . withPrivateCopyOf ( CLASS_NAME_DEPENDING_ON_INTERFACE ) . withPrivateCopyOf ( INTERFACE_NAME ) . build () ;
MockitoStatement statement
mock . otherMethod () ;
public void doAssert ( Throwable throwable ) { assertThrowable ( throwable , expected ) . hasMessage ( expectedMessage ) ; }
rule . expectThrowable ( UnnecessaryStubbingException . class ) ;
public void beforeTest ( Object testClassInstance , String testMethodName ) {}
public JUnitRule silent () { return new JUnitRule ( logger , Strictness.SILENT ) ; }
{ return new JUnitRule ( new ConsoleMockitoLogger () , JUnitRule.Strictness.WARN ) ; }
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
@ Test public void rule_validates_mockito_usage ( ) throws Throwable { rule . expectFailure ( UnfinishedVerificationException . class ) ; verify ( mock ) ; }
rule . expectFailure ( PotentialStubbingProblem . class ) ;
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectFailure ( UnnecessaryStubbingException . class ) ;
rule . expectFailure ( RuntimeException . class , STRING_CONSTANT ) ;
{ rule . expectFailure ( UnfinishedStubbingException . class ) ; when ( mock . simpleMethod () ) ; }
{ rule . expectFailure ( RuntimeException . class , STRING_CONSTANT ) ; throw new RuntimeException ( STRING_CONSTANT ) ; }
void doAssert ( Throwable t ) ;
notifyStubbedAnswerLookup ( invocation , stubbedInvocation ) ;
List < StubbingLookupListener > getStubbingLookupListeners ( ) ;
public MockitoRule silent () { return new JUnitRule ( logger , Strictness.LENIENT ) ; }
case LENIENT :
{ return new JUnitRule ( new ConsoleMockitoLogger () , Strictness.WARN ) ; }
( ( CreationSettings ) settings ) . getStubbingLookupListeners ()
mockingProgress . verificationStarted ( new MockAwareVerificationMode ( mock , actualMode , mockingProgress . verificationListeners () ) ) ;
DefaultAnswerValidator . validateReturnValueFor ( invocation , ret ) ;
private int wantedArgumentPosition () { return wantedArgumentPosition ; }
private boolean returnsNull () { return value == null ; }
public void reportMatcher ( ArgumentMatcher < > matcher ) { matcherStack . push ( new LocalizedMatcher ( matcher ) ) ; }
{ this ( new StrictRunner ( new RunnerFactory () . createStrict ( klass ) , klass ) ) ; }
{ super ( new StrictRunner ( new RunnerFactory () . createStrict ( klass ) , klass ) ) ; }
RunnerImpl runner = provider . newInstance ( STRING_CONSTANT , this . getClass () , null ) ;
InternalRunner runner
MockitoJUnitRunner ( InternalRunner runner ) throws InvocationTargetException { this . runner = runner ; }
loader . getStrategy ( features.mockedType )
@ Override public boolean mockable () { return INSTRUMENTATION . isModifiableClass ( type ) && ! EXCLUDES . contains ( type ) ; }
assertThat ( InlineByteBuddyMockMaker . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ) . isSameAs ( throwable ) ;
throwable = InlineByteBuddyMockMaker . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ;
if ( i != successCount ) { throw new AssertionError ( STRING_CONSTANT + successCount + STRING_CONSTANT + i + STRING_CONSTANT + result . getRunCount () + STRING_CONSTANT ) ; }
Result result = runner . run ( StubbingArgMismatch . class ) ;
Result result = runner . run ( UnnecessaryStubbing . class ) ;
{ return mock ( classToMock , withSettings () ) ; }
return new AndroidClassLoadingStrategy.Injecting ( target ) ;
MockSettings settings = withSettings () . defaultAnswer ( CALLS_REAL_METHODS ) . name ( field . getName () ) ;
Mockito . mock ( instance . getClass () , withSettings () . spiedInstance ( instance ) . defaultAnswer ( CALLS_REAL_METHODS ) . name ( field . getName () ) )
InnerStaticClassWithNoArgConstructor ( String f ) {}
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
throw noMatchingConstructor ( cls ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
if ( ! argMismatchStubbings . isEmpty () ) { mismatchesReported = true ; Reporter . potentialStubbingProblem ( invocation , argMismatchStubbings ) ; }
try { Mockito . framework () . addListener ( listener ) ; } catch ( RedundantListenerException e ) { Reporter . unfinishedMocking () ; }
Failure f = firstOf ( result . getFailures () ) ;
mockito . finishMocking () ;
mockito . finishMocking () ;
mockito . finishMocking () ;
mockito . finishMocking () ;
{ mock . simpleMethod ( NUMBER_CONSTANT ) ; mock . otherMethod () ; mockito . finishMocking () ; logger . assertEmpty () ; }
assertThat ( new Runnable () { public void run () { mockito . finishMocking () ; } } ) . throwsException ( UnnecessaryStubbingException . class )
{ this . currentStrictness = strictness ; this . stubbingLookupListener . setCurrentStrictness ( strictness ) ; }
event . getFailure () == null && ! stubbingLookupListener . isMismatchesReported ()
try { Mockito . framework () . addListener ( listener ) ; } catch ( RedundantListenerException e ) { Reporter . unfinishedMockingSession () ; }
assertThat ( result ) . fails ( UnfinishedMockingSessionException . class , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
assertThat ( result ) . succeeds ( NUMBER_CONSTANT ) ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , PotentialStubbingProblem . class ) ;
return decamelizeMatcher ( matcher . getClass () . getSimpleName () ) ;
return ExceptionFactory . createArgumentsAreDifferentException ( message , wanted , actual ) ;
withModifiers ( SynchronizationState.PLAIN )
assertThat ( MockMethodAdvice . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ) . isSameAs ( throwable ) ;
throwable = MockMethodAdvice . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ;
if ( paramsMatch ( types , params ) ) { evaluateConstructor ( matchingConstructors , constructor ) ; }
assertEquals ( STRING_CONSTANT , mock . forObject ( null ) ) ;
catch ( Throwable throwable ) { lastException = throwable ; return null ; }
STRING_CONSTANT . equals ( method . getName () )
STRING_CONSTANT . equals ( m . getName () )
return STRING_CONSTANT . equals ( method . getName () ) ;
if ( unused . isEmpty () ) { return; }
Type genericInterface = findGenericInterface ( match , targetBaseInterface ) ;
public Class < > [] getParameterTypes () { return parameterTypes ; }
this . arguments = ArgumentsProcessor . expandArgs ( mockitoMethod , args ) ;
parameterTypes = SuspendMethod . trimSuspendParameterTypes ( method . getParameterTypes () ) ;
this . arguments = ArgumentsProcessor . expandArgs ( mockitoMethod , arguments ) ;
{ if ( ! wantedArgumentPositionIsValidForInvocation ( invocation , argumentPosition ) ) { throw invalidArgumentPositionRangeAtInvocationTime ( invocation , wantedArgumentPosition == LAST_ARGUMENT , wantedArgumentPosition ) ; } }
validateArgumentTypeCompatibility ( ( Invocation ) invocation , argumentPosition ) ;
public InOrderImpl ( List < > mocksToBeVerifiedInOrder ) { this . mocksToBeVerifiedInOrder . addAll ( mocksToBeVerifiedInOrder ) ; }
assertThat ( m . getAllValues () ) . containsSequence ( STRING_CONSTANT , STRING_CONSTANT ) ;
Iterable < > mocks
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
given ( iMethods . varargsObject ( eq ( NUMBER_CONSTANT ) , any () ) ) . will ( returnsArgAt ( NUMBER_CONSTANT ) ) ;
@ Override public String indirect () { return STRING_CONSTANT ; }
UnusedStubbings stubbings = new UnusedStubbings ( Arrays . < Stubbing > asList () ) ;
List < Stubbing > getStubbedInvocations ( ) ;
MockHandler < T > mockHandler
{ ( ( MockAccess ) mock ) . setMockitoInterceptor ( new MockMethodInterceptor ( newHandler , settings ) ) ; }
mockAccess . setMockitoInterceptor ( new MockMethodInterceptor ( handler , settings ) ) ;
public NullResultGuardian ( MockHandler < T > delegate ) { this . delegate = delegate ; }
MockHandler < > handler = createMockHandler ( settings ) ;
MockHandler < > handler = createMockHandler ( settings ) ;
MockHandler handler
@ SuppressWarnings ( STRING_CONSTANT ) public < M > M getMock () { return ( M ) invocationContainer . invokedMock () ; }
public void setAnswersForStubbing ( List < Answer < > > answers ) { invocationContainer . setAnswersForStubbing ( answers ) ; }
this . invocationContainer = new InvocationContainerImpl ( mockSettings ) ;
MatchableInvocation invocation
MockUtil . getMockHandler ( mock ) . getInvocationContainer () . setAnswersForStubbing ( answers ) ;
MockUtil . getInvocationContainer ( mock ) . setAnswersForStubbing ( answers ) ;
List < ? extends Stubbing > stubbings = getInvocationContainer () . getStubbedInvocations () ;
InvocationContainerImpl invocationContainer
InvocationContainerImpl invocations
InvocationContainerImpl invocations = getInvocationContainer ( mock ) ;
for ( T m : mocks ) { getInvocationContainer ( m ) . clearInvocations () ; }
MockCreationSettings < T > creationSettings = impl . build ( typeToMock ) ;
private MockHandler < Object > mockHandler () { assertGoodMock () ; return MockUtil . getMockHandler ( toInspect ) ; }
given ( handler.invocationContainer . findAnswerFor ( any ( Invocation . class ) ) ) . willReturn ( value ) ;
{ if ( interceptor == null ) { return stubValue ; } return interceptor . doIntercept ( mock , invokedMethod , arguments , InterceptedInvocation.RealMethod.IsIllegal.INSTANCE ) ; }
return interceptor . doIntercept ( mock , invokedMethod , arguments , new InterceptedInvocation.RealMethod.FromCallable ( superCall ) ) ;
verify ( mock ) ;
{ RealMethod.FromCallable superMethod = new RealMethod.FromCallable ( realMethod ) ; return MockMethodInterceptor . createInvocation ( target , method , args , superMethod , settings ) ; }
RealMethod realMethod ;
{ if ( interceptor == null ) { return stubValue ; } return interceptor . doIntercept ( mock , invokedMethod , arguments , RealMethod.IsIllegal.INSTANCE ) ; }
return interceptor . doIntercept ( mock , invokedMethod , arguments , new RealMethod.FromCallable ( superCall ) ) ;
RealMethod realMethod
RealMethod realMethod
RealMethod realMethod
RealMethod realMethod
return ! node . getSort () . isResolved () || ! node . getRepresentative () . asDefined () . represents ( origin ) ;
if ( ! isMock ( mock ) ) { throw notAMockPassedToWhenMethod () ; }
UnusedStubbings stubbings = new UnusedStubbings ( Collections . < Stubbing > emptyList () ) ;
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . methodDoesNotAcceptNullParameters ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ addListeners ( listeners , this . verificationStartedListeners , STRING_CONSTANT ) ; return this ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . methodDoesNotAcceptParameter ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ if ( mock == null ) { throw Reporter . methodDoesNotAcceptParameter ( STRING_CONSTANT , STRING_CONSTANT ) ; } this . mock = mock ; }
VerificationStartedEvent event = new Event () ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
@ Test public void does_not_do_anything_when_list_is_empty ( ) throws Exception { VerificationStartedNotifier . notifyVerificationStarted ( ( List ) emptyList () , mockitoMock ) ; }
public static MockitoMock getMockitoMock ( Object mock ) { return new MockitoMock ( mock , mockMaker . getHandler ( mock ) ) ; }
mock = ( T ) VerificationStartedNotifier . notifyVerificationStarted ( handler . getMockSettings () . getVerificationStartedListeners () , mockitoMock ) ;
catch ( Exception e ) { assertEquals ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockingDetails ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockingDetails ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockingDetails ) ;
@ Test public void does_not_do_anything_when_list_is_empty ( ) throws Exception { VerificationStartedNotifier . notifyVerificationStarted ( ( List ) emptyList () , mockingDetails ) ; }
catch ( NotAMockException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
assertEquals ( Double . valueOf ( NUMBER_CONSTANT ) , captor . getValue () ) ;
SerializableClass proxy = mockMaker . createMock ( serializableSettingsFor ( SerializableClass . class , SerializableMode.BASIC ) , dummyHandler () ) ;
OtherClass mock = mockMaker . createMock ( settingsWithConstructorFor ( OtherClass . class ) , dummyHandler () ) ;
SomeClass mock = mockMaker . createMock ( settingsFor ( SomeClass . class , SomeInterface . class ) , dummyHandler () ) ;
ClassWithDodgyConstructor mock = mockMaker . createMock ( settingsFor ( ClassWithDodgyConstructor . class ) , dummyHandler () ) ;
ClassWithoutConstructor proxy = mockMaker . createMock ( settingsFor ( ClassWithoutConstructor . class ) , dummyHandler () ) ;
SomeInterface proxy = mockMaker . createMock ( settingsFor ( SomeInterface . class ) , dummyHandler () ) ;
@ Override public Object getOuterClassInstance () { return outerClassInstance ; }
@ Override public SerializableMode getSerializableMode () { return serializableMode ; }
@ Override public MockName getMockName () { return mockName ; }
@ Override public Object getSpiedInstance () { return spiedInstance ; }
@ Override public Object getOuterClassInstance () { return outerClassInstance ; }
@ Override public Object getSpiedInstance () { return spiedInstance ; }
@ Override public MockName getMockName () { return mockName ; }
new MockitoMockKey ( params.mockedType , params.interfaces , params.serializableMode , params.stripAnnotations )
{ this . bytecodeGenerator = bytecodeGenerator ; typeCache = new TypeCache.WithInlineExpunction < MockitoMockKey > ( weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT ) ; }
{ return ! selfCallInfo . isSelfInvocation ( instance ) && isMock ( instance ) ; }
if ( ! threads . awaitTermination ( NUMBER_CONSTANT , TimeUnit.MILLISECONDS ) ) { fail () ; }
if ( ! threads . awaitTermination ( NUMBER_CONSTANT , TimeUnit.MILLISECONDS ) ) { fail () ; }
assertEquals ( STRING_CONSTANT , mock . getFoo () ) ;
assertEquals ( STRING_CONSTANT , mock . getValue () ) ;
{ TestedObject mock = mock ( TestedObject . class , CALLS_REAL_METHODS ) ; assertEquals ( STRING_CONSTANT , mock . getValue () ) ; }
assertEquals ( STRING_CONSTANT , mock.value ) ;
{ when ( mock . getValue () ) . thenCallRealMethod () ; assertEquals ( STRING_CONSTANT , mock . getValue () ) ; }
{ verify ( mock , after ( NUMBER_CONSTANT ) . atLeast ( NUMBER_CONSTANT ) ) . oneArg ( CHAR_CONS ) ; fail ( STRING_CONSTANT ) ; }
sb . append ( STRING_CONSTANT ) . append ( mock ) . append ( STRING_CONSTANT ) ;
singletonLock || classLoader == null ? BOOTSTRAP_LOCK : classLoader
{ return selfCallInfo . checkSuperCall ( instance ) && isMock ( instance ) ; }
@ Override public boolean isMock ( Object instance ) { return instance != interceptors.target && interceptors . containsKey ( instance ) ; }
@ Override public Throwable getFailure () { return testFailure ; }
assertEquals ( filterLineNo ( STRING_CONSTANT + TEST_NAME + STRING_CONSTANT + STRING_CONSTANT ) , filterLineNo ( logger . getLoggedInfo () ) ) ;
assertEquals ( filterLineNo ( STRING_CONSTANT + TEST_NAME + STRING_CONSTANT + STRING_CONSTANT ) , filterLineNo ( logger . getLoggedInfo () ) ) ;
String getTestName ( ) ;
catch ( org.mockito.creation.instance.InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + type . getSimpleName () + STRING_CONSTANT , e ) ; }
catch ( org.mockito.creation.instance.InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + mockedProxyType . getSuperclass () . getSimpleName () + STRING_CONSTANT , e ) ; }
catch ( org.mockito.creation.instance.InstantiationException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Test ( expected = org.mockito.creation.instance.InstantiationException . class )
if ( explosive . get () != null ) { throw new RuntimeException ( MyMockMaker . class . getName () ) ; }
return pluginType . cast ( new InstantiatorProvider2Adapter ( create ( InstantiatorProvider2 . class , className ) ) ) ;
{ instantiatorProvider = new InstantiatorProviderAdapter ( ( InstantiatorProvider ) impl ) ; }
{ return createInvocation ( target , method , args , superMethod , settings ) ; }
this . mockRef . get () . equals ( other.mockRef . get () )
public String getStuff () { return STRING_CONSTANT ; }
if ( ref == null ) { throw new IllegalStateException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . instanceRef = new MockWeakReference < Object > ( instance ) ;
T ref = this . ref . get () ;
this . instanceRef = new MockWeakReference < Object > ( instance ) ;
{ if ( throwableType == null ) { return abortNullExceptionType () ; } return thenThrow ( newInstance ( throwableType ) ) ; }
{ new ThrowsException ( new IOException () ) . validateFor ( createMethodInvocation () ) ; }
{ new ThrowsException ( new CharacterCodingException () ) . validateFor ( createMethodInvocation () ) ; }
new ThrowsException ( throwableToRaise ) . answer ( createMethodInvocation () ) ;
new ThrowsException ( mock ( Exception . class ) ) . answer ( createMethodInvocation () ) ;
new ThrowsException ( new IllegalStateException ( STRING_CONSTANT ) ) . answer ( createMethodInvocation () ) ;
{ if ( throwableType == null ) { mockingProgress () . reset () ; throw notAnException () ; } return thenThrow ( newInstance ( throwableType ) ) ; }
Set < Object > testInstances
for ( Annotation firstParamAnnotation : firstParamAnnotations ) { if ( annotationClass . isAssignableFrom ( firstParamAnnotation . annotationType () ) ) { return ( T ) firstParamAnnotation ; } }
{ if ( field . isAnnotationPresent ( u ) ) { throw unsupportedCombinationOfAnnotations ( annotation . getSimpleName () , u . getSimpleName () ) ; } }
if ( isPrimitiveOrWrapper ( valueClass ) && isPrimitiveOrWrapper ( referenceType ) ) { return Primitives . primitiveTypeOf ( valueClass ) . isAssignableFrom ( Primitives . primitiveTypeOf ( referenceType ) ) ; }
assertThat ( subList . isEmpty () ) . isTrue () ;
@ SuppressWarnings ( { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } )
if ( isComingFromJDK ( type ) || isComingFromSignedJar ( type ) || isComingFromSealedPackage ( type ) ) { typeName = CODEGEN_PACKAGE + type . getSimpleName () ; }
assumeTrue ( ClassFileVersion . ofThisVm () . isAtLeast ( ClassFileVersion.JAVA_V7 ) ) ;
{ super ( Opcodes.ASM6 , cv ) ; this . typeDescription = typeDescription ; }
@ SuppressWarnings ( STRING_CONSTANT ) public MockitoExtension () { this ( Strictness.STRICT_STUBS ) ; }
if ( rawArguments == matcherCount && isLastMatcherVarargMatcher ( matchers ) ) { return MATCH_EACH_VARARGS_WITH_LAST_MATCHER ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . legendLabelURLGenerator = generator ; fireChangeEvent () ; }
{ this . legendLabelToolTipGenerator = generator ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . urlGenerator = generator ; fireChangeEvent () ; }
{ this . toolTipGenerator = generator ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . simpleLabels = simple ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . labelShadowPaint = paint ; fireChangeEvent () ; }
{ this . labelOutlineStroke = stroke ; fireChangeEvent () ; }
{ this . labelOutlinePaint = paint ; fireChangeEvent () ; }
{ this . labelBackgroundPaint = paint ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . labelLinkMargin = margin ; fireChangeEvent () ; }
{ this . labelLinksVisible = visible ; fireChangeEvent () ; }
{ this . maximumLabelWidth = width ; fireChangeEvent () ; }
{ this . labelGap = gap ; fireChangeEvent () ; }
{ this . labelGenerator = generator ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . shadowYOffset = offset ; fireChangeEvent () ; }
{ this . shadowXOffset = offset ; fireChangeEvent () ; }
{ this . shadowPaint = paint ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . sectionOutlineStrokeMap . put ( key , stroke ) ; fireChangeEvent () ; }
{ this . sectionOutlineStroke = stroke ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . sectionOutlinePaintMap . put ( key , paint ) ; fireChangeEvent () ; }
{ this . sectionOutlinePaint = paint ; fireChangeEvent () ; }
{ this . sectionOutlinesVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . sectionPaintMap . put ( key , paint ) ; fireChangeEvent () ; }
{ this . sectionPaint = paint ; fireChangeEvent () ; }
{ this . ignoreZeroValues = flag ; fireChangeEvent () ; }
{ this . ignoreNullValues = flag ; fireChangeEvent () ; }
{ this . circular = circular ; if ( notify ) { fireChangeEvent () ; } }
if ( this . interiorGap != percent ) { this . interiorGap = percent ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . startAngle = angle ; fireChangeEvent () ; }
{ fireChangeEvent () ; }
{ this . radiusGridlinePaint = paint ; fireChangeEvent () ; }
{ this . radiusGridlineStroke = stroke ; fireChangeEvent () ; }
if ( this . radiusGridlinesVisible != visible ) { this . radiusGridlinesVisible = visible ; fireChangeEvent () ; }
{ this . angleGridlinePaint = paint ; fireChangeEvent () ; }
{ this . angleGridlineStroke = stroke ; fireChangeEvent () ; }
if ( this . angleGridlinesVisible != visible ) { this . angleGridlinesVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
if ( this . angleLabelsVisible != visible ) { this . angleLabelsVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . cornerTextItems . clear () ; fireChangeEvent () ; }
if ( removed ) { fireChangeEvent () ; }
fireChangeEvent () ;
{ this . urlGenerator = generator ; fireChangeEvent () ; }
{ this . toolTipGenerator = generator ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . seriesOutlineStrokeList . setStroke ( series , stroke ) ; fireChangeEvent () ; }
{ this . seriesOutlineStroke = stroke ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . seriesOutlinePaintList . setPaint ( series , paint ) ; fireChangeEvent () ; }
{ this . seriesOutlinePaint = paint ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . seriesPaintList . setPaint ( series , paint ) ; fireChangeEvent () ; }
{ this . seriesPaint = paint ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . axisLabelGap = gap ; fireChangeEvent () ; }
if ( this . interiorGap != percent ) { this . interiorGap = percent ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . maxValue = value ; fireChangeEvent () ; }
{ this . startAngle = angle ; fireChangeEvent () ; }
{ this . headPercent = percent ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . webFilled = flag ; fireChangeEvent () ; }
{ this . sectionDepth = sectionDepth ; fireChangeEvent () ; }
{ this . outerSeparatorExtension = percent ; fireChangeEvent () ; }
{ this . innerSeparatorExtension = percent ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . separatorsVisible = visible ; fireChangeEvent () ; }
{ this . intervals . clear () ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . dialOutlinePaint = paint ; fireChangeEvent () ; }
{ this . drawBorder = draw ; fireChangeEvent () ; }
{ this . dialBackgroundPaint = paint ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . tickLabelPaint = paint ; fireChangeEvent () ; }
{ this . tickLabelFont = font ; fireChangeEvent () ; }
if ( this . tickLabelsVisible != visible ) { this . tickLabelsVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . units = units ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . gap = gap ; fireChangeEvent () ; }
{ this . rangeCrosshairPaint = paint ; fireChangeEvent () ; }
{ this . rangeCrosshairStroke = stroke ; fireChangeEvent () ; }
{ this . rangeCrosshairValue = value ; if ( isRangeCrosshairVisible () && notify ) { fireChangeEvent () ; } }
if ( this . rangeCrosshairLockedOnData != flag ) { this . rangeCrosshairLockedOnData = flag ; fireChangeEvent () ; }
if ( this . rangeCrosshairVisible != flag ) { this . rangeCrosshairVisible = flag ; fireChangeEvent () ; }
{ this . domainCrosshairPaint = paint ; fireChangeEvent () ; }
{ this . domainCrosshairStroke = stroke ; fireChangeEvent () ; }
{ this . domainCrosshairValue = value ; if ( isDomainCrosshairVisible () && notify ) { fireChangeEvent () ; } }
if ( this . domainCrosshairLockedOnData != flag ) { this . domainCrosshairLockedOnData = flag ; fireChangeEvent () ; }
if ( this . domainCrosshairVisible != flag ) { this . domainCrosshairVisible = flag ; fireChangeEvent () ; }
{ fireChangeEvent () ; }
if ( this . annotations != null ) { this . annotations . clear () ; fireChangeEvent () ; }
fireChangeEvent () ;
if ( this . rangeMarkers != null ) { this . rangeMarkers . clear () ; fireChangeEvent () ; }
fireChangeEvent () ;
if ( this . domainMarkers != null ) { this . domainMarkers . clear () ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . colorBar = axis ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . colorBarLocation = edge ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . gap = gap ; fireChangeEvent () ; }
{ this . gap = gap ; fireChangeEvent () ; }
{ this . columnRadius = r ; fireChangeEvent () ; }
{ this . bulbRadius = r ; fireChangeEvent () ; }
{ this . useSubrangePaint = flag ; fireChangeEvent () ; }
{ this . followDataInSubranges = flag ; fireChangeEvent () ; }
{ this . subrangePaint [ range ] = paint ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . showValueLines = b ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . valuePaint = paint ; fireChangeEvent () ; }
{ this . valueFont = f ; fireChangeEvent () ; }
{ this . axisLocation = location ; fireChangeEvent () ; }
{ this . valueLocation = location ; fireChangeEvent () ; }
if ( this . units != u ) { this . units = u ; fireChangeEvent () ; }
{ if ( paint != null ) { this . thermometerPaint = paint ; fireChangeEvent () ; } }
{ if ( s != null ) { this . thermometerStroke = s ; fireChangeEvent () ; } }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . limit = limit ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ super . setFixedRangeAxisSpace ( space ) ; setFixedRangeAxisSpaceForSubplots ( space ) ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . gap = gap ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . drawBorder = status ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
if ( this . labelType != type ) { this . labelType = type ; fireChangeEvent () ; }
{ this . darkerSides = darker ; fireChangeEvent () ; }
{ this . depthFactor = factor ; fireChangeEvent () ; }
{ fireChangeEvent () ; }
fireChangeEvent () ;
{ this . renderingHints . put ( RenderingHints.KEY_TEXT_ANTIALIASING , val ) ; notifyListeners ( new ChartChangeEvent ( this ) ) ; }
{ fireChangeEvent () ; }
{ this . datasetToScaleMap . set ( index , new Integer ( scaleIndex ) ) ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
{ result = iterateRangeBounds ( dataset , includeInterval ) ; }
{ result = iterateRangeBounds ( dataset , includeInterval ) ; }
public void datasetChanged ( DatasetChangeEvent event ) { notifyListeners ( event ) ; }
double gap = height - sumOfLabelHeights ;
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
Range r = DatasetUtilities . findRangeBounds ( d , true ) ;
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
double delta = getTickLength () ;
XYSeries series = new XYSeries ( STRING_CONSTANT , true , false ) ;
{ if ( stroke instanceof BasicStroke ) { setData ( stroke ) ; } else { throw new RuntimeException ( STRING_CONSTANT ) ; } }
double maxWidth = space * getMaximumItemWidth () ;
{ super(); setBaseToolTipGenerator ( toolTipGenerator ) ; setURLGenerator ( urlGenerator ) ; setBaseShapesVisible ( false ) ; }
catch ( Exception e ) { e . printStackTrace () ; }
public long getSerialIndex () { return this . time ; }
{ return this . time ; }
public long getMiddleMillisecond () { return this . time ; }
{ return this . time ; }
public long getLastMillisecond () { return this . time ; }
{ return this . time ; }
public long getFirstMillisecond () { return this . time ; }
difference = this . time - t1.time ;
public int hashCode () { return ( int ) this . time ; }
{ FixedMillisecond m = ( FixedMillisecond ) object ; return this . time == m . getFirstMillisecond () ; }
long t = this . time ;
long t = this . time ;
public Date getTime () { return new Date ( this . time ) ; }
{ this . time = time . getTime () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
public Date getUpperDate () { return new Date ( this . upperDate ) ; }
public Date getLowerDate () { return new Date ( this . lowerDate ) ; }
entities != null && isPointInRect ( dataArea , xx , yy )
catch ( Exception e ) { e . printStackTrace () ; }
public Date getEnd () { return new Date ( this . end ) ; }
public Date getStart () { return new Date ( this . start ) ; }
RelativeDateFormat rdf = new RelativeDateFormat ( c0 . getTime () . getTime () ) ;
{ throw new IllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
long skip
if ( pointCount < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
if ( periodCount < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
setChart ( chart ) ;
setLayout ( layout ) ;
setLayout ( layout ) ;
setLayout ( layout ) ;
{ this ( parent , style ) ; setColor ( color ) ; }
if ( dataset != null ) { setDataset ( dataset ) ; }
Paint paint = lookupSectionPaint ( key ) ;
Paint paint = lookupSectionPaint ( key ) ;
Paint paint = lookupSectionPaint ( key ) ;
EventListener listener
if ( currentGridBandIsDark ) { g2 . setPaint ( this . gridBandPaint ) ; } else { g2 . setPaint ( this . gridBandAlternatePaint ) ; }
if ( currentGridBandIsDark ) { g2 . setPaint ( this . gridBandPaint ) ; } else { g2 . setPaint ( this . gridBandAlternatePaint ) ; }
this . autoPopulateSeriesStroke = true ;
g2 . setPaint ( renderer . getShadowPaint () ) ;
g2 . setPaint ( renderer . getShadowPaint () ) ;
Paint paint = renderer . getItemOutlinePaint ( row , column ) ;
new Object [] { new Integer ( - s - NUMBER_CONSTANT ) , new Double ( negBase ) }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
{ if ( this . year < Year.MAXIMUM_YEAR ) { return new Year ( this . year + NUMBER_CONSTANT ) ; } else { return null ; } }
if ( ( year < Year.MINIMUM_YEAR ) || ( year > Year.MAXIMUM_YEAR ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + year + STRING_CONSTANT ) ; }
TimeZone zone
{ return createStandardDateTickUnits ( TimeZone . getDefault () , Locale . getDefault () ) ; }
Calendar calendar = Calendar . getInstance ( this . timeZone , this . locale ) ;
Calendar calendar = Calendar . getInstance ( this . timeZone , this . locale ) ;
assertEquals ( true , r . getAutoPopulateSeriesStroke () ) ;
if ( item == s . getLastItemIndex () ) { drawFirstPassShape ( g2 , pass , series , item , s.seriesPath ) ; }
setMinorTickCount ( NUMBER_CONSTANT ) ;
{ this . minorTickMarkOutsideLength = length ; fireChangeEvent () ; }
{ this . minorTickMarkInsideLength = length ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . tickMarkStroke = stroke ; fireChangeEvent () ; }
{ this . tickMarkOutsideLength = length ; fireChangeEvent () ; }
{ this . tickMarkInsideLength = length ; fireChangeEvent () ; }
if ( flag != this . tickMarksVisible ) { this . tickMarksVisible = flag ; fireChangeEvent () ; }
{ this . tickLabelInsets = insets ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . tickLabelFont = font ; fireChangeEvent () ; }
if ( flag != this . minorTickMarksVisible ) { this . minorTickMarksVisible = flag ; fireChangeEvent () ; }
if ( flag != this . tickLabelsVisible ) { this . tickLabelsVisible = flag ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . axisLineVisible = visible ; fireChangeEvent () ; }
{ this . labelAngle = angle ; fireChangeEvent () ; }
{ this . labelInsets = insets ; if ( notify ) { fireChangeEvent () ; } }
fireChangeEvent () ;
{ this . labelFont = font ; fireChangeEvent () ; }
if ( flag != this . visible ) { this . visible = flag ; fireChangeEvent () ; }
catch ( Exception e ) { e . printStackTrace () ; }
public static Test suite () { return new TestSuite ( SubCategoryAxisTests . class ) ; }
catch ( Exception e ) { e . printStackTrace () ; success = false ; }
catch ( Exception e ) { e . printStackTrace () ; success = false ; }
renderer1 . setBaseToolTipGenerator ( StandardXYToolTipGenerator . getTimeSeriesInstance () ) ;
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
this . shell . setText ( ResourceBundleWrapper . getBundle ( STRING_CONSTANT ) . getString ( STRING_CONSTANT ) ) ;
ResourceBundle resources = ResourceBundleWrapper . getBundle ( baseName ) ;
ResourceBundle resources = ResourceBundleWrapper . getBundle ( baseResourceClass ) ;
result = NUMBER_CONSTANT * result + this . unitType . hashCode () ;
TimeSeries overwritten = new TimeSeries ( STRING_CONSTANT + getKey () ) ;
{ throw new SeriesException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ this ( name , DEFAULT_DOMAIN_DESCRIPTION , DEFAULT_RANGE_DESCRIPTION ) ; }
drawZoomRectangle ( g2 , ! this . useBuffer ) ;
if ( ! this . useBuffer ) { drawZoomRectangle ( g2 , true ) ; }
{ return this . zoomFillPaint ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
return new Color ( g , g , g , this . alpha ) ;
this . shadowsVisible = getDefaultShadowsVisible () ;
this . shadowsVisible = getDefaultShadowsVisible () ;
if ( dataset == null ) { return null ; }
Calendar calendar = Calendar . getInstance ( zone , locale ) ;
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
Paint paint = renderer . getItemOutlinePaint ( row , column ) ;
StrokeChooserPanel panel = new StrokeChooserPanel ( this . gridStrokeSample , this . availableStrokeSamples ) ;
StrokeChooserPanel panel = new StrokeChooserPanel ( this . outlineStrokeSample , this . availableStrokeSamples ) ;
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
{ this ( label , first , last , TimeZone . getDefault () , Locale . getDefault () ) ; }
catch ( Exception e ) { e . printStackTrace () ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
catch ( Exception e ) { e . printStackTrace () ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
TimeSeries result = new TimeSeries ( name ) ;
TimeSeries series1 = new TimeSeries ( STRING_CONSTANT ) ;
calendar . add ( unit . getCalendarField () , unit . getMultiple () ) ;
public boolean isOutlineVisible () { return this . outlineVisible ; }
{ return this . maxY ; }
{ return this . minY ; }
{ return this . maxX ; }
{ return this . minX ; }
clone.zValues = DataUtilities . clone ( this . zValues ) ;
public Stroke getLabelOutlineStroke () { return this . labelOutlineStroke ; }
s1 . updateByIndex ( NUMBER_CONSTANT , new Double ( NUMBER_CONSTANT ) ) ;
s1 . updateByIndex ( NUMBER_CONSTANT , new Double ( - NUMBER_CONSTANT ) ) ;
rangeAxis . resizeRange2 ( factor , anchorY ) ;
rangeAxis . resizeRange2 ( factor , anchorY ) ;
domainAxis . resizeRange2 ( factor , anchorX ) ;
{ return STRING_CONSTANT + ImageMapUtilities . javascriptEscape ( toolTipText ) + STRING_CONSTANT ; }
{ if ( ! Double . isNaN ( hiY ) ) { result = Math . max ( result , hiY ) ; } }
this . domainAxis . resizeRange2 ( factor , anchorX ) ;
{ this ( renderer , false ) ; }
this . rangePannable = false ;
( mods & this . panMask ) == this . panMask
if ( entities != null ) { addEntity ( entities , hotspot , dataset , row , column , x1 , y1 ) ; }
public NumberAxis3D ( String label ) { super ( label ) ; }
this . stripOutlineVisible = true ;
TimeSeries series = new TimeSeries ( name ) ;
catch ( Exception e ) { e . printStackTrace () ; success = false ; }
Line2D line = new Line2D.Double ( startX , startY , arrowBaseX , arrowBaseY ) ;
if ( this . showBase ) { result . append ( this . baseLabel ) ; result . append ( this . powerLabel ) ; }
{ this . legendShapeList . setShape ( series , shape ) ; fireChangeEvent () ; }
{ return this . legendShapeList . getShape ( series ) ; }
return result ;
double ol ;
double transY0 ;
Paint seriesPaint ;
double value ;
Rectangle2D titleArea ;
double x0 ;
TimeSeriesDataItem item = series . getRawDataItem ( i ) ;
{ return getRawDataItem ( index ) . getValue () ; }
{ return getRawDataItem ( index ) . getPeriod () ; }
XYDataItem item = getRawDataItem ( index ) ;
{ return getRawDataItem ( index ) . getY () ; }
{ return getRawDataItem ( index ) . getX () ; }
catch ( Exception e ) { e . printStackTrace () ; }
{ return ( double [] ) this . coefficients . clone () ; }
catch ( Exception e ) { e . printStackTrace () ; }
{ return getDataset ( NUMBER_CONSTANT ) ; }
double maxRadius = plot . getAxis () . getUpperBound () ;
fireDatasetChanged () ;
catch ( Exception e ) { e . printStackTrace () ; }
Line2D line = new Line2D.Double ( startX , startY , arrowBaseX , arrowBaseY ) ;
{ super ( info ) ; this . area = new GeneralPath () ; this . line = new Line2D.Double () ; }
{ this . shapesVisible = shapesVisible ; fireChangeEvent () ; }
JPopupMenu result = new JPopupMenu ( localizationResources . getString ( STRING_CONSTANT ) + STRING_CONSTANT ) ;
String text = localizationResources . getString ( STRING_CONSTANT ) ;
public boolean isCounterClockwise () { return this . counterClockwise ; }
public double getAngleOffset () { return this . angleOffset ; }
getSectionOutlinesVisible () && outlinePaint != null && outlineStroke != null
{ Object c1 = new XYSeriesCollection () ; assertTrue ( c1 instanceof PublicCloneable ) ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; assertTrue ( false ) ; return; }
catch ( PropertyVetoException e ) { throw new IllegalArgumentException ( e . getMessage () ) ; }
this . shadowGenerator = null ;
this . shadowGenerator = null ;
this . maxY = maxIgnoreNaN ( this . maxY , yy ) ;
if ( ! file . exists () ) { throw new ServletException ( STRING_CONSTANT + filename + STRING_CONSTANT ) ; }
public boolean isRadiusMinorGridlinesVisible () { return this . radiusMinorGridlinesVisible ; }
assertTrue ( true ) ;
catch ( Exception e ) { fail ( e . toString () ) ; return; }
catch ( Exception e ) { fail ( e . toString () ) ; return; }
catch ( Exception e ) { fail ( e . toString () ) ; return; }
catch ( CloneNotSupportedException e ) { fail ( STRING_CONSTANT ) ; return; }
catch ( CloneNotSupportedException e ) { fail ( STRING_CONSTANT ) ; return; }
catch ( CloneNotSupportedException e ) { fail ( STRING_CONSTANT ) ; return; }
catch ( CloneNotSupportedException e ) { fail ( STRING_CONSTANT ) ; return; }
result = Range . combineIgnoringNaN ( result , r ) ;
boolean include ;
{ setItemLabelsVisible ( Boolean . valueOf ( visible ) ) ; }
{ setBaseItemLabelsVisible ( Boolean . valueOf ( visible ) ) ; }
{ setSeriesItemLabelsVisible ( series , Boolean . valueOf ( visible ) ) ; }
{ setSeriesShapesFilled ( series , Boolean . valueOf ( flag ) ) ; }
{ setShapesFilled ( Boolean . valueOf ( filled ) ) ; }
{ setSeriesShapesVisible ( series , Boolean . valueOf ( visible ) ) ; }
{ setShapesVisible ( Boolean . valueOf ( visible ) ) ; }
{ setSeriesLinesVisible ( series , Boolean . valueOf ( visible ) ) ; }
{ setLinesVisible ( Boolean . valueOf ( visible ) ) ; }
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return c . getTimeInMillis () ;
return c . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
if ( dimension > NUMBER_CONSTANT ) { space . add ( dimension , edge ) ; return space ; }
return c . getTimeInMillis () - NUMBER_CONSTANT ;
if ( counterClockwise ) { angleDegrees = - angleDegrees ; }
if ( sectionKeys . isEmpty () ) { return; }
{ this . stepped = stepped ; }
{ this . paletteName = paletteName ; }
catch ( Exception e ) { fail ( e . getMessage () ) ; }
catch ( CloneNotSupportedException e ) { fail ( e . getMessage () ) ; }
LegendItem result ;
if ( this . data . isEmpty () ) { return; }
ValueAxis valueAxis ;
double dim ;
Line2D line ;
Line2D line ;
boolean paintLine ;
ValueAxis valueAxis ;
ValueAxis valueAxis ;
Range adjusted ;
AxisState state ;
Rectangle2D bounds ;
CategoryToolTipGenerator result ;
try { clone = super . clone () ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; }
Range adjusted ;
EntityBlockParams ebp ;
ToolTipTagFragmentGenerator toolTipTagFragmentGenerator ;
int result ;
catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; }
public void valueBound ( HttpSessionBindingEvent event ) {}
public void init ( ) throws ServletException {}
float l ;
double result ;
catch ( Exception e ) { throw new RuntimeException ( e ) ; }
catch ( PropertyVetoException e ) { throw new IllegalArgumentException ( e . getMessage () ) ; }
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . tickMarkPosition = position ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
double result ;
{ this . labelInfo = info ; fireChangeEvent () ; }
{ this . minorTickMarkOutsideLength = length ; fireChangeEvent () ; }
{ this . minorTickMarkInsideLength = length ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . minorTickMarkPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . minorTickMarkStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . minorTickTimePeriodClass = c ; fireChangeEvent () ; }
{ this . minorTickMarksVisible = visible ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . majorTickTimePeriodClass = c ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . autoRangeTimePeriodClass = c ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
this . dateFormat = ( DateFormat ) dateFormat . clone () ;
{ this . categoryLabelToolTips . clear () ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ ParamChecks . nullNotPermitted ( positions , STRING_CONSTANT ) ; this . categoryLabelPositions = positions ; fireChangeEvent () ; }
{ this . maximumCategoryLabelWidthRatio = ratio ; fireChangeEvent () ; }
{ this . maximumCategoryLabelLines = lines ; fireChangeEvent () ; }
{ this . categoryMargin = margin ; fireChangeEvent () ; }
{ this . upperMargin = margin ; fireChangeEvent () ; }
{ this . lowerMargin = margin ; fireChangeEvent () ; }
Range adjusted ;
{ this . minorTickCount = count ; fireChangeEvent () ; }
{ this . standardTickUnits = source ; fireChangeEvent () ; }
{ this . autoTickUnitSelection = flag ; if ( notify ) { fireChangeEvent () ; } }
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ; this . defaultAutoRange = range ; fireChangeEvent () ; }
if ( notify ) { fireChangeEvent () ; }
if ( notify ) { fireChangeEvent () ; }
if ( this . inverted != flag ) { this . inverted = flag ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . rightArrow = arrow ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . leftArrow = arrow ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . downArrow = arrow ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . upArrow = arrow ; fireChangeEvent () ; }
{ this . negativeArrowVisible = visible ; fireChangeEvent () ; }
{ this . positiveArrowVisible = visible ; fireChangeEvent () ; }
if ( this . verticalTickLabels != flag ) { this . verticalTickLabels = flag ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandAlternatePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandPaint = paint ; fireChangeEvent () ; }
if ( this . gridBandsVisible != flag ) { this . gridBandsVisible = flag ; fireChangeEvent () ; }
{ this . numberFormatOverride = formatter ; fireChangeEvent () ; }
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
Date result ;
public int hashCode () { return super . hashCode () ; }
assertSame ( url2 , url1 ) ;
assertSame ( tt2 , tt ) ;
assertSame ( url2 , url1 ) ;
assertSame ( tt2 , tt ) ;
{ return ChartFactory . createPieChart3D ( STRING_CONSTANT , dataset ) ; }
return ChartFactory . createPieChart ( STRING_CONSTANT , data ) ;
{ return createXYAreaChart ( title , xAxisLabel , yAxisLabel , dataset , PlotOrientation.VERTICAL , true , true , false ) ; }
try { series2 . setKey ( STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException e ) {}
this . maxY = maxIgnoreNaN ( this . maxY , yy ) ;
double gap = NUMBER_CONSTANT ;
Date result ;
Line2D line ;
Line2D line ;
boolean paintLine ;
CategoryAxis axis ;
RectangleEdge result ;
ItemLabelPosition position ;
ItemLabelPosition position ;
( float ) regions [ NUMBER_CONSTANT ] . getMaxY ()
double result ;
StringBuilder tag = new StringBuilder () ;
StringBuilder result = new StringBuilder () ;
StringBuilder result = new StringBuilder () ;
StringBuilder result = new StringBuilder () ;
StringBuilder sb = new StringBuilder () ;
ToolTipTagFragmentGenerator toolTipTagFragmentGenerator ;
Shape box ;
Shape box ;
ItemLabelPosition position ;
ItemLabelPosition position ;
double space ;
int historyIdx ;
Range result ;
String result ;
double startX ;
BlockContainer result ;
boolean include ;
String label ;
boolean paintLine ;
int izV ;
int izV ;
DrawingSupplier result ;
Arc2D notch ;
double space ;
double yyAverage ;
double aRadius ;
Line2D line ;
Line2D line ;
int series ;
int series ;
double rectWidth ;
double rectHeight ;
boolean visible ;
Paint p ;
@ Ignore
DefaultXYDataset d = new DefaultXYDataset () { @ Override public DomainOrder getDomainOrder () { return DomainOrder.DESCENDING ; } } ;
DefaultXYDataset d = new DefaultXYDataset () { @ Override public DomainOrder getDomainOrder () { return DomainOrder.ASCENDING ; } } ;
DefaultXYDataset d = new DefaultXYDataset () { @ Override public DomainOrder getDomainOrder () { return DomainOrder.DESCENDING ; } } ;
DefaultXYDataset d = new DefaultXYDataset () { @ Override public DomainOrder getDomainOrder () { return DomainOrder.ASCENDING ; } } ;
boolean success ;
boolean success ;
boolean success ;
boolean success ;
boolean success ;
boolean success ;
boolean success ;
new Rectangle2D.Double ( Math . min ( x1 , x2 ) , dataArea . getMinY () , Math . abs ( x2 - x1 ) , dataArea . getHeight () )
return directions [ index ] ;
{ if ( y <= this . minY || y >= this . maxY ) { updateMinMaxYByIteration () ; } }
updateMinMaxYByIteration () ;
if ( removed ) { updateMinMaxYByIteration () ; if ( notify ) { fireSeriesChanged () ; } }
if ( removed ) { updateMinMaxYByIteration () ; if ( notify ) { fireSeriesChanged () ; } }
{ updateMinMaxYByIteration () ; }
{ updateMinMaxYByIteration () ; }
Line2D extendedSeparator = LineUtilities . extendLine ( separator , this . innerSeparatorExtension , this . outerSeparatorExtension ) ;
setRange ( calculateValueNoINF ( log1 ) , calculateValueNoINF ( log2 ) ) ;
{ this . attributedLabels . put ( section , label ) ; }
{ super ( labelFormat , numberFormat , percentFormat ) ; this . attributedLabels = new HashMap () ; }
CategoryPlot p2 ;
CategoryPlot p2 ;
CategoryPlot p2 ;
{ this . itemURLGeneratorMap . put ( series , generator ) ; fireChangeEvent () ; }
{ this . toolTipGeneratorMap . put ( series , generator ) ; fireChangeEvent () ; }
{ return this . toolTipGeneratorMap . get ( series ) ; }
{ this . itemLabelGeneratorMap . put ( series , generator ) ; fireChangeEvent () ; }
this . datasets . put ( index , dataset ) ;
this . rangeAxisLocations . put ( index , location ) ;
int result = findRangeAxisIndex ( axis ) ;
this . rangeAxes . put ( index , axis ) ;
this . domainAxisLocations . put ( index , location ) ;
this . domainAxes . put ( index , axis ) ;
{ this . toolTipGeneratorMap . put ( series , generator ) ; fireChangeEvent () ; }
{ return this . toolTipGeneratorMap . get ( series ) ; }
{ this . itemLabelGeneratorMap . put ( series , generator ) ; fireChangeEvent () ; }
{ return this . itemLabelGeneratorMap . get ( series ) ; }
{ this . legendTextFontMap . put ( series , font ) ; fireChangeEvent () ; }
{ return this . legendTextFontMap . get ( series ) ; }
{ this . negativeItemLabelPositionMap . put ( series , position ) ; if ( notify ) { fireChangeEvent () ; } }
{ this . positiveItemLabelPositionMap . put ( series , position ) ; if ( notify ) { fireChangeEvent () ; } }
{ this . itemLabelFontMap . put ( series , font ) ; if ( notify ) { fireChangeEvent () ; } }
{ return this . itemLabelFontMap . get ( series ) ; }
int result = findRangeAxisIndex ( axis ) ;
int result = findDomainAxisIndex ( axis ) ;
this . renderers . put ( index , renderer ) ;
this . datasets . put ( index , dataset ) ;
this . rangeAxisLocations . put ( index , location ) ;
this . rangeAxes . put ( index , axis ) ;
this . rangeAxes . put ( NUMBER_CONSTANT , axis ) ;
this . domainAxisLocations . put ( index , location ) ;
this . domainAxes . put ( index , axis ) ;
try { copy . add ( clone ) ; } catch ( SeriesException e ) { throw new RuntimeException ( e ) ; }
if ( nDataPoints > this . valueHistory . length ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
try { copy . add ( clone ) ; } catch ( SeriesException e ) { throw new RuntimeException ( STRING_CONSTANT , e ) ; }
{ super ( null , null , rangeAxis , null ) ; this . subplots = new java.util.ArrayList < XYPlot > () ; }
{ super ( null , domainAxis , null , null ) ; this . subplots = new java.util.ArrayList < XYPlot > () ; }
double adj = percent * length ;
{ return this . fontRenderContext ; }
ChartPanel chartPanel = new ChartPanel ( chart , false ) ;
public FixedMillisecond ( long millisecond ) { this . time = millisecond ; }
int response = JOptionPane . showConfirmDialog ( this , fileExists , localizationResources . getString ( STRING_CONSTANT ) , JOptionPane.OK_CANCEL_OPTION ) ;
int response = JOptionPane . showConfirmDialog ( this , fileExists , localizationResources . getString ( STRING_CONSTANT ) , JOptionPane.OK_CANCEL_OPTION ) ;
XYDataset dataset
ChartPanel panel = new ChartPanel ( chart , false ) ;
ChartPanel panel = new ChartPanel ( chart , false ) ;
this . panel = new ChartPanel ( this . chart , false ) ;
r1 . setBaseLegendTextPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.GREEN ) ) ;
g2 . draw ( new Line2D.Double ( xxMin , yymid - halfW , xxMin , yymid + halfW ) ) ;
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . canvas . removeChartMouseListener ( listener ) ; }
if ( ! hasUniqueID ( handler ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + handler . getID () + STRING_CONSTANT ) ; }
this . viewer . hideZoomRectangle () ;
this . viewer . showZoomRectangle ( x , y , w , h ) ;
ValueAxis xAxis = getDomainAxisForDataset ( datasetIndex ) ;
updateCrosshairValues ( crosshairState , x , y , datasetIndex , block . getCenterX () , block . getCenterY () , orientation ) ;
if ( entities != null ) { addEntity ( entities , block , dataset , series , item , transX , transY ) ; }
{ result . put ( key , ObjectUtils . clone ( value ) ) ; }
{ result . add ( ObjectUtils . clone ( obj ) ) ; }
if ( this . data != null ) { clone.data = ArrayUtils . clone ( this . data ) ; }
result = NUMBER_CONSTANT * result + ObjectUtils . hashCode ( this . fillPaint ) ;
if ( ! PaintUtils . equal ( this . groupPaint , that.groupPaint ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
{ stream . defaultReadObject () ; this . chartArea = ( Rectangle2D ) SerialUtils . readShape ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . chartArea , stream ) ; }
if ( ! PaintUtils . equal ( p1 , p2 ) ) { return false ; }
Paint paint = SerialUtils . readPaint ( in ) ;
Shape rotatedBox = ShapeUtils . rotateShape ( box , position . getAngle () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Shape rotatedBox = ShapeUtils . rotateShape ( box , position . getAngle () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( ! ObjectUtils . equal ( this . date , that.date ) ) { return false ; }
UIUtils . centerFrameOnScreen ( demo ) ;
{ stream . defaultReadObject () ; setArea ( SerialUtils . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( getArea () , stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendShape , stream ) ; }
{ stream . defaultReadObject () ; this . legendShape = SerialUtils . readShape ( stream ) ; }
if ( ! ShapeUtils . equal ( this . legendShape , that.legendShape ) ) { return false ; }
result.subplots = ( List ) ObjectUtils . deepClone ( this . subplots ) ;
if ( ! ObjectUtils . equal ( this . subplots , that.subplots ) ) { return false ; }
clone.legendItemShape = ShapeUtils . clone ( this . legendItemShape ) ;
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
if ( ! ObjectUtils . equal ( this . data , that.data ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendArea , stream ) ; }
{ stream . defaultReadObject () ; this . legendArea = SerialUtils . readShape ( stream ) ; }
if ( ! ShapeUtils . equal ( this . legendArea , that.legendArea ) ) { return false ; }
clone.legendArea = ShapeUtils . clone ( this . legendArea ) ;
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendBar , stream ) ; }
{ stream . defaultReadObject () ; this . legendBar = SerialUtils . readShape ( stream ) ; }
if ( ! ObjectUtils . equal ( this . arrowStroke , that.arrowStroke ) ) { return false ; }
{ stream . defaultReadObject () ; this . subLabelPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . subLabelPaint , stream ) ; }
if ( ! ObjectUtils . equal ( this . formatter , that.formatter ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . image , that.image ) ) { return false ; }
{ addEntity ( info , ShapeUtils . createLineRegion ( line , NUMBER_CONSTANT ) , rendererIndex , toolTip , url ) ; }
clone.rows = ( List ) ObjectUtils . deepClone ( this . rows ) ;
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
return ObjectUtils . equal ( this . data , that.data ) ;
hash = NUMBER_CONSTANT * hash + ObjectUtils . hashCode ( this . seriesKey ) ;
if ( ! ObjectUtils . equal ( this . key , that.key ) ) { return false ; }
result.subplots = ( List ) ObjectUtils . deepClone ( this . subplots ) ;
if ( ! ObjectUtils . equal ( this . subplots , that.subplots ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendLine , stream ) ; }
{ stream . defaultReadObject () ; this . legendLine = SerialUtils . readShape ( stream ) ; }
if ( ! ShapeUtils . equal ( this . legendLine , that.legendLine ) ) { return false ; }
if ( this . legendLine != null ) { clone.legendLine = ShapeUtils . clone ( this . legendLine ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendArea , stream ) ; }
{ stream . defaultReadObject () ; this . legendArea = SerialUtils . readShape ( stream ) ; }
clone.legendArea = ShapeUtils . clone ( this . legendArea ) ;
if ( ! ShapeUtils . equal ( this . legendArea , that.legendArea ) ) { return false ; }
{ stream . defaultReadObject () ; this . bounds = ( Rectangle2D ) SerialUtils . readShape ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . bounds , stream ) ; }
clone.bounds = ( Rectangle2D ) ShapeUtils . clone ( this . bounds ) ;
if ( ! ObjectUtils . equal ( this . id , that.id ) ) { return false ; }
return ObjectUtils . equal ( this . data , that.data ) ;
result.subplots = ( List ) ObjectUtils . deepClone ( this . subplots ) ;
if ( ! ObjectUtils . equal ( this . subplots , that.subplots ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . gradientPaintTransformer , that.gradientPaintTransformer ) ) { return false ; }
{ stream . defaultReadObject () ; this . wallPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . wallPaint , stream ) ; }
if ( ! PaintUtils . equal ( this . wallPaint , that.wallPaint ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . image , that.image ) ) { return false ; }
clone.legendItemShape = ShapeUtils . clone ( this . legendItemShape ) ;
clone.tasks = ( List ) ObjectUtils . deepClone ( this . tasks ) ;
{ StandardEntityCollection that = ( StandardEntityCollection ) obj ; return ObjectUtils . equal ( this . entities , that.entities ) ; }
{ stream . defaultReadObject () ; this . backgroundPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . backgroundPaint , stream ) ; }
if ( ! PaintUtils . equal ( this . backgroundPaint , that.backgroundPaint ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . seriesKey , that.seriesKey ) ) { return false ; }
clone.seriesList = ( List ) ObjectUtils . deepClone ( this . seriesList ) ;
{ MatrixSeriesCollection c = ( MatrixSeriesCollection ) obj ; return ObjectUtils . equal ( this . seriesList , c.seriesList ) ; }
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
return ObjectUtils . equal ( this . data , that.data ) ;
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
{ stream . defaultReadObject () ; this . shadowPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . shadowPaint , stream ) ; }
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
return ObjectUtils . equal ( this . data , that.data ) ;
if ( ! ObjectUtils . equal ( getDescription () , that . getDescription () ) ) { return false ; }
UIUtils . centerFrameOnScreen ( demo ) ;
clone.items = ( List ) ObjectUtils . deepClone ( this . items ) ;
{ new Integer ( series ) , faces [ NUMBER_CONSTANT ] . getBounds2D () , Boolean . valueOf ( v0 < getBase () ) }
{ new Integer ( series ) , faces [ NUMBER_CONSTANT ] . getBounds2D () , Boolean . valueOf ( v0 < getBase () ) }
clone.bins = ( List ) ObjectUtils . deepClone ( this . bins ) ;
if ( ! ObjectUtils . equal ( this . gradientPaintTransformer , that.gradientPaintTransformer ) ) { return false ; }
{ setSeriesShapesFilled ( series , Boolean . valueOf ( filled ) ) ; }
{ setSeriesShapesVisible ( series , Boolean . valueOf ( visible ) ) ; }
{ setShapesVisible ( Boolean . valueOf ( visible ) ) ; }
{ setSeriesLinesVisible ( series , Boolean . valueOf ( visible ) ) ; }
{ setLinesVisible ( Boolean . valueOf ( visible ) ) ; }
UIUtils . centerFrameOnScreen ( demo ) ;
result.subplots = ( List ) ObjectUtils . deepClone ( this . subplots ) ;
if ( ! ObjectUtils . equal ( this . subplots , that.subplots ) ) { return false ; }
clone.rangeAxis = ( ValueAxis ) ObjectUtils . clone ( this . rangeAxis ) ;
if ( ! ObjectUtils . equal ( this . image , that.image ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . data , that.data ) ) { return false ; }
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
{ stream . defaultReadObject () ; this . sublabelPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . sublabelPaint , stream ) ; }
if ( ! PaintUtils . equal ( this . sublabelPaint , that.sublabelPaint ) ) { return false ; }
final Shape shape = ShapeUtils . createTranslatedShape ( getItemShape ( seriesIndex , i ++ ) , x , y ) ;
{ this . seriesFilled . setBoolean ( series , Boolean . valueOf ( filled ) ) ; }
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
return ObjectUtils . equal ( this . data , that.data ) ;
{ stream . defaultReadObject () ; this . area = SerialUtils . readShape ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . area , stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendLine , stream ) ; }
{ stream . defaultReadObject () ; this . legendLine = SerialUtils . readShape ( stream ) ; }
clone.legendLine = ShapeUtils . clone ( this . legendLine ) ;
{ setShapesFilled ( Boolean . valueOf ( filled ) ) ; }
{ DefaultBoxAndWhiskerCategoryDataset dataset = ( DefaultBoxAndWhiskerCategoryDataset ) obj ; return ObjectUtils . equal ( this . data , dataset.data ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendLine , stream ) ; }
{ stream . defaultReadObject () ; this . legendLine = SerialUtils . readShape ( stream ) ; }
if ( this . legendLine != null ) { clone.legendLine = ShapeUtils . clone ( this . legendLine ) ; }
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
{ stream . defaultReadObject () ; setArea ( SerialUtils . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( getArea () , stream ) ; }
if ( ! ObjectUtils . equal ( this . formatter , that.formatter ) ) { return false ; }
{ ValueDataset vd = ( ValueDataset ) obj ; return ObjectUtils . equal ( this . value , vd . getValue () ) ; }
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! ObjectUtils . equal ( this . additionalItemLabelGenerator , that.additionalItemLabelGenerator ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . data , that.data ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . y , that.y ) ) { return false ; }
if ( ! PaintUtils . equal ( this . backgroundPaint , that.backgroundPaint ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . data , that.data ) ) { return false ; }
{ stream . defaultReadObject () ; this . defaultPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . defaultPaint , stream ) ; }
if ( ! PaintUtils . equal ( this . defaultPaint , that.defaultPaint ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . defaultGroup , that.defaultGroup ) ) { return false ; }
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
return ObjectUtils . equal ( this . data , that.data ) ;
{ if ( ! ShapeUtils . equal ( s1 [ i ] , s2 [ i ] ) ) { return false ; } }
{ stream . defaultReadObject () ; setArea ( SerialUtils . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( getArea () , stream ) ; }
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
if ( ! ObjectUtils . equal ( this . data , that.data ) ) { return false ; }
{ stream . defaultReadObject () ; this . artifactPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . artifactPaint , stream ) ; }
if ( ! PaintUtils . equal ( this . artifactPaint , that.artifactPaint ) ) { return false ; }
Stroke stroke = SerialUtils . readStroke ( stream ) ;
SerialUtils . writeStroke ( stroke , stream ) ;
if ( ! ObjectUtils . equal ( s1 , s2 ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . seriesShapesFilled , that.seriesShapesFilled ) ) { return false ; }
{ this . seriesShapesFilled . setBoolean ( series , Boolean . valueOf ( filled ) ) ; fireChangeEvent () ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
Paint paint = SerialUtils . readPaint ( stream ) ;
SerialUtils . writePaint ( paint , stream ) ;
if ( ! PaintUtils . equal ( p1 , p2 ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . drawable , that.drawable ) ) { return false ; }
{ stream . defaultReadObject () ; this . wallPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . wallPaint , stream ) ; }
if ( ! PaintUtils . equal ( this . wallPaint , that.wallPaint ) ) { return false ; }
Shape shadowArc = ShapeUtils . createTranslatedShape ( path , ( float ) shadowXOffset , ( float ) shadowYOffset ) ;
clone.legendLine = ShapeUtils . clone ( this . legendLine ) ;
if ( ! ObjectUtils . equal ( this . arrowStroke , that.arrowStroke ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . indexParamName , that.indexParamName ) ) { return false ; }
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
if ( ! ObjectUtils . equal ( this . data , that.data ) ) { return false ; }
Object toAdd = ObjectUtils . deepClone ( entry ) ;
{ anchor = ShapeUtils . getPointInRectangle ( anchor . getX () , anchor . getY () , dataArea ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . wallPaint , stream ) ; }
{ stream . defaultReadObject () ; this . wallPaint = SerialUtils . readPaint ( stream ) ; }
if ( ! PaintUtils . equal ( this . wallPaint , that.wallPaint ) ) { return false ; }
{ this . drawShapes = Boolean . valueOf ( this . drawShapesCheckBox . isSelected () ) ; }
{ this . drawLines = Boolean . valueOf ( this . drawLinesCheckBox . isSelected () ) ; }
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! ObjectUtils . equal ( this . title , that.title ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . obj , that.obj ) ) { return false ; }
{ stream . defaultReadObject () ; setArea ( SerialUtils . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( getArea () , stream ) ; }
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
Week w = new Week ( gc . getTime () , zone , Locale.UK ) ;
TimeSeries series1 = new TimeSeries ( STRING_CONSTANT ) ;
TimeSeries s1 = new TimeSeries ( STRING_CONSTANT ) ;
TimeSeries series = new TimeSeries ( STRING_CONSTANT ) ;
boolean interval = includeInterval ;
DateTickUnit a1 = new DateTickUnit ( DateTickUnitType.DAY , NUMBER_CONSTANT ) ;
axis . setTickUnit ( new DateTickUnit ( DateTickUnitType.MONTH , NUMBER_CONSTANT , sdf ) ) ;
{ this ( label , TimeZone . getDefault () , Locale . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
{ this . maxItemWidth = percent ; fireChangeEvent () ; }
public double getMaximumItemWidth () { return this . maxItemWidth ; }
if ( tooltips ) { renderer . setDefaultToolTipGenerator ( new StandardXYToolTipGenerator () ) ; }
renderer . setDefaultToolTipGenerator ( new BoxAndWhiskerToolTipGenerator () ) ;
if ( tooltips ) { renderer . setDefaultToolTipGenerator ( new StandardXYToolTipGenerator () ) ; }
if ( tooltips ) { renderer . setDefaultToolTipGenerator ( new StandardXYZToolTipGenerator () ) ; }
renderer . setDefaultToolTipGenerator ( new HighLowItemLabelGenerator () ) ;
renderer . setDefaultToolTipGenerator ( new HighLowItemLabelGenerator () ) ;
renderer . setDefaultToolTipGenerator ( toolTipGenerator ) ;
if ( tooltips ) { renderer . setDefaultToolTipGenerator ( new StandardXYToolTipGenerator () ) ; }
renderer . setDefaultToolTipGenerator ( tt ) ;
renderer . setDefaultToolTipGenerator ( toolTipGenerator ) ;
r1 . setDefaultPaint ( Color.red ) ;
r1 . setDefaultItemLabelGenerator ( new StandardCategoryItemLabelGenerator () ) ;
r1 . setDefaultItemLabelGenerator ( new StandardCategoryItemLabelGenerator () ) ;
setDefaultToolTipGenerator ( toolTipGenerator ) ;
renderer1 . setDefaultToolTipGenerator ( StandardXYToolTipGenerator . getTimeSeriesInstance () ) ;
setDefaultLegendShape ( this . legendLine ) ;
setDefaultToolTipGenerator ( labelGenerator ) ;
setDefaultToolTipGenerator ( new BoxAndWhiskerXYToolTipGenerator () ) ;
if ( result == null ) { result = this . defaultLegendTextPaint ; }
if ( result == null ) { result = this . defaultLegendTextFont ; }
if ( result == null ) { result = this . defaultLegendShape ; }
if ( position == null ) { position = this . defaultNegativeItemLabelPosition ; }
if ( position == null ) { position = this . defaultPositiveItemLabelPosition ; }
if ( result == null ) { result = this . defaultItemLabelPaint ; }
if ( result == null ) { result = this . defaultShape ; }
if ( result == null ) { result = this . defaultOutlineStroke ; }
if ( result == null ) { result = this . defaultStroke ; }
if ( seriesOutlinePaint == null ) { seriesOutlinePaint = this . defaultOutlinePaint ; }
if ( seriesFillPaint == null ) { seriesFillPaint = this . defaultFillPaint ; }
if ( generator == null ) { generator = this . defaultToolTipGenerator ; }
if ( generator == null ) { generator = this . defaultItemLabelGenerator ; }
setDefaultToolTipGenerator ( toolTipGenerator ) ;
setDefaultToolTipGenerator ( toolTipGenerator ) ;
assertEquals ( Color.GRAY , r . getDefaultOutlinePaint () ) ;
assertEquals ( Color.WHITE , r . getDefaultFillPaint () ) ;
assertEquals ( Color.BLUE , r . getDefaultPaint () ) ;
setDefaultToolTipGenerator ( toolTipGenerator ) ;
if ( generator == null ) { generator = this . defaultItemURLGenerator ; }
if ( result == null ) { result = this . defaultToolTipGenerator ; }
if ( generator == null ) { generator = this . defaultItemLabelGenerator ; }
if ( entities != null ) { addEntity ( entities , hotspot , dataset , series , item , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ! dataAreaHotspot . isEmpty () ) { addEntity ( entities , dataAreaHotspot , dataset , series , item , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
r1 . setErrorPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE ) ) ;
r1 . setErrorPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE ) ) ;
{ this ( new RectangleInsets ( top , left , bottom , right ) , Color.BLACK ) ; }
chart . setBackgroundPaint ( Color.WHITE ) ;
this . noDataMessagePaint = Color.BLACK ;
public DialBackground () { this ( Color.WHITE ) ; }
renderer . setSeriesPaint ( NUMBER_CONSTANT , Color.BLACK ) ;
m1 = new CategoryMarker ( STRING_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW ) , new BasicStroke ( NUMBER_CONSTANT ) )
m1 = new CategoryMarker ( STRING_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW ) , new BasicStroke ( NUMBER_CONSTANT ) )
public StandardDialRange () { this ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE ) ; }
g2 . setPaint ( Color.GRAY ) ;
p1 . setSubrangePaint ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ) ;
baseline . setPaint ( Color.BLACK ) ;
{ this ( label , Color.BLACK ) ; }
this . arrowPaint = Color.BLACK ;
{ this ( x1 , y1 , x2 , y2 , new BasicStroke ( NUMBER_CONSTANT ) , Color.BLACK ) ; }
this . arrowPaint = Color.BLACK ;
{ this ( x0 , y0 , x1 , y1 , new BasicStroke ( NUMBER_CONSTANT ) , Color.BLACK ) ; }
a1 . setAxisLinePaint ( Color.RED ) ;
{ this ( polygon , new BasicStroke ( NUMBER_CONSTANT ) , Color.BLACK ) ; }
this . outlinePaint = Color.BLACK ;
{ this ( shape , new BasicStroke ( NUMBER_CONSTANT ) , Color.BLACK ) ; }
g2 . setPaint ( Color.BLACK ) ;
this . sublabelPaint = Color.BLACK ;
this . labelPaint = Color.BLACK ;
public Crosshair ( double value ) { this ( value , Color.BLACK , new BasicStroke ( NUMBER_CONSTANT ) ) ; }
LegendGraphic g1 = new LegendGraphic ( r , Color.BLACK ) ;
LegendGraphic g1 = new LegendGraphic ( r , Color.BLACK ) ;
this . defaultSectionPaint = Color.GRAY ;
g2 . setColor ( Color.BLACK ) ;
this . axisLinePaint = Color.BLACK ;
this . paint = Color.BLACK ;
g2 . setPaint ( Color.BLUE ) ;
{ super ( datasetIndex ) ; this . paint = Color.RED ; this . stroke = new BasicStroke ( NUMBER_CONSTANT , BasicStroke.CAP_ROUND , BasicStroke.JOIN_BEVEL ) ; }
this . shadowPaint = Color.GRAY ;
this . artifactPaint = Color.BLACK ;
ObjectInputStream stream
ObjectOutputStream stream
Graphics2D g2
TextBlock block
double offset
double offset
Paint paint
Paint paint
RectangleInsets gap
Stroke stroke
Paint paint
ObjectInputStream stream
ObjectOutputStream stream
this . boxPaint = Color.GREEN ;
TextUtils . drawRotatedString ( label , g2 , xx , yy , TextAnchor.CENTER , NUMBER_CONSTANT , TextAnchor.CENTER ) ;
Rectangle2D bounds = TextUtils . getTextBounds ( label , g2 , fm ) ;
Rectangle2D r = TextUtils . getTextBounds ( text , g2 , fm ) ;
Rectangle2D bounds = TextUtils . getTextBounds ( tickLabel , g2 , g2 . getFontMetrics () ) ;
Rectangle2D bounds = TextUtils . getTextBounds ( tickLabel , g2 , g2 . getFontMetrics () ) ;
TextUtils . drawAlignedString ( valueStr , g2 , x , y , TextAnchor.TOP_CENTER ) ;
Rectangle2D tickLabelBounds = TextUtils . getTextBounds ( tickLabel , g2 , fm ) ;
Graphics2D g2
Rectangle2D bounds = TextUtils . getTextBounds ( getText () , g2 , fm ) ;
Rectangle2D bounds = TextUtils . getTextBounds ( getText () , g2 , fm ) ;
{ FontMetrics fm = g2 . getFontMetrics ( getLabelFont () ) ; bounds = TextUtils . getTextBounds ( axisLabel , g2 , fm ) ; }
if ( tick . getText () != null ) { labelBounds = TextUtils . getTextBounds ( tick . getText () , g2 , fm ) ; }
if ( tick . getText () != null ) { labelBounds = TextUtils . getTextBounds ( tick . getText () , g2 , fm ) ; }
this . label = TextUtils . createTextBlock ( this . text , font , this . paint ) ;
this . label = TextUtils . createTextBlock ( text , font , this . paint ) ;
Rectangle2D bounds = TextUtils . getTextBounds ( this . text , g2 , fm ) ;
Rectangle2D r = TextUtils . getTextBounds ( this . internalMarkerCycleBoundTick . getText () , g2 , fm ) ;
Rectangle2D bounds = getTextBounds ( text , g2 , fm ) ;
Paint paint
public DefaultShadowGenerator () { this ( NUMBER_CONSTANT , Color.BLACK , NUMBER_CONSTANT , NUMBER_CONSTANT , - Math.PI / NUMBER_CONSTANT ) ; }
renderer . setSeriesPaint ( NUMBER_CONSTANT , Color.BLACK ) ;
this . paint = Color.RED ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.BLUE ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ;
r1 . setDefaultPaint ( Color.RED ) ;
this . zoomOutlinePaint = Color.BLUE ;
g2 . setPaint ( Color.BLUE ) ;
new BlockBorder ( new RectangleInsets ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW ) )
o1 . addRangeCrosshair ( new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) , new BasicStroke ( NUMBER_CONSTANT ) ) )
o1 . addRangeCrosshair ( new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) , new BasicStroke ( NUMBER_CONSTANT ) ) )
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.BLUE ) ;
t1 . setBackgroundPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ) ;
t1 . setBackgroundPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW ) ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.BLUE ) ;
this . gridPaintSample = new PaintSample ( Color.BLUE ) ;
a1 . setSubLabelPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ) ;
c1 = new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) , new BasicStroke ( NUMBER_CONSTANT ) )
c1 = new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) , new BasicStroke ( NUMBER_CONSTANT ) )
XYDifferenceRenderer r1 = new XYDifferenceRenderer ( Color.RED , Color.BLUE , false ) ;
XYDifferenceRenderer r1 = new XYDifferenceRenderer ( Color.RED , Color.BLUE , false ) ;
this . incompletePaint = Color.RED ;
r1 . setSeriesPaint ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW ) ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ;
{ this ( label , range , Color.YELLOW , new BasicStroke ( NUMBER_CONSTANT ) , null ) ; }
Color defaultColor = ( p instanceof Color ? ( Color ) p : Color.BLUE ) ;
XYLineAnnotation a1 = new XYLineAnnotation ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , stroke , Color.BLUE ) ;
XYLineAnnotation a1 = new XYLineAnnotation ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , stroke , Color.BLUE ) ;
XYLineAnnotation a1 = new XYLineAnnotation ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , stroke , Color.BLUE ) ;
a1 . setTickLabelPaint ( STRING_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE ) ) ;
this . downPaint = Color.RED ;
a1 . setOutlinePaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ) ;
t1 . setBackgroundPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW ) ) ;
r1 . setShapePaint ( Color.RED ) ;
s1 . setMajorTickPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE ) ) ;
s1 . setMajorTickPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE ) ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED ) ;
new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW )
b1 . setPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.green ) ) ;
b1 . setPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.green ) ) ;
f1 . setBackgroundPaint ( Color.BLUE ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.BLUE ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.BLUE ) ;
a1 . setPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ) ;
p1 . setAggregatedItemsPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED ) ) ;
{ int result = NUMBER_CONSTANT ; result = HashUtils . hashCode ( result , this . visible ) ; return result ; }
{ int result = NUMBER_CONSTANT ; result = HashUtils . hashCode ( result , this . formatPattern ) ; return result ; }
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . arrowPaint ) ;
{ int result = super . hashCode () ; result = HashUtils . hashCode ( result , this . key ) ; return result ; }
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . paint ) ;
{ int result = super . hashCode () ; result = HashUtils . hashCode ( result , this . isArrowAtTop ) ; return result ; }
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . paint ) ;
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . paint ) ;
{ return HashUtils . hashCode ( super . hashCode () , this . stepPoint ) ; }
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . paint ) ;
{ int result = NUMBER_CONSTANT ; result = HashUtils . hashCode ( result , this . formatPattern ) ; return result ; }
@ Override public int hashCode () { return HashUtils . hashCodeForDoubleArray ( this . coefficients ) ; }
{ int result = NUMBER_CONSTANT ; result = HashUtils . hashCode ( result , this . radius ) ; return result ; }
result = result * NUMBER_CONSTANT + HashUtils . hashCodeForPaint ( this . arrowPaint ) ;
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . paint ) ;
{ int hash = super . hashCode () ; hash = HashUtils . hashCode ( hash , this . errorIndicatorPaint ) ; return hash ; }
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . paint ) ;
ChartUtils . saveChartAsJPEG ( tempFile , chart , width , height , info ) ;
ChartUtils . saveChartAsPNG ( tempFile , chart , width , height , info ) ;
{ return STRING_CONSTANT + ImageMapUtils . javascriptEscape ( toolTipText ) + STRING_CONSTANT ; }
{ return STRING_CONSTANT + ImageMapUtils . htmlEscape ( toolTipText ) + STRING_CONSTANT ; }
{ return ImageMapUtils . getImageMap ( name , info , toolTipTagFragmentGenerator , urlTagFragmentGenerator ) ; }
{ writer . println ( ImageMapUtils . getImageMap ( name , info , toolTipTagFragmentGenerator , urlTagFragmentGenerator ) ) ; }
ImageMapUtils . writeImageMap ( writer , name , info , toolTipTagFragmentGenerator , new StandardURLTagFragmentGenerator () ) ;
boolean visible = LineUtils . clipLine ( line , dataArea ) ;
visible = LineUtils . clipLine ( state.workingLine , dataArea ) ;
boolean visible = LineUtils . clipLine ( line , dataArea ) ;
Line2D extendedSeparator = LineUtils . extendLine ( separator , this . innerSeparatorExtension , this . outerSeparatorExtension ) ;
Range range = DatasetUtils . findDomainBounds ( this . dataset , false ) ;
CategoryDataset dataset = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset dataset = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset dataset = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
! DatasetUtils . isEmptyOrNull ( dataset )
CategoryDataset dataset = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
{ total = DatasetUtils . calculateStackTotal ( ( TableXYDataset ) dataset , item ) ; value = value / total ; }
if ( this . renderAsPercentages ) { return new Range ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } else { return DatasetUtils . findStackedRangeBounds ( ( TableXYDataset ) dataset ) ; }
Range r = DatasetUtils . findRangeBounds ( dataset , false ) ;
Range r = DatasetUtils . findDomainBounds ( dataset , false ) ;
CategoryDataset dataset = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
! DatasetUtils . isEmptyOrNull ( this . dataset )
Range r = DatasetUtils . findStackedRangeBounds ( dataset , this . seriesToGroupMap ) ;
{ if ( dataset != null ) { return DatasetUtils . findZBounds ( dataset ) ; } else { return null ; } }
Range r = DatasetUtils . findRangeBounds ( dataset , false ) ;
Range r = DatasetUtils . findDomainBounds ( dataset , false ) ;
{ if ( dataset != null ) { return DatasetUtils . findStackedRangeBounds ( ( TableXYDataset ) dataset ) ; } else { return null ; } }
{ if ( includeInterval ) { return this . intervalDelegate . getDomainBounds ( includeInterval ) ; } else { return DatasetUtils . iterateDomainBounds ( this , includeInterval ) ; } }
if ( this . renderAsPercentages ) { return new Range ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } else { return DatasetUtils . findStackedRangeBounds ( dataset ) ; }
{ if ( includeInterval ) { return this . intervalDelegate . getDomainBounds ( includeInterval ) ; } else { return DatasetUtils . iterateDomainBounds ( this , includeInterval ) ; } }
double totalValue = DatasetUtils . calculatePieDatasetTotal ( this . dataset ) ;
! DatasetUtils . isEmptyOrNull ( this . dataset )
if ( this . dataset != null ) { state . setTotal ( DatasetUtils . calculatePieDatasetTotal ( plot . getDataset () ) ) ; }
if ( this . renderAsPercentages ) { return new Range ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } else { return DatasetUtils . findStackedRangeBounds ( dataset , getBase () ) ; }
if ( d != null ) { result = Range . combine ( result , DatasetUtils . findRangeBounds ( d ) ) ; }
! DatasetUtils . isEmptyOrNull ( dataset )
CategoryDataset dataset = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
{ final XYDataset dataset = plot . getDataset ( i ) ; if ( ! DatasetUtils . isEmptyOrNull ( dataset ) ) { return false ; } }
{ if ( dataset != null ) { return DatasetUtils . findRangeBounds ( dataset , true ) ; } else { return null ; } }
Range r = DatasetUtils . findRangeBounds ( d , true ) ;
boolean hasData = ! DatasetUtils . isEmptyOrNull ( currentDataset ) ;
double total = DatasetUtils . calculatePieDatasetTotal ( dataset ) ;
{ this ( DataUtils . createNumberArray2D ( starts ) , DataUtils . createNumberArray2D ( ends ) ) ; }
double total = DataUtils . calculateColumnTotal ( dataset , column ) ;
if ( this . renderAsPercentages ) { total = DataUtils . calculateColumnTotal ( dataset , index , validRows ) ; }
clone.zValues = DataUtils . clone ( this . zValues ) ;
if ( ! DataUtils . equal ( this . zValues , that.zValues ) ) { return false ; }
{ total = DataUtils . calculateColumnTotal ( dataset , column , state . getVisibleSeriesArray () ) ; value = value / total ; }
Millisecond m2 = ( Millisecond ) TestUtils . serialised ( m1 ) ;
XYSeries s2 = ( XYSeries ) TestUtils . serialised ( s1 ) ;
GrayPaintScale g2 = ( GrayPaintScale ) TestUtils . serialised ( g1 ) ;
StandardCategoryURLGenerator g2 = ( StandardCategoryURLGenerator ) TestUtils . serialised ( g1 ) ;
GanttRenderer r2 = ( GanttRenderer ) TestUtils . serialised ( r1 ) ;
XIntervalDataItem item2 = ( XIntervalDataItem ) TestUtils . serialised ( item1 ) ;
CyclicNumberAxis a2 = ( CyclicNumberAxis ) TestUtils . serialised ( a1 ) ;
SymbolAxis a2 = ( SymbolAxis ) TestUtils . serialised ( a1 ) ;
XYBubbleRenderer r2 = ( XYBubbleRenderer ) TestUtils . serialised ( r1 ) ;
PeriodAxisLabelInfo info2 = ( PeriodAxisLabelInfo ) TestUtils . serialised ( info1 ) ;
TimeSeriesCollection c2 = ( TimeSeriesCollection ) TestUtils . serialised ( c1 ) ;
XYIntervalDataItem item2 = ( XYIntervalDataItem ) TestUtils . serialised ( item1 ) ;
XYBlockRenderer r2 = ( XYBlockRenderer ) TestUtils . serialised ( r1 ) ;
XYTitleAnnotation a2 = ( XYTitleAnnotation ) TestUtils . serialised ( a1 ) ;
XYIntervalSeriesCollection c2 = ( XYIntervalSeriesCollection ) TestUtils . serialised ( c1 ) ;
DefaultIntervalCategoryDataset d2 = ( DefaultIntervalCategoryDataset ) TestUtils . serialised ( d1 ) ;
HistogramDataset d2 = ( HistogramDataset ) TestUtils . serialised ( d1 ) ;
PiePlot p2 = ( PiePlot ) TestUtils . serialised ( p1 ) ;
BoxAndWhiskerXYToolTipGenerator g2 = ( BoxAndWhiskerXYToolTipGenerator ) TestUtils . serialised ( g1 ) ;
QuarterDateFormat qf2 = ( QuarterDateFormat ) TestUtils . serialised ( qf1 ) ;
SpiderWebPlot p2 = ( SpiderWebPlot ) TestUtils . serialised ( p1 ) ;
PeriodAxis a2 = ( PeriodAxis ) TestUtils . serialised ( a1 ) ;
ColorBlock b2 = ( ColorBlock ) TestUtils . serialised ( b1 ) ;
StandardTickUnitSource t2 = ( StandardTickUnitSource ) TestUtils . serialised ( t1 ) ;
BarRenderer r2 = ( BarRenderer ) TestUtils . serialised ( r1 ) ;
LegendGraphic g2 = ( LegendGraphic ) TestUtils . serialised ( g1 ) ;
XYSplineRenderer r2 = ( XYSplineRenderer ) TestUtils . serialised ( r1 ) ;
TimePeriodAnchor a2 = ( TimePeriodAnchor ) TestUtils . serialised ( a1 ) ;
StatisticalLineAndShapeRenderer r2 = ( StatisticalLineAndShapeRenderer ) TestUtils . serialised ( r1 ) ;
CategoryLabelPosition p2 = ( CategoryLabelPosition ) TestUtils . serialised ( p1 ) ;
Quarter q2 = ( Quarter ) TestUtils . serialised ( q1 ) ;
DefaultKeyedValues2D kv2D2 = ( DefaultKeyedValues2D ) TestUtils . serialised ( kv2D1 ) ;
Day d2 = ( Day ) TestUtils . serialised ( d1 ) ;
LegendItemCollection c2 = ( LegendItemCollection ) TestUtils . serialised ( c1 ) ;
CustomXYToolTipGenerator g2 = ( CustomXYToolTipGenerator ) TestUtils . serialised ( g1 ) ;
DialCap c2 = ( DialCap ) TestUtils . serialised ( c1 ) ;
BlockBorder b2 = ( BlockBorder ) TestUtils . serialised ( b1 ) ;
LongNeedle n2 = ( LongNeedle ) TestUtils . serialised ( n1 ) ;
GradientBarPainter p2 = ( GradientBarPainter ) TestUtils . serialised ( p1 ) ;
CrosshairOverlay o2 = ( CrosshairOverlay ) TestUtils . serialised ( o1 ) ;
DefaultDrawingSupplier r2 = ( DefaultDrawingSupplier ) TestUtils . serialised ( r1 ) ;
MatrixSeries m2 = ( MatrixSeries ) TestUtils . serialised ( m1 ) ;
XYAreaRenderer2 r2 = ( XYAreaRenderer2 ) TestUtils . serialised ( r1 ) ;
TimeSeriesDataItem item2 = ( TimeSeriesDataItem ) TestUtils . serialised ( item1 ) ;
FastScatterPlot p2 = ( FastScatterPlot ) TestUtils . serialised ( p1 ) ;
CategoryLabelWidthType w2 = ( CategoryLabelWidthType ) TestUtils . serialised ( w1 ) ;
StatisticalBarRenderer r2 = ( StatisticalBarRenderer ) TestUtils . serialised ( r1 ) ;
Week w2 = ( Week ) TestUtils . serialised ( w1 ) ;
PlotOrientation orientation2 = ( PlotOrientation ) TestUtils . serialised ( orientation1 ) ;
KeyedObjects ko2 = ( KeyedObjects ) TestUtils . serialised ( ko1 ) ;
DefaultPolarItemRenderer r2 = ( DefaultPolarItemRenderer ) TestUtils . serialised ( r1 ) ;
VectorRenderer r2 = ( VectorRenderer ) TestUtils . serialised ( r1 ) ;
DefaultHeatMapDataset d2 = ( DefaultHeatMapDataset ) TestUtils . serialised ( d1 ) ;
IntervalCategoryToolTipGenerator g2 = ( IntervalCategoryToolTipGenerator ) TestUtils . serialised ( g1 ) ;
LogarithmicAxis a2 = ( LogarithmicAxis ) TestUtils . serialised ( a1 ) ;
XYPlot p2 = ( XYPlot ) TestUtils . serialised ( p1 ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtils . serialised ( chart ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtils . serialised ( chart ) ;
XYPlot p2 = ( XYPlot ) TestUtils . serialised ( p1 ) ;
XYPlot p2 = ( XYPlot ) TestUtils . serialised ( p1 ) ;
PaintScaleLegend l2 = ( PaintScaleLegend ) TestUtils . serialised ( l1 ) ;
MultipleXYSeriesLabelGenerator g2 = ( MultipleXYSeriesLabelGenerator ) TestUtils . serialised ( g1 ) ;
LayeredBarRenderer r2 = ( LayeredBarRenderer ) TestUtils . serialised ( r1 ) ;
ComparableObjectItem item2 = ( ComparableObjectItem ) TestUtils . serialised ( item1 ) ;
CategoryLabelEntity e2 = ( CategoryLabelEntity ) TestUtils . serialised ( e1 ) ;
DialPointer i2 = ( DialPointer ) TestUtils . serialised ( i1 ) ;
DialPointer i2 = ( DialPointer ) TestUtils . serialised ( i1 ) ;
MarkerAxisBand a2 = ( MarkerAxisBand ) TestUtils . serialised ( a1 ) ;
CategoryLineAnnotation a2 = ( CategoryLineAnnotation ) TestUtils . serialised ( a1 ) ;
MeterPlot p2 = ( MeterPlot ) TestUtils . serialised ( p1 ) ;
MeterPlot p2 = ( MeterPlot ) TestUtils . serialised ( p1 ) ;
DefaultKeyedValues v2 = ( DefaultKeyedValues ) TestUtils . serialised ( v1 ) ;
XYDataItem i2 = ( XYDataItem ) TestUtils . serialised ( i1 ) ;
StandardXYItemLabelGenerator g2 = ( StandardXYItemLabelGenerator ) TestUtils . serialised ( g1 ) ;
DefaultKeyedValue v2 = ( DefaultKeyedValue ) TestUtils . serialised ( v1 ) ;
PolarPlot p2 = ( PolarPlot ) TestUtils . serialised ( p1 ) ;
CompositeTitle t2 = ( CompositeTitle ) TestUtils . serialised ( t1 ) ;
LogFormat f2 = ( LogFormat ) TestUtils . serialised ( f1 ) ;
KeyedObjects2D ko2D2 = ( KeyedObjects2D ) TestUtils . serialised ( ko2D1 ) ;
BoxAndWhiskerToolTipGenerator g2 = ( BoxAndWhiskerToolTipGenerator ) TestUtils . serialised ( g1 ) ;
ShortTextTitle t2 = ( ShortTextTitle ) TestUtils . serialised ( t1 ) ;
ModuloAxis a2 = ( ModuloAxis ) TestUtils . serialised ( a1 ) ;
CategoryTableXYDataset d2 = ( CategoryTableXYDataset ) TestUtils . serialised ( d1 ) ;
Hour h2 = ( Hour ) TestUtils . serialised ( h1 ) ;
TimeSeriesURLGenerator g2 = ( TimeSeriesURLGenerator ) TestUtils . serialised ( g1 ) ;
XYPolygonAnnotation a2 = ( XYPolygonAnnotation ) TestUtils . serialised ( a1 ) ;
CategoryAnchor a2 = ( CategoryAnchor ) TestUtils . serialised ( a1 ) ;
LegendItemEntity e2 = ( LegendItemEntity ) TestUtils . serialised ( e1 ) ;
ItemLabelAnchor a2 = ( ItemLabelAnchor ) TestUtils . serialised ( a1 ) ;
AreaRendererEndType t2 = ( AreaRendererEndType ) TestUtils . serialised ( t1 ) ;
CategoryPointerAnnotation a2 = ( CategoryPointerAnnotation ) TestUtils . serialised ( a1 ) ;
Month m2 = ( Month ) TestUtils . serialised ( m1 ) ;
WaterfallBarRenderer r2 = ( WaterfallBarRenderer ) TestUtils . serialised ( r1 ) ;
PolynomialFunction2D f2 = ( PolynomialFunction2D ) TestUtils . serialised ( f1 ) ;
SimpleTimePeriod p2 = ( SimpleTimePeriod ) TestUtils . serialised ( p1 ) ;
TimeSeries s2 = ( TimeSeries ) TestUtils . serialised ( s1 ) ;
XYBoxAndWhiskerRenderer r2 = ( XYBoxAndWhiskerRenderer ) TestUtils . serialised ( r1 ) ;
StackedAreaRenderer r2 = ( StackedAreaRenderer ) TestUtils . serialised ( r1 ) ;
XYSeriesCollection c2 = ( XYSeriesCollection ) TestUtils . serialised ( c1 ) ;
NumberTickUnit t2 = ( NumberTickUnit ) TestUtils . serialised ( t1 ) ;
XIntervalSeriesCollection c2 = ( XIntervalSeriesCollection ) TestUtils . serialised ( c1 ) ;
PlumNeedle n2 = ( PlumNeedle ) TestUtils . serialised ( n1 ) ;
Range r2 = ( Range ) TestUtils . serialised ( r1 ) ;
MyComparableObjectSeries s2 = ( MyComparableObjectSeries ) TestUtils . serialised ( s1 ) ;
DefaultKeyedValues2DDataset d2 = ( DefaultKeyedValues2DDataset ) TestUtils . serialised ( d1 ) ;
XYLineAndShapeRenderer r2 = ( XYLineAndShapeRenderer ) TestUtils . serialised ( r1 ) ;
ExtendedCategoryAxis a2 = ( ExtendedCategoryAxis ) TestUtils . serialised ( a1 ) ;
ChartRenderingInfo i2 = ( ChartRenderingInfo ) TestUtils . serialised ( i1 ) ;
ChartRenderingInfo i2 = ( ChartRenderingInfo ) TestUtils . serialised ( i1 ) ;
XYErrorRenderer r2 = ( XYErrorRenderer ) TestUtils . serialised ( r1 ) ;
XYErrorRenderer r2 = ( XYErrorRenderer ) TestUtils . serialised ( r1 ) ;
StandardPieSectionLabelGenerator g2 = ( StandardPieSectionLabelGenerator ) TestUtils . serialised ( g1 ) ;
YIntervalDataItem item2 = ( YIntervalDataItem ) TestUtils . serialised ( item1 ) ;
TaskSeriesCollection c2 = ( TaskSeriesCollection ) TestUtils . serialised ( c1 ) ;
OHLCSeriesCollection c2 = ( OHLCSeriesCollection ) TestUtils . serialised ( c1 ) ;
LineFunction2D f2 = ( LineFunction2D ) TestUtils . serialised ( f1 ) ;
DateTitle t2 = ( DateTitle ) TestUtils . serialised ( t1 ) ;
HighLowItemLabelGenerator g2 = ( HighLowItemLabelGenerator ) TestUtils . serialised ( g1 ) ;
StandardCategorySeriesLabelGenerator g2 = ( StandardCategorySeriesLabelGenerator ) TestUtils . serialised ( g1 ) ;
XYDrawableAnnotation a2 = ( XYDrawableAnnotation ) TestUtils . serialised ( a1 ) ;
Minute m2 = ( Minute ) TestUtils . serialised ( m1 ) ;
Crosshair c2 = ( Crosshair ) TestUtils . serialised ( c1 ) ;
AxisLocation location2 = ( AxisLocation ) TestUtils . serialised ( location1 ) ;
TaskSeries s2 = ( TaskSeries ) TestUtils . serialised ( s1 ) ;
PointerNeedle n2 = ( PointerNeedle ) TestUtils . serialised ( n1 ) ;
MinMaxCategoryRenderer r2 = ( MinMaxCategoryRenderer ) TestUtils . serialised ( r1 ) ;
StrokeMap m2 = ( StrokeMap ) TestUtils . serialised ( m1 ) ;
StrokeMap m2 = ( StrokeMap ) TestUtils . serialised ( m1 ) ;
MatrixSeriesCollection c2 = ( MatrixSeriesCollection ) TestUtils . serialised ( c1 ) ;
ThermometerPlot p2 = ( ThermometerPlot ) TestUtils . serialised ( p1 ) ;
ThermometerPlot p2 = ( ThermometerPlot ) TestUtils . serialised ( p1 ) ;
CustomPieURLGenerator g2 = ( CustomPieURLGenerator ) TestUtils . serialised ( g1 ) ;
StandardChartTheme t2 = ( StandardChartTheme ) TestUtils . serialised ( t1 ) ;
DateRange r2 = ( DateRange ) TestUtils . serialised ( r1 ) ;
BoxAndWhiskerItem i2 = ( BoxAndWhiskerItem ) TestUtils . serialised ( i1 ) ;
StandardEntityCollection c2 = ( StandardEntityCollection ) TestUtils . serialised ( c1 ) ;
DefaultCategoryDataset d2 = ( DefaultCategoryDataset ) TestUtils . serialised ( d1 ) ;
XYItemEntity e2 = ( XYItemEntity ) TestUtils . serialised ( e1 ) ;
ClusteredXYBarRenderer r2 = ( ClusteredXYBarRenderer ) TestUtils . serialised ( r1 ) ;
NumberAxis a2 = ( NumberAxis ) TestUtils . serialised ( a1 ) ;
ItemLabelPosition p2 = ( ItemLabelPosition ) TestUtils . serialised ( p1 ) ;
TextTitle t2 = ( TextTitle ) TestUtils . serialised ( t1 ) ;
LogAxis a2 = ( LogAxis ) TestUtils . serialised ( a1 ) ;
XYDifferenceRenderer r2 = ( XYDifferenceRenderer ) TestUtils . serialised ( r1 ) ;
DefaultMultiValueCategoryDataset d2 = ( DefaultMultiValueCategoryDataset ) TestUtils . serialised ( d1 ) ;
Year y2 = ( Year ) TestUtils . serialised ( y1 ) ;
CompassPlot p2 = ( CompassPlot ) TestUtils . serialised ( p1 ) ;
DeviationRenderer r2 = ( DeviationRenderer ) TestUtils . serialised ( r1 ) ;
PieLabelRecord p2 = ( PieLabelRecord ) TestUtils . serialised ( p1 ) ;
StandardXYSeriesLabelGenerator g2 = ( StandardXYSeriesLabelGenerator ) TestUtils . serialised ( g1 ) ;
CustomXYURLGenerator g2 = ( CustomXYURLGenerator ) TestUtils . serialised ( g1 ) ;
XYCoordinate v2 = ( XYCoordinate ) TestUtils . serialised ( v1 ) ;
StackedBarRenderer r2 = ( StackedBarRenderer ) TestUtils . serialised ( r1 ) ;
IntervalBarRenderer r2 = ( IntervalBarRenderer ) TestUtils . serialised ( r1 ) ;
CategoryToPieDataset d2 = ( CategoryToPieDataset ) TestUtils . serialised ( d1 ) ;
CategoryItemEntity e2 = ( CategoryItemEntity ) TestUtils . serialised ( e1 ) ;
Second s2 = ( Second ) TestUtils . serialised ( s1 ) ;
StackedXYAreaRenderer2 r2 = ( StackedXYAreaRenderer2 ) TestUtils . serialised ( r1 ) ;
YInterval i2 = ( YInterval ) TestUtils . serialised ( i1 ) ;
VectorDataItem v2 = ( VectorDataItem ) TestUtils . serialised ( v1 ) ;
MeanAndStandardDeviation m2 = ( MeanAndStandardDeviation ) TestUtils . serialised ( m1 ) ;
StackedXYBarRenderer r2 = ( StackedXYBarRenderer ) TestUtils . serialised ( r1 ) ;
DefaultTableXYDataset d2 = ( DefaultTableXYDataset ) TestUtils . serialised ( d1 ) ;
TimePeriodValuesCollection c2 = ( TimePeriodValuesCollection ) TestUtils . serialised ( c1 ) ;
SlidingCategoryDataset d2 = ( SlidingCategoryDataset ) TestUtils . serialised ( d1 ) ;
StandardXYZToolTipGenerator g2 = ( StandardXYZToolTipGenerator ) TestUtils . serialised ( g1 ) ;
StandardPieToolTipGenerator g2 = ( StandardPieToolTipGenerator ) TestUtils . serialised ( g1 ) ;
XYInterval i2 = ( XYInterval ) TestUtils . serialised ( i1 ) ;
DialValueIndicator i2 = ( DialValueIndicator ) TestUtils . serialised ( i1 ) ;
XYIntervalSeries s2 = ( XYIntervalSeries ) TestUtils . serialised ( s1 ) ;
CombinedRangeXYPlot plot2 = ( CombinedRangeXYPlot ) TestUtils . serialised ( plot1 ) ;
EmptyBlock b2 = ( EmptyBlock ) TestUtils . serialised ( b1 ) ;
HistogramBin b2 = ( HistogramBin ) TestUtils . serialised ( b1 ) ;
LineAndShapeRenderer r2 = ( LineAndShapeRenderer ) TestUtils . serialised ( r1 ) ;
DefaultBoxAndWhiskerCategoryDataset d2 = ( DefaultBoxAndWhiskerCategoryDataset ) TestUtils . serialised ( d1 ) ;
DefaultCategoryItemRenderer r2 = ( DefaultCategoryItemRenderer ) TestUtils . serialised ( r1 ) ;
StandardDialRange r2 = ( StandardDialRange ) TestUtils . serialised ( r1 ) ;
AreaRenderer r2 = ( AreaRenderer ) TestUtils . serialised ( r1 ) ;
DateTick t2 = ( DateTick ) TestUtils . serialised ( t1 ) ;
CategoryLabelPositions p2 = ( CategoryLabelPositions ) TestUtils . serialised ( p1 ) ;
LevelRenderer r2 = ( LevelRenderer ) TestUtils . serialised ( r1 ) ;
ScatterRenderer r2 = ( ScatterRenderer ) TestUtils . serialised ( r1 ) ;
StandardCategoryToolTipGenerator g2 = ( StandardCategoryToolTipGenerator ) TestUtils . serialised ( g1 ) ;
KeyedObject ko2 = ( KeyedObject ) TestUtils . serialised ( ko1 ) ;
LabelBlock b2 = ( LabelBlock ) TestUtils . serialised ( b1 ) ;
XYShapeAnnotation a2 = ( XYShapeAnnotation ) TestUtils . serialised ( a1 ) ;
DefaultStatisticalCategoryDataset d2 = ( DefaultStatisticalCategoryDataset ) TestUtils . serialised ( d1 ) ;
DefaultStatisticalCategoryDataset d2 = ( DefaultStatisticalCategoryDataset ) TestUtils . serialised ( d1 ) ;
XYStepAreaRenderer r2 = ( XYStepAreaRenderer ) TestUtils . serialised ( r1 ) ;
WindNeedle n2 = ( WindNeedle ) TestUtils . serialised ( n1 ) ;
XYLineAnnotation a2 = ( XYLineAnnotation ) TestUtils . serialised ( a1 ) ;
StandardCategoryItemLabelGenerator g2 = ( StandardCategoryItemLabelGenerator ) TestUtils . serialised ( g1 ) ;
YIntervalSeries s2 = ( YIntervalSeries ) TestUtils . serialised ( s1 ) ;
LegendItem item2 = ( LegendItem ) TestUtils . serialised ( item1 ) ;
item2 = ( LegendItem ) TestUtils . serialised ( item1 ) ;
KeyedValuesDataset d2 = ( KeyedValuesDataset ) TestUtils . serialised ( d1 ) ;
XYBarDataset bd2 = ( XYBarDataset ) TestUtils . serialised ( bd1 ) ;
OHLCDataItem i2 = ( OHLCDataItem ) TestUtils . serialised ( i1 ) ;
DefaultKeyedValueDataset d2 = ( DefaultKeyedValueDataset ) TestUtils . serialised ( d1 ) ;
Task t2 = ( Task ) TestUtils . serialised ( t1 ) ;
CandlestickRenderer r2 = ( CandlestickRenderer ) TestUtils . serialised ( r1 ) ;
MiddlePinNeedle n2 = ( MiddlePinNeedle ) TestUtils . serialised ( n1 ) ;
PowerFunction2D f2 = ( PowerFunction2D ) TestUtils . serialised ( f1 ) ;
XYShapeRenderer r2 = ( XYShapeRenderer ) TestUtils . serialised ( r1 ) ;
CategoryAxis a2 = ( CategoryAxis ) TestUtils . serialised ( a1 ) ;
OHLC i2 = ( OHLC ) TestUtils . serialised ( i1 ) ;
XIntervalSeries s2 = ( XIntervalSeries ) TestUtils . serialised ( s1 ) ;
BarRenderer r2 = ( BarRenderer ) TestUtils . serialised ( r1 ) ;
ArrowNeedle n2 = ( ArrowNeedle ) TestUtils . serialised ( n1 ) ;
SimpleHistogramDataset d2 = ( SimpleHistogramDataset ) TestUtils . serialised ( d1 ) ;
YWithXInterval i2 = ( YWithXInterval ) TestUtils . serialised ( i1 ) ;
EmptyBlock b2 = ( EmptyBlock ) TestUtils . serialised ( b1 ) ;
ArcDialFrame f2 = ( ArcDialFrame ) TestUtils . serialised ( f1 ) ;
XYTaskDataset d2 = ( XYTaskDataset ) TestUtils . serialised ( d1 ) ;
Axis a2 = ( Axis ) TestUtils . serialised ( a1 ) ;
XYTextAnnotation a2 = ( XYTextAnnotation ) TestUtils . serialised ( a1 ) ;
XYPointerAnnotation a2 = ( XYPointerAnnotation ) TestUtils . serialised ( a1 ) ;
CustomCategoryURLGenerator g2 = ( CustomCategoryURLGenerator ) TestUtils . serialised ( g1 ) ;
StandardPieURLGenerator g2 = ( StandardPieURLGenerator ) TestUtils . serialised ( g1 ) ;
IntervalCategoryItemLabelGenerator g2 = ( IntervalCategoryItemLabelGenerator ) TestUtils . serialised ( g1 ) ;
LegendTitle t2 = ( LegendTitle ) TestUtils . serialised ( t1 ) ;
VectorSeriesCollection c2 = ( VectorSeriesCollection ) TestUtils . serialised ( c1 ) ;
WindItemRenderer r2 = ( WindItemRenderer ) TestUtils . serialised ( r1 ) ;
HighLowRenderer r2 = ( HighLowRenderer ) TestUtils . serialised ( r1 ) ;
DefaultHighLowDataset d2 = ( DefaultHighLowDataset ) TestUtils . serialised ( d1 ) ;
VectorSeries s2 = ( VectorSeries ) TestUtils . serialised ( s1 ) ;
StandardXYBarPainter p2 = ( StandardXYBarPainter ) TestUtils . serialised ( p1 ) ;
TimeTableXYDataset d2 = ( TimeTableXYDataset ) TestUtils . serialised ( d1 ) ;
OHLCItem item2 = ( OHLCItem ) TestUtils . serialised ( item1 ) ;
TickLabelEntity e2 = ( TickLabelEntity ) TestUtils . serialised ( e1 ) ;
StackedXYAreaRenderer r2 = ( StackedXYAreaRenderer ) TestUtils . serialised ( r1 ) ;
GridArrangement f2 = ( GridArrangement ) TestUtils . serialised ( f1 ) ;
StandardBarPainter p2 = ( StandardBarPainter ) TestUtils . serialised ( p1 ) ;
Vector v2 = ( Vector ) TestUtils . serialised ( v1 ) ;
TickUnits t2 = ( TickUnits ) TestUtils . serialised ( t1 ) ;
CombinedDomainXYPlot plot2 = ( CombinedDomainXYPlot ) TestUtils . serialised ( plot1 ) ;
DefaultBoxAndWhiskerXYDataset d2 = ( DefaultBoxAndWhiskerXYDataset ) TestUtils . serialised ( d1 ) ;
LineNeedle n2 = ( LineNeedle ) TestUtils . serialised ( n1 ) ;
XYStepRenderer r2 = ( XYStepRenderer ) TestUtils . serialised ( r1 ) ;
CategoryTick t2 = ( CategoryTick ) TestUtils . serialised ( t1 ) ;
YIntervalSeriesCollection c2 = ( YIntervalSeriesCollection ) TestUtils . serialised ( c1 ) ;
DateTickUnit a2 = ( DateTickUnit ) TestUtils . serialised ( a1 ) ;
RingPlot p2 = ( RingPlot ) TestUtils . serialised ( p1 ) ;
LineBorder b2 = ( LineBorder ) TestUtils . serialised ( b1 ) ;
PaintMap m2 = ( PaintMap ) TestUtils . serialised ( m1 ) ;
PaintMap m2 = ( PaintMap ) TestUtils . serialised ( m1 ) ;
ShipNeedle n2 = ( ShipNeedle ) TestUtils . serialised ( n1 ) ;
DateAxis a2 = ( DateAxis ) TestUtils . serialised ( a1 ) ;
FixedMillisecond m2 = ( FixedMillisecond ) TestUtils . serialised ( m1 ) ;
KeyToGroupMap m2 = ( KeyToGroupMap ) TestUtils . serialised ( m1 ) ;
DateTickMarkPosition p2 = ( DateTickMarkPosition ) TestUtils . serialised ( p1 ) ;
TimePeriodValues s2 = ( TimePeriodValues ) TestUtils . serialised ( s1 ) ;
GradientXYBarPainter p2 = ( GradientXYBarPainter ) TestUtils . serialised ( p1 ) ;
CombinedDomainCategoryPlot plot2 = ( CombinedDomainCategoryPlot ) TestUtils . serialised ( plot1 ) ;
IntervalXYDelegate d2 = ( IntervalXYDelegate ) TestUtils . serialised ( d1 ) ;
FlowArrangement f2 = ( FlowArrangement ) TestUtils . serialised ( f1 ) ;
NormalDistributionFunction2D f2 = ( NormalDistributionFunction2D ) TestUtils . serialised ( f1 ) ;
MeterInterval m2 = ( MeterInterval ) TestUtils . serialised ( m1 ) ;
SubCategoryAxis a2 = ( SubCategoryAxis ) TestUtils . serialised ( a1 ) ;
SymbolicXYItemLabelGenerator g2 = ( SymbolicXYItemLabelGenerator ) TestUtils . serialised ( g1 ) ;
OHLCSeries s2 = ( OHLCSeries ) TestUtils . serialised ( s1 ) ;
StandardXYToolTipGenerator g2 = ( StandardXYToolTipGenerator ) TestUtils . serialised ( g1 ) ;
XYAreaRenderer r2 = ( XYAreaRenderer ) TestUtils . serialised ( r1 ) ;
SimpleHistogramBin b2 = ( SimpleHistogramBin ) TestUtils . serialised ( b1 ) ;
StandardDialFrame f2 = ( StandardDialFrame ) TestUtils . serialised ( f1 ) ;
DefaultPieDataset d2 = ( DefaultPieDataset ) TestUtils . serialised ( d1 ) ;
IntervalMarker m2 = ( IntervalMarker ) TestUtils . serialised ( m1 ) ;
BubbleXYItemLabelGenerator g2 = ( BubbleXYItemLabelGenerator ) TestUtils . serialised ( g1 ) ;
DefaultOHLCDataset d2 = ( DefaultOHLCDataset ) TestUtils . serialised ( d1 ) ;
CategoryTextAnnotation a2 = ( CategoryTextAnnotation ) TestUtils . serialised ( a1 ) ;
XYDotRenderer r2 = ( XYDotRenderer ) TestUtils . serialised ( r1 ) ;
ValueMarker m2 = ( ValueMarker ) TestUtils . serialised ( m1 ) ;
ValueMarker m2 = ( ValueMarker ) TestUtils . serialised ( m1 ) ;
CategoryPlot p2 = ( CategoryPlot ) TestUtils . serialised ( p1 ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtils . serialised ( chart ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtils . serialised ( chart ) ;
CategoryPlot p2 = ( CategoryPlot ) TestUtils . serialised ( p1 ) ;
CategoryPlot p2 = ( CategoryPlot ) TestUtils . serialised ( p1 ) ;
GroupedStackedBarRenderer r2 = ( GroupedStackedBarRenderer ) TestUtils . serialised ( r1 ) ;
PieSectionEntity e2 = ( PieSectionEntity ) TestUtils . serialised ( e1 ) ;
BoxAndWhiskerRenderer r2 = ( BoxAndWhiskerRenderer ) TestUtils . serialised ( r1 ) ;
CombinedRangeCategoryPlot plot2 = ( CombinedRangeCategoryPlot ) TestUtils . serialised ( plot1 ) ;
DefaultTableXYDataset d2 = ( DefaultTableXYDataset ) TestUtils . serialised ( d1 ) ;
PiePlot3D p2 = ( PiePlot3D ) TestUtils . serialised ( p1 ) ;
DialPlot p2 = ( DialPlot ) TestUtils . serialised ( p1 ) ;
BorderArrangement b2 = ( BorderArrangement ) TestUtils . serialised ( b1 ) ;
assertFalse ( TestUtils . containsInstanceOf ( ec . getEntities () , XYItemEntity . class ) ) ;
StandardXYItemRenderer r2 = ( StandardXYItemRenderer ) TestUtils . serialised ( r1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtils . serialised ( c1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtils . serialised ( c1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtils . serialised ( c1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtils . serialised ( c1 ) ;
YIntervalRenderer r2 = ( YIntervalRenderer ) TestUtils . serialised ( r1 ) ;
DomainOrder d2 = ( DomainOrder ) TestUtils . serialised ( d1 ) ;
SlidingGanttCategoryDataset d2 = ( SlidingGanttCategoryDataset ) TestUtils . serialised ( d1 ) ;
PinNeedle n2 = ( PinNeedle ) TestUtils . serialised ( n1 ) ;
PlotRenderingInfo p2 = ( PlotRenderingInfo ) TestUtils . serialised ( p1 ) ;
XYBarRenderer r2 = ( XYBarRenderer ) TestUtils . serialised ( r1 ) ;
XYBarRenderer r2 = ( XYBarRenderer ) TestUtils . serialised ( r1 ) ;
CategoryMarker m2 = ( CategoryMarker ) TestUtils . serialised ( m1 ) ;
StandardXYURLGenerator g2 = ( StandardXYURLGenerator ) TestUtils . serialised ( g1 ) ;
FlowArrangement f2 = ( FlowArrangement ) TestUtils . serialised ( f1 ) ;
XYBoxAnnotation a2 = ( XYBoxAnnotation ) TestUtils . serialised ( a1 ) ;
DatasetGroup g2 = ( DatasetGroup ) TestUtils . serialised ( g1 ) ;
CategoryStepRenderer r2 = ( CategoryStepRenderer ) TestUtils . serialised ( r1 ) ;
BlockContainer c2 = ( BlockContainer ) TestUtils . serialised ( c1 ) ;
MultiplePiePlot p2 = ( MultiplePiePlot ) TestUtils . serialised ( p1 ) ;
TimePeriodValue tpv2 = ( TimePeriodValue ) TestUtils . serialised ( tpv1 ) ;
RangeType r2 = ( RangeType ) TestUtils . serialised ( r1 ) ;
MonthDateFormat mf2 = ( MonthDateFormat ) TestUtils . serialised ( mf1 ) ;
Rectangle2D area
float s
float s
float s
Shape shape
ObjectInputStream stream
ObjectOutputStream stream
entities != null && ShapeUtils . isPointInRect ( dataArea , x , y )
entities != null && ShapeUtils . isPointInRect ( dataArea , xx , yy )
entities != null && ShapeUtils . isPointInRect ( dataArea , xx , yy )
Graphics2D g2
TextFragment fragment
TextFragment fragment
public TextLine ( String text ) { this ( text , TextFragment.DEFAULT_FONT ) ; }
int month
int code
boolean shortened
int weekday
String title
Object o
String name
Font font
Font font
Font font
Font font
Font font
double height
double height
double width
double width
double width
double width
double width
double width
double height
double height
double height
double height
int d
int serial
String name
String name
Dialog dialog
Window frame
Window frame
String name
double height
double width
int maxrows
TextLine line
String name
int index
ObjectOutputStream stream
int index
public ObjectList ( int initialCapacity ) { super ( initialCapacity ) ; }
String name
Object object
String classLoaderSource
RectangleEdge edge
String name
int targetDOW
int targetDOW
int targetDOW
int serial
int relative
int count
String name
int index
int index
String name
Number value
String name
ObjectInputStream stream
ObjectOutputStream stream
Object object
protected AbstractObjectList ( int initialCapacity ) { this ( initialCapacity , initialCapacity ) ; }
String name
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( axis , STRING_CONSTANT ) ; this . rangeAxis = axis ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( axis , STRING_CONSTANT ) ; this . domainAxis = axis ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( location , STRING_CONSTANT ) ; this . shapeLocation = location ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . shapeAnchor = anchor ; }
{ Args . nullNotPermitted ( transformer , STRING_CONSTANT ) ; this . fillPaintTransformer = transformer ; }
{ Args . nullNotPermitted ( icon , STRING_CONSTANT ) ; this . minIcon = icon ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( icon , STRING_CONSTANT ) ; this . maxIcon = icon ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( icon , STRING_CONSTANT ) ; this . objectIcon = icon ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . groupStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . groupPaint = paint ; fireChangeEvent () ; }
{ super ( size , minorTickCount ) ; Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . formatter = formatter ; }
{ super ( size ) ; Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . formatter = formatter ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . fillPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( order , STRING_CONSTANT ) ;
Args . nullNotPermitted ( locale , STRING_CONSTANT ) ;
Args . nullNotPermitted ( order , STRING_CONSTANT ) ;
Args . nullNotPermitted ( theme , STRING_CONSTANT ) ;
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( state , STRING_CONSTANT ) ;
Args . nullNotPermitted ( categories , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; if ( this . categoryLabelURLs . remove ( category ) != null ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; return ( String ) this . categoryLabelURLs . get ( category ) ; }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; this . categoryLabelURLs . put ( category , url ) ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; if ( this . categoryLabelToolTips . remove ( category ) != null ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; return ( String ) this . categoryLabelToolTips . get ( category ) ; }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; this . categoryLabelToolTips . put ( category , tooltip ) ; fireChangeEvent () ; }
Args . nullNotPermitted ( category , STRING_CONSTANT ) ;
Args . nullNotPermitted ( category , STRING_CONSTANT ) ;
Args . nullNotPermitted ( category , STRING_CONSTANT ) ;
Args . nullNotPermitted ( category , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( positions , STRING_CONSTANT ) ; this . categoryLabelPositions = positions ; fireChangeEvent () ; }
{ super ( formatString , xFormat , yFormat ) ; Args . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zDateFormat = zFormat ; }
{ super ( formatString , xFormat , yFormat ) ; Args . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zFormat = zFormat ; }
{ Args . nullNotPermitted ( name , STRING_CONSTANT ) ; this . name = name ; }
{ Args . nullNotPermitted ( id , STRING_CONSTANT ) ; this . id = id ; }
Args . nullNotPermitted ( tickType , STRING_CONSTANT ) ;
{ super ( formatString , xFormat , yFormat ) ; Args . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zDateFormat = zFormat ; }
{ super ( formatString , xFormat , yFormat ) ; Args . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zFormat = zFormat ; }
Args . nullNotPermitted ( alignment , STRING_CONSTANT ) ;
Args . nullNotPermitted ( alignment , STRING_CONSTANT ) ;
Args . nullNotPermitted ( position , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( array , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( columnKey , STRING_CONSTANT ) ; return getCategoryIndex ( columnKey ) ; }
Args . nullNotPermitted ( categoryKeys , STRING_CONSTANT ) ;
Args . nullNotPermitted ( seriesKeys , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . categoryAnchor = anchor ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; this . category = category ; fireAnnotationChanged () ; }
Args . nullNotPermitted ( category , STRING_CONSTANT ) ;
{ super ( area , toolTipText , urlText ) ; Args . nullNotPermitted ( plot , STRING_CONSTANT ) ; this . plot = plot ; }
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendShape = shape ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( prefix , STRING_CONSTANT ) ; this . prefix = prefix ; }
Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . foregroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . backgroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . chartMouseListeners . add ( ChartMouseListener . class , listener ) ; }
Args . nullNotPermitted ( file , STRING_CONSTANT ) ;
Args . nullNotPermitted ( overlay , STRING_CONSTANT ) ;
Args . nullNotPermitted ( overlay , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . zoomFillPaint = paint ; }
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . textAnchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . valueAnchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( insets , STRING_CONSTANT ) ; this . insets = insets ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . backgroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . formatter = formatter ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( value , STRING_CONSTANT ) ; this . templateValue = value ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . frameAnchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendItemShape = shape ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . aggregatedItemsPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; this . aggregatedItemsKey = key ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . dataExtractOrder = order ; fireChangeEvent () ; }
Args . nullNotPermitted ( pieChart , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeCrosshairPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeCrosshairStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainCrosshairPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainCrosshairStroke = stroke ; fireChangeEvent () ; }
Args . nullNotPermitted ( axisIndex , STRING_CONSTANT ) ;
Args . nullNotPermitted ( axisIndex , STRING_CONSTANT ) ;
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( origin , STRING_CONSTANT ) ; this . quadrantOrigin = origin ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeZeroBaselinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeZeroBaselineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainZeroBaselinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainZeroBaselineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeMinorGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeMinorGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainMinorGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainMinorGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . seriesRenderingOrder = order ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . datasetRenderingOrder = order ; fireChangeEvent () ; }
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . axisOffset = offset ; fireChangeEvent () ; }
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
Args . nullNotPermitted ( period , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( format , STRING_CONSTANT ) ; this . formatPattern = format ; }
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . remove ( ChartChangeListener . class , listener ) ; }
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . add ( ChartChangeListener . class , listener ) ; }
Args . nullNotPermitted ( subtitle , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subtitle , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . padding = padding ; notifyListeners ( new ChartChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( renderingHints , STRING_CONSTANT ) ; this . renderingHints = renderingHints ; fireChartChanged () ; }
Args . nullNotPermitted ( plot , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( transformer , STRING_CONSTANT ) ; this . gradientTransformer = transformer ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( area , STRING_CONSTANT ) ; this . legendArea = area ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . barPainter = painter ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( bar , STRING_CONSTANT ) ; this . legendBar = bar ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( painter , STRING_CONSTANT ) ; XYBarRenderer.defaultBarPainter = painter ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . arrowPaint = paint ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . arrowStroke = stroke ; fireAnnotationChanged () ; }
Args . nullNotPermitted ( state , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . subLabelPaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . subLabelFont = font ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( subCategory , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( period , STRING_CONSTANT ) ; this . period = period ; this . value = value ; }
Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ;
Args . nullNotPermitted ( image , STRING_CONSTANT ) ;
Args . nullNotPermitted ( columnKey , STRING_CONSTANT ) ;
Args . nullNotPermitted ( rowKey , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . columnKeys . indexOf ( key ) ; }
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( seriesKey , STRING_CONSTANT ) ; this . seriesKey = seriesKey ; this . itemIndex = itemIndex ; }
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( format , STRING_CONSTANT ) ; this . formatter = format ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . labelTextAnchor = anchor ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( adj , STRING_CONSTANT ) ; this . labelOffsetType = adj ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . labelOffset = offset ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . labelAnchor = anchor ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( color , STRING_CONSTANT ) ; this . labelBackgroundColor = color ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ super ( source ) ; Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ; this . annotation = annotation ; }
Args . nullNotPermitted ( hour , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( day , STRING_CONSTANT ) ;
Args . nullNotPermitted ( polygon , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; this . category2 = category ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; this . category1 = category ; fireAnnotationChanged () ; }
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( record , STRING_CONSTANT ) ; this . labels . add ( record ) ; }
{ Args . nullNotPermitted ( area , STRING_CONSTANT ) ; this . legendArea = area ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . artifactPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( scale , STRING_CONSTANT ) ; this . paintScale = scale ; fireChangeEvent () ; }
Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; this . key = key ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( f , STRING_CONSTANT ) ; factory = f ; }
Args . nullNotPermitted ( c , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( bounds , STRING_CONSTANT ) ; this . bounds = bounds ; }
{ Args . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . padding = padding ; }
{ Args . nullNotPermitted ( frame , STRING_CONSTANT ) ; this . frame = frame ; }
{ Args . nullNotPermitted ( margin , STRING_CONSTANT ) ; this . margin = margin ; }
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . listenerList . remove ( RendererChangeListener . class , listener ) ; }
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . listenerList . add ( RendererChangeListener . class , listener ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . defaultLegendTextFont = font ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( position , STRING_CONSTANT ) ; this . defaultNegativeItemLabelPosition = position ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( position , STRING_CONSTANT ) ; this . defaultPositiveItemLabelPosition = position ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultItemLabelPaint = paint ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; setDefaultItemLabelFont ( font , true ) ; }
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . defaultShape = shape ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . defaultOutlineStroke = stroke ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . defaultStroke = stroke ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultOutlinePaint = paint ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultFillPaint = paint ; if ( notify ) { fireChangeEvent () ; } }
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandAlternatePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ; Range result = iterateToFindZBounds ( dataset , visibleSeriesKeys , xRange , includeInterval ) ; return result ; }
{ Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ; Range result = iterateZBounds ( dataset , includeInterval ) ; return result ; }
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( input , STRING_CONSTANT ) ;
Args . nullNotPermitted ( input , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; this . key = key ; this . value = value ; }
Args . nullNotPermitted ( fillType , STRING_CONSTANT ) ;
Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( renderer , STRING_CONSTANT ) ;
Args . nullNotPermitted ( renderer , STRING_CONSTANT ) ;
Args . nullNotPermitted ( plot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( chart , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( supplier , STRING_CONSTANT ) ; this . drawingSupplier = supplier ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandAlternatePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . errorIndicatorPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . thermometerPaint = paint ; }
{ Args . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . xyBarPainter = painter ; }
{ Args . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . barPainter = painter ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . shadowPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . itemLabelPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickLabelPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . axisLabelPaint = paint ; }
{ Args . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . axisOffset = offset ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . crosshairPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . baselinePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelLinkPaint = paint ; }
{ Args . nullNotPermitted ( style , STRING_CONSTANT ) ; this . labelLinkStyle = style ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . plotOutlinePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . plotBackgroundPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . legendItemPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . legendBackgroundPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . chartBackgroundPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . subtitlePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . titlePaint = paint ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . smallFont = font ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . regularFont = font ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . largeFont = font ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . extraLargeFont = font ; }
Args . nullNotPermitted ( name , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . labelGenerator = generator ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendItemShape = shape ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . baseSeriesOutlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . baseSeriesOutlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . baseSeriesPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . axisLineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . axisLinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( direction , STRING_CONSTANT ) ; this . direction = direction ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . dataExtractOrder = order ; fireChangeEvent () ; }
Args . nullNotPermitted ( extract , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( task , STRING_CONSTANT ) ; this . tasks . add ( task ) ; fireSeriesChanged () ; }
{ Args . nullNotPermitted ( entity , STRING_CONSTANT ) ; this . entities . add ( entity ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . negativeBarPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . positiveBarPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . lastBarPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . firstBarPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( map , STRING_CONSTANT ) ; this . seriesToGroupMap = map ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( container , STRING_CONSTANT ) ; this . container = container ; }
{ Args . nullNotPermitted ( container , STRING_CONSTANT ) ; this . container = container ; this . backgroundPaint = null ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . guideLineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . guideLinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( scale , STRING_CONSTANT ) ; this . paintScale = scale ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . roseHighlightPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . roseCenterPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rosePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; fireChangeEvent () ; }
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . shadowPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . barPainter = painter ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( painter , STRING_CONSTANT ) ; BarRenderer.defaultBarPainter = painter ; }
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . legendItemLabelGenerator = generator ; fireChangeEvent () ; }
Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( interval , STRING_CONSTANT ) ; this . intervals . add ( interval ) ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . valuePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . valueFont = font ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( format , STRING_CONSTANT ) ; this . tickLabelFormat = format ; fireChangeEvent () ; }
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . needlePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( range , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . shape = shape ; fireChangeEvent () ; }
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( series , STRING_CONSTANT ) ; return this . data . indexOf ( series ) ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( values , STRING_CONSTANT ) ;
Args . nullNotPermitted ( values , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( values , STRING_CONSTANT ) ;
Args . nullNotPermitted ( values , STRING_CONSTANT ) ;
Args . nullNotPermitted ( values , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . tickLabelFormatter = formatter ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickLabelPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . tickLabelFont = font ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . minorTickStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . minorTickPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . majorTickStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . majorTickPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . incompletePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . completePaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( alignment , STRING_CONSTANT ) ; this . textAlignment = alignment ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( text , STRING_CONSTANT ) ;
Args . nullNotPermitted ( location , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . secondFormatter = formatter ; }
{ Args . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . secondSuffix = suffix ; }
{ Args . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . minuteSuffix = suffix ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . minuteFormatter = formatter ; }
{ Args . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . hourSuffix = suffix ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . hourFormatter = formatter ; }
{ Args . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . daySuffix = suffix ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . dayFormatter = formatter ; }
{ Args . nullNotPermitted ( prefix , STRING_CONSTANT ) ; this . positivePrefix = prefix ; }
Args . nullNotPermitted ( date , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( type , STRING_CONSTANT ) ; this . endType = type ; fireChangeEvent () ; }
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( tasks , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . mercuryPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . valueFormat = formatter ; fireChangeEvent () ; }
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( f , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . padding = padding ; fireChangeEvent () ; }
Args . nullNotPermitted ( axis , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( base , STRING_CONSTANT ) ;
Args . nullNotPermitted ( base , STRING_CONSTANT ) ;
Args . nullNotPermitted ( range , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . rotationAnchor = anchor ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . textAnchor = anchor ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( text , STRING_CONSTANT ) ; this . text = text ; fireAnnotationChanged () ; }
Args . nullNotPermitted ( text , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . minorTickMarkPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . minorTickMarkStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( c , STRING_CONSTANT ) ; this . minorTickTimePeriodClass = c ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( c , STRING_CONSTANT ) ; this . majorTickTimePeriodClass = c ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( c , STRING_CONSTANT ) ; this . autoRangeTimePeriodClass = c ; fireChangeEvent () ; }
Args . nullNotPermitted ( zone , STRING_CONSTANT ) ;
Args . nullNotPermitted ( last , STRING_CONSTANT ) ;
Args . nullNotPermitted ( first , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; this . key = key ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . sublabelPaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . sublabelFont = font ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( radialAxis , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( composite , STRING_CONSTANT ) ; this . fillComposite = composite ; fireChangeEvent () ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( zone , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( insets , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . noDataMessagePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . noDataMessageFont = font ; fireChangeEvent () ; }
Args . nullNotPermitted ( shape , STRING_CONSTANT ) ;
Args . nullNotPermitted ( rectangle , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( area , STRING_CONSTANT ) ; this . area = area ; }
Args . nullNotPermitted ( area , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( thresholdType , STRING_CONSTANT ) ; this . gapThresholdType = thresholdType ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . foregroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . backgroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
Args . nullNotPermitted ( unit , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( rangeType , STRING_CONSTANT ) ; this . rangeType = rangeType ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( state , STRING_CONSTANT ) ;
Args . nullNotPermitted ( state , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickMarkPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ;
Args . nullNotPermitted ( insets , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickLabelPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . axisLineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . axisLinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( location , STRING_CONSTANT ) ; this . labelLocation = location ; fireChangeEvent () ; }
Args . nullNotPermitted ( insets , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( font , STRING_CONSTANT ) ;
Args . nullNotPermitted ( rect , STRING_CONSTANT ) ;
Args . nullNotPermitted ( scale , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( pointer , STRING_CONSTANT ) ; return this . pointers . indexOf ( pointer ) ; }
Args . nullNotPermitted ( pointer , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( layer , STRING_CONSTANT ) ; return this . layers . indexOf ( layer ) ; }
Args . nullNotPermitted ( layer , STRING_CONSTANT ) ;
Args . nullNotPermitted ( frame , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( t , STRING_CONSTANT ) ; this . gradientPaintTransformer = t ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
{ super ( area , toolTipText , urlText ) ; Args . nullNotPermitted ( title , STRING_CONSTANT ) ; this . title = title ; }
Args . nullNotPermitted ( edge , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( color , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( range , STRING_CONSTANT ) ; setRange ( Range . expand ( range , getLowerMargin () , getUpperMargin () ) , turnOffAutoRange , notify ) ; }
Args . nullNotPermitted ( range , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( range , STRING_CONSTANT ) ; this . defaultAutoRange = range ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . rightArrow = arrow ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . leftArrow = arrow ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . downArrow = arrow ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . upArrow = arrow ; fireChangeEvent () ; }
Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ;
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( font , STRING_CONSTANT ) ;
Args . nullNotPermitted ( generator , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . contentAlignmentPoint = anchor ; }
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . volumePaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( x , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( x , STRING_CONSTANT ) ; this . x = x ; this . y = y ; }
Args . nullNotPermitted ( extract , STRING_CONSTANT ) ;
Args . nullNotPermitted ( hotspot , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . legendItemLabelGenerator = generator ; fireChangeEvent () ; }
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( plot , STRING_CONSTANT ) ; this . plot = plot ; }
Args . nullNotPermitted ( locale , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( arrangement , STRING_CONSTANT ) ; this . arrangement = arrangement ; }
Args . nullNotPermitted ( arrangement , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . sortOrder = order ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . itemLabelPadding = padding ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . itemPaint = paint ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . itemFont = font ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . legendItemGraphicPadding = padding ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . legendItemGraphicAnchor = anchor ; }
{ Args . nullNotPermitted ( edge , STRING_CONSTANT ) ; this . legendItemGraphicEdge = edge ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( sources , STRING_CONSTANT ) ; this . sources = sources ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( position , STRING_CONSTANT ) ; this . xPosition = position ; }
Args . nullNotPermitted ( defaultPaint , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . legendLabelGenerator = generator ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendItemShape = shape ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( distributor , STRING_CONSTANT ) ; this . labelDistributor = distributor ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . simpleLabelOffset = offset ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . labelPadding = padding ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . labelLinkStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelLinkPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( style , STRING_CONSTANT ) ; this . labelLinkStyle = style ; fireChangeEvent () ; }
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . defaultSectionOutlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultSectionOutlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultSectionPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( direction , STRING_CONSTANT ) ; this . direction = direction ; fireChangeEvent () ; }
Args . nullNotPermitted ( text , STRING_CONSTANT ) ;
Args . nullNotPermitted ( text , STRING_CONSTANT ) ;
Args . nullNotPermitted ( text , STRING_CONSTANT ) ;
Args . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
Args . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
Args . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
Args . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
Args . nullNotPermitted ( shape , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . anchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( label , STRING_CONSTANT ) ; this . label = label ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( label , STRING_CONSTANT ) ;
Args . nullNotPermitted ( range , STRING_CONSTANT ) ;
Args . nullNotPermitted ( range , STRING_CONSTANT ) ;
Args . nullNotPermitted ( group , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( defaultGroup , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( series , STRING_CONSTANT ) ; return this . data . indexOf ( series ) ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( format , STRING_CONSTANT ) ; this . formatPattern = format ; }
Args . nullNotPermitted ( file , STRING_CONSTANT ) ;
Args . nullNotPermitted ( chart , STRING_CONSTANT ) ;
Args . nullNotPermitted ( directions , STRING_CONSTANT ) ;
Args . nullNotPermitted ( seriesKeys , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( subtask , STRING_CONSTANT ) ; this . subtasks . add ( subtask ) ; }
{ Args . nullNotPermitted ( description , STRING_CONSTANT ) ; this . description = description ; }
Args . nullNotPermitted ( description , STRING_CONSTANT ) ;
{ super ( area , toolTipText , urlText ) ; Args . nullNotPermitted ( chart , STRING_CONSTANT ) ; this . chart = chart ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stripOutlineStroke = stroke ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . stripOutlinePaint = paint ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( location , STRING_CONSTANT ) ; this . axisLocation = location ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( axis , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( scale , STRING_CONSTANT ) ; this . scale = scale ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( axis , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( columnKey , STRING_CONSTANT ) ; return this . keys . indexOf ( columnKey ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . artifactPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; this . store . put ( key , stroke ) ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; return ( Stroke ) this . store . get ( key ) ; }
{ Args . nullNotPermitted ( coefficients , STRING_CONSTANT ) ; this . coefficients = ( double [] ) coefficients . clone () ; }
Args . nullNotPermitted ( line , STRING_CONSTANT ) ;
Args . nullNotPermitted ( axisIndex , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( text , STRING_CONSTANT ) ; this . cornerTextItems . add ( text ) ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . angleLabelPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . angleLabelFont = font ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( unit , STRING_CONSTANT ) ; this . angleTickUnit = unit ; fireChangeEvent () ; }
Args . nullNotPermitted ( location , STRING_CONSTANT ) ;
Args . nullNotPermitted ( chart , STRING_CONSTANT ) ;
Args . nullNotPermitted ( chart , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( prefix , STRING_CONSTANT ) ; ServletUtilities.tempOneTimeFilePrefix = prefix ; }
{ Args . nullNotPermitted ( prefix , STRING_CONSTANT ) ; ServletUtilities.tempFilePrefix = prefix ; }
{ Args . nullNotPermitted ( type , STRING_CONSTANT ) ; this . type = type ; fireDatasetChanged () ; }
{ Args . nullNotPermitted ( transformer , STRING_CONSTANT ) ; this . fillPaintTransformer = transformer ; }
{ Args . nullNotPermitted ( line , STRING_CONSTANT ) ; this . line = line ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . linePaint = paint ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . lineStroke = stroke ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . fillPaint = paint ; }
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . shape = shape ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . columnKeys . indexOf ( key ) ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . rowKeys . indexOf ( key ) ; }
Args . nullNotPermitted ( period , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( position , STRING_CONSTANT ) ; this . tickMarkPosition = position ; fireChangeEvent () ; }
Args . nullNotPermitted ( maximumDate , STRING_CONSTANT ) ;
Args . nullNotPermitted ( date , STRING_CONSTANT ) ;
Args . nullNotPermitted ( range , STRING_CONSTANT ) ;
Args . nullNotPermitted ( locale , STRING_CONSTANT ) ;
Args . nullNotPermitted ( zone , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . remove ( OverlayChangeListener . class , listener ) ; }
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . add ( OverlayChangeListener . class , listener ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . fillPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; this . store . put ( key , paint ) ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; return ( Paint ) this . store . get ( key ) ; }
Args . nullNotPermitted ( drawable , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( group , STRING_CONSTANT ) ; this . group = group ; }
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . separatorPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . separatorStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( color , STRING_CONSTANT ) ; this . centerTextColor = color ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . centerTextFont = font ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . centerTextFormatter = formatter ; }
{ Args . nullNotPermitted ( mode , STRING_CONSTANT ) ; this . centerTextMode = mode ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . negativePaint = paint ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . positivePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ; this . dataset = dataset ; }
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . arrowPaint = paint ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . arrowStroke = stroke ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( serialDate , STRING_CONSTANT ) ; this . serialDate = serialDate ; peg ( Calendar . getInstance () ) ; }
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( series , STRING_CONSTANT ) ; return this . data . indexOf ( series ) ; }
Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
Args . nullNotPermitted ( unit , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . baseFormatter = formatter ; fireChangeEvent () ; }
Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeCrosshairPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeCrosshairStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainCrosshairStroke = stroke ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainCrosshairPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( marker , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeMinorGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeMinorGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeZeroBaselinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeZeroBaselineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( position , STRING_CONSTANT ) ; this . domainGridlinePosition = position ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . rowRenderingOrder = order ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . columnRenderingOrder = order ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . renderingOrder = order ; fireChangeEvent () ; }
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . nullNotPermitted ( axis , STRING_CONSTANT ) ;
Args . nullNotPermitted ( axis , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . axisOffset = offset ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ; this . orientation = orientation ; fireChangeEvent () ; }
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( format , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . advanceLineStroke = stroke ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . advanceLinePaint = paint ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . data . getValue ( key ) ; }
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . rotationAnchor = anchor ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . textAnchor = anchor ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( text , STRING_CONSTANT ) ; this . text = text ; fireAnnotationChanged () ; }
Args . nullNotPermitted ( text , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( x , STRING_CONSTANT ) ; this . x = x ; this . obj = y ; }
{ super ( area , toolTipText , urlText ) ; Args . nullNotPermitted ( axis , STRING_CONSTANT ) ; this . axis = axis ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( period , STRING_CONSTANT ) ; this . period = period ; this . value = value ; }
final String name
Point2D anchorPoint = position . getCategoryAnchor () . getAnchorPoint ( area ) ;
Point2D anchorPoint = anchor . getAnchorPoint ( shape . getBounds2D () ) ;
Point2D pt2 = this . valueAnchor . getAnchorPoint ( bounds ) ;
return anchor . getAnchorPoint ( anchorRect ) ;
return anchor . getAnchorPoint ( anchorRect ) ;
Point2D anchorPoint = this . anchor . getAnchorPoint ( imageRect ) ;
Point2D pt = this . textAnchor . getAnchorPoint ( area ) ;
return anchor . getAnchorPoint ( anchorRect ) ;
return anchor . getAnchorPoint ( anchorRect ) ;
Point2D anchorPoint = this . anchor . getAnchorPoint ( titleRect ) ;
g2 . setXORMode ( Color.ORANGE ) ;
g2 . setXORMode ( Color.ORANGE ) ;
if ( xor ) { g2 . setXORMode ( Color.GRAY ) ; }
this . overlays = new java.util.ArrayList < Overlay > () ;
if ( mep > NUMBER_CONSTANT ) { ep = getExplodePercent ( dataset . getKey ( section ) ) / mep ; }
if ( ! ChartUtils . isOrsonPDFAvailable () ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
chart.subtitles = new ArrayList < Title > () ;
return this . subtitles . get ( index ) ;
this . subtitles = new ArrayList < Title > () ;
this . chartPanel = new ChartPanel ( chart , false ) ;
public ClassUtils () { ; }
public StringEscapeUtils () { ; }
public WordUtils () { ; }
public CharUtils () { ; }
public CharSetUtils () { ; }
Null () { ; }
public ObjectUtils () { ; }
public BooleanUtils () { ; }
public Validate () { ; }
public ArrayUtils () { ; }
public NumberUtils () { ; }
public RandomStringUtils () { ; }
public EnumUtils () { ; }
public NumberUtils () { ; }
public ExceptionUtils () { ; }
public EnumUtils () { ; }
private Entry () { ; }
private Entry () { ; }
public StopWatch () { ; }
public DateUtils () { ; }
public DateFormatUtils () { ; }
public ClassUtils () { super(); }
public StringEscapeUtils () { super(); }
public WordUtils () { super(); }
public CharUtils () { super(); }
public CharSetUtils () { super(); }
public ObjectUtils () { super(); }
public EnumUtils () { super(); }
public BooleanUtils () { super(); }
public ArrayUtils () { super(); }
public NumberUtils () { super(); }
public RandomStringUtils () { super(); }
{ try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { ; } return createBigInteger ( numeric ) ; }
{ try { if ( in != null ) { in . close () ; } } catch ( IOException ex ) { ; } }
{ try { if ( out != null ) { out . close () ; } } catch ( IOException ex ) { ; } }
{ try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { ; } return createBigInteger ( numeric ) ; }
public SystemUtils () { super(); }
if ( last == CHAR_CONS ) { ; } else { lastIdx ++ ; }
public StringUtils () { super(); }
{ try { if ( in != null ) { in . close () ; } } catch ( IOException ex ) {} }
{ try { if ( out != null ) { out . close () ; } } catch ( IOException ex ) {} }
TwoDigitMonthField () { super(); }
TwoDigitYearField () { super(); }
UnpaddedMonthField () { super(); }
Null () { super(); }
public DateUtils () { super(); }
public DateFormatUtils () { super(); }
public NumberUtils () { super(); }
public ExceptionUtils () { super(); }
public EnumUtils () { super(); }
suite . addTestSuite ( VariableFormatterTest . class ) ;
{ Object result = replaceObject ( source ) ; return result == null ? null : result . toString () ; }
sb . appendFixedWidthPadLeft ( null , NUMBER_CONSTANT , CHAR_CONS ) ;
noPrimitives = new Class [] { String . class , ClassUtils . class , Void.TYPE }
assertEquals ( true , tenToTwenty . containsNumber ( nonComparableNumber ) ) ;
Range r = new IntRange ( nonComparableNumber ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparableNumber ) ) ;
Range r = new FloatRange ( nonComparableNumber ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparableNumber ) ) ;
Range r = new DoubleRange ( nonComparableNumber ) ;
assertEquals ( true , tenToTwenty . containsFloat ( nonComparableNumber ) ) ;
assertEquals ( true , tenToTwenty . containsDouble ( nonComparableNumber ) ) ;
assertEquals ( true , tenToTwenty . containsInteger ( nonComparableNumber ) ) ;
assertEquals ( true , tenToTwenty . containsLong ( nonComparableNumber ) ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparableNumber ) ) ;
Range r = new LongRange ( nonComparableNumber ) ;
{ return getTSVClone () ; }
{ return getCSVClone () ; }
int removeLen = endIndex - startIndex ;
{ return lastIndexOf ( str , size - NUMBER_CONSTANT ) ; }
{ return lastIndexOf ( ch , size - NUMBER_CONSTANT ) ; }
{ return new String ( buf , size - length , length ) ; }
{ return new StringBuffer ( size ) . append ( buffer , NUMBER_CONSTANT , size ) ; }
{ return new String ( buffer , NUMBER_CONSTANT , size ) ; }
{ if ( str . charAt ( j ) != buffer [ i + j ] ) { continue outer ; } }
{ if ( buffer [ i ] == ch ) { return i ; } }
char [] thisBuf = buffer ;
char [] thisBuf = buffer ;
char [] thisBuf = buffer ;
{ endIndex = validateRange ( startIndex , endIndex ) ; return new String ( buffer , startIndex , endIndex - startIndex ) ; }
{ if ( buffer [ pos ] != str . charAt ( i ) ) { return false ; } }
{ if ( buffer [ i ] != str . charAt ( i ) ) { return false ; } }
if ( len > NUMBER_CONSTANT ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; size -= len ; }
for ( int i = NUMBER_CONSTANT ; i < length ; i ++ ) { buffer [ size ++ ] = padChar ; }
buffer [ size ++ ] = ch ;
System . arraycopy ( chars , startIndex , buffer , len , length ) ;
System . arraycopy ( chars , NUMBER_CONSTANT , buffer , len , strLen ) ;
System . arraycopy ( str.buffer , NUMBER_CONSTANT , buffer , len , strLen ) ;
str . getChars ( NUMBER_CONSTANT , strLen , buffer , len ) ;
str . getChars ( NUMBER_CONSTANT , strLen , buffer , len ) ;
System . arraycopy ( buffer , startIndex , destination , destinationIndex , endIndex - startIndex ) ;
System . arraycopy ( buffer , NUMBER_CONSTANT , destination , NUMBER_CONSTANT , len ) ;
System . arraycopy ( buffer , startIndex , chars , NUMBER_CONSTANT , len ) ;
System . arraycopy ( buffer , NUMBER_CONSTANT , chars , NUMBER_CONSTANT , size ) ;
buffer [ index ] = ch ;
{ if ( index < NUMBER_CONSTANT || index >= length () ) { throw new StringIndexOutOfBoundsException ( index ) ; } return buffer [ index ] ; }
for ( int i = oldEnd ; i < newEnd ; i ++ ) { buffer [ i ] = CHAR_CONS ; }
{ super(); if ( initialCapacity <= NUMBER_CONSTANT ) { initialCapacity = CAPACITY ; } buffer = new char [ initialCapacity ] ; }
assertEquals ( true , sb.buffer.length >= NUMBER_CONSTANT ) ;
if ( pos + len > textLen ) { return NUMBER_CONSTANT ; }
{ return ( boolean [] ) add ( array , index , BooleanUtils . toBooleanObject ( element ) , Boolean.TYPE ) ; }
try { sb . setLength ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IndexOutOfBoundsException e ) {}
try { sb . setLength ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IndexOutOfBoundsException e ) {}
try { sb . deleteCharAt ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IndexOutOfBoundsException e ) {}
{ if ( startPos < getPos () ) { getTokenList () . addLast ( VariableParser . newTextToken ( startPos , getPos () - startPos ) ) ; } }
if ( last != CharUtils.CR ) { lastIdx ++ ; }
tok . setIgnoredMatcher ( StrMatcher . trimMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . trimMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . trimMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . noneMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . noneMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . trimMatcher () ) ;
StrMatcher trimmer
{ setIgnoredMatcher ( StrMatcher . charMatcher ( ignored ) ) ; }
StrMatcher ignored
{ setQuoteMatcher ( StrMatcher . charMatcher ( quote ) ) ; }
StrMatcher quote
start == len && delim . isMatch ( chars , start - NUMBER_CONSTANT , NUMBER_CONSTANT , len ) == NUMBER_CONSTANT
StrMatcher delim
StrMatcher delim
private void setVarStartMatcher ( StrMatcher varStartMatcher ) { this . varStartMatcher = varStartMatcher ; }
private void setVarEndMatcher ( StrMatcher varEndMatcher ) { this . varEndMatcher = varEndMatcher ; }
private void setEscVarMatcher ( StrMatcher escVarMatcher ) { this . escVarMatcher = escVarMatcher ; }
sb . replaceFirst ( CHAR_CONS , CHAR_CONS ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
if ( cloned.chars != null ) { cloned.chars = cloned.chars ; }
if ( cloned.chars != null ) { cloned.chars = ( char [] ) cloned.chars . clone () ; }
public boolean isEmptyTokenAsNull () { return this . emptyAsNull ; }
{ if ( trimmer != null ) { this . trimmerMatcher = trimmer ; } return this ; }
public StrMatcher getTrimmerMatcher () { return trimmerMatcher ; }
{ if ( ignored != null ) { this . ignoredMatcher = ignored ; } return this ; }
public StrMatcher getIgnoredMatcher () { return ignoredMatcher ; }
{ if ( quote != null ) { this . quoteMatcher = quote ; } return this ; }
public StrMatcher getQuoteMatcher () { return quoteMatcher ; }
public StrMatcher getDelimiterMatcher () { return this . delimMatcher ; }
{ assertTrue ( ! bf_multi . isAllSet ( j ) ) ; assertTrue ( bf_zero . isAllSet ( j ) ) ; }
{ super ( msg == null ? DEFAULT_MESSAGE : msg ) ; this . cause = cause ; }
{ super ( DEFAULT_MESSAGE ) ; this . cause = cause ; }
{ super ( msg == null ? DEFAULT_MESSAGE : msg ) ; }
public NotImplementedException () { super ( DEFAULT_MESSAGE ) ; }
private void tokenize () { if ( tokens == null ) { tokens = readTokens () ; } }
sb . clear () . append ( true ) ;
assertLocaleLookupList ( LOCALE_EN_US_ZZZZ , null , new Locale [] { LOCALE_EN_US_ZZZZ , LOCALE_EN_US , new Locale ( STRING_CONSTANT , STRING_CONSTANT ) } ) ;
assertLocaleLookupList ( LOCALE_EN_US_ZZZZ , null , new Locale [] { LOCALE_EN_US_ZZZZ , LOCALE_EN_US , LOCALE_EN } ) ;
{ return ! StringUtils . isEmpty ( str ) ; }
List list = new ArrayList () ;
List list = new ArrayList () ;
{ StrBuilder . this . append ( str , off , len ) ; }
{ StrBuilder . this . append ( cbuf , off , len ) ; }
public void write ( char [] cbuf ) { StrBuilder . this . append ( cbuf ) ; }
public void write ( int c ) { StrBuilder . this . append ( ( char ) c ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
{ return indexOf ( array , valueToFind , NUMBER_CONSTANT , tolerance ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , objectToFind ) != INDEX_NOT_FOUND ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null , null ) ; }
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , testTransients , null , null ) ; }
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , false , null , null ) ; }
{ return reflectionEquals ( lhs , rhs , testTransients , null , null ) ; }
{ return reflectionEquals ( lhs , rhs , false , null , null ) ; }
{ return reflectionCompare ( lhs , rhs , compareTransients , null , null ) ; }
{ return reflectionCompare ( lhs , rhs , false , null , null ) ; }
HashCodeBuilder . reflectionHashCode ( x , ( String [] ) null )
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
assertEquals ( input , tok . getContent () ) ;
public boolean hasPrevious () { checkTokenized () ; return tokenPos > NUMBER_CONSTANT ; }
public boolean hasNext () { checkTokenized () ; return tokenPos < tokens.length ; }
checkTokenized () ;
{ checkTokenized () ; return ( String [] ) tokens . clone () ; }
public int size () { checkTokenized () ; return tokens.length ; }
{ if ( ready () == false ) { return - NUMBER_CONSTANT ; } return StrBuilder . this . charAt ( pos ++ ) ; }
String varValue = resolveVariable ( varName , buf , startPos , endPos ) ;
if ( substitute ( buf , NUMBER_CONSTANT , length ) == false ) { return source . substring ( offset , offset + length ) ; }
StrLookup variableResolver
{ this ( StrLookup . mapLookup ( valueMap ) , prefix , suffix , escape ) ; }
{ this ( StrLookup . mapLookup ( valueMap ) , prefix , suffix , DEFAULT_ESCAPE ) ; }
{ this ( StrLookup . mapLookup ( valueMap ) , DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ESCAPE ) ; }
{ return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; }
return entry.map . get ( getName () ) ;
protected Entry () { super(); }
return entry.map . get ( getName () ) ;
protected Entry () { super(); }
sub . replaceIn ( builder ) ;
assertEquals ( NUMBER_CONSTANT , ExceptionUtils . getThrowableCount ( cyclicCause ) ) ;
cyclicCause = null ;
cyclicCause = new ExceptionWithCause ( a ) ;
protected DefaultToStringStyle () { super(); }
DefaultToStringStyle () { super(); }
public Object getValue () { return Boolean . valueOf ( this . value ) ; }
public Object getValue () { return new Boolean ( this . value ) ; }
public Object getValue () { return BooleanUtils . toBooleanObject ( this . value ) ; }
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
{ StringWriter stringWriter = createStringWriter ( str ) ; this . unescape ( stringWriter , str ) ; return stringWriter . toString () ; }
{ StringWriter stringWriter = createStringWriter ( str ) ; this . escape ( stringWriter , str ) ; return stringWriter . toString () ; }
CharSet chars = CharSet . getInstance ( set ) ;
CharSet chars = CharSet . getInstance ( set ) ;
CharSet chars = CharSet . getInstance ( set ) ;
assertSame ( CharSet.EMPTY , CharSet . getInstance ( ( String ) null ) ) ;
this . stopTime = System . currentTimeMillis () ;
this . stopTime = - NUMBER_CONSTANT ;
this . stopTime = System . currentTimeMillis () ;
if ( this . runningState == STATE_RUNNING ) { this . stopTime = System . currentTimeMillis () ; }
protected void setUp ( ) throws Exception { super . setUp () ; java.util.Locale . setDefault ( java.util.Locale.US ) ; }
if ( StringUtils . containsNone ( str , CSV_SEARCH_CHARS ) ) { return str ; }
MessageFormat f = createMessageFormat ( pattern , locale ) ;
subformats . put ( INTEGER , createIntegerInstance ( getLocale () ) ) ;
getIntegerNumberFormat ( Locale.US )
{ return splitByWholeSeparatorWorker ( str , separator , - NUMBER_CONSTANT , false ) ; }
{ clazz = Class . forName ( toCanonicalName ( className ) , initialize , classLoader ) ; }
if ( StringUtils . containsAny ( quoteless , CSV_SEARCH_CHARS ) ) { str = StringUtils . replace ( quoteless , CSV_QUOTE_STR + CSV_QUOTE_STR , CSV_QUOTE_STR ) ; }
catch ( IllegalStateException e ) {}
if ( replaceChars == null ) { replaceChars = EMPTY ; }
{ if ( isEmpty ( str ) || isEmpty ( remove ) ) { return str ; } return replace ( str , remove , EMPTY , - NUMBER_CONSTANT ) ; }
{ return new ExtendedMessageFormat ( pattern , locale ) ; }
assertPatternsEqual ( null , pattern , emf . toPattern () ) ;
assertPatternsEqual ( STRING_CONSTANT , pattern , emf . toPattern () ) ;
int mid = ( low + high ) > > > NUMBER_CONSTANT ;
osName . toLowerCase ( Locale.ENGLISH ) . startsWith ( STRING_CONSTANT )
{ return Integer . toHexString ( ch ) . toUpperCase ( Locale.ENGLISH ) ; }
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
{ getRegistry () . remove ( new IDKey ( value ) ) ; }
{ getRegistry () . add ( new IDKey ( value ) ) ; }
{ return getRegistry () . contains ( new IDKey ( value ) ) ; }
roundUp = offset >= NUMBER_CONSTANT ;
{ if ( this . runningState == STATE_UNSTARTED ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } return this . startTimeMillis ; }
this . startTime += ( System . nanoTime () - this . stopTime ) ;
this . stopTime = System . nanoTime () ;
this . stopTime = System . nanoTime () ;
if ( this . runningState == STATE_RUNNING ) { this . stopTime = System . nanoTime () ; }
public static Test suite () { return new TestSuite ( NestableExceptionTest . class ) ; }
public ExceptionUtilsTest ( String name ) { super ( name ) ; }
public static Test suite () { return new TestSuite ( NestableErrorTest . class ) ; }
public static Test suite () { return new TestSuite ( NestableRuntimeExceptionTest . class ) ; }
@ Override public String toString () { return STRING_CONSTANT ; }
{ return ( ( Boolean ) IS_SYNTHETIC . invoke ( m , ( Object [] ) null ) ) . booleanValue () ; }
objects [ NUMBER_CONSTANT ] = simple ;
objectsLevel2 [ NUMBER_CONSTANT ] = objects ;
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
if ( cloned.chars != null ) { cloned.chars = cloned.chars . clone () ; }
{ checkTokenized () ; return tokens . clone () ; }
sb . appendln ( FOO ) ;
@ Override public String toString () { return toString ; }
@ Override public Throwable getCause () { return cause ; }
{ super ( msg ) ; this . cause = null ; }
{ super ( msg ) ; this . cause = null ; }
{ super ( msg ) ; this . cause = null ; }
String [] splitOnNullResults = StringUtils . splitByWholeSeparator ( stringToSplitOnNulls , null ) ;
{ ObjectUtils . identityToString ( buffer , value ) ; }
{ ObjectUtils . identityToString ( this . getStringBuffer () , object ) ; return this ; }
String pBaseStr = STRING_CONSTANT ;
catch ( NumberFormatException nfe ) { throw new UnhandledException ( STRING_CONSTANT + unicode , nfe ) ; }
final Throwable n = new UnhandledException ( t ) ;
{ super ( DEFAULT_MESSAGE , cause ) ; }
String entityValue = Entities . getISO8859_1 ( i % Entities.ISO8859_1_ARRAY_LENGTH , NUMBER_CONSTANT ) ;
String entityValue = Entities . getHTML40 ( i % Entities.HTML40_ARRAY_LENGTH , NUMBER_CONSTANT ) ;
Collection < > collection
Collection < > collection
Iterator < > iterator
Iterator < > iterator
Iterator < > it
Iterator < > it
List < String > tokens
List < String > tokens
List < String > list
{ mutNum . compareTo ( Byte . valueOf ( ( byte ) NUMBER_CONSTANT ) ) ; fail () ; }
{ return ( byte [] ) add ( array , index , Byte . valueOf ( element ) , Byte.TYPE ) ; }
{ result [ i ] = Byte . valueOf ( array [ i ] ) ; }
public Byte toByte () { return Byte . valueOf ( byteValue () ) ; }
public Object getValue () { return Byte . valueOf ( this . value ) ; }
Class < > type
Class < > type
Class < > type
Class < > clazz
Class < > clazz
List < String > list = getCauseMethodNameList () ;
List < String > list = getCauseMethodNameList () ;
String obj
String obj
Map < String , FormatFactory > registry
Map < String , FormatFactory > registry
Class < > clazz
List < String > priorVariables
Collection < String > excludeFields
Class < > reflectUpToClass
Class < > clazz
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > clazz
Class < > reflectUpToClass
Collection < String > excludeFields
Class < > cls
Class < > cls
Class < > clazz
Class < > clazz
Class < > reflectUpToClass
Collection < String > collection
Collection < String > excludeFieldNames
Class < > reflectUpToClass
Class < > cls
Class < > expected
Class < > lhsClass = lhs . getClass () ;
Class < > clazz
Class < > reflectUpToClass
Collection < String > excludeFields
Class < > clss
Class < > clss = null ;
Class < > newArrayComponentType
Class < > cls = target . getClass () ;
Class < > cls = target . getClass () ;
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls = target . getClass () ;
Class < > cls = target . getClass () ;
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
if ( methodNames == null ) { synchronized ( CAUSE_METHOD_NAMES_LOCK ) { methodNames = CAUSE_METHOD_NAMES ; } }
{ synchronized ( CAUSE_METHOD_NAMES_LOCK ) { return getCause ( throwable , CAUSE_METHOD_NAMES ) ; } }
if ( list . remove ( methodName ) ) { synchronized ( CAUSE_METHOD_NAMES_LOCK ) { CAUSE_METHOD_NAMES = toArray ( list ) ; } }
if ( list . add ( methodName ) ) { synchronized ( CAUSE_METHOD_NAMES_LOCK ) { CAUSE_METHOD_NAMES = toArray ( list ) ; } }
Iterator < > it
Iterator < > it
Iterator < > it
assertNotNull ( ObjectUtils.NULL ) ;
public Object getValue () { return Boolean . valueOf ( this . value ) ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , obj , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ return ( boolean [] ) add ( array , index , Boolean . valueOf ( element ) , Boolean.TYPE ) ; }
{ if ( cls == null ) { return StringUtils.EMPTY ; } return cls . getPackage () . getName () ; }
return Float . compare ( value , anotherVal ) ;
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = Float . compare ( lhs , rhs ) ; return this ; }
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = Double . compare ( lhs , rhs ) ; return this ; }
return Double . compare ( value , anotherVal ) ;
int compare = ( ( Comparable < Number > ) num1 ) . compareTo ( num2 ) ;
Map < , > map
Collection < > collection
Comparator < > comparator
T object
T object
T object
Class < ? super T > clazz
T object
T object
T object
Map < String , V > map
public String [] getExcludeFieldNames () { return this . excludeFieldNames . clone () ; }
{ UnescapeUtils.UNESCAPE_ECMASCRIPT . translate ( str , out ) ; }
{ return UnescapeUtils.UNESCAPE_ECMASCRIPT . translate ( str ) ; }
{ EscapeUtils.ESCAPE_ECMASCRIPT . translate ( str , out ) ; }
{ return EscapeUtils.ESCAPE_ECMASCRIPT . translate ( str ) ; }
{ EscapeUtils.ESCAPE_JAVA . translate ( str , out ) ; }
{ return EscapeUtils.ESCAPE_JAVA . translate ( str ) ; }
{ return UnescapeUtils . unescapeCsv ( str ) ; }
{ return EscapeUtils . escapeCsv ( str ) ; }
{ return UnescapeUtils . unescapeXml ( str ) ; }
{ return EscapeUtils . escapeXml ( str ) ; }
{ return UnescapeUtils . unescapeHtml4 ( str ) ; }
{ return EscapeUtils . escapeHtml4 ( str ) ; }
{ return UnescapeUtils . unescapeEcmaScript ( str ) ; }
{ return UnescapeUtils . unescapeJava ( str ) ; }
{ return EscapeUtils . escapeEcmaScript ( str ) ; }
{ return EscapeUtils . escapeJava ( str ) ; }
void setValue ( T value ) ;
T getValue ( ) ;
T value
T value
CharSequence str
CharSequence str
CharSequence str
CharSequence str
modify ( truncated , field , MODIFY_TRUNCATE ) ;
modify ( gval , field , MODIFY_TRUNCATE ) ;
modify ( rounded , field , MODIFY_ROUND ) ;
modify ( gval , field , MODIFY_ROUND ) ;
{ throw new NullPointerException ( STRING_CONSTANT ) ; }
if ( target == null ) { throw new NullPointerException ( STRING_CONSTANT ) ; }
catch ( NumberFormatException nfe ) { throw new RuntimeException ( STRING_CONSTANT + unicode , nfe ) ; }
assertGetClassThrowsNullPointerException ( null ) ;
catch ( IOException ioe ) { throw new RuntimeException ( ioe ) ; }
buffer = new char [ capacity * NUMBER_CONSTANT ] ;
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ result [ i ] = Float . valueOf ( array [ i ] ) ; }
{ result [ i ] = Double . valueOf ( array [ i ] ) ; }
{ result [ i ] = Short . valueOf ( array [ i ] ) ; }
{ result [ i ] = Integer . valueOf ( array [ i ] ) ; }
{ result [ i ] = Long . valueOf ( array [ i ] ) ; }
{ result [ i ] = Character . valueOf ( array [ i ] ) ; }
double . . . array2
float . . . array2
long . . . array2
int . . . array2
short . . . array2
byte . . . array2
char . . . array2
boolean . . . array2
object instanceof Map.Entry < , >
if ( num1 instanceof Comparable < > == false ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( num instanceof Comparable < > == false ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
Iterator < > it = collection . iterator ()
Iterator < > it = collection . iterator ()
Iterator < > it = collection . iterator ()
Iterator < > it = collection . iterator ()
oos . writeObject ( new ClassNotFoundSerialization () ) ;
{ if ( object == null ) { return valueIfNull ; } return getPackageName ( object . getClass () ) ; }
{ if ( object == null ) { return valueIfNull ; } return getShortClassName ( object . getClass () ) ; }
{ if ( cls == null ) { return StringUtils.EMPTY ; } return getPackageName ( cls . getName () ) ; }
isSet ( PARAM.escapePlus )
uu = new UnicodeUnescaper ( UnicodeUnescaper.PARAM.escapePlus ) ;
isSet ( OPTION.escapePlus )
uu = new UnicodeUnescaper ( UnicodeUnescaper.OPTION.escapePlus ) ;
StringBuilder canonicalClassNameBuffer = new StringBuilder ( className ) ;
StringBuilder classNameBuffer = new StringBuilder () ;
StringBuilder arrayPrefix = new StringBuilder () ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder result = new StringBuilder () ;
StringBuilder buffer = new StringBuilder ( strLen ) ;
StringBuilder buffer = new StringBuilder ( strLen ) ;
StringBuilder buffer = new StringBuilder ( strLen ) ;
StringBuilder buffer = new StringBuilder ( strLen ) ;
new StringBuilder ( strLen ) . append ( Character . toLowerCase ( str . charAt ( NUMBER_CONSTANT ) ) ) . append ( str . substring ( NUMBER_CONSTANT ) )
new StringBuilder ( strLen ) . append ( Character . toTitleCase ( str . charAt ( NUMBER_CONSTANT ) ) ) . append ( str . substring ( NUMBER_CONSTANT ) )
StringBuilder buf = new StringBuilder ( outputLength ) ;
StringBuilder buf = new StringBuilder ( strLength ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( bufSize ) ;
StringBuilder buf = new StringBuilder ( bufSize ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buffer = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
toString = new StringBuilder ( NUMBER_CONSTANT ) . append ( getNumerator () ) . append ( CHAR_CONS ) . append ( getDenominator () ) . toString () ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buffer = new StringBuilder () ;
StringBuilder buf = new StringBuilder () ;
CharRange range = CharRange . is ( CHAR_CONS ) ;
Collection < > collection
Collection < > collection
Class < > cls
Map < , > map
Collection < > coll
Class < > cls
Class < > cls
Class < > [] parameterTypes
Class < > [] parameterTypes
Class < > exceptionType
Class < > c
assertFalse ( ClassUtils . isAssignable ( ( Class < > ) null , null , true ) ) ;
assertFalse ( ClassUtils . isAssignable ( ( Class < > ) null , null ) ) ;
assertEquals ( STRING_CONSTANT , ClassUtils . getPackageName ( ( Class < > ) null ) ) ;
assertEquals ( null , StringUtils . join ( ( Collection < > ) null , null ) ) ;
assertEquals ( null , StringUtils . join ( ( Collection < > ) null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . join ( ( Iterator < > ) null , null ) ) ;
assertEquals ( null , StringUtils . join ( ( Iterator < > ) null , CHAR_CONS ) ) ;
iMap = new HashMap < Object , Object > () ;
Class < > [] c
sb . appendWithSeparators ( ( Iterator < > ) null , STRING_CONSTANT ) ;
sb . appendWithSeparators ( ( Collection < > ) null , STRING_CONSTANT ) ;
sb . appendAll ( ( Iterator < > ) null ) ;
sb . appendAll ( ( Collection < > ) null ) ;
public String getFormattedExceptionMessage ( String baseMessage ) { return exceptionContext . getFormattedExceptionMessage ( baseMessage ) ; }
public String getFormattedExceptionMessage ( String baseMessage ) { return exceptionContext . getFormattedExceptionMessage ( baseMessage ) ; }
Object value
Object value
StringBuffer buffer = new StringBuffer () ;
Class < > [] c
List < > list = tok . getTokenList () ;
values = new HashMap < String , String > () ;
Map < String , > map = null ;
Map < String , ? extends FormatFactory > registry
Map < String , > registry
Map < String , > registry
String toString = ReflectionToStringBuilder . toStringExclude ( new TestFixture () , ( Collection < String > ) null ) ;
String toString = ReflectionToStringBuilder . toStringExclude ( new TestFixture () , new ArrayList < String > () ) ;
Object object
Object object
Object object
Object object
Object object
Object object
{ this ( object , null , null ) ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( getMinimum () , element ) < NUMBER_CONSTANT ; }
StringEscapeUtils.UNESCAPE_CSV . translate ( value , writer ) ;
StringEscapeUtils.ESCAPE_CSV . translate ( value , writer ) ;
StringEscapeUtils.UNESCAPE_JAVA . translate ( original , writer ) ;
StringEscapeUtils.ESCAPE_JAVA . translate ( original , writer ) ;
Comparator < T > c
{ try { return initialize () ; } finally { if ( execFinally != null ) { execFinally . shutdown () ; } } }
{ execFinally = exec ; }
{ this . translators = ArrayUtils . clone ( translators ) ; }
{ return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
Object [] values2 = ArrayUtils . addAll ( values , Integer . valueOf ( i ) ) ;
Object [] values2 = ArrayUtils . add ( values , Integer . valueOf ( i ) ) ;
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , new Double ( value ) ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , Long . valueOf ( value ) ) ) ; } }
{ calendar . getTimeInMillis () ; calendar = ( Calendar ) calendar . clone () ; calendar . setTimeZone ( mTimeZone ) ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( element , this . maximum ) > NUMBER_CONSTANT ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( element , this . minimum ) < NUMBER_CONSTANT ; }
return null ;
{ return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return noNullElements ( iterable , DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE ) ; }
{ return noNullElements ( array , DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE ) ; }
{ return notBlank ( chars , DEFAULT_NOT_BLANK_EX_MESSAGE ) ; }
{ return notEmpty ( chars , DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE ) ; }
{ return notEmpty ( map , DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE ) ; }
{ return notEmpty ( collection , DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE ) ; }
{ return notEmpty ( array , DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE ) ; }
{ return notNull ( object , DEFAULT_IS_NULL_EX_MESSAGE ) ; }
StrLookup < > variableResolver
StrLookup < > resolver = getVariableResolver () ;
StrLookup < > variableResolver
StrLookup < > variableResolver
StrLookup < > variableResolver
public StrSubstitutor () { this ( ( StrLookup < > ) null , DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ESCAPE ) ; }
{ return m != null && Modifier . isPublic ( m . getModifiers () ) && ! m . isSynthetic () ; }
validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
{ return REGISTRY . get () ; }
CharSequence str
if ( str == null || suffix == null ) { return str == null && suffix == null ; }
{ if ( str == null ) { return null ; } return CharSequenceUtils . reverse ( str ) . toString () ; }
if ( str == null || searchStrs == null ) { return - NUMBER_CONSTANT ; }
smallestIndexOfDiff == INDEX_NOT_FOUND
if ( at == INDEX_NOT_FOUND ) { return EMPTY ; }
if ( isEmpty ( str ) || str . indexOf ( remove ) == INDEX_NOT_FOUND ) { return str ; }
if ( pos == INDEX_NOT_FOUND || pos == ( str . length () - separator . length () ) ) { return EMPTY ; }
if ( pos == INDEX_NOT_FOUND ) { return str ; }
if ( pos == INDEX_NOT_FOUND ) { return EMPTY ; }
if ( pos == INDEX_NOT_FOUND ) { return str ; }
return indexOfAnyBut ( cs , valid ) == INDEX_NOT_FOUND ;
{ if ( isEmpty ( cs ) || isEmpty ( searchChars ) ) { return INDEX_NOT_FOUND ; } return indexOfAny ( cs , searchChars . toCharArray () ) ; }
if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; }
{ if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } return str . lastIndexOf ( searchStr , startPos ) ; }
{ if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } return str . lastIndexOf ( searchStr ) ; }
{ if ( isEmpty ( str ) ) { return INDEX_NOT_FOUND ; } return str . lastIndexOf ( searchChar , startPos ) ; }
{ if ( isEmpty ( str ) ) { return INDEX_NOT_FOUND ; } return str . lastIndexOf ( searchChar ) ; }
{ if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } return str . indexOf ( searchStr , startPos ) ; }
{ if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } return str . indexOf ( searchStr ) ; }
( start != strLen ) && ( stripChars . indexOf ( str . charAt ( start ) ) != INDEX_NOT_FOUND )
{ if ( str == null ) { return null ; } return new StringBuilder ( str ) . reverse () . toString () ; }
int searchChar
int searchChar
int searchChar
int searchChar
int searchChar
Class < > . . . parameterTypes
Class < > . . . parameterTypes
Class < > . . . parameterTypes
Class < > . . . parameterTypes
Object . . . args
Object . . . args
Object . . . args
Object . . . args
String . . . parsePatterns
String . . . parsePatterns
String . . . strs
CharSequence . . . css
Boolean . . . array
boolean . . . array
char . . . delimiters
char . . . delimiters
char . . . delimiters
char . . . delimiters
Class < > . . . parameterTypes
Class < > . . . parameterTypes
Object . . . args
Object . . . args
String . . . searchStrings
assertEquals ( NUMBER_CONSTANT , new MutableFloat ( STRING_CONSTANT ) . floatValue () , NUMBER_CONSTANT ) ;
{ return reflectionCompare ( lhs , rhs , compareTransients , reflectUpToClass , null ) ; }
isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass )
listeners . fire () . propertyChange ( new PropertyChangeEvent ( this , STRING_CONSTANT , oldValue , property ) ) ;
{ Validate . notNull ( listener , STRING_CONSTANT ) ; listeners . add ( listener ) ; }
{ final String [] array = ArrayUtilsTest . toArrayPropagatingType () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtils . toArray () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtilsTest . < String > toArrayPropagatingType () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtils . < String > toArray () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( - NUMBER_CONSTANT , StringUtils . indexOfDifference ( ( String [] ) null ) ) ;
String [] results ;
String [] results ;
assertEquals ( null , StringUtils . concatWith ( null , ( String [] ) null ) ) ;
assertEquals ( null , StringUtils . concat ( ( String [] ) null ) ) ;
{ DateUtils . parseDate ( dateStr , ( String [] ) null ) ; fail () ; }
{ if ( expression == false ) { throw new IllegalStateException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } }
return new StringBuilder ( annotationType == null ? STRING_CONSTANT : annotationType . getName () ) . insert ( NUMBER_CONSTANT , CHAR_CONS ) . toString () ;
{ return isJavaVersionMatch ( JAVA_SPECIFICATION_VERSION , versionPrefix ) ; }
SystemUtils . isJavaVersionAtLeast ( JAVA_1_4 )
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
{ return isAssignable ( cls , toClass , SystemUtils . isJavaVersionAtLeast ( JavaVersion.JAVA_1_5 ) ) ; }
{ return isAssignable ( classArray , toClassArray , SystemUtils . isJavaVersionAtLeast ( JavaVersion.JAVA_1_5 ) ) ; }
boolean atLeastJava14 = SystemUtils . isJavaVersionAtLeast ( JAVA_1_4 ) ;
if ( SystemUtils . isJavaVersionAtLeast ( JAVA_1_3 ) ) { assertEquals ( STRING_CONSTANT , new BigDecimal ( STRING_CONSTANT ) , NumberUtils . createNumber ( STRING_CONSTANT ) ) ; }
{ if ( SystemUtils . isJavaVersionAtLeast ( JAVA_1_4 ) ) { assertEquals ( message , expected , actual ) ; } }
static JavaVersion getJavaVersion ( final String nom ) { return get ( nom ) ; }
{ return ( options == null ) ? false : options . contains ( option ) ; }
assertEquals ( false , StringUtils . isNumeric ( STRING_CONSTANT ) ) ;
assertEquals ( false , StringUtils . isAlphanumeric ( STRING_CONSTANT ) ) ;
assertEquals ( false , StringUtils . isAlpha ( STRING_CONSTANT ) ) ;
{ return format ( date , pattern , UTC_TIME_ZONE , locale ) ; }
{ return format ( new Date ( millis ) , pattern , UTC_TIME_ZONE , locale ) ; }
{ return format ( date , pattern , UTC_TIME_ZONE , null ) ; }
{ return format ( new Date ( millis ) , pattern , UTC_TIME_ZONE , null ) ; }
Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeftElement () , pair . getRightElement () ) ;
{ return Boolean . valueOf ( isEquals () ) ; }
{ return Integer . valueOf ( toComparison () ) ; }
public Integer build () { return Integer . valueOf ( toHashCode () ) ; }
EqualsBuilder . class
EqualsBuilder . class
new StringBuilder ( strLen ) . append ( Character . toLowerCase ( cs . charAt ( NUMBER_CONSTANT ) ) ) . append ( StringUtils . subSequence ( cs , NUMBER_CONSTANT ) )
new StringBuilder ( strLen ) . append ( Character . toTitleCase ( cs . charAt ( NUMBER_CONSTANT ) ) ) . append ( StringUtils . subSequence ( cs , NUMBER_CONSTANT ) )
CharSequence cs
return str . subSequence ( start , end ) . toString () ;
return str . subSequence ( start , str . length () ) . toString () ;
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
String . . . set
Object . . . array
Class < > . . . parameterTypes
Class < > . . . classes
Class < > . . . classes
Class < > . . . toClassArray
char . . . chars
char . . . chars
return frames . toArray ( new String [ frames . size () ] ) ;
return types . toArray ( new Type [ types . size () ] ) ;
String cs
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
String . . . searchStrs
String . . . searchStrs
char . . . searchChars
String . . . strs
String input
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
( idx = CharSequenceUtils . indexOf ( str , sub , idx ) ) != INDEX_NOT_FOUND
tmp = CharSequenceUtils . lastIndexOf ( str , search , str . length () ) ;
tmp = CharSequenceUtils . indexOf ( str , search , NUMBER_CONSTANT ) ;
{ if ( searchChars == null ) { return false ; } return containsAny ( cs , CharSequenceUtils . toCharArray ( searchChars ) ) ; }
{ if ( CharSequenceUtils . regionMatches ( str , true , i , searchStr , NUMBER_CONSTANT , len ) ) { return true ; } }
return CharSequenceUtils . indexOf ( seq , searchSeq , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ;
{ if ( isEmpty ( seq ) ) { return false ; } return CharSequenceUtils . indexOf ( seq , searchChar , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . lastIndexOf ( seq , searchSeq , startPos ) ; }
return CharSequenceUtils . lastIndexOf ( seq , searchSeq , seq . length () ) ;
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . lastIndexOf ( seq , searchChar , startPos ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . lastIndexOf ( seq , searchChar , seq . length () ) ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchSeq , startPos ) ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchSeq , NUMBER_CONSTANT ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchChar , startPos ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchChar , NUMBER_CONSTANT ) ; }
{ return value != NUMBER_CONSTANT ; }
{ if ( bool == null ) { return valueIfNull ; } return bool . booleanValue () ; }
{ if ( bool == null ) { return null ; } return bool . booleanValue () ? Boolean.FALSE : Boolean.TRUE ; }
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
if ( lastWasGap ) { buf [ count ++ ] = ch ; lastWasGap = false ; } else { continue; }
String . . . excludeFieldNames
String . . . excludeFields
{ return reflectionCompare ( lhs , rhs , compareTransients , null ) ; }
{ return reflectionCompare ( lhs , rhs , false , null ) ; }
String . . . excludeFields
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , testTransients , null ) ; }
String . . . excludeFields
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null ) ; }
String . . . excludeFields
{ return reflectionEquals ( lhs , rhs , testTransients , null ) ; }
String . . . excludeFields
{ this . excludeFieldNames = toNoNullStringArray ( excludeFieldNamesParam ) ; Arrays . sort ( this . excludeFieldNames ) ; }
StringBuilder builder = new StringBuilder ( this . getClass () . getSimpleName () ) ;
char . . . chars
@ Override public R getRightElement () { return right ; }
@ Override public L getLeftElement () { return left ; }
Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeft () , pair . getRight () ) ;
public R getValue () { return getRight () ; }
public final L getKey () { return getLeft () ; }
{ R result = getRight () ; setRightElement ( value ) ; return result ; }
{ try { return getAccessibleConstructor ( cls . getConstructor ( parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } }
{ try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } }
Calendar c = Calendar . getInstance ( mTimeZone , mLocale ) ;
Calendar c = Calendar . getInstance ( mTimeZone , mLocale ) ;
{ return cache . getDateTimeInstance ( dateStyle , timeStyle , null , locale ) ; }
{ return cache . getDateTimeInstance ( dateStyle , timeStyle , null , null ) ; }
{ return cache . getDateTimeInstance ( null , style , timeZone , null ) ; }
{ return cache . getDateTimeInstance ( null , style , null , locale ) ; }
{ return cache . getDateTimeInstance ( null , style , null , null ) ; }
{ return cache . getDateTimeInstance ( style , null , timeZone , null ) ; }
{ return cache . getDateTimeInstance ( style , null , null , locale ) ; }
{ return cache . getDateTimeInstance ( style , null , null , null ) ; }
{ return cache . getInstance ( pattern , null , locale ) ; }
{ return cache . getInstance ( pattern , timeZone , null ) ; }
{ return cache . getInstance ( pattern , null , null ) ; }
CharSequence _ellipsis = ObjectUtils . defaultIfNull ( ellipsis , StringUtils.EMPTY ) ;
return pad ( pads , padChar ) . concat ( str ) ;
return str . concat ( pad ( pads , padChar ) ) ;
if ( inputLength == NUMBER_CONSTANT && repeat <= PAD_LIMIT ) { return pad ( repeat , str . charAt ( NUMBER_CONSTANT ) ) ; }
return repeat ( padChar , pads ) . concat ( str ) ;
return str . concat ( repeat ( padChar , pads ) ) ;
assertEquals ( Locale.GERMANY , format1 . getLocale () ) ;
{ Integer count = eventCounts . get ( eventName ) ; return count == null ? NUMBER_CONSTANT : count . intValue () ; }
{ R result = getRight () ; setRight ( value ) ; return result ; }
{ if ( isSet ( OPTION.semiColonRequired ) ) { return NUMBER_CONSTANT ; } else if ( isSet ( OPTION.errorIfNoSemiColon ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } }
int delimLen = delimiters == null ? - NUMBER_CONSTANT : delimiters.length ;
@ Before
@ Test ( expected = NullPointerException . class )
@ Test ( expected = NullPointerException . class )
if ( timeToLive < NUMBER_CONSTANT ) { throw new IllegalStateException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ if ( StringUtils . isEmpty ( str ) ) { return null ; } return Character . valueOf ( str . charAt ( NUMBER_CONSTANT ) ) ; }
public Integer getValue () { return Integer . valueOf ( this . value ) ; }
Integer value = Integer . valueOf ( NUMBER_CONSTANT ) ;
mutNum . subtract ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == Integer . valueOf ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , numA . equals ( Integer . valueOf ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableInt ( Integer . valueOf ( NUMBER_CONSTANT ) ) . intValue () ) ;
assertEquals ( false , f1 . equals ( Integer . valueOf ( NUMBER_CONSTANT ) ) ) ;
try { FieldUtils . writeField ( field , publicChild , Integer . valueOf ( Integer.MAX_VALUE ) ) ; } catch ( IllegalAccessException e ) {}
DurationFormatUtils.Token numToken = new DurationFormatUtils.Token ( Integer . valueOf ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
map . put ( STRING_CONSTANT , Integer . valueOf ( NUMBER_CONSTANT ) ) ;
map . put ( STRING_CONSTANT , Integer . valueOf ( NUMBER_CONSTANT ) ) ;
coll . add ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
coll . add ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( false , sb1 . equals ( Integer . valueOf ( NUMBER_CONSTANT ) ) ) ;
sb . appendln ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . subtract ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
Integer i = Integer . valueOf ( NUMBER_CONSTANT ) ;
Integer val = Integer . valueOf ( NUMBER_CONSTANT ) ;
Integer val = Integer . valueOf ( NUMBER_CONSTANT ) ;
iInteger = Integer . valueOf ( NUMBER_CONSTANT ) ;
map . put ( STRING_CONSTANT , Integer . valueOf ( NUMBER_CONSTANT ) ) ;
Integer i = Integer . valueOf ( NUMBER_CONSTANT ) ;
public Long getValue () { return Long . valueOf ( this . value ) ; }
mutNum . subtract ( Long . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Long . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == Long . valueOf ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( Long . valueOf ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableLong ( Long . valueOf ( NUMBER_CONSTANT ) ) . longValue () ) ;
mutNum . subtract ( Short . valueOf ( ( short ) NUMBER_CONSTANT ) ) ;
mutNum . add ( Short . valueOf ( ( short ) NUMBER_CONSTANT ) ) ;
public Short getValue () { return Short . valueOf ( this . value ) ; }
public Double getValue () { return Double . valueOf ( this . value ) ; }
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , Double . valueOf ( value ) ) ) ; } }
mutNum . subtract ( Double . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Double . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == Double . valueOf ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( Double . valueOf ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableDouble ( Double . valueOf ( NUMBER_CONSTANT ) ) . doubleValue () , NUMBER_CONSTANT ) ;
try { FieldUtils . writeField ( field , publicChild , Double . valueOf ( Double.MAX_VALUE ) ) ; } catch ( IllegalAccessException e ) {}
mutNum . subtract ( Float . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Float . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == Float . valueOf ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( Float . valueOf ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableFloat ( Float . valueOf ( NUMBER_CONSTANT ) ) . floatValue () , NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , new MutableObject < Double > ( Double . valueOf ( NUMBER_CONSTANT ) ) . toString () ) ;
public Float getValue () { return Float . valueOf ( this . value ) ; }
Object [] args = new Object [] { Double . valueOf ( STRING_CONSTANT ) } ;
args = new Object [] { STRING_CONSTANT , cal . getTime () , Double . valueOf ( STRING_CONSTANT ) }
{ throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT + java6Exception + STRING_CONSTANT + sunException ) ; }
assertArrayEquals ( null , StringUtils . splitPreserveAllTokens ( null , CHAR_CONS ) ) ;
assertArrayEquals ( null , StringUtils . splitPreserveAllTokens ( null ) ) ;
assertArrayEquals ( null , StringUtils . splitByWholeSeparatorPreserveAllTokens ( null , STRING_CONSTANT , - NUMBER_CONSTANT ) ) ;
assertArrayEquals ( null , StringUtils . splitByWholeSeparator ( null , STRING_CONSTANT , NUMBER_CONSTANT ) ) ;
assertArrayEquals ( null , StringUtils . splitByWholeSeparator ( null , STRING_CONSTANT ) ) ;
assertArrayEquals ( null , StringUtils . split ( null , CHAR_CONS ) ) ;
assertArrayEquals ( null , StringUtils . split ( null ) ) ;
public synchronized void delete () { listField . remove ( Integer . valueOf ( random . nextInt ( N ) ) ) ; }
separator = separator == null ? STRING_CONSTANT : separator ;
separator = separator == null ? STRING_CONSTANT : separator ;
separator = separator == null ? STRING_CONSTANT : separator ;
separator = ObjectUtils . toString ( separator ) ;
separator = ObjectUtils . toString ( separator ) ;
separator = ObjectUtils . toString ( separator ) ;
return super . equals ( o ) && b == rhs.b ;
return a == rhs.a ;
assertEquals ( bf_zero . setShortValue ( ( short ) NUMBER_CONSTANT , ( short ) j ) , ( short ) NUMBER_CONSTANT ) ;
{ long bits = Double . doubleToLongBits ( value ) ; return ( int ) ( bits ^ bits > > > NUMBER_CONSTANT ) ; }
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
return super . equals ( o ) && b == rhs.b ;
return a == rhs.a ;
int d2 = tmodd1 == NUMBER_CONSTANT ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ;
long m = ( long ) x * ( long ) y ;
long m = ( long ) x * ( long ) y ;
power % NUMBER_CONSTANT == NUMBER_CONSTANT
{ return ( double ) numerator / ( double ) denominator ; }
{ return ( float ) numerator / ( float ) denominator ; }
return result != null ? result : value ;
{ return initializer != null ? initializer . get () : null ; }
for ( E constant : values ) { total |= NUMBER_CONSTANT < < constant . ordinal () ; }
if ( str == null || prefix == null ) { return str == null && prefix == null ; }
if ( allStringsNull || longestStrLen == NUMBER_CONSTANT && ! anyStringNull ) { return INDEX_NOT_FOUND ; }
if ( length >= str . length () || length < middle . length () + NUMBER_CONSTANT ) { return str ; }
int noOfItems = endIndex - startIndex ;
int noOfItems = endIndex - startIndex ;
if ( match || preserveAllTokens && lastMatch ) { list . add ( str . substring ( start , i ) ) ; }
if ( match || preserveAllTokens && lastMatch ) { list . add ( str . substring ( start , i ) ) ; }
if ( separator == null || EMPTY . equals ( separator ) ) { return splitWorker ( str , null , max , preserveAllTokens ) ; }
pos < strLen - closeLen
if ( pos == INDEX_NOT_FOUND || pos == str . length () - separator . length () ) { return EMPTY ; }
if ( str . length () <= pos + len ) { return str . substring ( pos ) ; }
return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret ;
startPos > str . length () - searchStr . length ()
int endLimit = str . length () - searchStr . length () + NUMBER_CONSTANT ;
{ return schedFuture != null ? schedFuture : super . startTimer () ; }
int delimLen = delimiters == null ? - NUMBER_CONSTANT : delimiters.length ;
int delimLen = delimiters == null ? - NUMBER_CONSTANT : delimiters.length ;
inputLineLength - offset > wrapLength
return super . equals ( o ) && b == rhs.b ;
return a == rhs.a ;
{ return options == null ? false : options . contains ( option ) ; }
{ boolean b = ch >= CHAR_CONS && ch <= CHAR_CONS ; t += b ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
root = root == null ? th : root ;
if ( cls == null ) { return ! toClass . isPrimitive () ; }
pos + i >= len || chars [ pos + i ] != chars [ quoteStart + i ]
{ return obj == null ? NUMBER_CONSTANT : obj . hashCode () ; }
if ( object1 == null || object2 == null ) { return false ; }
dev = observed [ i ] - expected [ i ] ;
int remainder = len - pos ;
if ( coll == null || coll . isEmpty () ) { return false ; }
Object [] original = new Object [] { Boolean.TRUE , Boolean.FALSE } ;
assertTrue ( STRING_CONSTANT , flag == t . isDaemon () ) ;
assertEquals ( Boolean.TRUE , triple . getRight () ) ;
assertEquals ( Boolean.FALSE , triple . getRight () ) ;
triple2 = Triple . of ( null , STRING_CONSTANT , Long . valueOf ( NUMBER_CONSTANT ) )
fdf = getInstance ( STRING_CONSTANT , NEW_YORK , Locale.US ) ;
public Locale getLocale () { return locale ; }
public TimeZone getTimeZone () { return timeZone ; }
public String getPattern () { return pattern ; }
public Locale getLocale () { return mLocale ; }
public TimeZone getTimeZone () { return mTimeZone ; }
public String getPattern () { return mPattern ; }
DateFormatSymbols symbols = new DateFormatSymbols ( locale ) ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
if ( str . length () == NUMBER_CONSTANT || deepEmpty ( set ) ) { return StringUtils.EMPTY ; }
if ( cls != null ) { return cls ; } else { throw cnfe ; }
@ Override public Object getValue () { return null ; }
@ Override public Locale getLocale () { return locale ; }
@ Override public TimeZone getTimeZone () { return timeZone ; }
@ Override public String getPattern () { return pattern ; }
new Runnable () { @ Override public void run () { endOfPeriod () ; } }
@ Override public Locale getLocale () { return mLocale ; }
@ Override public TimeZone getTimeZone () { return mTimeZone ; }
@ Override public String getPattern () { return mPattern ; }
Locale getLocale ( ) ;
Locale getLocale ( ) ;
@ Before public void setUp ( ) throws Exception { exceptionContext = new DefaultExceptionContext () ; super . setUp () ; }
@ Before
assertFalse ( new BitField ( NUMBER_CONSTANT ) . isSet ( clearedBit ) ) ;
assertTrue ( rangea . isNegated () ) ;
assertTrue ( rangea . isNegated () ) ;
assertTrue ( rangea . isNegated () ) ;
assertFalse ( rangea . isNegated () ) ;
assertFalse ( rangea . isNegated () ) ;
assertFalse ( rangea . isNegated () ) ;
assertTrue ( rangea . isNegated () ) ;
assertFalse ( rangea . isNegated () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertTrue ( hc2a != NUMBER_CONSTANT ) ;
assertTrue ( sb.buffer.length >= NUMBER_CONSTANT ) ;
@ Override public int hashCode () { return b * NUMBER_CONSTANT + super . hashCode () ; }
{ return parseDateStrictly ( str , null , parsePatterns ) ; }
{ return parseDate ( str , null , parsePatterns ) ; }
DateParser parser = getInstance ( STRING_CONSTANT , GMT ) ;
{ return getInstance ( FormatCache . getPatternForStyle ( Integer . valueOf ( dateStyle ) , null , locale ) , TimeZone . getDefault () , Locale . getDefault () ) ; }
DateFormatSymbols symbols = DateFormatSymbols . getInstance ( locale ) ;
if ( eraBC && format . equals ( SHORT_FORMAT ) && locale . equals ( FastDateParser.JAPANESE_IMPERIAL ) ) { continue; }
if ( year < NUMBER_CONSTANT && locale . equals ( FastDateParser.JAPANESE_IMPERIAL ) ) { continue; }
assertEquals ( locale . toString () + STRING_CONSTANT + formattedDate + STRING_CONSTANT , expectedTime , actualTime ) ;
Strategy strategy = cache . get ( Integer . valueOf ( field ) ) ;
{ return getInstance ( FormatCache . getPatternForStyle ( Integer . valueOf ( dateStyle ) , null , locale ) , TimeZone . getDefault () , Locale . getDefault () ) ; }
return Integer . valueOf ( initializeCalls ) ;
return Integer . valueOf ( ++ initializeCalls ) ;
return Integer . valueOf ( REPEAT ) ;
this . value instanceof StringBuilder
StringBuilder buffer = new StringBuilder () ;
StringBuilder buffer = new StringBuilder () ;
StringBuilder result = new StringBuilder () ;
StringBuilder buffer = new StringBuilder () ;
StringBuilder expected = new StringBuilder () ;
StringBuilder sb = new StringBuilder ( dstInit ) ;
StringBuilder sb = new StringBuilder ( dstInit ) ;
StringBuilder sb = new StringBuilder ( dstInit ) ;
StringBuilder sb = new StringBuilder ( dstInit ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + nibble ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + nibble ) ;
HashMap < Boolean , MutableInt > occurrences = new HashMap < Boolean , MutableInt > ( NUMBER_CONSTANT ) ;
{ System.out . println ( STRING_CONSTANT + osName ) ; }
{ System.out . println ( STRING_CONSTANT + javaVersion ) ; }
{ output = ( int [] ) ArrayUtils . removeAll ( array , toRemove ) ; }
return ( boolean [] ) removeAll ( array , toRemove ) ;
return ( double [] ) removeAll ( array , toRemove ) ;
return ( float [] ) removeAll ( array , toRemove ) ;
return ( long [] ) removeAll ( array , toRemove ) ;
return ( char [] ) removeAll ( array , toRemove ) ;
return ( int [] ) removeAll ( array , toRemove ) ;
return ( short [] ) removeAll ( array , toRemove ) ;
return ( byte [] ) removeAll ( array , toRemove ) ;
result = ( T [] ) removeAll ( array , toRemove )
{ return printer . format ( millis ) ; }
Calendar c = newCalendar () ;
{ if ( str == null ) { return null ; } return WHITESPACE_PATTERN . matcher ( trim ( str ) ) . replaceAll ( STRING_CONSTANT ) ; }
{ if ( str == null ) { return null ; } return WHITESPACE_PATTERN . matcher ( trim ( str ) ) . replaceAll ( SPACE ) ; }
if ( isEmpty ( padStr ) ) { padStr = SPACE ; }
if ( isEmpty ( padStr ) ) { padStr = SPACE ; }
if ( isEmpty ( padStr ) ) { padStr = SPACE ; }
{ out . write ( toUtf16Escape ( codepoint ) ) ; }
@ Override public boolean equals ( final Object obj ) { return EqualsBuilder . reflectionEquals ( this , obj ) ; }
public void setObjectReference ( final TestObjectReference reference ) { this . reference = reference ; }
public TestObjectReference ( final int one ) { this . one = new TestObject ( one ) ; }
final Object o
public TestBCanEqualA ( final int b ) { this . b = b ; }
final Object o
public TestACanEqualB ( final int a ) { this . a = a ; }
final boolean testTransients
public void setT ( final int t ) { this . t = t ; }
public void setB ( final int b ) { this . b = b ; }
final Object o
public void setA ( final int a ) { this . a = a ; }
final Object o
public TestObject ( final int a ) { this . a = a ; }
c = new Comparable () { @ Override public int compareTo ( final Object other ) { return NUMBER_CONSTANT ; } }
final MutableInt other
final Object obj
final Number operand
final int operand
final Number operand
final int operand
final Number value
final int value
final String value
final Number value
final int value
final String input
final String baseMessage
final String label
final String label
final String format
final Object obj
final Range < T > other
final Range < T > otherRange
final Range < T > otherRange
final Range < T > otherRange
final Range < T > otherRange
final T element
final T element
final T element
final T element
final T element
final T element
final T element
final MutableDouble other
final Object obj
final Number operand
final double operand
final Number operand
final double operand
final Number value
final double value
final String value
final Number value
final double value
final int codepoint
final CharSequenceTranslator . . . translators
final CharSequence input
final boolean testTransients
final boolean testTransients
final String str
final char [] cbuf
final int c
@ Override public void mark ( final int readAheadLimit ) { mark = pos ; }
final int index
final int startIndex
final Object obj
final StrBuilder other
final StrBuilder other
final StrMatcher matcher
final StrMatcher matcher
final String str
final String str
final char ch
final char ch
final StrMatcher matcher
final StrMatcher matcher
final String str
final String str
final char ch
final char ch
final StrMatcher matcher
final String str
final char ch
final int length
final int length
final int length
final int startIndex
final int start
final String str
final String str
final StrMatcher matcher
final StrMatcher matcher
final String str
final String str
final char ch
final char ch
final int startIndex
final boolean value
final int index
final char separator
final String separator
final Iterator < > it
final Iterable < > iterable
final Object [] array
final Iterator < > it
final Iterable < > iterable
final T . . . array
final double value
final float value
final long value
final int value
final char ch
final boolean value
final char [] chars
final StrBuilder str
final StringBuilder str
final StringBuffer str
final String str
final Object obj
final double value
final float value
final long value
final int value
final char ch
final boolean value
final char [] chars
final StrBuilder str
final StringBuilder str
final StringBuffer str
final String str
final CharSequence seq
final Object obj
final int startIndex
final int index
final int index
final int capacity
final int length
final String newLine
final String str
{ @ Override public void vetoableChange ( final PropertyChangeEvent e ) { calledListeners . add ( this ) ; } }
{ @ Override public void vetoableChange ( final PropertyChangeEvent e ) { listenerSupport . removeListener ( this ) ; } }
listenerSupport . addListener ( new VetoableChangeListener () { @ Override public void vetoableChange ( final PropertyChangeEvent e ) {} } ) ;
final boolean expression
final T iterable
final T [] array
final T chars
final T chars
final T map
final T collection
final T [] array
final T object
final boolean expression
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String name
final String name
final String name
final String name
final String name
final ExecutorService exec
final Throwable cause
final String msg
final JavaVersion requiredVersion
final String property
final String osNamePrefix
final String versionPrefix
final boolean flag
final BasicThreadFactory factory
final int unit
final Date date
final int count
final int count
final int count
final int count
final int count
final Object obj
final T value
final T value
final MutableLong other
final Object obj
final Number operand
final long operand
final Number operand
final long operand
final Number value
final long value
final String value
final Number value
final long value
final int codepoint
final int codepoint
final int codepoint
final JavaVersion requiredVersion
final Throwable cause
protected String toUtf16Escape ( final int codepoint ) { return STRING_CONSTANT + hex ( codepoint ) ; }
final int codepoint
final int codepoint
final Object o
public void setA ( final int a ) { this . a = a ; }
final Object o
public TestObject ( final int a ) { this . a = a ; }
final byte holder
final short holder
final int holder
final byte holder
final short holder
final int holder
final int holder
final int holder
final short holder
final int holder
final short holder
final int holder
final int mask
final Constructor < T > ctor
final Class < T > cls
final Class < T > cls
final Class < T > cls
final Class < T > cls
public InspectingClient ( final TestFixture testFixture ) { this . testFixture = testFixture ; }
public MutatingClient ( final TestFixture testFixture ) { this . testFixture = testFixture ; }
final Fraction other
final Object obj
final Fraction fraction
final Fraction fraction
final Fraction fraction
final Fraction fraction
final int power
@ Override public boolean cancel ( final boolean mayInterruptIfRunning ) { return false ; }
final T value
final T value
final ConcurrentInitializer < T > initializer
final ConcurrentInitializer < T > initializer
final ExecutionException ex
final Throwable ex
final ExecutionException ex
final ExecutionException ex
final ExecutionException ex
final ExecutionException ex
final boolean enableSubstitutionInVariables
final StrLookup < > variableResolver
final String suffix
final char suffix
final StrMatcher suffixMatcher
final String prefix
final char prefix
final StrMatcher prefixMatcher
final char escapeCharacter
final StrBuilder source
final StringBuffer source
final Object source
final StrBuilder source
final StringBuffer source
final char [] source
final String source
final StrLookup < > variableResolver
final Map < String , V > valueMap
final Object source
final Class < E > enumClass
final Class < E > enumClass
final Class < E > enumClass
final Class < E > enumClass
final Class < E > enumClass
final Object obj2
final Object value
final String format
final long durationMillis
final long durationMillis
final String msg
DateParser getInstance ( final String format ) { return getInstance ( format , TimeZone . getDefault () , Locale . getDefault () ) ; }
final String str
final int threshold
final String . . . strs
final CharSequence . . . css
final String str
final String str
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final String str
final String str
final String str
final String str
final String str
final int size
final CharSequence cs
final String str
final String str
final String str
final String str
final T . . . elements
final String str
final String str
final String str
final String str
final String str
final String str
final CharSequence seq
final String input
final String . . . strs
final String stripChars
final String str
final String str
final String str
final String str
final String str
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final Boolean . . . array
final boolean . . . array
final Boolean . . . array
final boolean . . . array
final Boolean . . . array
final boolean . . . array
final boolean bool
final boolean bool
final boolean bool
final Boolean bool
final Boolean bool
final Boolean bool
final String str
final String str
final Boolean bool
final boolean bool
final boolean bool
final Integer value
final int value
final int value
final Boolean bool
final Boolean bool
final Boolean bool
final Boolean bool
final Boolean bool
final Boolean bool
final Object obj
@ Override public Date parse ( final String source ) throws ParseException { return parser . parse ( source ) ; }
final Calendar calendar
final Date date
final long millis
final int style
final int style
final String pattern
final Class < > clazz
final String . . . excludeFieldNamesParam
final boolean appendTransients
final boolean appendStatics
final Object array
final Field field
final Class < > clazz
final Field field
final Object object
final Object [] array
final Collection < String > collection
final Object object
final int nibble
final int nibble
final boolean [] src
final boolean [] src
final boolean [] src
final char hexDigit
final char hexDigit
final char hexDigit
final char hexDigit
public void testTwo ( final ChildInterface obj ) {}
public void testOne ( final GrandParentObject obj ) {}
public void testOne ( final Object obj ) {}
public void testOne ( final ParentObject obj ) {}
public void testTwo ( final GrandParentObject obj ) {}
public void testTwo ( final Object obj ) {}
final Class < > c
final Class < > [] c
@ Override public void setValue ( final Object value ) {}
public void oneParameter ( final String s ) {}
public String foo ( final Object o ) { return STRING_CONSTANT ; }
public String foo ( final String s ) { return STRING_CONSTANT ; }
public String foo ( final double d ) { return STRING_CONSTANT ; }
public String foo ( final Integer i ) { return STRING_CONSTANT ; }
public String foo ( final int i ) { return STRING_CONSTANT ; }
public static String bar ( final Object o ) { return STRING_CONSTANT ; }
public static String bar ( final String s ) { return STRING_CONSTANT ; }
public static String bar ( final Integer i ) { return STRING_CONSTANT ; }
final CharRange r
final Object obj
final CharRange range
final char ch
final char ch
final char ch
final boolean negated
final boolean fieldSeparatorAtEnd
final boolean fieldSeparatorAtStart
final boolean arrayContentDetail
final boolean defaultFullDetail
final boolean useFieldNames
final boolean useIdentityHashCode
final boolean useShortClassName
final boolean useClassName
final Class < > cls
final Boolean fullDetailRequest
final StringBuffer buffer
final StringBuffer buffer
final StringBuffer buffer
final StringBuffer buffer
final Object value
final Object value
final Object value
final Callable < T > call
final Callable < T > call
final StrTokenizer tokenizer
final StrTokenizer tokenizer
final String data
final StrTokenizer tokenizer
final int superCompareTo
DatePrinter getInstance ( final String format ) { return getInstance ( format , TimeZone . getDefault () , Locale . getDefault () ) ; }
final String languageCode
final String countryCode
final Locale locale
final Locale locale
public AClass ( final AAClass < String > enclosingInstance ) { enclosingInstance . super ( ) ; }
final String baseMessage
final String label
final String label
final Throwable cause
final String message
final String format
final Object obj
final Pair < L , R > other
final String str
CharMatcher ( final char ch ) { super(); this . ch = ch ; }
final char chars []
final String str
final String chars
final char . . . chars
final char ch
final String str
final String str
final String str
final char . . . delimiters
final String str
final String str
final String str
final String str
final Object array
final float [] array
final double [] array
final byte [] array
final short [] array
final int [] array
final long [] array
final float [] array
final double [] array
final byte [] array
final short [] array
final int [] array
final long [] array
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final Object o
final TestObject rhs
public void setA ( final int a ) { this . a = a ; }
final Object o
public TestObject ( final int a ) { this . a = a ; }
final Thread.UncaughtExceptionHandler handler
final int prio
final boolean f
final String pattern
final ThreadFactory factory
final Thread t
final Runnable r
final Builder builder
final Object obj
final T obj
final String [] eventTypes
final Collection < > coll
final String language
final float [] array
final double [] array
final float [] array
final double [] array
final String key
final Map < String , V > map
final Map < String , V > map
final Object obj
final Object . . . keys
final String pattern
public BackgroundInitializerTestImpl ( final ExecutorService exec ) { super ( exec ) ; }
final BackgroundInitializerTestImpl init
CollectionHolder ( final T collection ) { this . collection = collection ; }
final String format
final Object obj
final int codepoint
final int codepoint
final OPTION option
final OPTION . . . options
final int loopCount
final int loopCount
final int loopCount
public static void main ( final String [] args ) { new CharUtilsPerfRun () . run () ; }
final Throwable th
final Throwable th
final Throwable t
final String stackTrace
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Type type
final Type type
final ParameterizedType parameterizedType
final WildcardType wildcardType
final WildcardType wildcardType
final TypeVariable < > typeVariable
final Type [] bounds
final ParameterizedType type
final String name
final ExecutorService exec
final ExecutorService execDestroy
final ExecutorService externalExecutor
final ExecutorService exec
final Collection < > coll
final ParsePosition pos
final String desc
final Object obj
final String pattern
final String pattern
private void assertGetClassThrowsClassNotFound ( final String className ) throws Exception { assertGetClassThrowsException ( className , ClassNotFoundException . class ) ; }
private void assertGetClassThrowsNullPointerException ( final String className ) throws Exception { assertGetClassThrowsException ( className , NullPointerException . class ) ; }
final Class < > c
final String [] strings
final String canonicalName
final Class < > cls
final String canonicalName
final Class < > cls
final Object . . . array
final String className
final Class < > cls
final Class < > . . . classes
final Class < > cls
final Class < > . . . classes
final Class < > cls
final Class < > type
final Class < > type
final boolean autoboxing
final List < Class < > > classes
final List < String > classNames
final HashSet < Class < > > interfacesFound
final Class < > cls
final Class < > cls
final Class < > cls
final Class < > cls
final Class < > cls
final String [] [] array
final String toString
final String toString
final String toString
final Object obj
@ Override public char charAt ( final int index ) { return seq . charAt ( index ) ; }
public CustomCharSequence ( final CharSequence seq ) { this . seq = seq ; }
final char [] str
final StrBuilder str
final StringBuilder str
final StringBuffer str
final String str
final String str
final Throwable cause
final boolean ignoreEmptyTokens
final boolean emptyAsNull
final StrMatcher trimmer
final char ignored
final StrMatcher ignored
final char quote
final StrMatcher quote
final String delim
final char delim
final StrMatcher delim
final List < String > list
final String obj
final String obj
final char [] input
final String input
final char [] input
final String input
final char [] input
final String input
final char [] input
final String input
final String replaceTemplate
final char ch
final char ch
final char ch
final char ch
final char ch
final char ch
final char ch
final char ch
final Character ch
final char ch
final Character ch
final char ch
final Character ch
final char ch
final String str
final Character ch
final String str
final char ch
final Field field
final String formattedDate
final int superHashCode
final short [] array
final short value
final Object [] array
final Object object
final long [] array
final long value
final int [] array
final int value
final float [] array
final float value
final double [] array
final double value
final char [] array
final char value
final byte [] array
final byte value
final boolean [] array
final boolean value
final Object value
final Object value
final Object value
void warn ( final String msg ) { System.err . println ( msg ) ; }
private void assertSupportedEncoding ( final String name ) { assertTrue ( STRING_CONSTANT + name , CharEncoding . isSupported ( name ) ) ; }
final Annotation a
final java.lang.Class < > cls
final T . . . items
final T . . . items
final T . . . values
final T . . . values
final Object obj
final Object object
final Object . . . objects
final Object obj
final T . . . values
final boolean isEquals
final boolean superEquals
final boolean [] src
@ Override public char charAt ( final int arg0 ) { return value . charAt ( arg0 ) ; }
final String value
public void removePropertyChangeListener ( final PropertyChangeListener listener ) { listeners . removeListener ( listener ) ; }
public void addPropertyChangeListener ( final PropertyChangeListener listener ) { listeners . addListener ( listener ) ; }
protected void addVetoableChangeListener ( final VetoableChangeListener listener ) {}
final String property
public void addPropertyChangeListener ( final PropertyChangeListener listener ) { throw new RuntimeException () ; }
public void addMultipleEventListener ( final MultipleEventListener listener ) { listeners . addListener ( listener ) ; }
final String eventName
final Class < L > listenerType
public void eventOccurred ( final PropertyChangeEvent e ) { count ++ ; }
new PropertyChangeListener () { @ Override public void propertyChange ( final PropertyChangeEvent e ) {} }
final String toString
final String superToString
final Object object
final short [] array
final short value
final Object [] array
final Object obj
final long [] array
final long value
final int [] array
final int value
final float [] array
final float value
final double [] array
final double value
final char [] array
final char value
final byte [] array
final byte value
final boolean [] array
final boolean value
final Object object
final Object object
final Object object
final ToStringStyle style
final R value
final R right
final L left
public SimpleReflectionTestFixture ( final Object o ) { this . o = o ; }
final Object o
final R right
final M middle
final L left
void warn ( final String msg ) { System.err . println ( msg ) ; }
private void readObject ( final ObjectInputStream in ) throws ClassNotFoundException { throw new ClassNotFoundException ( SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE ) ; }
{ @ Override public void write ( final int arg0 ) throws IOException { throw new IOException ( SERIALIZE_IO_EXCEPTION_MESSAGE ) ; } }
final ObjectStreamClass desc
final byte [] objectData
final InputStream inputStream
final Serializable obj
final T object
final CharSequence cs
final CharSequence [] . . . lookup
final MutableByte other
final Object obj
final Number operand
final byte operand
final Number operand
final byte operand
final Number value
final byte value
final String value
final Number value
final byte value
final Object obj
final char ch
final String str
final String . . . set
final String . . . setStrs
final Formattable formattable
final CharSequenceTranslator . . . translators
final ObjectInputStream objectInputStream
final ObjectOutputStream objectOutputStream
final L listener
final L listener
final Class < L > listenerInterface
final Class < T > listenerInterface
@ Override int modify ( final int iValue ) { return iValue % NUMBER_CONSTANT ; }
@ Override int modify ( final int iValue ) { return iValue % NUMBER_CONSTANT ; }
@ Override int modify ( final int iValue ) { return iValue - NUMBER_CONSTANT ; }
final Locale locale
int modify ( final int iValue ) { return iValue ; }
NumberStrategy ( final int field ) { this . field = field ; }
CopyQuotedStrategy ( final String formatField ) { this . formatField = formatField ; }
final int field
final Calendar definingCalendar
final int twoDigitYear
final String source
@ Override public Object parseObject ( final String source ) throws ParseException { return parse ( source ) ; }
final ObjectInputStream in
final Object obj
final int limit
final Object other
final Object _value
final Class < > c
final Class < > [] c
public TestBean ( final Object o ) { toString = STRING_CONSTANT ; }
public TestBean ( final String s ) { toString = STRING_CONSTANT ; }
public TestBean ( final double d ) { toString = STRING_CONSTANT ; }
public TestBean ( final Integer i ) { toString = STRING_CONSTANT ; }
public TestBean ( final int i ) { toString = STRING_CONSTANT ; }
final MutableBoolean other
final Object obj
final Boolean value
final boolean value
final Boolean value
final boolean value
CollectionHolder ( final T collection ) { this . collection = collection ; }
final String summaryObjectEndText
final String summaryObjectStartText
final String sizeEndText
final String sizeStartText
final String nullText
final boolean fieldSeparatorAtEnd
final boolean fieldSeparatorAtStart
final String fieldSeparator
final String fieldNameValueSeparator
final String contentEnd
final String contentStart
final String arraySeparator
final String arrayEnd
final String arrayStart
final boolean arrayContentDetail
final boolean defaultFullDetail
final boolean useFieldNames
final boolean useIdentityHashCode
final boolean useShortClassName
final boolean useClassName
final BitSet coll
final HashSet < Integer > coll
final int count
final int count
final int count
final int count
final int count
final Object obj
final boolean colon
final NumberRule rule
final NumberRule rule
TwoDigitNumberField ( final int field ) { mField = field ; }
UnpaddedNumberField ( final int field ) { mField = field ; }
final String value
CharacterLiteral ( final char value ) { mValue = value ; }
final ObjectInputStream in
final Object obj
final Calendar calendar
final Date date
final Calendar c
final long millis
final R value
final String val
final String str
final String str
final String str
final String str
final String str
final String str
final MutableShort other
final Object obj
final Number operand
final short operand
final Number operand
final short operand
final Number value
final short value
final String value
final Number value
final short value
final String baseMessage
final String label
final String label
final Throwable cause
final String message
final MutableFloat other
final Object obj
final Number operand
final float operand
final Number operand
final float operand
final Number value
final float value
final String value
final Number value
final float value
final Class < > destClass
final Member m
final int modifiers
final AccessibleObject o
public NestableException ( final Throwable t ) { super ( t ) ; }
public void setCause ( final Throwable cause ) { this . cause = cause ; }
public ExceptionWithCause ( final Throwable cause ) { super(); setCause ( cause ) ; }
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final T [] array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final Object [] array
final boolean [] array
final Boolean [] array
final float [] array
final Float [] array
final double [] array
final Double [] array
final byte [] array
final Byte [] array
final short [] array
final Short [] array
final int [] array
final Integer [] array
final long [] array
final Long [] array
final char [] array
final Character [] array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final Object [] array
final Object array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final T [] array
final Boolean [] array
final Float [] array
final Double [] array
final Byte [] array
final Character [] array
final Short [] array
final Integer [] array
final Long [] array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final String [] array
final Object [] array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final T [] array
final Object [] array
final Object array
final Object array
final EqualsBuilder equalsBuilder = new EqualsBuilder () ;
final EqualsBuilder equalsBuilder = new EqualsBuilder () ;
final TestSubObject rhs = ( TestSubObject ) o ;
final TestObject rhs = ( TestObject ) o ;
final OctalUnescaper oue = new OctalUnescaper () ;
try { intRange . elementCompareTo ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( final NullPointerException npe ) {}
{ final String str = intRange . toString ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , str ) ; }
final String str = intRange . toString () ;
final char pad = CHAR_CONS ;
final int anotherVal = other.value ;
final StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
{ final double anotherVal = other.value ; return Double . compare ( value , anotherVal ) ; }
{ final long bits = Double . doubleToLongBits ( value ) ; return ( int ) ( bits ^ bits > > > NUMBER_CONSTANT ) ; }
final String str = super . getContent () ;
final char buf [] = buffer ;
final int strLen = str . length () ;
final char [] thisBuf = buffer ;
final char [] thisBuf = buffer ;
final int len = str . length () ;
final int len = str . length () ;
final char [] buf = buffer ;
final int newSize = size - removeLen + insertLen ;
final int len = endIndex - startIndex ;
final int len = chars.length ;
{ if ( iterable != null ) { for ( final Object o : iterable ) { append ( o ) ; } } return this ; }
{ for ( final Object element : array ) { append ( element ) ; } }
final int len = length () ;
final int len = length () ;
final int len = length () ;
final int len = length () ;
final int len = length () ;
final int len = length () ;
final int len = length () ;
final char [] old = buffer ;
final char [] old = buffer ;
for ( final BackgroundInitializer < > bi : childInitializers . values () ) { result += bi . getTaskCount () ; }
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
{ final Integer [] iArray = null ; assertEquals ( null , ArrayUtils . toPrimitive ( iArray , Integer.MIN_VALUE ) ) ; }
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
final StringBuffer buf = new StringBuffer ( STRING_CONSTANT ) ;
catch ( final SecurityException ex ) { System.err . println ( STRING_CONSTANT + property + STRING_CONSTANT ) ; return null ; }
{ final BasicThreadFactory factory = builder . build () ; checkFactoryDefaults ( factory ) ; }
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final long millisPerUnit = getMillisPerUnit ( unit ) ;
final Calendar calendar = Calendar . getInstance () ;
final Calendar gval = Calendar . getInstance () ;
final Calendar gval = Calendar . getInstance () ;
final Calendar gval = Calendar . getInstance () ;
final Calendar gval = Calendar . getInstance () ;
{ final Calendar c = Calendar . getInstance () ; c . setTime ( date ) ; return c ; }
final Calendar c = Calendar . getInstance () ;
final Calendar c = Calendar . getInstance () ;
final long anotherVal = other.value ;
final String str = f . toProperString () ;
final String str = f . toString () ;
try { f1 . compareTo ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( final NullPointerException ex ) {}
try { f = f . abs () ; fail ( STRING_CONSTANT ) ; } catch ( final ArithmeticException ex ) {}
try { f = f . negate () ; fail ( STRING_CONSTANT ) ; } catch ( final ArithmeticException ex ) {}
final Object obj = new Object () ;
final TestSubObject rhs = ( TestSubObject ) o ;
final TestObject rhs = ( TestObject ) o ;
{ try { return getAccessibleConstructor ( cls . getConstructor ( parameterTypes ) ) ; } catch ( final NoSuchMethodException e ) { return null ; } }
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final int properNumerator = getProperNumerator () ;
final Fraction other = ( Fraction ) obj ;
final Fraction f = this . multiplyBy ( this ) ;
final int gcd = greatestCommonDivisor ( numerator , denominator ) ;
catch ( final ConcurrentException cex ) { throw new ConcurrentRuntimeException ( cex . getCause () ) ; }
final V value = map . get ( key ) ;
try { return initialize ( initializer ) ; } catch ( final ConcurrentException cex ) { throw new ConcurrentRuntimeException ( cex . getCause () ) ; }
{ final ConcurrentRuntimeException crex = extractCauseUnchecked ( ex ) ; if ( crex != null ) { throw crex ; } }
{ final ConcurrentException cex = extractCause ( ex ) ; if ( cex != null ) { throw cex ; } }
final StrLookup < > resolver = getVariableResolver () ;
final StrBuilder buf = new StrBuilder ( NUMBER_CONSTANT ) ;
final StrBuilder buf = new StrBuilder ( source ) ;
final E value
final E constant
try { return Enum . valueOf ( enumClass , enumName ) ; } catch ( final IllegalArgumentException ex ) { return null ; }
try { Enum . valueOf ( enumClass , enumName ) ; return true ; } catch ( final IllegalArgumentException ex ) { return false ; }
final Token tok2 = ( Token ) obj2 ;
final int sz = tokens.length ;
{ final DateParser parser = getInstance ( yMdHmsSZ , REYKJAVIK ) ; assertEquals ( REYKJAVIK , parser . getTimeZone () ) ; }
{ final DateParser parser = getInstance ( yMdHmsSZ , SWEDEN ) ; assertEquals ( SWEDEN , parser . getLocale () ) ; }
{ final DateParser parser = getInstance ( yMdHmsSZ ) ; assertEquals ( yMdHmsSZ , parser . getPattern () ) ; }
{ final DateParser parser = getInstance ( YMD_SLASH ) ; assertTrue ( parser . toString () . startsWith ( STRING_CONSTANT ) ) ; }
final Calendar cal = Calendar . getInstance () ;
final int gmt = msg . indexOf ( STRING_CONSTANT ) ;
for ( final CharSequence searchString : searchStrings ) { if ( StringUtils . endsWith ( string , searchString ) ) { return true ; } }
for ( final CharSequence searchString : searchStrings ) { if ( StringUtils . startsWith ( string , searchString ) ) { return true ; } }
final CharSequence tmp = s ;
final int smallestIndexOfDiff = indexOfDifference ( strs ) ;
final int at = indexOfDifference ( str1 , str2 ) ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int pads = size - str . length () ;
final int pads = size - str . length () ;
final char [] chars = str . toCharArray () ;
final int pos = str . lastIndexOf ( separator ) ;
final int pos = str . lastIndexOf ( separator ) ;
final int pos = str . indexOf ( separator ) ;
final int pos = str . indexOf ( separator ) ;
final int strLen = seq . length () ;
{ final String ts = trim ( str ) ; return isEmpty ( ts ) ? null : ts ; }
final boolean element
for ( final boolean element : array ) { if ( element ) { return true ; } }
for ( final boolean element : array ) { if ( ! element ) { return false ; } }
final FastDateFormat other = ( FastDateFormat ) obj ;
final Object object = getObject () ;
final char c = Character . forDigit ( nibble , NUMBER_CONSTANT ) ;
catch ( final NoSuchMethodException e ) {}
final char cur = current ;
final StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
final CharRange other = ( CharRange ) obj ;
if ( start > end ) { final char temp = start ; start = end ; end = temp ; }
final Object item = array [ i ] ;
final StrTokenizer tkn = new StrTokenizer ( STRING_CONSTANT ) ;
final StrTokenizer tok = new StrTokenizer ( STRING_CONSTANT ) ;
final StrTokenizer tok = new StrTokenizer ( STRING_CONSTANT ) ;
final StrTokenizer tok = new StrTokenizer () ;
final String input = STRING_CONSTANT ;
try { tokenizer . next () ; fail () ; } catch ( final NoSuchElementException ex ) {}
final CompareToBuilder compareToBuilder = new CompareToBuilder () ;
{ final DatePrinter printer = getInstance ( YYYY_MM_DD , NEW_YORK ) ; assertEquals ( NEW_YORK , printer . getTimeZone () ) ; }
{ final DatePrinter printer = getInstance ( YYYY_MM_DD , SWEDEN ) ; assertEquals ( SWEDEN , printer . getLocale () ) ; }
{ final DatePrinter printer = getInstance ( YYYY_MM_DD ) ; assertEquals ( YYYY_MM_DD , printer . getPattern () ) ; }
{ final DatePrinter printer = getInstance ( YYYY_MM_DD ) ; assertTrue ( printer . toString () . startsWith ( STRING_CONSTANT ) ) ; }
final CharRange rangea = CharRange . isNot ( CHAR_CONS ) ;
final CharRange rangea = CharRange . is ( CHAR_CONS ) ;
catch ( final InterruptedException iex ) { Thread . currentThread () . interrupt () ; }
try { result = neu . translate ( input ) ; fail ( STRING_CONSTANT ) ; } catch ( final IllegalArgumentException iae ) {}
final NumericEntityUnescaper neu = new NumericEntityUnescaper () ;
final int len = chars.length ;
for ( final char delimiter : delimiters ) { if ( ch == delimiter ) { return true ; } }
try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
final String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
final String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
final String o1 = STRING_CONSTANT ;
final String o1 = STRING_CONSTANT ;
{ final TestObject o1 = new TestObject ( NUMBER_CONSTANT ) ; CompareToBuilder . reflectionCompare ( o1 , null ) ; }
final TestSubObject rhs = ( TestSubObject ) o ;
final TestObject rhs = ( TestObject ) o ;
{ final BasicThreadFactory factory = new BasicThreadFactory ( this ) ; reset () ; return factory ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
{ final ExecutorService exec = Executors . newSingleThreadExecutor () ; new CallableBackgroundInitializer < Integer > ( null , exec ) ; }
{ try { coll . add ( null ) ; fail () ; } catch ( final UnsupportedOperationException ex ) {} }
final Locale locale = LocaleUtils . toLocale ( localeString ) ;
final Locale locale = LocaleUtils . toLocale ( localeString ) ;
final Locale locale = LocaleUtils . toLocale ( language ) ;
final Object obj = map . get ( key ) ;
{ final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . isException ( STRING_CONSTANT ) ; }
{ final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getException ( STRING_CONSTANT ) ; }
{ final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getResultObject ( STRING_CONSTANT ) ; }
{ final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getInitializer ( STRING_CONSTANT ) ; }
catch ( final IllegalStateException istex ) { initializer . get () ; }
final ExecutorService exec = Executors . newCachedThreadPool () ;
final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer . get () ;
final Object key
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
{ final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; assertFalse ( STRING_CONSTANT , init . isStarted () ) ; }
{ final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; init . get () ; }
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
{ final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; assertNull ( STRING_CONSTANT , init . getActiveExecutor () ) ; }
{ final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; init . start () ; checkInitialize ( init ) ; }
final long total = System . currentTimeMillis () - start ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
{ final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , sb . toString () ) ; }
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
catch ( final IndexOutOfBoundsException ex ) {}
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final Type rawType = parameterizedType . getRawType () ;
final Type replacementType = typeVarAssigns . get ( type ) ;
final Type bound
try { return Charset . isSupported ( name ) ; } catch ( final IllegalCharsetNameException ex ) { return false ; }
for ( final Object name : coll ) { if ( name != null ) { return true ; } }
final char [] buffer = pattern . toCharArray () ;
final ExtendedMessageFormat rhs = ( ExtendedMessageFormat ) obj ;
catch ( final Exception e ) { assertTrue ( exceptionType . isAssignableFrom ( e . getClass () ) ) ; }
final boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
final boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
{ for ( final String s : strings ) { if ( StringUtils . isNotEmpty ( s ) ) { return false ; } } }
final StringBuilder canonicalClassNameBuffer = new StringBuilder ( className ) ;
final int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ;
final String toString = AnnotationUtils . toString ( testAnno ) ;
final Person p = new Person () ;
final CustomCharSequence other = ( CustomCharSequence ) obj ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder ( NUMBER_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
{ try { return cloneReset () ; } catch ( final CloneNotSupportedException ex ) { return null ; } }
{ final StrTokenizer tok = getTSVClone () ; tok . reset ( input ) ; return tok ; }
{ final StrTokenizer tok = getTSVClone () ; tok . reset ( input ) ; return tok ; }
{ final StrTokenizer tok = getCSVClone () ; tok . reset ( input ) ; return tok ; }
{ final StrTokenizer tok = getCSVClone () ; tok . reset ( input ) ; return tok ; }
final StrBuilder buf = new StrBuilder () ;
final StrSubstitutor sub = new StrSubstitutor () ;
{ final StrSubstitutor sub = new StrSubstitutor () ; assertEquals ( STRING_CONSTANT , sub . replace ( STRING_CONSTANT ) ) ; }
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
{ final StrSubstitutor sub = new StrSubstitutor () ; assertEquals ( STRING_CONSTANT , sub . replace ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
try { mutNum . compareTo ( null ) ; fail () ; } catch ( final NullPointerException ex ) {}
try { mutNum . setValue ( null ) ; fail () ; } catch ( final NullPointerException ex ) {}
try { new MutableShort ( ( Number ) null ) ; fail () ; } catch ( final NullPointerException ex ) {}
{ for ( final short element : array ) { append ( element ) ; } }
{ for ( final Object element : array ) { append ( element ) ; } }
{ for ( final long element : array ) { append ( element ) ; } }
{ for ( final int element : array ) { append ( element ) ; } }
{ for ( final float element : array ) { append ( element ) ; } }
{ for ( final double element : array ) { append ( element ) ; } }
{ for ( final char element : array ) { append ( element ) ; } }
{ for ( final byte element : array ) { append ( element ) ; } }
{ for ( final boolean element : array ) { append ( element ) ; } }
final StrMatcher matcher = StrMatcher . stringMatcher ( STRING_CONSTANT ) ;
final StrMatcher matcher = StrMatcher . stringMatcher ( STRING_CONSTANT ) ;
final StrMatcher matcher = StrMatcher . charSetMatcher ( STRING_CONSTANT ) ;
final StrMatcher matcher = StrMatcher . charMatcher ( CHAR_CONS ) ;
final StrMatcher matcher = StrMatcher . noneMatcher () ;
final StrMatcher matcher = StrMatcher . quoteMatcher () ;
final StrMatcher matcher = StrMatcher . doubleQuoteMatcher () ;
final StrMatcher matcher = StrMatcher . singleQuoteMatcher () ;
final StrMatcher matcher = StrMatcher . trimMatcher () ;
final StrMatcher matcher = StrMatcher . splitMatcher () ;
final StrMatcher matcher = StrMatcher . spaceMatcher () ;
final StrMatcher matcher = StrMatcher . tabMatcher () ;
final StrMatcher matcher = StrMatcher . commaMatcher () ;
final int part1 = name . hashCode () * NUMBER_CONSTANT ;
final T value
final T value
final StringBuffer buffer = new StringBuffer () ;
{ for ( final Object object : objects ) { hash = hash * NUMBER_CONSTANT + ObjectUtils . hashCode ( object ) ; } }
if ( values != null ) { for ( final T val : values ) { if ( val != null ) { return val ; } } }
{ try { return parentClass . getMethod ( methodName , parameterTypes ) ; } catch ( final NoSuchMethodException e ) { return null ; } }
{ try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( final NoSuchMethodException e ) { return null ; } }
final String osName = System . getProperty ( STRING_CONSTANT ) ;
final String javaVersion = System . getProperty ( STRING_CONSTANT ) ;
final File dir = SystemUtils . getUserHome () ;
final File dir = SystemUtils . getUserDir () ;
final File dir = SystemUtils . getJavaIoTmpDir () ;
final File dir = SystemUtils . getJavaHome () ;
final String src = STRING_CONSTANT ;
final String src = STRING_CONSTANT ;
final String src = STRING_CONSTANT ;
final String src = STRING_CONSTANT ;
{ final Object [] array = null ; assertEquals ( NUMBER_CONSTANT , ObjectUtils . hashCodeMulti ( array ) ) ; }
final String oldValue = this . property ;
{ final Integer count = eventCounts . get ( eventName ) ; return count == null ? NUMBER_CONSTANT : count . intValue () ; }
catch ( final RuntimeException e ) {}
final int start = index + NUMBER_CONSTANT ;
final long testResult = DateUtils . getFragmentInHours ( aCalendar , Calendar.YEAR ) ;
final long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.YEAR ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.YEAR ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.YEAR ) ;
final long testResult = DateUtils . getFragmentInHours ( aCalendar , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInHours ( aDate , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInMinutes ( aDate , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.MONTH ) ;
final long expectedValue = hours ;
final long expectedValue = hours ;
{ final long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.HOUR_OF_DAY ) ; assertEquals ( minutes , testResult ) ; }
{ final long testResult = DateUtils . getFragmentInMinutes ( aDate , Calendar.HOUR_OF_DAY ) ; assertEquals ( minutes , testResult ) ; }
final long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.HOUR_OF_DAY ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.HOUR_OF_DAY ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.HOUR_OF_DAY ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.HOUR_OF_DAY ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.MINUTE ) ;
{ final long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.MINUTE ) ; assertEquals ( seconds , testResult ) ; }
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.MINUTE ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.MINUTE ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.SECOND ) ;
{ final long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.SECOND ) ; assertEquals ( millis , testResult ) ; }
{ final R result = getRight () ; setRight ( value ) ; return result ; }
final String message = exceptionContext . getMessage () ;
final String trace = ExceptionUtils . getStackTrace ( exceptionContext ) ;
final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture () ;
final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture () ;
final SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture () ;
final SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture () ;
final SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture () ;
final SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture () ;
final Outer outer = new Outer () ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final Character c = new Character ( CHAR_CONS ) ;
final Locale dflt = Locale . getDefault () ;
final Locale dflt = Locale . getDefault () ;
final Locale dflt = Locale . getDefault () ;
final Locale dflt = Locale . getDefault () ;
final Locale dflt = Locale . getDefault () ;
final Calendar testCalendar = Calendar . getInstance () ;
try { DateUtils . toCalendar ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( final NullPointerException npe ) {}
final GregorianCalendar cal = new GregorianCalendar () ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
catch ( final IllegalArgumentException ex ) {}
catch ( final IllegalArgumentException ex ) {}
final IllegalArgumentException ex
final long seed = System . currentTimeMillis () ;
final long seed = System . currentTimeMillis () ;
catch ( final SerializationException ex ) { return; }
{ final Object test = SerializationUtils . clone ( null ) ; assertNull ( test ) ; }
try { SerializationUtils . deserialize ( new byte [ NUMBER_CONSTANT ] ) ; } catch ( final SerializationException ex ) { return; }
try { SerializationUtils . deserialize ( ( byte [] ) null ) ; } catch ( final IllegalArgumentException ex ) { return; }
catch ( final SerializationException ex ) { return; }
catch ( final SerializationException ex ) { return; }
try { SerializationUtils . deserialize ( ( InputStream ) null ) ; } catch ( final IllegalArgumentException ex ) { return; }
{ try { SerializationUtils . serialize ( null , null ) ; } catch ( final IllegalArgumentException ex ) { return; } fail () ; }
{ try { SerializationUtils . serialize ( iMap , null ) ; } catch ( final IllegalArgumentException ex ) { return; } fail () ; }
final Exception ex = new Exception () ;
catch ( final IllegalArgumentException expected ) {}
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
{ final ByteArrayOutputStream baos = new ByteArrayOutputStream ( NUMBER_CONSTANT ) ; serialize ( obj , baos ) ; return baos . toByteArray () ; }
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final String message = exceptionContext . getMessage () ;
final String trace = ExceptionUtils . getStackTrace ( exceptionContext ) ;
final byte anotherVal = other.value ;
final CharSet other = ( CharSet ) obj ;
{ for ( final CharRange range : set ) { if ( range . contains ( ch ) ) { return true ; } } return false ; }
final int sz = set.length ;
try { CharUtils . toIntValue ( CHAR_CONS ) ; } catch ( final IllegalArgumentException ex ) {}
try { CharUtils . toChar ( ( Character ) null ) ; } catch ( final IllegalArgumentException ex ) {}
{ for ( final L listener : listeners ) { method . invoke ( listener , args ) ; } return null ; }
for ( final String textKeyValue : keyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
final FastDateParser other = ( FastDateParser ) obj ;
final ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor ( THREAD_POOL_SIZE ) ;
final IDKey idKey = ( IDKey ) other ;
{ final boolean anotherVal = other.value ; return value == anotherVal ? NUMBER_CONSTANT : ( value ? NUMBER_CONSTANT : - NUMBER_CONSTANT ) ; }
final BitSet toRemove = new BitSet () ;
try { StrLookup . systemPropertiesLookup () . lookup ( null ) ; fail () ; } catch ( final NullPointerException ex ) {}
final Integer i = Integer . valueOf ( NUMBER_CONSTANT ) ;
final TimeZoneDisplayKey other = ( TimeZoneDisplayKey ) obj ;
final TimeZone zone = calendar . getTimeZone () ;
{ final int len = mValues [ i ] . length () ; if ( len > max ) { max = len ; } }
final FastDatePrinter other = ( FastDatePrinter ) obj ;
{ for ( final Rule rule : mRules ) { rule . appendTo ( buf , calendar ) ; } return buf ; }
{ final Calendar c = newCalendar () ; c . setTime ( date ) ; return applyRules ( c , buf ) ; }
{ final Calendar c = newCalendar () ; c . setTime ( date ) ; return applyRulesToString ( c ) ; }
{ final Calendar c = newCalendar () ; c . setTimeInMillis ( millis ) ; return applyRulesToString ( c ) ; }
try { NumberUtils . createNumber ( STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( final NumberFormatException nfe ) {}
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final short anotherVal = other.value ;
{ final float anotherVal = other.value ; return Float . compare ( value , anotherVal ) ; }
{ try { throw new ExceptionWithoutCause () ; } catch ( final Throwable t ) { return t ; } }
final MessageFormat result = new MessageFormat ( pattern ) ;
for ( final Locale locale : locales ) { checkBuiltInFormat ( pattern , registry , args , locale ) ; }
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final Boolean b = array [ i ] ;
final Float b = array [ i ] ;
final Double b = array [ i ] ;
final Byte b = array [ i ] ;
final Short b = array [ i ] ;
final Integer b = array [ i ] ;
final Long b = array [ i ] ;
final Character b = array [ i ] ;
catch ( final IllegalStateException e ) {}
{ final BigDecimal value = NumberUtils . createBigDecimal ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final BigInteger value = NumberUtils . createBigInteger ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final Long value = NumberUtils . createLong ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final Integer value = NumberUtils . createInteger ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final Double value = NumberUtils . createDouble ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final Float value = NumberUtils . createFloat ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ return cache . getTimeInstance ( style , timeZone , locale ) ; }
{ return cache . getTimeInstance ( style , timeZone , null ) ; }
{ return cache . getTimeInstance ( style , null , locale ) ; }
{ return cache . getTimeInstance ( style , null , null ) ; }
{ return cache . getDateInstance ( style , timeZone , locale ) ; }
{ return cache . getDateInstance ( style , timeZone , null ) ; }
{ return cache . getDateInstance ( style , null , locale ) ; }
{ return cache . getDateInstance ( style , null , null ) ; }
return SerializationUtils . < T > deserialize ( new ByteArrayInputStream ( objectData ) ) ;
exceptionContext = new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () ) ;
exceptionContext = new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () {} ) ;
Strategy strategy = cache . get ( locale ) ;
if ( nullText != null && nullText . isEmpty () ) { nullText = null ; }
if ( str . isEmpty () ) { return ArrayUtils.EMPTY_STRING_ARRAY ; }
if ( separator . isEmpty () ) { return EMPTY ; }
return str . isEmpty () ? null : str ;
if ( str . isEmpty () || deepEmpty ( set ) ) { return StringUtils.EMPTY ; }
final Integer max = TypeUtilsTest . < Integer > stub () ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () { private static final long serialVersionUID = NUMBER_CONSTANT ; } )
{ if ( this . runningState == State.UNSTARTED ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } return this . startTimeMillis ; }
if ( this . splitState != SplitState.SPLIT ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
{ return new GenericArrayTypeImpl ( Validate . notNull ( componentType , STRING_CONSTANT ) ) ; }
{ FieldUtils . readDeclaredField ( null , STRING_CONSTANT , true ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readDeclaredField ( null , STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readField ( null , publicChild , true ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readField ( null , publicChild ) ; fail ( STRING_CONSTANT ) ; }
assertNull ( LocaleUtils . toLocale ( ( String ) null ) ) ;
final Iterable < ? extends E > values
final Iterable < ? extends E > values
{ return new FastDateParser ( format , timeZone , locale , null ) ; }
assertNull ( StringUtils . normalizeSpace ( null ) ) ;
assertNull ( StringUtils . difference ( null , null ) ) ;
assertNull ( StringUtils . abbreviate ( null , NUMBER_CONSTANT ) ) ;
assertNull ( StringUtils . reverseDelimited ( null , CHAR_CONS ) ) ;
assertNull ( StringUtils . reverse ( null ) ) ;
assertNull ( StringUtils . leftPad ( null , NUMBER_CONSTANT , CHAR_CONS ) ) ;
assertNull ( StringUtils . leftPad ( null , NUMBER_CONSTANT ) ) ;
assertNull ( StringUtils . rightPad ( null , NUMBER_CONSTANT , CHAR_CONS ) ) ;
assertNull ( StringUtils . rightPad ( null , NUMBER_CONSTANT ) ) ;
assertNull ( StringUtils . repeat ( null , NUMBER_CONSTANT ) ) ;
assertNull ( StringUtils . replaceChars ( null , CHAR_CONS , CHAR_CONS ) ) ;
assertNull ( StringUtils . deleteWhitespace ( null ) ) ;
assertNull ( StringUtils . splitPreserveAllTokens ( null , CHAR_CONS ) ) ;
assertNull ( StringUtils . splitPreserveAllTokens ( null ) ) ;
assertNull ( StringUtils . split ( null , CHAR_CONS ) ) ;
assertNull ( StringUtils . split ( null ) ) ;
assertEquals ( minutes + ( ( hours * DateUtils.MILLIS_PER_HOUR ) + ( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_MINUTE , testResult )
assertEquals ( minutes + ( ( hours * DateUtils.MILLIS_PER_HOUR ) + ( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_MINUTE , testResult )
( ( minutes * DateUtils.MILLIS_PER_MINUTE ) + ( hours * DateUtils.MILLIS_PER_HOUR ) + ( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_SECOND
( ( minutes * DateUtils.MILLIS_PER_MINUTE ) + ( hours * DateUtils.MILLIS_PER_HOUR ) + ( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_SECOND
( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY )
( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY )
assertNull ( StringUtils . swapCase ( null ) ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
final Class < > context
final Class < > context
list0 = new ArrayList < Object > ( Arrays . asList ( new Object [ NUMBER_CONSTANT ] ) )
assertEquals ( STRING_CONSTANT , StringUtils . join ( new Object [ NUMBER_CONSTANT ] ) ) ;
return readField ( field , target , false ) ;
return readField ( field , target , false ) ;
writeField ( field , target , value , false ) ;
writeField ( field , target , value , false ) ;
writeField ( field , ( Object ) null , value , false ) ;
writeStaticField ( field , value , false ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toShort ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toDouble ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toFloat ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toLong ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toInt ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toShort ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toDouble ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toFloat ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toLong ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toInt ( null ) == NUMBER_CONSTANT ) ;
{ return new DiffResult ( left , right , diffs , style ) ; }
{ this ( message , cause , null ) ; }
public NotImplementedException ( final Throwable cause ) { this ( cause , null ) ; }
{ this ( message , ( String ) null ) ; }
{ pos += Character . charCount ( Character . codePointAt ( input , pos ) ) ; }
return Character . codePointCount ( input , NUMBER_CONSTANT , input . length () ) ;
final Date centuryStart
{ return getFragment ( calendar , fragment , TimeUnit.DAYS ) ; }
{ return getFragment ( calendar , fragment , TimeUnit.HOURS ) ; }
{ return getFragment ( calendar , fragment , TimeUnit.MINUTES ) ; }
{ return getFragment ( calendar , fragment , TimeUnit.SECONDS ) ; }
{ return getFragment ( calendar , fragment , TimeUnit.MILLISECONDS ) ; }
{ return getFragment ( date , fragment , TimeUnit.DAYS ) ; }
{ return getFragment ( date , fragment , TimeUnit.HOURS ) ; }
{ return getFragment ( date , fragment , TimeUnit.MINUTES ) ; }
{ return getFragment ( date , fragment , TimeUnit.SECONDS ) ; }
{ return getFragment ( date , fragment , TimeUnit.MILLISECONDS ) ; }
return NOT_FOUND ;
final Integer iVal = lKeyValues . get ( value . toLowerCase () ) ;
regex . append ( STRING_CONSTANT ) ;
final Integer iVal = lKeyValues . get ( value . toLowerCase ( locale ) ) ;
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
for ( final String textKeyValue : lKeyValues . keySet () ) { sb . append ( textKeyValue ) . append ( CHAR_CONS ) ; }
for ( final String textKeyValue : lKeyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
shift = i + srcPos ;
shift = i + srcPos ;
shift = i + srcPos ;
shift = i + dstPos ;
shift = i + dstPos ;
shift = i + dstPos ;
shift = i + dstPos ;
final SimpleClass obj
public SimpleClass ( final boolean booleanField ) { this . booleanField = booleanField ; }
final T value
final String fieldName
final StringBuilder source
final CharSequence source
final StringBuilder sb = new StringBuilder () ;
final StringBuilder sb = new StringBuilder () ;
{ for ( final Token token : tokens ) { if ( token . getValue () == value ) { return true ; } } return false ; }
final char firstChar = str . charAt ( NUMBER_CONSTANT ) ;
final char firstChar = str . charAt ( NUMBER_CONSTANT ) ;
final CharSequence . . . css
final CharSequence . . . css
protected BooleanDiff ( final String fieldName ) { super ( fieldName ) ; }
final Method m
final Method m
@ Override public void consume ( final T t ) {}
final TypeTestClass class1 = new TypeTestClass () ;
@ Override public boolean equals ( final Object obj ) { return EqualsBuilder . reflectionEquals ( this , obj , false ) ; }
final TypeTestClass obj
final String [] element
final String [] element
final Locale locale
final Locale locale
final Locale locale
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final GenericArrayType g
final WildcardType w
final ParameterizedType p
final TypeVariable < > v
final Class < > c
final TypeVariable < > var
final Type type
final Object obj
final Object obj
final Object obj
final Type componentType
final Type . . . bounds
final Type . . . bounds
final double result = RandomUtils . nextDouble ( NUMBER_CONSTANT , Double.MAX_VALUE ) ;
final float result = RandomUtils . nextFloat ( NUMBER_CONSTANT , Float.MAX_VALUE ) ;
final long result = RandomUtils . nextLong ( NUMBER_CONSTANT , Long.MAX_VALUE ) ;
final int result = RandomUtils . nextInt ( NUMBER_CONSTANT , Integer.MAX_VALUE ) ;
final long result = RandomUtils . nextLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final double result = RandomUtils . nextFloat ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final double result = RandomUtils . nextDouble ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final int result = RandomUtils . nextInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
@ Override public void consume ( final String t ) { super . consume ( t ) ; }
final Field field
final Class < > cls
{ final String pattern = STRING_CONSTANT ; FastDateFormat . getInstance ( pattern ) ; }
{ final int tmpHash = ObjectUtils . hashCode ( object ) ; hash = hash * NUMBER_CONSTANT + tmpHash ; }
final Interfaces interfacesBehavior
final char ch
final char ch
final Calendar c = Calendar . getInstance () ;
final Object obj
final String [] zone
{ final int trial = century + twoDigitYear ; return twoDigitYear >= startYear ? trial : trial + NUMBER_CONSTANT ; }
final Calendar definingCalendar
for ( final CharSequence searchString : searchStrings ) { if ( endsWith ( string , searchString ) ) { return true ; } }
for ( final CharSequence searchString : searchStrings ) { if ( startsWith ( string , searchString ) ) { return true ; } }
{ return isEmpty ( str ) ? defaultStr : str ; }
{ return isBlank ( str ) ? defaultStr : str ; }
{ return ! isBlank ( cs ) ; }
{ return ! isEmpty ( cs ) ; }
{ return isDigits ( StringUtils . replaceOnce ( str . substring ( NUMBER_CONSTANT ) , STRING_CONSTANT , StringUtils.EMPTY ) ) ; }
modify ( ceiled , field , ModifyType.CEILING ) ;
modify ( gval , field , ModifyType.CEILING ) ;
modify ( truncated , field , ModifyType.TRUNCATE ) ;
modify ( gval , field , ModifyType.TRUNCATE ) ;
modify ( rounded , field , ModifyType.ROUND ) ;
modify ( gval , field , ModifyType.ROUND ) ;
class Named {}
class Named {}
class Named {}
class Named {}
class Named {}
class Named {}
class Named {}
class Named {}
{ type = array . getClass () . getComponentType () ; }
appendQuotedString ( pattern , pos , sb ) ;
getQuotedString ( pattern , pos ) ;
appendQuotedString ( pattern , pos , stripCustom ) ;
{ regex . append ( pattern ) ; return true ; }
{ if ( value < NUMBER_CONSTANT ) { appendDigits ( buffer , value ) ; } else { buffer . append ( value ) ; } }
exec . awaitTermination ( NUMBER_CONSTANT , TimeUnit.SECONDS ) ;
{ fail ( STRING_CONSTANT + osName ) ; }
return isOSNameMatch ( osName , osNamePrefix ) && osVersion . startsWith ( osVersionPrefix ) ;
return isOSNameMatch ( osName , osNamePrefix ) && isOSVersionMatch ( osVersion , osVersionPrefix ) ;
{ System.out . println ( STRING_CONSTANT + osName ) ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
final int halflength = shorter . length () / NUMBER_CONSTANT + NUMBER_CONSTANT ;
( ! f . getName () . contains ( STRING_CONSTANT ) )
( ! field . getName () . contains ( STRING_CONSTANT ) )
( ! f . getName () . contains ( STRING_CONSTANT ) )
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }
{ if ( ! isEquals ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
if ( ! isEquals ) { return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = superEquals ; return this ; }
modType == ModifyType.CEILING || modType == ModifyType.ROUND && roundUp
{ DateUtils . setMilliseconds ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setSeconds ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setMinutes ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setHours ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setDays ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setMonths ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
try { DateUtils . parseDateStrictly ( dateStr , parsers ) ; fail () ; } catch ( final ParseException ex ) {}
{ regex . append ( VALID_TZ ) ; return true ; }
{ regex . append ( validTimeZoneChars ) ; return true ; }
{ regex . append ( VALID_TZ ) ; return true ; }
return false ;
cal . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.OCTOBER , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.DECEMBER , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT ) ;
expected . set ( NUMBER_CONSTANT , Calendar.MAY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.OCTOBER , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.DECEMBER , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.JUNE , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ this ( pattern , timeZone , locale , null , true ) ; }
text = DateFormatUtils . format ( cal , DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT . getPattern () , timeZone ) ;
final String actualValue = FastDateFormat . getInstance ( PATTERN , this . timeZone ) . format ( cal ) ;
{ return format ( calendar . getTime () , buf ) ; }
if ( tokenLen == NUMBER_CONSTANT ) { rule = Iso8601_Rule.ISO8601_HOURS_COLON_MINUTES ; } else { rule = TimeZoneNumberRule.INSTANCE_COLON ; }
if ( ! threadGroup . isDestroyed () ) { threadGroup . destroy () ; }
this . typeArguments = typeArguments . clone () ;
@ Override public boolean test ( final Thread thread ) { return true ; }
@ Override public boolean test ( final ThreadGroup threadGroup ) { return true ; }
if ( threadGroups . isEmpty () ) { return Collections . emptyList () ; }
super ( checkNotNull ( object ) , style , buffer ) ;
{ super ( checkNotNull ( object ) , style , buffer ) ; }
{ super ( checkNotNull ( object ) , style ) ; }
{ super ( checkNotNull ( object ) ) ; }
@ Override public boolean test ( final Thread thread ) { return true ; }
@ Override public boolean test ( final ThreadGroup threadGroup ) { return true ; }
if ( threadGroups . isEmpty () ) { return Collections . emptyList () ; }
tz = tzNames . get ( value . toLowerCase ( locale ) ) ;
{ regex . append ( validTimeZoneChars ) ; return true ; }
for ( final String textKeyValue : lKeyValues . keySet () ) { simpleQuote ( regex , textKeyValue ) . append ( CHAR_CONS ) ; }
@ SuppressWarnings ( { STRING_CONSTANT , STRING_CONSTANT } ) final Map < String , String > propertiesMap = ( Map ) properties ;
ISO8601TimeZoneStrategy ( String pattern ) { createPattern ( pattern ) ; }
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( definingCalendar , locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
{ this ( pattern , timeZone , locale , null ) ; }
final String systemNewLine = SystemUtils.LINE_SEPARATOR ;
final String systemNewLine = SystemUtils.LINE_SEPARATOR ;
final DateParser fdp = getInstance ( STRING_CONSTANT , kst , Locale.KOREA ) ;
{ return applyRules ( c , new StringBuilder ( mMaxLengthEstimate ) ) . toString () ; }
assertTrue ( BooleanUtils . toBoolean ( new StringBuilder ( STRING_CONSTANT ) . append ( STRING_CONSTANT ) . toString () ) ) ;
final char newChar = Character . toTitleCase ( firstChar ) ;
{ try { throw new IOException () ; } catch ( Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; } }
if ( length <= NUMBER_CONSTANT || index >= size ) { return StringUtils.EMPTY ; }
{ return StringUtils.EMPTY ; }
{ return StringUtils.EMPTY ; }
if ( str == null ) { str = StringUtils.EMPTY ; }
if ( str == null ) { str = StringUtils.EMPTY ; }
if ( count == NUMBER_CONSTANT ) { return StringUtils.EMPTY ; } else if ( count < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + count + STRING_CONSTANT ) ; }
return pattern . matcher ( decomposed ) . replaceAll ( StringUtils.EMPTY ) ;
{ if ( summaryObjectEndText == null ) { summaryObjectEndText = StringUtils.EMPTY ; } this . summaryObjectEndText = summaryObjectEndText ; }
{ if ( summaryObjectStartText == null ) { summaryObjectStartText = StringUtils.EMPTY ; } this . summaryObjectStartText = summaryObjectStartText ; }
{ if ( sizeEndText == null ) { sizeEndText = StringUtils.EMPTY ; } this . sizeEndText = sizeEndText ; }
{ if ( sizeStartText == null ) { sizeStartText = StringUtils.EMPTY ; } this . sizeStartText = sizeStartText ; }
{ if ( nullText == null ) { nullText = StringUtils.EMPTY ; } this . nullText = nullText ; }
{ if ( fieldSeparator == null ) { fieldSeparator = StringUtils.EMPTY ; } this . fieldSeparator = fieldSeparator ; }
{ if ( fieldNameValueSeparator == null ) { fieldNameValueSeparator = StringUtils.EMPTY ; } this . fieldNameValueSeparator = fieldNameValueSeparator ; }
{ if ( contentEnd == null ) { contentEnd = StringUtils.EMPTY ; } this . contentEnd = contentEnd ; }
{ if ( contentStart == null ) { contentStart = StringUtils.EMPTY ; } this . contentStart = contentStart ; }
{ if ( arraySeparator == null ) { arraySeparator = StringUtils.EMPTY ; } this . arraySeparator = arraySeparator ; }
{ if ( arrayEnd == null ) { arrayEnd = StringUtils.EMPTY ; } this . arrayEnd = arrayEnd ; }
{ if ( arrayStart == null ) { arrayStart = StringUtils.EMPTY ; } this . arrayStart = arrayStart ; }
if ( locale . getCountry () . length () > NUMBER_CONSTANT ) { list . add ( new Locale ( locale . getLanguage () , StringUtils.EMPTY ) ) ; }
if ( delimiters != null && delimiters.length == NUMBER_CONSTANT ) { return StringUtils.EMPTY ; }
if ( th == null ) { return StringUtils.EMPTY ; }
if ( pos >= count ) { addToken ( tokenList , StringUtils.EMPTY ) ; }
return new StringBuilder ( annotationType == null ? StringUtils.EMPTY : annotationType . getName () ) . insert ( NUMBER_CONSTANT , CHAR_CONS ) . toString () ;
{ return obj == null ? StringUtils.EMPTY : obj . toString () ; }
lKeyValues = appendDisplayNames ( definingCalendar , locale , field , regex ) ;
{ return parseDateWithLeniency ( str , locale , parsePatterns , false ) ; }
public TestBean ( final Object o ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean ( final String s ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean ( final double d ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean ( final Integer i ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean ( final int i ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean () { toString = STRING_CONSTANT ; varArgs = null ; }
{ return ( boolean [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( double [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( float [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( long [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( char [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( int [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( short [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( byte [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( T [] ) removeAll ( ( Object ) array , indices ) ; }
{ assertEquals ( str , toString ) ; assertArrayEquals ( args , varArgs ) ; }
{ return getCause ( throwable , null ) ; }
if ( STRING_CONSTANT . equals ( nom ) ) { return JAVA_1_8 ; } else if ( STRING_CONSTANT . equals ( nom ) ) { return JAVA_9 ; }
assertEquals ( STRING_CONSTANT , JAVA_9 , get ( STRING_CONSTANT ) ) ;
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
final boolean isValid = NumberUtils . isCreatable ( val ) ;
if ( srcArgs.length < normalArgsLen ) { return Float.MAX_VALUE ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
final boolean hasSign = firstChar == CHAR_CONS || firstChar == CHAR_CONS ;
final String javaVersion = SystemUtils.JAVA_VERSION ;
if ( ArrayUtils . isEmpty ( css ) ) { return false ; }
if ( ArrayUtils . isEmpty ( css ) ) { return false ; }
if ( ArrayUtils . isEmpty ( css ) ) { return false ; }
if ( ArrayUtils . isEmpty ( css ) ) { return false ; }
final Set < String > labels = new HashSet <> () ;
final List < Object > values = new ArrayList <> () ;
{ contextValues . add ( new ImmutablePair <> ( label , value ) ) ; return this ; }
{ return new Range <> ( fromInclusive , toInclusive , comparator ) ; }
final List < VetoableChangeListener > calledListeners = new ArrayList <> () ;
{ expectedSource = source ; changedValues = new ArrayList <> () ; }
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
triple = new MutableTriple <> ()
final List < ThreadGroup > result = new ArrayList <> ( count ) ;
final List < Thread > result = new ArrayList <> ( count ) ;
final Collection < Thread > result = new ArrayList <> () ;
final HashMap < Integer , String > map = new HashMap <> () ;
{ return new ConstantFuture <> ( value ) ; }
{ priorVariables = new ArrayList <> () ; priorVariables . add ( new String ( chars , offset , length ) ) ; }
final Map < String , String > valueMap = new HashMap <> () ;
final Map < String , E > map = new LinkedHashMap <> () ;
final Map < DateParser , Integer > map = new HashMap <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final ArrayList < String > substrings = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> ( array.length ) ;
if ( m == null ) { REGISTRY . set ( new WeakHashMap <> () ) ; }
countries = new ArrayList <> () ;
langs = new ArrayList <> () ;
final List < Locale > list = new ArrayList <> ( NUMBER_CONSTANT ) ;
typeVarAssigns = new HashMap <> ()
{ return new ImmutablePair <> ( left , right ) ; }
final List < Field > allFieldsInteger = new ArrayList <> ( fieldsInteger ) ;
final Collection < String > coll = new ArrayList <> () ;
final Collection < String > coll = new ArrayList <> () ;
final List < String > coll = new ArrayList <> () ;
final List < String > coll = new ArrayList <> () ;
final Map < String , Integer > map = new HashMap <> () ;
final Map < String , Integer > map = new HashMap <> () ;
final Collection < Integer > coll = new ArrayList <> () ;
final Collection < Integer > coll = new ArrayList <> () ;
this . eventTypes = new HashSet <> ( Arrays . asList ( eventTypes ) ) ;
final CallableBackgroundInitializer < Integer > init = new CallableBackgroundInitializer <> ( call ) ;
{ new CallableBackgroundInitializer <> ( null ) ; }
final Set < Locale > jdkLocaleSet = new HashSet <> ( jdkLocaleList ) ;
{ return new MapStrLookup <> ( map ) ; }
pair = new MutablePair <> ( NUMBER_CONSTANT , STRING_CONSTANT )
final MutablePair < Integer , String > pair = new MutablePair <> () ;
final AtomicReference < InterruptedException > iex = new AtomicReference <> () ;
tasks = new ArrayList <> ()
List < TimeZone > timeZones = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > frames = new ArrayList <> () ;
final List < Throwable > list = new ArrayList <> () ;
final Set < Type > types = new HashSet <> ( bounds.length ) ;
final Set < > set = Collections . unmodifiableSet ( new HashSet <> () ) ;
final Set < > set = Collections . unmodifiableSet ( new HashSet <> () ) ;
final List < Class < > > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final List < Class < > > candidateClasses = new ArrayList <> () ;
final List < String > classNames = new ArrayList <> ( classes . size () ) ;
final List < Class < > > classes = new ArrayList <> () ;
final List < String > excludeList = new ArrayList <> () ;
final List < String > excludeList = new ArrayList <> () ;
final List < String > excludeList = new ArrayList <> () ;
final List < String > tokenList = new ArrayList <> () ;
final List < String > list = new ArrayList <> ( tokens.length ) ;
final MutableObject < String > obj = new MutableObject <> ( replaceTemplate ) ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
values = new HashMap <> () ;
final List < Field > annotatedFields = new ArrayList <> () ;
final List < Field > allFields = new ArrayList <> () ;
if ( registry == null ) { registry = new HashSet <> () ; REGISTRY . set ( registry ) ; }
final HashMap < T , MutableInt > occurrences = new HashMap <> ( items.length ) ;
final TreeSet < T > sort = new TreeSet <> ( comparator ) ;
final TreeSet < T > sort = new TreeSet <> () ;
final List < Method > annotatedMethods = new ArrayList <> () ;
final Set < Method > result = new LinkedHashSet <> () ;
{ return new MutablePair <> ( left , right ) ; }
final List < Object > list = new ArrayList <> () ;
iMap = new HashMap <> () ;
this . diffs = new ArrayList <> () ;
this . listeners = new CopyOnWriteArrayList <> ( srcListeners ) ;
final ArrayList < L > serializableListeners = new ArrayList <> () ;
{ return new EventListenerSupport <> ( listenerInterface ) ; }
final Set < String > sorted = new TreeSet <> ( LONGER_FIRST_LOWERCASE ) ;
{ caches [ field ] = new ConcurrentHashMap <> ( NUMBER_CONSTANT ) ; }
patterns = new ArrayList <> () ;
tasks = new ArrayList <> ()
final HashSet < Integer > toRemove = new HashSet <> () ;
final Map < String , Object > map = new HashMap <> () ;
final List < Rule > rules = new ArrayList <> () ;
{ return new ImmutablePair <> ( left , right ) ; }
final HashSet < Locale > testLocales = new HashSet <> () ;
final HashMap < Boolean , MutableInt > occurrences = new HashMap <> ( NUMBER_CONSTANT ) ;
final HashMap < Double , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Float , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Long , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Character , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Integer , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Short , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final Map < Byte , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < T , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final String s = new ConstantInitializer <> ( null ) . toString () ;
checkEquals ( new ConstantInitializer <> ( STRING_CONSTANT ) , false ) ;
@ Before public void setUp ( ) throws Exception { init = new ConstantInitializer <> ( VALUE ) ; }
private NotVisibleException ( final Throwable cause ) { this . cause = cause ; }
final Boolean . . . values
final PropertyChangeEvent evt
final Object source
final long time
class LANG1261ParentObject { @ Override public boolean equals ( final Object o ) { return true ; } }
final TimeZone tz
final int max
final StringBuilder decomposed
final int maxWidth
public Customer ( final String name ) { this . name = name ; }
public Bank ( final String name ) { this . name = name ; }
final Object object
final Object object
final Number . . . args
final String . . . args
final Number . . . args
final String . . . args
public static String numOverload ( final Number . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Long . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Integer . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Double . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Float . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Short . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Byte . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final String . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Object . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Number . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Long . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Integer . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Double . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Float . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Boolean . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Short . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Character . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Byte . . . args ) { return STRING_CONSTANT ; }
public int [] unboxing ( final int . . . values ) { return values ; }
final String valueAsString
final String valueAsString
final TimeZone tz
public CircuitBreakingException ( final Throwable cause ) { super ( cause ) ; }
public CircuitBreakingException ( final String message ) { super ( message ) ; }
final String key
public FastDatePrinterTimeZonesTest ( final TimeZone timeZone ) { this . timeZone = timeZone ; }
final Class < ? extends Throwable > type
final Throwable throwable
final Throwable throwable
final Throwable throwable
final long nanos
final int spaces
final Long increment
final long threshold
final int len
@ Override protected long fetchCheckInterval ( final EventCountCircuitBreaker breaker ) { return breaker . getClosingInterval () ; }
@ Override protected long fetchCheckInterval ( final EventCountCircuitBreaker breaker ) { return breaker . getOpeningInterval () ; }
final int delta
final State state
final State newState
final int increment
final Integer increment
final Method method
final PropertyChangeListener listener
final PropertyChangeListener listener
final State newState
final State state
final boolean allowDuplicate
final FastDateParser parser
final FastDateParser parser
final FastDateParser parser
@ Override int modify ( final FastDateParser parser , final int iValue ) { return iValue - NUMBER_CONSTANT ; }
final int tokenLen
ISO8601TimeZoneStrategy ( final String pattern ) { createPattern ( pattern ) ; }
final FastDateParser parser
final FastDateParser parser
void createPattern ( final String regex ) { this . pattern = Pattern . compile ( regex ) ; }
void createPattern ( final StringBuilder regex ) { createPattern ( regex . toString () ) ; }
final char c
final char c
final ListIterator < StrategyAndWidth > lt
final SystemDefaults defaults
final SystemDefaults defaults
final int . . . args
final String . . . s
final Calendar calendar
final Calendar calendar
final int tokenLen
final int value
final Object obj
final Constructor < > constructor
final Method method
private static Executable of ( final Constructor < > constructor ) { return new Executable ( constructor ) ; }
private static Executable of ( final Method method ) { return new Executable ( method ) ; }
final boolean [] array
final char [] array
final byte [] array
final short [] array
final long [] array
final int [] array
final int offset
final int offset
final int offset
final int offset
final int offset
final int offset
final int offset
final int offset
final int offset
{ final int last = value ; this . value += operand . intValue () ; return last ; }
{ final int last = value ; this . value += operand ; return last ; }
{ final int last = value ; value -- ; return last ; }
{ final int last = value ; value ++ ; return last ; }
{ final double last = value ; this . value += operand . doubleValue () ; return last ; }
{ final double last = value ; this . value += operand ; return last ; }
{ final double last = value ; value -- ; return last ; }
{ final double last = value ; value ++ ; return last ; }
{ final StopWatch sw = new StopWatch () ; sw . start () ; return sw ; }
catch ( final UnsupportedOperationException e ) {}
catch ( final UnsupportedOperationException e ) {}
catch ( final UnsupportedOperationException e ) {}
final int result = mutNum . getAndDecrement () ;
final int result = mutNum . decrementAndGet () ;
final int result = mutNum . getAndIncrement () ;
final int result = mutNum . incrementAndGet () ;
{ final long last = value ; this . value += operand . longValue () ; return last ; }
{ final long last = value ; this . value += operand ; return last ; }
{ final long last = value ; value -- ; return last ; }
{ final long last = value ; value ++ ; return last ; }
final Exception ex
final double result = mutableDouble . addAndGet ( - NUMBER_CONSTANT ) ;
final double result = mutableDouble . getAndAdd ( NUMBER_CONSTANT ) ;
final double result = mutNum . getAndDecrement () ;
final double result = mutNum . decrementAndGet () ;
final double result = mutNum . getAndIncrement () ;
final double result = mutNum . incrementAndGet () ;
final Calendar calendar = Calendar . getInstance () ;
final DateParser parser = getInstance ( YMD_SLASH ) ;
final Calendar cal = Calendar . getInstance ( tz ) ;
for ( final CharSequence searchCharSequence : searchCharSequences ) { if ( contains ( cs , searchCharSequence ) ) { return true ; } }
{ for ( final CharSequence next : searchStrings ) { if ( equalsIgnoreCase ( string , next ) ) { return true ; } } }
{ for ( final CharSequence next : searchStrings ) { if ( equals ( string , next ) ) { return true ; } } }
{ double balance = NUMBER_CONSTANT ; for ( final Transaction tx : transactions ) { balance += tx.amount ; } return balance ; }
{ final String date = STRING_CONSTANT ; DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT . parse ( date ) ; }
final Calendar calendar = Calendar . getInstance () ;
final Calendar cal = Calendar . getInstance ( SWEDEN ) ;
final Calendar cal = Calendar . getInstance ( tz ) ;
catch ( final InterruptedException iex ) {}
final Pattern patternToWrapOn = Pattern . compile ( wrapOn ) ;
{ try { return System . getProperty ( key ) ; } catch ( final SecurityException scex ) {} }
final StringBuilder sb = new StringBuilder () ;
final ExecutorService exec = Executors . newSingleThreadExecutor () ;
final long result = mutNum . getAndDecrement () ;
final long result = mutNum . decrementAndGet () ;
final long result = mutNum . getAndIncrement () ;
final long result = mutNum . incrementAndGet () ;
catch ( final IllegalAccessException e ) { return null ; }
final int lastHold = start ;
final StringBuilder sb = new StringBuilder () ;
final TimeZone utc = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
final long randomResult = RandomUtils . nextLong () ;
final float randomResult = RandomUtils . nextFloat () ;
final double randomResult = RandomUtils . nextDouble () ;
final int randomResult = RandomUtils . nextInt () ;
final byte result = mutNum . getAndDecrement () ;
final byte result = mutNum . decrementAndGet () ;
final byte result = mutNum . getAndIncrement () ;
final byte result = mutNum . incrementAndGet () ;
final short result = mutNum . getAndDecrement () ;
final short result = mutNum . decrementAndGet () ;
final short result = mutNum . getAndIncrement () ;
final short result = mutNum . incrementAndGet () ;
{ final StateStrategy strategy = STRATEGY_MAP . get ( state ) ; return strategy ; }
final long time = now () ;
final StringBuilder sb = new StringBuilder ( NUMBER_CONSTANT ) ;
final Format fdf = FastDateFormat . getInstance ( pattern ) ;
final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
{ final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( zeroThreshold ) ; assertTrue ( STRING_CONSTANT , circuit . incrementAndCheckState ( NUMBER_CONSTANT ) ) ; }
final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
final float result = mutableFloat . addAndGet ( NUMBER_CONSTANT ) ;
final float result = mutableFloat . getAndAdd ( NUMBER_CONSTANT ) ;
final float result = mutNum . getAndDecrement () ;
final float result = mutNum . decrementAndGet () ;
final float result = mutNum . getAndIncrement () ;
final float result = mutNum . incrementAndGet () ;
{ final byte last = value ; this . value += operand . byteValue () ; return last ; }
{ final byte last = value ; this . value += operand ; return last ; }
{ final byte last = value ; value -- ; return last ; }
{ final byte last = value ; value ++ ; return last ; }
final Diff < > diff
final StringBuilder regex = new StringBuilder () ;
final int sIdx = idx + pos . getIndex () ;
final char c = value . charAt ( i ) ;
final ParsePosition pp = new ParsePosition ( NUMBER_CONSTANT ) ;
final char c = pattern . charAt ( currentIdx ) ;
final Calendar cal = Calendar . getInstance () ;
final Locale save = Locale . getDefault () ;
final TimeZone save = TimeZone . getDefault () ;
catch ( final Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; }
catch ( final Exception e ) { return ExceptionUtils . < Boolean > rethrow ( e ) ; }
final int value = calendar . get ( Calendar.DAY_OF_WEEK ) ;
catch ( final IOException ioe ) { ExceptionUtils . rethrow ( ioe ) ; }
{ final short last = value ; this . value += operand . shortValue () ; return last ; }
{ final short last = value ; this . value += operand ; return last ; }
{ final short last = value ; value -- ; return last ; }
{ final short last = value ; value ++ ; return last ; }
{ final float last = value ; this . value += operand . floatValue () ; return last ; }
{ final float last = value ; this . value += operand ; return last ; }
{ final float last = value ; value -- ; return last ; }
{ final float last = value ; value ++ ; return last ; }
catch ( final Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , TestThrowable . class ) ) ; }
catch ( final Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , IOException . class ) ) ; }
catch ( final Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , RuntimeException . class ) ) ; }
catch ( final Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , Error . class ) ) ; }
try { throw new IOException () ; } catch ( final Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; }
final int [] clonedIndices = clone ( indices ) ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final short aux = array [ offset1 ] ;
final Object aux = array [ offset1 ] ;
final long aux = array [ offset1 ] ;
final int aux = array [ offset1 ] ;
final float aux = array [ offset1 ] ;
final double aux = array [ offset1 ] ;
final char aux = array [ offset1 ] ;
final byte aux = array [ offset1 ] ;
final boolean aux = array [ offset1 ] ;
final String encoding = STRING_CONSTANT ;
final String methodStr = m . toString () ;
methodName . equals ( method . getName () ) && Objects . deepEquals ( parameterTypes , method . getParameterTypes () )
Memoizer < Integer , Integer > memoizer = new Memoizer <> ( computable ) ;
Memoizer < Integer , Integer > memoizer = new Memoizer <> ( computable ) ;
Memoizer < Integer , Integer > memoizer = new Memoizer <> ( computable ) ;
if ( ! isEquals ) { return this ; }
final StrategyParser fm = new StrategyParser ( definingCalendar ) ;
public void setCycle ( final TestRecursiveCycleObject cycle ) { this . cycle = cycle ; }
public TestRecursiveCycleObject ( final int n ) { this . n = n ; this . cycle = this ; }
public TestRecursiveInnerObject ( final int n ) { this . n = n ; }
final int offset
final boolean testRecursive
final String . . . excludeFields
final Class < > reflectUpToClass
final boolean testRecursive
final boolean testTransients
final Locale [] availableLocales = NumberFormat . getAvailableLocales () ;
{ mRule . appendTo ( buffer , calendar . getWeekYear () ) ; }
if ( b . compareTo ( BigDecimal . valueOf ( d . doubleValue () ) ) == NUMBER_CONSTANT ) { return d ; }
{ spaceToWrapAt = matcher . start () + offset ; }
@ SuppressWarnings ( { STRING_CONSTANT , STRING_CONSTANT } ) final String [] sa = ArrayUtils . add ( stringArray , NUMBER_CONSTANT , aString ) ;
@ SuppressWarnings ( STRING_CONSTANT ) final T . . . array
assertEquals ( STRING_CONSTANT + locale , expectedPattern , emf . toPattern () ) ;
assertEquals ( STRING_CONSTANT , pattern , emf . toPattern () ) ;
{ if ( newLine == null ) { append ( System . lineSeparator () ) ; return this ; } return append ( newLine ) ; }
{ assertEquals ( baseStr + STRING_CONSTANT + System . lineSeparator () + STRING_CONSTANT , new ToStringBuilder ( base ) . toString () ) ; }
if ( newLineStr == null ) { newLineStr = System . lineSeparator () ; }
final String systemNewLine = System . lineSeparator () ;
final String systemNewLine = System . lineSeparator () ;
final String linebreak = System . lineSeparator () ;
final String linebreak = System . lineSeparator () ;
{ if ( fieldName == null ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; } super . appendFieldStart ( buffer , FIELD_NAME_QUOTE + fieldName + FIELD_NAME_QUOTE ) ; }
assertFalse ( CharUtils . isAsciiPrintable ( CHAR_COPY ) ) ;
intRange = Range . between ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( NUMBER_CONSTANT ) . toHashCode () ) ;
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( NUMBER_CONSTANT ) . toHashCode () ) ;
assertNull ( LocaleUtils . toLocale ( null ) ) ;
sb . replace ( NUMBER_CONSTANT , NUMBER_CONSTANT , null ) ;
sb . setNullText ( null ) ;
sb . setNewLineText ( null ) ;
final StrBuilder sb5 = new StrBuilder ( null ) ;
final GenericDeclaration d = var . getGenericDeclaration () ;
assertEquals ( STRING_CONSTANT , ClassUtils . getSimpleName ( null ) ) ;
assertEquals ( STRING_CONSTANT , BooleanUtils . toString ( null , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEquals ( null , BooleanUtils . toStringYesNo ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringOnOff ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringTrueFalse ( null ) ) ;
assertEquals ( null , BooleanUtils . toIntegerObject ( null ) ) ;
assertTrue ( BooleanUtils . isNotFalse ( null ) ) ;
assertFalse ( BooleanUtils . isFalse ( null ) ) ;
assertTrue ( BooleanUtils . isNotTrue ( null ) ) ;
assertFalse ( BooleanUtils . isTrue ( null ) ) ;
assertSame ( StrMatcher . noneMatcher () , StrMatcher . stringMatcher ( null ) ) ;
assertEquals ( BAR , ObjectUtils . toString ( null , BAR ) ) ;
assertEquals ( STRING_CONSTANT , ObjectUtils . toString ( null ) ) ;
{ DateUtils . isSameLocalTime ( Calendar . getInstance () , null ) ; }
{ DateUtils . isSameLocalTime ( null , Calendar . getInstance () ) ; }
{ DateUtils . isSameInstant ( Calendar . getInstance () , null ) ; }
{ DateUtils . isSameInstant ( null , Calendar . getInstance () ) ; }
{ DateUtils . isSameInstant ( new Date () , null ) ; }
{ DateUtils . isSameInstant ( null , new Date () ) ; }
{ DateUtils . isSameDay ( Calendar . getInstance () , null ) ; }
{ DateUtils . isSameDay ( null , Calendar . getInstance () ) ; }
{ DateUtils . isSameDay ( new Date () , null ) ; }
{ DateUtils . isSameDay ( null , new Date () ) ; }
array = ArrayUtils . removeElement ( null , true ) ;
array = ArrayUtils . removeElement ( null , STRING_CONSTANT ) ;
assertSame ( cyclicCause . getCause () . getCause () , throwables . get ( NUMBER_CONSTANT ) ) ;
assertSame ( cyclicCause . getCause () . getCause () , throwables [ NUMBER_CONSTANT ] ) ;
assertSame ( cyclicCause . getCause () . getCause () , ExceptionUtils . getRootCause ( cyclicCause ) ) ;
{ if ( value <= start || value >= end ) { throw new IllegalArgumentException ( message ) ; } }
{ if ( value <= start || value >= end ) { throw new IllegalArgumentException ( message ) ; } }
{ if ( value < start || value > end ) { throw new IllegalArgumentException ( message ) ; } }
{ if ( value < start || value > end ) { throw new IllegalArgumentException ( message ) ; } }
longRange = Range . between ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
{ assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , NUMBER_CONSTANT ) ) ; }
{ assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , - NUMBER_CONSTANT ) ) ; }
return parseLocale ( str ) ;
classes . add ( NUMBER_CONSTANT , cls ) ;
assertTrue ( trace . contains ( TEST_MESSAGE ) ) ;
assertTrue ( trace . contains ( STRING_CONSTANT ) ) ;
assertTrue ( trace . contains ( TEST_MESSAGE ) ) ;
assertTrue ( trace . contains ( STRING_CONSTANT ) ) ;
assertFalse ( contextMessage . contains ( TEST_MESSAGE ) ) ;
assertFalse ( stackTrace . contains ( ExceptionUtils.WRAPPED_MARKER ) ) ;
assertFalse ( stackTrace . contains ( ExceptionUtils.WRAPPED_MARKER ) ) ;
final HashSet < Integer > toRemove = new HashSet <> () ;
super . reflectionAppendArrayDetail ( buffer , fieldName , array ) ;
final List < Object > list = new ArrayList <> ( NUMBER_CONSTANT ) ;
TestEmptySubObject ( final int a ) { super ( a ) ; }
TestSubObject () { super ( NUMBER_CONSTANT ) ; }
static String getFieldName () { return STRING_CONSTANT ; }
TestSubObject () { super ( NUMBER_CONSTANT ) ; }
{ Validate . noNullElements ( values ) ; return generateBitVector ( enumClass , Arrays . asList ( values ) ) ; }
TestSubObject () { super ( NUMBER_CONSTANT ) ; }
final List < String > strColl = Arrays . asList ( STRING_CONSTANT ) ;
final List < String > strColl = Arrays . asList ( STRING_CONSTANT ) ;
BackgroundInitializerTestImpl () { super(); }
{ return options != null && options . contains ( option ) ; }
{ return TypeUtils . wrap ( ( Type ) type ) ; }
if ( typeArguments == null ) { typeArguments = Collections . emptyMap () ; }
assertSame ( StrMatcher . noneMatcher () , StrMatcher . charSetMatcher () ) ;
assertNull ( ObjectUtils . firstNonNull () ) ;
void event2 ( PropertyChangeEvent e ) ;
void event1 ( PropertyChangeEvent e ) ;
SelfInstanceTwoVarsReflectionTestFixture () { this . typeIsSelf = this ; }
SelfInstanceVarReflectionTestFixture () { this . typeIsSelf = this ; }
{ Validate . isTrue ( objectData != null , STRING_CONSTANT ) ; return SerializationUtils . deserialize ( new ByteArrayInputStream ( objectData ) ) ; }
@ SuppressWarnings ( STRING_CONSTANT ) NestableException () { super(); }
assertTrue ( StringUtils . containsOnly ( str , CHAR_CONS ) ) ;
assertTrue ( StringUtils . containsOnly ( str , CHAR_CONS ) ) ;
assertTrue ( StringUtils . containsOnly ( str , CHAR_CONS ) ) ;
final List < Object > list = new ArrayList <> ( arraylistInitialCapacity ) ;
final List < Object > list = new ArrayList <> ( ARRAYLIST_INITIAL_CAPACITY ) ;
final List < Object > list = new ArrayList <> ( ARRAYLIST_INITIAL_CAPACITY ) ;
for ( int i = oldEnd ; i < newEnd ; i ++ ) { buffer [ i ] = CharUtils.NUL ; }
if ( isEmpty ( str ) || wrapChar == CharUtils.NUL ) { return str ; }
if ( isEmpty ( str ) || wrapWith == CharUtils.NUL ) { return str ; }
{ if ( isEmpty ( str ) || wrapWith == CharUtils.NUL ) { return str ; } return wrapWith + str + wrapWith ; }
assertNull ( StringUtils . unwrap ( null , CharUtils.NUL ) ) ;
{ if ( ! expression ) { throw new IllegalStateException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } }
{ if ( ! expression ) { throw new IllegalArgumentException ( DEFAULT_IS_TRUE_EX_MESSAGE ) ; } }
if ( ! ( obj instanceof Fraction ) ) { return false ; }
if ( ! ( obj instanceof FastDateFormat ) ) { return false ; }
if ( ! toClass . isPrimitive () ) { return false ; }
{ if ( ! isAsciiNumeric ( ch ) ) { return defaultValue ; } return ch - NUMBER_CONSTANT ; }
{ return ! ObjectUtils . equals ( object1 , object2 ) ; }
if ( ! ( obj instanceof TypeLiteral ) ) { return false ; }
if ( ! ( obj instanceof CharSet ) ) { return false ; }
public boolean isFalse () { return ! value ; }
public boolean isTrue () { return value ; }
if ( ! ( obj instanceof FastDatePrinter ) ) { return false ; }
I arg
final Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getRight () , pair . getLeft () ) ;
if ( ! hasNext ) { throw new NoSuchElementException () ; }
if ( ! ( obj instanceof CharRange ) ) { return false ; }
try { CharUtils . toIntValue ( CHAR_CONS ) ; fail ( STRING_CONSTANT ) ; } catch ( final IllegalArgumentException ex ) {}
if ( tzId . equalsIgnoreCase ( TimeZones.GMT_ID ) ) { continue; }
{ cal . setTimeZone ( TimeZone . getTimeZone ( TimeZones.GMT_ID + value ) ) ; }
{ cal . setTimeZone ( TimeZone . getTimeZone ( TimeZones.GMT_ID ) ) ; }
{ return toAppendTo . append ( ( ( String ) obj ) . toUpperCase ( Locale.ROOT ) ) ; }
expected . append ( args [ NUMBER_CONSTANT ] . toString () . toUpperCase ( Locale.ROOT ) ) ;
assertFalse ( StringUtils . equalsAny ( FOO , FOO . toUpperCase ( Locale.ROOT ) ) ) ;
{ return toAppendTo . append ( ( ( String ) obj ) . toLowerCase ( Locale.ROOT ) ) ; }
timeZone = FastTimeZone . getGmtTimeZone () ;
{ final TimeZone timeZone = FastTimeZone . getGmtTimeZone () ; assertFormats ( expectedValue , pattern , timeZone , createFebruaryTestDate ( timeZone ) ) ; }
final Calendar c = Calendar . getInstance ( FastTimeZone . getGmtTimeZone () ) ;
final Calendar c = Calendar . getInstance ( FastTimeZone . getGmtTimeZone () ) ;
final Calendar c = Calendar . getInstance ( FastTimeZone . getGmtTimeZone () ) ;
final Calendar c = Calendar . getInstance ( FastTimeZone . getGmtTimeZone () ) ;
TimeZone . setDefault ( FastTimeZone . getGmtTimeZone () ) ;
final TimeZone utc = FastTimeZone . getGmtTimeZone () ;
final TimeZone utc = FastTimeZone . getGmtTimeZone () ;
assertNull ( ArrayUtils . toPrimitive ( l , Double.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( l , Float.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( l , Long.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
{ final Integer [] iArray = null ; assertNull ( ArrayUtils . toPrimitive ( iArray , Integer.MIN_VALUE ) ) ; }
assertNull ( ArrayUtils . toPrimitive ( l , Integer.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( s , Short.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b , Byte.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b , Character.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( null , false ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( ArrayUtils . toMap ( null ) ) ;
assertNull ( StringUtils . strip ( null ) ) ;
assertNull ( StringUtils . trim ( null ) ) ;
assertNull ( StringUtils . substring ( null , NUMBER_CONSTANT ) ) ;
assertNull ( tok . getContent () ) ;
assertNull ( tokenizer . nextToken () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( StringEscapeUtils . unescapeJson ( null ) ) ;
assertNull ( StringEscapeUtils . escapeJson ( null ) ) ;
assertNull ( StringEscapeUtils . unescapeCsv ( null ) ) ;
assertNull ( StringEscapeUtils . escapeCsv ( null ) ) ;
assertNull ( StringEscapeUtils . escapeEcmaScript ( null ) ) ;
assertNull ( StringEscapeUtils . escapeEcmaScript ( null ) ) ;
assertNull ( StringEscapeUtils . unescapeJava ( null ) ) ;
assertNull ( StringEscapeUtils . escapeJava ( null ) ) ;
assertNull ( WordUtils . swapCase ( null ) ) ;
assertNull ( WordUtils . initials ( null ) ) ;
assertNull ( WordUtils . uncapitalize ( null , null ) ) ;
assertNull ( WordUtils . uncapitalize ( null ) ) ;
assertNull ( WordUtils . capitalizeFully ( null , null ) ) ;
assertNull ( WordUtils . capitalizeFully ( null ) ) ;
assertNull ( WordUtils . capitalize ( null , null ) ) ;
assertNull ( WordUtils . capitalize ( null ) ) ;
{ assertNull ( CharSequenceUtils . subSequence ( StringUtils.EMPTY , NUMBER_CONSTANT ) ) ; }
{ assertNull ( CharSequenceUtils . subSequence ( StringUtils.EMPTY , - NUMBER_CONSTANT ) ) ; }
assertNull ( ClassUtils . getAllInterfaces ( null ) ) ;
assertNull ( ClassUtils . getAllSuperclasses ( null ) ) ;
assertNull ( BooleanUtils . toStringYesNo ( null ) ) ;
assertNull ( BooleanUtils . toStringOnOff ( null ) ) ;
assertNull ( BooleanUtils . toStringTrueFalse ( null ) ) ;
assertNull ( BooleanUtils . toBooleanObject ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNull ( BooleanUtils . toIntegerObject ( null , six , seven , null ) ) ;
assertNull ( BooleanUtils . toIntegerObject ( null ) ) ;
assertNull ( BooleanUtils . toBooleanObject ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
assertNull ( BooleanUtils . toBooleanObject ( ( Integer ) null ) ) ;
assertNull ( ObjectUtils . identityToString ( null ) ) ;
{ assertNull ( CharUtils . unicodeEscaped ( null ) ) ; assertEquals ( STRING_CONSTANT , CharUtils . unicodeEscaped ( CHARACTER_A ) ) ; }
assertNull ( CharUtils . toString ( null ) ) ;
assertNull ( new MutableObject <> () . getValue () ) ;
assertNull ( StringUtils . getDigits ( null ) ) ;
assertNull ( StringUtils . wrap ( null , null ) ) ;
assertNull ( StringUtils . rotate ( null , NUMBER_CONSTANT ) ) ;
assertNotEquals ( summer . getTime () , standard . getTime () ) ;
assertEquals ( cal . getTime () , date ) ;
@ Test public void testInvokeMethodForceAccessNoArgs ( ) throws Exception { assertEquals ( STRING_CONSTANT , MethodUtils . invokeMethod ( testBean , true , STRING_CONSTANT ) ) ; }
assertEquals ( STRING_CONSTANT , TypeUtils . toString ( method . getGenericReturnType () ) ) ;
assertTrue ( TypeUtils . isAssignable ( fromType , failingToType ) ) ;
assertArrayEquals ( expectedArray , TypeUtils . normalizeUpperBounds ( typeArray ) ) ;
@ Test public void testUTC () { assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testZ () { assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testBareGmt () { assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testGetGmtTimeZone () { assertEquals ( NUMBER_CONSTANT , FastTimeZone . getGmtTimeZone () . getRawOffset () ) ; }
{ assertEquals ( REPEAT , future . get () . intValue () ) ; }
{ watch . getStartTime () ; assertTrue ( watch . getStartTime () >= beforeStopWatch ) ; }
{ assertTrue ( toString . indexOf ( SECRET_VALUE ) > NUMBER_CONSTANT ) ; this . validateNonSecretField ( toString ) ; }
{ assertEquals ( ArrayUtils.INDEX_NOT_FOUND , toString . indexOf ( SECRET_VALUE ) ) ; this . validateNonSecretField ( toString ) ; }
assertEquals ( expected , hostName ) ;
assertEquals ( value , SerializationUtils . deserialize ( serialized ) ) ;
assertEquals ( isoForm , printer . format ( vulgar ) ) ;
assertEquals ( vulgar . getTime () , cal . getTime () ) ;
final ReflectionToStringBuilder oldBuilder = new ReflectionToStringBuilder ( BOTH_NULL ) ;
final String value
final StringBuilder builder = new StringBuilder ( count ) ;
final String group
final String group
final CharSequence cs
final boolean excludeNullValues
catch ( final NoSuchMethodException expected ) {}
final CharRange a = CharRange . is ( CHAR_CONS ) ;
final T object
for ( final char chr : chrs ) { if ( chars . contains ( chr ) == expect ) { buffer . append ( chr ) ; } }
{ final boolean result = RandomUtils . nextBoolean () ; assertTrue ( result == true || result == false ) ; }
final Object other
@ Override public boolean inDaylightTime ( final Date date ) { return false ; }
@ Override public void setRawOffset ( final int offsetMillis ) { throw new UnsupportedOperationException () ; }
final Class < > anInterface
{ super(); for ( final String s : set ) { add ( s ) ; } }
final TimeZone tz = FastTimeZone . getGmtTimeZone ( timeZone ) ;
final String . . . s
final double [] array
final float [] array
final long [] array
final int [] array
final short [] array
final char [] array
final byte [] array
final boolean [] array
final Object [] array
{ list . add ( throwable ) ; throwable = throwable . getCause () ; }
assertTrue ( String . format ( STRING_CONSTANT , delta ) , delta < NUMBER_CONSTANT ) ;
{ return performStateCheck ( increment ) ; }
this . typeArguments = Arrays . copyOf ( typeArguments , typeArguments.length , Type [] . class ) ;
daemon = null ;
{ daemon = Boolean . valueOf ( f ) ; return this ; }
daemonFlag = builder.daemon ;
public final Boolean getDaemonFlag () { return daemon ; }
daemon = builder.daemon ;
{ return valueAsString . startsWith ( getArrayStart () ) && valueAsString . endsWith ( getArrayEnd () ) ; }
{ return defaultString ( str , EMPTY ) ; }
final String sanitizedSeparator = defaultString ( separator ) ;
if ( str == null || suffix == null ) { return str == suffix ; }
if ( str == null || prefix == null ) { return str == prefix ; }
{ bypassReflectionClasses = new ArrayList <> () ; bypassReflectionClasses . add ( String . class ) ; }
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
for ( Field field : allFields ) { if ( field . getName () . equals ( JACOCO_DATA_FIELD_NAME ) ) { expected ++ ; } }
for ( Field field : allFields ) { if ( field . getName () . equals ( JACOCO_DATA_FIELD_NAME ) ) { expected ++ ; } }
{ buffer . append ( CHAR_CONS ) . append ( StringEscapeUtils . escapeJson ( value ) ) . append ( CHAR_CONS ) ; }
super . appendFieldStart ( buffer , FIELD_NAME_QUOTE + StringEscapeUtils . escapeJson ( fieldName ) + FIELD_NAME_QUOTE ) ;
if ( ! iterator . hasNext () ) { return Objects . toString ( first , EMPTY ) ; }
final StringBuilder buf = new StringBuilder ( STRING_BUILDER_SIZE ) ;
final StringBuilder buf = new StringBuilder ( STRING_BUILDER_SIZE ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
int [] indexesToRemove = {} ;
return ! str . isEmpty () ;
if ( diffs . isEmpty () ) { return OBJECTS_SAME_STRING ; }
notNull ( chars ) ;
notNull ( collection ) ;
notNull ( array ) ;
notNull ( iterable ) ;
notNull ( array ) ;
{ return IS_OS_WINDOWS ? System . getenv ( STRING_CONSTANT ) : System . getenv ( STRING_CONSTANT ) ; }
return getFraction ( numerator / gcd , denominator / gcd ) ;
return replace ( source , valueMap ) ;
if ( isEmpty ( str ) ) { return str ; }
{ return replaceFirst ( text , regex , EMPTY ) ; }
return pattern . matcher ( decomposed ) . replaceAll ( EMPTY ) ;
private Object readResolve () { return JSON_STYLE ; }
private Object readResolve () { return NO_CLASS_NAME_STYLE ; }
private Object readResolve () { return MULTI_LINE_STYLE ; }
private Object readResolve () { return SIMPLE_STYLE ; }
private Object readResolve () { return SHORT_PREFIX_STYLE ; }
private Object readResolve () { return NO_FIELD_NAMES_STYLE ; }
private Object readResolve () { return DEFAULT_STYLE ; }
Throwable root = getRootCause ( th ) ;
final Throwable [] throwables = getThrowables ( throwable ) ;
{ return wrap ( ( Type ) type ) ; }
{ Validate . isTrue ( isAssignable ( owner , raw . getEnclosingClass () ) , STRING_CONSTANT , owner , raw ) ; useOwner = owner ; }
{ parameterizedTypeArguments = new HashMap <> ( typeArguments ) ; parameterizedTypeArguments . putAll ( getTypeArguments ( p ) ) ; }
{ return getPackageName ( getCanonicalName ( canonicalName ) ) ; }
{ return getShortClassName ( getCanonicalName ( canonicalName ) ) ; }
private Object readResolve () { return NULL ; }
{ final int tmpHash = hashCode ( object ) ; hash = hash * NUMBER_CONSTANT + tmpHash ; }
{ return ! equals ( object1 , object2 ) ; }
{ Validate . isTrue ( objectData != null , STRING_CONSTANT ) ; return deserialize ( new ByteArrayInputStream ( objectData ) ) ; }
{ return ( T ) deserialize ( serialize ( msg ) ) ; }
{ return isMatchingExecutable ( Executable . of ( method ) , parameterTypes ) ; }
{ return isMatchingExecutable ( Executable . of ( method ) , parameterTypes ) ; }
final int srcLength = getLength ( array ) ;
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
{ _mask = mask ; _shift_count = mask == NUMBER_CONSTANT ? NUMBER_CONSTANT : Integer . numberOfTrailingZeros ( mask ) ; }
{ return iValue == NUMBER_CONSTANT ? Calendar.SUNDAY : iValue + NUMBER_CONSTANT ; }
mRule . appendTo ( buffer , value == Calendar.SUNDAY ? NUMBER_CONSTANT : value - NUMBER_CONSTANT ) ;
if ( lhs ) { comparison = NUMBER_CONSTANT ; } else { comparison = - NUMBER_CONSTANT ; }
if ( rhs == null ) { comparison = NUMBER_CONSTANT ; return this ; }
