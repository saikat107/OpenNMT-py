{ super . moveDateTimeZone ( zone ) ; }
if ( sm != null ) { sm . checkPermission ( new DateTimeZonePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new DateTimeZonePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new DateTimeZonePermission ( STRING_CONSTANT ) ) ; }
{ return getField () . getAsText ( getInstant () . getMillis () , null ) ; }
DurationField getLeapDurationField ( ) ;
boolean isSupported ( ) ;
DateTime result = new DateTime ( test . resolve ( dt . getMillis () ) ) ;
{ this ( instant , null ) ; }
{ this ( DateTimeUtils . currentTimeMillis () , chronology ) ; }
public TimeOfDay () { this ( DateTimeUtils . currentTimeMillis () , null ) ; }
iInstantConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , PartialInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
iInstantConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , PartialInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
return ( getMillis ( readableInstant ) < readableInstant . getMillis ( this ) ) ;
PartialInstant instant
PartialInstant instant
PartialInstant instant
public abstract int getMaximumValue ( PartialInstant instant ) ;
PartialInstant instant
public abstract int getMinimumValue ( PartialInstant instant ) ;
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant partial
PartialInstant partial
PartialInstant partial
PartialInstant partial
PartialInstant instant
public DateTimeField getField () { return iInstant . getField ( iFieldIndex ) ; }
public DateTimeField getField () { return iInstant . getField ( iFieldIndex ) ; }
{ test1 . dayOfMonth () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . dayOfMonth () . getPartialInstant () ) ;
{ test1 . monthOfYear () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . monthOfYear () . getPartialInstant () ) ;
{ test1 . year () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . year () . getPartialInstant () ) ;
assertEquals ( false , test1 . equals ( MockPartialInstant.EMPTY_INSTANCE ) ) ;
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
public int getMinimumValue ( PartialInstant instant ) { return NUMBER_CONSTANT ; }
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant partial
PartialInstant partial
{ return getField () . getMaximumValue ( getPartialInstant () ) ; }
{ return getField () . getMinimumValue ( getPartialInstant () ) ; }
{ return getField () . getAsShortText ( getPartialInstant () , get () , locale ) ; }
{ return getField () . getAsText ( getPartialInstant () , get () , locale ) ; }
PartialInstant instant
public int getMaximumValue ( PartialInstant instant ) { throw unsupported () ; }
PartialInstant instant
public int getMinimumValue ( PartialInstant instant ) { throw unsupported () ; }
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant partial
PartialInstant partial
void validate ( PartialInstant instant ) ;
PartialInstant instant
PartialInstant instant
PartialInstant instant
public int getMaximumValue ( PartialInstant instant , int [] values ) { return iField . getMaximumValue ( instant , values ) ; }
public int getMaximumValue ( PartialInstant instant ) { return iField . getMaximumValue ( instant ) ; }
public int getMinimumValue ( PartialInstant instant , int [] values ) { return iField . getMinimumValue ( instant , values ) ; }
public int getMinimumValue ( PartialInstant instant ) { return iField . getMinimumValue ( instant ) ; }
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
public String getAsShortText ( PartialInstant partial , Locale locale ) { return iField . getAsShortText ( partial , locale ) ; }
PartialInstant partial
public String getAsText ( PartialInstant partial , Locale locale ) { return iField . getAsText ( partial , locale ) ; }
PartialInstant partial
{ test1 . millisOfSecond () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . millisOfSecond () . getPartialInstant () ) ;
{ test1 . secondOfMinute () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . secondOfMinute () . getPartialInstant () ) ;
{ test1 . minuteOfHour () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . minuteOfHour () . getPartialInstant () ) ;
{ test1 . hourOfDay () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . hourOfDay () . getPartialInstant () ) ;
assertEquals ( false , test1 . equals ( MockPartialInstant.EMPTY_INSTANCE ) ) ;
PartialInstant instant
PartialInstant instant
PartialInstant instant
{ t = new DateTimeFormatterBuilder ( iChrono ) . append ( hourMinuteSecondFraction () ) . append ( offsetElement () ) . toFormatter () ; }
iChronology = converter . getChronology ( instant , chronology ) ;
iChronology = converter . getChronology ( instant , zone ) ;
iChronology = converter . getChronology ( instant ) ;
{ return DurationType . getAverageYearMonthType () ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
public DurationField millis () { return UnsupportedDurationField.INSTANCE ; }
public DurationField seconds () { return UnsupportedDurationField.INSTANCE ; }
public DurationField minutes () { return UnsupportedDurationField.INSTANCE ; }
public DurationField hours () { return UnsupportedDurationField.INSTANCE ; }
public DurationField days () { return UnsupportedDurationField.INSTANCE ; }
public DurationField weeks () { return UnsupportedDurationField.INSTANCE ; }
public DurationField months () { return UnsupportedDurationField.INSTANCE ; }
public DurationField years () { return UnsupportedDurationField.INSTANCE ; }
boolean isSupported ( ) ;
{ return getField () . remainder ( getInstant () . getMillis () ) ; }
{ return getField () . getMaximumValue ( getInstant () . getMillis () ) ; }
{ return getField () . getMinimumValue ( getInstant () . getMillis () ) ; }
{ return getField () . getLeapAmount ( getInstant () . getMillis () ) ; }
{ return getField () . isLeap ( getInstant () . getMillis () ) ; }
return getField () . getDifferenceAsLong ( getInstant () . getMillis () , instant . getMillis () ) ;
return getField () . getDifference ( getInstant () . getMillis () , instant . getMillis () ) ;
{ return getField () . getAsShortText ( getInstant () . getMillis () , locale ) ; }
{ return getField () . getAsText ( getInstant () . getMillis () , locale ) ; }
{ return getField () . get ( getInstant () . getMillis () ) ; }
assertSame ( test , test . dayOfMonth () . getInstant () ) ;
assertSame ( test , test . monthOfYear () . getInstant () ) ;
assertSame ( test , test . year () . getInstant () ) ;
assertSame ( test , test . yearOfCentury () . getInstant () ) ;
assertSame ( test , test . centuryOfEra () . getInstant () ) ;
assertSame ( test , test . yearOfEra () . getInstant () ) ;
assertSame ( test , test . era () . getInstant () ) ;
try { iChrono . era () . addWrapped ( SMALL_MILLIS , NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
iMillis = converter . getInstantMillis ( instant , chronology ) ;
iMillis = converter . getInstantMillis ( instant , zone ) ;
iMillis = converter . getInstantMillis ( instant ) ;
{ super(); iChronology = selectChronology ( chronology ) ; iMillis = instant ; }
{ setDateTime ( instant ) ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
LongConverter.INSTANCE . setInto ( m , null ) ;
withUTC () . getTimeOnlyMillis ( iCutoverMillis ) == NUMBER_CONSTANT
{ long instant = getChronology () . getDateTimeMillis ( getMillis () , hour , minuteOfHour , secondOfMinute , millisOfSecond ) ; setTime ( instant ) ; }
return getDateOnlyMillis ( year , monthOfYear , dayOfMonth ) + millisOfDay ;
assertEquals ( false , zone5 . equals ( zone5 ) ) ;
protected DateTimeUtils () {}
private DateTimeUtils () { super(); }
public int size () { return iConverters.length ; }
catch ( Exception ex ) {}
assertNotSame ( set , result ) ;
assertEquals ( NUMBER_CONSTANT * DateTimeConstants.MILLIS_PER_DAY , test . monthOfYear () . remainder () ) ;
MutableDuration duration = new MutableDuration ( type , NUMBER_CONSTANT ) ;
public String toString () { return STRING_CONSTANT + getName () + CHAR_CONS ; }
{ if ( chrono == getChronology () ) { return this ; } return mask ( iType . withChronology ( chrono ) , iMask ) ; }
{ if ( chrono == iChronology ) { return this ; } return new YearWeekType ( iChronology ) ; }
{ if ( chrono == iChronology ) { return this ; } return new YearMonthType ( iChronology ) ; }
{ if ( chrono == iChronology ) { return this ; } return new AllType ( iChronology ) ; }
{ if ( chrono == iChronology ) { return this ; } return new DayHourType ( iChronology ) ; }
if ( isPrecise () ) { return instant += getTotalMillis () * scalar ; }
MutableDuration test = new MutableDuration ( NUMBER_CONSTANT ) ;
{ assertEquals ( NUMBER_CONSTANT , Duration.ZERO . getTotalMillis () ) ; assertEquals ( DurationType . getMillisType () , Duration.ZERO . getDurationType () ) ; }
public YearMonthType ( Chronology chrono ) { super ( chrono ) ; }
public AllType ( Chronology chrono ) { super ( chrono ) ; }
public void testGetDurationType_Object ( ) throws Exception { assertEquals ( DurationType . getMillisType () , NullConverter.INSTANCE . getDurationType ( null ) ) ; }
{ duration = duration . withDurationType ( type ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( duration , type ) ; }
{ super ( duration , null ) ; }
assertEquals ( DurationType . getMillisType () , test . getDurationType () ) ;
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( duration , type ) ; }
{ super ( duration , null ) ; }
assertEquals ( DurationType . getMillisType () , test . getDurationType () ) ;
assertEquals ( DurationType . getMillisType () , test . getDurationType () ) ;
{ MutableDuration test = new MutableDuration () ; assertEquals ( DurationType . getMillisType () , test . getDurationType () ) ; }
{ convId = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return new FixedDateTimeZone ( convId , null , offset , offset ) ; }
{ id = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return new FixedDateTimeZone ( id , null , offset , offset ) ; }
assertEquals ( false , test1 . equals ( new Duration ( NUMBER_CONSTANT , DurationType . getAverageYearMonthType () ) ) ) ;
type = ( type == null ? converter . getDurationType ( duration ) : type ) ;
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearWeekType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearMonthType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getAllType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getDayHourType () ; }
assertEquals ( type , type . withChronology ( ISOChronology . getInstanceUTC () ) ) ;
assertEquals ( null , type . getChronology () ) ;
assertEquals ( false , test1 . equals ( new Duration ( NUMBER_CONSTANT , DurationType . getAverageYearMonthType () ) ) ) ;
ReadWritableDuration duration
MutableDuration test = new MutableDuration ( NUMBER_CONSTANT ) ;
{ return ( ( ReadableDuration ) object ) . getTotalMillis () ; }
{ return ( ( ReadableDuration ) object ) . isPrecise () ; }
Duration test = new Duration ( NUMBER_CONSTANT ) ;
Duration test = new Duration ( NUMBER_CONSTANT ) ;
{ Duration test = new Duration ( NUMBER_CONSTANT ) ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
public void setInto ( ReadWritableDuration duration , Object object ) {}
public void setInto ( ReadWritableDuration duration , Object object ) {}
public void setInto ( ReadWritableDuration duration , Object object ) {}
c = ConverterManager . getInstance () . getDurationConverter ( new Duration ( DurationType . getMillisType () ) ) ;
Duration test = new Duration ( STRING_CONSTANT ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( length , null ) ;
Duration test = new Duration ( length ) ;
Duration test = Duration.ZERO ;
MutableDuration test = new MutableDuration ( STRING_CONSTANT ) ;
MutableDuration test = new MutableDuration ( dt1 , dt2 ) ;
MutableDuration test = new MutableDuration ( dt1 , dt2 ) ;
MutableDuration test = new MutableDuration ( dt1 , dt2 ) ;
MutableDuration test = new MutableDuration ( dt1 , dt2 ) ;
MutableDuration test = new MutableDuration ( length , null ) ;
MutableDuration test = new MutableDuration ( length ) ;
{ try { new MutableDuration ( DurationType . getAllType () , true ) ; fail () ; } catch ( IllegalArgumentException ex ) {} }
MutableDuration test = new MutableDuration ( null , false ) ;
MutableDuration test = new MutableDuration ( null , true ) ;
MutableDuration test = new MutableDuration () ;
MutableDuration test = new MutableDuration ( NUMBER_CONSTANT ) ;
MutableDuration test = new MutableDuration () ;
{ MutableDuration test = new MutableDuration () ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
{ DurationConverter [] array = ConverterManager . getInstance () . getDurationConverters () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , m . getTotalMillis () ) ;
assertEquals ( NUMBER_CONSTANT , m . getTotalMillis () ) ;
{ add ( new TimePeriod ( duration ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () ) ) ; } }
suite . addTest ( TestDurationType . suite () ) ;
{ add ( new TimePeriod ( duration , getDurationType () ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () , getDurationType () ) ) ; } }
{ if ( interval != null ) { add ( interval . toTimePeriod ( getDurationType () ) ) ; } }
final DurationType type = iType ;
DurationType type
DurationType type
DurationType type
DurationType type
int hash = getDurationType () . hashCode () ;
DurationType type = iType ;
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getMillisType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getYearMonthType () ) ;
DurationType type = period . getDurationType () ;
DurationType type
if ( ! mustParse && ! isSupported ( period . getDurationType () ) ) { return position ; }
DurationType type
DurationType type
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
TimePeriodConverter c = ConverterManager . getInstance () . getTimePeriodConverter ( new TimePeriod ( DurationType . getMillisType () ) ) ;
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( DurationType . getMillisType () ) ) ;
{ return new TimePeriod ( toDurationMillis () , getDurationType () ) ; }
DurationType type
DurationType type
DurationType type
DurationType type
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
test . add ( new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseAllType () ) ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearWeekType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearWeekType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
DurationType type
DurationType type
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getMillisType () ) ;
public TestDurationType ( String name ) { super ( name ) ; }
assertEquals ( test . getDurationType () , copy . getDurationType () ) ;
assertEquals ( test . getDurationType () , copy . getDurationType () ) ;
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
MillisDuration base = new MillisDuration ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getDayHourType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
DurationType type
DurationType type
DurationType type
DurationType type
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getMillisType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getYearMonthType () ) ;
if ( pos < NUMBER_CONSTANT ) { parser . parseMutableTimePeriod ( period . getDurationType () , str ) ; }
ReadableTimePeriod period
ReadableTimePeriod period
public void testSetDuration_RD () { setTimePeriod ( ( ReadableDuration ) null ) ; }
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ;
{ TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
MutableTimePeriod result = test . toMutableTimePeriod () ;
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( PeriodType . getMillisType () ) ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
ReadableTimePeriod period
ReadableTimePeriod period
TimePeriod duration ;
{ return STRING_CONSTANT + iInstantConverters . size () + STRING_CONSTANT + iDurationConverters . size () + STRING_CONSTANT + iTimePeriodConverters . size () + STRING_CONSTANT + iIntervalConverters . size () + STRING_CONSTANT ; }
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod () ;
{ MutableTimePeriod test = new MutableTimePeriod () ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
TimePeriod test = new TimePeriod ( STRING_CONSTANT ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( length , null ) ;
TimePeriod test = new TimePeriod ( length ) ;
TimePeriod test = new TimePeriod ( length ) ;
MutableTimePeriod test = new MutableTimePeriod ( STRING_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( length , null ) ;
MutableTimePeriod test = new MutableTimePeriod ( length ) ;
MutableTimePeriod test = new MutableTimePeriod ( length ) ;
MutableTimePeriod test = new MutableTimePeriod () ;
Class cls = ReadableTimePeriodConverter . class ;
ReadableTimePeriod period
ReadableTimePeriod period
public void testSetTotalMillis_2 () { setPeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testSetTotalMillis_1 () { setPeriod ( NUMBER_CONSTANT ) ; }
public void testSetDuration_RD () { setDuration ( null ) ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getUTCAllType () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getUTCAllType () ) ;
{ if ( chrono == iChronology ) { return this ; } return PeriodType . getYearWeekType ( chrono ) ; }
{ return PRECISE_ALL_TYPE ; }
{ return PRECISE_YEAR_WEEK_TYPE ; }
{ return PRECISE_YEAR_MONTH_TYPE ; }
public static PeriodType getPreciseYearDayType () { return PRECISE_YEAR_DAY_TYPE ; }
public static PeriodType getPreciseDayHourType () { return PRECISE_DAY_HOUR_TYPE ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getUTCYearWeekType () ; }
{ return YEAR_WEEK_TYPE ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getUTCYearMonthType () ; }
{ return YEAR_MONTH_TYPE ; }
public static PeriodType getYearDayType () { return YEAR_DAY_TYPE ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getUTCAllType () ; }
{ return ALL_TYPE ; }
public static PeriodType getMillisType () { return MILLIS_TYPE ; }
public Duration ( long duration ) { super ( duration ) ; }
public AbstractDuration () { super(); }
{ long durationMillis = DateTimeUtils . getDurationMillis ( duration ) ; setStartMillis ( FieldUtils . safeAdd ( getStartMillis () , - durationMillis ) ) ; }
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
final Object duration
public Duration ( long duration ) { super(); iMillis = duration ; }
{ long endMillis = DateTimeUtils . getInstantMillis ( end ) ; setInterval ( iStartMillis , endMillis ) ; }
{ long startMillis = DateTimeUtils . getInstantMillis ( start ) ; setInterval ( startMillis , iEndMillis ) ; }
{ setInterval ( startInstant , iEndMillis ) ; }
public void normalize () { super . normalize () ; }
{ return new MutableDateTime ( this , chronology ) ; }
public MutableDateTime toMutableDateTime () { return new MutableDateTime ( this ) ; }
{ long instant = getChronology () . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; setDateTime ( instant ) ; }
{ super(); iChronology = partial.iChronology ; iValues = values ; }
{ super(); iChronology = partial.iChronology ; iValues = values ; }
{ Chronology chrono = iChronology . withZone ( zone ) ; return resolve ( baseInstant , chrono ) ; }
AbstractGJChronology chronology
GJWeekyearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
AbstractGJChronology chronology
GJYearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
AbstractGJChronology chronology
GJEraDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
AbstractGJChronology chronology
GJMonthOfYearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
AbstractGJChronology chronology
NoWeekyearZeroField ( AbstractGJChronology chronology , DateTimeField field ) { super ( chronology , field ) ; }
AbstractGJChronology chronology
AbstractGJChronology chronology
AbstractGJChronology chronology
AbstractGJChronology chrono = iChronology ;
CopticYearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public static TestSuite suite () { return BulkTest . makeSuite ( TestDateTimeConstants . class ) ; }
public static TestSuite suite () { return BulkTest . makeSuite ( TestParseISO . class ) ; }
{ millis = getField ( i ) . set ( millis , getValue ( i ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendSuffix ( new SingularAffix ( text ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendPrefix ( new SingularAffix ( text ) ) ; }
DurationFieldAffix affix ;
DurationFieldAffix affix ;
DurationFieldAffix affix ;
DurationFieldAffix suffix
int scan ( String durationStr , int position ) ;
int parse ( String durationStr , int position ) ;
DurationFieldAffix suffix
DurationFieldAffix prefix
{ if ( iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue ( period ) >= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
public PeriodFormatterBuilder appendMillis () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithOptionalMillis () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithMillis () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendSeconds () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendMinutes () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendHours () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendDays () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendWeeks () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendMonths () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendYears () { appendField ( NUMBER_CONSTANT ) ; return this ; }
DateTimeComparator c = DateTimeComparator . getInstance ( ISO . hourOfDay () , ISO . dayOfYear () ) ;
DateTimeField lowerLimit
public static DateTimeComparator getInstance () { return INSTANCE ; }
public DateTimeField era () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , eras () ) ; }
public DateTimeField centuryOfEra () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , centuries () ) ; }
public DateTimeField yearOfCentury () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , years () ) ; }
public DateTimeField yearOfEra () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , years () ) ; }
public DateTimeField year () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , years () ) ; }
public DateTimeField monthOfYear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , months () ) ; }
public DateTimeField weekyear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , weekyears () ) ; }
public DateTimeField weekOfWeekyear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , weeks () ) ; }
public DateTimeField dayOfYear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , days () ) ; }
public DateTimeField dayOfMonth () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , days () ) ; }
{ return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , days () ) ; }
{ return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ) ; }
public DateTimeField clockhourOfHalfday () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField hourOfHalfday () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField clockhourOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField hourOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField minuteOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , minutes () ) ; }
public DateTimeField minuteOfHour () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , minutes () ) ; }
public DateTimeField secondOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , seconds () ) ; }
public DateTimeField secondOfMinute () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , seconds () ) ; }
public DateTimeField millisOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , millis () ) ; }
public DateTimeField millisOfSecond () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , millis () ) ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( yearField , STRING_CONSTANT ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
if ( iParseField == null ) { iParseField = new PreciseDateTimeField ( STRING_CONSTANT , MillisDurationField.INSTANCE , iField . getDurationField () ) ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( STRING_CONSTANT , STRING_CONSTANT , chrono . millisPerMonth () , chrono ) ; }
public TestGJYearField ( TestGJChronology chrono ) { super ( STRING_CONSTANT , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( STRING_CONSTANT , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( STRING_CONSTANT , weeks ) ; iChronology = chronology ; }
{ super ( field , field . getName () ) ; iDurationField = durationField ; iRangeDurationField = rangeDurationField ; iLeapDurationField = leapDurationField ; }
private ISOYearOfEraDateTimeField () { super ( GregorianChronology . getInstanceUTC () . year () , STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
super ( gregorianField . getName () ) ;
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , months ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
super ( field . getName () ) ;
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , STRING_CONSTANT , chrono.MILLIS_PER_DAY , chrono ) ; }
{ return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . halfdayOfDay () , UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ) ; }
{ super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , STRING_CONSTANT , chrono.MILLIS_PER_DAY , chrono ) ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chrono . millisPerMonth () , chrono ) ; }
fields.centuryOfEra = new DividedDateTimeField ( ISOYearOfEraDateTimeField.INSTANCE , DateTimeFieldType . centuryOfEra () , STRING_CONSTANT , NUMBER_CONSTANT ) ;
public TestGJYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . year () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , STRING_CONSTANT , NUMBER_CONSTANT ) ;
LinkedDurationField ( DurationField durationField , ImpreciseCutoverField dateTimeField ) { super ( durationField , durationField . getName () ) ; iField = dateTimeField ; }
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , STRING_CONSTANT , chrono.MILLIS_PER_DAY , chrono ) ; }
public String toString () { return STRING_CONSTANT ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , STRING_CONSTANT , NUMBER_CONSTANT ) ;
super ( field . getName () ) ;
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
{ super ( chrono ) ; iMonths = new ScaledDurationField ( chrono . days () , STRING_CONSTANT , NUMBER_CONSTANT ) ; }
{ super ( chrono ) ; iYears = new ScaledDurationField ( chrono . days () , STRING_CONSTANT , NUMBER_CONSTANT ) ; }
partial . isSupported ( iField )
partial . isSupported ( iField )
partial . isSupported ( iField )
{ return getAsShortText ( partial , partial . get ( this ) , locale ) ; }
{ return getAsText ( partial , partial . get ( this ) , locale ) ; }
public int getFieldSize () { return NUMBER_CONSTANT ; }
int i = NUMBER_CONSTANT , isize = getFieldSize ()
int getFieldSize ( ) ;
public int getFieldSize () { return getFields () . length ; }
public int getFieldSize () { return NUMBER_CONSTANT ; }
int [] values = new int [ getFieldSize () ] ;
int otherValue = chrono . getField ( getFieldType () ) . get ( instant . getMillis () ) ;
public static DurationFieldType eras () { return ERAS ; }
public static DurationFieldType centuries () { return CENTURIES ; }
public static DurationFieldType years () { return YEARS ; }
public static DurationFieldType months () { return MONTHS ; }
public static DurationFieldType weekyears () { return WEEKYEARS ; }
public static DurationFieldType weeks () { return WEEKS ; }
public static DurationFieldType days () { return DAYS ; }
public static DurationFieldType halfdays () { return HALFDAYS ; }
public static DurationFieldType hours () { return HOURS ; }
public static DurationFieldType minutes () { return MINUTES ; }
public static DurationFieldType seconds () { return SECONDS ; }
public static DurationFieldType millis () { return MILLIS ; }
public static DateTimeFieldType era () { return ERA ; }
public static DateTimeFieldType centuryOfEra () { return CENTURY_OF_ERA ; }
public static DateTimeFieldType yearOfCentury () { return YEAR_OF_CENTURY ; }
public static DateTimeFieldType yearOfEra () { return YEAR_OF_ERA ; }
public static DateTimeFieldType year () { return YEAR ; }
public static DateTimeFieldType monthOfYear () { return MONTH_OF_YEAR ; }
public static DateTimeFieldType weekyearOfCentury () { return WEEKYEAR_OF_CENTURY ; }
public static DateTimeFieldType weekyear () { return WEEKYEAR ; }
public static DateTimeFieldType weekOfWeekyear () { return WEEK_OF_WEEKYEAR ; }
public static DateTimeFieldType dayOfYear () { return DAY_OF_YEAR ; }
public static DateTimeFieldType dayOfMonth () { return DAY_OF_MONTH ; }
public static DateTimeFieldType dayOfWeek () { return DAY_OF_WEEK ; }
public static DateTimeFieldType halfdayOfDay () { return HALFDAY_OF_DAY ; }
public static DateTimeFieldType clockhourOfHalfday () { return CLOCKHOUR_OF_HALFDAY ; }
public static DateTimeFieldType hourOfHalfday () { return HOUR_OF_HALFDAY ; }
public static DateTimeFieldType clockhourOfDay () { return CLOCKHOUR_OF_DAY ; }
public static DateTimeFieldType hourOfDay () { return HOUR_OF_DAY ; }
public static DateTimeFieldType minuteOfDay () { return MINUTE_OF_DAY ; }
public static DateTimeFieldType minuteOfHour () { return MINUTE_OF_HOUR ; }
public static DateTimeFieldType secondOfDay () { return SECOND_OF_DAY ; }
public static DateTimeFieldType secondOfMinute () { return SECOND_OF_MINUTE ; }
public static DateTimeFieldType millisOfDay () { return MILLIS_OF_DAY ; }
public static DateTimeFieldType millisOfSecond () { return MILLIS_OF_SECOND ; }
{ if ( instant == null ) { return isAfter ( DateTimeUtils . currentTimeMillis () ) ; } return isAfter ( instant . getMillis () ) ; }
{ if ( instant == null ) { return isBefore ( DateTimeUtils . currentTimeMillis () ) ; } return isBefore ( instant . getMillis () ) ; }
{ if ( instant == null ) { return contains ( DateTimeUtils . currentTimeMillis () ) ; } return contains ( instant . getMillis () ) ; }
assertEquals ( false , test . isAfter ( null ) ) ;
assertEquals ( false , test . isBefore ( null ) ) ;
assertEquals ( false , test . isAfter ( null ) ) ;
assertEquals ( false , test . isBefore ( null ) ) ;
{ super . setMillis ( millis ) ; }
{ super . setSeconds ( seconds ) ; }
{ super . setMinutes ( minutes ) ; }
{ super . setHours ( hours ) ; }
{ super . setDays ( days ) ; }
{ super . setWeeks ( weeks ) ; }
{ super . setMonths ( months ) ; }
{ super . setYears ( years ) ; }
{ super . setPeriod ( duration ) ; }
{ super ( period , type ) ; }
{ super ( period , null ) ; }
public MutablePeriod ( PeriodType type ) { super ( NUMBER_CONSTANT , type ) ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period result = test . withPeriodType ( PeriodType . getAllType () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
{ Period test = new Period ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
{ super ( period , type ) ; }
{ super ( period , null ) ; }
test = new MutablePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadablePeriodConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
{ MutablePeriod test = new MutablePeriod () ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
{ if ( period != null ) { setMillis ( period . addTo ( getMillis () , scalar ) ) ; } }
{ test1 . year () . compareTo ( null ) ; fail () ; }
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setStartMillis ( period . addTo ( getEndMillis () , - NUMBER_CONSTANT , chrono ) ) ; }
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setEndMillis ( period . addTo ( getStartMillis () , NUMBER_CONSTANT , chrono ) ) ; }
assertEquals ( PeriodType . time () , test . getPeriodType () ) ;
{ if ( period != null ) { setMillis ( period . addTo ( getMillis () , scalar , getChronology () ) ) ; } }
assertEquals ( PeriodType . time () , test . getPeriodType () ) ;
return new Period ( new int [] { millis } , PeriodType . standard () ) ;
return new Period ( new int [] { seconds } , PeriodType . standard () ) ;
return new Period ( new int [] { minutes } , PeriodType . standard () ) ;
return new Period ( new int [] { hours } , PeriodType . standard () ) ;
return new Period ( new int [] { days } , PeriodType . standard () ) ;
return new Period ( new int [] { weeks } , PeriodType . standard () ) ;
return new Period ( new int [] { months } , PeriodType . standard () ) ;
new Period ( new int [] { years } , PeriodType . standard () )
try { test . setYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
{ duration . setPeriod ( NUMBER_CONSTANT , chrono ) ; }
{ super . setEndMillis ( endInstant ) ; }
{ super . setStartMillis ( startInstant ) ; }
public long getDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
{ IntervalConverter [] array = ConverterManager . getInstance () . getIntervalConverters () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ return ( ( ( ReadableInterval ) object ) ) . getDurationMillis () ; }
{ MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . getDuration () ) ; }
iIntervalConverters = new ConverterSet ( new Converter [] { ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , } ) ;
public long getDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
Interval result = test . withEndInstant ( null ) ;
{ test . withEndInstant ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withEndInstant ( new Instant ( TEST_TIME2 - NUMBER_CONSTANT ) ) ;
Interval result = test . withStartInstant ( null ) ;
{ test . withStartInstant ( new Instant ( TEST_TIME2 + NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withStartInstant ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ;
{ Interval test = new Interval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . getDuration () ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
Instant getEndInstant ( ) ;
Instant getStartInstant ( ) ;
long resolved = resolve ( instantMillis , chrono ) ;
{ Chronology chrono = getChronology () . withZone ( zone ) ; return resolve ( baseInstant , chrono ) ; }
iValues = initValues ( millis , chronology ) ;
iValues = initValues ( millis , chronology ) ;
iValues = initValues ( instant , chronology ) ;
{ setStartMillis ( getChronology () . add ( getEndMillis () , period , - NUMBER_CONSTANT ) ) ; }
{ setEndMillis ( getChronology () . add ( getStartMillis () , period , NUMBER_CONSTANT ) ) ; }
{ if ( period == null ) { setPeriodInternal ( NUMBER_CONSTANT , null ) ; } else { setPeriodInternal ( period ) ; } }
long endMillis = chrono . add ( startMillis , this , NUMBER_CONSTANT ) ;
setPeriodInternal ( startMillis , endMillis , chrono ) ;
if ( period == null ) { iStartMillis = iEndMillis ; } else { iStartMillis = chrono . add ( iEndMillis , period , - NUMBER_CONSTANT ) ; }
if ( period == null ) { iEndMillis = iStartMillis ; } else { iEndMillis = chrono . add ( iStartMillis , period , NUMBER_CONSTANT ) ; }
long instant = getChronology () . add ( getMillis () , period , scalar ) ;
{ if ( period != null ) { setMillis ( getChronology () . add ( getMillis () , period , scalar ) ) ; } }
{ if ( period != null ) { addPeriod ( period ) ; } }
{ long millis = partial . resolve ( NUMBER_CONSTANT , DateTimeZone.UTC ) ; printTo ( null , out , millis ) ; }
long millis = partial . resolve ( NUMBER_CONSTANT , DateTimeZone.UTC ) ;
DateTime result = test . resolveDateTime ( null ) ;
{ if ( partial == null ) { return this ; } return partial . resolveDateTime ( this ) ; }
DateTime result = test . resolveDateTime ( null ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
{ return new Period ( getStartMillis () , getEndMillis () , type ) ; }
{ return new Period ( getStartMillis () , getEndMillis () ) ; }
{ return new MutableInterval ( getStartMillis () , getEndMillis () ) ; }
{ return new Interval ( getStartMillis () , getEndMillis () ) ; }
Interval test4 = new Interval ( TEST_TIME1 , TEST_TIME1 , Chronology . getGJ () ) ;
{ if ( endInstant == getEndMillis () ) { return this ; } return new Interval ( getStartMillis () , endInstant ) ; }
{ if ( startInstant == getStartMillis () ) { return this ; } return new Interval ( startInstant , getEndMillis () ) ; }
{ test . set ( ISOChronology . getInstance () . monthOfYear () , NUMBER_CONSTANT ) ; fail () ; }
test . set ( ISOChronology . getInstance () . year () , NUMBER_CONSTANT ) ;
public MutableDateTime parseMutableDateTime ( final String text ) { return mParser . parseMutableDateTime ( text ) ; }
public DateTime parseDateTime ( final String text ) { return mParser . parseDateTime ( text ) ; }
public long parseMillis ( final String text ) { return mParser . parseMillis ( text ) ; }
public String print ( final long instant ) { throw unsupported () ; }
public String print ( final ReadableInstant instant ) { throw unsupported () ; }
FParser ( final DateTimeParser parser ) { super(); mParser = parser ; }
public MutableDateTime parseMutableDateTime ( final String text ) { throw unsupported () ; }
public DateTime parseDateTime ( final String text ) { throw unsupported () ; }
public long parseMillis ( final String text ) { throw unsupported () ; }
public String print ( final long instant ) { return mPrinter . print ( instant ) ; }
public String print ( final ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
FPrinter ( final DateTimePrinter printer ) { super(); mPrinter = printer ; }
final Object f
final Object f
final Object f
public DateTimeFormatterBuilder appendEraText () { return appendText ( iChronoUTC . era () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearShortText () { return appendShortText ( iChronoUTC . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearText () { return appendText ( iChronoUTC . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekShortText () { return appendShortText ( iChronoUTC . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekText () { return appendText ( iChronoUTC . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendHalfdayOfDayText () { return appendText ( iChronoUTC . halfdayOfDay () ) ; }
final String text
final char c
final Object element
final DateTimeParser parser
final DateTimeParser parser
final DateTimePrinter printer
final DateTimeFormatter formatter
final Chronology chrono
final DateTimeZone zone
iMillis = converter . getInstantMillis ( instant ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getInstantConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
{ PartialConverter [] array = ConverterManager . getInstance () . getPartialConverters () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
iPartialConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , null ) ; }
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , null ) ; }
throw new IllegalStateException () ;
throw new IllegalStateException () ;
{ return value * getUnitMillis () ; }
{ return value * iUnitMillis ; }
try { MillisDurationField.INSTANCE . getDifferenceAsLong ( Long.MAX_VALUE , NUMBER_CONSTANT ) ; fail () ; } catch ( ArithmeticException ex ) {}
BaseDateTimeField field = new MockBaseDateTimeField () ;
BaseDateTimeField field = new MockPreciseDateTimeField () ;
DateTimeParser dateTimeParser = ISODateTimeFormat . getInstance () . dateTimeParser () ;
{ assertEquals ( PARIS , DateTimeUtils . getZone ( PARIS ) ) ; assertEquals ( LONDON , DateTimeUtils . getZone ( null ) ) ; }
DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder ( iChrono , iLocale ) ;
PeriodParser [] parsers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
Separator finish ( PeriodFormatter after ) { iAfter = after ; return this ; }
PeriodFormatter before
PeriodFormatter composite = createComposite ( formatters ) ;
return offsetFormatter () . print ( instant , this ) ;
return offsetFormatter () . print ( instant , this ) ;
{ convId = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return fixedOffsetZone ( convId , offset ) ; }
return DateTimeFormat . getInstance ( getChronology () , locale ) . forPattern ( pattern ) . print ( this ) ;
return DateTimeFormat . getInstance ( getChronology () ) . forPattern ( pattern ) . print ( this ) ;
DateTimeParser p = ISODateTimeFormat . getInstance ( getLenientISOChronology () ) . hourMinuteSecondFraction () ;
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono ) ;
DateTimeParserBucket bucket = new DateTimeParserBucket ( NUMBER_CONSTANT , chrono ) ;
DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono ) ;
{ if ( permission instanceof JodaTimePermission ) { return false ; } return super . implies ( domain , permission ) ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return super . implies ( domain , permission ) ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return super . implies ( domain , permission ) ; }
iFieldType >= NUMBER_CONSTANT
{ return appendSeparator ( text , finalText , true , true ) ; }
{ return appendSeparator ( text , text , true , true ) ; }
int offset = - ( int ) offsetFormatter () . parseMillis ( convId ) ;
int offset = - ( int ) offsetFormatter () . parseMillis ( id ) ;
int itimeStyle = selectStyle ( dateStyle ) ;
DateTimeField field = iFieldType . getField ( chrono ) ;
return printTimeZone ( getOffset ( instant ) ) ;
return printTimeZone ( getOffset ( instant ) ) ;
String id = printTimeZone ( offset ) ;
public MutableDateTime parseMutableDateTime ( String text , ReadableInstant instant ) { return mParser . parseMutableDateTime ( text , instant ) ; }
public MutableDateTime parseMutableDateTime ( String text , Chronology chrono ) { return mParser . parseMutableDateTime ( text , chrono ) ; }
public DateTime parseDateTime ( String text , ReadableInstant instant ) { return mParser . parseDateTime ( text , instant ) ; }
public DateTime parseDateTime ( String text , Chronology chrono ) { return mParser . parseDateTime ( text , chrono ) ; }
{ return mParser . parseMillis ( text , instant , chrono ) ; }
{ return mParser . parseInto ( instant , text , position ) ; }
public String print ( long instant , Chronology chrono ) { return mPrinter . print ( instant , chrono ) ; }
public String print ( long instant , DateTimeZone zone ) { return mPrinter . print ( instant , zone ) ; }
{ mPrinter . printTo ( out , instant , chrono ) ; }
{ mPrinter . printTo ( buf , instant , chrono ) ; }
{ mPrinter . printTo ( out , instant , zone ) ; }
{ mPrinter . printTo ( buf , instant , zone ) ; }
public void printTo ( Writer out , long instant ) throws IOException { mPrinter . printTo ( out , instant ) ; }
{ mPrinter . printTo ( out , instant ) ; }
protected int estimateParsedLength () { return iParsedLengthEstimate ; }
protected int estimateParsedLength () { return iParsedLengthEstimate ; }
BaseDateTimeFormatter [] elements = iPrinters ;
BaseDateTimeFormatter [] elements = iPrinters ;
protected int estimatePrintedLength () { return iPrintedLengthEstimate ; }
BaseDateTimeFormatter [] printers
protected int estimatePrintedLength () { return iShortFormat ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
protected int estimateParsedLength () { return estimatePrintedLength () ; }
protected int estimateParsedLength () { return iMaxDigits ; }
protected int estimatePrintedLength () { return iMaxDigits ; }
protected int estimateParsedLength () { return estimatePrintedLength () ; }
protected int estimatePrintedLength () { return iShort ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
protected int estimatePrintedLength () { return NUMBER_CONSTANT ; }
protected int estimateParsedLength () { return NUMBER_CONSTANT ; }
protected int estimatePrintedLength () { return iMaxParsedDigits ; }
protected int estimatePrintedLength () { return iMaxParsedDigits ; }
protected int estimateParsedLength () { return iMaxParsedDigits ; }
ParseBucket bucket
protected int estimateParsedLength () { return NUMBER_CONSTANT ; }
return new MutableDateTime ( parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new MutableDateTime ( parseMillis ( text , chrono ) , chrono ) ; }
return new DateTime ( parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new DateTime ( parseMillis ( text , chrono ) , chrono ) ; }
return print ( millis , chrono ) ;
printTo ( out , millis , chrono ) ;
printTo ( buf , millis , chrono ) ;
BasePeriodFormatter [] parsers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
Separator finish ( BasePeriodFormatter after ) { iAfter = after ; return this ; }
BasePeriodFormatter before
BasePeriodFormatter composite = createComposite ( formatters ) ;
{ return getField () . remainder ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMaximumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMinimumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getLeapAmount ( getReadableInstant () . getMillis () ) ; }
{ return getField () . isLeap ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getAsShortText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . getAsText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . get ( getReadableInstant () . getMillis () ) ; }
if ( value == NUMBER_CONSTANT ) { return this ; }
fields.era = BuddhistEraDateTimeField.INSTANCE ;
{ zone = DateTimeZone . getInstance ( cal . getTimeZone () ) ; }
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
{ DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , zone . getID () ) ; }
DateTimeZone . setDefault ( DateTimeZone . getInstance ( STRING_CONSTANT ) ) ;
iChronology = ISOChronology . getInstance ( DateTimeZone . getInstance ( id ) ) ;
z = DateTimeZone . getInstance ( str ) ;
zones [ i ++ ] = new ZoneData ( id , DateTimeZone . getInstance ( id ) ) ;
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , chrono.MILLIS_PER_DAY , chrono ) ; }
int dayOfWeek = ( int ) iChronology . mod ( iChronology . fixedFromMillis ( millis ) , NUMBER_CONSTANT ) ;
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , chrono.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , chrono.MILLIS_PER_DAY , chrono ) ; }
DateTimeFormatter [] printers
{ return append0 ( new TimeZoneOffsetFormatter ( zeroOffsetText , showSeparators , minFields , maxFields ) ) ; }
{ return append0 ( new TimeZonePrinter ( iLocale , true ) , null ) ; }
{ return append0 ( new TimeZonePrinter ( iLocale , false ) , null ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , iLocale , true ) ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , iLocale , false ) ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter ) ; }
return - ( int ) offsetFormatter () . parseMillis ( str , chrono ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance ( locale ) . forPattern ( pattern ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance () . forPattern ( pattern ) . print ( this ) ; }
DateTimeParser p = ISODateTimeFormat . getInstance () . hourMinuteSecondFraction () ;
parse ( ISODateTimeFormat . getInstance () . dateTimeParser () ) ;
DateTimeParser p
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance ( locale ) . forPattern ( pattern ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance () . forPattern ( pattern ) . print ( this ) ; }
return cOffsetFormatter . print ( millis , iZone ) ;
bucket . saveField ( DateTimeFieldType . year () , year ) ;
try { g . parseMutableDateTime ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { g . parseDateTime ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
iFormatters . add ( field ) ;
iFormatters . add ( literal ) ;
iFormatters . add ( formatter ) ;
PeriodFormatter formatter = toFormatter ( iFormatters ) ;
public PeriodParser toParser () { return toFormatter () ; }
public PeriodPrinter toPrinter () { return toFormatter () ; }
f = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
InputStream in = new StringBufferInputStream ( data ) ;
{ return ISOPeriodFormat . getInstance () . standard () . print ( this ) ; }
PeriodFormatter periodParser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = PeriodFormat . getInstance () . getDefault () ;
Locale iLocale
Locale iLocale
Locale iLocale
Locale iLocale
fields.year = new CopticYearDateTimeField ( this ) ;
fields.year = new GJYearDateTimeField ( this ) ;
fields.year = new BasicYearDateTimeField ( this ) ;
fields.year = new BasicYearDateTimeField ( this ) ;
{ if ( iZone == zone ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , false , iChrono , zone ) ; }
{ if ( iChrono == chrono ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , iOffsetParsed , chrono , iZone ) ; }
{ if ( iOffsetParsed == true ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , true , iChrono , null ) ; }
return new DateTimeFormatter ( iPrinter , iParser , locale , iOffsetParsed , iChrono , iZone ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
{ return append0 ( new TwoDigitYear ( DateTimeFieldType . weekyear () , pivot ) ) ; }
{ return append0 ( new TwoDigitYear ( DateTimeFieldType . year () , pivot ) ) ; }
suite . addTest ( TestSerialization . suite () ) ;
catch ( NumberFormatException ex ) { throw new IllegalArgumentException ( STRING_CONSTANT + getName () + STRING_CONSTANT + text ) ; }
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalArgumentException ( STRING_CONSTANT + text ) ; } return instant ; }
FieldUtils . verifyValueBounds ( STRING_CONSTANT , millisOfDay , NUMBER_CONSTANT , DateTimeConstants.MILLIS_PER_DAY ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalArgumentException ( STRING_CONSTANT + text ) ; } return instant ; }
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
public final int getMinimumDaysInFirstWeek () { return iMinDaysInFirstWeek ; }
DateTimeZone test = PARIS ;
private DateTimeFormat () { super(); }
private PeriodFormat () {}
private ISOPeriodFormat () {}
cfg . setProperty ( STRING_CONSTANT , STRING_CONSTANT ) ;
fields.era = ThaiBuddhistEraDateTimeField.INSTANCE ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
ReadableIntervalConverter.INSTANCE . setInto ( m , i , Chronology . getCoptic () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
Chronology chrono = Chronology . getISO ( ZONES [ i ] ) ;
Chronology chrono = Chronology . getISO ( ZONES [ i ] ) ;
Chronology chrono = Chronology . getGregorian () ;
Chronology chrono = Chronology . getGJUTC () ;
test . add ( ms , Chronology . getISOUTC () ) ;
test . add ( ms , Chronology . getISO () ) ;
test . add ( NUMBER_CONSTANT , Chronology . getISO () ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( Chronology . getISO () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == Chronology . getISO () . minutes () . hashCode () ) ;
assertEquals ( false , iField . equals ( Chronology . getISO () . minutes () ) ) ;
int [] actual = NullConverter.INSTANCE . getPartialValues ( tod , null , Chronology . getISO () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
int [] actual = StringConverter.INSTANCE . getPartialValues ( tod , STRING_CONSTANT , Chronology . getISO () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( new Interval ( TEST_TIME1 , TEST_TIME2 , Chronology . getISO () ) , test ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
try { type . getField ( Chronology . getCopticUTC () ) ; fail () ; } catch ( InternalError ex ) {}
assertEquals ( - NUMBER_CONSTANT , MillisDurationField.INSTANCE . compareTo ( Chronology . getISO () . seconds () ) ) ;
Period test = new Period ( length , PeriodType . standard () , Chronology . getISOUTC () ) ;
Period test = new Period ( length , PeriodType . time () . withMillisRemoved () , Chronology . getISO () ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( Chronology . getISO () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == Chronology . getISO () . minutes () . hashCode () ) ;
assertEquals ( false , iField . equals ( Chronology . getISO () . minutes () ) ) ;
{ FieldUtils . verifyValueBounds ( Chronology . getISO () . monthOfYear () , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail () ; }
actual = ReadablePartialConverter.INSTANCE . getPartialValues ( tod , new TimeOfDay ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , Chronology . getISO ( PARIS ) )
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , Chronology . getISOUTC () ) ;
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , Chronology . getISO () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . standard () , Chronology . getISOUTC () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . time () . withMillisRemoved () , Chronology . getISO () ) ;
try { type . getField ( Chronology . getCopticUTC () ) ; fail () ; } catch ( InternalError ex ) {}
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
{ super ( Chronology . getISO ( zone ) ) ; }
{ super ( Chronology . getISO ( zone ) ) ; }
public Chronology getChronology () { return Chronology . getISOUTC () ; }
iMillis = converter . getInstantMillis ( instant , Chronology . getISOUTC () ) ;
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = Chronology . getISO () ; }
{ return Chronology . getISO ( zone ) ; }
this . iZone = zone ;
this . iZone = zone ;
{ newValues = getField ( index ) . addWrapPartial ( this , index , newValues , FieldUtils . safeMultiplyToInt ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiplyToInt ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiplyToInt ( period . getValue ( i ) , scalar ) ) ; }
if ( dt == null ) { System.out . println ( STRING_CONSTANT ) ; }
if ( dt == null ) { System.out . println ( STRING_CONSTANT ) ; }
cal . setTime ( toDate () ) ;
cal . setTime ( toDate () ) ;
{ out . write ( print ( instant , displayZone , locale ) ) ; }
{ buf . append ( print ( instant , displayZone , locale ) ) ; }
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
{ return ChronologyType . iso () . getChronology ( zone ) ; }
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
public Chronology getChronology () { return ChronologyType . iso () . getChronologyUTC () ; }
iMillis = converter . getInstantMillis ( instant , ChronologyType . iso () . getChronologyUTC () ) ;
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = ChronologyType . iso () . getChronology () ; }
{ return ChronologyType . iso () . getChronology ( zone ) ; }
return NUMBER_CONSTANT ;
return NUMBER_CONSTANT ;
FieldUtils . verifyValueBounds ( this , month , MIN , MAX ) ;
long difference = ( minuendYear - subtrahendYear ) * NUMBER_CONSTANT + minuendMonth - subtrahendMonth ;
{ return set ( instant , FieldUtils . getWrappedValue ( get ( instant ) , months , MIN , MAX ) ) ; }
assertEquals ( true , CopticChronology . getInstanceUTC () . months () . isPrecise () ) ;
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * DateTimeConstants.MILLIS_PER_DAY ; return new TestSuite ( TestCopticChronology . class ) ; }
assertEquals ( true , EthiopicChronology . getInstanceUTC () . months () . isPrecise () ) ;
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * DateTimeConstants.MILLIS_PER_DAY ; return new TestSuite ( TestEthiopicChronology . class ) ; }
fields.monthOfYear = new BasicMonthOfYearDateTimeField ( this , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
fields.monthOfYear = new IslamicMonthOfYearDateTimeField ( this ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
assertEquals ( cal . get ( Calendar.HOUR_OF_DAY ) , test . getHourOfDay () ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
BaseGJChronology chronology
BaseGJChronology chronology
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( DateTimeFieldType . era () ) ; iChronology = chronology ; }
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
GJMonthOfYearDateTimeField ( BaseGJChronology chronology ) { super ( chronology , NUMBER_CONSTANT ) ; }
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
{ int len = parser . estimateParsedLength () ; if ( len > est ) { len = est ; } }
long instant = chronology . getDateTimeMillis ( hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
LocalTime test = LocalTime . forInstant ( ( Object ) null , JULIAN ) ;
LocalTime test = LocalTime . forInstant ( date , JULIAN ) ;
LocalTime test = LocalTime . forInstant ( TEST_TIME2 , JULIAN ) ;
LocalTime test = LocalTime . now ( JULIAN ) ;
LocalTime test = LocalTime . fromMillisOfDay ( TEST_TIME1 , JULIAN ) ;
assertEquals ( true , test . isSupported ( DurationFieldType . eras () ) ) ;
DateMidnight test = base . toDateMidnightDefaultZone () ;
DateTime test = base . toDateTimeAtCurrentTimeDefaultZone () ;
DateTime test = base . toDateTimeAtMidnightDefaultZone () ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . nowDefaultZone () ;
LocalDate test = LocalDate . nowDefaultZone () ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
public void testSize () { LocalDate test = LocalDate . nowDefaultZone () ; assertEquals ( NUMBER_CONSTANT , test . size () ) ; }
LocalDate test = LocalDate . nowDefaultZone () ;
DateTime test = base . toDateTimeTodayDefaultZone () ;
long getApproxMillisAtEpoch () { return - MILLIS_YEAR_1 ; }
public long computeMillis () { return computeMillis ( false ) ; }
long millis = bucket . computeMillis ( true ) ;
long millis = bucket . computeMillis ( true ) ;
{ if ( newPos >= text . length () ) { return bucket . computeMillis ( true ) ; } }
instant . setMillis ( bucket . computeMillis () ) ;
test = new DateMidnight ( TEST_TIME1_UTC , GregorianChronology . getInstance ( PARIS ) ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( false , test1 . equals ( new DateMidnight ( TEST_TIME1_UTC , GregorianChronology . getInstance () ) ) ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
test = new DateTime ( TEST_TIME1 , GregorianChronology . getInstance ( PARIS ) ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
long millis = converter . getInstantMillis ( instant , chronology ) ;
long millis = converter . getInstantMillis ( instant , chronology ) ;
long millis = converter . getInstantMillis ( instant , chronology ) ;
long millis = converter . getInstantMillis ( instant , chronology ) ;
{ super ( instant , DateTimeUtils . getChronology ( chronology ) ) ; }
{ super ( instant , null ) ; }
int index = dateStyle * NUMBER_CONSTANT + timeStyle ;
LocalTime copy = test . millisOfSecond () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . secondOfMinute () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . minuteOfHour () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . hourOfDay () . withValue ( STRING_CONSTANT ) ;
public LocalDate withMinimumValue () { return withValue ( getMinimumValue () ) ; }
{ return withValue ( getMaximumValue () ) ; }
public LocalDateTime withMinimumValue () { return withValue ( getMinimumValue () ) ; }
{ return withValue ( getMaximumValue () ) ; }
LocalDateTime copy = test . millisOfSecond () . withValue ( STRING_CONSTANT ) ;
LocalDateTime copy = test . secondOfMinute () . withValue ( STRING_CONSTANT ) ;
LocalDateTime copy = test . minuteOfHour () . withValue ( STRING_CONSTANT ) ;
LocalDateTime copy = test . hourOfDay () . withValue ( STRING_CONSTANT ) ;
public LocalTime withMinimumValue () { return withValue ( getMinimumValue () ) ; }
public LocalTime withMaximumValue () { return withValue ( getMaximumValue () ) ; }
assertEquals ( true , interval33 . contains ( new Instant ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( true , interval33 . containsNow () ) ;
assertEquals ( true , interval33 . contains ( NUMBER_CONSTANT ) ) ;
return ( getChronology () == other . getChronology () ) ;
public synchronized Set getAvailableIDs () { return Collections . unmodifiableSet ( iZoneInfoMap . keySet () ) ; }
if ( value >= min && value < getMaximumValue ( instant ) ) { return super . set ( instant , value ) ; }
DateTimeZone tz = builder . toDateTimeZone ( STRING_CONSTANT ) ;
builder . writeTo ( out ) ;
super ( createMessage ( fieldName , value , lowerBound , upperBound ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound ) ) ;
try { test . minusYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { test . plusYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { test . withYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
{ checkPrinter () ; printTo ( out , instant , null ) ; }
{ checkPrinter () ; printTo ( buf , instant , null ) ; }
DateTime now = new DateTime () ;
offsetLocal < NUMBER_CONSTANT
{ t = new DateTimeFormatterBuilder () . append ( hourMinuteSecondMillis () ) . append ( offsetElement () ) . toFormatter () ; }
DateTime start = base . toDateTimeAtMidnight ( LONDON ) ;
DateTime start = base . toDateTimeAtMidnight ( TOKYO ) ;
DateTime start = base . toDateTimeAtMidnight () ;
String [] [] zoneStrings = new DateFormatSymbols ( locale ) . getZoneStrings () ;
DateFormatSymbols dfs = new DateFormatSymbols ( locale ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + id ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + id ) ;
{ Hibernate.DATE . nullSafeSet ( preparedStatement , ( ( LocalDate ) value ) . toDateMidnight () . toDate () , index ) ; }
f = ( DateTimeFormatter ) cCache . get ( key ) ;
formatter = ( DateTimeFormatter ) cPatternedCache . get ( pattern ) ;
Object durationField
public int compareTo ( Object durationField ) { return iField . compareTo ( durationField ) ; }
List list
List elementPairs
List elementPairs
List pairs = iElementPairs ;
if ( iElementPairs == null ) { iElementPairs = new ArrayList () ; } else { iElementPairs . clear () ; }
Collection fields
Collection fields
Collection fields
Collection fields
Collection fields
List list
public DateTimeFormatterBuilder () { super(); iElementPairs = new ArrayList () ; }
chrono = ( ISOChronology ) cCache . get ( zone ) ;
Object partial
HashMap converted
HashMap converted
iRules = new ArrayList ( rs.iRules ) ;
RuleSet () { iRules = new ArrayList ( NUMBER_CONSTANT ) ; iUpperYear = Integer.MAX_VALUE ; }
TreeMap map
TreeMap map
symbols = ( GJLocaleSymbols ) cCache . get ( locale ) ;
Object partial
Map ruleSets
{ iRules = new ArrayList () ; iRules . add ( rule ) ; }
Object readableInstant
Map zimap
iZoneInfoMap . put ( id , new SoftReference ( tz ) ) ;
public int compareTo ( Object durationField ) { return NUMBER_CONSTANT ; }
Object partial
HashMap converted
HashMap converted
Class type
Class type
Object obj
try { Single . between ( start , new TimeOfDay () , zero ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
{ if ( ldp == null ) { ldp = dateElementParser () . withZone ( DateTimeZone.UTC ) ; } return ldp ; }
assertEquals ( STRING_CONSTANT , f . withZone ( UTC ) . print ( dt ) ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.KOREAN ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withPivotYear ( NUMBER_CONSTANT ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withPivotYear ( NUMBER_CONSTANT ) . withZone ( DateTimeZone.UTC ) ;
{ if ( value == null ) return null ; return new Instant ( value ) ; }
{ return ( int [] ) iValues . clone () ; }
{ return ( int [] ) iValues . clone () ; }
Locale . setDefault ( Locale.UK ) ;
java.util.TimeZone . setDefault ( LONDON . toTimeZone () ) ;
Locale . setDefault ( Locale.UK ) ;
Locale . setDefault ( Locale.ENGLISH ) ;
Locale . setDefault ( Locale.UK ) ;
java.util.TimeZone . setDefault ( LONDON . toTimeZone () ) ;
Locale . setDefault ( Locale.UK ) ;
{ locale = Locale . getDefault () ; zone = DateTimeZone . getDefault () ; Locale . setDefault ( Locale.UK ) ; }
Locale . setDefault ( Locale.UK ) ;
public YearMonth getYearMonth () { return iYearMonth ; }
protected ReadablePartial getReadablePartial () { return iYearMonth ; }
public DateTimeField getField () { return iYearMonth . getField ( iFieldIndex ) ; }
{ super(); iYearMonth = partial ; iFieldIndex = fieldIndex ; }
Map < String , Object > map = new TreeMap < String , Object > ( String.CASE_INSENSITIVE_ORDER ) ;
DateTimeZone . setDefault ( LONDON ) ;
return iZone . convertLocalToUTC ( localInstant , false ) ;
return iZone . convertLocalToUTC ( localInstant , false ) ;
return iZone . convertLocalToUTC ( localInstant , false ) ;
long result = iZone . convertLocalToUTC ( localInstant , false ) ;
return iZone . convertLocalToUTC ( localInstant , false ) ;
return iZone . convertLocalToUTC ( localInstant , false ) ;
return iZone . convertLocalToUTC ( localInstant , false ) ;
return iBase . getZone () . convertLocalToUTC ( localInstant , false ) ;
{ super ( duration , null , null ) ; }
{ super ( duration , null , null ) ; }
Object timestamp = Hibernate.TIMESTAMP . nullSafeGet ( resultSet , string ) ;
Object date = Hibernate.TIME . nullSafeGet ( resultSet , string ) ;
Object date = Hibernate.DATE . nullSafeGet ( resultSet , string ) ;
Object timestamp = Hibernate.TIME . nullSafeGet ( resultSet , string ) ;
Object timestamp = Hibernate.DATE . nullSafeGet ( resultSet , string ) ;
Object timestamp = Hibernate.INTEGER . nullSafeGet ( resultSet , string ) ;
Object timestamp = Hibernate.TIMESTAMP . nullSafeGet ( resultSet , string ) ;
Object timestamp = Hibernate.STRING . nullSafeGet ( resultSet , string ) ;
String s = ( String ) Hibernate.STRING . nullSafeGet ( resultSet , strings [ NUMBER_CONSTANT ] ) ;
Object value = Hibernate.TIMESTAMP . nullSafeGet ( resultSet , name ) ;
Object value = Hibernate.LONG . nullSafeGet ( resultSet , name ) ;
{ if ( period != null ) { iValues = addPeriodInto ( getValues () , period ) ; } }
{ if ( period != null ) { iValues = mergePeriodInto ( getValues () , period ) ; } }
iValues = newValues ;
{ integers [ i ] = new Integer ( i ) ; }
array = new Object [] { validValues , new Integer ( maxLength ) } ;
{ return withPivotYear ( new Integer ( pivotYear ) ) ; }
array = new Object [] { validValues , new Integer ( maxLength ) } ;
{ return withPivotYear ( new Integer ( pivotYear ) ) ; }
DateTimeFormatter printer = ISODateTimeFormat . dateHourMinuteSecondFraction () ;
protected void setUp ( ) throws Exception { originalLocale = Locale . getDefault () ; Locale . setDefault ( Locale.UK ) ; }
convId = zone . getDisplayName () ;
catch ( ArrayIndexOutOfBoundsException e ) { throw new IOException ( STRING_CONSTANT ) ; }
try { readZoneInfoMap ( din , map ) ; } finally { try { din . close () ; } catch ( IOException e ) {} }
StringBuffer msg = new StringBuffer () ;
StringBuffer sb = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer () ;
if ( tokenLen >= NUMBER_CONSTANT ) { builder . appendTimeZoneName () ; } else { builder . appendTimeZoneShortName () ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . startsWith ( STRING_CONSTANT ) ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . startsWith ( STRING_CONSTANT ) ) ; }
try { localDateTime . toDateTime ( this ) ; return false ; } catch ( IllegalArgumentException ex ) { return true ; }
throw new IllegalArgumentException ( message ) ;
{ if ( divisor == NUMBER_CONSTANT ) return this ; return new Duration ( FieldUtils . safeDivide ( getMillis () , divisor ) ) ; }
{ if ( multiplicand == NUMBER_CONSTANT ) return this ; return new Duration ( FieldUtils . safeMultiply ( getMillis () , multiplicand ) ) ; }
{ appendable . append ( print ( instant ) ) ; }
DateTimePrinter [] elements = iPrinters ;
DateTimePrinter [] elements = iPrinters ;
{ printTo ( appendable , null , instant , chrono ) ; }
f instanceof DateTimePrinter
DateTimePrinter printer
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( printer , parser ) ; }
{ checkPrinter ( printer ) ; return append0 ( printer , null ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter () , formatter . getParser () ) ; }
{ DateTimePrinter p = getFormatter ( locale ) . getPrinter () ; p . printTo ( appendable , partial , locale ) ; }
DateTimePrinter p = getFormatter ( locale ) . getPrinter () ;
return ( ( StyleFormatter ) formatter . getPrinter () ) . getPattern ( locale ) ;
f2 = new DateTimeFormatter ( null , f . getParser () ) ;
DateTimePrinter printer = requirePrinter () ;
DateTimePrinter printer = requirePrinter () ;
{ printTo ( out , instant , null ) ; }
DateTimePrinter printer
catch ( IllegalArgumentException ex ) {}
{ return computeMillis ( resetFields , null ) ; }
{ return computeMillis ( false , null ) ; }
{ saveField ( new SavedField ( fieldType . getField ( iChrono ) , value ) ) ; }
{ saveField ( new SavedField ( field , value ) ) ; }
String text
String text
String text
String text
f instanceof DateTimeParser
DateTimeParser parser
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , parser ) ; }
{ checkParser ( parser ) ; return append0 ( null , parser ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter0 () , formatter . getParser () ) ; }
{ reset () ; return doParseMillis ( parser , text ) ; }
f2 = new DateTimeFormatter ( ( InternalPrinter ) null , f . getParser () ) ;
DateTimeParser parser = requireParser () ;
DateTimeParser parser = requireParser () ;
DateTimeParser parser = requireParser () ;
DateTimeParser parser = requireParser () ;
DateTimeParser parser = requireParser () ;
public DateTimeParser getParser () { return iParser ; }
DateTimeParser parser
DateTimeParser parser
{ this ( DateTimePrinterInternalPrinter . of ( printer ) , parser ) ; }
iMillis = FieldUtils . safeAdd ( endMillis , - startMillis ) ;
{ super(); iMillis = FieldUtils . safeAdd ( endInstant , - startInstant ) ; }
try { builder . appendSuffix ( null , null ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { builder . appendPrefix ( null , null ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
iSuffixes = texts ;
new PeriodFormatterBuilder () . appendDays () . appendSuffix ( STRING_CONSTANT ) . appendSuffix ( STRING_CONSTANT , STRING_CONSTANT )
new PeriodFormatterBuilder () . appendPrefix ( STRING_CONSTANT ) . appendPrefix ( STRING_CONSTANT , STRING_CONSTANT )
if ( periodStr . regionMatches ( true , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
if ( periodStr . regionMatches ( false , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
synchronized ( DateTimeZone . class ) { cDefault = zone ; }
{ return new TreeSet < String > ( iZoneInfoMap . keySet () ) ; }
public Set < String > getAvailableIDs () { return Collections . singleton ( STRING_CONSTANT ) ; }
public static Set < String > getAvailableIDs () { return cAvailableIDs ; }
DateTimeZone zone = cProvider . getZone ( id ) ;
assertSame ( zone , result ) ;
int curMonth0 = partial . getValue ( NUMBER_CONSTANT ) - NUMBER_CONSTANT ;
if ( ZoneInfoCompiler . verbose () ) { System.out . println ( STRING_CONSTANT + tz . getID () ) ; }
cVerbose . set ( verbose ) ;
Interval interval = new Interval ( start , end ) ;
int compare = csCompare ( value , text , position ) ;
{ return FieldUtils . safeAdd ( getEndMillis () , - getStartMillis () ) ; }
{ millis = iField . set ( millis , iValue ) ; }
str = str . toLowerCase () ;
DateTimeFormatter fmt = DateTimeFormat . forPattern ( STRING_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , str ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
{ Provider provider = new ZoneInfoProvider ( STRING_CONSTANT ) ; return validateProvider ( provider ) ; }
{ return getCumPct ( new Character ( v ) ) ; }
{ return getCumFreq ( new Character ( v ) ) ; }
{ return getPct ( new Character ( v ) ) ; }
{ return getCount ( new Character ( v ) ) ; }
public IntegratorException ( Throwable cause ) { super ( cause ) ; }
double initialStepSize
SecondOrderDifferentialEquations equations
public DerivativeException ( Throwable cause ) { super ( cause ) ; }
{ super ( c , a , b , new EulerStepInterpolator () , step ) ; }
super ( minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
{ super ( c , a , b , new GillStepInterpolator () , step ) ; }
{ super ( c , a , b , new ClassicalRungeKuttaStepInterpolator () , step ) ; }
{ super ( c , a , b , new MidpointStepInterpolator () , step ) ; }
{ super ( c , a , b , new ThreeEighthesStepInterpolator () , step ) ; }
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new VariableHandler () ) ;
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new VariableHandler () ) ;
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
handler = DummyStepHandler . getInstance () ;
integ . setStepHandler ( new VariableStepHandler () ) ;
integ . setStepHandler ( new KeplerStepHandler ( pb ) ) ;
integrator . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new KeplerStepHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( cm ) ;
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
FirstOrderIntegrator integrator
regression . addData ( y , x , omega ) ;
regression . addData ( y , x , omega ) ;
CombinedEventsManager manager = addEndTimeChecker ( t , eventsHandlersManager ) ;
CombinedEventsManager manager = addEndTimeChecker ( t , eventsHandlersManager ) ;
{ maxValueError = NUMBER_CONSTANT ; maxTimeError = NUMBER_CONSTANT ; lastError = NUMBER_CONSTANT ; expectedStepStart = problem . getInitialTime () ; }
ComplexFormat cf = new ComplexFormat () ;
ComplexFormat cf = ComplexFormat . getInstance ( getLocale () ) ;
stepSize = step ;
this . step = step ;
stepSize = step ;
this . step = step ;
this . step = step ;
{ if ( qr == null ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ System . arraycopy ( b [ i ] , NUMBER_CONSTANT , root . getDataRef () [ swap [ i ] ] , NUMBER_CONSTANT , rank ) ; }
{ new QRDecompositionImpl () . isFullRank () ; fail ( STRING_CONSTANT ) ; }
if ( ! isFullRank () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! isFullRank () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
cachedQ == null
RealMatrix sse = u . transpose () . multiply ( Omega . inverse () ) . multiply ( u ) ;
{ RealMatrix XTX = X . transpose () . multiply ( X ) ; return XTX . inverse () ; }
catch ( IndexOutOfBoundsException e ) { throw new MatrixIndexException ( e . getMessage () ) ; }
if ( singular ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( singular ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( singular ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! matrix . isSquare () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! isSquare () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! matrix . isSquare () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! isNonSingular () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! isNonSingular () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
MatrixIndexException ex = new MatrixIndexException ( msg ) ;
throw new RuntimeException ( STRING_CONSTANT ) ;
catch ( Exception e ) { throw new RuntimeException ( e . getMessage () ) ; }
{ return ( Object [] ) arguments . clone () ; }
{ super(); this . pattern = null ; this . arguments = new Object [ NUMBER_CONSTANT ] ; }
{ return ( Object [] ) arguments . clone () ; }
assertNull ( ex . getMessage ( Locale.FRENCH ) ) ;
{ throw new InvalidMatrixException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
assertNull ( ex . getMessage ( Locale.FRENCH ) ) ;
InvalidMatrixException ex = new InvalidMatrixException ( msg , new Object [ NUMBER_CONSTANT ] ) ;
MatrixIndexException ex = new MatrixIndexException ( msg , new Object [ NUMBER_CONSTANT ] ) ;
if ( norm == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( o == null ) { throw new MathException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( s == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
throw new MathRuntimeException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ;
public Double getZ () { throw new MathRuntimeException () ; }
{ super(); this . pattern = null ; this . arguments = null ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
catch ( Exception e ) { throw new IOException ( e . getMessage () ) ; }
catch ( Exception e ) { throw new IOException ( e . getMessage () ) ; }
catch ( Exception e ) { throw new IOException ( e . getMessage () ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
catch ( IOException ioe ) { assertNull ( ioe . getMessage () ) ; }
catch ( IOException ioe ) { assertNull ( ioe . getMessage () ) ; }
{ if ( resultComputed ) { return iterationCount ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( resultComputed ) { return result ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( lu == null ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( resultComputed ) { return iterationCount ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( resultComputed ) { return result ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( qrt == null ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
if ( ! loaded ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , vTv . subtract ( id ) . getNorm () , normTolerance ) ;
assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
{ assertEquals ( refValues [ i ] , eigenValues [ eigenValues.length - NUMBER_CONSTANT - i ] , NUMBER_CONSTANT ) ; }
orthoTridiag = null ;
public int [] getPivot ( ) throws IllegalStateException { checkDecomposed () ; return pivot . clone () ; }
public double getNorm ( ) throws InvalidMatrixException { checkDecomposed () ; return singularValues [ NUMBER_CONSTANT ] ; }
public double [] getSingularValues ( ) throws InvalidMatrixException { checkDecomposed () ; return singularValues . clone () ; }
lu = null ;
lu = null ;
{ copyIn ( d ) ; lu = null ; }
lu = null ;
{ checkDecomposed () ; return eigenvalues [ i ] ; }
public double [] getEigenvalues ( ) throws InvalidMatrixException { checkDecomposed () ; return eigenvalues . clone () ; }
EigenDecomposition ed = new EigenDecompositionImpl ( distinct ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( repeated ) ;
RealMatrix v = new EigenDecompositionImpl ( matrix ) . getV () ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
ds = null ;
ds = null ;
{ copyIn ( d ) ; ds = null ; }
ds = null ;
EigenDecomposition ed = new DecompositionSolver ( distinct ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( repeated ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( m ) . eigenDecompose () ;
RealMatrix v = new DecompositionSolver ( matrix ) . eigenDecompose () . getV () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
public DescriptiveStatistics ( int window ) { super(); setWindowSize ( window ) ; }
{ return stat . evaluate ( eDA . getValues () , eDA . start () , eDA . getNumElements () ) ; }
double [] [] in
RealVectorImpl v
double [] v
RealMatrixImpl m
RealMatrixImpl m
RealMatrixImpl m
double [] v
UnivariateRealSolver solver = factory . newSecantSolver ( function ) ;
UnivariateRealSolver solver = factory . newBrentSolver ( function ) ;
UnivariateRealSolver solver = factory . newNewtonSolver ( function ) ;
UnivariateRealSolver solver = factory . newBisectionSolver ( function ) ;
{ setup ( f ) ; return factory . newDefaultSolver ( f ) . solve ( x0 , x1 ) ; }
try { iterator . next () ; } catch ( ConcurrentModificationException cme ) {}
RealMatrix covRM = new RealMatrixImpl ( cov , false ) ;
{ this . Omega = new RealMatrixImpl ( omega ) ; this . OmegaInverse = null ; }
cachedV = transformer . getV () . multiply ( new RealMatrixImpl ( iData , false ) ) ;
cachedU = transformer . getU () . multiply ( new RealMatrixImpl ( iData , false ) ) ;
RealMatrixImpl matrix = new RealMatrixImpl ( testSquare , false ) ;
return new RealMatrixImpl ( xData , false ) ;
{ this . X = new RealMatrixImpl ( x ) ; }
{ this . Y = new RealMatrixImpl ( y ) ; }
@ Test ( expected = IllegalArgumentException . class )
RealMatrixImpl m_outerProduct = v1 . outerProduct ( v2 ) ;
return new RealMatrixImpl ( dData , false ) ;
return new RealMatrixImpl ( data , false ) ;
{ this . X = new RealMatrixImpl ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
RealMatrixImpl matrix = new RealMatrixImpl ( testData , false ) ;
RealMatrixImpl matrix = new RealMatrixImpl ( testData , false ) ;
RealMatrixImpl matrix = new RealMatrixImpl ( testData , false ) ;
RealMatrixImpl matrix = new RealMatrixImpl ( testData , false ) ;
return new RealMatrixImpl ( bp , false ) ;
return new RealMatrixImpl ( invData , false ) ;
return new RealMatrixImpl ( bp , false ) ;
{ return new RealVectorImpl ( solve ( b . getData () ) , false ) ; }
{ this . decomposition = decomposition ; }
assertTrue ( solver . isNonSingular () ) ;
{ this . Omega = MatrixUtils . createRealMatrix ( omega ) ; this . OmegaInverse = null ; }
{ this . X = MatrixUtils . createRealMatrix ( x ) ; }
{ this . Y = new RealVectorImpl ( y ) ; }
@ Test ( expected = ArrayIndexOutOfBoundsException . class )
{ this . X = new DenseRealMatrix ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
return MatrixUtils . createRealMatrix ( data ) ;
public boolean isSingular ( ) ;
return new RealMatrixImpl ( data , false ) ;
{ this . decomposition = decomposition ; }
{ eigenvectors [ i ] = findEigenvector ( eigenvalues [ i ] , d , l ) ; }
{ eigenvalues [ index ] = main [ index ] ; }
{ if ( eigenvectors == null ) { findEigenVectors () ; } return new Solver ( eigenvalues , eigenvectors ) ; }
{ double determinant = NUMBER_CONSTANT ; for ( double lambda : eigenvalues ) { determinant *= lambda ; } return determinant ; }
{ if ( cachedD == null ) { cachedD = MatrixUtils . createRealDiagonalMatrix ( eigenvalues ) ; } return cachedD ; }
double [] observed = ed . getEigenvalues () ;
double lambda = ed . getEigenvalue ( i ) ;
double [] eigenValues = ed . getEigenvalues () ;
double [] eigenValues = ed . getEigenvalues () ;
double [] eigenValues = ed . getEigenvalues () ;
assertEquals ( NUMBER_CONSTANT , ed . getEigenvalue ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
singularValues = eigenDecomposition . getEigenvalues () ;
{ if ( eigenvectors == null ) { findEigenVectors () ; } return new Solver ( realEigenvalues , eigenvectors ) ; }
if ( n == NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ return fht ( f ) ; }
{ OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap () ; assertEquals ( NUMBER_CONSTANT , map . remove ( NUMBER_CONSTANT ) ) ; }
this . entries = new OpenIntToDoubleHashMap () ;
double previous = NUMBER_CONSTANT ;
values [ index ] = NUMBER_CONSTANT ;
return new LUSolver ( new LUDecompositionImpl ( XTX ) ) . getInverse () ;
assertEquals ( new RealMatrixImpl ( reference ) , new RealMatrixImpl ( sub ) ) ;
assertEquals ( new RealMatrixImpl ( reference ) , new RealMatrixImpl ( sub ) ) ;
RealMatrix m = new RealMatrixImpl ( subTestData ) ;
assertEquals ( new RealMatrixImpl ( reference ) , sub ) ;
assertEquals ( new RealMatrixImpl ( reference ) , sub ) ;
RealMatrix m = new RealMatrixImpl ( subTestData ) ;
rDiag = new double [ n ] ;
return new LUSolver ( new LUDecompositionImpl ( XTOIX ) ) . getInverse () ;
private double getDeterminant ( RealMatrix m ) { return new LUSolver ( new LUDecompositionImpl ( m ) ) . getDeterminant () ; }
{ if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; } }
if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; }
if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; }
if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; }
if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; }
{ clearResult () ; return localmin ( min , max , relativeAccuracy , absoluteAccuracy , f ) ; }
assertEquals ( Float.NaN , MathUtils . sign ( Float.NaN ) , delta ) ;
{ vals [ i ] = values [ i ] ; }
computeOmega ( - f.length ) ;
computeOmega ( - f.length ) ;
computeOmega ( f.length ) ;
{ computeOmega ( f.length ) ; return fft ( f ) ; }
{ set ( index , v.data ) ; }
{ for ( int i = NUMBER_CONSTANT ; i < virtualSize ; i ++ ) { set ( i , value ) ; } }
{ set ( i , Math . log ( getEntry ( i ) ) ) ; }
{ set ( i , Math . log10 ( getEntry ( i ) ) ) ; }
{ set ( i , NUMBER_CONSTANT / getEntry ( i ) ) ; }
{ set ( i , getEntry ( i ) + d ) ; }
{ set ( i , Math . acos ( getEntry ( i ) ) ) ; }
{ res . set ( i + virtualSize , a [ i ] ) ; }
{ RealVector res = new SparseRealVector ( this , NUMBER_CONSTANT ) ; res . set ( virtualSize , d ) ; return res ; }
w . set ( i , w . getEntry ( i ) / si ) ;
assertClose ( STRING_CONSTANT , m3 . multiply ( m4 ) , m5 , entryTolerance ) ;
FunctionEvaluationException ex = new FunctionEvaluationException ( NUMBER_CONSTANT , cause ) ;
FunctionEvaluationException ex = new FunctionEvaluationException ( NUMBER_CONSTANT , pattern , arguments , cause ) ;
{ super ( STRING_CONSTANT , new Object [] { rows , columns } ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
MathException ex = new MathException ( pattern , arguments , cause ) ;
if ( b.length != nRows ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( v.length != nRows ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( ! isSquare () ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
final Object [] arguments
if ( isZero ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( numElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( STRING_CONSTANT , null ) ; }
{ return buildMessage ( pattern , arguments , locale ) ; }
catch ( DerivativeException de ) { throw new MathRuntimeException ( STRING_CONSTANT , null , de ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
catch ( ClassCastException cce ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
ConvergenceException ex = new ConvergenceException ( pattern , arguments , cause ) ;
Object [] parts
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
final Object [] parts
{ throw new InvalidMatrixException ( STRING_CONSTANT , null ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , null ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT + STRING_CONSTANT , null ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ throw new InvalidMatrixException ( STRING_CONSTANT , null ) ; }
MathConfigurationException ex = new MathConfigurationException ( pattern , arguments , cause ) ;
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT , null ) ; }
Object [] arguments
{ super ( isCardan ? STRING_CONSTANT : STRING_CONSTANT , null ) ; }
final Object [] arguments
catch ( DimensionMismatchException dme ) { throw new MathRuntimeException ( STRING_CONSTANT , null , dme ) ; }
final Object [] parts
final Object [] parts
Object [] parts
Object [] arguments
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT , null ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
{ return buildMessage ( pattern , arguments , locale ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } return isForward ; }
Object [] arguments
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
Object [] arguments
public Double getZ () { throw new MathRuntimeException ( STRING_CONSTANT , null ) ; }
MatrixIndexException ex = new MatrixIndexException ( msg , null ) ;
{ throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; }
{ if ( data.length != n ) { throw new IllegalArgumentException ( STRING_CONSTANT + data.length + STRING_CONSTANT + n + STRING_CONSTANT ) ; } }
if ( d.length == NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
while ( iter . hasNext () ) { iter . advance () ; if ( Double . isNaN ( iter . value () ) ) return true ; }
while ( iter . hasNext () ) { iter . advance () ; if ( Double . isInfinite ( iter . value () ) ) return true ; }
if ( delta > max ) max = delta ;
{ virtualSize = values.length ; fromDoubleArray ( values ) ; }
epsilon = DEFAULT_ZERO_TOLERANCE ;
public void setConvergenceChecker ( ConvergenceChecker checker ) { optimizer . setConvergenceChecker ( checker ) ; }
final Optimizer optimizer
final MultiObjectiveFunction function
final MultiObjectiveFunction function
final MultiObjectiveFunction function
final Comparator < PointValuePair > comparator
public void setConvergenceChecker ( ConvergenceChecker checker ) { this . checker = checker ; }
final double residual = objective [ i ] - target [ i ] ;
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , buildArray ( m , factor ) , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , buildChebyquadArray ( n , factor ) , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , buildArray ( n , x0 ) , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; if ( theoreticalStartCost > NUMBER_CONSTANT ) { setCostAccuracy ( NUMBER_CONSTANT ) ; setParamsAccuracy ( NUMBER_CONSTANT ) ; } }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; if ( theoreticalStartCost > NUMBER_CONSTANT ) { setCostAccuracy ( NUMBER_CONSTANT ) ; setParamsAccuracy ( NUMBER_CONSTANT ) ; } }
{ super ( NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , x0 ) , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
{ super ( m , buildArray ( n , x0 ) , theoreticalStartCost , theoreticalMinCost , null ) ; }
optimizer . setMaxEvaluations ( maxCostEval ) ;
incrementJacobianEvaluationsCounter () ;
{ setConvergenceChecker ( new SimpleVectorialValueChecker () ) ; setMaxEvaluations ( DEFAULT_MAX_EVALUATIONS ) ; }
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
{ super ( cause , pattern , arguments ) ; this . argument = argument ; }
{ super ( cause ) ; this . argument = argument ; }
{ super ( pattern , arguments ) ; this . argument = argument ; }
assertEquals ( NUMBER_CONSTANT , ex . getArgument () , NUMBER_CONSTANT ) ;
assertEquals ( Math.PI , ex . getArgument () , NUMBER_CONSTANT ) ;
final VectorialObjectiveFunction function
public void setConvergenceChecker ( ScalarConvergenceChecker checker ) { this . checker = checker ; }
catch ( ObjectiveException oe ) { assertTrue ( exceptionExpected ) ; }
{ if ( numerator == NUMBER_CONSTANT ) { return ZERO ; } return new BigFraction ( numerator , denominator ) . reduce () ; }
public FractionFormat () { this ( getDefaultNumberFormat () ) ; }
{ if ( format == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . wholeFormat = format ; }
{ return subtract ( new BigFraction ( l , NUMBER_CONSTANT ) ) ; }
{ return subtract ( new BigFraction ( i , NUMBER_CONSTANT ) ) ; }
{ return multiply ( new BigFraction ( l , NUMBER_CONSTANT ) ) ; }
{ return multiply ( new BigFraction ( i , NUMBER_CONSTANT ) ) ; }
{ return add ( new BigFraction ( l , NUMBER_CONSTANT ) ) ; }
{ return add ( new BigFraction ( i , NUMBER_CONSTANT ) ) ; }
final ArrayList < Fraction > coefficients
assertEquals ( ci , l40 [ i ] , ci * NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , new BigFraction ( Double.MIN_NORMAL ) . getNumeratorAsLong () ) ;
protected Locale getLocale () { return Locale.US ; }
protected Locale getLocale () { return Locale.US ; }
protected Locale getLocale () { return Locale.FRENCH ; }
protected Locale getLocale () { return Locale.US ; }
protected String getResourceName () { return STRING_CONSTANT ; }
protected String getResourceName () { return STRING_CONSTANT ; }
protected Locale getLocale () { return Locale.FRENCH ; }
protected Locale getLocale () { return Locale.FRENCH ; }
UnivariateRealSolver solver = factory . newDefaultSolver () ;
{ setup ( f ) ; return factory . newDefaultSolver () . solve ( f , x0 , x1 ) ; }
{ logSum += Math . log ( ( double ) i ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return ( RealPointValuePair [] ) optima . clone () ; }
double n = ( double ) length ;
{ return ( Object [] [] ) contents . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return ( RealPointValuePair [] ) optima . clone () ; }
double degreesOfFreedom = ( double ) ( n1 + n2 - NUMBER_CONSTANT ) ;
{ dest.sumOfLogs = ( SumOfLogs ) source.sumOfLogs . copy () ; }
{ return Math . exp ( sumOfLogs . evaluate ( values , begin , length ) / ( double ) length ) ; }
{ return Math . exp ( sumOfLogs . getResult () / ( double ) sumOfLogs . getN () ) ; }
{ return ( StorelessUnivariateStatistic [] ) meanImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) geoMeanImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) sumLogImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) maxImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) minImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) sumSqImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) sumImpl . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return ( VectorialPointValuePair [] ) optima . clone () ; }
double n0 = ( double ) n ;
{ dest.moment = ( FourthMoment ) source.moment . copy () ; dest.incMoment = source.incMoment ; }
double n0 = ( double ) n ;
{ result [ i - NUMBER_CONSTANT ] = ( double ) i * coefficients [ i ] ; }
{ dest.incMoment = source.incMoment ; dest.moment = ( FirstMoment ) source.moment . copy () ; }
double sampleSize = ( double ) length ;
{ return ( sumY - slope * sumX ) / ( ( double ) n ) ; }
Math . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / ( double ) n ) + ( xbar * xbar ) / sumXX ) )
{ if ( n < NUMBER_CONSTANT ) { return Double.NaN ; } return getSumSquaredErrors () / ( double ) ( n - NUMBER_CONSTANT ) ; }
{ dest.moment = ( SecondMoment ) source.moment . copy () ; dest.isBiasCorrected = source.isBiasCorrected ; dest.incMoment = source.incMoment ; }
double len = ( double ) length ;
double n0 = ( double ) n ;
{ return sumDifference ( sample1 , sample2 ) / ( double ) sample1.length ; }
{ return ( NumberTransformer ) map . get ( key ) ; }
{ dest.moment = new ThirdMoment ( ( ThirdMoment ) source.moment . copy () ) ; dest.incMoment = source.incMoment ; }
{ dest.variance = ( Variance ) source.variance . copy () ; }
return sum / ( double ) v.length ;
catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( asBigDecimal ( testVector ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . getTrace () . doubleValue () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) { ; }
catch ( InvalidMatrixException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
{ super ( problem ) ; a = problem.a ; y = ( double [] ) problem.y . clone () ; }
return Math . sqrt ( sum / ( double ) v.length ) ;
{ super ( problem ) ; e = problem.e ; y = ( double [] ) problem.y . clone () ; }
{ super ( problem ) ; y = ( double [] ) problem.y . clone () ; }
{ dY [ i ] = ( double ) y [ i ] ; }
{ dX [ i ] = ( double ) x [ i ] ; }
{ super ( problem ) ; y = ( double [] ) problem.y . clone () ; }
try { randomData . nextExponential ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { randomData . nextSecureInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { randomData . nextSecureLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { randomData . nextLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { randomData . nextInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) { ; }
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
final SimplexTableau tableau = new SimplexTableau ( f , constraints , goalType , restrictToNonNegative ) ;
SimplexTableau tableau = new SimplexTableau ( f , constraints , GoalType.MAXIMIZE , false ) ;
SimplexTableau tableau = new SimplexTableau ( f , constraints , GoalType.MAXIMIZE , false ) ;
{ return ( sumY - slope * sumX ) / ( n ) ; }
Math . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / n ) + ( xbar * xbar ) / sumXX ) )
Math . sqrt ( ( accum - ( Math . pow ( accum2 , NUMBER_CONSTANT ) / ( length ) ) ) / ( length - NUMBER_CONSTANT ) )
double degreesOfFreedom = ( n1 + n2 - NUMBER_CONSTANT ) ;
{ checkSufficientData ( matrix ) ; nObs = matrix . getRowDimension () ; correlationMatrix = computeCorrelation ( matrix ) ; }
{ checkSufficientData ( matrix ) ; n = matrix . getRowDimension () ; covarianceMatrix = computeCovariance ( matrix , biasCorrected ) ; }
catch ( IllegalStateException ex ) { ; }
{ try { vs . getNext () ; fail ( STRING_CONSTANT ) ; } catch ( IllegalStateException ex ) { ; } }
try { testGenerator . nextInt ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { regression . getSlopeConfidenceInterval ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
Iterator it = f . valuesIterator () ;
final T [] out = buildArray ( nCols ) ;
final T [] out = buildArray ( nCols ) ;
final T [] out = buildArray ( nRows ) ;
final T [] out = buildArray ( nRows ) ;
final T [] out = buildArray ( nRows ) ;
final T [] out = buildArray ( nCols ) ;
final T [] [] data = buildArray ( getRowDimension () , getColumnDimension () ) ;
final T [] [] out = buildArray ( nRows , getColumnDimension () ) ;
final T [] out = buildArray ( nCols ) ;
final T [] out = buildArray ( nRows ) ;
data = buildArray ( subMatrix.length , nCols ) ;
final T [] [] outData = buildArray ( nRows , nCols ) ;
final T [] [] outData = buildArray ( rowCount , columnCount ) ;
final T [] [] outData = buildArray ( rowCount , columnCount ) ;
{ return ( FieldVectorImpl < T > ) subtract ( ( T [] ) v.data ) ; }
{ return ( FieldVectorImpl < T > ) add ( ( T [] ) v.data ) ; }
super ( ( Field < T > ) extractField ( v ) ) ;
super ( ( Field < T > ) extractField ( d ) ) ;
{ super ( ( Field < T > ) extractField ( d ) ) ; copyIn ( d ) ; }
nextAction = handler . eventOccurred ( t , y ) ;
{ if ( f == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + n ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + n ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( f == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
return null ;
if ( Double . doubleToLongBits ( test ) != Double . doubleToLongBits ( iter . value () ) ) { return false ; }
double [] hatResiduals = I . subtract ( hat ) . multiply ( model.Y ) . getColumn ( NUMBER_CONSTANT ) ;
if ( mean.length != standardDeviation.length ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( x0 > x1 ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
checkColumnIndex ( col ) ;
checkColumnIndex ( col ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
checkMultiplicationCompatible ( m ) ;
checkMultiplicationCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + p ) ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + p ) ; }
if ( r < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
throw new IllegalArgumentException ( STRING_CONSTANT ) ;
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( trials < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } numberOfTrials = trials ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( x0 > x1 ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( x0 > x1 ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } }
{ this . Y = new RealMatrixImpl ( y ) ; }
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkMultiplicationCompatible ( m ) ;
checkSubtractionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . degreesOfFreedom = degreesOfFreedom ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( mean <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . mean = mean ; }
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkColumnIndex ( column ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkSubMatrixIndex ( selectedRows , selectedColumns ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( selectedRows , selectedColumns ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkMultiplicationCompatible ( m ) ;
checkSubtractionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw new IllegalArgumentException () ; }
{ if ( values == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
catch ( ClassCastException ex ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( size < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } sampleSize = size ; }
{ if ( size <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } populationSize = size ; }
{ if ( num < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } numberOfSuccesses = num ; }
throw new IllegalArgumentException ( STRING_CONSTANT ) ;
{ if ( beta <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . alpha = alpha ; }
{ if ( values == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( sd <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } standardDeviation = sd ; }
if ( n < NUMBER_CONSTANT || n != sample2.length ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( mean < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( sigma <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( len <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( len <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( s <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } scale = s ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . alpha = alpha ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( successes < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } numberOfSuccesses = successes ; }
{ if ( realFormat == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . realFormat = realFormat ; }
{ if ( imaginaryFormat == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . imaginaryFormat = imaginaryFormat ; }
if ( imaginaryCharacter == null || imaginaryCharacter . length () == NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkColumnIndex ( column ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkSubMatrixIndex ( row , endRow , column , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkMultiplicationCompatible ( m ) ;
checkMultiplicationCompatible ( m ) ;
checkSubtractionCompatible ( m ) ;
checkSubtractionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + alpha ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + alpha ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + alpha ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + alpha ) ; }
Object obj1 = null ;
SparseRealVector v1 = new SparseRealVector ( vec1 ) ;
return new SparseRealVector ( out ) ;
{ Assert . assertEquals ( expected [ i ] , observed [ i ] , tolerance ) ; }
final int dimension = currentState.length ;
final int dimension = currentState.length ;
final MultistepStepInterpolator prototype
equations . computeDerivatives ( t0 + h , y1 , yDot1 ) ;
equations = null ;
equations = null ;
{ super(); yDotK = null ; equations = null ; }
interpolator . reinitialize ( new DummyEquations () , y , yDot , true ) ;
interpolator . reinitialize ( new DummyEquations () , y , yDot , true ) ;
interpolator . reinitialize ( new DummyEquations () , y , yDot , true ) ;
RealMatrix outMatrix = new DenseRealMatrix ( nVars , nVars ) ;
{ return computeCorrelationMatrix ( new DenseRealMatrix ( data ) ) ; }
RealMatrix outMatrix = new DenseRealMatrix ( nVars , nVars ) ;
return new DenseRealMatrix ( out ) ;
return new DenseRealMatrix ( out ) ;
{ this ( new DenseRealMatrix ( data ) ) ; }
assertClose ( STRING_CONSTANT , m . multiply ( new DenseRealMatrix ( testDataInv ) ) , identity , entryTolerance ) ;
RealMatrix mA = new DenseRealMatrix ( a ) ;
assertEquals ( MatrixUtils . createColumnRealMatrix ( col ) , new DenseRealMatrix ( colMatrix ) ) ;
assertEquals ( MatrixUtils . createRowRealMatrix ( row ) , new DenseRealMatrix ( rowMatrix ) ) ;
assertEquals ( new DenseRealMatrix ( testData ) , MatrixUtils . createRealMatrix ( testData ) ) ;
{ return computeCovarianceMatrix ( new DenseRealMatrix ( data ) , biasCorrected ) ; }
RealMatrix outMatrix = new DenseRealMatrix ( dimension , dimension ) ;
{ this ( new DenseRealMatrix ( data ) , biasCorrected ) ; }
{ this . factors = new DenseRealMatrix ( factors ) ; this . target = target ; }
{ DenseRealMatrix m = new DenseRealMatrix ( testData ) ; assertEquals ( m , TestUtils . serializeAndRecover ( m ) ) ; }
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
assertEquals ( new DenseRealMatrix ( reference ) , new DenseRealMatrix ( sub ) ) ;
assertEquals ( new DenseRealMatrix ( reference ) , new DenseRealMatrix ( sub ) ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
assertEquals ( new DenseRealMatrix ( reference ) , sub ) ;
assertEquals ( new DenseRealMatrix ( reference ) , sub ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( testData ) ;
RealMatrix m = new DenseRealMatrix ( testData ) ;
RealMatrix m = new DenseRealMatrix ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return computeCorrelationMatrix ( new DenseRealMatrix ( data ) ) ; }
{ this . factors = new DenseRealMatrix ( factors ) ; this . target = target ; }
RealMatrix result = new DenseRealMatrix ( dimension , dimension ) ;
return new DenseRealMatrix ( matrixData ) ;
{ this . factors = new DenseRealMatrix ( factors ) ; this . target = target ; }
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
assertEquals ( new DenseFieldMatrix < Fraction > ( reference ) , sub ) ;
assertEquals ( new DenseFieldMatrix < Fraction > ( reference ) , sub ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( testData ) ;
decompMatrix = new RealMatrixImpl ( decomp ) ;
return new FieldMatrixImpl < Fraction > ( out ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
return new FieldVectorImpl < Fraction > ( data , false ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
assertEquals ( new FieldMatrixImpl < Fraction > ( reference ) , sub ) ;
assertEquals ( new FieldMatrixImpl < Fraction > ( reference ) , sub ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( testData ) ;
FieldMatrix < T > identity = new FieldMatrixImpl < T > ( field , m , m ) ;
return new FieldMatrixImpl < T > ( bp , false ) ;
cachedP = new FieldMatrixImpl < T > ( field , m , m ) ;
cachedU = new FieldMatrixImpl < T > ( field , m , m ) ;
cachedL = new FieldMatrixImpl < T > ( field , m , m ) ;
return new RealMatrixImpl ( bp , false ) ;
{ this ( new RealVectorImpl ( coefficients ) , constantTerm ) ; }
FieldMatrix < Fraction > matrix = new FieldMatrixImpl < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new FieldMatrixImpl < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new FieldMatrixImpl < Fraction > ( testData ) ;
final RealMatrix matrix = new RealMatrixImpl ( data , false ) ;
final RealVector vector = new RealVectorImpl ( data , false ) ;
RealMatrix getConvertedMatrix () { return new RealMatrixImpl ( data , false ) ; }
RealMatrix getConvertedMatrix () { return new RealMatrixImpl ( data , false ) ; }
{ return new FieldVectorImpl < T > ( data , true ) ; }
{ return new RealVectorImpl ( data , true ) ; }
return new FieldMatrixImpl < T > ( d , false ) ;
new FieldMatrixImpl < T > ( data )
new FieldMatrixImpl < T > ( field , rows , columns )
this . coefficients = new RealVectorImpl ( sub , false ) ;
{ this ( new RealVectorImpl ( coefficients ) , relationship , value ) ; }
this . tableau = new RealMatrixImpl ( matrix ) ;
this . tableau = new RealMatrixImpl ( createTableau ( goalType == GoalType.MAXIMIZE ) ) ;
return new RealVectorImpl ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new RealVectorImpl ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new RealVectorImpl ( testVector ) ) . getData () , entryTolerance ) ;
{ this . Omega = new RealMatrixImpl ( omega ) ; this . OmegaInverse = null ; }
{ setColumn ( column , ( ( FieldVectorImpl < T > ) vector ) . getDataRef () ) ; }
return new FieldVectorImpl < T > ( outData , false ) ;
{ setRow ( row , ( ( FieldVectorImpl < T > ) vector ) . getDataRef () ) ; }
return new FieldVectorImpl < T > ( outData , false ) ;
nordsieck = new RealMatrixImpl ( nData , false ) ;
{ setColumn ( column , ( ( RealVectorImpl ) vector ) . getDataRef () ) ; }
return new RealVectorImpl ( outData , false ) ;
{ setRow ( row , ( ( RealVectorImpl ) vector ) . getDataRef () ) ; }
return new RealVectorImpl ( outData , false ) ;
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
RealVector lhs = new RealVectorImpl ( numCoefficients ) ;
{ es . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
return new RealMatrixImpl ( x , false ) ;
{ this . X = new RealMatrixImpl ( x ) ; }
{ this . Y = new RealVectorImpl ( y ) ; }
return new FieldVectorImpl < Fraction > ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new FieldVectorImpl < Fraction > ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new FieldVectorImpl < Fraction > ( testVector ) ) . getData () , entryTolerance ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new FieldMatrixImpl < Fraction > ( testDataInv ) ) , identity , entryTolerance ) ;
return new RealVectorImpl ( data , false ) ;
{ m . setColumnVector ( NUMBER_CONSTANT , new RealVectorImpl ( NUMBER_CONSTANT ) ) ; fail ( STRING_CONSTANT ) ; }
TestUtils . assertEquals ( STRING_CONSTANT , m . preMultiply ( new RealVectorImpl ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , testVector , m . operate ( new RealVectorImpl ( testVector ) ) . getData () , entryTolerance ) ;
eigenvectors = new RealVectorImpl [ m ] ;
final RealVectorImpl v = eigenvectors [ i ] ;
final RealVectorImpl v = eigenvectors [ i ] ;
final RealVectorImpl [] eigenvectors
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ return new RealVectorImpl ( getColumn ( column ) , false ) ; }
{ return new RealVectorImpl ( getRow ( row ) , false ) ; }
return new RealMatrixImpl ( matrixData ) ;
RealMatrix repeatedColumns = new RealMatrixImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
return new RealVectorImpl ( x ) ;
{ this . X = new RealMatrixImpl ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
RealMatrixImpl augI = new RealMatrixImpl ( n , n ) ;
return new FieldMatrixImpl < BigFraction > ( pData , false ) ;
FieldMatrix < BigFraction > bigMSupdate = bigMStoN . multiply ( new FieldMatrixImpl < BigFraction > ( shiftedP , false ) ) ;
return coefficients.msToN . multiply ( new RealMatrixImpl ( multistep , false ) ) ;
{ return new FieldVectorImpl < T > ( getColumn ( column ) , false ) ; }
{ return new FieldVectorImpl < T > ( getRow ( row ) , false ) ; }
{ super ( STRING_CONSTANT , new RealVectorImpl ( argument ) ) ; this . argument = argument . clone () ; }
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
return new FieldMatrixImpl < BigFraction > ( pData , false ) ;
FieldMatrix < BigFraction > bigMSupdate = bigMStoN . multiply ( new FieldMatrixImpl < BigFraction > ( shiftedP , false ) ) ;
return coefficients.msToN . multiply ( new RealMatrixImpl ( multistep , false ) ) ;
RealMatrix triangularMatrix = new RealMatrixImpl ( lowerTriangularMatrix ) ;
RealMatrix triangularMatrix = new RealMatrixImpl ( lowerTriangularMatrix ) ;
solver . solve ( new RealMatrixImpl ( m3 ) , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } ) ;
solver . decompose ( new RealMatrixImpl ( m7 ) ) ;
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n , simplex.length ) ; }
{ Arrays . fill ( corrected , NUMBER_CONSTANT ) ; }
f . set ( this , NordsieckTransformer . getInstance ( nSteps ) ) ;
{ super ( STRING_CONSTANT , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
final RealMatrix nordsieck
if ( interpolator.nordsieck != null ) { nordsieck = interpolator.nordsieck . copy () ; }
nordsieck = transformer . initializeHighOrderDerivatives ( scaled , multistep ) ;
! ( original instanceof RandomKey )
TestProblem1 pb2 = ( TestProblem1 ) pb1 . clone () ;
if ( ! ( another instanceof RandomKey ) ) return false ;
v instanceof SparseFieldVector
v instanceof SparseFieldVector
v instanceof SparseFieldVector
v instanceof SparseFieldVector
{ addMeasurement ( new LocalMeasurement ( x , y , w ) ) ; }
{ measurements [ i ] = new MinpackMeasurement ( i ) ; }
Object v
Object v
Object v
final long curN = current . getN () ;
StatisticalSummaryValues observed
StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics . aggregate ( aggregate ) ;
optimizer . setConvergenceChecker ( new SimpleScalarValueChecker ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
optimizer . setConvergenceChecker ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
final DescriptiveStatistics dstat = new DescriptiveStatistics () ;
DescriptiveStatistics stats = new DescriptiveStatistics () ;
DescriptiveStatistics stats = new DescriptiveStatistics () ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
{ super ( m , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
OpenMapRealVector res = ( OpenMapRealVector ) copy () ;
OpenMapRealVector res = ( OpenMapRealVector ) copy () ;
this . constraints = constraints ;
{ super ( STRING_CONSTANT , c , a , b , new ThreeEighthesStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , c , a , b , new GillStepInterpolator () , step ) ; }
return factorials [ n ] ;
public static DummyStepHandler getInstance () { return instance ; }
{ return percentile . evaluate ( values , begin , length , p ) ; }
{ return percentile . evaluate ( values , p ) ; }
{ return min . evaluate ( values , begin , length ) ; }
{ return min . evaluate ( values ) ; }
{ return max . evaluate ( values , begin , length ) ; }
{ return max . evaluate ( values ) ; }
{ return variance . evaluate ( values , mean ) ; }
{ return variance . evaluate ( values , mean , begin , length ) ; }
{ return variance . evaluate ( values , begin , length ) ; }
{ return variance . evaluate ( values ) ; }
{ return geometricMean . evaluate ( values , begin , length ) ; }
{ return geometricMean . evaluate ( values ) ; }
{ return mean . evaluate ( values , begin , length ) ; }
{ return mean . evaluate ( values ) ; }
{ return sumLog . evaluate ( values , begin , length ) ; }
{ return sumLog . evaluate ( values ) ; }
{ return prod . evaluate ( values , begin , length ) ; }
{ return prod . evaluate ( values ) ; }
{ return sumSq . evaluate ( values , begin , length ) ; }
{ return sumSq . evaluate ( values ) ; }
{ return sum . evaluate ( values , begin , length ) ; }
{ return sum . evaluate ( values ) ; }
{ super ( STRING_CONSTANT , c , a , b , new EulerStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , c , a , b , new ClassicalRungeKuttaStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , c , a , b , new MidpointStepInterpolator () , step ) ; }
@ Override public Object [] [] getContents () { return contents . clone () ; }
try { alg = MessageDigest . getInstance ( STRING_CONSTANT ) ; } catch ( NoSuchAlgorithmException ex ) { return null ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . alpha = alpha ; }
final SimplexTableau tableau = new SimplexTableau ( f , constraints , goalType , restrictToNonNegative , epsilon ) ;
{ return row * columnDimension + column ; }
@ Override public int getRowDimension () { return rowDimension ; }
@ Override public int getColumnDimension () { return columnDimension ; }
{ final double residual = residuals [ i ] ; chiSquare += residual * residual / weights [ i ] ; }
{ final double residual = residuals [ i ] ; criterion += weights [ i ] * residual * residual ; }
final double factor = - Math . sqrt ( weights [ i ] ) ;
{ return row * columnDimension + column ; }
@ Override public int getRowDimension () { return rowDimension ; }
@ Override public int getColumnDimension () { return columnDimension ; }
catch ( Exception e ) { throw new MathException ( e , STRING_CONSTANT , e . getMessage () ) ; }
public abstract void resetRelativeAccuracy ( ) ;
public abstract double getRelativeAccuracy ( ) ;
public abstract void resetAbsoluteAccuracy ( ) ;
public abstract double getAbsoluteAccuracy ( ) ;
public abstract int getMaximalIterationCount ( ) ;
public UnivariateMatrixFunction derivative ( ) ;
public double getCurrentTime ( ) ;
public double getPreviousTime ( ) ;
public void reset ( ) ;
public UnivariateVectorialFunction derivative ( ) ;
public double getMean ( ) ;
public abstract double getSum ( ) ;
public abstract long getN ( ) ;
public abstract double getMin ( ) ;
public abstract double getMax ( ) ;
public boolean isNaN ( ) ;
public double getExponent ( ) ;
public int getNumberOfElements ( ) ;
public double fitness ( ) ;
public abstract int getSampleSize ( ) ;
public abstract int getPopulationSize ( ) ;
public abstract int getNumberOfSuccesses ( ) ;
public int getDimension ( ) ;
public int getDimension ( ) ;
public UnivariateRealFunction derivative ( ) ;
public abstract long getN ( ) ;
public int getDimension ( ) ;
RandomGenerator generator
public static DummyStepHandler getInstance () { return INSTANCE ; }
{ super(); this . randomData = randomData ; }
{ correction += ( values [ i ] - xbar ) ; }
return ( anovaPValue ( categoryData ) < alpha ) ;
{ checkSignificanceLevel ( alpha ) ; return ( tTest ( sampleStats1 , sampleStats2 ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( homoscedasticTTest ( sample1 , sample2 ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( tTest ( sample1 , sample2 ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( tTest ( mu , sampleStats ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( tTest ( mu , sample ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( pairedTTest ( sample1 , sample2 ) < alpha ) ; }
final boolean forward = ( t > t0 ) ;
final boolean forward = ( t > t0 ) ;
i < this . getRowDimension ()
{ return ( o1 . compareTo ( ( T ) o2 ) ) ; }
return ( stdDev ) ;
double dx = ( x2 - x1 ) ;
return ( super . equals ( stat ) && aggregateStatistics . equals ( stat.aggregateStatistics ) ) ;
{ sum += ( values [ i ] * weights [ i ] ) ; }
public boolean isSquare () { return ( getColumnDimension () == getRowDimension () ) ; }
{ return ( internalArray ) ; }
{ return ( internalArray ) ; }
synchronized int getInternalLength () { return ( internalArray.length ) ; }
final boolean forward = ( t > t0 ) ;
public boolean isSquare () { return ( getColumnDimension () == getRowDimension () ) ; }
{ g0Positive = ( g0 >= NUMBER_CONSTANT ) ; nextAction = EventHandler.CONTINUE ; }
increasing = ( gb >= ga ) ;
{ t0 = tStart ; g0 = handler . g ( tStart , yStart ) ; g0Positive = ( g0 >= NUMBER_CONSTANT ) ; }
return ( stdDev ) ;
return ( isForward ) ? omegaImaginaryForward [ k ] : omegaImaginaryInverse [ k ] ;
isForward = ( n > NUMBER_CONSTANT ) ;
final boolean forward = ( t > t0 ) ;
forward = ( interpolator . getCurrentTime () >= lastTime ) ;
return ( chiSquareTestDataSetsComparison ( observed1 , observed2 ) < alpha ) ;
unequalCounts = ( countSum1 != countSum2 ) ;
return ( chiSquareTest ( counts ) < alpha ) ;
return ( chiSquareTest ( expected , observed ) < alpha ) ;
final boolean forward = ( t > t0 ) ;
Complex N1 = new Complex ( ( n - NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
while ( ! isOptimal ( tableau ) ) { doIteration ( tableau ) ; }
while ( ! isPhase1Solved ( tableau ) ) { doIteration ( tableau ) ; }
Integer pivotRow = getPivotRow ( pivotCol , tableau ) ;
assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
tableau . discardArtificialVariables () ;
assertTrue ( fitResidualSum < noisyResidualSum ) ;
double [] bounds = empiricalDistribution2 . getUpperBounds () ;
{ if ( microsphereElements < NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , microsphereElements ) ; } this . microsphereElements = microsphereElements ; }
{ if ( brightnessExponent < NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , brightnessExponent ) ; } this . brightnessExponent = brightnessExponent ; }
if ( xval.length == NUMBER_CONSTANT || xval [ NUMBER_CONSTANT ] == null ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
super ( buildMessage ( Locale.US , pattern , arguments ) , rootCause ) ;
super ( buildMessage ( Locale.US , pattern , arguments ) , rootCause ) ;
catch ( Exception e ) { throw new MathRuntimeException ( e ) ; }
Math . sqrt ( NUMBER_CONSTANT * Math.PI * x )
double f = ( PI_2 * x * ( n - x ) ) / n ;
double d = ( x - mu ) ;
flipIfWarranted ( deflatedEnd , NUMBER_CONSTANT )
flipIfWarranted ( n , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n , startConfiguration.length ) ; }
if ( steps [ j ] == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , j , j + NUMBER_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return isForward ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , o.length ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , d.length ) ; } }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } }
if ( function == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
{ if ( BigInteger.ZERO . equals ( fraction.numerator ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; } return multiply ( fraction . reciprocal () ) ; }
if ( BigInteger.ZERO . equals ( bg ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( BigInteger.ZERO . equals ( den ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , pos , size , d.length ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , pos , size , d.length ) ; }
{ super ( STRING_CONSTANT , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
{ super ( STRING_CONSTANT , argument ) ; this . argument = new double [] { argument } ; }
int negativeVarColumn = columnLabels . indexOf ( STRING_CONSTANT ) ;
if ( ! restrictToNonNegative ) { columnLabels . add ( STRING_CONSTANT ) ; }
int value = ( Integer ) decoded . get ( i ) ;
if ( isZero ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
! isZero ( value )
{ this ( values , DEFAULT_ZERO_TOLERANCE ) ; }
public OpenMapRealVector ( int dimension ) { this ( dimension , DEFAULT_ZERO_TOLERANCE ) ; }
{ this ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE ) ; }
public void setEntry ( int index , double value ) throws MatrixIndexException { throw unsupported () ; }
return mapDivide ( getNorm () ) ;
public ArrayRealVector ( ArrayRealVector v ) { data = v.data . clone () ; }
{ try { return mapToSelf ( UnivariateRealFunctions.ULP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.TANH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.TAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.SQRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.SINH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.SIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.SIGNUM ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.RINT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.LOG10 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.LOG ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.FLOOR ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.EXP1M ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.EXP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.COSH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.COS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.CEIL ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.CBRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ATAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ACOS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ABS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
Iterator < Entry > it = sparseIterator () ;
setDefault ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE ) ;
{ this ( values , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
setDefault ( NUMBER_CONSTANT , epsilon ) ;
public OpenMapRealVector ( int dimension ) { this ( dimension , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
{ this ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
{ return new BigReal ( d . divide ( a.d ) ) ; }
return new ArrayRealVector ( out ) ;
return new ArrayRealVector ( out ) ;
return new ArrayRealVector ( out ) ;
return new ArrayRealVector ( out ) ;
return new ArrayRealVector ( out ) ;
if ( lcm == Integer.MIN_VALUE ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
{ return new Solver ( singularValues , getUT () , getV () , getRank () == singularValues.length ) ; }
public double getLInfNorm () { throw unsupported () ; }
public double getL1Norm () { throw unsupported () ; }
public double getNorm () { throw unsupported () ; }
public void unitize () { throw unsupported () ; }
public RealVector unitVector () { throw unsupported () ; }
public RealVector mapCoshToSelf () { throw unsupported () ; }
{ dest.n = source.n ; dest.m1 = source.m1 ; dest.dev = source.dev ; dest.nDev = dest.nDev ; }
{ new LoessInterpolator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ new LoessInterpolator ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT , min , max , yMin , yMax ) ; }
assertEquals ( NUMBER_CONSTANT , es . solve ( b ) . subtract ( xRef ) . getNorm () , NUMBER_CONSTANT ) ;
{ interpolator = new DummyStepInterpolator ( yTmp , forward ) ; }
{ interpolator = new DummyStepInterpolator ( yTmp , forward ) ; }
public BadStepInterpolator ( double [] y , boolean forward ) { super ( y , forward ) ; }
DummyStepInterpolator interpolator = new DummyStepInterpolator ( y , true ) ;
{ interpolator = new DummyStepInterpolator ( y , forward ) ; }
{ super ( interpolator ) ; }
{ super(); }
{ handler . handleStep ( new StepInterpolatorWrapper ( interpolator , ode . getDimension () , ode . getParametersDimension () ) , isLast ) ; }
final ParameterizedODEWithJacobians ode
{ super(); setMean ( mean ) ; setStandardDeviation ( sd ) ; }
{ super ( f , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setTolerance ( NUMBER_CONSTANT ) ; }
if ( p < NUMBER_CONSTANT ) { ret = getMean () ; } else { ret = Double.MAX_VALUE ; }
if ( p < NUMBER_CONSTANT ) { ret = - Double.MAX_VALUE ; } else { ret = getMean () ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - Math . pow ( x / getScale () , getShape () ) ) ; }
{ super(); setShape ( alpha ) ; setScale ( beta ) ; }
{ ret = Beta . regularizedBeta ( getProbabilityOfSuccess () , getNumberOfSuccesses () , x + NUMBER_CONSTANT ) ; }
{ super(); setNumberOfSuccesses ( r ) ; setProbabilityOfSuccess ( p ) ; }
public TDistributionImpl ( double degreesOfFreedom ) { super(); setDegreesOfFreedom ( degreesOfFreedom ) ; }
{ if ( p < NUMBER_CONSTANT ) { return getMean () ; } else { return Double.MAX_VALUE ; } }
{ ret = - getMean () * Math . log ( NUMBER_CONSTANT - p ) ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - x / getMean () ) ; }
public ExponentialDistributionImpl ( double mean ) { super(); setMean ( mean ) ; }
if ( p < NUMBER_CONSTANT ) { ret = getMedian () ; } else { ret = Double.MAX_VALUE ; }
if ( p < NUMBER_CONSTANT ) { ret = - Double.MAX_VALUE ; } else { ret = getMedian () ; }
{ super(); setMedian ( median ) ; setScale ( s ) ; }
double d = getDenominatorDegreesOfFreedom () ;
{ super(); setNumeratorDegreesOfFreedom ( numeratorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; }
{ return getUpperDomain ( getSampleSize () , getNumberOfSuccesses () ) ; }
{ return getLowerDomain ( getPopulationSize () , getNumberOfSuccesses () , getSampleSize () ) ; }
x < NUMBER_CONSTANT || x > getNumberOfTrials ()
{ return getNumberOfTrials () ; }
{ super(); setNumberOfTrials ( trials ) ; setProbabilityOfSuccess ( p ) ; }
if ( p < NUMBER_CONSTANT ) { ret = getAlpha () * getBeta () ; } else { ret = Double.MAX_VALUE ; }
{ ret = Gamma . regularizedGammaP ( getAlpha () , x / getBeta () ) ; }
{ super(); setAlpha ( alpha ) ; setBeta ( beta ) ; }
if ( x <= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else if ( x >= getNumberOfElements () ) { return NUMBER_CONSTANT ; }
if ( x <= NUMBER_CONSTANT || x > getNumberOfElements () ) { return NUMBER_CONSTANT ; }
{ setNumberOfElements ( numberOfElements ) ; setExponent ( exponent ) ; }
{ return Double.MIN_VALUE * getGamma () . getBeta () ; }
{ return getGamma () . cumulativeProbability ( x ) ; }
public LaguerreSolver () { super ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ super(); setShapeInternal ( alpha ) ; setScaleInternal ( beta ) ; }
protected void setDistribution ( ContinuousDistribution distribution ) { this . distribution = distribution ; }
public TDistributionImpl ( double degreesOfFreedom ) { super(); setDegreesOfFreedomInternal ( degreesOfFreedom ) ; }
{ super(); setNumeratorDegreesOfFreedomInternal ( numeratorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedomInternal ( denominatorDegreesOfFreedom ) ; }
{ super(); setAlphaInternal ( alpha ) ; setBetaInternal ( beta ) ; }
public ExponentialDistributionImpl ( double mean ) { super(); setMeanInternal ( mean ) ; }
{ super(); setMedianInternal ( median ) ; setScaleInternal ( s ) ; }
final double [] row = aInv [ i ] ;
{ p = interpolator . interpolate ( xval , wyval , zval ) ; Assert . fail ( STRING_CONSTANT ) ; }
int length = eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = eliminateZeroMassPoints ( densityPoints , densityValues ) ;
if ( ak2 == NUMBER_CONSTANT ) { rank = k ; return; }
if ( ak2 < NUMBER_CONSTANT ) { rank = k ; return; }
if ( ak2 == NUMBER_CONSTANT ) { rank = k ; return; }
assertTrue ( MathUtils . equals ( Double.NaN , Double.NaN , NUMBER_CONSTANT ) ) ;
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( DIMENSION_MISMATCH_MESSAGE , n , startConfiguration.length ) ; }
if ( steps [ j ] == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EQUAL_VERTICES_MESSAGE , j , j + NUMBER_CONSTANT ) ; }
{ if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; } quantile = p ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
{ if ( getDimension () != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , getDimension () , n ) ; } }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( sd <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , sd ) ; } standardDeviation = sd ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . scale = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . shape = alpha ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( microsphereElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , microsphereElements ) ; } this . microsphereElements = elements ; }
{ if ( brightnessExponent < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , brightnessExponent ) ; } this . brightnessExponent = brightnessExponent ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ;
{ if ( realFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . realFormat = realFormat ; }
{ if ( imaginaryFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . imaginaryFormat = imaginaryFormat ; }
if ( imaginaryCharacter == null || imaginaryCharacter . length () == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ; }
{ double d = getDimension () ; if ( d != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , d , n ) ; } }
catch ( InvalidMatrixException e ) { throw new OptimizationException ( STRING_CONSTANT ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
if ( arrayDimension != expected ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , arrayDimension , expected ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
String specifier
if ( y0 * y1 >= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT , min , max , y0 , y1 ) ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , columns ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , columns , length ) ; }
{ super ( pattern , arguments ) ; }
if ( nSteps <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , name ) ; }
if ( ( c1 / c2 < NUMBER_CONSTANT ) || ( c2 / c3 < NUMBER_CONSTANT ) ) { throw new OptimizationException ( STRING_CONSTANT ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , f.length ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
if ( e . compareTo ( BigInteger.ZERO ) < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
{ if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; } return k . pow ( e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( lcm == Long.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , a , b ) ; }
if ( lcm == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , a , b ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
{ if ( ( minimalIterationCount <= NUMBER_CONSTANT ) || ( maximalIterationCount <= minimalIterationCount ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , minimalIterationCount , maximalIterationCount ) ; } }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( STRING_CONSTANT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
String pattern
String pattern
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FRACTION ) ; }
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( OVERFLOW_MESSAGE , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
if ( p <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
{ super ( pattern , arguments ) ; }
if ( r < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , r ) ; }
if ( nRows == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( nCols == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( dimension == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , minSingularValue , singularValues [ NUMBER_CONSTANT ] ) ; }
if ( target.length != weights.length ) { throw new OptimizationException ( STRING_CONSTANT , target.length , weights.length ) ; }
if ( rows <= cols ) { throw new OptimizationException ( STRING_CONSTANT , rows , cols ) ; }
catch ( InvalidMatrixException ime ) { throw new OptimizationException ( STRING_CONSTANT ) ; }
if ( objective.length != rows ) { throw new FunctionEvaluationException ( point , STRING_CONSTANT , objective.length , rows ) ; }
if ( jacobian.length != rows ) { throw new FunctionEvaluationException ( point , STRING_CONSTANT , jacobian.length , rows ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( successes < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , successes ) ; } numberOfSuccesses = successes ; }
{ if ( newDegreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , newDegreesOfFreedom ) ; } this . degreesOfFreedom = newDegreesOfFreedom ; }
if ( b.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v.length != getColumnDimension () ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( sampleSize <= NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( OUT_OF_RANGE_POINT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( WRONG_ORDER_ENDPOINTS_MESSAGE , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( WRONG_ORDER_ENDPOINTS_MESSAGE , x0 , x1 ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTH_MISMATCH_MESSAGE , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTH_MISMATCH_MESSAGE , b.length , m ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , nRows , nCols ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( observations.length < NUMBER_CONSTANT ) { throw new OptimizationException ( STRING_CONSTANT , observations.length , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( newMean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , newMean ) ; } this . mean = newMean ; }
catch ( ClassCastException ex ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getClass () . getName () ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getClass () . getName () ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
if ( ( str = filePointer . readLine () ) == null ) { throw MathRuntimeException . createEOFException ( STRING_CONSTANT , valuesFileURL ) ; }
if ( ( empiricalDistribution == null ) || ( empiricalDistribution . getBinStats () . size () == NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , dimension1 , dimension2 ) ; this . dimension1 = dimension1 ; this . dimension2 = dimension2 ; }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , s ) ; } scale = s ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; }
if ( isDefaultValue ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( vector . getDimension () != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( vector . getDimension () != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nCols ) ; }
{ if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return d [ NUMBER_CONSTANT ] . getField () ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( Double . isInfinite ( norm2 ) || Double . isNaN ( norm2 ) ) { throw new OptimizationException ( STRING_CONSTANT , rows , cols ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( getN () > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , getN () ) ; } }
{ super ( STRING_CONSTANT , abscissa , i1 , i2 ) ; }
if ( i < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , i ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , initialCapacity ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( STRING_CONSTANT , index ) ; }
if ( expansion <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , expansion ) ; }
if ( numElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( STRING_CONSTANT ) ; }
{ throw new IntegratorException ( STRING_CONSTANT , minStep , Math . abs ( h ) ) ; }
if ( m <= p ) { throw new EstimationException ( STRING_CONSTANT , m , p ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT ) ; }
if ( ++ costEvaluations > maxCostEval ) { throw new EstimationException ( STRING_CONSTANT , maxCostEval ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
{ if ( size < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , size ) ; } sampleSize = size ; }
{ if ( size <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , size ) ; } populationSize = size ; }
{ if ( num < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , num ) ; } numberOfSuccesses = num ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( STRING_CONSTANT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; }
if ( sigma <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , sigma ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , len ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , len ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( vector . getDimension () != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( vector . getDimension () != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nCols ) ; }
throw new NotARotationMatrixException ( STRING_CONSTANT , i - NUMBER_CONSTANT ) ;
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
catch ( IllegalAccessException e2 ) { throw MathRuntimeException . createIllegalArgumentException ( ILLEGAL_ACCESS_MESSAGE , SET_QUANTILE_METHOD_NAME , percentileImpl . getClass () . getName () ) ; }
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , windowSize ) ; } }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
public CardanEulerSingularityException ( boolean isCardan ) { super ( isCardan ? STRING_CONSTANT : STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( Double . isNaN ( optima [ NUMBER_CONSTANT ] ) ) { throw new OptimizationException ( STRING_CONSTANT , starts ) ; }
{ if ( optimaValues == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optimaValues . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
catch ( DuplicateSampleAbscissaException e ) { throw new FunctionEvaluationException ( e , z , e . getPattern () , e . getArguments () ) ; }
if ( Double . isInfinite ( norm2 ) || Double . isNaN ( norm2 ) ) { throw new EstimationException ( STRING_CONSTANT , rows , cols ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
final String pattern
if ( xval.length != yval.length ) { throw new MathException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , xval.length , yval.length ) ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , columns ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , columns , length ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( STRING_CONSTANT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( offset > NUMBER_CONSTANT ) { throw new EventException ( STRING_CONSTANT , t ) ; }
{ throw new DerivativeException ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( MISSING_ROOTS_OF_UNITY_MESSAGE ) ; }
if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( MISSING_ROOTS_OF_UNITY_MESSAGE ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( MISSING_ROOTS_OF_UNITY_MESSAGE ) ; } return isForward ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( NOT_POWER_OF_TWO_MESSAGE , o.length ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( NOT_POWER_OF_TWO_MESSAGE , d.length ) ; } }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
{ super ( cause , pattern , arguments ) ; }
{ super ( pattern , arguments ) ; }
if ( sampleStats . getN () == NUMBER_CONSTANT ) { throw MathRuntimeException . createEOFException ( STRING_CONSTANT , url ) ; }
final String specifier
{ if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , lower , initial , upper ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FUNCTION_MESSAGE ) ; } }
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
final String specifier
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( trials < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , trials ) ; } numberOfTrials = trials ; }
{ if ( BigInteger.ZERO . equals ( fraction.numerator ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; } return multiply ( fraction . reciprocal () ) ; }
if ( BigInteger.ZERO . equals ( bg ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; }
throw new OptimizationException ( STRING_CONSTANT ) ;
{ if ( newBeta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , newBeta ) ; } this . beta = newBeta ; }
{ if ( newAlpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , newAlpha ) ; } this . alpha = newAlpha ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ super ( STRING_CONSTANT , value , p , q ) ; }
{ super ( STRING_CONSTANT , value , maxIterations ) ; }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , s ) ; } this . exponent = s ; }
{ if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; } this . numberOfElements = n ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ;
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . wholeFormat = format ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . numeratorFormat = format ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . denominatorFormat = format ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
{ if ( in [ i ] < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , i , in [ i ] ) ; } }
{ if ( in [ i ] <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , i , in [ i ] ) ; } }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREE_MESSAGE , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREE_MESSAGE , n ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POLYNOMIAL_FUNCTION_MESSAGE ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( NON_POLYNOMIAL_FUNCTION_MESSAGE ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , nRows , nCols ) ; }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
if ( residuals.length != observations.length ) { throw new FunctionEvaluationException ( point , STRING_CONSTANT , residuals.length , observations.length ) ; }
if ( observations.length != scale . getColumnDimension () ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , observations.length , scale . getColumnDimension () ) ; }
if ( observations.length != weights.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , observations.length , weights.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
public Double getZ () { throw new MathRuntimeException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( mean.length != standardDeviation.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean.length , standardDeviation.length ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , data.length , n ) ; } }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , pos , size , d.length ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( xval.length == NUMBER_CONSTANT || xval [ NUMBER_CONSTANT ] == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || zval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , rows , columns ) ; }
if ( f [ NUMBER_CONSTANT ] != NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , f [ NUMBER_CONSTANT ] ) ; }
catch ( ClassCastException cce ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , data.length , n ) ; } }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( NON_FITTING_POSITION_AND_SIZE_MESSAGE , pos , size , d.length ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( NON_FITTING_POSITION_AND_SIZE_MESSAGE , pos , size , d.length ) ; }
if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
if ( sampleSize <= NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new MathRuntimeException ( new UnsupportedOperationException () , STRING_CONSTANT ) ; }
{ super ( FAILED_EVALUATION_MESSAGE , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
{ super ( FAILED_EVALUATION_MESSAGE , argument ) ; this . argument = new double [] { argument } ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . wholeFormat = format ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
if ( sum == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , lower , upper ) ; } }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
catch ( NoSuchMethodException e1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , percentileImpl . getClass () . getName () ) ; }
{ throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , i , k , x [ i ] ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( OUT_OF_RANGE_ROOT_INDEX_MESSAGE , k , NUMBER_CONSTANT , omegaCount - NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( OUT_OF_RANGE_ROOT_INDEX_MESSAGE , k , NUMBER_CONSTANT , omegaCount - NUMBER_CONSTANT ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , lower , upper ) ; } }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT + original . getClass () . getSimpleName () ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , lower , upper ) ; } }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT , n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
public NotStrictlyPositiveException ( Number value ) { super ( LocalizedFormats.NOT_STRICTLY_POSITIVE , value ) ; }
public NotPositiveException ( Number value ) { super ( LocalizedFormats.NOT_POSITIVE , value ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
if ( x.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( x.length , NUMBER_CONSTANT , true ) ; }
if ( x.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( x.length , NUMBER_CONSTANT , true ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_UPPER_BOUND , n ) ; }
if ( mean.length != standardDeviation.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , mean.length , standardDeviation.length ) ; }
{ return point . clone () ; }
{ return value . clone () ; }
{ return point . clone () ; }
final double [] scale = new double [ y0.length ] ;
catch ( IllegalStateException ise ) {}
{ super ( specific , LocalizedFormats.NO_DATA , null ) ; }
startConfiguration == null || startConfiguration.length != startPoint.length
a [ i ] [ j ] [ k ] = aV [ i + N * j + N2 * k ]
super ( specific , ( boundIsAllowed ? LocalizedFormats.NUMBER_TOO_SMALL : LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED ) , wrong , min ) ;
{ return ( point == null ? null : point . clone () ) ; }
{ return ( value == null ? null : value . clone () ) ; }
{ return ( point == null ? null : point . clone () ) ; }
public GoalType getGoalType () { return goal ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , column , NUMBER_CONSTANT , getColumnDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , row , NUMBER_CONSTANT , getRowDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
public void remove () { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
{ ret = addAndCheck ( a , - b , msg ) ; }
if ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
{ return addAndCheck ( a , b , STRING_CONSTANT ) ; }
if ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( populationLimit < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
catch ( ArithmeticException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
{ this ( wrong , previous , index , MathUtils.Order.Direction.INCREASING , true ) ; }
{ checkOrder ( val , Order.Direction.INCREASING , true ) ; }
if ( e [ i + NUMBER_CONSTANT ] == NUMBER_CONSTANT && i >= j ) continue;
arguments = flatten ( args ) . toArray () ;
public void remove () { throw MathRuntimeException . createUnsupportedOperationException ( LocalizedFormats.UNSUPPORTED_OPERATION ) ; }
@ Test ( expected = ZeroNotAllowedException . class )
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FRACTION ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FRACTION ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FRACTION ) ; }
if ( d == NUMBER_CONSTANT ) { throw new ZeroNotAllowedException () ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , xArray.length , yArray.length ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_COVARIANCE_MATRIX ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( idxStep == NUMBER_CONSTANT ) { throw new ZeroNotAllowedException () ; }
if ( idxStep == NUMBER_CONSTANT ) { throw new ZeroNotAllowedException () ; }
if ( observations == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; } }
if ( function == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( d == NUMBER_CONSTANT ) { throw new ZeroNotAllowedException () ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
final double [] grad = jacobian [ i ] ;
{ this ( cause , argument , new DummyLocalizable ( pattern ) , argument ) ; }
{ this ( cause , argument , new DummyLocalizable ( pattern ) , argument ) ; }
{ this ( argument , new DummyLocalizable ( pattern ) , argument ) ; }
{ this ( argument , new DummyLocalizable ( pattern ) , argument ) ; }
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double fpos = Math . floor ( pos ) ;
{ return Math . asin ( z / getNorm () ) ; }
{ return Math . atan2 ( y , x ) ; }
double expected = Math . random () ;
double expected = Math . random () ;
double range = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double range = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
NUMBER_CONSTANT * ( NUMBER_CONSTANT + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( NUMBER_CONSTANT ) ) ) )
return Math . sqrt ( sum / v.length ) ;
if ( value != i ) { res += Math . abs ( value - i ) ; }
{ norm = Math . max ( norm , Math . abs ( e . getValue () ) ) ; }
{ norm += Math . abs ( e . getValue () ) ; }
return Math . sqrt ( sum ) ;
return Math . sqrt ( d ) ;
FastFourierTransformer . scaleArray ( x , Math . sqrt ( x.length / NUMBER_CONSTANT ) ) ;
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
minor < Math . min ( m , n )
j < Math . min ( i + NUMBER_CONSTANT , n )
int row = Math . min ( m , n ) - NUMBER_CONSTANT
assertEquals ( Math . sqrt ( NUMBER_CONSTANT ) , e1 . distanceFrom ( e2 ) , NUMBER_CONSTANT ) ;
{ Assert . assertEquals ( Math . pow ( NUMBER_CONSTANT , x ) , f . value ( x ) , NUMBER_CONSTANT ) ; }
{ assertTrue ( Math . abs ( value - reference ) < NUMBER_CONSTANT ) ; }
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
assertTrue ( Math . abs ( h ) < minStep ) ;
double maxStep = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
Math . abs ( max - min ) <= absoluteAccuracy
final double power = Math . pow ( normalizedAbscissa , order ) ;
final int pEnd = Math . min ( pStart + BLOCK_SIZE , rows ) ;
final int pEnd = Math . min ( pStart + BLOCK_SIZE , rows ) ;
Assert . assertEquals ( STRING_CONSTANT , expected , result , Math . ulp ( NUMBER_CONSTANT ) ) ;
Assert . assertEquals ( STRING_CONSTANT , expected , result , Math . ulp ( NUMBER_CONSTANT ) ) ;
setMaxGrowth ( Math . pow ( NUMBER_CONSTANT , - exp ) ) ;
setMaxGrowth ( Math . pow ( NUMBER_CONSTANT , - exp ) ) ;
{ assertEquals ( msg , expected , actual , Math . abs ( tolerance * actual ) ) ; }
Gamma . digamma ( Math . pow ( NUMBER_CONSTANT , - n ) )
final int capacity = ( int ) Math . ceil ( expectedSize / LOAD_FACTOR ) ;
double scaling_coefficient = Math . sqrt ( NUMBER_CONSTANT / ( n - NUMBER_CONSTANT ) ) ;
double scaling_coefficient = Math . sqrt ( NUMBER_CONSTANT / ( f.length - NUMBER_CONSTANT ) ) ;
{ sum += Math . abs ( p1 [ i ] - p2 [ i ] ) ; }
{ return ( Math . exp ( x ) - Math . exp ( - x ) ) / NUMBER_CONSTANT ; }
float factor = ( float ) Math . pow ( NUMBER_CONSTANT , scale ) * sign ;
{ return Math . log ( x ) / Math . log ( base ) ; }
return Math . abs ( u ) + Math . abs ( v ) ;
return Math . abs ( u ) + Math . abs ( v ) ;
final boolean isEqual = Math . abs ( xInt - yInt ) <= maxUlps ;
{ return equalsIncludingNaN ( x , y ) || ( Math . abs ( y - x ) <= eps ) ; }
{ return equals ( x , y , NUMBER_CONSTANT ) || Math . abs ( y - x ) <= eps ; }
{ return ( Math . exp ( x ) + Math . exp ( - x ) ) / NUMBER_CONSTANT ; }
return Math . floor ( result + NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / Math . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / Math . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / Math . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / Math . sqrt ( NUMBER_CONSTANT ) ;
assertEquals ( Math.PI , x , accuracy ) ;
{ double x = UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; assertEquals ( Math.PI , x , NUMBER_CONSTANT ) ; }
double t = Math . abs ( t ( m , mu , v , n ) ) ;
{ return ( m - mu ) / Math . sqrt ( v / n ) ; }
double sqrt = Math . sqrt ( c [ ir ] [ ir ] ) ;
{ return ( int ) Math . min ( randomData . nextPoisson ( mean ) , Integer.MAX_VALUE ) ; }
normal . setStandardDeviation ( Math . sqrt ( p ) ) ;
final int p = Math . min ( m , n ) ;
assertEquals ( Math.PI , MathUtils . scalb ( Math.PI , NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
MathUtils . hash ( new double [] { MathUtils . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) } )
assertEquals ( i + STRING_CONSTANT , Math . log ( factorial ( i ) ) , MathUtils . factorialLog ( i ) , NUMBER_CONSTANT ) ;
new double [] { MathUtils . nextAfter ( MathUtils . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT ) }
MathUtils . equals ( new double [] { NUMBER_CONSTANT } , new double [] { MathUtils . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) } )
error = Math . sqrt ( error / scale.length ) * errfac [ currentDegree - NUMBER_CONSTANT ] ;
final int capacity = ( int ) Math . ceil ( expectedSize / LOAD_FACTOR ) ;
{ return Math . atan2 ( getImaginary () , getReal () ) ; }
Math . abs ( c ) < Math . abs ( d )
{ singularValues [ i ] = Math . sqrt ( Math . abs ( singularValues [ i ] ) ) ; }
double sigma = Math . sqrt ( mean ) ;
{ return Math . sqrt ( getChiSquare () / rows ) ; }
double wi = Math . sqrt ( residualsWeights [ i ] ) ;
double range = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double range = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
{ return Math . atan2 ( x , y ) ; }
{ return Math . pow ( x , y ) ; }
return Math . sqrt ( dx * dx + dy * dy ) ;
assertTrue ( Math . sqrt ( m.length ) * estimator . getRMS ( problem ) > NUMBER_CONSTANT ) ;
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
Math . abs ( dt ) <= Math . ulp ( stepStart )
this . step = Math . abs ( step ) ;
double fl = Math . floor ( x ) ;
{ return cumulativeProbability ( ( int ) Math . floor ( x ) ) ; }
assertEquals ( ci , l40 [ i ] , Math . abs ( ci ) * NUMBER_CONSTANT ) ;
Math . abs ( Tk . value ( x ) ) < ( NUMBER_CONSTANT + NUMBER_CONSTANT )
{ return new HarmonicFunction ( a * omega , omega , phi + Math.PI / NUMBER_CONSTANT ) ; }
{ return a * Math . cos ( omega * x + phi ) ; }
assertTrue ( Math . abs ( generated [ NUMBER_CONSTANT ] - NUMBER_CONSTANT ) > NUMBER_CONSTANT ) ;
return a * Math . cos ( omega * x + phi ) ;
double [] y0 = { Math . sin ( a ) , Math . cos ( a ) } ;
{ ret = - mean * Math . log ( NUMBER_CONSTANT - p ) ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - x / mean ) ; }
{ if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } return Math . exp ( - x / mean ) / mean ; }
Complex sqrtz = ComplexUtils . polar2Complex ( Math . sqrt ( r ) , theta / NUMBER_CONSTANT ) ;
TestUtils . assertEquals ( new Complex ( Math . acos ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) , Complex.ZERO . acos () , NUMBER_CONSTANT ) ;
{ if ( getN () > NUMBER_CONSTANT ) { stdDev = Math . sqrt ( getVariance () ) ; } else { stdDev = NUMBER_CONSTANT ; } }
assertTrue ( Math . sqrt ( problem.target.length ) * optimizer . getRMS () > NUMBER_CONSTANT ) ;
{ ret = median + scale * Math . tan ( Math.PI * ( p - NUMBER_CONSTANT ) ) ; }
return ( NUMBER_CONSTANT / Math.PI ) * ( scale / ( dev * dev + scale * scale ) ) ;
assertEquals ( NUMBER_CONSTANT , Math . sqrt ( circle . getN () ) * optimizer . getRMS () , NUMBER_CONSTANT ) ;
final double f = NUMBER_CONSTANT / Math . sqrt ( normSq ) ;
new Fraction ( Math.PI , NUMBER_CONSTANT )
{ new Fraction ( ( NUMBER_CONSTANT + Math . sqrt ( NUMBER_CONSTANT ) ) / NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
double delta = Math . abs ( getEntry ( i ) - v [ i ] ) ;
{ double delta = Math . abs ( getEntry ( i ) - v [ i ] ) ; max += delta ; }
return Math . sqrt ( res ) ;
return Math . sqrt ( res ) ;
{ return Math . abs ( value ) < epsilon ; }
{ return Math . sqrt ( variance . evaluate ( values , mean ) ) ; }
{ return Math . sqrt ( variance . evaluate ( values , mean , begin , length ) ) ; }
{ return Math . sqrt ( variance . evaluate ( values , begin , length ) ) ; }
{ return Math . sqrt ( variance . evaluate ( values ) ) ; }
@ Override public double getResult () { return Math . sqrt ( variance . getResult () ) ; }
@ Override public double value ( double d ) { return Math . ulp ( d ) ; }
@ Override public double value ( double d ) { return Math . signum ( d ) ; }
@ Override public double value ( double d ) { return Math . rint ( d ) ; }
@ Override public double value ( double d ) { return Math . cosh ( d ) ; }
@ Override public double value ( double d ) { return Math . acos ( d ) ; }
@ Override public double value ( double d ) { return Math . cos ( d ) ; }
@ Override public double value ( double d ) { return Math . log10 ( d ) ; }
@ Override public double value ( double d ) { return Math . log ( d ) ; }
@ Override public double value ( double d ) { return Math . floor ( d ) ; }
@ Override public double value ( double d ) { return Math . ceil ( d ) ; }
@ Override public double value ( double d ) { return Math . cbrt ( d ) ; }
@ Override public double value ( double d ) { return Math . tanh ( d ) ; }
@ Override public double value ( double d ) { return Math . tan ( d ) ; }
@ Override public double value ( double d ) { return Math . atan ( d ) ; }
@ Override public double value ( double d ) { return Math . asin ( d ) ; }
@ Override public double value ( double d ) { return Math . expm1 ( d ) ; }
@ Override public double value ( double d ) { return Math . exp ( d ) ; }
@ Override public double value ( double d ) { return Math . sinh ( d ) ; }
@ Override public double value ( double d ) { return Math . sqrt ( d ) ; }
@ Override public double value ( double d ) { return Math . sin ( d ) ; }
@ Override public double value ( double d ) { return Math . abs ( d ) ; }
widthSufficient = Math . min ( lowerBinMass , upperBinMass ) * sampleSize >= minExpectedCount ;
{ return Math . exp ( sumOfLogs . getResult () / sumOfLogs . getN () ) ; }
int k = Math . max ( N , seed.length )
final double s17 = Math . sqrt ( NUMBER_CONSTANT ) ;
{ assertTrue ( Math . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
{ assertTrue ( Math . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
{ stepStart = Double.NaN ; stepSize = Math . sqrt ( minStep * maxStep ) ; }
return Math . sqrt ( criterion / wm.length ) ;
double factor = - Math . sqrt ( wm . getWeight () ) ;
if ( deltaNorm > NUMBER_CONSTANT * Math . max ( NUMBER_CONSTANT , initialNorm ) ) { return false ; }
assertTrue ( Math . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( Math . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( Math . abs ( walk ) < NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * Math . sqrt ( NUMBER_CONSTANT ) ) , sample . getStandardDeviation () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * Math . sqrt ( NUMBER_CONSTANT ) ) , sample . getStandardDeviation () , NUMBER_CONSTANT ) ;
ret = Math . exp ( p1 + p2 - p3 ) ;
{ return Math . min ( k , m ) ; }
{ return Math . max ( NUMBER_CONSTANT , m - ( n - k ) ) ; }
{ assertTrue ( Math . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
FastFourierTransformer . scaleArray ( x2 , NUMBER_CONSTANT / Math . sqrt ( x2.length ) ) ;
double c = t2 + NUMBER_CONSTANT * ( Math . exp ( - NUMBER_CONSTANT * t2 ) - NUMBER_CONSTANT ) ;
return - mean * Math . log ( unif ) ;
double expected = Math . random () ;
double expected = Math . random () ;
public double end () { return Math . sqrt ( sum ) ; }
if ( Math . abs ( fn1 - fn ) <= threshold ) return o ;
this . convergence = Math . abs ( convergence ) ;
assertEquals ( n + STRING_CONSTANT + degree + STRING_CONSTANT + i , reference , result , NUMBER_CONSTANT * ( NUMBER_CONSTANT + Math . abs ( reference ) ) ) ;
{ if ( getN () > NUMBER_CONSTANT ) { stdDev = Math . sqrt ( getVariance () ) ; } else { stdDev = NUMBER_CONSTANT ; } }
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
long index = Math . round ( ( Math . random () ) * testArray.length ) ;
new double [] { - Math . sqrt ( NUMBER_CONSTANT ) , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT }
{ new BigReal ( NUMBER_CONSTANT ) , BigReal.ONE , BigReal.ZERO , new BigReal ( NUMBER_CONSTANT ) , new BigReal ( Math.PI ) , new BigReal ( - NUMBER_CONSTANT ) }
Math . log ( x ) - NUMBER_CONSTANT / x
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double invR3 = NUMBER_CONSTANT / ( r2 * Math . sqrt ( r2 ) ) ;
{ result [ i ] = Math . sqrt ( sigma * betaVariance [ i ] [ i ] ) ; }
final double dist = Math . abs ( z - x [ i ] ) ;
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
{ product *= Math . pow ( values [ i ] , weights [ i ] ) ; }
return Math . sqrt ( sum2 ) ;
final int pEnd = Math . min ( pStart + BLOCK_SIZE , rows ) ;
final int pEnd = Math . min ( pStart + BLOCK_SIZE , rows ) ;
accum3 /= variance * Math . sqrt ( variance ) ;
( n0 * moment.m3 ) / ( ( n0 - NUMBER_CONSTANT ) * ( n0 - NUMBER_CONSTANT ) * Math . sqrt ( variance ) * variance )
assertEquals ( Math . sqrt ( NUMBER_CONSTANT ) , Vector3D . distance ( v1 , v2 ) , NUMBER_CONSTANT ) ;
assertEquals ( Math . sqrt ( NUMBER_CONSTANT ) , new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getNorm () , NUMBER_CONSTANT ) ;
double tmp2 = Math . exp ( tmp1 ) ;
double tmp2 = Math . sqrt ( tmpSquare ) ;
assertEquals ( mi , vi , paramsAccuracy * ( NUMBER_CONSTANT + Math . abs ( mi ) ) ) ;
assertEquals ( theoreticalMinCost , Math . sqrt ( m ) * rms , threshold ) ;
double t = NUMBER_CONSTANT * Math.PI ;
double t = NUMBER_CONSTANT * Math.PI ;
Double pi = Double . valueOf ( Math.PI ) ;
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( f.length ) ;
double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( n ) ;
{ double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( f.length ) ; return scaleArray ( fft ( f , true ) , scaling_coefficient ) ; }
double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( f.length ) ;
double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( n ) ;
{ double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( f.length ) ; return scaleArray ( fft ( f , false ) , scaling_coefficient ) ; }
{ assertTrue ( Math . abs ( value - reference ) < NUMBER_CONSTANT ) ; }
double x = Math . random () ;
double absTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
{ values [ i ] = Math . pow ( values [ i ] , d ) ; }
assertNotSame ( v , new OpenMapRealVector ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT + Math . ulp ( NUMBER_CONSTANT ) } ) ) ;
double tmp2 = Math . exp ( tmp1 ) ;
double tmp2 = Math . sqrt ( tmpSquare ) ;
double c = Math . exp ( t0 - t ) ;
return Math . sqrt ( dx * dx + dy * dy ) ;
assertEquals ( NUMBER_CONSTANT , Math . sqrt ( circle . getM () ) * rms , NUMBER_CONSTANT ) ;
Math . abs ( dt ) <= Math . ulp ( stepStart )
new BigFraction ( Math.PI , NUMBER_CONSTANT )
{ new BigFraction ( ( NUMBER_CONSTANT + Math . sqrt ( NUMBER_CONSTANT ) ) / NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
( int ) ( Math . abs ( NUMBER_CONSTANT * x + NUMBER_CONSTANT * y ) ) % NUMBER_CONSTANT == NUMBER_CONSTANT
( int ) ( Math . abs ( NUMBER_CONSTANT * x + NUMBER_CONSTANT * y ) ) % NUMBER_CONSTANT == NUMBER_CONSTANT
step *= Math . max ( NUMBER_CONSTANT , yA / yB )
{ value += NUMBER_CONSTANT / Math . pow ( k , m ) ; }
return ( NUMBER_CONSTANT / Math . pow ( x , exponent ) ) / generalizedHarmonic ( numberOfElements , exponent ) ;
FastFourierTransformer . scaleArray ( x , Math . sqrt ( NUMBER_CONSTANT * ( x.length - NUMBER_CONSTANT ) ) ) ;
double sigma = NUMBER_CONSTANT + Math . random () ;
double mu = Math . random () ;
{ this . h = Math . abs ( h ) ; this . handler = handler ; reset () ; }
if ( unequalCounts ) { weight = Math . sqrt ( ( double ) countSum1 / ( double ) countSum2 ) ; }
if ( Math . abs ( sumExpected - sumObserved ) > NUMBER_CONSTANT ) { ratio = sumObserved / sumExpected ; rescale = true ; }
double tolerance = Math . max ( relativeAccuracy * z . abs () , absoluteAccuracy ) ;
{ double absError = Math . abs ( expected ) * relativeError ; Assert . assertEquals ( msg , expected , actual , absError ) ; }
double absAi = Math . abs ( coefficients [ i ] ) ;
{ return NUMBER_CONSTANT * ( NUMBER_CONSTANT - distribution . cumulativeProbability ( Math . abs ( getSlope () ) / getSlopeStdErr () ) ) ; }
{ return Math . sqrt ( getMeanSquareError () / sumXX ) ; }
double result = Math . sqrt ( getRSquare () ) ;
if ( Math . abs ( sumXX ) < NUMBER_CONSTANT * Double.MIN_VALUE ) { return Double.NaN ; }
double t = Math . abs ( rValues . getEntry ( i , j ) ) / stdErrors . getEntry ( i , j ) ;
assertNotSame ( v , new ArrayRealVector ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT + Math . ulp ( NUMBER_CONSTANT ) } ) ) ;
{ sumLog += Math . log ( values [ i ] ) ; }
{ value += Math . log ( d ) ; n ++ ; }
{ assertTrue ( Math . abs ( value - expected ) < NUMBER_CONSTANT ) ; }
Math . sin ( i * Math.PI / n ) * ( f [ i ] + f [ n - i ] )
double scaling_coefficient = Math . sqrt ( NUMBER_CONSTANT / n ) ;
{ double scaling_coefficient = Math . sqrt ( NUMBER_CONSTANT / f.length ) ; return FastFourierTransformer . scaleArray ( fst ( f ) , scaling_coefficient ) ; }
i < Math . min ( rows , columns )
final double inv = NUMBER_CONSTANT / Math . sqrt ( norm2 ) ;
{ if ( Math . abs ( value - searchArray [ i ] ) < tolerance ) { found = true ; } i ++ ; }
if ( Math . abs ( x1 - x0 ) <= absoluteAccuracy ) { setResult ( x1 , i ) ; return x1 ; }
max = Math . max ( max , Math . abs ( delta ) ) ;
max = Math . max ( max , Math . abs ( delta ) ) ;
{ final double delta = data [ i ] - v [ i ] ; sum += Math . abs ( delta ) ; }
sum += Math . abs ( delta ) ;
return Math . sqrt ( sum ) ;
return Math . sqrt ( sum ) ;
for ( double a : data ) { max = Math . max ( max , Math . abs ( a ) ) ; }
for ( double a : data ) { sum += Math . abs ( a ) ; }
return Math . sqrt ( sum ) ;
{ data [ i ] = Math . ulp ( data [ i ] ) ; }
{ data [ i ] = Math . signum ( data [ i ] ) ; }
{ data [ i ] = Math . rint ( data [ i ] ) ; }
{ data [ i ] = Math . floor ( data [ i ] ) ; }
{ data [ i ] = Math . ceil ( data [ i ] ) ; }
{ data [ i ] = Math . cbrt ( data [ i ] ) ; }
{ data [ i ] = Math . sqrt ( data [ i ] ) ; }
{ data [ i ] = Math . abs ( data [ i ] ) ; }
{ data [ i ] = Math . atan ( data [ i ] ) ; }
{ data [ i ] = Math . asin ( data [ i ] ) ; }
{ data [ i ] = Math . acos ( data [ i ] ) ; }
{ data [ i ] = Math . tan ( data [ i ] ) ; }
{ data [ i ] = Math . sin ( data [ i ] ) ; }
{ data [ i ] = Math . cos ( data [ i ] ) ; }
{ data [ i ] = Math . tanh ( data [ i ] ) ; }
{ data [ i ] = Math . sinh ( data [ i ] ) ; }
{ data [ i ] = Math . cosh ( data [ i ] ) ; }
{ data [ i ] = Math . log1p ( data [ i ] ) ; }
{ data [ i ] = Math . log10 ( data [ i ] ) ; }
{ data [ i ] = Math . log ( data [ i ] ) ; }
{ data [ i ] = Math . expm1 ( data [ i ] ) ; }
{ data [ i ] = Math . exp ( data [ i ] ) ; }
{ data [ i ] = Math . pow ( data [ i ] , d ) ; }
{ stdDev [ i ] = Math . sqrt ( matrix . getEntry ( i , i ) ) ; }
{ assertTrue ( Math . abs ( value - expected ) < NUMBER_CONSTANT ) ; }
{ length = list . size () - Math . max ( NUMBER_CONSTANT , list . size () - windowSize ) ; }
assertEquals ( Math . exp ( NUMBER_CONSTANT ) , u . getGeometricMean () , NUMBER_CONSTANT ) ;
RealConvergenceChecker convergenceChecker
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
catch ( OptimizationException ee ) {}
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
catch ( OptimizationException e ) { assertTrue ( ( ! solvable ) && ( degree > NUMBER_CONSTANT ) ) ; }
public GoalType getGoalType () { return optimizationGoal ; }
assertTrue ( Double . isNaN ( product . getResult () ) ) ;
@ Override public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
public SumOfSquares () { n = NUMBER_CONSTANT ; value = Double.NaN ; }
@ Override public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
public Sum () { n = NUMBER_CONSTANT ; value = Double.NaN ; }
assertTrue ( Double . isNaN ( statistic . getResult () ) ) ;
assertTrue ( Double . isNaN ( statistic . getResult () ) ) ;
@ Override public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
public Product () { n = NUMBER_CONSTANT ; value = Double.NaN ; }
assertTrue ( Double . isNaN ( sumSq . getResult () ) ) ;
assertTrue ( Double . isNaN ( sum . getResult () ) ) ;
{ return NUMBER_CONSTANT + ( sign < < NUMBER_CONSTANT ) + ( nans < < NUMBER_CONSTANT ) + exp + mant . hashCode () ; }
@ Override protected int getNumberOfRegressors () { return x [ NUMBER_CONSTANT ] . length ; }
@ Override protected int getNumberOfRegressors () { return x [ NUMBER_CONSTANT ] . length ; }
final boolean isMinim = ( getGoalType () == GoalType.MINIMIZE ) ;
public Well44497b ( long seed ) { super ( seed ) ; }
{ super ( seed ) ; }
public Well44497b ( int seed ) { super ( seed ) ; }
public Well44497b () {}
public Well19937c ( long seed ) { super ( seed ) ; }
{ super ( seed ) ; }
public Well19937c ( int seed ) { super ( seed ) ; }
public Well19937c () {}
v [ indexRm2 ] &= mp ;
v [ indexRm2 ] &= mp ;
v [ indexRm2 ] &= mp ;
v [ indexRm2 ] &= mp ;
{ super ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , wrong , expected ) ; dimension = expected ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , columns ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIFFERENT_ROWS_LENGTHS , columns , length ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , columns ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIFFERENT_ROWS_LENGTHS , columns , length ) ; }
{ this ( p , new NormalDistributionImpl () ) ; }
dist . setMean ( NUMBER_CONSTANT ) ;
double density ( Double x ) ;
distribution . setDegreesOfFreedom ( df ) ;
{ distribution . setDegreesOfFreedom ( expected.length - NUMBER_CONSTANT ) ; return NUMBER_CONSTANT - distribution . cumulativeProbability ( chiSquare ( expected , observed ) ) ; }
( FastMath . max ( FastMath . abs ( mij ) , Math . abs ( mji ) ) * eps )
org.apache.commons.math.distribution.FDistributionImpl fd = new org.apache.commons.math.distribution.FDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( n > NUMBER_CONSTANT ) { distribution . setDegreesOfFreedom ( n - NUMBER_CONSTANT ) ; }
if ( n > NUMBER_CONSTANT ) { distribution . setDegreesOfFreedom ( n - NUMBER_CONSTANT ) ; }
protected AbstractContinuousDistribution () { super(); }
@ SuppressWarnings ( STRING_CONSTANT ) private RandomAdaptor () {}
return a . dotrap ( DfpField.FLAG_INVALID , STRING_CONSTANT , a , a . newInstance ( ( byte ) NUMBER_CONSTANT , ( byte ) Dfp.QNAN ) ) ;
if ( ia > NUMBER_CONSTANT ) { return a . newInstance ( ( byte ) NUMBER_CONSTANT , ( byte ) Dfp.INFINITE ) ; }
protected AbstractIntegerDistribution () { super(); }
public int [] getSizes () { return Arrays . copyOf ( size , dimension ) ; }
this . size = Arrays . copyOf ( size , dimension ) ;
public int [] getCounts () { return Arrays . copyOf ( counter , dimension ) ; }
final double [] d = Arrays . copyOf ( direc [ i ] , n ) ;
AbstractMultipleLinearRegression regression = ( AbstractMultipleLinearRegression ) createRegression () ;
{ try { ExponentialDistribution distribution = new ExponentialDistributionImpl ( NUMBER_CONSTANT ) ; } catch ( NotStrictlyPositiveException e ) {} }
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ realVectorFormat . parseObject ( STRING_CONSTANT ) ; }
{ UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
zb += ( za - temp2 ) ;
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
{ setQuantile ( p ) ; }
if ( isDefaultValue ( norm ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
{ this ( n , DEFAULT_RHO , DEFAULT_KHI , DEFAULT_GAMMA , DEFAULT_SIGMA ) ; }
public MultiDirectionalSimplex ( final int n ) { this ( n , DEFAULT_KHI , DEFAULT_GAMMA ) ; }
{ super ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ; dimension = expected ; }
catch ( InvalidMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
@ Test ( expected = NotPositiveDefiniteMatrixException . class )
@ Test ( expected = NotPositiveDefiniteMatrixException . class )
@ Test ( expected = NotSymmetricMatrixException . class )
catch ( InvalidMatrixException ime ) {}
catch ( FunctionEvaluationException ee ) { assertTrue ( shouldFail ) ; }
catch ( FunctionEvaluationException oe ) {}
try { es . getInverse () ; fail ( STRING_CONSTANT ) ; } catch ( InvalidMatrixException ime ) {}
catch ( InvalidMatrixException ime ) {}
catch ( NotPositiveDefiniteMatrixException e ) { fail ( STRING_CONSTANT ) ; }
public LaguerreSolver () { super ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; p = null ; }
{ return MessageFactory . buildMessage ( locale , pattern , LocalizedFormats.USER_EXCEPTION , arguments ) ; }
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
{ try { return mapToSelf ( ComposableFunction.ULP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TANH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SQRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SINH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIGNUM ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.RINT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
try { return mapToSelf ( BinaryFunction.POW . fix2ndArgument ( d ) ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; }
try { return mapToSelf ( BinaryFunction.MULTIPLY . fix1stArgument ( d ) ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; }
{ try { return mapToSelf ( ComposableFunction.LOG1P ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG10 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.INVERT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.FLOOR ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXPM1 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
try { return mapToSelf ( BinaryFunction.DIVIDE . fix2ndArgument ( d ) ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; }
{ try { return mapToSelf ( ComposableFunction.COSH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.COS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CEIL ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CBRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ATAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ACOS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ABS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( FunctionEvaluationException fe ) { assertTrue ( exceptionExpected ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
{ return x + y ; }
Circle circle = new Circle () ;
Circle circle = new Circle () ;
Circle circle = new Circle () ;
assertTrue ( handler . getMaximalValueError () < NUMBER_CONSTANT ) ;
ConvergenceException ex
public RealVector mapPowToSelf ( double d ) { return mapToSelf ( BinaryFunction.POW . fix2ndArgument ( d ) ) ; }
{ if ( d != NUMBER_CONSTANT ) { return mapToSelf ( BinaryFunction.ADD . fix1stArgument ( d ) ) ; } return this ; }
{ if ( ++ iterations > maxIterations ) { throw new OptimizationException ( new MaxIterationsExceededException ( maxIterations ) ) ; } }
{ throw new MaxIterationsExceededException ( maxIterations ) ; }
throw new MaxIterationsExceededException ( maximalIterationCount ) ;
if ( n >= maxIterations ) { throw new MaxIterationsExceededException ( maxIterations , LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION , x ) ; }
if ( dimension == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE , minSingularValue , singularValues [ NUMBER_CONSTANT ] ) ; }
{ return solve ( f , Double.NaN , Double.NaN , startValue ) ; }
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer msgBuffer = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer sb = new StringBuffer () ;
final StringBuffer buff = new StringBuffer ( STRING_CONSTANT ) ;
StringBuffer msgBuffer = new StringBuffer () ;
StringBuffer out = new StringBuffer ( msg ) ;
StringBuffer messageBuffer = new StringBuffer () ;
StringBuffer s = new StringBuffer () ;
StringBuffer buffer
StringBuffer outBuffer = new StringBuffer () ;
result = solver . solve ( f , min , max ) ;
Assert . assertEquals ( FastMath.PI , solver . solve ( f , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , solver . getAbsoluteAccuracy () ) ;
{ this ( new SimpleVectorialValueChecker () , Integer.MAX_VALUE ) ; }
{ this ( new SimpleScalarValueChecker () , Integer.MAX_VALUE ) ; }
try { StatUtils . min ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { StatUtils . max ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { StatUtils . mean ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p ) ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p ) ; }
catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
{ if ( a < NUMBER_CONSTANT ) { ret = a - b ; } else { throw new ArithmeticException ( msg ) ; } }
try { m . preMultiply ( new BlockRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . multiply ( new BlockRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( new BlockRealMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
{ try { UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {} }
{ try { UnivariateRealSolverUtils . solve ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail () ; } catch ( IllegalArgumentException ex ) {} }
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.OVERFLOW_IN_FRACTION , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
if ( begin + length > values.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END ) ; }
try { m . preMultiply ( new Array2DRowRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . multiply ( new Array2DRowRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( new Array2DRowRealMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
if ( x1 < x0 ) { throw new NumberIsTooSmallException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 , true ) ; }
if ( x1 < x0 ) { throw new NumberIsTooSmallException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 , true ) ; }
try { optimizer . getOptima () ; fail ( STRING_CONSTANT ) ; } catch ( IllegalStateException ise ) {}
@ Test ( expected = java.lang.IllegalArgumentException . class )
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
@ Test ( expected = java.lang.IllegalArgumentException . class )
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
formatDouble ( vector . getEntry ( i ) , format , toAppendTo , pos ) ;
{ return new RealVectorFormat ( getDefaultNumberFormat ( locale ) ) ; }
{ this ( prefix , suffix , separator , getDefaultNumberFormat () ) ; }
{ NumberFormat f = getDefaultNumberFormat ( locale ) ; return new ComplexFormat ( f ) ; }
public ComplexFormat ( String imaginaryCharacter ) { this ( imaginaryCharacter , getDefaultNumberFormat () ) ; }
{ return new Vector3DFormat ( getDefaultNumberFormat ( locale ) ) ; }
{ this ( prefix , suffix , separator , getDefaultNumberFormat () ) ; }
if ( ! found ) { Assert . fail ( msg + STRING_CONSTANT + ComplexFormat . formatComplex ( z ) ) ; }
Class type
{ this ( imaginaryCharacter , format , ( NumberFormat ) format . clone () ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
try { alg = MessageDigest . getInstance ( STRING_CONSTANT ) ; } catch ( NoSuchAlgorithmException ex ) { throw MathRuntimeException . createInternalError ( ex ) ; }
throw MathRuntimeException . createInternalError ( null ) ;
throw MathRuntimeException . createInternalError ( null ) ;
denseOutput = requiresDenseOutput () || ( ! eventsHandlersManager . isEmpty () ) ;
{ super . addStepHandler ( handler ) ; denseOutput = requiresDenseOutput () || ( ! eventsHandlersManager . isEmpty () ) ; initializeArrays () ; }
denseOutput = requiresDenseOutput () || ( ! eventsHandlersManager . isEmpty () ) ;
denseOutput = requiresDenseOutput () || ( ! eventsHandlersManager . isEmpty () ) ;
stepStart = acceptStep ( interpolator , stepHandlers , y , yDot , t ) ;
stepStart = acceptStep ( interpolator , stepHandlers , y , yDot , t ) ;
final double temp = sinEpsA * NUMBER_CONSTANT ;
final double tmp = hiPrec [ NUMBER_CONSTANT ] * NUMBER_CONSTANT ;
if ( x >= NUMBER_CONSTANT || x <= - NUMBER_CONSTANT ) { return x ; }
if ( y >= NUMBER_CONSTANT || y <= - NUMBER_CONSTANT ) { return pow ( - x , y ) ; }
final double epsilon = xa - EIGHTHES [ idx ] ;
final double epsilon = xa - EIGHTHES [ idx ] ;
final boolean fatal = false ;
final boolean fatal = true ;
if ( invx == NUMBER_CONSTANT ) { if ( x > NUMBER_CONSTANT ) { return y ; } else { return getSign ( y ) * Math.PI ; } }
if ( xa == NUMBER_CONSTANT ) { return leftPlane ? getSign ( xa ) * Math.PI : xa ; }
@ Test
{ return Math . round ( x ) ; }
public int [] getSizes () { return copyOf ( size , dimension ) ; }
this . size = copyOf ( size , dimension ) ;
public int [] getCounts () { return copyOf ( counter , dimension ) ; }
final double [] d = copyOf ( direc [ i ] , n ) ;
{ return oneWayAnova . anovaTest ( categoryData , alpha ) ; }
{ return oneWayAnova . anovaPValue ( categoryData ) ; }
{ return oneWayAnova . anovaFValue ( categoryData ) ; }
{ return unknownDistributionChiSquareTest . chiSquareTestDataSetsComparison ( observed1 , observed2 , alpha ) ; }
{ return unknownDistributionChiSquareTest . chiSquareTestDataSetsComparison ( observed1 , observed2 ) ; }
{ return unknownDistributionChiSquareTest . chiSquareDataSetsComparison ( observed1 , observed2 ) ; }
{ return chiSquareTest . chiSquareTest ( counts ) ; }
{ return chiSquareTest . chiSquareTest ( counts , alpha ) ; }
{ return chiSquareTest . chiSquareTest ( expected , observed ) ; }
{ return chiSquareTest . chiSquareTest ( expected , observed , alpha ) ; }
{ return chiSquareTest . chiSquare ( counts ) ; }
{ return chiSquareTest . chiSquare ( expected , observed ) ; }
{ return tTest . tTest ( sampleStats1 , sampleStats2 ) ; }
{ return tTest . tTest ( sampleStats1 , sampleStats2 , alpha ) ; }
{ return tTest . tTest ( sample1 , sample2 ) ; }
{ return tTest . tTest ( sample1 , sample2 , alpha ) ; }
{ return tTest . tTest ( mu , sampleStats ) ; }
{ return tTest . tTest ( mu , sampleStats , alpha ) ; }
{ return tTest . tTest ( mu , sample ) ; }
{ return tTest . tTest ( mu , sample , alpha ) ; }
{ return tTest . t ( sampleStats1 , sampleStats2 ) ; }
{ return tTest . t ( sample1 , sample2 ) ; }
{ return tTest . t ( mu , sampleStats ) ; }
{ return tTest . t ( mu , observed ) ; }
{ return tTest . pairedTTest ( sample1 , sample2 ) ; }
{ return tTest . pairedTTest ( sample1 , sample2 , alpha ) ; }
{ return tTest . pairedT ( sample1 , sample2 ) ; }
{ return tTest . homoscedasticTTest ( sampleStats1 , sampleStats2 ) ; }
{ return tTest . homoscedasticTTest ( sample1 , sample2 ) ; }
{ return tTest . homoscedasticTTest ( sample1 , sample2 , alpha ) ; }
{ return tTest . homoscedasticT ( sampleStats1 , sampleStats2 ) ; }
{ return tTest . homoscedasticT ( sample1 , sample2 ) ; }
protected TestUtils () { super(); }
return ( double ) y ;
RealMatrix arzneg = selectColumns ( arz , Arrays . copyOf ( arReverseIndex , mu ) ) ;
statesInitialized = false ;
statesInitialized = false ;
statesInitialized = false ;
double numer = ( bits & NUMBER_CONSTANT ) ;
statesInitialized = false ;
statesInitialized = false ;
final ParametricRealFunction f
final ParametricRealFunction f
final ParametricRealFunction f
ParametricRealFunction sif = new SimpleInverseFunction () ;
ParametricRealFunction sif = new SimpleInverseFunction () ;
final double g = Gaussian . this . value ( x ) ;
{ fitter = new CurveFitter ( optimizer ) ; }
final boolean fatal = false ;
{ super ( null , specific , LocalizedFormats.ILLEGAL_STATE , args ) ; }
{ super ( null , null , specific , general , args ) ; }
{ super ( null , null , LocalizedFormats.CANNOT_PARSE , wrong , new Integer ( position ) ) ; }
{ assertEquals ( reference , p . toString () ) ; }
assertEquals ( reference , p . multiply ( q ) . toString () ) ;
{ assertEquals ( reference , p . toString () ) ; }
this . n = n ;
return isMinimize ? penalty : - penalty ;
if ( boundaries == null ) return true ;
return _isMinimize ? penalty : - penalty ;
if ( _boundaries == null ) return true ;
final FitnessFunction fitfun = new FitnessFunction ( boundaries , isMinimize ) ;
{ super ( specific , LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ; dimension = expected ; }
public ZeroException ( Localizable specific ) { super ( specific , LocalizedFormats.ZERO_NOT_ALLOWED , NUMBER_CONSTANT ) ; }
if ( result == - NUMBER_CONSTANT ) { throw new MathArithmeticException ( STRING_CONSTANT ) ; }
super ( specific , LocalizedFormats.SAME_SIGN_AT_ENDPOINTS , lo , hi , fLo , fHi , args ) ;
{ this ( null , lo , hi , fLo , fHi ) ; }
{ super ( null , null , LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
{ super ( specific , LocalizedFormats.NOT_FINITE_NUMBER , wrong , args ) ; }
{ this ( null , wrong , args ) ; }
public MathInternalError ( final Throwable cause ) { super ( LocalizedFormats.INTERNAL_ERROR , REPORT_URL ) ; }
{ super ( specific , LocalizedFormats.MAX_COUNT_EXCEEDED , max , args ) ; this . max = max ; }
public MaxCountExceededException ( Number max ) { this ( null , max ) ; }
catch ( IOException ioe ) { assertEquals ( NUMBER_CONSTANT , ioe . getMessage () . length () ) ; }
super ( specific , boundIsAllowed ? LocalizedFormats.NUMBER_TOO_SMALL : LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED , wrong , min ) ;
{ this ( null , wrong , min , boundIsAllowed ) ; }
{ super ( specific , LocalizedFormats.OUT_OF_RANGE_SIMPLE , wrong , lo , hi ) ; this . lo = lo ; this . hi = hi ; }
{ this ( null , wrong , lo , hi ) ; }
{ this ( cause , LocalizedFormats.USER_EXCEPTION ) ; }
super ( specific , LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ;
{ this ( null , wrong , expected ) ; }
{ super ( specific , LocalizedFormats.NO_DATA , ( Object [] ) null ) ; }
super ( specific , boundIsAllowed ? LocalizedFormats.NUMBER_TOO_LARGE : LocalizedFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED , wrong , max ) ;
{ this ( null , wrong , max , boundIsAllowed ) ; }
{ ++ count ; assertEquals ( i + j / NUMBER_CONSTANT , value , NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
{ assertEquals ( NUMBER_CONSTANT , l . getEntry ( i , j ) , NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
{ ++ count ; assertEquals ( i + j / NUMBER_CONSTANT , value , NUMBER_CONSTANT ) ; }
{ assertEquals ( NUMBER_CONSTANT , m . getEntry ( i , j ) , NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
@ Override protected void doFinalize ( ) throws MathUserException { throw new MathUserException ( LocalizedFormats.SIMPLE_MESSAGE , null ) ; }
@ Override protected void doFinalize ( ) throws MathUserException { throw new MathUserException () ; }
catch ( IOException ioe ) {}
{ super ( cause ) ; addMessage ( LocalizedFormats.USER_EXCEPTION , null ) ; }
private Beta () { super(); }
private Gamma () { super(); }
private Erf () { super(); }
@ Override public void setUp () { f = new Frequency () ; }
assertTrue ( bestFinal . compareTo ( bestInitial ) > NUMBER_CONSTANT ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
{ ComplexField field = ComplexField . getInstance () ; assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { assertEquals ( Complex.ONE , ComplexField . getInstance () . getOne () ) ; }
@ Test public void testZero () { assertEquals ( Complex.ZERO , ComplexField . getInstance () . getZero () ) ; }
{ assertEquals ( a1 , MathUtils . normalizeAngle ( a2 , a1 ) , NUMBER_CONSTANT ) ; }
assertEquals ( p , TestUtils . serializeAndRecover ( p ) ) ;
@ Override
@ Override public void tearDown () { pb = null ; integ = null ; }
@ Override
assertTrue ( FastMath . abs ( h ) < minStep ) ;
assertEquals ( STRING_CONSTANT , s . getN () , u . getN () ) ;
{ double variance = regression . estimateRegressandVariance () ; assertTrue ( variance > NUMBER_CONSTANT ) ; }
{ double [] [] variance = regression . estimateRegressionParametersVariance () ; assertEquals ( getNumberOfRegressors () , variance.length ) ; }
{ double [] e = regression . estimateResiduals () ; assertEquals ( getSampleSize () , e.length ) ; }
{ double [] beta = regression . estimateRegressionParameters () ; assertEquals ( getNumberOfRegressors () , beta.length ) ; }
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
assertEquals ( c3 , population . getFittestChromosome () ) ;
assertTrue ( uniquePointIsCenter ) ;
if ( isLast ) { assertTrue ( maxError > NUMBER_CONSTANT ) ; }
@ Override
assertEquals ( approYDot , yDot [ i ] , threshold ) ;
assertEquals ( NUMBER_CONSTANT , changes ) ;
try { new Fraction ( a , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( ConvergenceException ce ) {}
fail ( STRING_CONSTANT ) ;
{ DummyRandomKey drk = new DummyRandomKey ( RandomKey . randomPermutation ( NUMBER_CONSTANT ) ) ; assertNotNull ( drk ) ; }
catch ( FractionConversionException fce ) { fail ( fce . getMessage () ) ; }
catch ( FractionConversionException fce ) { fail ( fce . getMessage () ) ; }
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
{ assertEquals ( y [ i ] , iResult [ i ] ) ; }
assertTrue ( maxError < NUMBER_CONSTANT ) ;
protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertTrue ( Double . isNaN ( statistic . getResult () ) ) ; }
if ( isLast ) { assertTrue ( maxError > NUMBER_CONSTANT ) ; }
{ BigRealField field = BigRealField . getInstance () ; assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { assertEquals ( BigReal.ONE , BigRealField . getInstance () . getOne () ) ; }
@ Test public void testZero () { assertEquals ( BigReal.ZERO , BigRealField . getInstance () . getZero () ) ; }
assertEquals ( STRING_CONSTANT + p , expected , actual , NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT + x , expected , actual , NUMBER_CONSTANT ) ;
if ( isLast ) { assertTrue ( maxError > NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , numDifferent ) ;
assertTrue ( fitnessCalls <= neededCalls ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
@ Override public void tearDown () { pb = null ; integ = null ; }
@ Override
{ FractionField field = FractionField . getInstance () ; assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { assertEquals ( Fraction.ONE , FractionField . getInstance () . getOne () ) ; }
@ Test public void testZero () { assertEquals ( Fraction.ZERO , FractionField . getInstance () . getZero () ) ; }
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
assertEquals ( expected . getN () , observed . getN () ) ;
@ Override public void setUp () { tooShortStats = new SummaryStatistics () ; tooShortStats . addValue ( NUMBER_CONSTANT ) ; }
{ assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ assertEquals ( null , expected , actual , delta ) ; }
{ try { new DummyBinaryChromosome ( repr ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException e ) {} }
assertEquals ( NUMBER_CONSTANT , nextGeneration . getPopulationSize () ) ;
@ Override public void tearDown () { refValues = null ; matrix = null ; }
@ Override
{ assertTrue ( isIncludedColumn ( eigenVector , ed . getV () , tolerance ) ) ; }
{ if ( column > row ) { assertEquals ( NUMBER_CONSTANT , value , entryTolerance ) ; } }
{ if ( column < row ) { assertEquals ( NUMBER_CONSTANT , value , entryTolerance ) ; } }
assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
{ BigFractionField field = BigFractionField . getInstance () ; assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { assertEquals ( BigFraction.ONE , BigFractionField . getInstance () . getOne () ) ; }
@ Test public void testZero () { assertEquals ( BigFraction.ZERO , BigFractionField . getInstance () . getZero () ) ; }
assertEquals ( STRING_CONSTANT , s . getN () , u . getN () ) ;
public NoDataException ( Localizable specific ) { super ( specific , null ) ; }
double [] param
double [] param
double [] param
double [] param
double [] param
double [] param
double [] doubles
double [] parameters
double [] param
double [] param
double [] param
double [] param
final double [] parameters
double [] parameters
public void setMinimalIterationCount ( int count ) { minimalIterationCount = count ; }
UnivariateRealIntegrator integrator = new LegendreGaussIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final double [] z = concatinateSamples ( x , y ) ;
public Set < String > getContextKeys () { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
public Object getContext ( String key ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
public Set < String > getContextKeys () { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
public Object getContext ( String key ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
public double getRelativeAccuracy ( ) ;
public double getAbsoluteAccuracy ( ) ;
public int getMaximalIterationCount ( ) ;
Assert . assertEquals ( new PearsonsCorrelation () . correlation ( x , y ) , corrInstance . getCorrelationMatrix () . getEntry ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , Double.MIN_VALUE ) ;
{ new PearsonsCorrelation () . correlation ( one , two ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertTrue ( Double . isNaN ( new PearsonsCorrelation () . correlation ( noVariance , values ) ) ) ;
Assert . assertEquals ( PearsonsCorrelation . correlation ( x , y ) , corrInstance . getCorrelationMatrix () . getEntry ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , Double.MIN_VALUE ) ;
{ PearsonsCorrelation . correlation ( one , two ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertTrue ( Double . isNaN ( PearsonsCorrelation . correlation ( noVariance , values ) ) ) ;
normps = norm ( ps ) ;
normps = norm ( ps ) ;
{ this ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; }
final SimplexTableau tableau = new SimplexTableau ( function , linearConstraints , goal , nonNegative , epsilon ) ;
if ( MathUtils . compareTo ( entry , minValue , getEpsilon ( entry ) ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
if ( MathUtils . compareTo ( entry , NUMBER_CONSTANT , getEpsilon ( entry ) ) > NUMBER_CONSTANT ) { columnsToDrop . add ( i ) ; }
{ addMessage ( pattern , args ) ; }
{ addMessage ( pattern , args ) ; }
{ super ( cause ) ; addMessage ( pattern , args ) ; }
{ addMessage ( pattern , args ) ; }
{ addMessage ( LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
{ addMessage ( pattern , args ) ; }
{ super ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; this . max = max ; }
{ super ( LocalizedFormats.EVALUATIONS , max ) ; }
{ addMessage ( pattern , args ) ; }
{ super ( cause ) ; addMessage ( pattern , arguments ) ; }
{ addMessage ( pattern , arguments ) ; }
{ super ( cause ) ; addMessage ( LocalizedFormats.USER_EXCEPTION ) ; }
this . field = data [ NUMBER_CONSTANT ] . getField () ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayRealVector ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new Array2DRowFieldMatrix < T > ( outData , false ) ;
{ super ( extractField ( d ) ) ; copyIn ( d ) ; }
return new ArrayFieldVector < T > ( outData , false ) ;
return new ArrayFieldVector < T > ( outData , false ) ;
return new Array2DRowFieldMatrix < T > ( d , false ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
Assert . assertEquals ( new Array2DRowFieldMatrix < Fraction > ( fractionColMatrix ) , MatrixUtils . createFieldMatrix ( fractionColMatrix ) ) ;
return new Array2DRowFieldMatrix < T > ( bp , false ) ;
return new ArrayFieldVector < T > ( bp , false ) ;
return new Array2DRowFieldMatrix < BigFraction > ( Hdata ) ;
return new Array2DRowFieldMatrix < T > ( outData , false ) ;
return new Array2DRowFieldMatrix < T > ( outData , false ) ;
{ return projection ( new ArrayFieldVector < T > ( v , false ) ) ; }
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix < Fraction > ( testDataInv ) ) , identity , entryTolerance ) ;
String source
{ this ( prefix , suffix , separator , CompositeFormat . getDefaultNumberFormat () ) ; }
public Vector3DFormat ( final NumberFormat format ) { this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_SEPARATOR , format ) ; }
public Vector3DFormat () { this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_SEPARATOR , CompositeFormat . getDefaultNumberFormat () ) ; }
Hyperplane other
Point point
final BSPTreeVisitor visitor
void visitLeafNode ( BSPTree node ) ;
BSPTree node
BSPTree node
public Order visitOrder ( final BSPTree node ) { return Order.MINUS_SUB_PLUS ; }
final BSPTree tree
final Point2D tmp = loop [ min ] ;
final Point2D [] bLoop
final Hyperplane other
final Point point
final Point3D p
origin = new Point3D ( - originOffset , w ) ;
public Order visitOrder ( final BSPTree node ) { return Order.MINUS_SUB_PLUS ; }
public BoundaryProjector () { projected = new PolygonsSet ( new BSPTree ( Boolean.FALSE ) ) ; }
final Point2D p
final Hyperplane other
final Point2D p
public Order visitOrder ( final BSPTree node ) { return Order.MINUS_SUB_PLUS ; }
final BSPTree tree
final BSPTree tree
Point3D point = p . intersection ( l ) ;
Point3D [] points
final Hyperplane other
public abstract SplitSubHyperplane < S > split ( Hyperplane < S > hyperplane ) ;
public abstract Side side ( Hyperplane < S > hyperplane ) ;
{ if ( in [ i ] < NUMBER_CONSTANT ) { throw new NotPositiveException ( in [ i ] ) ; } }
{ if ( val < NUMBER_CONSTANT || val > NUMBER_CONSTANT ) { throw new InvalidRepresentationException ( STRING_CONSTANT ) ; } }
for ( int i : chromosomeRepresentation ) { if ( i < NUMBER_CONSTANT || i > NUMBER_CONSTANT ) throw new InvalidRepresentationException ( STRING_CONSTANT ) ; }
clusters = transformer . cluster ( Arrays . asList ( points ) , NUMBER_CONSTANT , NUMBER_CONSTANT )
public RealVector getInitialStateEstimate () { return initialStateEstimate ; }
{ numElements -= i ; if ( front ) startIndex += i ; }
{ for ( Chromosome anotherChr : population ) { if ( this . isSame ( anotherChr ) ) return anotherChr ; } return null ; }
if ( remA > NUMBER_CONSTANT ) break;
if ( remA > NUMBER_CONSTANT ) break;
if ( remA > NUMBER_CONSTANT ) break;
if ( x * x == NUMBER_CONSTANT ) return Double.NaN ;
if ( t == NUMBER_CONSTANT && i >= j ) continue;
if ( boundaries == null ) return x ;
if ( boundaries == null ) return x ;
if ( negccov > negcovMax ) negccov = negcovMax ;
if ( y . equals ( py ) ) break;
if ( x < NUMBER_CONSTANT ) return NUMBER_CONSTANT ;
if ( ! forward ) h = - h ;
{ if ( maxGenerations <= NUMBER_CONSTANT ) throw new IllegalArgumentException ( STRING_CONSTANT ) ; this . maxGenerations = maxGenerations ; }
{ super ( relativeAccuracy , absoluteAccuracy , Method.SECANT ) ; }
public SecantSolver ( final double absoluteAccuracy ) { super ( absoluteAccuracy , Method.SECANT ) ; }
{ this . allowedSolutions = allowedSolutions ; return super . solve ( maxEval , f , min , max , startValue ) ; }
{ super ( relativeAccuracy , absoluteAccuracy ) ; this . allowedSolutions = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ super ( absoluteAccuracy ) ; this . allowedSolutions = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ se [ i ] = FastMath . sqrt ( rank ) ; continue; }
if ( ! Double . isNaN ( var ) && var > Double.MIN_VALUE ) { return FastMath . sqrt ( rank ) ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
{ if ( isNaN () ) { return Complex.NaN ; } return createComplex ( FastMath . log ( abs () ) , FastMath . atan2 ( imaginary , real ) ) ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () || rhs . isNaN () ) { return NaN ; }
{ if ( isNaN () ) { return NaN ; } return createComplex ( - real , - imaginary ) ; }
if ( isNaN () || Double . isNaN ( rhs ) ) { return NaN ; }
if ( isNaN () || rhs . isNaN () ) { return NaN ; }
if ( isNaN () ) { return NUMBER_CONSTANT ; }
if ( isNaN () || rhs . isNaN () ) { return NaN ; }
{ if ( isNaN () ) { return NaN ; } return createComplex ( real , - imaginary ) ; }
if ( isNaN () ) { return Double.NaN ; }
{ if ( rng . nextBoolean () ) { throw new MathRuntimeException () ; } }
Assert . assertEquals ( w . getReal () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ include ( Arrays . copyOf ( x , x.length ) , NUMBER_CONSTANT , y ) ; }
if ( index < NUMBER_CONSTANT || index >= this . parameters . length ) { throw new IndexOutOfBoundsException ( STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT || index >= this . parameters . length ) { throw new IndexOutOfBoundsException ( STRING_CONSTANT ) ; }
{ return outerProduct ( ( ArrayRealVector ) v ) ; }
{ return getLInfDistance ( ( ArrayRealVector ) v ) ; }
{ return getL1Distance ( ( ArrayRealVector ) v ) ; }
{ return getDistance ( ( ArrayRealVector ) v ) ; }
{ return dotProduct ( ( ArrayRealVector ) v ) ; }
{ return ebeDivide ( ( ArrayRealVector ) v ) ; }
{ return ebeMultiply ( ( ArrayRealVector ) v ) ; }
{ return subtract ( ( ArrayRealVector ) v ) ; }
{ return add ( ( ArrayRealVector ) v ) ; }
{ super ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , Method.PEGASUS ) ; }
Assert . assertTrue ( z . isNaN () ) ;
{ return ( ( Integer ) node . getElement () ) . intValue () ; }
if ( numberOfVariables < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BrentSolver ( convergence ) ) ; }
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolutions.ABOVE_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolutions.BELOW_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolutions.RIGHT_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolutions.LEFT_SIDE ) ;
this . allowed = AllowedSolutions.ANY_SIDE ;
this . allowed = AllowedSolutions.ANY_SIDE ;
this . allowed = AllowedSolutions.ANY_SIDE ;
{ return solve ( maxEval , f , min , max , startValue , AllowedSolutions.ANY_SIDE ) ; }
{ super ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ super ( relativeAccuracy , absoluteAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ super ( absoluteAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
double x = FastMath . random () ;
double dot = dotProduct ( v1 , v2 ) ;
{ return new Solver ( singularValues , getUT () , getV () , getRank () == Math . max ( m , n ) ) ; }
tol = FastMath . max ( FastMath . max ( m , n ) * singularValues [ NUMBER_CONSTANT ] * EPS , FastMath . sqrt ( MathUtils.SAFE_MIN ) ) ;
{ super . setEntry ( row - NUMBER_CONSTANT , col - NUMBER_CONSTANT , value ) ; }
{ super . setEntry ( index - NUMBER_CONSTANT , value ) ; }
fsave = fval . getEntry ( NUMBER_CONSTANT ) ;
{ return Vector3D . dotProduct ( ( Vector3D ) point , w ) + originOffset ; }
{ setNormal ( normal ) ; originOffset = - Vector3D . dotProduct ( p , w ) ; setFrame () ; }
final Vector3D n = new Vector3D ( NUMBER_CONSTANT , d , - Vector3D . dotProduct ( d , direction ) , direction ) ;
Vector3D . dotProduct ( crossP , otherPlane . getNormal () ) < NUMBER_CONSTANT
Vector3D . dotProduct ( crossP , otherPlane . getNormal () ) < NUMBER_CONSTANT
double scaled = area * Vector3D . dotProduct ( facetB , plane . getNormal () ) ;
public Line revert () { return new Line ( zero , direction . negate () ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS , nRows , nCols ) ; }
if ( ( delta <= rLimit ) || ( delta <= absoluteAccuracy ) ) { setResult ( t ) ; return result ; }
if ( ( delta <= rLimit ) || ( delta <= absoluteAccuracy ) ) { setResult ( s ) ; return result ; }
{ setResult ( t ) ; return result ; }
RealVector v = AbstractRealVector . unmodifiableRealVector ( u . copy () ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u . copy () ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u ) ;
final double [] actual = x . getData () ;
final double [] actual = z . getData () ;
double [] d2 = w . getData () ;
{ return coefficients . dotProduct ( point ) + constantTerm ; }
final RealVector x = new ArrayRealVector ( dim ) ;
final RealVector x = new ArrayRealVector ( dim ) ;
dist = new EmpiricalDistributionImpl ( NUMBER_CONSTANT , null ) ;
empiricalDistribution = new EmpiricalDistributionImpl ( binCount ) ;
public EmpiricalDistributionImpl ( int binCount ) { this ( binCount , null ) ; }
return NUMBER_CONSTANT * ( NUMBER_CONSTANT + Erf . erf ( dev / ( standardDeviation * FastMath . sqrt ( NUMBER_CONSTANT ) ) ) ) ;
{ setConvergenceChecker ( new SimpleScalarValueChecker ( rel , abs ) ) ; }
@ Test ( expected = TooManyEvaluationsException . class )
{ solver . solve ( b . getColumn ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ solver . solve ( b . getColumn ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ es . solve ( b . getColumn ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ solver . solve ( b . getColumn ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertEquals ( z , Complex.NaN ) ;
Assert . assertEquals ( z , Complex.INF ) ;
final ExceptionContext cOut = new ExceptionContext () ;
final ExceptionContext cOut = new ExceptionContext () ;
final ExceptionContext c = new ExceptionContext () ;
final ExceptionContext c = new ExceptionContext () ;
final ExceptionContext c = new ExceptionContext () ;
@ Test ( expected = MathUserException . class )
@ Test ( expected = MathUserException . class )
MathUserException e
MathUserException e
int i = NUMBER_CONSTANT
public double [] getStateEstimation () { return stateEstimation . getData () ; }
assertClose ( m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
double [] hatResiduals = I . subtract ( hat ) . operate ( model.Y ) . getData () ;
TestUtils . assertEquals ( new double [] { - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , b . getData () , NUMBER_CONSTANT ) ;
TestUtils . assertEquals ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , - NUMBER_CONSTANT , NUMBER_CONSTANT } , b . getData () , NUMBER_CONSTANT ) ;
final double objectiveValue = computeObjectiveValue ( currentBest . getData () ) ;
f = computeObjectiveValue ( currentBest . getData () ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
if ( x instanceof ArrayRealVector ) { return ( ( ArrayRealVector ) x ) . getDataRef () ; } else { return x . getData () ; }
return e . getData () ;
{ RealVector b = calculateBeta () ; return b . getData () ; }
double [] y = u . add ( x . operate ( b ) ) . getData () ;
final double [] actual = x . getData () ;
final double [] actual = x . getData () ;
final double [] actual = x . combine ( a , b , y ) . getData () ;
final double [] actual = x . combine ( a , b , y ) . getData () ;
Assert . assertNotSame ( STRING_CONSTANT , v1.data , v_copy . getData () ) ;
final double [] x = b . getData () ;
{ double sum = NUMBER_CONSTANT ; for ( double coefficient : coefficients . getData () ) { sum -= coefficient ; } return sum ; }
if ( ltI [ i ] < absolutePositivityThreshold ) { throw new NonPositiveDefiniteMatrixException ( i , absolutePositivityThreshold ) ; }
{ return getIntercept ( getSlope () ) ; }
int i = FACT_LEN - NUMBER_CONSTANT
int i = FACT_LEN - NUMBER_CONSTANT
int i = FACT_LEN - NUMBER_CONSTANT
CholeskyDecomposition llt = new CholeskyDecompositionImpl ( matrix ) ;
CholeskyDecomposition llt = new CholeskyDecompositionImpl ( matrix ) ;
DecompositionSolver solver = new CholeskyDecompositionImpl ( s ) . getSolver () ;
DecompositionSolver solver = new CholeskyDecompositionImpl ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = new CholeskyDecompositionImpl ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
final RealMatrix matrix = EigenDecompositionImplTest . createTestMatrix ( new Random ( NUMBER_CONSTANT ) , refValues ) ;
EigenDecomposition eig = new EigenDecompositionImpl ( C , NUMBER_CONSTANT ) ;
EigenDecompositionImpl ed
EigenDecompositionImpl ed
RealMatrix v = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) . getV () ;
DecompositionSolver es = new EigenDecompositionImpl ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecompositionImpl ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecompositionImpl ( m , MathUtils.SAFE_MIN ) . getSolver () ;
EigenDecompositionImpl eig = new EigenDecompositionImpl ( C , NUMBER_CONSTANT ) ;
int max = val.length ;
int max = val.length ;
int max = val.length ;
throw new IllegalArgumentException () ;
throw new IllegalArgumentException () ;
throw new IllegalArgumentException () ;
throw new IllegalArgumentException () ;
double slope
double slope
double alpha
FieldDecompositionSolver < BigFraction > pSolver = new FieldLUDecompositionImpl < BigFraction > ( bigP ) . getSolver () ;
{ return new FieldLUDecompositionImpl < Fraction > ( m ) . getDeterminant () . doubleValue () ; }
solver = new FieldLUDecompositionImpl < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
solver = new FieldLUDecompositionImpl ( createFractionMatrix ( singular ) ) . getSolver () ;
solver = new FieldLUDecompositionImpl < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
catch ( NonMonotonousSequenceException iae ) {}
@ Test ( expected = NonMonotonousSequenceException . class )
catch ( NonMonotonousSequenceException iae ) {}
@ Test ( expected = NonMonotonousSequenceException . class )
@ Test ( expected = NonMonotonousSequenceException . class )
@ Test ( expected = NonMonotonousSequenceException . class )
DecompositionSolver solver = useLU ? new LUDecompositionImpl ( mA ) . getSolver () : new QRDecompositionImpl ( mA ) . getSolver () ;
return new LUDecompositionImpl ( XTOIX ) . getSolver () . getInverse () ;
RealMatrix inverse = new LUDecompositionImpl ( XTOIX ) . getSolver () . getInverse () ;
final DecompositionSolver solver = new LUDecompositionImpl ( MatrixUtils . createRealMatrix ( jTj ) , threshold ) . getSolver () ;
DecompositionSolver solver = new LUDecompositionImpl ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = new LUDecompositionImpl ( MatrixUtils . createRealMatrix ( singular ) ) . getSolver () ;
DecompositionSolver solver = new LUDecompositionImpl ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
RealMatrix Rinv = new LUDecompositionImpl ( Raug ) . getSolver () . getInverse () ;
DecompositionSolver solver = useLU ? new LUDecomposition ( mA ) . getSolver () : new QRDecompositionImpl ( mA ) . getSolver () ;
RealMatrix x = new QRDecompositionImpl ( a ) . getSolver () . solve ( b ) ;
RealMatrix x = new QRDecompositionImpl ( a ) . getSolver () . solve ( b ) ;
DecompositionSolver solver = new QRDecompositionImpl ( MatrixUtils . createRealMatrix ( testData3x3Singular ) ) . getSolver () ;
DecompositionSolver solver = new QRDecompositionImpl ( MatrixUtils . createRealMatrix ( testData3x3NonSingular ) ) . getSolver () ;
{ super . newXSampleData ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecompositionImpl ( X ) ; }
final RectangularCholeskyDecomposition decomposition = new RectangularCholeskyDecompositionImpl ( covariance , small ) ;
final RectangularCholeskyDecomposition decomposition = new RectangularCholeskyDecompositionImpl ( covariance , small ) ;
SingularValueDecomposition svd = new SingularValueDecompositionImpl ( rm ) ;
DecompositionSolver solver = new SingularValueDecompositionImpl ( MatrixUtils . createRealMatrix ( testSquare ) ) . getSolver () ;
DecompositionSolver solver = new SingularValueDecompositionImpl ( m ) . getSolver () ;
DecompositionSolver solver = new SingularValueDecompositionImpl ( MatrixUtils . createRealMatrix ( testSquare ) ) . getSolver () ;
{ g0Positive = g0 >= NUMBER_CONSTANT ; nextAction = EventHandler.CONTINUE ; }
nextAction = EventHandler.CONTINUE ;
final FirstOrderDifferentialEquations equations
final FirstOrderDifferentialEquations equations
FirstOrderDifferentialEquations equations
{ out . writeDouble ( polynoms [ k ] [ l ] ) ; }
final double e = polynoms [ currentDegree ] [ i ] / scale [ i ] ;
{ return ( T [] ) Array . newInstance ( field . getZero () . getClass () , length ) ; }
( T [] [] ) Array . newInstance ( zero . getClass () , new int [] { dimension , dimension } )
{ return ( T [] ) Array . newInstance ( field . getZero () . getClass () , length ) ; }
{ return ( T [] ) Array . newInstance ( field . getZero () . getClass () , length ) ; }
array = ( T [] ) Array . newInstance ( field . getZero () . getClass () , length )
Array . newInstance ( field . getZero () . getClass () , new int [] { m , nColB } )
bp = ( T [] ) Array . newInstance ( field . getZero () . getClass () , m )
bp = ( T [] ) Array . newInstance ( field . getZero () . getClass () , m )
{ return ( T [] ) Array . newInstance ( field . getZero () . getClass () , length ) ; }
solver . solve ( a , b , null , false ) ;
final RealVector x = solver . solve ( a , m , b , null , false ) ;
final RealVector x = solver . solve ( a , m , b , null , false ) ;
solver . solve ( a , m , b , null , false ) ;
solver . solve ( a , m , b , null , false ) ;
solver . solve ( a , m , b , null , false ) ;
final RealVector x = solver . solve ( a , b , null , false ) ;
final RealVector x = solver . solve ( a , b , x0 , false ) ;
final RealVector x = solver . solve ( a , b , x0 , true ) ;
final RealVector x = solver . solve ( a , b , null , false ) ;
solver . solve ( a , b , x , false ) ;
solver . solve ( a , b , x , false ) ;
solver . solve ( a , b , x , false ) ;
solver . solve ( a , b , x , false ) ;
if ( nSteps <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS , name ) ; }
throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED , n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
catch ( ArithmeticException e ) {}
catch ( ParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
catch ( ParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
try { f1 . divide ( f2 ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( ArithmeticException ex ) {}
catch ( ParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
catch ( ParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
{ if ( getN () > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC , getN () ) ; } }
if ( i < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INDEX_NOT_POSITIVE , i ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INITIAL_CAPACITY_NOT_POSITIVE , initialCapacity ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.UNSUPPORTED_EXPANSION_MODE , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( LocalizedFormats.CANNOT_SET_AT_NEGATIVE_INDEX , index ) ; }
catch ( ClassCastException ex ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES , v . getClass () . getName () ) ; }
MathException cause = new MathConfigurationException ( inMsg ) ;
{ evaluations . incrementCount () ; equations . computeDerivatives ( t , y , yDot ) ; }
{ this . equations = equations ; }
allocateInterpolatedArrays ( y.length , primaryMapper , secondaryMappers ) ;
allocateInterpolatedArrays ( - NUMBER_CONSTANT , null , null ) ;
catch ( MathException ex ) { Assert . fail ( STRING_CONSTANT + mean + STRING_CONSTANT + p + STRING_CONSTANT + ex . getMessage () ) ; }
catch ( MathException ex ) { Assert . fail ( STRING_CONSTANT + mean + STRING_CONSTANT + x + STRING_CONSTANT + ex . getMessage () ) ; }
@ Test ( expected = NonPositiveDefiniteLinearOperatorException . class )
@ Test ( expected = NonSquareLinearOperatorException . class )
@ Test ( expected = NonPositiveDefiniteLinearOperatorException . class )
@ Test ( expected = NonSquareLinearOperatorException . class )
if ( ( str = filePointer . readLine () ) == null ) { throw MathRuntimeException . createEOFException ( LocalizedFormats.URL_CONTAINS_NO_DATA , valuesFileURL ) ; }
if ( ( empiricalDistribution == null ) || ( empiricalDistribution . getBinStats () . size () == NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.DIGEST_NOT_INITIALIZED ) ; }
if ( sampleStats . getN () == NUMBER_CONSTANT ) { throw MathRuntimeException . createEOFException ( LocalizedFormats.URL_CONTAINS_NO_DATA , url ) ; }
catch ( IOException e ) { throw new MathRuntimeException ( e ) ; }
catch ( EOFException eof ) {}
catch ( EOFException eof ) {}
final ArrayList < BigFraction > coefficients
final ArrayList < BigFraction > coefficients
double y = x * NUMBER_CONSTANT - NUMBER_CONSTANT ;
{ Assert . assertTrue ( MathUtils . equals ( out [ i ] , expectedSample [ i ] , NUMBER_CONSTANT ) ) ; }
if ( MathUtils . compareTo ( entry , minValue , maxUlps ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
isLastStep = isLastStep || MathUtils . equals ( currentT , tEnd , NUMBER_CONSTANT ) ;
Assert . assertTrue ( MathUtils . equals ( NUMBER_CONSTANT , MathUtils . distanceInf ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( MathUtils . equals ( NUMBER_CONSTANT , MathUtils . distance ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( MathUtils . equals ( NUMBER_CONSTANT , MathUtils . distance ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( MathUtils . equals ( NUMBER_CONSTANT , MathUtils . distance1 ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( MathUtils . equals ( binomial , jacobi . value ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ) ;
if ( FastMath . abs ( m ) <= tol || MathUtils . equals ( fb , NUMBER_CONSTANT ) ) { return b ; }
if ( mode == StepNormalizerMode.MULTIPLES && MathUtils . equals ( nextTime , lastTime , NUMBER_CONSTANT ) ) { nextTime += h ; }
! MathUtils . equalsIncludingNaN ( expected [ i ] , observed [ i ] , tolerance )
for ( double value : values ) { if ( MathUtils . equals ( value , x , epsilon ) ) { return; } }
MathUtils . equalsIncludingNaN ( stat . getN () , getN () )
if ( MathUtils . compareTo ( entry , NUMBER_CONSTANT , epsilon ) < NUMBER_CONSTANT ) { return false ; }
if ( MathUtils . compareTo ( entry , NUMBER_CONSTANT , maxUlps ) > NUMBER_CONSTANT ) { columnsToDrop . add ( i ) ; }
MathUtils . checkOrder ( x ) ;
public int [] getOrderOfRegressors () { return MathUtils . copyOf ( vorder ) ; }
{ include ( MathUtils . copyOf ( x , x.length ) , NUMBER_CONSTANT , y ) ; }
{ if ( this . parameters == null ) { return null ; } return MathUtils . copyOf ( parameters ) ; }
MathUtils . checkOrder ( knots ) ;
{ this ( wrong , previous , index , MathUtils.OrderDirection.INCREASING , true ) ; }
public int [] getSizes () { return MathUtils . copyOf ( size ) ; }
this . size = MathUtils . copyOf ( size ) ;
public int [] getCounts () { return MathUtils . copyOf ( counter ) ; }
final double [] d = MathUtils . copyOf ( direc [ i ] ) ;
return MathUtils . checkOrder ( x , MathUtils.OrderDirection.INCREASING , true , abort ) ;
MathUtils . sortInPlace ( xNew , yNew ) ;
MathUtils . sortInPlace ( this . x , this . y ) ;
MathUtils . checkOrder ( xval ) ;
RealMatrix arzneg = selectColumns ( arz , MathUtils . copyOf ( arReverseIndex , mu ) ) ;
{ return MathUtils . distance ( point , p . getPoint () ) ; }
MathUtils . checkOrder ( x ) ;
Assert . assertEquals ( expectedValue () , variance . evaluate ( testArray , MathUtils . normalizeArray ( identicalWeightsArray , testArray.length ) , NUMBER_CONSTANT , testArray.length ) , getTolerance () ) ;
long lcm = FastMath . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ;
int lcm = FastMath . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ;
int gcd = MathUtils . gcd ( numerator , denominator ) ;
final int d = MathUtils . gcd ( num , den ) ;
double binomial = MathUtils . binomialCoefficient ( v + i , i ) ;
{ coeff [ i ] [ j ] = ( int ) MathUtils . binomialCoefficient ( i , j ) ; }
int gcd = ArithmeticsUtils . gcd ( numerator , denominator ) ;
final int d = ArithmeticsUtils . gcd ( num , den ) ;
double binomial = ArithmeticsUtils . binomialCoefficient ( v + i , i ) ;
{ coeff [ i ] [ j ] = ( int ) ArithmeticsUtils . binomialCoefficient ( i , j ) ; }
MathUtils . sign ( y0 ) + MathUtils . sign ( ym ) == NUMBER_CONSTANT
{ return FastMath . abs ( x ) < NUMBER_CONSTANT ? NUMBER_CONSTANT : FastMath . sin ( x ) / x ; }
ed = new EigenDecomposition ( indefinite , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( distinct , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( repeated , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) ;
RealMatrix v = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) . getV () ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( createTestMatrix ( r , bigValues ) , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () , MathUtils.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , MathUtils.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , MathUtils.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
if ( FastMath . abs ( tmp ) > MathUtils.EPSILON ) { w = ( di * w ) / dpi ; }
{ this ( numberOfVariables , includeConstant , MathUtils.EPSILON ) ; }
if ( FastMath . abs ( diag ) < MathUtils.SAFE_MIN ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
if ( FastMath . abs ( diag ) < MathUtils.SAFE_MIN ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
tol = FastMath . max ( m * singularValues [ NUMBER_CONSTANT ] * EPS , FastMath . sqrt ( MathUtils.SAFE_MIN ) ) ;
LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer ( initialStepBoundFactor , costRelativeTolerance , parRelativeTolerance , orthoTolerance , MathUtils.SAFE_MIN ) ;
if ( n < MathUtils.EPSILON ) { return zero ; }
if ( n < MathUtils.SAFE_MIN ) { return distance ( line.zero ) ; }
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
final double eps = NUMBER_CONSTANT * rows * columns * MathUtils.EPSILON ;
if ( d > - MathUtils.SAFE_MIN && d < MathUtils.SAFE_MIN ) { return d ; }
FastMath . abs ( sumXX ) > MathUtils.SAFE_MIN
@ Test ( expected = OutOfRangeException . class )
{ this ( numberOfInterpolationPoints , null , null ) ; }
this . stopfitness = stopfitness ;
this . stopfitness = stopFitness ;
public boolean isInfinite () { throw unsupported () ; }
public boolean isNaN () { throw unsupported () ; }
public boolean isInfinite () { throw unsupported () ; }
public boolean isNaN () { throw unsupported () ; }
public boolean isInfinite () { throw unsupported () ; }
public boolean isNaN () { throw unsupported () ; }
public void unitize () { throw unsupported () ; }
public double getLInfNorm () { throw unsupported () ; }
public double getL1Norm () { throw unsupported () ; }
public double getNorm () { throw unsupported () ; }
double [] bounds = ( ( EmpiricalDistributionImpl ) empiricalDistribution2 ) . getGeneratorUpperBounds () ;
FieldDecompositionSolver solver ;
double floatn = ( double ) v.length ;
final double [] eventY = interpolator . getInterpolatedState () ;
final double [] yTmp = new double [ y0.length ] ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new BetaDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
BetaDistributionImpl betaDistribution = new BetaDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
BetaDistribution d = new BetaDistributionImpl ( alpha , beta ) ;
BetaDistribution d = new BetaDistributionImpl ( alpha , beta ) ;
setDistribution ( new BinomialDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new BinomialDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new CauchyDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new ChiSquaredDistributionImpl ( NUMBER_CONSTANT ) ) ;
ChiSquaredDistribution d = new ChiSquaredDistributionImpl ( df ) ;
setDistribution ( new ChiSquaredDistributionImpl ( NUMBER_CONSTANT ) ) ;
@ Override public ChiSquaredDistribution makeDistribution () { return new ChiSquaredDistributionImpl ( NUMBER_CONSTANT ) ; }
FDistribution fdist = new FDistributionImpl ( a.dfbg , a.dfwg ) ;
@ Override public ExponentialDistribution makeDistribution () { return new ExponentialDistributionImpl ( NUMBER_CONSTANT ) ; }
double [] quartiles = TestUtils . getDistributionQuartiles ( new FDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ gamma = new GammaDistributionImpl ( degreesOfFreedom / NUMBER_CONSTANT , NUMBER_CONSTANT ) ; solverAbsoluteAccuracy = inverseCumAccuracy ; }
GammaDistribution distribution = new GammaDistributionImpl ( a , b ) ;
GammaDistribution distribution = new GammaDistributionImpl ( a , b ) ;
FDistributionImpl fd = new FDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
HypergeometricDistribution dist = new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
setDistribution ( new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;
NormalDistribution normal = new NormalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
NormalDistribution distribution = new NormalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
NormalDistribution d = new NormalDistributionImpl ( mean , sd ) ;
setDistribution ( new PascalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new PascalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
TDistribution distribution = new TDistributionImpl ( degreesOfFreedom ) ;
TDistribution distribution = new TDistributionImpl ( degreesOfFreedom ) ;
PoissonDistribution dist = new PoissonDistributionImpl ( mean ) ;
PoissonDistribution dist = new PoissonDistributionImpl ( mean ) ;
{ PoissonDistribution dist = new PoissonDistributionImpl ( NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , dist . getMean () , NUMBER_CONSTANT ) ; }
@ Test ( expected = NotStrictlyPositiveException . class ) public void testNegativeMean () { new PoissonDistributionImpl ( - NUMBER_CONSTANT ) ; }
PoissonDistribution dist = new PoissonDistributionImpl ( DEFAULT_TEST_POISSON_PARAMETER ) ;
@ Override public IntegerDistribution makeDistribution () { return new PoissonDistributionImpl ( DEFAULT_TEST_POISSON_PARAMETER ) ; }
double [] quartiles = TestUtils . getDistributionQuartiles ( new WeibullDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new TDistributionImpl ( NUMBER_CONSTANT ) ) ;
PoissonDistribution poissonDistribution = new PoissonDistributionImpl ( mean ) ;
FastMath . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / ( double ) n ) + ( xbar * xbar ) / sumXX ) )
TDistribution tDistribution = new TDistributionImpl ( NUMBER_CONSTANT ) ;
TDistribution td = new TDistributionImpl ( df ) ;
setDistribution ( new TDistributionImpl ( NUMBER_CONSTANT ) ) ;
{ TDistributionImpl td = new TDistributionImpl ( NUMBER_CONSTANT ) ; td . cumulativeProbability ( NUMBER_CONSTANT ) ; td . cumulativeProbability ( NUMBER_CONSTANT ) ; }
@ Override public TDistribution makeDistribution () { return new TDistributionImpl ( NUMBER_CONSTANT ) ; }
dist = new ZipfDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_WINDOW_SIZE , windowSize ) ; } }
if ( sign >= NUMBER_CONSTANT && magnitude == Long.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW ) ; } else { return ( long ) - magnitude ; }
if ( sign >= NUMBER_CONSTANT && magnitude == Integer.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW ) ; } else { return ( int ) - magnitude ; }
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction f = new Gaussian () ;
final UnivariateRealFunction f = new Gaussian () ;
final ParametricUnivariateRealFunction f
final ParametricUnivariateRealFunction f
final ParametricUnivariateRealFunction f
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f
UnivariateRealFunction func
UnivariateRealFunction f
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
public MonitoredFunction ( UnivariateRealFunction f ) { callsCount = NUMBER_CONSTANT ; this . f = f ; }
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f = new QuinticFunction () ;
final UnivariateRealFunction f
final UnivariateRealFunction f
DifferentiableUnivariateRealFunction f
DifferentiableUnivariateRealFunction f
UnivariateRealFunction dSpline = spline . derivative () ;
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction p = interpolator . interpolate ( x , y ) ;
UnivariateRealFunction f
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new XMinus5Function () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new Expm1Function () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction dfdx = f . derivative () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new Expm1Function () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final UnivariateRealFunction f
final UnivariateRealFunction f
final UnivariateRealFunction f
final UnivariateRealFunction f
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction f = new Sigmoid () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
DifferentiableUnivariateRealFunction f = new QuinticFunction () ;
DifferentiableUnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction p = interpolator . interpolate ( x , y ) ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
ParametricUnivariateRealFunction sif = new SimpleInverseFunction () ;
ParametricUnivariateRealFunction sif = new SimpleInverseFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new Expm1Function () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
@ Override public RealVector mapToSelf ( UnivariateRealFunction function ) { throw unsupported () ; }
@ Override public RealVector map ( UnivariateRealFunction function ) { throw unsupported () ; }
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction f
final UnivariateRealFunction f
final UnivariateRealFunction lsf = new LineSearchFunction ( searchDirection ) ;
if ( c . isAssignableFrom ( UnivariateRealFunction . class ) ) { return new Sin () ; } else { throw new IllegalArgumentException ( STRING_CONSTANT + c ) ; }
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f
UnivariateRealFunction f
@ Override public RealVector mapToSelf ( UnivariateRealFunction function ) { throw unsupported () ; }
@ Override public RealVector map ( UnivariateRealFunction function ) { throw unsupported () ; }
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
final DifferentiableUnivariateRealFunction f
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final UnivariateRealFunction dfdx = f . derivative () ;
MultivariateRealFunction coll = FunctionUtils . collector ( bi , NUMBER_CONSTANT ) ;
final MultivariateRealFunction evaluationFunction
final MultivariateRealFunction evaluationFunction
DifferentiableMultivariateRealFunction func
DifferentiableMultivariateRealFunction func
final DifferentiableMultivariateRealFunction f
final MultivariateRealFunction evaluationFunction
MultivariateRealFunction func
final MultivariateRealFunction evaluationFunction
final MultivariateRealFunction evaluationFunction
MultivariateRealFunction func
MultivariateRealFunction func
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
resetEvaluations () ;
public KeplerStepHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
public KeplerStepHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
final DifferentiableMultivariateVectorialFunction f
DifferentiableMultivariateVectorialFunction problem
# optimize ( int , MultivariateVectorialFunction , double [] , double [] , double [] )
final MultivariateVectorialFunction function
final MultivariateVectorialFunction function
final MultivariateVectorialFunction function
double dResult [] = transformer . inversetransform ( dY ) ;
result = transformer . inversetransform ( f , min , max , N ) ;
if ( forward ) { temp = transform2 ( temp ) ; } else { temp = inversetransform2 ( temp ) ; }
Object o []
double d []
Complex f []
double f []
Complex f []
double f []
double f []
double f []
double f []
double f []
int x []
double x []
int f []
double f []
double f []
double f []
double f []
double f []
double f []
new Fraction ( ( ( Math . abs ( w ) * d ) + n ) * MathUtils . sign ( w ) , d )
final int bits
if ( seed == null ) { setSeed ( System . currentTimeMillis () ) ; return; }
catch ( Exception e ) { fail ( STRING_CONSTANT ) ; }
catch ( Exception e ) { fail ( STRING_CONSTANT ) ; }
double x
p = dist . cumulativeProbability ( x ) ;
ContinuousDistribution distribution
ContinuousDistribution distribution
FastFourierTransformer transformer = new FastFourierTransformer () ;
FastFourierTransformer transformer = new FastFourierTransformer () ;
FastFourierTransformer transformer = new FastFourierTransformer () ;
FastFourierTransformer transformer = new FastFourierTransformer () ;
FastCosineTransformer transformer = new FastCosineTransformer () ;
FastCosineTransformer transformer = new FastCosineTransformer () ;
final DifferentiableMultivariateVectorialOptimizer optimizer
final DifferentiableMultivariateVectorialOptimizer optimizer
public HarmonicFitter ( final DifferentiableMultivariateVectorialOptimizer optimizer ) { super ( optimizer ) ; }
public GaussianFitter ( DifferentiableMultivariateVectorialOptimizer optimizer ) { super ( optimizer ) ; }
DifferentiableMultivariateVectorialOptimizer optimizer
{ DifferentiableMultivariateVectorialOptimizer optimizer = new GaussNewtonOptimizer ( true ) ; checkUnsolvableProblem ( optimizer , false ) ; }
final BaseMultivariateRealOptimizer < FUNC > optimizer
MultivariateRealOptimizer optim
final DifferentiableMultivariateRealOptimizer optimizer
final MultivariateRealOptimizer optimizer
@ Override public void setSeed ( int seed ) { ran . setSeed ( seed ) ; }
{ if ( rand == null ) { rand = new JDKRandomGenerator () ; } rand . setSeed ( seed ) ; }
FastSineTransformer transformer = new FastSineTransformer () ;
FastSineTransformer transformer = new FastSineTransformer () ;
{ return getNumberOfTrials () * getProbabilityOfSuccess () ; }
Assert . assertEquals ( - NUMBER_CONSTANT , dist . inverseCumulativeProbability ( NUMBER_CONSTANT ) ) ;
setInverseCumulativeTestValues ( new int [] { - NUMBER_CONSTANT , - NUMBER_CONSTANT } ) ;
setInverseCumulativeTestValues ( new int [] { Integer.MAX_VALUE - NUMBER_CONSTANT , Integer.MAX_VALUE - NUMBER_CONSTANT } ) ;
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_PLUS_ONE , Integer . valueOf ( f.length ) ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , Integer . valueOf ( n ) ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , Integer . valueOf ( n ) ) ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( o.length ) ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( d.length ) ) ; } }
{ final double [] data = FastFourierTransformer . sample ( f , min , max , n ) ; return inverseTransform ( data ) ; }
{ final double [] data = FastFourierTransformer . sample ( f , min , max , n ) ; return transform ( data ) ; }
final double [] unscaled = fht ( FastFourierTransformer . sample ( f , min , max , n ) ) ;
{ return fht ( FastFourierTransformer . sample ( f , min , max , n ) ) ; }
final double [] data = sample ( f , min , max , n ) ;
final double [] data = sample ( f , min , max , n ) ;
final double [] data = FastFourierTransformer . sample ( f , min , max , n ) ;
final double [] data = FastFourierTransformer . sample ( f , min , max , n ) ;
FastFourierTransformer . scaleArray ( x , FastMath . sqrt ( x.length / NUMBER_CONSTANT ) ) ;
return FastFourierTransformer . scaleArray ( fct ( f ) , s1 ) ;
return FastFourierTransformer . scaleArray ( fct ( f ) , s ) ;
return FastFourierTransformer . scaleArray ( unscaled , NUMBER_CONSTANT / n ) ;
{ return FastFourierTransformer . scaleArray ( fht ( f ) , NUMBER_CONSTANT / f.length ) ; }
FastFourierTransformer . scaleArray ( x2 , NUMBER_CONSTANT / FastMath . sqrt ( x2.length ) ) ;
return scaleArray ( transformed , NUMBER_CONSTANT ) ;
return scaleArray ( fft ( f ) , s ) ;
return scaleArray ( fft ( data , true ) , s ) ;
return scaleArray ( fft ( f , true ) , s ) ;
{ final double s = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ; return scaleArray ( fft ( f ) , s ) ; }
return scaleArray ( fft ( data , false ) , s ) ;
return scaleArray ( fft ( f , false ) , s ) ;
return FastFourierTransformer . scaleArray ( fst ( data ) , s ) ;
return FastFourierTransformer . scaleArray ( fst ( f ) , s ) ;
{ final double s = FastMath . sqrt ( NUMBER_CONSTANT / n ) ; return FastFourierTransformer . scaleArray ( fst ( data ) , s ) ; }
{ final double s = FastMath . sqrt ( NUMBER_CONSTANT / f.length ) ; return FastFourierTransformer . scaleArray ( fst ( f ) , s ) ; }
{ for ( double diag : rDiag ) { if ( diag == NUMBER_CONSTANT ) { return false ; } } return true ; }
public DecompositionSolver getSolver () { return new Solver ( qrt , rDiag ) ; }
@ Test ( expected = NonMonotonicSequenceException . class )
final UnivariateRealSolver solver
UnivariateRealSolverUtils . verifyInterval ( lower , upper ) ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = new RiddersSolver () ;
UnivariateRealSolver solver = new RiddersSolver () ;
UnivariateRealSolver solver = new RiddersSolver () ;
UnivariateRealSolver solver = new RiddersSolver () ;
UnivariateRealSolver solver = new BrentSolver () ;
UnivariateRealSolver solver = new BrentSolver () ;
UnivariateRealSolver solver = new MullerSolver () ;
UnivariateRealSolver solver = new MullerSolver () ;
UnivariateRealSolver solver = new MullerSolver () ;
UnivariateRealSolver solver = new MullerSolver () ;
final UnivariateRealSolver solver
final UnivariateRealSolver solver = new RegulaFalsiSolver () ;
final UnivariateRealSolver solver
UnivariateRealSolver solver
UnivariateRealSolver solver = new MullerSolver2 () ;
UnivariateRealSolver solver = new MullerSolver2 () ;
UnivariateRealSolver solver = new MullerSolver2 () ;
UnivariateRealSolver solver = new MullerSolver2 () ;
double x = UnivariateRealSolverUtils . solve ( toSolve , lowerBound , upperBound , getSolverAbsoluteAccuracy () ) ;
final UnivariateRealSolver lineSearchSolver
final UnivariateRealSolver lineSearchSolver
{ return super . solve ( maxEval , f , UnivariateRealSolverUtils . midpoint ( min , max ) ) ; }
int l
java.util.List < Double > chromosomeRepresentation
Chromosome another
List < T > sequence
Double [] representation
Population current
RandomGenerator random
int populationLimit
Chromosome chromosome
List < Chromosome > chromosomes
int arity
Chromosome another
Chromosome another
Chromosome original
Population population
if ( elitismRate < NUMBER_CONSTANT || elitismRate > NUMBER_CONSTANT ) { throw new OutOfRangeException ( LocalizedFormats.OUT_OF_RANGE_ELITISM_RATE , elitismRate , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( maxGenerations <= NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.TOO_SMALL_GENERATION_COUNT , maxGenerations , NUMBER_CONSTANT , true ) ; } this . maxGenerations = maxGenerations ; }
BivariateRealFunction div = new Divide () ;
BivariateRealFunction bi = new Add () ;
BivariateRealFunction bi = new Add () ;
partialDerivatives = new BivariateRealFunction [ [ [ NUMBER_CONSTANT ] [ lastI ] [ lastJ ] ;
final BivariateRealFunction f
final BivariateRealFunction f
final BivariateRealFunction combiner
final BivariateRealFunction combiner
final BivariateRealFunction combiner
final IterativeLinearSolverEvent event = createEvent ( state ) ;
{ return x . ebeMultiply ( diag ) ; }
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
roots . computeOmega ( - f.length ) ;
roots . computeOmega ( f.length ) ;
MultivariateRealInterpolator interpolator = new MicrosphereInterpolator () ;
MultivariateRealInterpolator interpolator = new MicrosphereInterpolator () ;
UnivariateRealInterpolator i = new LinearInterpolator () ;
UnivariateRealInterpolator i = new LinearInterpolator () ;
UnivariateRealInterpolator i = new LinearInterpolator () ;
UnivariateRealInterpolator i = new LinearInterpolator () ;
UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
UnivariateRealInterpolator interpolator = new NevilleInterpolator () ;
UnivariateRealInterpolator interpolator = new NevilleInterpolator () ;
UnivariateRealInterpolator interpolator = new NevilleInterpolator () ;
TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator () ;
TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator () ;
TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator () ;
BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator () ;
BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator () ;
BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator () ;
roots . computeOmega ( f.length ) ;
roots . computeOmega ( - f.length ) ;
UnivariateRealIntegrator integrator = new SimpsonIntegrator () ;
UnivariateRealIntegrator integrator = new SimpsonIntegrator () ;
UnivariateRealIntegrator integrator = new TrapezoidIntegrator () ;
UnivariateRealIntegrator integrator = new TrapezoidIntegrator () ;
UnivariateRealIntegrator integrator = new RombergIntegrator () ;
UnivariateRealIntegrator integrator = new RombergIntegrator () ;
LegendreGaussIntegrator integrator = new LegendreGaussIntegrator ( n , UnivariateRealIntegratorImpl.DEFAULT_RELATIVE_ACCURACY , UnivariateRealIntegratorImpl.DEFAULT_ABSOLUTE_ACCURACY , UnivariateRealIntegratorImpl.DEFAULT_MIN_ITERATIONS_COUNT , NUMBER_CONSTANT ) ;
final UnivariateRealIntegratorImpl baseIntegrator
{ allocArrays () ; setSeed ( seed ) ; }
public ISAACRandom ( long seed ) { allocArrays () ; setSeed ( seed ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS ) ; } }
final double fact2 = ( n ) / ( n - NUMBER_CONSTANT ) ;
final double fact2 = ( n ) / ( NUMBER_CONSTANT + n ) ;
public void init ( double t0 , double [] y0 , double t ) {}
try { t . transform ( input ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathException e ) {}
catch ( MathException e ) { e . printStackTrace () ; }
if ( ( nvars + NUMBER_CONSTANT ) * nobs != data.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_REGRESSION_ARRAY , data.length , nobs , nvars ) ; }
EmpiricalDistributionImpl dist = new EmpiricalDistributionImpl ( NUMBER_CONSTANT ) ;
{ new EmpiricalDistributionImpl () . load ( ( File ) null ) ; }
{ new EmpiricalDistributionImpl () . load ( ( URL ) null ) ; }
{ new EmpiricalDistributionImpl () . load ( ( double [] ) null ) ; }
EmpiricalDistribution dist = new EmpiricalDistributionImpl () ;
new EmpiricalDistributionImpl () . load ( x ) ;
empiricalDistribution = new EmpiricalDistributionImpl ( binCount , randomData ) ;
{ computeDistribution ( EmpiricalDistributionImpl.DEFAULT_BIN_COUNT ) ; }
dataRI = new double [] [] { Arrays . copyOf ( f , f.length ) , new double [ f.length ] }
dataRI = new double [] [] { Arrays . copyOf ( f , f.length ) , new double [ f.length ] }
Collection < double [] > categoryData
Collection < double [] > categoryData
Collection < double [] > categoryData
boolean exactPValue
double dResult [] = transformer . inverseTransform ( dY ) ;
double dResult [] = transformer . transform ( dX ) ;
public SimplexOptimizer ( ConvergenceChecker < RealPointValuePair > checker ) { super ( checker ) ; }
protected AbstractScalarDifferentiableOptimizer ( ConvergenceChecker < RealPointValuePair > checker ) { super ( checker ) ; }
ConvergenceChecker < UnivariateRealPointValuePair > checker
RealPointValuePair expected
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < UnivariateRealPointValuePair > checker
RealPointValuePair [] points
RealPointValuePair point
final Comparator < RealPointValuePair > comparator
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < RealPointValuePair > checker
protected BaseAbstractMultivariateSimpleBoundsOptimizer ( ConvergenceChecker < RealPointValuePair > checker ) { super ( checker ) ; }
UnivariateRealPointValuePair [] optima = optimizer . getOptima () ;
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < RealPointValuePair > checker
org.apache.commons.math.stat.inference.ChiSquareTestImpl csti = new org.apache.commons.math.stat.inference.ChiSquareTestImpl () ;
ChiSquareTest chiSquareTest = new ChiSquareTestImpl () ;
org.apache.commons.math.stat.inference.ChiSquareTestImpl csti = new org.apache.commons.math.stat.inference.ChiSquareTestImpl () ;
ChiSquareTest chiSquareTest = new ChiSquareTestImpl () ;
ConvergenceChecker < VectorialPointValuePair > checker
ConvergenceChecker < VectorialPointValuePair > checker
protected AbstractLeastSquaresOptimizer ( ConvergenceChecker < VectorialPointValuePair > checker ) { super ( checker ) ; }
ConvergenceChecker < VectorialPointValuePair > checker
ConvergenceChecker < VectorialPointValuePair > checker
ConvergenceChecker < VectorialPointValuePair > checker
VectorialPointValuePair optimum
SimplexOptimizer optimizer = new SimplexOptimizer ( new SimpleRealPointChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ this ( new SimpleScalarValueChecker ( rel , abs ) ) ; }
NonLinearConjugateGradientOptimizer underlying = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver () , preconditioner ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ this ( lambda , inputSigma , boundaries , maxIterations , stopFitness , isActiveCMA , diagonalOnly , checkFeasableCount , random , generateStatistics , new SimpleScalarValueChecker () ) ; }
SimplexOptimizer optimizer = new SimplexOptimizer ( new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
SimplexOptimizer underlying = new SimplexOptimizer ( new SimpleScalarValueChecker ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
DifferentiableMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer ( true , new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
DifferentiableMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer ( true , new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ throw new UnsupportedOperationException () ; }
FastSineTransformer transformer = FastSineTransformer . create () ;
FastSineTransformer transformer = FastSineTransformer . create () ;
{ throw new NumberIsTooSmallException ( LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION , minStep , FastMath . abs ( h ) , true ) ; }
if ( variablesToInclude == null || variablesToInclude.length == NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.ARRAY_ZERO_LENGTH_OR_NULL_NOTALLOWED ) ; }
UnivariateRealOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
static double [] [] loadLnMant () { return LN_MANT . clone () ; }
static double [] loadExpFracB () { return EXP_FRAC_B . clone () ; }
static double [] loadExpFracA () { return EXP_FRAC_A . clone () ; }
static double [] loadExpIntB () { return EXP_INT_B . clone () ; }
static double [] loadExpIntA () { return EXP_INT_A . clone () ; }
@ Test ( expected = MultiDimensionMismatchException . class )
@ Test ( expected = MultiDimensionMismatchException . class )
StringBuffer imAppendTo = new StringBuffer () ;
{ if ( this . fitness == Double.MIN_VALUE ) { this . fitness = fitness () ; } return this . fitness ; }
setStepsizeControl ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
setStepsizeControl ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
( n * ( n + NUMBER_CONSTANT ) * moment.m4 - NUMBER_CONSTANT * moment.m2 * moment.m2 * ( n - NUMBER_CONSTANT ) )
{ RealVector b = calculateBeta () ; return Y . subtract ( X . operate ( b ) ) ; }
return residuals . dotProduct ( residuals ) / ( X . getRowDimension () - X . getColumnDimension () ) ;
RealVector e = Y . subtract ( X . operate ( b ) ) ;
this . Y = new ArrayRealVector ( y ) ;
final RealMatrix x = ols.X . copy () ;
double [] hatResiduals = I . subtract ( hat ) . operate ( model.Y ) . toArray () ;
return t / ( X . getRowDimension () - X . getColumnDimension () ) ;
int p = X . getColumnDimension () ;
{ return qr . getSolver () . solve ( Y ) ; }
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( X ) ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( X ) ; }
final int length = b . getDataRef () . length ;
final double epsa = ( s + SymmLQ.MACH_PREC ) * SymmLQ.CBRT_MACH_PREC ;
@ Override public RealVector getRightHandSideVector () { return RealVector . unmodifiableRealVector ( state.b ) ; }
this . x . set ( NUMBER_CONSTANT ) ;
this . x = x ;
solver = new ConjugateGradient ( maxIterations , NUMBER_CONSTANT , true ) ;
solver = new ConjugateGradient ( maxIterations , NUMBER_CONSTANT , true ) ;
double array []
double [] [] householderMatrix
{ key = k ; value = v ; }
{ this ( entry , false ) ; }
{ this ( k , v , false ) ; }
throw new RuntimeException ( STRING_CONSTANT ) ;
throw new RuntimeException ( STRING_CONSTANT ) ;
if ( x <= NUMBER_CONSTANT ) { ret = NUMBER_CONSTANT ; } else { ret = Gamma . regularizedGammaP ( alpha , x / beta ) ; }
{ return getAlpha () * getBeta () ; }
v . walkInDefaultOrder ( visitor , expectedStart , expectedEnd ) ;
{ ret = innerCumulativeProbability ( domain [ NUMBER_CONSTANT ] , x , NUMBER_CONSTANT , populationSize , numberOfSuccesses , sampleSize ) ; }
{ recurseBuildBoundary ( tree ) ; }
SimplexOptimizer optimizer = new SimplexOptimizer () ;
@ Override public RealVector create ( final double [] data ) { return new OpenMapRealVector ( data ) ; }
TestVectorImpl ( double [] values ) { this . values = values ; }
catch ( IllegalArgumentException e ) {}
final ParametricUnivariateFunction f
final ParametricUnivariateFunction f
final double n1n2prod = n1 * n2 ;
{ create ( data1 ) . addToEntry ( - NUMBER_CONSTANT , getPreferredEntryValue () ) ; }
{ create ( data1 ) . setEntry ( - NUMBER_CONSTANT , getPreferredEntryValue () ) ; }
@ Override public RealVector createAlien ( double [] data ) { return new RealVectorTestImpl ( data ) ; }
final RealVector x = new TestVectorImpl ( v . clone () ) ;
@ Override public RealVector createAlien ( double [] data ) { return new TestVectorImpl ( data ) ; }
@ Override public RealVector create ( final double [] data ) { return new TestVectorImpl ( data ) ; }
SparseRealVectorTestImpl v7_i = new SparseRealVectorTestImpl ( vec1 ) ;
@ Override public RealVector createAlien ( double [] data ) { return new SparseRealVectorTestImpl ( data ) ; }
Assert . assertEquals ( STRING_CONSTANT + i + STRING_CONSTANT + j + STRING_CONSTANT , expected , actual , NUMBER_CONSTANT ) ;
private ComplexUtils () { super(); }
Object obj
int n = coefficients.length - NUMBER_CONSTANT ;
ed = new EigenDecomposition ( indefinite , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( distinct , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( repeated , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( m , Precision.SAFE_MIN ) ;
RealMatrix v = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) . getV () ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( symmetric , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( createTestMatrix ( r , bigValues ) , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
{ return ( int ) FastMath . min ( randomData . nextPoisson ( mean ) , Integer.MAX_VALUE ) ; }
{ double n = randomData . nextGaussian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; return FastMath . exp ( scale + shape * n ) ; }
EigenDecomposition eig = new EigenDecomposition ( C , NUMBER_CONSTANT ) ;
BaseRuleFactory factory
final GaussIntegrator g = factory . legendreHighPrecision ( numberOfPoints , a , b ) ;
{ this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ROW_SEPARATOR , DEFAULT_COLUMN_SEPARATOR , format ) ; }
public RealMatrixFormat () { this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ROW_SEPARATOR , DEFAULT_COLUMN_SEPARATOR , CompositeFormat . getDefaultNumberFormat () ) ; }
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
{ double multiplier = tableau . getEntry ( i , pivotCol ) ; tableau . subtractRow ( i , pivotRow , multiplier ) ; }
if ( Precision . compareTo ( entry , minValue , maxUlps ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
if ( Precision . compareTo ( p , NUMBER_CONSTANT , epsilon ) < NUMBER_CONSTANT ) { s = - s ; }
catch ( Exception e ) { throw new MathIllegalStateException () ; }
{ if ( ! Precision . equals ( imagEigenvalues [ i ] , NUMBER_CONSTANT , epsilon ) ) { return true ; } }
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , new RealMatrixFormat () . parse ( source , pos ) ) ;
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , new RealMatrixFormat () . parse ( source , pos ) ) ;
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , new RealMatrixFormat () . parse ( source , pos ) ) ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
final UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
DifferentiableUnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
{ secRand = SecureRandom . getInstance ( algorithm , provider ) ; }
{ return nextInversionDeviate ( new ZipfDistribution ( numberOfElements , exponent ) ) ; }
{ return nextInversionDeviate ( new WeibullDistribution ( shape , scale ) ) ; }
{ return nextInversionDeviate ( new TDistribution ( df ) ) ; }
{ return nextInversionDeviate ( new PascalDistribution ( r , p ) ) ; }
{ return nextInversionDeviate ( new HypergeometricDistribution ( populationSize , numberOfSuccesses , sampleSize ) ) ; }
{ return nextInversionDeviate ( new FDistribution ( numeratorDf , denominatorDf ) ) ; }
{ return nextInversionDeviate ( new ChiSquaredDistribution ( df ) ) ; }
{ return nextInversionDeviate ( new CauchyDistribution ( median , scale ) ) ; }
{ return nextInversionDeviate ( new BinomialDistribution ( numberOfTrials , probabilityOfSuccess ) ) ; }
{ return nextInversionDeviate ( new BetaDistribution ( alpha , beta ) ) ; }
{ return nextUniform ( lower , upper , false ) ; }
{ super(); this . rand = rand ; }
double dotProduct = new LegendreGaussIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . integrate ( NUMBER_CONSTANT , f , a , b ) ;
FastMath . exp ( Gamma . logGamma ( shape ) )
@ Override public int hashCode () { throw new UnsupportedOperationException () ; }
{ throw new UnsupportedOperationException () ; }
double x = randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
fillBinStats ( in ) ;
final UnivariateDifferentiable sPrime = new Sqrt () ;
final UnivariateDifferentiable q = new QuinticFunction () ;
final UnivariateDifferentiable f
final UnivariateDifferentiable f
UnivariateDifferentiable f
final UnivariateDifferentiable f = new QuinticFunction () ;
UnivariateDifferentiable f = new Sin () ;
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.ENTRY , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.ENTRY , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.ENTRY , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.ENTRY , i ) ; }
public CircleVectorial () { points = new ArrayList < Point2D.Double > () ; }
DifferentiableMultivariateVectorFunction problem
public CircleScalar () { points = new ArrayList < Point2D.Double > () ; }
{ gradient = f . gradient () ; return super . optimize ( maxEval , f , goalType , startPoint ) ; }
final DifferentiableMultivariateVectorFunction problem ;
{ return product ( this , q ) ; }
final Quaternion product = Quaternion . product ( inverseQ , q ) ;
final double normSquareRef = Quaternion . product ( q , q . getConjugate () ) . getScalarPart () ;
optimum = new PointValuePair ( fitfun . decode ( bestArx . getColumn ( NUMBER_CONSTANT ) ) , isMinimize ? bestFitness : - bestFitness ) ;
double tmp = wxi * xi / di ;
Iterator < Entry > it = v . sparseIterator () ;
Iterator < Entry > it = v . sparseIterator () ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = sparseIterator () ;
{ return optimize ( maxEval , f , goalType , startPoint , null , null ) ; }
public double [] getUpperBound () { return upperBound . clone () ; }
public double [] getLowerBound () { return lowerBound . clone () ; }
public double [] getStartPoint () { return start . clone () ; }
Math . max ( NUMBER_CONSTANT , NUMBER_CONSTANT - dimension / ( NUMBER_CONSTANT + Math . min ( maxIterations , getMaxEvaluations () / lambda ) ) )
final double [] [] out = new double [ [ sampleSize ] [ numDimensions ] ;
{ random = rng ; numDimensions = n ; }
final int dim = getDimensions () ;
final int dim = getDimensions () ;
final int dim = getDimensions () ;
final int dim = d . getDimensions () ;
final int dim = d . getDimensions () ;
double [] insigma = point ( DIM + NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
double [] insigma = null ;
double [] insigma = null ;
double [] insigma = null ;
final double [] f
jF = new JacobianFunction ( f ) ;
{ distribution . get ( i ) . reseedRandomGenerator ( seed ) ; }
MultivariateFunction f
MultivariateFunction f
final RealMatrix d = createDiagonalMatrix ( eigenValues , n , n ) ;
RealMatrix m = createDiagonalMatrix ( diagonal , diagonal.length , diagonal.length ) ;
{ x = list . remove ( list . size () - NUMBER_CONSTANT ) . getLower () ; }
final double [] sigma = optim . getSigma () ;
double [] currentPoint = getStartPoint () ;
final double [] [] covMatrix = optimizer . getCovariances () ;
final double [] [] covarMatrix = optimizer . getCovariances () ;
final RealMatrix j = computeJacobian ( params ) ;
qrDecomposition ( computeJacobian ( currentPoint ) ) ;
final RealMatrix weightedJacobian = computeJacobian ( currentPoint ) ;
try { testStatistic . gTestGoodnessOfFit ( expected , observed , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( OutOfRangeException ex ) {}
try { testStatistic . gTestGoodnessOfFitPValue ( expected , observed ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NotStrictlyPositiveException ex ) {}
final double residual = - currentResiduals [ i ] ;
{ super . testAdd1000 () ; Assert . assertEquals ( STRING_CONSTANT + STRING_CONSTANT , NUMBER_CONSTANT , ( ( ResizableDoubleArray ) da ) . getInternalLength () ) ; }
ResizableDoubleArray other = ( ResizableDoubleArray ) object ;
{ ResizableDoubleArray result = new ResizableDoubleArray () ; copy ( this , result ) ; return result ; }
hashData [ NUMBER_CONSTANT ] = expansionMode ;
expansionMode == MULTIPLICATIVE_MODE
expansionMode == MULTIPLICATIVE_MODE
{ if ( initialDoubleArray != null ) { eDA = new ResizableDoubleArray ( initialDoubleArray ) ; } }
{ if ( initialDoubleArray != null ) { eDA = new StatArray ( initialDoubleArray ) ; } }
{ this ( DEFAULT_INITIAL_CAPACITY , DEFAULT_EXPANSION_FACTOR , NUMBER_CONSTANT + DEFAULT_EXPANSION_FACTOR , ExpansionMode.MULTIPLICATIVE , initialArray ) ; }
hashData [ NUMBER_CONSTANT ] = new Float ( contractionCriteria ) . hashCode () ;
result = result && ( other.contractionCriteria == contractionCriteria ) ;
dest.contractionCriteria = source.contractionCriteria ;
{ checkContractExpand ( getContractionCriteria () , expansionFactor ) ; synchronized ( this ) { this . expansionFactor = expansionFactor ; } }
{ checkContractExpand ( contractionCriteria , getExpansionFactor () ) ; synchronized ( this ) { this . contractionCriteria = contractionCriteria ; } }
public double getContractionCriterion () { return contractionCriteria ; }
{ super ( relativeThreshold , absoluteThreshold ) ; }
@ Deprecated public SimpleVectorValueChecker () {}
{ super ( relativeThreshold , absoluteThreshold ) ; }
@ Deprecated public SimpleValueChecker () {}
{ super ( relativeThreshold , absoluteThreshold ) ; }
@ Deprecated public SimplePointChecker () {}
NaturalRanking ranking = new NaturalRanking ( TiesStrategy.MINIMUM ) ;
{ super ( relativeThreshold , absoluteThreshold ) ; }
@ Deprecated public SimpleUnivariateValueChecker () {}
logBeta ( a , b , epsilon , maxIterations )
RandomDataImpl randomData
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataImpl () ) ; }
RandomDataImpl randomData
this . q0 = NUMBER_CONSTANT ;
if ( diagonalOnly <= NUMBER_CONSTANT ) { updateCovariance ( hsig , bestArx , arz , arindex , xold ) ; } else { updateCovarianceDiagonalOnly ( hsig , bestArz , xold ) ; }
if ( diagonalOnly <= NUMBER_CONSTANT ) { updateCovariance ( hsig , bestArx , arz , arindex , xold ) ; } else { updateCovarianceDiagonalOnly ( hsig , bestArz , xold ) ; }
final CodyWaite cw = new CodyWaite ( xa , xb ) ;
final CodyWaite cw = new CodyWaite ( xa , xb ) ;
final CodyWaite cw = new CodyWaite ( xa , xb ) ;
@ Override public void reseedRandomGenerator ( long seed ) { randomData . reSeed ( seed ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataGenerator () ) ; }
@ Override public void reseedRandomGenerator ( long seed ) { reSeed ( seed ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , ( RandomGenerator ) null ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataImpl () ) ; }
filePointer = new BufferedReader ( new InputStreamReader ( valuesFileURL . openStream () ) ) ;
new Weight ( w )
new Weight ( weights )
new Weight ( weights )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( weights )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( w )
new Weight ( problem . weight () )
new Weight ( circle . weight () )
new Weight ( weights )
new Weight ( w )
new Weight ( w )
new Weight ( w )
new Weight ( function . getWeight () )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( problem . weight () )
new NonCorrelatedWeight ( circle . weight () )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( function . getWeight () )
{ data = d . clone () ; }
public SimplexSolver ( final double epsilon ) { this ( epsilon , DEFAULT_ULPS ) ; }
if ( FastMath . abs ( result ) < CUTOFF_THRESHOLD ) { result = NUMBER_CONSTANT ; }
{ this ( f , constraints , goalType , restrictToNonNegative , epsilon , DEFAULT_ULPS ) ; }
final T [] out = buildArray ( data.length + NUMBER_CONSTANT ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
data = buildArray ( v1.length + v2.length ) ;
data = buildArray ( v1.length + v2.data.length ) ;
data = buildArray ( v1.data.length + v2.length ) ;
data = buildArray ( v1.data.length + v2.data.length ) ;
data = buildArray ( v . getDimension () ) ;
data = buildArray ( size ) ;
data = buildArray ( size ) ;
final T [] [] out = buildArray ( getField () , nRows , getColumnDimension () ) ;
final T [] out = buildArray ( getField () , nCols ) ;
final T [] out = buildArray ( getField () , nRows ) ;
data = buildArray ( getField () , subMatrix.length , nCols ) ;
final T [] [] outData = buildArray ( getField () , nRows , nCols ) ;
final T [] [] outData = buildArray ( getField () , rowCount , columnCount ) ;
final T [] [] outData = buildArray ( getField () , rowCount , columnCount ) ;
data = buildArray ( getField () , nRows , NUMBER_CONSTANT ) ;
{ super ( field , rowDimension , columnDimension ) ; data = buildArray ( field , rowDimension , columnDimension ) ; }
final T [] out = buildArray ( getField () , columns ) ;
final T [] out = buildArray ( getField () , rows ) ;
final T [] out = buildArray ( getField () , rows ) ;
final T [] out = buildArray ( getField () , columns ) ;
final T [] outData = buildArray ( getField () , rows ) ;
final T [] outData = buildArray ( getField () , columns ) ;
final T [] [] data = buildArray ( getField () , getRowDimension () , getColumnDimension () ) ;
{ blocks = buildArray ( getField () , blockRows * blockColumns , - NUMBER_CONSTANT ) ; }
final T [] out = buildArray ( field , nCols ) ;
final T [] out = buildArray ( field , nCols ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nCols ) ;
final T [] [] data = buildArray ( field , getRowDimension () , getColumnDimension () ) ;
T [] res = buildArray ( virtualSize ) ;
int exponent = ( int ) ( y . log10 () * NUMBER_CONSTANT ) ;
{ return new Decimal64 ( value % a.value ) ; }
{ return new Decimal64 ( value % a ) ; }
return ePlus . add ( eMinus ) . divide ( ePlus . subtract ( eMinus ) ) ;
DerivativeStructure ref = dsX . subtract ( x - ( x % y ) ) ;
DerivativeStructure sAccurate = u1 . dotProduct ( u2 ) ;
Assert . assertEquals ( - NUMBER_CONSTANT , r . getAxis () . dotProduct ( reverted . getAxis () ) . getReal () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( - NUMBER_CONSTANT , r . getAxis () . dotProduct ( reverted . getAxis () ) . getReal () , NUMBER_CONSTANT ) ;
randomData = new RandomDataImpl ( randomGenerator ) ;
{ super(); this . tiesStrategy = TiesStrategy.RANDOM ; nanStrategy = DEFAULT_NAN_STRATEGY ; randomData = new RandomDataImpl ( randomGenerator ) ; }
{ super(); this . nanStrategy = nanStrategy ; this . tiesStrategy = tiesStrategy ; randomData = new RandomDataImpl () ; }
{ super(); this . tiesStrategy = tiesStrategy ; nanStrategy = DEFAULT_NAN_STRATEGY ; randomData = new RandomDataImpl () ; }
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
@ Test ( expected = MathUnsupportedOperationException . class )
{ return randomData . nextGaussian ( stats . getMean () , stats . getStandardDeviation () ) ; }
{ getRan () . setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ getRan () . setSeed ( seed ) ; }
final RandomGenerator generator = getRan () ;
{ return new FDistribution ( getRan () , numeratorDf , denominatorDf , FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ChiSquaredDistribution ( getRan () , df , ChiSquaredDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new CauchyDistribution ( getRan () , median , scale , CauchyDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new BinomialDistribution ( getRan () , numberOfTrials , probabilityOfSuccess ) . sample () ; }
{ return new BetaDistribution ( getRan () , alpha , beta , BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ZipfDistribution ( getRan () , numberOfElements , exponent ) . sample () ; }
{ return new WeibullDistribution ( getRan () , shape , scale , WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new TDistribution ( getRan () , df , TDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new PascalDistribution ( getRan () , r , p ) . sample () ; }
{ return new HypergeometricDistribution ( getRan () , populationSize , numberOfSuccesses , sampleSize ) . sample () ; }
{ return new GammaDistribution ( getRan () , shape , scale , GammaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ExponentialDistribution ( getRan () , mean , ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
return sigma * getRan () . nextGaussian () + mu ;
{ return new PoissonDistribution ( getRan () , mean , PoissonDistribution.DEFAULT_EPSILON , PoissonDistribution.DEFAULT_MAX_ITERATIONS ) . sample () ; }
RandomGenerator ran = getRan () ;
@ Test public void testReciprocalZero () { Assert . assertEquals ( Complex.ZERO . reciprocal () , Complex.NaN ) ; }
{ return ( ( Float . floatToIntBits ( f ) > > > NUMBER_CONSTANT ) & NUMBER_CONSTANT ) - NUMBER_CONSTANT ; }
final long bits = Double . doubleToLongBits ( d ) ;
final long bits = Double . doubleToLongBits ( d ) ;
return abs ( x - Double . longBitsToDouble ( Double . doubleToLongBits ( x ) ^ NUMBER_CONSTANT ) ) ;
{ long bits = Double . doubleToLongBits ( x ) ; if ( bits < NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
{ long bits = Double . doubleToLongBits ( x ) ; if ( bits < NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
long inbits = Double . doubleToLongBits ( x ) ;
long bits = Double . doubleToLongBits ( x ) ;
long bits = Double . doubleToLongBits ( x ) ;
long xl = Double . doubleToLongBits ( d ) ;
File file = new File ( url . getFile () ) ;
{ return Double . longBitsToDouble ( Long.MAX_VALUE & Double . doubleToRawLongBits ( x ) ) ; }
{ return Float . intBitsToFloat ( Integer.MAX_VALUE & Float . floatToRawIntBits ( x ) ) ; }
double [] [] matrix
{ this ( lower , upper , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ fit ( initialMixture , defaultMaxIterations , defaultThreshold ) ; }
sum += FastMath . pow ( distA / distB , NUMBER_CONSTANT / ( fuzzyness - NUMBER_CONSTANT ) ) ;
final double u = FastMath . pow ( membershipMatrix [ i ] [ j ] , fuzzyness ) ;
final long grayCode = i ^ ( i / NUMBER_CONSTANT ) ;
int count = ( samples / centers ) * centers ;
{ this . a [ i ] [ j ] = a [ i + N * j ] ; }
assertArrayEquals ( expected , actual , NUMBER_CONSTANT ) ;
{ double tEnd = test ( NUMBER_CONSTANT ) ; assertEquals ( NUMBER_CONSTANT , tEnd , NUMBER_CONSTANT ) ; }
{ double tEnd = test ( NUMBER_CONSTANT ) ; assertEquals ( NUMBER_CONSTANT , tEnd , NUMBER_CONSTANT ) ; }
{ final double midPoint = NUMBER_CONSTANT * diff ; return diff * computeObjectiveValue ( midPoint ) ; }
{ dist = new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ dist = new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
incrementValue ( entry . getKey () , entry . getValue () ) ;
Assert . assertEquals ( false , random . nextBoolean () ) ;
{ result [ i ] = r . call () ; }
final int uniDimIndex = iter . next () ;
{ super ( specific , NUMBER_CONSTANT , arguments ) ; }
{ super ( specific , value , NUMBER_CONSTANT , false ) ; }
public NotStrictlyPositiveException ( Number value ) { super ( value , NUMBER_CONSTANT , false ) ; }
{ super ( specific , wrong , expected ) ; dimension = expected ; }
{ return expected [ index ] ; }
{ return wrong [ index ] ; }
{ super ( specific , value , NUMBER_CONSTANT , true ) ; }
public NotPositiveException ( Number value ) { super ( value , NUMBER_CONSTANT , true ) ; }
{ secRand = SecureRandom . getInstance ( algorithm , provider ) ; }
SecureRandom secRan = getSecRan () ;
T withConvergenceChecker ( ConvergenceChecker < PointVectorValuePair > checker ) ;
double binomial = ArithmeticUtils . binomialCoefficient ( v + i , i ) ;
long expected = ArithmeticUtils . binomialCoefficient ( i + j , i ) ;
double inv = NUMBER_CONSTANT / ArithmeticUtils . factorial ( i ) ;
double refDer = - ArithmeticUtils . factorial ( n - NUMBER_CONSTANT ) / FastMath . pow ( - x , n ) ;
ArithmeticUtils . pow ( - NUMBER_CONSTANT , i ) * ArithmeticUtils . factorial ( i ) / FastMath . pow ( x , i + NUMBER_CONSTANT )
{ coeff [ i ] [ j ] = ( int ) ArithmeticUtils . binomialCoefficient ( i , j ) ; }
RandomDataImpl randomData = new RandomDataImpl () ;
{ term *= FastMath . pow ( delta [ k ] , orders [ k ] ) / ArithmeticUtils . factorial ( orders [ k ] ) ; }
AbstractOptimizer other
{ return Double . valueOf ( o . toString () ) . doubleValue () ; }
{ val = Double . valueOf ( str ) . doubleValue () ; sampleStats . addValue ( val ) ; }
return Double . valueOf ( str ) . doubleValue () ;
final List < Segment > segments = new ArrayList < Segment > () ;
final List < Segment > segments = new ArrayList < Segment > () ;
List < Edge > edges = new ArrayList < Edge > () ;
final List < EventHandler > list = new ArrayList < EventHandler > () ;
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > () ;
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > () ;
List < int [] > row = new ArrayList < int [] > () ;
double [] vectorData = null ;
{ this ( value , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , f . getCount ( THREEE ) ) ;
f . addValue ( THREEE ) ;
{ return new Combinations ( n , k , Combinations.IterationOrder.LEXICOGRAPHIC ) . iterator () ; }
int [] index = getNatural ( n ) ;
{ final int [] natural = MathArrays . natural ( NUMBER_CONSTANT ) ; Assert . assertEquals ( natural.length , NUMBER_CONSTANT ) ; }
AbstractLeastSquaresOptimizer other
if ( a0 > overflow ) { throw new FractionConversionException ( value , a0 , NUMBER_CONSTANT ) ; }
mult . multInPlace ( var1 ) ;
{ return NUMBER_CONSTANT + NUMBER_CONSTANT * + NUMBER_CONSTANT * MathUtils . hash ( value ) + NUMBER_CONSTANT * derivatives . hashCode () ; }
{ return MathArrays . test ( values , weights , begin , length , allowEmpty ) ; }
{ return MathArrays . test ( values , weights , begin , length , false ) ; }
{ return MathArrays . test ( values , begin , length , allowEmpty ) ; }
{ return MathArrays . test ( values , begin , length , false ) ; }
den = den + NUMBER_CONSTANT ;
den = den + NUMBER_CONSTANT ;
trial = trial * NUMBER_CONSTANT ;
xx = xx + NUMBER_CONSTANT / NUMBER_CONSTANT ;
for ( final T a : data ) { h = h ^ a . hashCode () ; }
if ( result == NUMBER_CONSTANT ) { result = result * x ; }
za = za * ya ;
e = e > > NUMBER_CONSTANT ;
z = z * lnb ;
xl = xl & MASK_30BITS ;
if ( i > NUMBER_CONSTANT ) { randInt = randInt > > NUMBER_CONSTANT ; }
coeff1 = coeff1 / pc2 ;
r = r * rnd ;
e = e > > NUMBER_CONSTANT ;
e = e > > NUMBER_CONSTANT ;
e = e > > NUMBER_CONSTANT ;
coeff1 = coeff1 / pc2 ;
k = k + m ;
{ m = m > > NUMBER_CONSTANT ; ++ k ; }
{ data [ i ] = data [ i ] / d ; }
{ data [ i ] = data [ i ] * d ; }
{ data [ i ] = data [ i ] - d ; }
{ data [ i ] = data [ i ] + d ; }
rhs [ m ] = rhs [ m ] / X ;
{ while ( NUMBER_CONSTANT == n % p ) { n = n / p ; factors . add ( p ) ; } }
{ c [ NUMBER_CONSTANT ] = c [ NUMBER_CONSTANT ] + NUMBER_CONSTANT ; return ret ; }
n = n | NUMBER_CONSTANT ;
bits = bits & NUMBER_CONSTANT ;
v = v * v ;
w = w - NUMBER_CONSTANT ;
{ bytes [ i ++ ] = ( byte ) ( random & NUMBER_CONSTANT ) ; random = random > > NUMBER_CONSTANT ; }
num = num % den ;
extra = extra - rh * RADIX ;
coeff1 = coeff1 / pc2 ;
iter = iter + NUMBER_CONSTANT ;
{ ret = scale * FastMath . pow ( - FastMath . log ( NUMBER_CONSTANT - p ) , NUMBER_CONSTANT / shape ) ; }
( a * FastMath . log ( x ) ) + ( b * FastMath . log ( NUMBER_CONSTANT - x ) )
return ( FastMath . exp ( ss ) - NUMBER_CONSTANT ) * FastMath . exp ( NUMBER_CONSTANT * scale + ss ) ;
{ correct ( new ArrayRealVector ( z ) ) ; }
{ predict ( new ArrayRealVector ( u ) ) ; }
minadj /= ( divisor.mant [ mant.length - NUMBER_CONSTANT ] + NUMBER_CONSTANT ) ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= Math . sqrt ( sp ) ;
{ double f = Math . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= Math . sqrt ( sp ) ;
{ double f = Math . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
final double max = Math.PI ;
{ FunctionUtils . sample ( new Sin () , NUMBER_CONSTANT , Math.PI , NUMBER_CONSTANT ) ; }
{ FunctionUtils . sample ( new Sin () , NUMBER_CONSTANT , Math.PI , - NUMBER_CONSTANT ) ; }
{ FunctionUtils . sample ( new Sin () , Math.PI , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
double x = Math . random () * NUMBER_CONSTANT ;
double x = Math . random () ;
- NUMBER_CONSTANT / ( a * a ) - NUMBER_CONSTANT + Math . cos ( a )
minDiff = Math . min ( minDiff , boundDifference [ i ] ) ;
minDiff = Math . min ( minDiff , boundDifference [ i ] ) ;
{ d [ r ] [ c ] = Math . sqrt ( m . getEntry ( r , c ) ) ; }
{ d [ r ] [ c ] = Math . log ( m . getEntry ( r , c ) ) ; }
double diff = Math . abs ( x [ i ] - repaired [ i ] ) ;
( NUMBER_CONSTANT - ccovmu ) * NUMBER_CONSTANT * mueff / ( Math . pow ( dimension + NUMBER_CONSTANT , NUMBER_CONSTANT ) + NUMBER_CONSTANT * mueff )
{ d [ r ] [ c ] = Math . sqrt ( m . getEntry ( r , c ) ) ; }
{ d [ r ] [ c ] = Math . log ( m . getEntry ( r , c ) ) ; }
double diff = Math . abs ( x [ i ] - repaired [ i ] ) ;
( NUMBER_CONSTANT - ccovmu ) * NUMBER_CONSTANT * mueff / ( Math . pow ( dimension + NUMBER_CONSTANT , NUMBER_CONSTANT ) + NUMBER_CONSTANT * mueff )
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= Math . sqrt ( sp ) ;
{ double f = Math . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , Math . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , Math . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , Math . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
double diff = Math . abs ( constantValue - filter . getStateEstimation () [ NUMBER_CONSTANT ] ) ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= Math . sqrt ( sp ) ;
{ double f = Math . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
a1 = FastMath . sqrt ( FastMath.PI * twolpd ) * FastMath . exp ( NUMBER_CONSTANT / NUMBER_CONSTANT * lambda )
ret += c [ i ] * ArithmeticUtils . pow ( n , ( long ) i ) ;
public double estimateRegressionStandardError () { return Math . sqrt ( estimateErrorVariance () ) ; }
for ( int i = NUMBER_CONSTANT ; i < length ; i ++ ) { sample [ i ] = Math . random () ; }
int k = ( int ) Math . ceil ( n * d ) ;
final int k = ( int ) Math . ceil ( n * d ) ;
final int k = ( int ) Math . ceil ( n * d ) ;
{ return NUMBER_CONSTANT - NUMBER_CONSTANT * Math . pow ( NUMBER_CONSTANT - d , n ) ; }
final double originalDelta = Math . random () ;
h += p_i * Math . log ( p_i ) ;
h += p_ij * Math . log ( p_ij ) ;
if ( Math . abs ( sumExpected - sumObserved ) > NUMBER_CONSTANT ) { ratio = sumObserved / sumExpected ; rescale = true ; }
System . arraycopy ( seed , NUMBER_CONSTANT , v , NUMBER_CONSTANT , Math . min ( seed.length , v.length ) ) ;
double denom = Math . abs ( val ) < EPS_MIN ? NUMBER_CONSTANT * EPS_MIN : NUMBER_CONSTANT * val ;
double err = Math . abs ( actual - expected ) / Math . ulp ( expected ) ;
final int shift = Math . min ( aTwos , bTwos ) ;
{ public double value ( double x ) { return NUMBER_CONSTANT / ( NUMBER_CONSTANT * Math . sqrt ( x ) ) ; } }
f = new UnivariateFunction () { public double value ( double x ) { return Math . sqrt ( x ) ; } }
Assert . assertTrue ( STRING_CONSTANT , Math . abs ( v - randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) > NUMBER_CONSTANT ) ;
int shift = Math . max ( numerator . bitLength () , denominator . bitLength () ) - FastMath . getExponent ( Float.MAX_VALUE ) ;
int shift = Math . max ( numerator . bitLength () , denominator . bitLength () ) - FastMath . getExponent ( Double.MAX_VALUE ) ;
Math . sqrt ( d [ col ] ) < tol [ col ]
Math . sqrt ( d [ i ] ) < tol [ i ]
double denom = Math . abs ( val ) < EPS_MIN ? NUMBER_CONSTANT * EPS_MIN : NUMBER_CONSTANT * val ;
{ return Math . exp ( x ) - Math . pow ( Math.PI , NUMBER_CONSTANT ) ; }
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double gn = factor1 * Math . log ( qExp1 ) * oneOverN ;
System . arraycopy ( seed , NUMBER_CONSTANT , rsl , NUMBER_CONSTANT , Math . min ( seedLen , rslLen ) ) ;
expected = Math . abs ( period ) - delta ;
double xabs = Math . abs ( v [ i ] ) ;
final double result = NUMBER_CONSTANT * Erf . erfc ( ref [ i ] [ NUMBER_CONSTANT ] / Math . sqrt ( NUMBER_CONSTANT ) ) ;
new Fraction ( ( ( Math . abs ( w ) * d ) + n ) * MathUtils . copySign ( NUMBER_CONSTANT , w ) , d )
num = Math . abs ( num ) ;
{ minValue = entry ; minPos = i ; if ( pivotSelection == PivotSelectionRule.Bland && isValidPivotColumn ( tableau , i ) ) { break; } }
this . pivotSelection = PivotSelectionRule.Dantzig ;
solution = new SimplexSolver () . optimize ( DEFAULT_MAX_ITER , f , new DeterministicLinearConstraintSet ( constraints ) , GoalType.MINIMIZE , new NonNegativeConstraint ( true ) , PivotSelectionRule.BLAND )
{ this ( f , constraints , goalType , restrictToNonNegative , epsilon , SimplexSolver.DEFAULT_ULPS , SimplexSolver.DEFAULT_CUT_OFF ) ; }
if ( Precision . compareTo ( entry , NUMBER_CONSTANT , maxUlps ) > NUMBER_CONSTANT ) { return true ; }
final Vector < Euclidean3D > point
final Vector < Euclidean3D > point
final Vector < S > barycenter
final Vector < S > point
final Vector < S > point
final Vector < Euclidean1D > point
final Vector < Euclidean2D > point
final Vector < Euclidean1D > point
final Vector < Euclidean3D > point
Vector < S > point
final Vector < S > point
{ final Vector2D v2 = ( Vector2D ) v ; return x * v2.x + y * v2.y ; }
final Vector < Euclidean2D > point
final Vector < Euclidean2D > point
final Vector < Euclidean1D > point
final Vector < Euclidean2D > point
final Vector < S > point
{ return Vector3D . angle ( pole , direction ) - radius ; }
public SphericalPolygonsSet wholeSpace () { return new SphericalPolygonsSet () ; }
public SubCircle wholeHyperplane () { return new SubCircle ( this , new ArcsSet () ) ; }
{ this ( circle.pole , circle.x , circle.y , circle.radius , circle.cos , circle.sin ) ; }
public ArcsSet wholeSpace () { return new ArcsSet () ; }
{ return new ArcsSet ( tree ) ; }
final double offset = plane . getOffset ( point ) ;
final Vector1D x = thisLine . toSubSpace ( crossing ) ;
final Vector1D x = thisLine . toSubSpace ( crossing ) ;
final Vector3D point = line . toSpace ( Vector1D.ZERO ) ;
Vector < Euclidean1D > p
Vector < Euclidean2D > p
Vector < Euclidean3D > v
public SubChord copySelf () { return new SubChord ( chord , limits ) ; }
{ this . upper = NUMBER_CONSTANT * FastMath.PI + lower ; }
Arc arc = new Arc ( NUMBER_CONSTANT , FastMath . nextAfter ( NUMBER_CONSTANT , Double.POSITIVE_INFINITY ) ) ;
{ return buildNew ( hyperplane , remainingRegion ) ; }
{ return new PolyhedronsSet ( tree ) ; }
final BSPTree < S > cell = node . getCell ( point ) ;
public IntervalsSet wholeSpace () { return new IntervalsSet () ; }
return getRemainingRegion () . side ( new OrientedPoint ( x , direct ) ) ;
public PolyhedronsSet wholeSpace () { return new PolyhedronsSet () ; }
public SubPlane wholeHyperplane () { return new SubPlane ( this , new PolygonsSet () ) ; }
final Plane plane = new Plane ( origin . add ( translation ) , w ) ;
{ return new PolygonsSet ( tree ) ; }
if ( line == null ) { line = new Line ( start . getLocation () , end . getLocation () ) ; }
final BoundaryProjector projector = new BoundaryProjector () ;
public SubLine wholeLine () { return new SubLine ( this , new IntervalsSet () ) ; }
{ return distance ( p ) < NUMBER_CONSTANT ; }
Segment segment = new Segment ( start , end , new Line ( start , end ) ) ;
Segment segment = new Segment ( p1 , p2 , new Line ( p1 , p2 ) ) ;
{ return new Line ( start , end ) . wholeHyperplane () ; }
return new PolygonsSet ( edges ) ;
return new OrientedPoint ( newLoc , op . isDirect () ) . wholeHyperplane () ;
{ return FastMath . abs ( getOffset ( p ) ) < NUMBER_CONSTANT ; }
public PolygonsSet wholeSpace () { return new PolygonsSet () ; }
public SubLine wholeHyperplane () { return new SubLine ( this , new IntervalsSet () ) ; }
if ( FastMath . abs ( d ) < NUMBER_CONSTANT ) { return null ; }
{ return new ArcsSet ( tree , tolerance ) ; }
{ return new LimitAngle ( new S1Point ( alpha ) , true , tolerance ) . wholeHyperplane () ; }
{ return new LimitAngle ( new S1Point ( alpha ) , false , tolerance ) . wholeHyperplane () ; }
{ super ( boundary ) ; this . tolerance = tolerance ; }
{ super ( tree ) ; this . tolerance = tolerance ; }
public ArcsSet ( final double tolerance ) { this . tolerance = tolerance ; }
final EdgesBuilder visitor = new EdgesBuilder ( root , tolerance ) ;
{ return new SphericalPolygonsSet ( tree , tolerance ) ; }
{ super ( boundary ) ; this . tolerance = tolerance ; }
{ super ( tree ) ; this . tolerance = tolerance ; }
public SphericalPolygonsSet ( final double tolerance ) { this . tolerance = tolerance ; }
{ add ( new NestedLoops ( bLoop ) ) ; }
{ return new IntervalsSet ( tree ) ; }
PolyhedronsSet tree = new PolyhedronsSet ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
boundary . add ( new LimitAngle ( new S1Point ( MathUtils.TWO_PI ) , true , NUMBER_CONSTANT ) . wholeHyperplane () ) ;
( Boolean ) getTree ( false ) . getAttribute ()
Assert . assertTrue ( projection . get0riginal () == v ) ;
List < P > points
final List < P > points
ConvexHull2D hull = generator . generate ( points ) ;
GrahamScan2D generator = new GrahamScan2D () ;
RandomGenerator random = new MersenneTwister ( NUMBER_CONSTANT ) ;
@ Before public void setUp () { generator = createConvexHullGenerator () ; random = new MersenneTwister ( NUMBER_CONSTANT ) ; }
final Collection < Vector2D > points
checkConvexHull ( points , hull ) ;
ConvexHullGenerator2D generator = new MonotoneChain () ;
public Segment [] getLineSegments () { return lineSegments . clone () ; }
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.MINUS_I ) . ballOnSupport ( support ) ;
cap = new SphericalCapGenerator ( new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . ballOnSupport ( support )
cap = new SphericalCapGenerator ( new Vector3D ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ) . ballOnSupport ( support )
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.MINUS_K ) . ballOnSupport ( support ) ;
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.MINUS_K ) . ballOnSupport ( support ) ;
{ return new EnclosingBall < Sphere2D , S2Point > ( new S2Point ( outside . negate () ) , - NUMBER_CONSTANT ) ; }
@ Override protected ConvexHullGenerator2D createConvexHullGenerator ( boolean includeCollinearPoints ) { return new GrahamScan ( includeCollinearPoints ) ; }
{ return getOptimizer ( points ) . optimize () . getPoint () ; }
boolean useLU
optimizer = LevenbergMarquardtOptimizer . create () . withInitialStepBoundFactor ( initialStepBoundFactor ) . withCostRelativeTolerance ( costRelativeTolerance ) . withParameterRelativeTolerance ( parRelativeTolerance ) . withOrthoTolerance ( orthoTolerance ) . withRankingThreshold ( Precision.SAFE_MIN )
{ return LevenbergMarquardtOptimizer . create () ; }
{ return new LeastSquaresProblemImpl ( maxEvaluations , maxIterations , checker , observed , model , jacobian , start ) ; }
public RealMatrix computeJacobian () { return MatrixUtils . createRealMatrix ( this . jacobian ) ; }
public double [] computeValue () { return this . values ; }
@ Test public void testGaussNewtonQR ( ) throws Exception { check ( new GaussNewtonOptimizer ( false ) ) ; }
@ Test public void testGaussNewtonLU ( ) throws Exception { check ( new GaussNewtonOptimizer ( true ) ) ; }
{ return new LeastSquaresBuilder () . checker ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . maxEvaluations ( NUMBER_CONSTANT ) . maxIterations ( getMaxIterations () ) ; }
final ConvergenceChecker < PointVectorValuePair > checker
final ConvergenceChecker < PointVectorValuePair > checker
builder ( circle ) . checker ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . maxIterations ( Integer.MAX_VALUE )
final ConvergenceChecker < PointVectorValuePair > checker
final ConvergenceChecker < PointVectorValuePair > checker
final ConvergenceChecker < PointVectorValuePair > checker
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , NUMBER_CONSTANT ) ;
final double [] point
function . checkTheoreticalMinParams ( optimum . getPoint () ) ;
final double [] point
double [] computeValue ( ) ;
double [] point
double [] getStart ( ) ;
double [] point
final double [] start
final double [] target
public RealVector computeValue () { return unweighted . computeValue () ; }
catch ( NonPositiveDefiniteMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
final double actual = lsp . evaluate ( lsp . getStart () ) . computeRMS () ;
final double cost = lsp . evaluate ( lsp . getStart () ) . computeCost () ;
Assert . assertArrayEquals ( evaluation . computeResiduals () . toArray () , new double [] { NUMBER_CONSTANT , - NUMBER_CONSTANT } , Precision.EPSILON ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertTrue ( optimum . computeRMS () > NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
final double cost = lsp . evaluate ( params ) . computeCost () ;
final RealVector sigma = lsp . evaluate ( regress ) . computeSigma ( NUMBER_CONSTANT ) ;
final RealVector sigma = lsp . evaluate ( init ) . computeSigma ( NUMBER_CONSTANT ) ;
final double [] asymptoticStandardErrorFound = optimum . computeSigma ( NUMBER_CONSTANT ) . toArray () ;
final RealMatrix covarMatrix = optimum . computeCovariances ( NUMBER_CONSTANT ) ;
function . checkTheoreticalMinCost ( optimum . computeRMS () ) ;
RealVector computeValue ( ) ;
Assert . assertNotSame ( STRING_CONSTANT , v1 . getDataRef () , v_copy . getData () ) ;
{ return new LeastSquaresProblemImpl ( model , observed , start , checker , maxEvaluations , maxIterations ) ; }
assertEquals ( TOl , optimum . getValue () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
line = new LineSearch ( lineRel , lineAbs ) ;
line = new LineSearch ( this , lineRel , lineAbs ) ;
{ this ( updateFormula , checker , NUMBER_CONSTANT , NUMBER_CONSTANT , new IdentityPreconditioner () ) ; }
penalty += diff * valueRange ;
public FitnessFunction () { valueRange = NUMBER_CONSTANT ; isRepairMode = true ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( getX () ) ; }
public RealVector getResiduals () { return this . residuals ; }
public RealVector getPoint () { return this . point ; }
public RealMatrix getJacobian () { return this . jacobian ; }
super ( null ) ;
@ Override protected RealDistribution getKernel ( SummaryStatistics bStats ) { return new ConstantDistribution ( bStats . getMean () ) ; }
return new Median () . withEstimationtype ( type ) . withNaNStrategy ( strategy ) ;
double result = new Percentile ( p ) . withEstimationtype ( e ) . withNaNStrategy ( nanStrategy ) . evaluate ( data ) ;
{ new Percentile ( NUMBER_CONSTANT ) . withEstimationtype ( Percentile.EstimationType.LEGACY ) . withNaNStrategy ( null ) ; Assert . fail ( STRING_CONSTANT + STRING_CONSTANT ) ; }
new Percentile ( NUMBER_CONSTANT ) . withEstimationtype ( Percentile.EstimationType.R_9 ) . withNaNStrategy ( NaNStrategy.FAILED ) . evaluate ( specialValues , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new Percentile ( quantile ) . withEstimationtype ( type ) . withNaNStrategy ( nanStrategy ) . withPivotingStrategy ( pivotingStrategy ) ; }
final BicubicSplineInterpolator bsi = new BicubicSplineInterpolator () ;
return new BicubicSplineInterpolatingFunction ( xval , yval , fval , dFdX , dFdY , d2FdXdY ) ;
final FieldMatrix < BigFraction > H = this . createH ( d , n ) ;
{ return new Median ( getEstimationType () , newNaNStrategy , getPivotingStrategy () ) ; }
{ return new Median ( newEstimationType , getNaNStrategy () , getPivotingStrategy () ) ; }
Percentile p = getUnivariateStatistic () ;
Percentile p = getUnivariateStatistic () ;
Percentile p = getUnivariateStatistic () ;
{ for ( Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testWeightedConsistency () ; } }
{ for ( Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testEvaluateArraySegment () ; } }
{ for ( Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testEvaluateArraySegmentWeighted () ; } }
UnivariateStatistic percentile = getUnivariateStatistic () ;
UnivariateStatistic percentile = getUnivariateStatistic () ;
Percentile percentile = new Percentile ( NUMBER_CONSTANT ) ;
return work.length == NUMBER_CONSTANT ? Double.NaN : estimationType . evaluate ( work , pivotsHeap , p , pivotingStrategy ) ;
pivotingStrategy = original . getPivotingStrategy () ;
final double Umin = x.length * y.length - Umax ;
{ return new LazyUnweightedEvaluation ( model , target , p ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , ( ( ResizableDoubleArray ) da ) . getContractionCriteria () , NUMBER_CONSTANT ) ;
ResizableDoubleArray testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ADDITIVE_MODE ) ;
testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ADDITIVE_MODE ) ;
ResizableDoubleArray testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ADDITIVE_MODE ) ;
empiricalDistribution = new EmpiricalDistribution ( binCount , randomData ) ;
{ this . randomData = new RandomDataImpl ( generator ) ; }
{ this . randomData = randomData ; }
RandomDataImpl random = new RandomDataImpl () ;
{ return ( FastMath.PI * FastMath.PI / NUMBER_CONSTANT ) * ( NUMBER_CONSTANT / ( s * s ) ) ; }
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
final FDistribution fdist = new FDistribution ( a.dfbg , a.dfwg ) ;
final NormalDistribution standardNormal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final BinomialDistribution distribution = new BinomialDistribution ( numberOfTrials , probability ) ;
final NormalDistribution standardNormal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( getX () ) ; }
t . insertInTree ( parentTree , isPlusChild ) ;
return ( sin * otherL.sin + cos * otherL.cos ) >= NUMBER_CONSTANT ;
tree = region1 . getTree ( false ) . merge ( region2 . getTree ( false ) , new DifferenceMerger () )
{ originOffset = offset ; }
if ( p == NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else if ( p == NUMBER_CONSTANT ) { return Double.POSITIVE_INFINITY ; }
{ vals = Arrays . copyOf ( b , b.length ) ; nVals = n ; }
cachedTransform = org.apache.commons.math3.geometry.euclidean.twod.Line . getTransform ( at ) ;
cachedTransform = org.apache.commons.math3.geometry.euclidean.twod.Line . getTransform ( at ) ;
@ Test ( expected = org.apache.commons.math3.linear.SingularMatrixException . class )
org.apache.commons.math3.stat.inference.ChiSquareTest csti = new org.apache.commons.math3.stat.inference.ChiSquareTest () ;
org.apache.commons.math3.stat.inference.ChiSquareTest csti = new org.apache.commons.math3.stat.inference.ChiSquareTest () ;
( numIterations < maximumIterations ) && ( a > lowerBound || b > upperBound )
public Well1024a ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well1024a ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497b ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497b ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937a ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937a ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well512a ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well512a ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937c ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937c ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497a ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497a ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
TestUtils . assertEquals ( m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . getData () ) , preMultTest ) ;
TestUtils . assertEquals ( m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . getData () ) , preMultTest ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
x = new UniformRealDistribution ( rng , lo , hi , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
x = new UniformRealDistribution ( rng , lo , hi , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
x = new UniformRealDistribution ( rng , lo , hi , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
{ double actual = getDistribution () . cumulativeProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , actual , NUMBER_CONSTANT ) ; }
distribution . cumulativeProbability ( lower [ i ] , upper [ i ] )
final double withinBinKernelMass = kernel . cumulativeProbability ( lower , upper ) ;
try { distribution . cumulativeProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
( ( AbstractRealDistribution ) distribution ) . logDensity ( cumulativeTestPoints [ i ] )
try { distribution . cumulativeProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
try { StatUtils . min ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . max ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . mean ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
@ Test ( expected = MathIllegalArgumentException . class ) public void testNullFunction () { UnivariateSolverUtils . bracket ( null , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test ( expected = MathIllegalArgumentException . class )
tournamentPopulation = new ListPopulation ( this . arity ) { public Population nextGeneration () { return null ; } }
delta = ( max - min ) / ( ( double ) binCount ) ;
T reciprocal ( ) ;
delta = ( max - min ) / ( binCount ) ;
protected double getSolverAbsoluteAccuracy () { return solverAbsoluteAccuracy ; }
SparseGradient sgY2 = sgX . compose ( poly . value ( x ) , poly . derivative () . value ( x ) ) ;
Assert . assertEquals ( f . polynomialDerivative () . derivative () . value ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , tolerance ) ;
UnivariateFunction dSpline = spline . derivative () ;
{ return FastMath . abs ( getOffset ( p ) ) < NUMBER_CONSTANT ; }
if ( direction . getNorm () < NUMBER_CONSTANT ) { return null ; }
test ( values , begin , length ) ;
ptile . evaluate ( d ) ;
test ( values , begin , length , true )
test ( values , weights , begin , length )
test ( values , begin , length )
test ( values , begin , length , true )
m . evaluate ( values ) ;
m . evaluate ( values ) ;
test ( values , begin , length )
test ( values , start , length ) ;
test ( values , weights , begin , length )
test ( values , begin , length )
test ( values , weights , begin , length , true )
test ( values , begin , length ) && length > NUMBER_CONSTANT
test ( values , begin , length )
{ test ( values , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
test ( values , weights , begin , length , true )
test ( values , begin , length , true )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
catch ( IllegalArgumentException iae ) {}
try { stats . setWindowSize ( - NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException iae ) {}
{ try { new DummyBinaryChromosome ( repr ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException e ) {} }
@ Test ( expected = IllegalArgumentException . class )
catch ( IllegalArgumentException iae ) { return true ; }
catch ( IllegalArgumentException iae ) {}
final double Hs = generalizedHarmonic ( N , s ) ;
final double Hs = generalizedHarmonic ( N , s ) ;
return generalizedHarmonic ( x , exponent ) / generalizedHarmonic ( numberOfElements , exponent ) ;
return - FastMath . log ( x ) * exponent - FastMath . log ( generalizedHarmonic ( numberOfElements , exponent ) ) ;
if ( x != x ) { return x ; }
if ( x != x ) { return x ; }
if ( x != x ) { return Double.NaN ; }
if ( x != x ) { return Double.NaN ; }
if ( x != x || y != y ) { return Double.NaN ; }
if ( x != x || x == NUMBER_CONSTANT ) { return x ; }
if ( x != x ) { return x ; }
if ( x != x ) { return x ; }
if ( x != x ) { return x ; }
{ super ( LocalizedFormats.UNKNOWN_PARAMETER ) ; this . name = name ; }
final int exponent
int brightnessExponent
MultivariateInterpolator interpolator = new MicrosphereInterpolator () ;
{ return ( BigInteger.ZERO . compareTo ( numerator ) <= NUMBER_CONSTANT ) ? this : negate () ; }
final long numCalls = numberOfCalls . incrementAndGet () ;
final Gaussian neighbourhoodDecay = new Gaussian ( currentLearning , NUMBER_CONSTANT , NUMBER_CONSTANT / currentNeighbourhood ) ;
{ return new Fraction ( numerator , denominator * i ) ; }
{ return new Fraction ( numerator * i , denominator ) ; }
TestUtils . assertRelativelyEquals ( expected , ZipfRejectionSampler . helper2 ( testValue ) * testValue , tol ) ;
evaluations . setMaximalCount ( maxEvaluations ) ;
int rowOffset = NUMBER_CONSTANT ;
int swaps = NUMBER_CONSTANT ;
{ if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return FastMath . pow ( NUMBER_CONSTANT - probabilityOfSuccess , x ) * probabilityOfSuccess ; } }
SQRT_TWO_PI / x * FastMath . pow ( y , absX + NUMBER_CONSTANT ) * FastMath . exp ( - y )
return new CorrelatedRandomVectorGenerator ( new double [ cov.length ] , matrix , small , new GaussianRandomGenerator ( new JDKRandomGenerator () ) ) ;
public BigFractionMatrixConverter () { super ( BigFraction.ZERO ) ; }
public FractionMatrixConverter () { super ( Fraction.ZERO ) ; }
final FieldUnivariateFunction < T > f
final FieldUnivariateFunction < T > f
FieldUnivariateFunction < Dfp > f
final EnumeratedRealDistribution dist = new EnumeratedRealDistribution ( combined ) ;
public JDKRandomGenerator ( int seed ) { setSeed ( seed ) ; }
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
starter . addStepHandler ( new NordsieckInitializer ( nSteps , y0.length ) ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
{ evaluations . incrementCount () ; expandable . computeDerivatives ( t , y , yDot ) ; }
evaluations . resetCount () ;
catch ( InitializationCompletedMarkerException icme ) { getEvaluationsCounter () . incrementCount ( starter . getEvaluations () ) ; }
Vector3D axis = r . getAxis () ;
FieldVector3D < DerivativeStructure > axis = r . getAxis () ;
FieldVector3D < Dfp > axis = r . getAxis () ;
final Rotation composite = r3 . applyTo ( r2 . applyTo ( r1 ) ) ;
{ return r1 . applyInverseTo ( r2 ) . getAngle () ; }
{ return r1 . applyInverseTo ( r2 ) . getAngle () ; }
{ try { return super . nextInt ( n ) ; } catch ( IllegalArgumentException e ) { throw new NotStrictlyPositiveException ( n ) ; } }
{ setSeed ( RandomGeneratorFactory . convertToLong ( seed ) ) ; }
{ setSeed ( ( long ) seed ) ; }
setSeed ( seed ) ;
{ setSeed ( seed ) ; }
public ISAACRandom ( long seed ) { setSeed ( seed ) ; }
{ setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ bits = ( nextInt () > > > NUMBER_CONSTANT ) ; val = bits % n ; }
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ setSeed ( new int [] { seed } ) ; }
return computeInterpolatedStateAndDerivatives ( equations , theta , oneMinusThetaH ) ;
equations = null ;
yDotK [ NUMBER_CONSTANT ] = stepStart . getDerivative () ;
mainSetDimension = eqn . getState () . length ;
FieldBracketingNthOrderBrentSolver < T > solver
final FieldBracketingNthOrderBrentSolver < T > solver
final FieldBracketingNthOrderBrentSolver < T > solver
public TestProblem5 () { super(); setFinalConditions ( NUMBER_CONSTANT * t0 - t1 ) ; }
for ( int i = NUMBER_CONSTANT ; i < n ; ++ i ) { y [ i ] = c ; }
i < n
i < n
i < n
i < n
currentState = y . clone () ;
super ( field , METHOD_NAME , true , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , true , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
super ( field , METHOD_NAME , true , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , true , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
start . subtract ( problem . getInitialTime () ) . divide ( integrator . getCurrentSignedStepsize () ) . abs () . getReal () > NUMBER_CONSTANT
super ( field , METHOD_NAME , false , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , false , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
{ super ( field ) ; setFinalConditions ( getInitialTime () . multiply ( NUMBER_CONSTANT ) . subtract ( getFinalTime () ) ) ; }
{ return integrator . getField () . getOne () . multiply ( p ) . divide ( q ) ; }
d = MathArrays . buildArray ( integrator . getField () , NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
{ finalizeStep () ; return doCopy () ; }
{ return new EulerFieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new DormandPrince54FieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new DormandPrince853FieldStepInterpolator < T > ( this , forward , mapper ) ; }
final T one = time . getField () . getOne () ;
{ return new MidpointFieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new HighamHall54FieldStepInterpolator < T > ( this , forward , mapper ) ; }
final T coeffDot1 = time . getField () . getOne () . subtract ( coeffDot2 ) ;
{ return new ClassicalRungeKuttaFieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new GillFieldStepInterpolator < T > ( this , forward , mapper ) ; }
final T one = time . getField () . getOne () ;
{ return new LutherFieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new ThreeEighthesFieldStepInterpolator < T > ( this , forward , mapper ) ; }
final T two = getField () . getOne () . multiply ( NUMBER_CONSTANT ) ;
{ return getField () . getOne () . multiply ( p ) . divide ( q ) ; }
{ return new EulerFieldStepInterpolator <> ( field , forward , mapper ) ; }
integ . integrate ( new FieldExpandableODE <> ( equations ) , new FieldODEState < T > ( t0 , y0 ) , t ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
mapper = new FieldEquationsMapper <> ( mapper , secondary . getDimension () ) ;
integrator . integrate ( new FieldExpandableODE <> ( problem ) , problem . getInitialState () , problem . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
FieldFirstOrderDifferentialEquations < T > eqn = new SinCos <> ( field ) ;
setUpInterpolator ( field , new SinCos <> ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
setUpInterpolator ( field , new SinCos <> ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
steps . add ( interpolator . copy () ) ;
for ( FieldStepInterpolator < T > interpolator : model.steps ) { steps . add ( interpolator . copy () ) ; }
while ( ++ index < getNumberOfEquations () ) { insertEquationData ( index , state . getSecondaryDerivative ( index - NUMBER_CONSTANT ) , yDot ) ; }
while ( ++ index < getNumberOfEquations () ) { insertEquationData ( index , state . getSecondaryState ( index - NUMBER_CONSTANT ) , y ) ; }
{ System . arraycopy ( mapper.start , NUMBER_CONSTANT , start , NUMBER_CONSTANT , index ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test
@ Test
@ Test
@ Test
@ Test
@ Test
@ Test
@ Test
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
FieldFirstOrderIntegrator < T > integrator
final FieldFirstOrderDifferentialEquations < T > primary
final FieldFirstOrderIntegrator < T > integrator
final FieldFirstOrderDifferentialEquations < T > equations
final FieldFirstOrderDifferentialEquations < T > eqn
final FieldFirstOrderDifferentialEquations < T > eqn
{ return taylor ( getPreviousState () , time , scalingH , scaled , nordsieck ) ; }
@ Test ( expected = MaxCountExceededException . class ) public void exceedMaxEvaluations () { doExceedMaxEvaluations ( Decimal64Field . getInstance () ) ; }
if ( seed == null ) { setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
if ( seed == null ) { setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ setSeedInternal ( new int [] { seed } ) ; }
{ bits = nextInt () > > > NUMBER_CONSTANT ; val = bits % n ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ setSeedInternal ( seed ) ; }
public ISAACRandom ( long seed ) { setSeedInternal ( seed ) ; }
{ setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
setSeedInternal ( seed ) ;
{ return timeAndReport ( title , DEFAULT_REPEAT_CHUNK , DEFAULT_REPEAT_STAT , false , methods ) ; }
double sample ( ) ;
random = new Well44497b ( seed ) ;
{ this ( cityList , numNeuronsPerCity , new Well44497b () . nextLong () ) ; }
final TDistribution distribution = new TDistribution ( null , degreesOfFreedom ) ;
final TDistribution distribution = new TDistribution ( null , degreesOfFreedom ) ;
final TDistribution distribution = new TDistribution ( null , n - NUMBER_CONSTANT ) ;
return empiricalDistribution . getNextValue () ;
empiricalDistribution = new EmpiricalDistribution ( binCount , randomData . getRandomGenerator () ) ;
{ super ( null ) ; this . value = value ; }
final NormalDistribution standardNormal = new NormalDistribution ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final NormalDistribution standardNormal = new NormalDistribution ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final FDistribution fdist = new FDistribution ( null , a.dfbg , a.dfwg ) ;
final FDistribution fdist = new FDistribution ( null , a.dfbg , a.dfwg ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
{ final double u = random . nextDouble () ; return u * upper + ( NUMBER_CONSTANT - u ) * lower ; }
final BinomialDistribution distribution = new BinomialDistribution ( null , numberOfTrials , probability ) ;
{ randomSource = RandomSource.WELL_19937_C ; }
return complexSolver . solve ( ComplexUtils . convertToComplex ( coefficients ) , new Complex ( initial , NUMBER_CONSTANT ) ) ;
return complexSolver . solveAll ( ComplexUtils . convertToComplex ( coefficients ) , new Complex ( initial , NUMBER_CONSTANT ) ) ;
final Complex c [] = ComplexUtils . convertToComplex ( getCoefficients () ) ;
RandomGenerator rng = new Well19937c ( NUMBER_CONSTANT ) ;
NormalDistribution distribution
if ( shuffle ) { Collections . shuffle ( points ) ; }
if ( shuffle ) { Collections . shuffle ( points ) ; }
if ( shuffle ) { Collections . shuffle ( points ) ; }
for ( int i = NUMBER_CONSTANT ; i < dim ; i ++ ) { normalVals [ i ] = random . nextGaussian () ; }
cachedD = MatrixUtils . createRealDiagonalMatrix ( realEigenvalues ) ;
ComplexFormat cf = ComplexFormat . getInstance () ;
ComplexFormat cf = ComplexFormat . getInstance () ;
RandomGenerator randomGenerator
public NaturalRanking ( RandomGenerator randomGenerator ) { this ( DEFAULT_NAN_STRATEGY , TiesStrategy.RANDOM , randomGenerator ) ; }
{ this ( nanStrategy , tiesStrategy , new Well19937c () ) ; }
{ this ( DEFAULT_NAN_STRATEGY , tiesStrategy , new Well19937c () ) ; }
final RandomGenerator random
final RandomGenerator random
{ this ( k , maxIterations , measure , new JDKRandomGenerator () ) ; }
final RandomGenerator random = new JDKRandomGenerator () ;
final RandomGenerator random
{ this ( k , fuzziness , maxIterations , measure , DEFAULT_EPSILON , new JDKRandomGenerator () ) ; }
final RandomGenerator random
final RandomGenerator random = GeneticAlgorithm . getRandomGenerator () ;
RandomGenerator randGen = getRandomGenerator () ;
final RandomGenerator random
final RandomGenerator random = GeneticAlgorithm . getRandomGenerator () ;
final RandomGenerator random = GeneticAlgorithm . getRandomGenerator () ;
{ d [ r ] [ c ] = random . nextGaussian () ; }
for ( int i = NUMBER_CONSTANT ; i < size ; i ++ ) { randn [ i ] = random . nextGaussian () ; }
final RandomGenerator generator
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
UnitSphereRandomVectorGenerator random = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , new Well1024a ( NUMBER_CONSTANT ) ) ;
UnitSphereRandomVectorGenerator random = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , new Well1024a ( NUMBER_CONSTANT ) ) ;
final double comp = rand . nextGaussian () ;
{ this ( dimension , new MersenneTwister () ) ; }
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator generator = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator generator = new Well1024a ( NUMBER_CONSTANT ) ;
{ field = new DfpField ( NUMBER_CONSTANT ) ; generator = new MersenneTwister ( NUMBER_CONSTANT ) ; }
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator rng = new Well19937a ( NUMBER_CONSTANT ) ;
final RandomGenerator r
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator rng = new Well1024a ( NUMBER_CONSTANT ) ;
new PivotingStrategyInterface [] { new MedianOf3PivotingStrategy () , new CentralPivotingStrategy () , new RandomPivotingStrategy ( RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) }
kthSelector = new KthSelector ( new RandomPivotingStrategy ( RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) ) ;
final RandomGenerator rng = new MersenneTwister () ;
return TestUtils . gTest ( expected , observed ) ;
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( random ) ) ; }
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( delegate ) ) ; }
this . rng = new Well19937c ( seed ) ;
final RandomGenerator random = GeneticAlgorithm . getRandomGenerator () ;
rng = new Well19937c ( seed ) ;
RandomGenerator random = new MersenneTwister () ;
List < Integer > baseSequence = new ArrayList < Integer > ( l ) ;
List < S > origDataCopy = new ArrayList < S > ( originalData ) ;
List < S > sortedData = new ArrayList < S > ( data ) ;
List < Double > repr = new ArrayList < Double > ( l ) ;
List < Double > repr = new ArrayList < Double > ( l ) ;
List < Double > sortedRepr = new ArrayList < Double > ( getRepresentation () ) ;
this . hParam = new HashMap < String , Double > () ;
BlockFieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
BlockFieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
return new ArrayFieldVector < Fraction > ( data , false ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
{ Assert . assertEquals ( new BlockFieldMatrix < Fraction > ( reference ) , sub ) ; }
{ Assert . assertEquals ( new BlockFieldMatrix < Fraction > ( reference ) , sub ) ; }
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
final List < double [] > paramsAndChi2 = new ArrayList < double [] > ( gridSize * gridSize ) ;
FirstOrderFieldDifferentialEquations < T > eqn = new SinCos < T > ( field ) ;
setUpInterpolator ( field , new SinCos < T > ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
setUpInterpolator ( field , new SinCos < T > ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
return new FieldODEStateAndDerivative < T > ( time , y , yDot ) ;
this . interpolator = new PerfectInterpolator < T > ( problem ) ;
boundary = new ArrayList < SubHyperplane < Euclidean3D > > ()
{ return new BSPTree < Euclidean3D > ( Boolean.FALSE ) ; }
final List < Neuron > neuronList = new ArrayList < Neuron > () ;
final List < Neuron > neurons = new ArrayList < Neuron > () ;
{ copy.linkMap . put ( e . getKey () , new HashSet < Long > ( e . getValue () ) ) ; }
return new Array2DRowFieldMatrix < T > ( pData , false ) ;
{ return new ArrayList < WeightedObservedPoint > ( observations ) ; }
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( fData , false ) ;
FieldMatrix < BigFraction > m = new Array2DRowFieldMatrix < BigFraction > ( bfData , false ) ;
List < CentroidCluster < T > > newClusters = new ArrayList < CentroidCluster < T > > () ;
final Collection < Neuron > exclude = new ArrayList < Neuron > () ;
List < Number > components = new ArrayList < Number > () ;
return new FieldODEStateAndDerivative < S > ( time , estimatedState , estimatedDerivatives ) ;
this . nordsieck = new Array2DRowFieldMatrix < T > ( nordsieck . getData () , false ) ;
List < Chromosome > popList = new LinkedList < Chromosome > () ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
{ return new ThreeEighthesFieldIntegrator < T > ( field , step ) ; }
{ innerDistribution = new EnumeratedDistribution < Double > ( createDistribution ( singletons , probabilities ) ) ; }
{ return new Pair < K , V > ( k , v ) ; }
{ return new ClassicalRungeKuttaFieldIntegrator < T > ( field , field . getOne () ) ; }
return new Array2DRowFieldMatrix < T > ( field , d , false ) ;
List < Vector2D > support = new ArrayList < Vector2D > () ;
{ return new ArrayList < String > () ; }
{ points = new ArrayList < double [] > () ; sigma = error ; }
ArrayFieldVector < T > out = new ArrayFieldVector < T > ( field , n ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
{ return new ArrayFieldVector < T > ( this , v ) ; }
final FieldMatrix < T > out = new Array2DRowFieldMatrix < T > ( field , m , n ) ;
final FieldMatrix < T > out = new Array2DRowFieldMatrix < T > ( field , m , n ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
{ return new ArrayFieldVector < T > ( this , true ) ; }
List < Comparable < > > modeList = new ArrayList < Comparable < > > () ;
TestFieldProblem3 < T > pb = new TestFieldProblem3 < T > ( field ) ;
return new Pair < RealMatrix , RealVector > ( normal , jTr ) ;
{ return new FieldODEState < T > ( t0 , y0 ) ; }
final Set < City > unique = new HashSet < City > () ;
final List < Future < > > execOutput = new ArrayList < Future < > > () ;
{ return new EulerFieldIntegrator < T > ( field , step ) ; }
{ return new ThreeEighthesFieldIntegrator < T > ( field , field . getOne () ) ; }
{ return new SparseFieldMatrix < T > ( getField () , rowDimension , columnDimension ) ; }
{ return new SparseFieldMatrix < T > ( this ) ; }
entries = new OpenIntToFieldHashMap < T > ( getField () ) ;
entries = new OpenIntToFieldHashMap < T > ( other.entries ) ;
entries = new OpenIntToFieldHashMap < T > ( field ) ;
entries = new OpenIntToFieldHashMap < T > ( field ) ;
singletons = new ArrayList < T > ( pmf . size () ) ;
final FuzzyKMeansClusterer < DoublePoint > clusterer = new FuzzyKMeansClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final HashSet < Double > values = new HashSet < Double > () ;
return new Array2DRowFieldMatrix < BigFraction > ( BigFractionField . getInstance () , Hdata ) ;
Collection < Neuron > exclude = new HashSet < Neuron > () ;
Collection < Neuron > exclude = new HashSet < Neuron > () ;
final List < Long > linkEnd = new ArrayList < Long > () ;
final List < BigFraction > list = new ArrayList < BigFraction > () ;
final List < Segment > segments = new ArrayList < Segment > ( list . size () ) ;
binStats = new ArrayList < SummaryStatistics > () ;
final Set < T > oneSet = new HashSet < T > ( one ) ;
final List < T > neighbors = new ArrayList < T > () ;
List < T > seeds = new ArrayList < T > ( neighbors ) ;
final List < Object > orig = new ArrayList < Object > () ;
context = new HashMap < String , Object > () ;
final Set < Integer > usedBasicRows = new HashSet < Integer > () ;
final Set < Integer > columnsToDrop = new TreeSet < Integer > () ;
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > ( originalConstraints . size () ) ;
this . derivatives = new HashMap < Integer , Double > () ;
this . derivatives = new HashMap < Integer , Double > () ;
final FieldODEStateAndDerivative < T > state0 = new FieldODEStateAndDerivative < T > ( t0 , y0 , y0Dot ) ;
return new Array2DRowFieldMatrix < Fraction > ( out ) ;
Array2DRowFieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
return new ArrayFieldVector < Fraction > ( data , false ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
{ Assert . assertEquals ( new Array2DRowFieldMatrix < Fraction > ( reference ) , sub ) ; }
{ Assert . assertEquals ( new Array2DRowFieldMatrix < Fraction > ( reference ) , sub ) ; }
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
@ Before public void setUp () { evaluator = new SumOfClusterVariances < DoublePoint > ( new EuclideanDistance () ) ; }
final List < WeightedObservedPoint > observations = new ArrayList < WeightedObservedPoint > ( unsorted ) ;
RegionFactory < Sphere1D > factory = new RegionFactory < Sphere1D > () ;
List < SubHyperplane < Sphere1D > > boundary = new ArrayList < SubHyperplane < Sphere1D > > () ;
List < Integer > newRepr = new ArrayList < Integer > ( origChrom . getRepresentation () ) ;
this . representation = Collections . unmodifiableList ( copyList ? new ArrayList < T > ( representation ) : representation ) ;
final RegionFactory < Euclidean2D > factory = new RegionFactory < Euclidean2D > () ;
final List < EventHandler > list = new ArrayList < EventHandler > ( eventsStates . size () ) ;
final List < double [] > coordinatesList = new ArrayList < double [] > () ;
final List < Neuron > list = new ArrayList < Neuron > () ;
final List < City > cityList = new ArrayList < City > () ;
final ArrayList < Double > list = new ArrayList < Double > () ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , nCols , nRows ) ;
return new ArrayFieldVector < T > ( getField () , outData , false ) ;
return new ArrayFieldVector < T > ( getField () , outData , false ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , NUMBER_CONSTANT ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , NUMBER_CONSTANT , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , m.columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
{ return new BlockFieldMatrix < T > ( getField () , rowDimension , columnDimension ) ; }
List < Vector2D > points = new ArrayList < Vector2D > ( size ) ;
List < Vector2D > points = new ArrayList < Vector2D > () ;
List < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList < Object > () , transformers ) ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList < Object > () , transformers ) ;
DescriptiveStatistics u = new ListUnivariateImpl ( new ArrayList < Object > () , transformers ) ;
List < Object > externalList = new ArrayList < Object > () ;
List < Chromosome > popList = new LinkedList < Chromosome > () ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
{ map = new HashMap < Class < > , NumberTransformer > () ; defaultTransformer = new DefaultTransformer () ; }
return new SparseFieldVector < Fraction > ( field , t ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
SparseFieldVector < Fraction > v1 = new SparseFieldVector < Fraction > ( field , vec1 ) ;
SparseFieldVector < Fraction > v1 = new SparseFieldVector < Fraction > ( field , vec1 ) ;
BSPTree < Sphere1D > tree = new BSPTree < Sphere1D > ( Boolean.FALSE ) ;
final List < Arc > list = new ArrayList < Arc > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
final ArrayList < Object [] > parameters = new ArrayList < Object [] > () ;
this . listeners = new CopyOnWriteArrayList < IterationListener > () ;
this . listeners = new CopyOnWriteArrayList < IterationListener > () ;
close = new ArrayList < BSPTree < S > > ()
ArrayList < Integer > out = new ArrayList < Integer > () ;
steps = new ArrayList < FieldStepInterpolator < T > > () ;
List < Vector2D > quadrilateral = new ArrayList < Vector2D > () ;
final List < Vector2D > reducedPoints = new ArrayList < Vector2D > ( quadrilateral ) ;
final ArrayList < Integer > nonZeroPositions = new ArrayList < Integer > () ;
List < Integer > minRatioPositions = new ArrayList < Integer > () ;
ArrayList < SubHyperplane < Euclidean2D > > edges = new ArrayList < SubHyperplane < Euclidean2D > > () ;
RegionFactory < Euclidean2D > factory = new RegionFactory < Euclidean2D > () ;
final List < Segment > segments = new ArrayList < Segment > ( list . size () ) ;
loops = new ArrayList < Vertex > () ;
{ return new FieldLUDecomposition < Fraction > ( m ) . getDeterminant () . doubleValue () ; }
solver = new FieldLUDecomposition < Fraction > ( createFractionMatrix ( singular ) ) . getSolver () ;
solver = new FieldLUDecomposition < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
final FieldODEStateAndDerivative < T > stateTmp = new FieldODEStateAndDerivative < T > ( stepEnd , yTmp , yDotTmp ) ;
return new Array2DRowFieldMatrix < BigFraction > ( pData , false ) ;
final List < Complex > result = new ArrayList < Complex > () ;
return new FieldRotation < DerivativeStructure > ( mds , threshold ) ;
FieldRotation < DerivativeStructure > quat = new FieldRotation < DerivativeStructure > ( u1 , u2 , v1 , v2 ) ;
public ListUnivariateImpl () { this ( new ArrayList < Object > () ) ; }
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
tasks = new ArrayList < Callable < Double > > ()
NPointCrossover < Integer > npc = new NPointCrossover < Integer > ( order ) ;
RegionFactory < Sphere1D > factory = new RegionFactory < Sphere1D > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator < Dfp > () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator < Dfp > () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator < Dfp > () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator < Dfp > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
List < Vector2D > reducedSupport = new ArrayList < Vector2D > () ;
List < Vector2D > list = new ArrayList < Vector2D > ( coordinates.length / NUMBER_CONSTANT ) ;
List < Vector2D > points = new ArrayList < Vector2D > () ;
WelzlEncloser < Euclidean2D , Vector2D > encloser = new WelzlEncloser < Euclidean2D , Vector2D > ( NUMBER_CONSTANT , generator ) ;
WelzlEncloser < Euclidean2D , Vector2D > encloser = new WelzlEncloser < Euclidean2D , Vector2D > ( NUMBER_CONSTANT , generator ) ;
Collection < SummaryStatistics > aggregate = new ArrayList < SummaryStatistics > () ;
Collection < SummaryStatistics > aggregate = new ArrayList < SummaryStatistics > () ;
Collection < StatisticalSummary > aggregate = new ArrayList < StatisticalSummary > () ;
Collection < SummaryStatistics > aggregate = new ArrayList < SummaryStatistics > () ;
List < Chromosome > chromosomes = new ArrayList < Chromosome > ( population . getChromosomes () ) ;
ContinuousOutputFieldModel < T > otherCm = new ContinuousOutputFieldModel < T > () ;
ContinuousOutputFieldModel < T > cm = new ContinuousOutputFieldModel < T > () ;
edges = new ArrayList < SubHyperplane < Euclidean2D > > ()
final List < Field > fields = new ArrayList < Field > () ;
output = new ArrayList < Double > () ;
{ return new GillFieldIntegrator < T > ( field , field . getOne () ) ; }
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
{ return new Array2DRowFieldMatrix < T > ( getField () , rowDimension , columnDimension ) ; }
{ return new LutherFieldIntegrator < T > ( field , step ) ; }
this . convexCellsInsidePoints = new ArrayList < Vector3D > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
List < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
List < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
return new ArrayList < Edge > ( edgeToNode . keySet () ) ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
List < Vector3D > support = new ArrayList < Vector3D > () ;
return new ArrayFieldVector < Fraction > ( t ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( vec1 ) ;
ArrayFieldVector < Fraction > v1 = new ArrayFieldVector < Fraction > ( vec1 ) ;
return new FieldVectorTestImpl < T > ( out ) ;
final BoundarySizeVisitor < S > visitor = new BoundarySizeVisitor < S > () ;
final BoundaryProjector < S , T > projector = new BoundaryProjector < S , T > ( point ) ;
{ tree = new BSPTree < S > ( Boolean.FALSE ) ; }
{ this . tree = new BSPTree < S > ( Boolean.TRUE ) ; this . tolerance = tolerance ; }
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
RegionFactory < Sphere1D > factory = new RegionFactory < Sphere1D > () ;
RegionFactory < Sphere2D > factory = new RegionFactory < Sphere2D > () ;
RegionFactory < Sphere2D > factory = new RegionFactory < Sphere2D > () ;
List < SubHyperplane < Sphere2D > > boundary = new ArrayList < SubHyperplane < Sphere2D > > () ;
List < SubHyperplane < Sphere2D > > boundary = new ArrayList < SubHyperplane < Sphere2D > > () ;
RegionFactory < Sphere2D > factory = new RegionFactory < Sphere2D > () ;
RegionFactory < Sphere2D > factory = new RegionFactory < Sphere2D > () ;
final ArrayList < Object [] > parameters = new ArrayList < Object [] > () ;
TestFieldProblem3 < T > pb = new TestFieldProblem3 < T > ( field ) ;
RegionFactory < Euclidean3D > factory = new RegionFactory < Euclidean3D > () ;
newClusters = new ArrayList < CentroidCluster < T > > ( k )
HashSet < Object > sampSet = new HashSet < Object > () ;
{ return new FieldVector3D < T > ( NUMBER_CONSTANT , this , factor , v ) ; }
microsphereData = new ArrayList < FacetData > ( size ) ;
OnePointCrossover < Integer > opc = new OnePointCrossover < Integer > () ;
{ return new MidpointFieldIntegrator < T > ( field , field . getOne () ) ; }
KMeansPlusPlusClusterer < DoublePoint > transformer = new KMeansPlusPlusClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
{ return new ClassicalRungeKuttaFieldIntegrator < T > ( field , step ) ; }
final ArrayList < String > lines = new ArrayList < String > () ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList < Object > () ) ;
List < Object > list = new ArrayList < Object > () ;
List < Object > externalList = new ArrayList < Object > () ;
mapper = new FieldEquationsMapper < T > ( mapper , secondary . getDimension () ) ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
DBSCANClusterer < DoublePoint > clusterer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > clusterer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
List < Vector3D > reducedSupport = new ArrayList < Vector3D > () ;
List < Vector3D > points = new ArrayList < Vector3D > () ;
WelzlEncloser < Euclidean3D , Vector3D > encloser = new WelzlEncloser < Euclidean3D , Vector3D > ( NUMBER_CONSTANT , generator ) ;
WelzlEncloser < Euclidean3D , Vector3D > encloser = new WelzlEncloser < Euclidean3D , Vector3D > ( NUMBER_CONSTANT , generator ) ;
regions = new ArrayList < Region < T > > ( NUMBER_CONSTANT )
return new BoundaryProjection < S > ( original , projected , offset ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
Map < Integer , Fraction > generated = new HashMap < Integer , Fraction > () ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
Set < Integer > keysInMap = new HashSet < Integer > ( javaMap . keySet () ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field , NUMBER_CONSTANT ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
Map < Integer , Fraction > map = new HashMap < Integer , Fraction > () ;
integrator . integrate ( new FieldExpandableODE < T > ( problem ) , problem . getInitialState () , problem . getFinalTime () ) ;
{ return new GillFieldIntegrator < T > ( field , step ) ; }
{ components = new ArrayList < ExpandableStatefulODE.SecondaryComponent > () ; firstIndex = primary . getDimension () ; }
this . components = new ArrayList < ExpandableStatefulODE.SecondaryComponent > () ;
{ return new EulerFieldIntegrator < T > ( field , field . getOne () ) ; }
{ this . tolerance = tolerance ; this . segments = new ArrayList < ConnectableSegment > () ; }
final List < Segment > loop = new ArrayList < Segment > () ;
loops = new ArrayList < List < Segment > > ()
this . lines = new ArrayList < Line > () ;
List < Frequency > coll = new ArrayList < Frequency > () ;
List < Double > valuesList = new ArrayList < Double > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final HashMap < Neuron , Integer > hit = new HashMap < Neuron , Integer > () ;
final List < PairNeuronDouble > list = new ArrayList < PairNeuronDouble > () ;
this . circles = new ArrayList < Circle > () ;
this . jacobianProviders = new ArrayList < ParameterJacobianProvider > () ;
{ return new LutherFieldIntegrator < T > ( field , field . getOne () ) ; }
this . chromosomes = new ArrayList < Chromosome > ( populationLimit ) ;
{ innerDistribution = new EnumeratedDistribution < Integer > ( createDistribution ( singletons , probabilities ) ) ; }
steps = new ArrayList < StepInterpolator > () ;
public CircleVectorial () { points = new ArrayList < Vector2D > () ; }
final List < Interval > list = new ArrayList < Interval > () ;
return new FieldRotation < Dfp > ( mds , threshold ) ;
FieldRotation < Dfp > quat = new FieldRotation < Dfp > ( u1 , u2 , v1 , v2 ) ;
final ArrayList < Object [] > parameters = new ArrayList < Object [] > () ;
List < Object [] > list = new ArrayList < Object [] > () ;
List < Chromosome > popList = new ArrayList < Chromosome > () ;
final ArrayList < Double > integrationTestPoints = new ArrayList < Double > () ;
root = new BSPTree < S > () ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
public Cluster () { points = new ArrayList < T > () ; }
List < Integer > rList = new ArrayList < Integer > ( length ) ;
{ return new MidpointFieldIntegrator < T > ( field , step ) ; }
Map < String , String > referenceRules = new HashMap < String , String > () ;
Map < String , String > referenceRules = new HashMap < String , String > () ;
return new FieldODEState < T > ( state . getTime () , y ) ;
SparseFieldVector < T > res = new SparseFieldVector < T > ( this ) ;
FieldMatrix < T > res = new SparseFieldMatrix < T > ( field , virtualSize , n ) ;
SparseFieldMatrix < T > res = new SparseFieldMatrix < T > ( field , virtualSize , n ) ;
SparseFieldVector < T > res = new SparseFieldVector < T > ( field , n ) ;
SparseFieldVector < T > res = new SparseFieldVector < T > ( this ) ;
SparseFieldVector < T > res = new SparseFieldVector < T > ( this ) ;
{ return new SparseFieldVector < T > ( this ) ; }
FieldVector < T > res = new SparseFieldVector < T > ( this , NUMBER_CONSTANT ) ;
FieldVector < T > res = new SparseFieldVector < T > ( this , n ) ;
entries = new OpenIntToFieldHashMap < T > ( v . getEntries () ) ;
entries = new OpenIntToFieldHashMap < T > ( field ) ;
entries = new OpenIntToFieldHashMap < T > ( field , expectedSize ) ;
entries = new OpenIntToFieldHashMap < T > ( v.entries ) ;
entries = new OpenIntToFieldHashMap < T > ( field ) ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
{ new SparseFieldMatrix < Fraction > ( field , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
return new ArrayFieldVector < Fraction > ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayFieldVector < Fraction > ( testVector ) ) . toArray () , entryTolerance ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testDataInv ) ) , identity , entryTolerance ) ;
Map < Integer , Double > generated = new HashMap < Integer , Double > () ;
Set < Integer > keysInMap = new HashSet < Integer > ( javaMap . keySet () ) ;
Map < Integer , Double > map = new HashMap < Integer , Double > () ;
final List < Integer > factors = new ArrayList < Integer > ( NUMBER_CONSTANT ) ;
final List < WeightedObservedPoint > observations = new ArrayList < WeightedObservedPoint > ( unsorted ) ;
final FieldODEStateAndDerivative < T > stateTmp = new FieldODEStateAndDerivative < T > ( stepEnd , yTmp , yDotTmp ) ;
certifiedValues = new HashMap < String , Double > () ;
final Collection < SummaryStatistics > categoryDataSummaryStatistics = new ArrayList < SummaryStatistics > ( categoryData . size () ) ;
distribution = new ArrayList < T > () ;
List < Chromosome > popChr = new ArrayList < Chromosome > () ;
final List < WeightedObservedPoint > points = new ArrayList < WeightedObservedPoint > () ;
final List < Object > list = new ArrayList < Object > () ;
final SimplePointChecker < PointValuePair > checker = new SimplePointChecker < PointValuePair > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final SimplePointChecker < PointValuePair > checker = new SimplePointChecker < PointValuePair > ( NUMBER_CONSTANT , NUMBER_CONSTANT , max ) ;
{ parametersNames = new ArrayList < String > () ; parametersNames . addAll ( names ) ; }
parametersNames = new ArrayList < String > () ;
final Set < Neuron > list = new HashSet < Neuron > () ;
p2 = new Pair < String , Integer > ( STRING_CONSTANT , NUMBER_CONSTANT )
FieldMatrix < T > identity = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
return new Array2DRowFieldMatrix < T > ( field , bp , false ) ;
return new ArrayFieldVector < T > ( bp , false ) ;
return new ArrayFieldVector < T > ( field , bp , false ) ;
{ return new Solver < T > ( field , lu , pivot , singular ) ; }
cachedP = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
cachedU = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
cachedL = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
FieldBracketingNthOrderBrentSolver < Dfp > solver = new FieldBracketingNthOrderBrentSolver < Dfp > ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ;
FieldBracketingNthOrderBrentSolver < Dfp > solver = new FieldBracketingNthOrderBrentSolver < Dfp > ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ;
{ new FieldBracketingNthOrderBrentSolver < Dfp > ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ; }
RegionFactory < Euclidean2D > factory = new RegionFactory < Euclidean2D > () ;
{ this . surrounded = new ArrayList < NestedLoops > () ; this . tolerance = tolerance ; }
points = new ArrayList < double [] > () ;
public CircleScalar () { points = new ArrayList < Vector2D > () ; }
RegionFactory < Euclidean1D > factory = new RegionFactory < Euclidean1D > () ;
this . features = new AtomicReference < double [] > ( features . clone () ) ;
List < Double > newRepr = new ArrayList < Double > ( repr ) ;
TreeSet < Double > values = new TreeSet < Double > () ;
final List < PairDoubleInteger > list = new ArrayList < PairDoubleInteger > ( len ) ;
final Chromosome p1c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
public StepInterpolator copy () { return this ; }
final Chromosome p1c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
population = new ListPopulation ( chromosomes , NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
new ListPopulation ( chromosomes , NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } } ;
new ListPopulation ( chromosomes , - NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } } ;
{ new ListPopulation ( - NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } } ; }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
final Chromosome p1c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
public StepInterpolator copy () { return this ; }
final Chromosome p1c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
for ( int val : this . getRepresentation () ) { if ( val != NUMBER_CONSTANT ) num ++ ; }
if ( counts [ i ] == - NUMBER_CONSTANT ) continue;
if ( count ++ > NUMBER_CONSTANT ) break;
if ( count ++ > NUMBER_CONSTANT ) break;
RandomSource . restoreState ( random , state ) ;
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( random ) . getState () ) ; }
RandomSource . restoreState ( delegate , state ) ;
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( delegate ) . getState () ) ; }
{ double n = upper - lower + NUMBER_CONSTANT ; return ( n * n - NUMBER_CONSTANT ) / NUMBER_CONSTANT ; }
{ return NUMBER_CONSTANT * ( lower + upper ) ; }
return ( x - lower + NUMBER_CONSTANT ) / ( upper - lower + NUMBER_CONSTANT ) ;
return NUMBER_CONSTANT / ( upper - lower + NUMBER_CONSTANT ) ;
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomSource.State ) random . saveState () ) . getState () ) ; }
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomSource.State ) delegate . saveState () ) . getState () ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
TranslationTransform ( final Vector3D translation ) { this . translation = translation ; }
final Vector3D translation
final Vector3D center
final Vector3D center
final Vector3D point
{ setSize ( NUMBER_CONSTANT ) ; setBarycenter ( ( Point < Euclidean3D > ) new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final List < Vector3D > vertices
final List < Vector3D > vertices
final Vector2D p2 = ( Vector2D ) vector ;
Collection < Vector2D > points
{ final Circle otherC = ( Circle ) other ; return Vector3D . dotProduct ( pole , otherC.pole ) >= NUMBER_CONSTANT ; }
final Vector3D direction
final Vector3D pole
Vector1D expected = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = Vector1D.NEGATIVE_INFINITY ;
Vector1D c = Vector1D.POSITIVE_INFINITY ;
Vector1D c = Vector1D.NaN ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( - NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
final Vector2D [] vertices
{ final Vector1D p1 = ( Vector1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
final Collection < Vector2D > points
final Collection < Vector2D > points
final Collection < Vector2D > points
ConvexHull2D hull = generator . generate ( Collections . < Vector2D > emptyList () ) ;
final double angle = Vector3D . angle ( thisCircle . getPole () , otherCircle . getPole () ) ;
{ return new SphericalCoordinates ( new Vector3D ( x , y , z ) ) ; }
final Vector3D v
final Vector3D pole
{ return Vector2D . angle ( p1.vector , p2.vector ) ; }
final Vector2D vector
Circle circle = new Circle ( Vector3D.PLUS_K , NUMBER_CONSTANT ) ;
this . summedBarycenter = Vector3D.ZERO ;
{ return Vector3D . angle ( p1.vector , p2.vector ) ; }
final Vector3D vector
final Vector3D p
final double angle = Vector3D . angle ( direction , line.direction ) ;
final Vector3D point
Vector3D v
{ new Vector3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
Vector2D expected = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = Vector2D.NEGATIVE_INFINITY ;
Vector2D c = Vector2D.POSITIVE_INFINITY ;
Vector2D c = Vector2D.NaN ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return ( ( Vector3D ) point ) . dotProduct ( w ) + originOffset ; }
final Vector3D p
final Vector3D translation
final double angle = Vector3D . angle ( w , plane.w ) ;
final Vector3D tmp = u ;
final Vector3D normal
final Vector3D p = h . toSpace ( Vector2D.ZERO ) ;
final Vector2D p = h . toSpace ( Vector1D.ZERO ) ;
Vector3D [] points
final List < Vector3D > vertices
Arrays . asList ( Vector3D.ZERO , Vector3D.PLUS_I , Vector3D.PLUS_J , Vector3D.PLUS_K )
try { ps . checkPoint ( Vector3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v1
final Vector3D v2
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D u
for ( Vector2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Vector2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
Vector3D c = Vector3D.NEGATIVE_INFINITY ;
Vector3D c = Vector3D.POSITIVE_INFINITY ;
Vector3D c = Vector3D.NaN ;
final Vector2D point
final Vector2D location
final Vector2D . . . vertices
final Vector2D . . . vertices
final Vector3D u
final Vector3D u
final double x = ( ( Vector1D ) point ) . getX () ;
{ return new Line ( new Vector2D ( getNumber () , getNumber () ) , getNumber () , getNumber () ) ; }
{ return new OrientedPoint ( new Vector1D ( getNumber () ) , getBoolean () , getNumber () ) ; }
{ return new Circle ( new Vector3D ( getNumber () , getNumber () , getNumber () ) , getNumber () ) ; }
Vector1D v
Vector1D v = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D v = new Vector1D ( NUMBER_CONSTANT ) ;
{ Space space = new Vector1D ( NUMBER_CONSTANT ) . getSpace () ; Assert . assertEquals ( NUMBER_CONSTANT , space . getDimension () ) ; }
final double delta = ( ( Vector1D ) point ) . getX () - location . getX () ;
final Vector1D location
try { FieldVector3D . angle ( v1 , Vector3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
Vector2D oneTwo = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ new Vector2D ( v ) ; }
final Vector2D tmp = loop [ min ] ;
final Vector2D [] bLoop
final Vector3D axis
Vector3D axis
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Vector1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
final Vector2D p
final Vector2D p
final Vector2D p
Vector2D p2 = ( Vector2D ) point ;
final Vector2D p
final Vector2D p
TranslationTransform ( final Coordinates3D translation ) { this . translation = translation ; }
final Coordinates3D translation
final Coordinates3D center
final Coordinates3D center
final Coordinates3D point
{ setSize ( NUMBER_CONSTANT ) ; setBarycenter ( ( Point < Euclidean3D > ) new Coordinates3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final List < Coordinates3D > vertices
final List < Coordinates3D > vertices
final Coordinates2D p2 = ( Coordinates2D ) vector ;
Collection < Coordinates2D > points
{ final Circle otherC = ( Circle ) other ; return Coordinates3D . dotProduct ( pole , otherC.pole ) >= NUMBER_CONSTANT ; }
final Coordinates3D direction
final Coordinates3D pole
Coordinates1D expected = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = Coordinates1D.NEGATIVE_INFINITY ;
Coordinates1D c = Coordinates1D.POSITIVE_INFINITY ;
Coordinates1D c = Coordinates1D.NaN ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( - NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
final Coordinates2D [] vertices
{ final Coordinates1D p1 = ( Coordinates1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
final Collection < Coordinates2D > points
final Collection < Coordinates2D > points
final Collection < Coordinates2D > points
ConvexHull2D hull = generator . generate ( Collections . < Coordinates2D > emptyList () ) ;
final double angle = Coordinates3D . angle ( thisCircle . getPole () , otherCircle . getPole () ) ;
{ return new SphericalCoordinates ( new Coordinates3D ( x , y , z ) ) ; }
final Coordinates3D v
final Coordinates3D pole
{ return Coordinates2D . angle ( p1.vector , p2.vector ) ; }
final Coordinates2D vector
Circle circle = new Circle ( Coordinates3D.PLUS_K , NUMBER_CONSTANT ) ;
this . summedBarycenter = Coordinates3D.ZERO ;
{ return Coordinates3D . angle ( p1.vector , p2.vector ) ; }
final Coordinates3D vector
final Coordinates3D p
final double angle = Coordinates3D . angle ( direction , line.direction ) ;
final Coordinates3D point
Coordinates3D v
{ new Coordinates3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Coordinates3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
Coordinates2D expected = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = Coordinates2D.NEGATIVE_INFINITY ;
Coordinates2D c = Coordinates2D.POSITIVE_INFINITY ;
Coordinates2D c = Coordinates2D.NaN ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return ( ( Coordinates3D ) point ) . dotProduct ( w ) + originOffset ; }
final Coordinates3D p
final Coordinates3D translation
final double angle = Coordinates3D . angle ( w , plane.w ) ;
final Coordinates3D tmp = u ;
final Coordinates3D normal
final Coordinates3D p = h . toSpace ( Coordinates2D.ZERO ) ;
final Coordinates2D p = h . toSpace ( Coordinates1D.ZERO ) ;
Coordinates3D [] points
final List < Coordinates3D > vertices
Arrays . asList ( Coordinates3D.ZERO , Coordinates3D.PLUS_I , Coordinates3D.PLUS_J , Coordinates3D.PLUS_K )
try { ps . checkPoint ( Coordinates3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D u
for ( Coordinates2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Coordinates2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
Coordinates3D c = Coordinates3D.NEGATIVE_INFINITY ;
Coordinates3D c = Coordinates3D.POSITIVE_INFINITY ;
Coordinates3D c = Coordinates3D.NaN ;
final Coordinates2D point
final Coordinates2D location
final Coordinates2D . . . vertices
final Coordinates2D . . . vertices
final Coordinates3D u
final Coordinates3D u
final double x = ( ( Coordinates1D ) point ) . getX () ;
{ return new Line ( new Coordinates2D ( getNumber () , getNumber () ) , getNumber () , getNumber () ) ; }
{ return new OrientedPoint ( new Coordinates1D ( getNumber () ) , getBoolean () , getNumber () ) ; }
{ return new Circle ( new Coordinates3D ( getNumber () , getNumber () , getNumber () ) , getNumber () ) ; }
Coordinates1D v
Coordinates1D v = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D v = new Coordinates1D ( NUMBER_CONSTANT ) ;
{ Space space = new Coordinates1D ( NUMBER_CONSTANT ) . getSpace () ; Assert . assertEquals ( NUMBER_CONSTANT , space . getDimension () ) ; }
final double delta = ( ( Coordinates1D ) point ) . getX () - location . getX () ;
final Coordinates1D location
try { FieldVector3D . angle ( v1 , Coordinates3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
Coordinates2D oneTwo = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ new Coordinates2D ( v ) ; }
final Coordinates2D tmp = loop [ min ] ;
final Coordinates2D [] bLoop
final Coordinates3D axis
Coordinates3D axis
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Coordinates1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
final Coordinates2D p
final Coordinates2D p
final Coordinates2D p
final Coordinates2D p
final Coordinates2D p
{ centered [ i ] = values [ i ] - getMeans () [ i ] ; }
private final ContinuousSampler sampler = new BoxMullerLogNormalSampler ( rng , scale , shape ) ;
private final ContinuousSampler sampler = new BoxMullerGaussianSampler ( rng , mean , standardDeviation ) ;
public Plot ( final List < Vector2D > points ) { this . points = points ; }
List < Vector2D > points = null ;
Vector3D p
rings = new ChineseRings ( new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
Cartesian1D actual = vector1DFormat . parse ( source ) ;
Cartesian1D actual = vector1DFormat . parse ( source ) ;
Cartesian1D actual = vector1DFormat . parse ( source ) ;
Cartesian1D expected = new Cartesian1D ( NUMBER_CONSTANT ) ;
{ final Cartesian1D p1 = ( Cartesian1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
final Cartesian2D p2 = ( Cartesian2D ) vector ;
Cartesian2D actual = vector2DFormat . parse ( source ) ;
Cartesian2D actual = vector2DFormat . parse ( source ) ;
Cartesian2D actual = vector2DFormat . parse ( source ) ;
Cartesian3D actual = vector3DFormat . parse ( source ) ;
Cartesian3D actual = vector3DFormat . parse ( source ) ;
Cartesian3D actual = vector3DFormat . parse ( source ) ;
int j = NUMBER_CONSTANT
Assert . assertFalse ( STRING_CONSTANT + level , new KolmogorovSmirnovTest ( RandomSource.JDK , NUMBER_CONSTANT ) . kolmogorovSmirnovTest ( betaDistribution , observed ) < level ) ;
Assert . assertEquals ( test . exactP ( d , sampleSize1 , sampleSize2 , strict ) , test . monteCarloP ( d , sampleSize1 , sampleSize2 , strict , KolmogorovSmirnovTest.MONTE_CARLO_ITERATIONS , rng ) , tol )
final double tol = KolmogorovSmirnovTestTest.TOLERANCE ;
final double tol = KolmogorovSmirnovTestTest.TOLERANCE ;
Vector3D p
rings = new ChineseRings ( new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
final Vector2D [] vertices
final Collection < Vector2D > points
final Collection < Vector2D > points
final Collection < Vector2D > points
ConvexHull2D hull = generator . generate ( Collections . < Vector2D > emptyList () ) ;
final Vector3D p
final double angle = Vector3D . angle ( direction , line.direction ) ;
final Vector3D point
Vector3D v
{ new Vector3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v1
final Vector3D v2
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D u
for ( Vector2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Vector2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
final Vector2D point
final Vector2D location
final Vector2D . . . vertices
final Vector2D . . . vertices
final double x = ( ( Vector1D ) point ) . getX () ;
try { FieldVector3D . angle ( v1 , Vector3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Vector1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
Gamma . logGamma ( z + NUMBER_CONSTANT ) - ( z + NUMBER_CONSTANT ) * FastMath . log ( z ) + z - HALF_LOG_2_PI
( sc * sc ) * FastMath . exp ( Gamma . logGamma ( NUMBER_CONSTANT + ( NUMBER_CONSTANT / sh ) ) )
return sc * FastMath . exp ( Gamma . logGamma ( NUMBER_CONSTANT + ( NUMBER_CONSTANT / sh ) ) ) ;
if ( x <= NUMBER_CONSTANT ) { ret = NUMBER_CONSTANT ; } else { ret = Gamma . regularizedGammaP ( shape , x / scale ) ; }
final double expected = Gamma . logGamma ( i + NUMBER_CONSTANT ) ;
{ return Gamma . regularizedGammaP ( mu , mu * x * x / omega ) ; }
NUMBER_CONSTANT * FastMath . pow ( mu , mu ) / ( Gamma . gamma ( mu ) * FastMath . pow ( omega , mu ) )
return Gamma . logGamma ( n + NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , Gamma . gamma ( t ) / s , tol ) ;
Beta . logBeta ( nhalf , mhalf )
{ ret = NUMBER_CONSTANT - Beta . regularizedBeta ( probabilityOfSuccess , x + NUMBER_CONSTANT , numberOfTrials - x ) ; }
if ( x >= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return Beta . regularizedBeta ( x , alpha , beta ) ; }
{ ret = Beta . regularizedBeta ( probabilityOfSuccess , numberOfSuccesses , x + NUMBER_CONSTANT ) ; }
return NUMBER_CONSTANT * Erf . erf ( v0 , v1 ) ;
return NUMBER_CONSTANT + NUMBER_CONSTANT * Erf . erf ( dev / ( shape * SQRT2 ) ) ;
return NUMBER_CONSTANT * Erf . erf ( v0 , v1 ) ;
return mean + standardDeviation * SQRT2 * Erf . erfInv ( NUMBER_CONSTANT * p - NUMBER_CONSTANT ) ;
return NUMBER_CONSTANT * Erf . erfc ( - dev / ( standardDeviation * SQRT2 ) ) ;
final double t = Erf . erfcInv ( p ) ;
double refDer = - CombinatoricsUtils . factorial ( n - NUMBER_CONSTANT ) / FastMath . pow ( - x , n ) ;
ArithmeticUtils . pow ( - NUMBER_CONSTANT , i ) * CombinatoricsUtils . factorial ( i ) / FastMath . pow ( x , i + NUMBER_CONSTANT )
CombinatoricsUtils . binomialCoefficientDouble ( n + m , m )
{ coeff [ i ] [ j ] = ( int ) CombinatoricsUtils . binomialCoefficient ( i , j ) ; }
final int numCombinations = ( int ) CombinatoricsUtils . binomialCoefficient ( arraySize , numberOfTrueValues ) ;
long expected = CombinatoricsUtils . binomialCoefficient ( i + j , i ) ;
{ term *= FastMath . pow ( delta [ k ] , orders [ k ] ) / CombinatoricsUtils . factorial ( orders [ k ] ) ; }
double binomial = CombinatoricsUtils . binomialCoefficient ( v + i , i ) ;
Assert . assertEquals ( CombinatoricsUtils . binomialCoefficient ( n , NUMBER_CONSTANT ) , CombinatoricsUtils . stirlingS2 ( n , n - NUMBER_CONSTANT ) ) ;
return MathArrays . linearCombination ( x1 , y1 , - x2 , y2 ) ;
{ final Cartesian2D v2 = ( Cartesian2D ) v ; return MathArrays . linearCombination ( x , v2.x , y , v2.y ) ; }
final double n = FastMath . abs ( MathArrays . linearCombination ( v1.x , v2.y , - v1.y , v2.x ) ) ;
out.value = MathArrays . linearCombination ( a1 , b1.value , a2 , b2.value , a3 , b3.value ) ;
out.value = MathArrays . linearCombination ( a1.value , b1.value , a2.value , b2.value , a3.value , b3.value ) ;
out.value = MathArrays . linearCombination ( a1 , b1.value , a2 , b2.value ) ;
out.value = MathArrays . linearCombination ( a1.value , b1.value , a2.value , b2.value ) ;
out.value = MathArrays . linearCombination ( a , bDouble ) ;
out.value = MathArrays . linearCombination ( aDouble , bDouble ) ;
{ return new Decimal64 ( MathArrays . linearCombination ( a1 , b1.value , a2 , b2.value , a3 , b3.value ) ) ; }
{ return new Decimal64 ( MathArrays . linearCombination ( a1.value , b1.value , a2.value , b2.value , a3.value , b3.value ) ) ; }
{ return new Decimal64 ( MathArrays . linearCombination ( a1 , b1.value , a2 , b2.value ) ) ; }
{ return new Decimal64 ( MathArrays . linearCombination ( a1.value , b1.value , a2.value , b2.value ) ) ; }
return new Decimal64 ( MathArrays . linearCombination ( a , bDouble ) ) ;
return new Decimal64 ( MathArrays . linearCombination ( aDouble , bDouble ) ) ;
packed [ i + NUMBER_CONSTANT ] = MathArrays . linearCombination ( dv , partials ) ;
final double cos = MathArrays . cosAngle ( n , sampleDirection ) ;
final double diffNorm = MathArrays . safeNorm ( diff ) ;
final double r = MathArrays . linearCombination ( coeff [ i ] , pY ) ;
final double accurateValue = MathArrays . linearCombination ( a , bDouble ) ;
final double accurateValue = MathArrays . linearCombination ( aDouble , bDouble ) ;
{ return FastMath . abs ( MathArrays . linearCombination ( sin , line.cos , - cos , line.sin ) ) < tolerance ; }
return MathArrays . linearCombination ( sin , otherL.sin , cos , otherL.cos ) >= NUMBER_CONSTANT ;
{ return originOffset + ( MathArrays . linearCombination ( cos , line.cos , sin , line.sin ) > NUMBER_CONSTANT ? - line.originOffset : line.originOffset ) ; }
checkRelative ( MathArrays . linearCombination ( aD , bD ) , bF [ NUMBER_CONSTANT ] . linearCombination ( aD , bF ) ) ;
checkRelative ( MathArrays . linearCombination ( aD , bD ) , aF [ NUMBER_CONSTANT ] . linearCombination ( aF , bF ) ) ;
final double lB = MathUtils . normalizeAngle ( limits . get ( j ) , lA ) ;
final double syncedStart = MathUtils . normalizeAngle ( a [ NUMBER_CONSTANT ] , reference ) - arc . getInf () ;
final double normalizedLower = MathUtils . normalizeAngle ( lower , FastMath.PI ) ;
{ Assert . assertEquals ( a1 . getReal () , MathUtils . normalizeAngle ( a2 , a1 . getReal () ) , NUMBER_CONSTANT ) ; }
final double arcRelativeStart = MathUtils . normalizeAngle ( arc . getInf () , edgeStart + FastMath.PI ) - edgeStart ;
{ this ( MathUtils . normalizeAngle ( alpha , FastMath.PI ) , new Cartesian2D ( FastMath . cos ( alpha ) , FastMath . sin ( alpha ) ) ) ; }
final double normalizedPoint = MathUtils . normalizeAngle ( point , middle ) ;
this . lower = MathUtils . normalizeAngle ( lower , FastMath.PI ) ;
{ Assert . assertEquals ( a1 . getReal () , MathUtils . normalizeAngle ( a2 , a1 . getReal () ) , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( p , MathUtils . normalizeAngle ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , MathUtils . normalizeAngle ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , MathUtils . normalizeAngle ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , MathUtils . normalizeAngle ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
this . angle = MathUtils . normalizeAngle ( angle , FastMath.PI ) ;
this . angle = MathUtils . normalizeAngle ( alpha , FastMath.PI ) ;
angle = MathUtils . normalizeAngle ( line.angle , FastMath.PI ) ;
if ( knots.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION , NUMBER_CONSTANT , knots.length , false ) ; }
if ( knots.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION , NUMBER_CONSTANT , knots.length , false ) ; }
UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
UnitSphereRandomVectorGenerator rand
UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
this ( new InterpolatingMicrosphere ( dimension , elements , maxDarkFraction , darkThreshold , background , new UnitSphereRandomVectorGenerator ( dimension ) ) , exponent , sharedSphere , noInterpolationTolerance ) ;
UnitSphereRandomVectorGenerator sphRandom = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
{ sampler = new NormalDistribution () . createSampler ( generator ) ; }
private final ContinuousSampler sampler = new MarsagliaLogNormalSampler ( rng , scale , shape ) ;
final RealDistribution.Sampler random
{ return randomize ( new UniformRealDistribution ( min , max ) . createSampler ( rng ) , function ( new Constant ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
RealDistribution.Sampler sampler
RealDistribution distribution
RealDistribution distribution
RealDistribution distribution
RealDistribution distribution
final NormalDistribution normalDistribution = new NormalDistribution () ;
final RealDistribution expectedDistribution
final NormalDistribution normalDistribution = new NormalDistribution () ;
IntegerDistribution.Sampler sampler
final NormalDistribution normalDistribution = new NormalDistribution () ;
this . random = new NormalDistribution () . createSampler ( rng ) ;
final RealDistribution kernel = findKernel ( lower , upper ) ;
final RealDistribution kernel = findKernel ( lower , upper ) ;
tP = new UniformRealDistribution ( NUMBER_CONSTANT , MathUtils.TWO_PI ) . createSampler ( rng ) ;
x = new UniformRealDistribution ( lo , hi ) . createSampler ( rng ) ;
@ Override public double getNumericalMean () { return NUMBER_CONSTANT ; }
final double offset = plane . getOffset ( ( Point < Euclidean3D > ) point ) ;
{ Assert . assertEquals ( x , v . getX () , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( false , pt . isDirect () ) ;
Assert . assertEquals ( true , copy . isDirect () ) ;
Assert . assertEquals ( true , pt . isDirect () ) ;
TestUtils . assertContains ( result , expected , tolerance ) ;
assertContains ( result , expected , tolerance ) ;
for ( float d : imaginary ) { c [ index ] = new Complex ( NUMBER_CONSTANT , d ) ; index ++ ; }
for ( double d : imaginary ) { c [ index ] = new Complex ( NUMBER_CONSTANT , d ) ; index ++ ; }
for ( float d : real ) { c [ index ] = new Complex ( d ) ; index ++ ; }
for ( double d : real ) { c [ index ] = new Complex ( d ) ; index ++ ; }
{ return new Complex ( NUMBER_CONSTANT , imaginary [ index ] ) ; }
{ return new Complex ( NUMBER_CONSTANT , imaginary [ index ] ) ; }
{ return new Complex ( real [ index ] ) ; }
{ return new Complex ( real [ index ] ) ; }
y [ i ] = new Complex ( yr , yi ) ;
data [ i ] = new Complex ( re , im ) ;
Object expected = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = new Complex ( Double.NEGATIVE_INFINITY , Double.NEGATIVE_INFINITY ) ;
Complex expected = new Complex ( Double.POSITIVE_INFINITY , Double.POSITIVE_INFINITY ) ;
Complex expected = new Complex ( Double.NaN , Double.NaN ) ;
Complex expected = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( Double.NEGATIVE_INFINITY , Double.NEGATIVE_INFINITY ) ;
Complex c = new Complex ( Double.POSITIVE_INFINITY , Double.POSITIVE_INFINITY ) ;
Complex c = new Complex ( Double.NaN , Double.NaN ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
for ( Complex cc : c ) { TestUtils . assertEquals ( new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , cc , NUMBER_CONSTANT ) ; }
for ( float d : real ) { c [ index ] = Complex . ofCartesian ( d ) ; index ++ ; }
for ( double d : real ) { c [ index ] = Complex . ofCartesian ( d ) ; index ++ ; }
{ return Complex . ofCartesian ( real [ index ] ) ; }
{ return Complex . ofCartesian ( real [ index ] ) ; }
x [ i ] = Complex . ofCartesian ( f . value ( t ) ) ;
{ final int value = count ; increment () ; return value ; }
{ new SimpsonIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
expr . setLineno ( expr . getLineno () + templateLineno - NUMBER_CONSTANT ) ;
if ( definitionNodeByDefinitionSite . containsKey ( useSite ) ) { return null ; }
FeatureSet features = ( ( JsAst ) ast ) . getFeatures ( compiler ) ;
if ( tags == FALSY_MASK ) { return builder . append ( STRING_CONSTANT ) ; } else { return builder . append ( STRING_CONSTANT + tags ) ; }
output.compiledCode = compiler . toSource () ;
options . setWarningLevel ( DiagnosticGroups.MISSING_PROVIDE , CheckLevel.WARNING ) ;
resultPair = analyzeCastFwd ( expr , inEnv ) ;
options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.OFF ) ;
resultPair = analyzeCastFwd ( expr , inEnv , specializedType ) ;
resultPair = analyzeCastFwd ( expr , inEnv ) ;
public void testEs6ONoEs6 () { testSame ( STRING_CONSTANT ) ; }
options . setWarningLevel ( DiagnosticGroups.MISSING_PROVIDE , CheckLevel.WARNING ) ;
public Node getNext () { return next ; }
public Token getToken () { return token ; }
STRING . isSubtypeOf ( this ) && this . commonTypes . getNumberInstance () . mayHaveProp ( pname )
if ( type == null && isConstant ) { type = JSType.UNKNOWN ; }
if ( isUnknown () ) { return UNKNOWN ; }
if ( isBottom () || isUnknown () || hasTruthyMask () ) { return UNKNOWN ; }
if ( this . isUnknown () ) { return TRUTHY ; }
{ globalThisType = JSType.TOP_OBJECT . withLoose () ; }
if ( type == null && isConstant ) { type = JSType.UNKNOWN ; }
return JSType.UNKNOWN ;
@ Deprecated public AssertionFunctionSpec ( String functionName ) { this ( functionName , JSType.UNKNOWN , null ) ; }
{ Preconditions . checkState ( function . getToken () == Token.FUNCTION ) ; expandedDefinitions . add ( functionSideEffectMap . get ( function ) ) ; }
n . getChildCount () == NUMBER_CONSTANT && t . inGlobalScope ()
initializer . isVar () && initializer . getChildCount () == NUMBER_CONSTANT
if ( n . getChildCount () == NUMBER_CONSTANT && NodeUtil . isStatement ( n ) ) { processName ( n . getFirstChild () , n ) ; }
if ( currentStatement . getChildCount () == NUMBER_CONSTANT ) { return; }
typeNode != null && typeNode . getToken () == Token.STRING
n . getChildCount () == NUMBER_CONSTANT && parent == googScopeBlock
if ( varNode . getChildCount () > NUMBER_CONSTANT && varType != null ) { warnings . add ( JSError . make ( varNode , ONE_TYPE_FOR_MANY_VARS ) ) ; }
if ( inputId == null ) { inputId = NodeUtil . getInputId ( node ) ; }
if ( inputId == null ) { inputId = NodeUtil . getInputId ( node ) ; }
String name = node . getQualifiedName () ;
options.rewritePolyfills = flags.rewritePolyfills ;
JSType t = getMaybeTypeFromComment ( jsdoc , registry , typeParameters ) ;
builder . append ( paramType . toStringHelper ( forAnnotations ) ) . append ( STRING_CONSTANT ) ;
builder . append ( STRING_CONSTANT ) . append ( paramType . toStringHelper ( forAnnotations ) ) ;
{ b . append ( p . getJSType () . toStringHelper ( forAnnotations ) ) ; }
b . append ( call.returnType . toStringHelper ( forAnnotations ) ) ;
sb . append ( getPropertyType ( property ) . toStringHelper ( forAnnotations ) ) ;
if ( n . isFromExterns () ) { this . allPropertyNames . add ( propName ) ; }
allPropertyNames . add ( getProp . getLastChild () . getString () ) ;
if ( NodeUtil . isPropertyTest ( compiler , n ) || isPropertyAbsentTest ( n ) ) { allPropertyNames . add ( n . getLastChild () . getString () ) ; }
allPropertyNames . add ( pname ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
compiler . getOptions () . setUseTypesForOptimization ( true ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
if ( singleSiteDefinitions . size () > NUMBER_CONSTANT ) { return false ; }
NodeTraversal . traverseEs6 ( compiler , root , new FunctionVisitor ( compiler , blacklistedPropNames ) ) ;
@ Override void endCaseBody () { super . endCaseBody () ; indent -- ; endStatement () ; }
assertEquals ( NUMBER_CONSTANT , compiler . getErrorCount () ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
options . setLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ;
JSType objectWithBadKey = findObjectWithNonStringifiableKey ( realType ) ;
Config config = findMatching ( name ) ;
if ( currentScript.defaultExportName != null ) { assignNode . getParent () . detach () ; return; }
boolean nameIsExported = name . equals ( currentScript.defaultExportName ) ;
JSType jsType
JSType jsType
public J2clCheckPassTest () { enableTypeCheck () ; }
void setMask ( int mask ) { bitmask |= mask ; checkInvariant () ; }
if ( info . isNoSideEffects () ) { sideEffectInfo . setIsPure () ; } else { sideEffectInfo . setTaintsGlobalState () ; }
features . require ( Feature.ASYNC_FUNCTIONS ) ;
features . require ( Feature.ASYNC_FUNCTIONS ) ;
config.parseTypeSyntax && peek ( TokenType.OPEN_PAREN ) || peek ( TokenType.OPEN_ANGLE )
features . require ( Feature.ASYNC_FUNCTIONS ) ;
JSDocInfo info = getJSDocInfoForFunction ( node , parent ) ;
FunctionInformation sideEffectInfo = new FunctionInformation ( inExterns ) ;
FunctionInformation representativeNode = new FunctionInformation ( false ) ;
if ( modulePath == null ) { t . makeError ( typeNode , LOAD_ERROR , moduleName ) ; return; }
if ( modulePath == null ) { compiler . report ( t . makeError ( require , LOAD_ERROR , requireName ) ) ; return; }
assertPasses ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String treeDiff = node . checkTreeEquals ( getSubject () ) ;
public ImmutableMap < String , Stats > getStats () { calcTotalStats () ; return summaryCopy ; }
maybeWarnForInvalidDestructuring ( t , lhs , legacyNamespace ) ;
{ options . setReportMissingOverride ( value ? CheckLevel.WARNING : CheckLevel.OFF ) ; }
this . output . print ( Joiner . on ( STRING_CONSTANT ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
NodeTraversal . traverseEs6 ( compiler , scriptRoot , new Es6RenameReferences ( renameMap ) ) ;
NodeTraversal . traverseEs6 ( compiler , root , new Es6RenameReferences ( renameMap ) ) ;
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode , definitionProvider , representativeNodesByName ) ;
this . functionSideEffectMap = new LinkedHashMap <> () ;
return IR . exprResult ( assign ) . useSourceInfoFromForTree ( var ) ;
{ if ( Matchers . functionCall ( STRING_CONSTANT ) . matches ( child . getFirstChild () , metadata ) ) { return true ; } }
Matchers . functionCall ( STRING_CONSTANT ) . matches ( child . getFirstChild () , metadata )
{ eatPredefinedString ( PredefinedName.FROM ) ; moduleSpecifier = eat ( TokenType.STRING ) . asLiteral () ; }
public void testRequireUseStrict1 () { configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( EXTERNS , STRING_CONSTANT , null ) ; }
testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
testSame ( EXTERNS , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , null ) ;
testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , null ) ;
testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , null ) ; }
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
compiler . reportCodeChange () ;
{ parent . removeChild ( node ) ; t . getCompiler () . reportCodeChange () ; }
Pattern argPattern = Pattern . compile ( STRING_CONSTANT ) ;
new ByteArrayInputStream ( inputString . getBytes () )
new ByteArrayInputStream ( inputString . getBytes () )
new ByteArrayInputStream ( inputString . getBytes () )
new ByteArrayInputStream ( inputString . getBytes () )
inputSourceMaps . put ( sourceMapPath , new SourceMapInput ( sourceMap ) ) ;
{ if ( child != n . getFirstChild () ) { add ( STRING_CONSTANT ) ; } add ( child ) ; }
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; } }
final Node extendsClause = className . getNext () ;
{ test ( createCompilerOptions () , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; break; } }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
builder . setTagAsStrict ( firstOutput && options . getLanguageOut () . isStrict () ) ;
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; } }
com.google.javascript.jscomp.parsing.parser.Parser.Config es6config = new com.google.javascript.jscomp.parsing.parser.Parser.Config ( mode ( config.languageMode ) ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , ERROR ) ;
protected CodingConvention getCodingConvention () { return codingConvention ; }
{ super . setUp () ; codingConvention = new GoogleCodingConvention () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; }
Config config = ParserRunner . createConfig ( mode , Config.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , Config.RunMode.KEEP_GOING , null , true ) ;
if ( config.languageMode != LanguageMode.ECMASCRIPT6_TYPED ) { errorReporter . warning ( STRING_CONSTANT + feature , sourceName , lineno ( node ) , charno ( node ) ) ; }
builder . setTagAsStrict ( firstOutput && options . isEmitUseStrict () && options . getLanguageOut () . isStrict () ) ;
if ( options . getLanguageIn () . isStrict () ) { options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.ERROR ) ; }
options . setEmitUseStrict ( flags.emitUseStrict && options . getLanguageOut () . isStrict () ) ;
public void testDoWhileLoopBranch ( ) throws Exception { compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
{ googRequireNode = IR . var ( IR . name ( shortName ) , googRequireNode ) ; }
return getTypeJSDoc ( oldJSDoc , expr ) ;
if ( ! hasConstructor ) { addSyntheticConstructor ( n ) ; }
! isCallTo ( value , STRING_CONSTANT ) && ! ( info != null && info . isConstructorOrInterface () )
if ( isCallTo ( destructuringLhsNode . getLastChild () , STRING_CONSTANT ) ) { return; }
var != null && var . getInitialValue () != null && ! isCallTo ( var . getInitialValue () , STRING_CONSTANT )
if ( aliasVarNodeRhs == null || ! isCallTo ( aliasVarNodeRhs , STRING_CONSTANT ) ) { t . report ( call , INVALID_GET_ALIAS ) ; return; }
String exportedNamespace = currentScript.declareLegacyNamespace ? currentScript.legacyNamespace : currentScript . getBinaryNamespace () ;
String exportedNamespace = rewriteState . getExportedNamespace ( legacyNamespace ) ;
String exportedNamespace = rewriteState . getExportedNamespace ( legacyNamespace ) ;
if ( isExportPropertyAssignment ( n ) ) { recordExportsPropertyAssignment ( n ) ; }
IR . call ( IR . getprop ( superClass . cloneTree () , IR . string ( STRING_CONSTANT ) ) , IR . thisNode () , IR . name ( STRING_CONSTANT ) )
{ typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; typeCheck ( STRING_CONSTANT , JSTypeCreatorFromJSDoc.INHERITANCE_CYCLE ) ; }
assertEquals ( null , LanguageMode . fromString ( STRING_CONSTANT ) ) ;
sourceMap . appendTo ( out , sourceMapOutputFile . getName () ) ;
{ if ( n . isSuper () ) { visitSuper ( n , parent ) ; } }
add ( last , Context.PRESERVE_BLOCK ) ;
assertValidOrder ( checks ) ;
assertValidOrder ( passes ) ;
CompilerPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeFoldConstants ( late , compiler . getOptions () . useTypesForLocalOptimization ) ) ;
if ( ! ( rval >= NUMBER_CONSTANT && rval < NUMBER_CONSTANT ) ) { report ( SHIFT_AMOUNT_OUT_OF_BOUNDS , n ) ; return n ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , VariableReferenceCheck.EARLY_REFERENCE ) ; }
declaresFunction ( n )
DeclaredTypeRegistry getScope () { return this . scope ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , EARLY_REFERENCE ) ; }
if ( isCallInLoop ) { fixUnitializedVarDeclarations ( newBlock ) ; }
{ super . setUp () ; codingConvention = new GoogleCodingConvention () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT8 ) ; }
if ( ! targetType . getGreatestSubtype ( type ) . isBottom () ) { methodPolyfills . remove ( method ) ; }
new PeepholeReplaceKnownMethods ( late )
new PeepholeReplaceKnownMethods ( late )
new PeepholeReplaceKnownMethods ( late )
return TOP_OBJECT ;
public boolean isBuiltinObject () { return this . rawType . isBuiltinWithName ( STRING_CONSTANT ) ; }
boolean isClassy () { return ! isFunction () && ! isBuiltinObject () ; }
if ( this . equals ( proto ) ) { Preconditions . checkState ( this . isInstanceofObject () , STRING_CONSTANT , this ) ; return null ; }
return isUnknown () || ( isInstanceofObject () && isLoose () ) || ( ft != null && ft . isTopFunction () ) ;
if ( this == other || other . isBuiltinWithName ( STRING_CONSTANT ) ) { return true ; }
if ( ! isBuiltinWithName ( STRING_CONSTANT ) ) { this . subtypes . add ( subtype ) ; }
return nt . isBuiltinObject () ? false : nt . isPropDefinedOnSubtype ( pname ) ;
Preconditions . checkArgument ( name . equals ( STRING_CONSTANT ) || name . equals ( STRING_CONSTANT ) || name . equals ( STRING_CONSTANT ) , STRING_CONSTANT , name ) ;
public RemoveUnusedPolyfillsTest () { super ( EXTERNS ) ; enableTypeCheck () ; }
{ result = result . toString () . toUpperCase () ; }
{ CompilerOptions.J2clPassMode j2clPassMode = CompilerOptions.J2clPassMode . valueOf ( flags.j2clPassMode . toUpperCase () ) ; options . setJ2clPass ( j2clPassMode ) ; }
String lowerParam = param . toLowerCase () ;
compilationLevelParsed = COMPILATION_LEVEL_MAP . get ( compilationLevel . toUpperCase () ) ;
return Long . toString ( nonnegativeHash , NUMBER_CONSTANT ) . toUpperCase () ;
addParserWarning ( STRING_CONSTANT , visibility . toString () . toLowerCase () ) ;
String canonicalizedName = value . trim () . toUpperCase () . replaceFirst ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ Node parent = n . getParent () ; return wasCast ( n ) || isAssertionCall ( parent ) ; }
! t . isSubtypeOf ( this . commonTypes . TOP_OBJECT ) && ( ! t . hasTypeVariable () || t . hasScalar () )
return TOP_OBJECT ;
JSType objLitType = commonTypes.TOP_OBJECT ;
{ globalThisType = this . commonTypes . TOP_OBJECT . withLoose () ; }
this == other || other.ns != null || ! other . getNominalType () . equals ( this . commonTypes . getObjectType () )
boolean isInhabitable () { return this != this . commonTypes . BOTTOM_OBJECT ; }
objType != null && ! objType . getNominalType () . isClassy () && ! objType . isLoose ()
if ( nameNode == null ) return;
{ throw new IllegalStateException ( STRING_CONSTANT + declaredValue . toStringTree () ) ; }
if ( name != null ) { this . definitionNodeByDefinitionSite . remove ( node ) ; this . nameDefinitionMultimap . remove ( name , node ) ; }
callNode . getParent () . replaceChild ( callNode , replacement . useSourceInfoIfMissingFrom ( callNode ) ) ;
{ oldRoot . getParent () . replaceChild ( oldRoot , newRoot ) ; }
n . getParent () . replaceChild ( n , stringNode ) ;
callNode . getParent () . replaceChild ( callNode , objNode ) ;
callNode . getParent () . replaceChild ( callNode , objNode ) ;
{ forCondition . getParent () . replaceChild ( forCondition , IR . empty () ) ; reportCodeChange () ; }
n . getParent () . replaceChild ( n , whileNode ) ;
condition . getParent () . replaceChild ( condition , replacementConditionNode ) ;
n . getParent () . replaceChild ( n , replacement ) ;
n . getParent () . replaceChild ( n , caseBlock . detach () ) ;
{ if ( result . getParent () != null ) { result . detach () ; } n . getParent () . replaceChild ( n , result ) ; }
{ subtree . getParent () . replaceChild ( subtree , right . detach () ) ; reportCodeChange () ; return right ; }
node . getParent () . replaceChild ( node , replacement ) ;
n . getParent () . replaceChild ( n , newNode ) ;
subtree . getParent () . replaceChild ( subtree , replacement ) ;
subtree . getParent () . replaceChild ( subtree , replacement ) ;
n . getParent () . replaceChild ( n , placeholder ) ;
n . getParent () . replaceChild ( n , replacement ) ;
n . getParent () . replaceChild ( n , replacement ) ;
pattern . getParent () . replaceChild ( pattern , IR . name ( tempVarName ) ) ;
patternParam . getParent () . replaceChild ( patternParam , newParam ) ;
first . getParent () . replaceChild ( first , name ) ;
callNode . getParent () . replaceChild ( callNode , objNode ) ;
assignNode . getParent () . replaceChild ( assignNode , rhs ) ;
n . getParent () . replaceChild ( n , call ) ;
statement . getParent () . replaceChild ( statement , newStatement ) ;
loadModuleStatement . getParent () . replaceChild ( loadModuleStatement , moduleBlockNode ) ;
n . getParent () . replaceChild ( n , legacyQname ) ;
exprResultNode . getParent () . replaceChild ( exprResultNode , exportsObjectCreationNode ) ;
call . getParent () . replaceChild ( call , exportedNamespaceName ) ;
n . getParent () . replaceChild ( n , replacement ) ;
n . getParent () . replaceChild ( n , elem ) ;
n . getParent () . replaceChild ( n , elem ) ;
n . getParent () . replaceChild ( n , lengthNode ) ;
n . getParent () . replaceChild ( n , newNode ) ;
n . getParent () . replaceChild ( n , newNumber ) ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . getParent () . replaceChild ( n , result ) ; reportCodeChange () ; return result ; }
n . getParent () . replaceChild ( n , newStringNode ) ;
n . getParent () . replaceChild ( n , replacement ) ;
n . getParent () . replaceChild ( n , newNode ) ;
if ( replacementNode != null ) { n . getParent () . replaceChild ( n , replacementNode ) ; reportCodeChange () ; return replacementNode ; }
originalTypeofNode . getParent () . replaceChild ( originalTypeofNode , newNode ) ;
n . getParent () . replaceChild ( n , replacement ) ;
obj . getParent () . replaceChild ( obj , result ) ;
if ( replaceParent ) { parent . getParent () . replaceChild ( parent , replacement ) ; } else { parent . replaceChild ( n , replacement ) ; }
candidateDefinition . getParent () . replaceChild ( candidateDefinition , varNode ) ;
parent . getParent () . replaceChild ( parent , replacement ) ;
if ( enclosing != null && enclosing . isGeneratorFunction () ) { n . getParent () . replaceChild ( n , IR . name ( GENERATOR_THIS ) ) ; }
{ original . getParent () . replaceChild ( original , replacement ) ; return replacement ; }
enclosingCall . getParent () . replaceChild ( enclosingCall , baseCall ) ;
{ Node parent = n . getParent () ; parent . getParent () . replaceChild ( parent , fncBlock ) ; }
n . getParent () . replaceChild ( n , replacement ) ;
callNode . getParent () . replaceChild ( callNode , replacement ) ;
superCall . getParent () . replaceChild ( superCall , superErrorExpr ) ;
{ newValue . useSourceInfoIfMissingFromForTree ( msgNode ) ; msgNode . getParent () . replaceChild ( msgNode , newValue ) ; compiler . reportCodeChange () ; }
callNode . getParent () . replaceChild ( callNode , replacementNode . detach () ) ;
target . getParent () . replaceChild ( target , value . cloneTree () ) ;
{ aliasReference . getParent () . replaceChild ( aliasReference , replacement ) ; }
expressionWithScopeCall . getParent () . replaceChild ( expressionWithScopeCall , scopeClosureBlock ) ;
{ parent . getParent () . replaceChild ( parent , IR . empty () ) ; }
n . getParent () . replaceChild ( n , call ) ;
n . getParent () . replaceChild ( n , not ) ;
if ( newLiteralNode != null ) { n . getParent () . replaceChild ( n , newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
n . getParent () . replaceChild ( n , replacement ) ;
member . getParent () . replaceChild ( member , memberVariable ) ;
n . getParent () . replaceChild ( n , attachTypeExpr ) ;
msgNode . getParent () . replaceChild ( msgNode , newValue ) ;
n . getParent () . replaceChild ( n , var ) ;
grandparent . getParent () . replaceChild ( grandparent , functionNode ) ;
public void testNgInjectSetVisibility ( ) throws Exception { compareJsDoc = true ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
Node scopeMethodCall = findScopeMethodCall ( t . getScope () . getRootNode () ) ;
Node n = t . getScope () . getRootNode () ;
return list ;
return list . isEmpty () ? null : list ;
abstract Node getRoot ( ) ;
String getContent ( ) throws ServiceException ;
String getName ( ) throws ServiceException ;
{ return STRING_CONSTANT ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate ) ; }
{ return Strings . nullToEmpty ( sourceMapCache . get ( path ) ) ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate , CacheBuilder . newBuilder () ) ; }
String output = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
if ( n . getChildCount () != NUMBER_CONSTANT ) { return n ; }
if ( castType . isSubtype ( exprType ) || expr . isObjectLit () ) { expr . setJSType ( castType ) ; }
{ return STRING_CONSTANT ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate ) ; }
options . setLanguageOut ( LanguageMode.ECMASCRIPT5_STRICT ) ;
return new RawNominalType ( commonTypes , defSite , name , typeParameters , Kind.RECORD , objKind ) ;
return new RawNominalType ( commonTypes , defSite , name , typeParameters , Kind.INTERFACE , objKind ) ;
ImmutableCollection < Node > exports
if ( isUnknownType () || implicitPrototypeChainIsUnknown () ) { return true ; }
return list ;
if ( ! hasConstructor ) { addSyntheticConstructor ( t , n ) ; }
IR . comma ( IR . comma ( IR . comma ( getTmpError , copyMessage ) , setStack ) , IR . name ( TMP_ERROR ) ) . useSourceInfoIfMissingFromForTree ( superCall )
{ compiler . report ( JSError . make ( constructor , CANNOT_CONVERT_YET , STRING_CONSTANT + superClassQName ) ) ; }
this . implementedInterfaces = new HashMap <> () ;
script . addChildToFront ( googProvide . copyInformationFromForTree ( script ) ) ;
require . copyInformationFromForTree ( importDecl ) ;
newChild . copyInformationFrom ( child ) ;
{ node . copyInformationFromForTree ( basisNode ) ; node . setOriginalName ( originalName ) ; }
newNode . copyInformationFromForTree ( sourceInfoNode ) ;
expr . copyInformationFromForTree ( parent ) ;
newChild . useSourceInfoWithoutLengthIfMissingFrom ( child ) ;
String name
if ( strictMismatch ) { implicitStructuralInterfaceUses . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordStructuralInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
{ recordStructuralInterfaceUses ( caseType , switchType ) ; }
if ( strictMismatch ) { mismatches . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordImplicitInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( caseType , switchType ) ; }
@ Override Iterable < TypeMismatch > getImplicitInterfaceUses () { return getTypeValidator () . getImplicitStructuralInterfaceUses () ; }
if ( strictMismatch ) { implicitStructuralInterfaceUses . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordStructuralInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
{ recordStructuralInterfaceUses ( caseType , switchType ) ; }
if ( options.tracer . isOn () && tracker != null ) { tracker . recordPassStop ( passName , result ) ; }
if ( options.tracer . isOn () && tracker != null ) { tracker . recordPassStart ( passName , true ) ; }
{ return compilerExecutor . runInCompilerThread ( callable , options != null && options.tracer . isOn () ) ; }
options.tracer = config.tracerMode ;
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExport5 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
for ( Reference ref : refCollection ) { processReference ( collector , ref , info ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
Map < String , DependencyInfo > parsedFiles = new HashMap <> () ;
Map < String , DependencyInfo > depsFiles = new HashMap <> () ;
Map < String , DependencyInfo > providesMap = new HashMap <> () ;
( ! NodeUtil . isPropertyTest ( compiler , n ) || objectType . isStruct () )
{ if ( canCreate ) { createName ( name ) ; } return allNames . get ( name ) ; }
if ( ! Double . isNaN ( d ) ) { cc . addNumber ( d ) ; } else { addJsString ( n ) ; }
assertThat ( result.sourceMap ) . contains ( STRING_CONSTANT ) ;
catch ( IOException e ) { compiler . report ( JSError . make ( REPORT_PATH_IO_ERROR , reportPath ) ) ; }
catch ( IOException e ) { compiler . report ( JSError . make ( REPORT_PATH_IO_ERROR , reportPath ) ) ; }
Preconditions . checkState ( current . isGetProp () ) ;
static boolean isEnhancedFor ( Node n ) { return n . isForOf () || isForIn ( n ) ; }
return newNode ( Token.FOR , initializer , transform ( loopNode.collection ) , transformBlock ( loopNode.body ) ) ;
return new Node ( Token.FOR , target , cond , body ) ;
validateNodeType ( Token.BLOCK , n ) ;
validateNodeType ( Token.BLOCK , n ) ;
TranspileResult result = transpiler . transpile ( path , s ) ;
String path
String path
BaseTranspiler.CompileResult result = compiler . compile ( STRING_CONSTANT , STRING_CONSTANT ) ;
BaseTranspiler.CompileResult result = compiler . compile ( STRING_CONSTANT , STRING_CONSTANT ) ;
String path
String path
TranspileResult transpile ( String path , String code ) ;
String path
! NodeUtil . isForIn ( n )
parent . isFor () && ! NodeUtil . isForIn ( parent )
if ( NodeUtil . isForIn ( n ) ) { return n ; }
if ( ! NodeUtil . isForIn ( node ) ) { tryJoinForCondition ( node ) ; tryMinimizeCondition ( NodeUtil . getConditionExpression ( node ) ) ; }
( NodeUtil . isForIn ( parent ) )
NodeUtil . isForIn ( c )
parent . isFor () && ! NodeUtil . isForIn ( parent ) && NodeUtil . getConditionExpression ( parent ) != n
if ( ! NodeUtil . isForIn ( n ) ) { tryRemoveAssignment ( t , NodeUtil . getConditionExpression ( n ) , state ) ; }
boolean lhsOfForInLoop = NodeUtil . isForIn ( gp ) && gp . getFirstFirstChild () == declNode ;
Preconditions . checkState ( NodeUtil . isForIn ( expr ) ) ;
Preconditions . checkState ( NodeUtil . isForIn ( expr . getParent () ) ) ;
Preconditions . checkState ( NodeUtil . isForIn ( lvalue . getParent () ) ) ;
NodeUtil . isForIn ( n )
Node expr = NodeUtil . isForIn ( n ) ? n . getFirstChild () : NodeUtil . getConditionExpression ( n ) ;
NodeUtil . isVanillaFor ( loopNode )
srcDeclaration . isConst () && ! ( NodeUtil . isForIn ( srcParent ) && srcDeclaration == srcParent . getFirstChild () )
if ( ! NodeUtil . isForIn ( parent ) && child == parent . getFirstChild () ) { return parent ; }
NodeUtil . isForIn ( parent )
if ( ! NodeUtil . isForIn ( parent ) ) { return ( parent . getSecondChild () == expr ) ; }
( isForIn ( parent ) && parent . getFirstChild () == n )
return NodeUtil . isForIn ( n ) ? null : n . getSecondChild () ;
( isForIn ( parent ) && parent . getFirstChild () == n )
if ( NodeUtil . isForIn ( parent ) ) { return; }
if ( enclosingFunc == null || ! enclosingFunc . isGeneratorFunction () || NodeUtil . isForIn ( n ) ) { return; }
if ( NodeUtil . isForIn ( currentStatement ) ) { visitForIn () ; return false ; }
NodeUtil . isForIn ( nextSibling )
NodeUtil . isForIn ( source )
if ( NodeUtil . isForIn ( parent ) ) { return n != parent . getFirstChild () ; } else { return NodeUtil . getConditionExpression ( parent ) != n ; }
NodeUtil . isForIn ( parent )
! NodeUtil . isForIn ( n )
! NodeUtil . isForIn ( n )
if ( NodeUtil . isForIn ( parent ) && parent . getFirstChild () == n ) { return false ; }
NodeUtil . isForIn ( n )
! NodeUtil . isForIn ( n )
var . getParentNode () . isVar () && ! NodeUtil . isForIn ( var . getParentNode () . getParent () )
if ( n . isForOf () || NodeUtil . isForIn ( n ) ) { return n . getSecondChild () ; }
if ( NodeUtil . isForIn ( parent ) ) { return parent ; } else { return parent . getSecondChild () . getNext () ; }
if ( NodeUtil . isVanillaFor ( cur ) ) { iter = cur . getChildAtIndex ( NUMBER_CONSTANT ) ; }
NodeUtil . isForIn ( forNode ) || forNode . isForOf ()
NodeUtil . isForIn ( control )
NodeUtil . isForIn ( n )
n . isAssign () && ! parent . isFor ()
n . isAssign () && ( parent . isExprResult () || parent . isFor () || parent . isReturn () )
grandparent . isFor ()
( declaration . getParent () . isVar () && ! declaration . getGrandparent () . isFor () )
Node initializer = n . isFor () ? n . getFirstChild () : IR . empty () ;
Preconditions . checkState ( ! parent . isFor () ) ;
currentStatement . isFor ()
nextSibling . isFor () && nextSibling . getFirstChild () . isEmpty ()
if ( ! parent . isFor () ) { assign = NodeUtil . newExpr ( assign ) ; }
{ appendField ( out , name , STRING_CONSTANT ) ; }
Preconditions . checkNotNull ( scope ) ;
parent . isBlock () || NodeUtil . isAnyFor ( parent ) || parent . isScript () || parent . isModuleBody () || parent . isLabel ()
boolean scanInnerBlocks = n . isSyntheticBlock () || NodeUtil . isFunctionBlock ( n ) || n . isModuleBody () ;
TypedScope s = new TypedScopeCreator ( compiler , CodingConventions . getDefault () ) . createInitialScope ( new Node ( Token.BLOCK ) ) ;
boolean preserveBlock = n . isBlock () && ! n . isSyntheticBlock () ;
testMissingRequireCall ( js , STRING_CONSTANT ) ;
testMissingRequireCall ( js , STRING_CONSTANT ) ;
testMissingRequireCall ( js , STRING_CONSTANT ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckRequiresForConstructors ( compiler , CheckRequiresForConstructors.Mode.FULL_COMPILE ) ; }
if ( this . optimizePropertyIndex && isObjectLiteralThatCanBeSkipped ( type ) ) { type = this . sentinelObjectLiteral ; }
new PeepholeMinimizeConditions ( late , useTypesForOptimization )
new PeepholeMinimizeConditions ( late , false )
new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false ) , new PeepholeFoldConstants ( true , false ) )
new PeepholeMinimizeConditions ( late , false )
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeMinimizeConditions ( late , useTypes ) ) ;
invalidationMap . get ( t )
throw Throwables . propagate ( cause ) ;
try { TextFormat . merge ( textProto , builder ) ; } catch ( Exception e ) { throw Throwables . propagate ( e ) ; }
if ( exception [ NUMBER_CONSTANT ] != null ) { Throwables . propagate ( exception [ NUMBER_CONSTANT ] ) ; }
{ try { initialize ( metadata . getCompiler () ) ; } catch ( Exception e ) { Throwables . propagate ( e ) ; } }
@ Override public void setUp ( ) throws Exception { super . setUp () ; }
{ CompilerOptions options = super . getOptions () ; if ( enableUnusedLocalAssignmentCheck ) { options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ; } return options ; }
getInvalidationsErrors () . get ( t )
private String getNewName () { return paramPredix + uniqueId ++ ; }
{ this . compiler = Preconditions . checkNotNull ( compiler ) ; this . paramPredix = Preconditions . checkNotNull ( paramPrefix ) ; }
new PeepholeMinimizeConditions ( late , useTypesForOptimization , options.assumeAccurateNullUndefinedTypes )
new PeepholeMinimizeConditions ( late , false , false )
new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false , false ) , new PeepholeFoldConstants ( true , false ) )
new PeepholeMinimizeConditions ( late , false , false )
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeMinimizeConditions ( late , useTypes , assumeAccurateNullUndefinedTypes ) ) ;
( new NodeTraversal ( compiler , this ) ) . traverseAtScope ( scope ) ;
{ addLibrary ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; setLanguage ( ES6 , ES5 ) ; testInjects ( STRING_CONSTANT ) ; }
{ addLibrary ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; setLanguage ( ES6 , ES5 ) ; testInjects ( STRING_CONSTANT ) ; }
validateSyntheticBlock ( n . getLastChild () ) ;
{ validateNodeType ( Token.DEFAULT_CASE , n ) ; validateChildCount ( n ) ; validateSyntheticBlock ( n . getLastChild () ) ; }
block . putBooleanProp ( Node.SYNTHETIC_BLOCK_PROP , true ) ;
block . putBooleanProp ( Node.SYNTHETIC_BLOCK_PROP , true ) ;
{ Preconditions . checkState ( body . isBlock () ) ; body . putBooleanProp ( Node.SYNTHETIC_BLOCK_PROP , true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
body . putBooleanProp ( Node.SYNTHETIC_BLOCK_PROP , true ) ;
public void testNgInjectToArrowFunctions () { testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testEmpty () { this . instrumentationPb = STRING_CONSTANT ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( fullJsCode , fullJsCode ) ;
{ foldSame ( STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testDivision () { fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ test ( STRING_CONSTANT , STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ testLocal ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testLocal ( STRING_CONSTANT , STRING_CONSTANT ) ; }
testLocal ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testSwitchCase () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveDo () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testReturnType () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRestParameter () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
testWithInversion ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( js , js ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
test ( src , src ) ;
public void testForIn () { inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ; inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ if ( ! isClinitMethod ( node ) ) { return; } trySubstituteEmptyFunction ( node , t . getCompiler () ) ; }
{ tryRemovingClinit ( t , node , parent ) ; if ( isNewControlBranch ( parent ) ) { clinitsCalledAtBranch = clinitsCalledAtBranch.parent ; } }
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode ) ;
this . functionSideEffectMap = ArrayListMultimap . create () ;
PropertyType pt = getPropTypeHelper ( jsdoc , initializer , rawType ) ;
{ lint ( Paths . get ( filename ) , false ) ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , VariableReferenceCheck.EARLY_REFERENCE ) ; }
testSame ( STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT ) ;
options.protectHiddenSideEffects = true ;
NodeTraversal outOfBandTraversal = new NodeTraversal ( compiler , this ) ;
{ Preconditions . checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.EXPR_RESULT , expr ) ; }
{ Node root = compiler . parseTestCode ( js ) ; assertEquals ( NUMBER_CONSTANT , compiler . getErrorCount () ) ; return root ; }
ScopeCreator scopeCreator = SyntacticScopeCreator . makeUntypedWithRedeclHandler ( compiler , new DuplicateDeclarationHandler () ) ;
if ( isConstructor ( n ) ) { processConstructor ( n ) ; }
NodeTraversal . traverseRootsEs6 ( compiler , new RemoveCode ( compiler ) , externs , root ) ;
handleTypedefDefinition ( t , n ) ;
Node memberType = parseTypeExpressionList ( next () ) ;
Node memberType = parseTypeExpressionList ( typeName , next () ) ;
lastIndex = replacement . getStartPosition () + replacement . getLength () ;
{ return compilerExecutor . runInCompilerThread ( callable , options != null && options . getTracerMode () . isOn () ) ; }
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode , definitionProvider , representativeNodesByName ) ;
this . functionSideEffectMap = new LinkedHashMap <> () ;
Object object
{ Preconditions . checkState ( token == Token.BLOCK ) ; putBooleanProp ( SYNTHETIC_BLOCK_PROP , val ) ; }
public void setTypeI ( TypeI type ) { this . typei = type ; }
public TypeI getTypeI () { return typei ; }
public void setJSType ( JSType jsType ) { this . typei = jsType ; }
Preconditions . checkArgument ( target != null , STRING_CONSTANT ) ;
{ Preconditions . checkState ( parent != null ) ; parent . removeChild ( this ) ; return this ; }
public AncestorIterable getAncestors () { return new AncestorIterable ( this . getParent () ) ; }
public Node getParent () { return parent ; }
void setPropListHead ( PropListItem propListHead ) { this . propListHead = propListHead ; }
PropListItem getPropListHeadForTesting () { return propListHead ; }
public void setStaticSourceFile ( StaticSourceFile file ) { this . putProp ( STATIC_SOURCE_FILE , file ) ; }
PropListItem next
PropListItem next
Object value
{ Preconditions . checkState ( this . propListHead == null , STRING_CONSTANT ) ; this . propListHead = other.propListHead ; return this ; }
Preconditions . checkArgument ( target != null , STRING_CONSTANT ) ;
{ Preconditions . checkArgument ( prevChild.next != null , STRING_CONSTANT ) ; replaceChild ( prevChild.next , newChild ) ; }
{ Preconditions . checkArgument ( child.parent == null ) ; child.parent = this ; }
public Node getSecondChild () { return first.next ; }
public Node getFirstChild () { return first ; }
PropListItem next
PropListItem next
PropListItem next
PropListItem next
@ Override public abstract PropListItem chain ( PropListItem next ) ;
PropListItem next
PropListItem chain ( PropListItem next ) ;
PropListItem getNext ( ) ;
Node memberType = parseTypeExpressionList ( next () ) ;
checkState ( n . getChildCount () == NUMBER_CONSTANT , n ) ;
condition . isCall () && condition . getChildCount () == NUMBER_CONSTANT
Preconditions . checkState ( left . getChildCount () == NUMBER_CONSTANT ) ;
Preconditions . checkState ( node . getChildCount () == NUMBER_CONSTANT ) ;
Preconditions . checkState ( n . getChildCount () == NUMBER_CONSTANT , n ) ;
Preconditions . checkState ( node . getChildCount () == NUMBER_CONSTANT ) ;
callName . matchesQualifiedName ( STRING_CONSTANT ) && n . getChildCount () == NUMBER_CONSTANT
boolean isDeprecatedCall = callNode . getChildCount () == NUMBER_CONSTANT && callName . isGetProp () ;
if ( createSourceMap ) { mcp . generateSourceMap ( sourceMap ) ; }
setReferencedType ( registry . getNativeObjectType ( JSTypeNative.NO_RESOLVED_TYPE ) ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope ) ; }
assertThat ( templateTypes ) . hasSize ( NUMBER_CONSTANT ) ;
String shortName = namespaceToRequire . substring ( namespaceToRequire . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
String shortName = namespace . substring ( namespace . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
String shortName = namespace . substring ( namespace . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
setReferencedType ( new NoResolvedType ( registry , getReferenceName () ) ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope , true ) ; }
rightmostName . toUpperCase ()
{ Preconditions . checkState ( isAnalyzableObjectDefinePropertiesDefinition ( n ) ) ; return ImmutableList . of ( n . getLastChild () ) ; }
Preconditions . checkArgument ( parent . isVanillaFor () , STRING_CONSTANT , parent . getToken () ) ;
Preconditions . checkNotNull ( reportPath ) ;
NameInformation referring
NameInformation referring
Preconditions . checkNotNull ( ns ) ;
{ Preconditions . checkNotNull ( name ) ; scopes . put ( node , name ) ; }
Preconditions . checkState ( node . isCall () ) ;
{ super ( name , node ) ; Preconditions . checkState ( node . isCall () ) ; }
{ super ( name , parent . getFirstChild () ) ; Preconditions . checkState ( parent . isAssign () ) ; }
{ checkLocalityOfMarkedCalls ( source , expected , LanguageMode.ECMASCRIPT6 ) ; checkLocalityOfMarkedCalls ( source , expected , LanguageMode.ECMASCRIPT5 ) ; }
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
assertPureCallsMarked ( templateSrc . replace ( STRING_CONSTANT , STRING_CONSTANT ) , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
JSType recvType = simpleInferExprType ( recv ) ;
JSType t = simpleInferExprType ( argNode ) ;
{ String name = NodeUtil . getName ( n ) ; noSideEffectExterns . put ( name , null ) ; }
qname != null && noSideEffectExterns . containsKey ( qname ) && ! isDefinedInSrc
Map < ParamGroup , CompilationParam [] > compilationParamsByGroup = new HashMap <> () ;
Preconditions . checkState ( n . getFirstChild () . isBlock () , n ) ;
statement . isBlock ()
assertTrue ( functionA . getBodyNode () . isBlock () ) ;
assertTrue ( mainFunction . getAstNode () . isBlock () ) ;
assertTrue ( mainFunction . getBodyNode () . isBlock () ) ;
{ return n . isBlock () && n . hasChildren () && isReturnTypeNullable ( n . getParent () ) && ! hasSingleThrow ( n ) ; }
markNameProcessed ( nameNode . getQualifiedName () ) ;
Preconditions . checkState ( root . isBlock () ) ;
if ( ! subtree . isScript () && ! subtree . isBlock () ) { return subtree ; }
body . isBlock () && ! body . hasChildren ()
{ return ( n . isBlock () && n . isSyntheticBlock () ) || n . isScript () ; }
Preconditions . checkState ( block . isBlock () ) ;
! target . getParent () . isScript () && ! target . getParent () . isBlock ()
Preconditions . checkArgument ( block . isBlock () , STRING_CONSTANT ) ;
n . isBlock ()
n . isBlock ()
n . isBlock ()
n . isBlock ()
parent != null && ( parent . isBlock () || parent . isScript () )
parent . isScript () || ( parent . isBlock () && parent . getParent () . isFunction () )
{ Preconditions . checkArgument ( blockNode . isBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
if ( n . isBlock () ) { visitBlock ( n ) ; }
node . isFunction () && ! NodeUtil . getFunctionBody ( node ) . isBlock ()
if ( ! n . isScript () && ! n . isBlock () ) { return; }
if ( body . isBlock () ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
{ Preconditions . checkArgument ( n . isBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
Preconditions . checkState ( addingRoot . isBlock () || addingRoot . isModuleBody () || addingRoot . isScript () ) ;
{ return n . isBlock () && n . getParent () != null && n . getParent () . isFunction () ; }
Preconditions . checkState ( block . isBlock () ) ;
node . isBlock ()
if ( n . isEmpty () || ( n . isBlock () && ! n . hasChildren () ) ) { return; }
next != null && next . isBlock ()
if ( ! n . isFunction () || ! n . getLastChild () . isBlock () ) { return; }
currentStatement . isBlock ()
c . isBlock ()
c . isBlock ()
Preconditions . checkState ( caseBody . isBlock () ) ;
! labeledStatement . isBlock ()
last . isBlock ()
NodeUtil . isControlStructureCodeBlock ( n , c ) && ! c . isBlock ()
if ( ! body . isBlock () || ! body . hasOneChild () || ! body . getFirstChild () . isReturn () ) { return; }
s . isFunctionScope () && s . getRootNode () . getLastChild () . isBlock ()
if ( maybeAssign . isBlock () || maybeAssign . isScript () || NodeUtil . isStatement ( maybeAssign ) ) { return; }
if ( n . isExprResult () || n . isBlock () ) { return; }
umdPattern.activeBranch . isBlock () && umdPattern.activeBranch . getChildCount () == NUMBER_CONSTANT
Preconditions . checkState ( n . isBlock () , n ) ;
if ( ! originalBody . isBlock () ) { originalBody = IR . block ( IR . returnNode ( originalBody ) ) . useSourceInfoFromForTree ( originalBody ) ; }
for ( Node child : node . children () ) { if ( child . isBlock () ) { blocks . add ( child ) ; } }
checkState ( body . isBlock () , body ) ;
boolean isVar = NodeUtil . isNameDeclaration ( parent ) && parent . getParent () . isBlock () ;
isGoogScopeFunctionBody ( enclosingFunctionBody ) && scopeRoot . isBlock () && ! scopeRoot . getParent () . isFunction ()
! n . getParent () . isScript () && ! n . getParent () . isBlock ()
return expectedBlock . isBlock () ? expectedBlock : null ;
if ( newChild . isBlock () ) { NodeUtil . tryMergeBlock ( newChild ) ; }
Preconditions . checkState ( block . isBlock () ) ;
! body . isBlock ()
Preconditions . checkState ( body . getNext () == null && body . isBlock () , body ) ;
for ( ; ! currentParent . isScript () && ! currentParent . isBlock () ; current = currentParent , currentParent = currentParent . getParent () ) {}
Preconditions . checkArgument ( node . isBlock () ) ;
! setFunction . hasChildren () || ! setFunction . getLastChild () . isBlock () || ! setFunction . getSecondChild () . isParamList ()
if ( ! getFunction . hasChildren () || ! getFunction . getLastChild () . isBlock () ) { return false ; }
if ( ! favorsCommaOverSemiColon && ! block . isBlock () ) { return false ; }
if ( ! n . isBlock () || ! n . hasChildren () ) { return; }
if ( ! ( parent . isScript () || grandparent != null && grandparent . isFunction () && parent . isBlock () ) ) { return; }
n . isBlock () && ! loneBlocks . isEmpty () && loneBlocks . peek () == n
Preconditions . checkState ( collectionRoot . isScript () || collectionRoot . isBlock () ) ;
Preconditions . checkState ( externs . isBlock () ) ;
assertTrue ( functionA . getBodyNode () . isNormalBlock () ) ;
assertTrue ( mainFunction . getAstNode () . isRoot () ) ;
assertTrue ( mainFunction . getBodyNode () . isRoot () ) ;
! isArrow && ! isSignature && ! bodyNode . isBlock ()
! irNode . isBlock ()
{ assertTrue ( mainRoot . isBlock () && ! mainRoot . hasChildren () ) ; }
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( finallyBody . isBlock () ) ;
Preconditions . checkState ( tryBody . isBlock () ) ;
{ Preconditions . checkState ( body . isBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( then . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
n . hasChildren () && n . getFirstChild () . isBlock ()
return ImmutableList . of ( bang , qmark ) ;
( parent . isScript () || ( parent . isBlock () && ! parent . isSyntheticBlock () && ! parent . isAddedBlock () ) )
return scopeRoot . isBlock () && scopeRoot . getParent () != null && scopeRoot . getParent () . isFunction () ;
n . isBlock ()
block . isBlock () && block . getParent () . isTry () && block . getParent () . getFirstChild () == block
node . isBlock () && parent != null && parent . isTry () && NodeUtil . getCatchBlock ( parent ) == node
if ( ! n . isBlock () || ! n . hasChildren () || ! isGoogModuleCall ( n . getFirstChild () ) ) { return false ; }
if ( ! block . isBlock () ) { return false ; }
if ( node . isBlock () ) { node . setToken ( Token.SCRIPT ) ; }
boolean needsSemicolon = parent != null && ( parent . isExprResult () || parent . isBlock () || parent . isScript () ) ;
deleteWhitespaceBefore && parent != null && ( parent . isScript () || parent . isBlock () )
Preconditions . checkState ( parentNode . isBlock () , STRING_CONSTANT ) ;
endPass () ;
endPass () ;
endPass () ;
endPass () ;
! currentScope . hasThis () && NodeUtil . referencesSuper ( fn )
Renamer forChildScope ( boolean hoisted ) ;
{ renamer = nameStack . peek () . forChildScope ( ! NodeUtil . createsBlockScope ( declarationRoot ) ) ; }
testSame ( STRING_CONSTANT ) ;
if ( isInferrableConst ( jsdoc , name ) ) { jsdoc = pullJsdocTypeFromAst ( compiler , jsdoc , name ) ; }
if ( ! isInferrableConst ( jsdoc , nameNode ) ) { return; }
warnings . add ( JSError . make ( propAccessNode , ABSTRACT_METHOD_NOT_CALLABLE , funName ) ) ;
{ Preconditions . checkState ( languageIn != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
throw new MalformedException ( STRING_CONSTANT + node . getToken () , fnChild ) ;
Node argList = getFunctionArgList ( function ) ;
Node argList = getFunctionArgList ( function ) ;
findDeclaredNames ( functionBody , null , renamer ) ;
if ( ! declarationRoot . isFunction () ) { findDeclaredNames ( declarationRoot , null , renamer ) ; }
if ( isCallInLoop ) { fixUnitializedVarDeclarations ( newBlock , newBlock ) ; }
void clear () { prefixNames . clear () ; seenNames . clear () ; constructorsToProcess . clear () ; }
for ( String prefix : Iterables . concat ( seenNames , prefixNames ) ) { if ( fullyQualifiedName . startsWith ( prefix ) ) { return true ; } }
Preconditions . checkArgument ( declaration . isName () ) ;
if ( instrumentationData . get ( fileName ) != null ) { node . addChildToFront ( newHeaderNode ( traversal , node ) ) ; }
{ node . addChildToFront ( newHeaderNode ( traversal , node ) ) ; instrumentBranchCoverage ( traversal , instrumentationData . get ( fileName ) ) ; }
if ( isInterface () ) { return getTopDefiningInterface ( getInstanceType () , propertyName ) ; }
{ return isUnionType () ? this . toMaybeUnionType () . getAlternates () : null ; }
if ( lvalueType . isEnumElement () ) { lvalueType = lvalueType . getEnumeratedType () ; }
JSType enumeratedType = requiredType . getProp ( new QualifiedName ( pname ) ) . getEnumeratedType () ;
JSType enumeratedType = requiredType . getProp ( new QualifiedName ( pname ) ) . getEnumeratedType () ;
JSType type
JSType type = getType ( typeObj ) ;
JSType type = getType ( n ) ;
this . BOTTOM_OBJECT = this . registry . getNativeType ( JSTypeNative.NO_OBJECT_TYPE ) . toObjectType () ;
JSType type
JSType type
{ objectType = FunctionType . getTopDefiningInterface ( objectType , propName ) ; }
NominalType nominal = NominalType . pickSuperclass ( nt1 , nt2 ) ;
{ NominalType tmp = NominalType . pickSuperclass ( n1 , n2 ) ; if ( tmp != null ) { return tmp . getInstanceAsJSType () ; } }
@ Override public CompilerPass getProcessor ( final Compiler compiler ) { return new ClosureOptimizePrimitives ( compiler ) ; }
{ Preconditions . checkState ( n . isName () , n ) ; n . removeChild ( n . getFirstChild () ) ; }
parent . removeChild ( parent . getFirstChild () ) ;
! currentScript.declareLegacyNamespace && currentScript.defaultExportRhs == null && namedExport . hasInlinableName ()
this . registry = compiler . getTypeRegistry () ;
Preconditions . checkArgument ( o instanceof JSType ) ;
test ( externs , js , expected , null , warning , description ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES + STRING_CONSTANT + STRING_CONSTANT ;
testSets ( BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES , js , output , STRING_CONSTANT ) ;
{ super . setUp () ; super . enableNormalize () ; super . enableTypeCheck () ; }
public DisambiguatePropertiesTest () { parseTypeInfo = true ; }
if ( ! t . inGlobalHoistScope () ) { return false ; }
{ assertEquals ( e . getType () , type ) ; assertEquals ( e.lineNumber , lineNumber ) ; }
assertEquals ( result.errors [ NUMBER_CONSTANT ] . getType () , errorType ) ;
assertTrue ( result.success ) ;
assertTrue ( compiler . getResult () . success ) ;
checkShortGoogRequireCall ( t , callNode , parent ) ;
options . setPolymerPass ( true ) ;
if ( options.deadAssignmentElimination ) { passes . add ( deadAssignmentsElimination ) ; if ( ! options.polymerPass ) { passes . add ( deadPropertyAssignmentElimination ) ; } }
if ( options.polymerPass ) { checks . add ( polymerPass ) ; }
options . setPolymerPass ( true ) ;
polymerPass = false ;
if ( other . isGeneric () ) { other = instantiateGenericsWithUnknown ( other ) ; }
{ if ( this . equals ( other ) ) { return true ; } return instantiateGenericsWithUnknown ( this ) . isSubtypeOfHelper ( other , checkThisType , subSuperMap , boxedInfo ) ; }
if ( isGeneric () ) { return instantiateGenericsWithUnknown ( this ) . transformByApplyProperty () ; }
Preconditions . checkArgument ( rootNode != parent.rootNode , STRING_CONSTANT , rootNode , parent.rootNode ) ;
public void testDontCrashCtorAliasWithEnum () { test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; compareJsDoc = false ; }
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
public void testGlobalObjectDeclaredToPreserveItsPreviousValue2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjLitAssignmentDepth2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; compareJsDoc = false ; }
boolean isConstDeclaration () { return getParent () . isConst () ; }
boolean isVarDeclaration () { return getParent () . isVar () ; }
{ traverseClass ( n , parent ) ; }
String code = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
options.prettyPrint = true ;
this . prettyPrint = options.prettyPrint ;
String zipEntryPath = STRING_CONSTANT + absoluteZipPath + STRING_CONSTANT + entryPath ;
options . setPrettyPrint ( true ) ;
this . prettyPrint = options . isPrettyPrint () ;
public void testJqueryExpandedEachExpansionEs6ComputedProp () { testErrorEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ExpandJqueryAliases.JQUERY_UNABLE_TO_EXPAND_INVALID_NAME ) ; }
options.prettyPrint = true ;
this . prettyPrint = options.prettyPrint ;
{ options . setPolymerPass ( value ) ; }
fix . getReplacements () . keys ()
nameDefinitionMultimap . keys ()
nameDefinitionMultimap . keySet ()
nameDefinitionMultimap . keys ()
{ checkState ( scope . getParent () == null ) ; scanVars ( n , true , true ) ; }
testError ( STRING_CONSTANT , VarCheck.VAR_ARGUMENTS_SHADOWED_ERROR ) ;
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ;
public void testTypeParsingOnWithVerbose () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ; test ( STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ; }
testSame ( DEFAULT_EXTERNS , STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ;
{ CompilerOptions options = createCompilerOptions () ; options . setCheckTypes ( true ) ; test ( options , STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ; }
markConstAndCopyJsDoc ( assignNode , jsdocNode , rhs ) ;
markConstAndCopyJsDoc ( target , target , value ) ;
markConstAndCopyJsDoc ( jsdocNode , jsdocNode , parent . getLastChild () ) ;
super . setCode ( cachedCode , this . getCharset () == StandardCharsets.UTF_8 ) ;
super . setCode ( cachedCode , this . getCharset () == StandardCharsets.UTF_8 ) ;
{ return list . get ( list . size () - NUMBER_CONSTANT ) ; }
if ( this . ns != null ) { builder . append ( this . ns . toString () ) ; }
{ if ( inheritedPropDef.methodType != null ) { propMethodTypesToProcess . put ( pname , inheritedPropDef.methodType . substituteNominalGenerics ( superType ) ) ; } }
{ Preconditions . checkState ( this . rawType . isFinalized () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) . substituteGenerics ( typeMap ) ; }
this . inGeneratorContext . add ( initialGeneratorContext ) ;
Node namespaceArg = crDefineCallNode . getChildAtIndex ( NUMBER_CONSTANT ) ;
Node pathArg = crExportPathNode . getChildAtIndex ( NUMBER_CONSTANT ) ;
String target = call . getChildAtIndex ( NUMBER_CONSTANT ) . getQualifiedName () ;
{ int result = BASE64_DECODE_MAP [ c ] ; assert ( result != - NUMBER_CONSTANT ) : STRING_CONSTANT ; return BASE64_DECODE_MAP [ c ] ; }
ParseTree arrowFunctionBody = parseArrowFunctionBody ( expressionIn ) ;
ParseTree arrowFunctionBody = parseArrowFunctionBody ( expressionIn ) ;
parseGeneratorFunctionTail ( builder ) ;
parseFunctionTail ( builder ) ;
parseFunctionTail ( builder ) ;
parseFunctionTail ( builder ) ;
parseFunctionTail ( builder , isGenerator ) ;
parseFunctionTail ( builder , isGenerator ) ;
parseFunctionTail ( builder , isGenerator ) ;
recvType = recvType . removeType ( commonTypes.NULL ) ;
if ( NodeUtil . isCallTo ( destructuringLhsNode . getLastChild () , STRING_CONSTANT ) ) { return; }
if ( aliasVarNodeRhs == null || ! NodeUtil . isCallTo ( aliasVarNodeRhs , STRING_CONSTANT ) ) { t . report ( call , INVALID_GET_ALIAS ) ; return; }
return call != null && NodeUtil . isCallTo ( call , STRING_CONSTANT ) && call . getLastChild () . isFunction () ;
reset ( reservedNames , prefix , reservedCharacters ) ;
{ return new AmbiguateProperties ( compiler , options.anonymousFunctionNaming . getReservedCharacters () ) ; }
NameGenerator nameGen = new DefaultNameGenerator ( reservedNames . build () , STRING_CONSTANT , reservedCharacters ) ;
nameGenerator . reset ( reservedNames , STRING_CONSTANT , reservedCharacters ) ;
{ this ( compiler , generatePseudoNames , prevUsedPropertyMap , null , nameGenerator ) ; }
{ this ( compiler , generatePseudoNames , null , null , nameGenerator ) ; }
if ( isBottom () || isUnknown () || hasTruthyMask () ) { return this . commonTypes . UNKNOWN ; }
private boolean hasFalsyMask () { return FALSY_MASK == getMask () ; }
private boolean hasTruthyMask () { return TRUTHY_MASK == getMask () ; }
Preconditions . checkState ( this . isFinalized ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; recordImplicitUseOfNativeObject ( n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; recordImplicitUseOfNativeObject ( n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; recordImplicitUseOfNativeObject ( n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; recordImplicitUseOfNativeObject ( n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ; return options ; }
for ( TypedScope s : scopes . values () ) { Iterables . addAll ( vars , s . getAllSymbols () ) ; }
for ( Var v : globalExternsScope . getAllSymbols () ) { considerVar ( v , null ) ; }
scope . getAllSymbols ()
parseWarning ( STRING_CONSTANT , STRING_CONSTANT ) ;
for ( TypedScope s : scopes . values () ) { Iterables . addAll ( vars , s . getVarIterable () ) ; }
for ( Var v : globalExternsScope . getVarIterable () ) { considerVar ( v , null ) ; }
scope . getVarIterable ()
{ return isContinueStructure ( target ) && matchLabel ( target . getParent () , label ) ; }
{ if ( leftOfArrow.type == ParseTreeType.CALL_EXPRESSION ) { return completeAssignmentExpressionParseAtArrow ( leftOfArrow . asCallExpression () , expressionIn ) ; } else { return completeArrowFunctionParseAtArrow ( leftOfArrow , expressionIn ) ; } }
if ( topInterface != null && topInterface . getConstructor () != null ) { foundType = topInterface . getConstructor () . getPrototypeProperty () ; }
{ ObjectType obj = getObjTypeIfSingletonObj () ; return obj != null && obj . hasOwnPropery ( new QualifiedName ( propertyName ) ) ; }
if ( this . equals ( proto ) ) { Preconditions . checkState ( this . isUnknownObject () , STRING_CONSTANT , this ) ; return null ; }
if ( ! sourceType . isSubtypeWithoutStructuralTyping ( targetType ) ) { recordImplicitInterfaceUses ( n , sourceType , targetType ) ; }
recordImplicitInterfaceUses ( n , argType , paramType ) ;
recordImplicitInterfaceUses ( n , rightType , leftType ) ;
recordImplicitInterfaceUses ( n , rightType , leftType ) ;
recordImplicitInterfaceUses ( n , caseType , switchType ) ;
if ( isPrototypeObject () ) { return builder . append ( getOwnerFunction () . getInstanceTypeOfCtor () ) . append ( STRING_CONSTANT ) ; }
test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
testSets ( js , output , STRING_CONSTANT + STRING_CONSTANT ) ;
n . isVar () && n . getFirstFirstChild () != null && n . getFirstFirstChild () . isFunction ()
return builder () . withCharset ( inputCharset ) . withOriginalPath ( originalZipPath + STRING_CONSTANT + entryPath ) . buildFromUrl ( zipEntryUrl ) ;
assertPasses ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
parent . isVar () || parent . isExprResult ()
println ( STRING_CONSTANT + funType ) ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
@ Override public void setUp () { enableNormalize () ; compareJsDoc = false ; }
@ Override protected void setUp () { style = RELAX ; compareJsDoc = false ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendStringPart ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED ) ;
{ if ( options == null ) { initOptions ( newCompilerOptions () ) ; } return errorManager ; }
inputsById = new HashMap <> () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = errorManager ; }
{ if ( options == null ) { initOptions ( new CompilerOptions () ) ; } return errorManager ; }
inputsById . clear () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
Preconditions . checkState ( ! areSubtypes ) ;
{ switch ( ch ) { case CHAR_CONS : case CHAR_CONS : return true ; default: return Character . isLetter ( ch ) ; } }
{ if ( options == null ) { initOptions ( newCompilerOptions () ) ; } return errorManager ; }
inputsById = new HashMap <> () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = errorManager ; }
Preconditions . checkArgument ( callNode . isCall () ) ;
fold ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ; return options ; }
Node root = compiler . getRoot () . getLastChild () ;
{ assertThat ( aggregateWarnings ) . isEmpty () ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; runTypeCheckAfterProcessing = true ; compareJsDoc = true ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; runTypeCheckAfterProcessing = true ; }
public void testTaggedTemplateError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; runTypeCheckAfterProcessing = true ; propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED ; }
public void testAsyncFunction () { setLanguage ( LanguageMode.ECMASCRIPT8 , LanguageMode.ECMASCRIPT5 ) ; testError ( STRING_CONSTANT , CANNOT_CONVERT_YET ) ; testError ( STRING_CONSTANT , CANNOT_CONVERT_YET ) ; }
public void testExponentiationAssignmentOperator () { setLanguage ( LanguageMode.ECMASCRIPT7 , LanguageMode.ECMASCRIPT5 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExponentiationOperator () { setLanguage ( LanguageMode.ECMASCRIPT7 , LanguageMode.ECMASCRIPT5 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; runTypeCheckAfterProcessing = true ; }
public void testWhileLoopBranch ( ) throws Exception { compareWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareWhileLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testDoWhileLoopMultiLineBranch ( ) throws Exception { compareDoWhileLoopMultiLineBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopMultiLineBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testDoWhileLoopBranch ( ) throws Exception { compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testForLoopBranch ( ) throws Exception { compareForLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareForLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testIfElseBranch ( ) throws Exception { compareIfElseBranch ( LanguageMode.ECMASCRIPT5 ) ; compareIfElseBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testIfBranch ( ) throws Exception { compareIfBranch ( LanguageMode.ECMASCRIPT5 ) ; compareIfBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testFunction ( ) throws Exception { compareFunctionOneMode ( LanguageMode.ECMASCRIPT5 ) ; compareFunctionOneMode ( LanguageMode.ECMASCRIPT6 ) ; }
{ setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ; testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ; testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
{ compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
public void testInlineIntoNestedNonHoistedNamedFunctions () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testInvalidVariableInScope () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_INVALID_VARIABLE ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_INVALID_VARIABLE ) ; }
public void testNonAliasLocal () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testJSDocCopiedForClasses () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testObjectLiteralMethods () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testObjectLiteralShorthand () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testDefaultParameter () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testClassDefinition3 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testClassDefinition2 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testClassDefinition1 () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testArrowFunction () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testNonTopLevelDestructuring () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testObjectDescructuringError2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testObjectDescructuringError1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testDestructuringError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testYieldExpression () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
{ testScopedNoChanges ( aliases , code , LanguageMode.ECMASCRIPT3 ) ; testScopedNoChanges ( aliases , code , LanguageMode.ECMASCRIPT6 ) ; }
{ testScoped ( code , expected , LanguageMode.ECMASCRIPT3 ) ; testScoped ( code , expected , LanguageMode.ECMASCRIPT6 ) ; }
{ testError ( createFunction ( body ) ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testError ( createShorthandFunctionInObjLit ( body ) ) ; }
{ testOk ( createFunction ( body ) ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testOk ( createShorthandFunctionInObjLit ( body ) ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ;
{ testExternChanges ( extern , input , expectedExtern , LanguageMode.ECMASCRIPT6 ) ; testExternChanges ( extern , input , expectedExtern , LanguageMode.ECMASCRIPT5 ) ; }
{ testWarning ( js , expected , warning , LanguageMode.ECMASCRIPT6 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testWarning ( js , warning , warningMessage ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testWarning ( js , warning ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testWarning ( js , warning ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT6 ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT6 ) ; testError ( js , error , LanguageMode.ECMASCRIPT5 ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT6 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testError ( js , es6Error ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testError ( js , es5Error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testError ( js , error ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testError ( js , error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( externs , js , diag , error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testSame ( externs , js , warning ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . test ( js , js ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . test ( js , js ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . test ( js , js ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
{ test ( js , expected , LanguageMode.ECMASCRIPT6 ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ test ( js , expected , LanguageMode.ECMASCRIPT6 ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . test ( js , expected ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . test ( js , expected ) ; }
setLanguage ( LanguageMode.ECMASCRIPT8 , LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( LanguageMode.ECMASCRIPT8 , LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( LanguageMode.ECMASCRIPT8 , LanguageMode.ECMASCRIPT5 ) ;
public void testValidRestParameter () { setLanguage ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ; valid ( STRING_CONSTANT ) ; valid ( STRING_CONSTANT ) ; }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; allowExternsChanges ( true ) ; }
public void testNoRewriteIfNotInGlobalScope1 ( ) throws Exception { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT + NoRewriteIfNotInGlobalScopeTestInput.INPUT + STRING_CONSTANT ) ; }
options . setLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
private void testSameEs6Strict ( String js ) { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ; test ( js , js , null , null ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; allowExternsChanges ( false ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; anchorUnusedVars = false ; canRemoveExterns = false ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testObjLit () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; assertUnreachable ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testForLoopsEs6 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; assertUnreachable ( STRING_CONSTANT ) ; assertUnreachable ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testConst () { testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testLet () { testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
{ testRewriteWarning ( code , expected , warning , LanguageMode.ECMASCRIPT3 ) ; testRewriteWarning ( code , expected , warning , LanguageMode.ECMASCRIPT6 ) ; }
{ testRewriteError ( js , error , LanguageMode.ECMASCRIPT3 ) ; testRewriteError ( js , error , LanguageMode.ECMASCRIPT6 ) ; }
{ testRewrite ( code , expected , LanguageMode.ECMASCRIPT3 ) ; testRewrite ( code , expected , LanguageMode.ECMASCRIPT6 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; languageOut = LanguageMode.ECMASCRIPT3 ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrowFunction4 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testFailure ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrowFunction3 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testFailure ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrowFunction2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testFailure ( STRING_CONSTANT ) ; }
public void testArrowFunction1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testFailure ( STRING_CONSTANT ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( createShorthandFunctionInObjLit ( returnType , body ) ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; String js = createShorthandFunctionInObjLit ( returnType , body ) ; testWarning ( js , CheckMissingReturn.MISSING_RETURN_STATEMENT ) ; }
options . setLanguage ( LanguageMode.ECMASCRIPT8 ) ;
public void testFunctionNonMovement1 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; testSame ( createModuleStar ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testInlineEmptyFunction6 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
public void testEs6EnhancedObjLiteralsPropertyShorthand () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testEs6EnhancedObjLiteralsComputedValuesNotRemoved () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testES6ClassComputedProperty () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT ) ; }
public void testEs6GettersWithoutTranspilation () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageOut ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
public CheckUnusedPrivatePropertiesTest () { super ( EXTERNS ) ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; }
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT8 ;
languageMode = LanguageMode.ECMASCRIPT8 ;
public void testAsyncArrowFunction () { languageMode = LanguageMode.ECMASCRIPT8 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT8 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testMemberGeneratorYield1 () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testNewTarget () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDefaultParametersWithRestParameters () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testRestParameters () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDefaultParameters () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testOctalNumericKey () { allowWarnings = true ; languageMode = LanguageMode.ECMASCRIPT6 ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testComputedPropertiesClassMethods () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
{ assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrettyPrinter_defaultValue ( ) throws Exception { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testPrettyPrinter_arrow ( ) throws Exception { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testForOf () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDestructuringForOfLoops2 () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrintDestructuringInRestParam () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrintMixedDestructuring () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testPrettyPrintObjectPattern () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrintNestedObjectPattern () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testPrettyPrintArrayPattern () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrintBlockScopedFunctions () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExponentiationAssignmentOperator () { languageMode = LanguageMode.ECMASCRIPT7 ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT7 ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT8 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; runTypeCheckAfterProcessing = true ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
{ CompilerOptions options = super . getOptions () ; options . setLanguageIn ( LanguageMode.ECMASCRIPT6_TYPED ) ; options . setLanguageOut ( LanguageMode.ECMASCRIPT6 ) ; return options ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; compiler = createCompiler () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; runTypeCheckAfterProcessing = true ; compareJsDoc = true ; }
return CompilerOptions.LanguageMode.ECMASCRIPT6_STRICT ;
this . languageIn = CompilerOptions.LanguageMode.ECMASCRIPT6 ;
public void testCodeMotionDoesntBreakFunctionHoisting ( ) throws Exception { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
return languageOutIsAtLeast ( LanguageMode.ECMASCRIPT6 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , VarCheck.VIOLATED_MODULE_DEP_ERROR ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , VarCheck.VIOLATED_MODULE_DEP_ERROR ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , VarCheck.MISSING_MODULE_DEP_ERROR ) ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , VarCheck.MISSING_MODULE_DEP_ERROR ) ; }
public void testLegalConstReferenceBetweenModules () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testLegalLetReferenceBetweenModules () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
public void testNoMoveDeepFunctionDeclarations () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
setLanguage ( LanguageMode.ECMASCRIPT6_STRICT , LanguageMode.ECMASCRIPT5_STRICT ) ;
{ setLanguage ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setLanguage ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
{ super . setUp () ; compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ; compilerOptions . setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
replaceSymbol ( n , name , t . getInput () ) ;
com.google.javascript.jscomp.newtypes.FunctionType ctorType = functionType . getFunTypeIfSingletonObj () ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
checkState ( child.parent == this ) ;
{ Preconditions . checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
replaceSymbol ( t , n , name , t . getInput () ) ;
findDeclaredNames ( functionBody , renamer , false ) ;
if ( ! declarationRoot . isFunction () ) { findDeclaredNames ( declarationRoot , renamer , false ) ; }
testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ;
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
checkState ( child.parent == this , STRING_CONSTANT , child , parent ) ;
{ checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
checkState ( child.parent == this ) ;
{ Preconditions . checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
Preconditions . checkState ( this . rawType . isFinalized () ) ;
{ Preconditions . checkState ( this . rawType . isFinalized () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
Preconditions . checkState ( this . rawType . isFinalized () ) ;
public RawNominalType getRawNominalType () { Preconditions . checkState ( ! this . rawType . isFinalized () ) ; return this . rawType ; }
{ if ( isFinalized && externs . containsKey ( name ) ) { type = externs . get ( name ) ; } }
Preconditions . checkState ( isFinalized ) ;
Preconditions . checkArgument ( nominalType . isFinalized () ) ;
Preconditions . checkArgument ( nominalType . isFinalized () ) ;
Preconditions . checkState ( this . isFinalized , STRING_CONSTANT , this ) ;
{ Preconditions . checkState ( ! this . isFinalized ) ; super . addUndeclaredProperty ( pname , defSite , this . commonTypes . UNKNOWN , false ) ; }
{ Preconditions . checkState ( ! this . isFinalized ) ; super . addProperty ( pname , defSite , type , isConstant ) ; }
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( this . isFinalized ) ;
if ( ! this . isFinalized ) { return null ; }
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
public boolean isStruct () { Preconditions . checkState ( isFinalized () || isClass () ) ; return this . objectKind . isStruct () ; }
if ( ! thisNode . isEquivalentToShallow ( thatNode ) ) { return false ; }
ScopedChangeHandler () { this . lastCodeChangeQuery = timestamp ; }
maybeSanityCheck ( externs , root ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
@ Override protected void setUp () { super . enableLineNumberCheck ( false ) ; }
@ Override public void setUp () { enableNormalize () ; }
@ Override protected void setUp () { nameGenerator = null ; }
@ Override public void setUp () { enableNormalize () ; }
@ Override public void setUp () { super . enableLineNumberCheck ( false ) ; }
@ Override public void setUp () { enableNormalize () ; }
@ Override public void setUp () { enableNormalize () ; }
@ Override protected void setUp () { super . enableNormalize () ; }
@ Override public void setUp () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; }
@ Override public void setUp () { enableNormalize () ; }
public InlineVariablesConstantsTest () { enableNormalize () ; }
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; }
globalScope = TypedScope . createGlobalScope ( blockNode ) ;
setReferencedType ( registry . getNativeObjectType ( JSTypeNative.NO_RESOLVED_TYPE ) ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope ) ; }
@ Override public void setUp () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; validateAstChangeMarking ( false ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
compiler . reportCodeChange () ;
{ Node grandparent = parent . getParent () ; replaceWithEmpty ( parent , grandparent ) ; compiler . reportCodeChange () ; }
@ Override public boolean isUnresolved () { return false ; }
JSTypes getCommonTypes () { return this . commonTypes ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ newBlockNode . useSourceInfoIfMissingFromForTree ( oldBlockNode ) ; functionNode . replaceChild ( oldBlockNode , newBlockNode ) ; compiler . reportCodeChange () ; }
if ( ! origValueNode . getString () . equals ( newString ) ) { origValueNode . setString ( newString ) ; compiler . reportCodeChange () ; }
if ( newValue != msgNode ) { newValue . useSourceInfoIfMissingFromForTree ( msgNode ) ; msgNode . replaceWith ( newValue ) ; compiler . reportCodeChange () ; }
enableTypeCheck () ;
public void testCoercionSubstitution_boxedNumberVsZero () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
@ Override protected void setUp () { super . enableLineNumberCheck ( false ) ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( ! collapses . isEmpty () ) { applyCollapses () ; compiler . reportCodeChange () ; }
if ( codeChanged ) { reportCodeChange () ; }
{ if ( NodeUtil . getPureBooleanValue ( forCondition ) == TernaryValue.TRUE ) { forCondition . replaceWith ( IR . empty () ) ; reportCodeChange () ; } }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
{ maybeBreak . detach () ; reportCodeChange () ; }
reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; reportCodeChange () ; return right ; }
@ Override protected void setUp () { allowExternsChanges ( true ) ; validateAstChangeMarking ( false ) ; }
reportCodeChange () ;
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; reportCodeChange () ; return null ; }
for ( Node childToRemove : nodesToRemove ) { node . removeChild ( childToRemove ) ; reportCodeChange () ; }
t . getCompiler () . reportCodeChange () ;
{ n . setString ( newName ) ; t . getCompiler () . reportCodeChange () ; return; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ callTarget . getLastChild () . setString ( STRING_CONSTANT ) ; firstArg . getNext () . detach () ; reportCodeChange () ; return n ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; reportCodeChange () ; return newNode ; }
if ( rhs . isChanged () ) { reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( placeholder , mNode . getNode () . removeFirstChild () ) ; reportCodeChange () ; }
reportCodeChange () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detach () ; reportCodeChange () ; return null ; }
this . reportCodeChange () ;
reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . setString ( prop + fileid ) ; compiler . reportCodeChange () ; }
void apply () { parent . replaceChild ( oldChild , newChild ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; reportCodeChange () ; return result ; }
reportCodeChange () ;
{ n . detachChildren () ; parent . replaceChild ( n , result ) ; reportCodeChange () ; return result ; }
reportCodeChange () ;
reportCodeChange () ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; reportCodeChange () ; return replacementNode ; }
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ Node retValue = returnedValue . cloneTree () ; parent . replaceChild ( call , retValue ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
if ( canFoldStandardConstructors ( n ) ) { n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; validateAstChangeMarking ( false ) ; }
{ parent . removeChild ( n ) ; compiler . reportCodeChange () ; functions . put ( t . getModule () , n ) ; }
if ( node != null ) { n . setDeclaredTypeExpression ( node ) ; compiler . reportCodeChange () ; }
{ attachTypeExpr = IR . rest ( n . getString () ) ; n . replaceWith ( attachTypeExpr ) ; compiler . reportCodeChange () ; }
if ( ! p.newName . equals ( oldName ) ) { n . setString ( p.newName ) ; compiler . reportCodeChange () ; }
public InlineVariablesConstantsTest () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; validateAstChangeMarking ( false ) ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
notifyOfRemoval ( node ) ;
{ parent . removeChild ( node ) ; notifyOfRemoval ( node ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
for ( Node closureRequire : requiresToBeRemoved ) { closureRequire . detach () ; compiler . reportCodeChange () ; }
@ Override protected void setUp () { super . enableNormalize () ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ functionBody . removeChild ( current ) ; insertAfter = addToFront ( functionBody , current , insertAfter ) ; reportCodeChange ( STRING_CONSTANT ) ; }
reportCodeChange ( STRING_CONSTANT ) ;
reportCodeChange ( STRING_CONSTANT ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
scope . isLocal ()
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( maybeNormalizeFunctionDeclaration ( n ) ) { reportCodeChange ( n , STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ return new TypeInformationGatherer ( compiler , new DevirtualizePrototypeMethods ( compiler ) , typeInformation ) ; }
Iterable < JSModule > getAllModules () { return modules ; }
n . isName () && n . getParent () . isVar ()
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
setInputId ( null , STRING_CONSTANT ) ;
setInputId ( NodeUtil . getInputId ( scopeRoot ) , STRING_CONSTANT ) ;
setInputId ( NodeUtil . getInputId ( root ) , STRING_CONSTANT ) ;
compiler . setScope ( root ) ;
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
{ Node dollarChildProp = n . getGrandparent () ; dollarChildProp . setToken ( Token.GETELEM ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
@ Override public void setUp () { super . enableLineNumberCheck ( false ) ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ c . setQuotedString () ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ if ( NodeUtil . getPureBooleanValue ( forCondition ) == TernaryValue.TRUE ) { forCondition . replaceWith ( IR . empty () ) ; compiler . reportCodeChange () ; } }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; compiler . reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ maybeBreak . detach () ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; compiler . reportCodeChange () ; return right ; }
compiler . reportCodeChange () ;
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; compiler . reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; compiler . reportCodeChange () ; return null ; }
for ( Node childToRemove : nodesToRemove ) { node . removeChild ( childToRemove ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ callTarget . getLastChild () . setString ( STRING_CONSTANT ) ; firstArg . getNext () . detach () ; compiler . reportCodeChange () ; return n ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; compiler . reportCodeChange () ; return newNode ; }
if ( rhs . isChanged () ) { compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . replaceChild ( placeholder , mNode . getNode () . removeFirstChild () ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detach () ; compiler . reportCodeChange () ; return null ; }
this . compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( tryReplaceArguments ( traversal . getScope () ) ) { traversal . getCompiler () . reportCodeChange () ; }
t . getCompiler () . reportCodeChange () ;
t . getCompiler () . reportCodeChange () ;
if ( newJsdoc != null ) { jsdocNode . setJSDocInfo ( newJsdoc ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
if ( isGoogLoadModuleStatement ( n ) ) { updateGoogLoadModuleLate ( n ) ; }
{ n . putBooleanProp ( Node.GOOG_MODULE , true ) ; inlineModuleIntoGlobal ( n ) ; compiler . reportCodeChange () ; checkAndSetStrictModeDirective ( t , n ) ; }
visitClass ( n , parent ) ;
visitRestParam ( n , parent ) ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ parent . replaceChild ( n , declaringNode . getFirstFirstChild () . cloneTree () ) ; compiler . reportCodeChange () ; }
{ if ( isUtilGetDefineCall ( n ) ) { substituteUtilGetDefine ( n ) ; } }
{ if ( NodeUtil . isDestructuringDeclaration ( n ) ) { splitDeclaration ( n , parent ) ; } }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; compiler . reportCodeChange () ; return newLiteralNode ; }
if ( canFoldStandardConstructors ( n ) ) { n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ visitArrowFunction ( n , checkNotNull ( thisContext ) ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
JSTypeExpression typeExpr = getTypeFromGetterOrSetter ( member ) . clone () ;
{ if ( expr != null ) { return cloneTypeNodes ? expr . clone () : expr ; } return null ; }
if ( foundObj . isGeneric () ) { foundType = foundObj . getRawType () ; }
if ( foundType != null && foundType . isGeneric () ) { foundType = foundType . getRawType () ; }
ImmutableMap < String , JSType > typeVars
if ( obj != null && obj . isGeneric () ) { return obj . instantiateGenericsWithUnknown () ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new PropagateConstJsdoc ( compiler ) ) ; new RemoveCode ( compiler ) . process ( externs , root ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
JSType type = n . getJSType () ;
JSType type = n . getJSType () ;
if ( extractionInfo . shouldExtract () ) { doExtraction ( extractionInfo ) ; compiler . reportCodeChange () ; }
compiler . reportChangeToEnclosingScope ( getKey . getParent () ) ;
t . reportCodeChange () ;
compiler . reportCodeChange () ;
{ if ( logger . isLoggable ( Level.FINE ) ) { logger . fine ( STRING_CONSTANT + callName ) ; } inlineEmptyMethod ( parent , callNode ) ; }
compiler . reportCodeChange () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; validateAstChangeMarking ( false ) ; }
for ( Definition def : definitionsGatherer.definitions ) { def . remove () ; compiler . reportCodeChange () ; }
if ( codeChanged ) { compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; compiler . reportCodeChange () ; return result ; }
compiler . reportCodeChange () ;
{ n . detachChildren () ; parent . replaceChild ( n , result ) ; compiler . reportCodeChange () ; return result ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; compiler . reportCodeChange () ; return replacementNode ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; compiler . reportCodeChange () ; }
if ( ! precheck () ) { return; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
if ( Keywords . isKeyword ( idToken.value ) && ! Keywords . isTypeScriptSpecificKeyword ( idToken.value ) ) { reportError ( STRING_CONSTANT + name + STRING_CONSTANT ) ; }
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null , null ) ;
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null , null ) ;
optimizer = new PhaseOptimizer ( compiler , tracker , null ) ;
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null , null ) ;
if ( typeWithBannedProp . isSubtypeOf ( foundType ) ) { if ( matchesPrototype ( typeWithBannedProp , foundType ) ) { return ConformanceResult.VIOLATION ; } else if ( reportLooseTypeViolations ) { return ConformanceResult.POSSIBLE_VIOLATION_DUE_TO_LOOSE_TYPES ; } }
Iterable < JSModule > getAllModules () { return modules ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ clazz . replaceChild ( clazz . getFirstChild () , IR . empty () . useSourceInfoFrom ( clazz . getFirstChild () ) ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( n . getLineno () == NUMBER_CONSTANT ) { n . setCharno ( n . getCharno () - NUMBER_CONSTANT ) ; compiler . reportCodeChange () ; }
Compiler compiler
{ n . setString ( newName ) ; t . getCompiler () . reportChangeToEnclosingScope ( n ) ; return; }
maybeRewriteClassDefinition ( n ) ;
{ if ( isMethodOrCtorCallThatTriggersRemoval ( t , n , parent ) ) { replaceHighestNestedCallWithNull ( n , parent ) ; } }
if ( parent . getFirstChild () == n && isReferenceToRemovedVar ( t , n ) ) { replaceHighestNestedCallWithNull ( parent , parent . getParent () ) ; }
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , InliningMode.DIRECT ) ;
this . mode = TypeInferenceMode.BOTH ;
PeepholeFoldConstantsTest () { super ( DEFAULT_EXTERNS ) ; }
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
@ Override public void setUp () { setLanguage ( ECMASCRIPT_NEXT , ECMASCRIPT_NEXT ) ; }
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
tightenTypeAndDontWarn ( varName , expr , declType , inferredType , requiredType )
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT ) , InliningMode.DIRECT ) ;
Iterable < JSModule > getAllModules () { return modules ; }
List < TypeMismatch > actual = ImmutableList . copyOf ( compiler . getTypeMismatches () ) ;
JSTypeRegistry registry = compiler . getTypeRegistry () ;
JSTypeRegistry registry = compiler . getTypeRegistry () ;
JSTypeRegistry registry = compiler . getTypeRegistry () ;
NodeTraversal . traverseEs6 ( currentCompiler , currentCompiler.jsRoot , s ) ;
{ currentLocationAbstractionIdentifier = locationAbstractionIdentifier ; testSame ( SHARED_EXTERNS , js , null ) ; currentJsRoot = currentCompiler.jsRoot ; return currentAnalysis ; }
NodeTraversal . traverseEs6 ( lastCompiler , lastCompiler.jsRoot , s ) ;
NodeTraversal . traverseEs6 ( lastCompiler , lastCompiler.jsRoot , findFunction ) ;
NodeTraversal . traverseEs6 ( lastCompiler , lastCompiler.jsRoot , findParameter ) ;
if ( NodeUtil . isCompoundAssignementOp ( n ) ) { normalizeAssignShorthand ( n ) ; }
NodeUtil . isCompoundAssignementOp ( n ) || n . isInc () || n . isDec ()
sourceMapOriginalSources . putIfAbsent ( path , originalSourcesLoader . apply ( path ) ) ;
Function < String , SourceFile > originalSourcesLoader
bundler . appendTo ( out , input , input . getSourceFile () . getCodeCharSource () ) ;
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
read () ;
{ ensureRequirementIsMutable () ; super . addAll ( values , requirement_ ) ; onChanged () ; }
catch ( com.google.protobuf.InvalidProtocolBufferException e ) { parsedMessage = ( com.google.javascript.jscomp.ConformanceConfig ) e . getUnfinishedMessage () ; throw e ; }
private void maybeForceBuilderInitialization () { if ( com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ) { getRequirementFieldBuilder () ; } }
private Builder ( com.google.protobuf.GeneratedMessage.BuilderParent parent ) { super ( parent ) ; maybeForceBuilderInitialization () ; }
com.google.protobuf.GeneratedMessage.BuilderParent parent
{ return PARSER . parseFrom ( input , extensionRegistry ) ; }
{ return PARSER . parseDelimitedFrom ( input , extensionRegistry ) ; }
{ return PARSER . parseFrom ( input , extensionRegistry ) ; }
public void testInlineInFunction () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( n . isAsyncFunction () ) { cannotConvertYet ( n , STRING_CONSTANT ) ; }
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT , STRING_CONSTANT ) , InliningMode.DIRECT ) ;
declaration . isVar () && declaredVarOrProp . isName ()
testGetFunctionName ( parent . getLastChild () , STRING_CONSTANT ) ;
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; testGetFunctionName ( parent . getFirstChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; testGetFunctionName ( parent . getLastChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; testGetFunctionName ( parent . getFirstChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) ; testGetFunctionName ( parent . getFirstChild () , STRING_CONSTANT ) ; }
if ( sanityCheck != null ) { setSanityCheckState () ; }
{ sanityCheck . create ( compiler ) . process ( externs , root ) ; NodeUtil . verifyScopeChanges ( passName , mtoc , jsRoot ) ; }
if ( n . getFirstChild () . matchesQualifiedName ( Es6ToEs3Converter.INHERITS ) ) { inheritsCalls . add ( n ) ; }
parent . replaceChild ( node , Node . newNumber ( NUMBER_CONSTANT ) . useSourceInfoIfMissingFrom ( node ) ) ;
compiler . optimize () ;
n . isName () && searchIt . currentParent () . isVar () && n . getString () . equals ( STRING_CONSTANT )
( declaration . getParent () . isVar () && ! NodeUtil . isLoopStructure ( declaration . getGrandparent () ) )
public HierarchicalSet ( HierarchicalSet parent ) { this . parent = parent ; }
clinitsCalledAtBranch = new HierarchicalSet ( clinitsCalledAtBranch ) ;
JSType declType = currentScope . getDeclaredTypeOf ( name ) ;
NTIScope innerScope = currentScope . getScope ( fnName ) ;
lhs . isName () && currentScope . isConstVar ( lhs . getString () )
if ( ! currentScope . hasThis () ) { return new EnvTypePair ( inEnv , UNKNOWN ) ; }
return expr . isNew () || ( expr . isCall () && currentScope . isConstructor () && expr . getFirstChild () . isSuper () ) ;
JSType declType = currentScope . getDeclaredTypeOf ( name ) ;
JSType declRetType = currentScope . getDeclaredFunctionType () . getReturnType () ;
guardA . addGuard ( accessControlsOff ) ;
Preconditions . checkState ( val . isObjectLit () ) ;
Preconditions . checkState ( object . isObjectLit () ) ;
Preconditions . checkState ( parent . getFirstChild () == name ) ;
checkState ( val . isObjectLit () , val ) ;
checkState ( object . isObjectLit () , object ) ;
checkState ( parent . getFirstChild () == name ) ;
Preconditions . checkState ( val . isObjectLit () ) ;
Preconditions . checkState ( object . isObjectLit () ) ;
Preconditions . checkState ( parent . getFirstChild () == name ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( t . getScope () != t . getClosestHoistScope () ) { return; }
public InlineVariablesTest () { enableNormalize () ; }
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
@ Override void reportChangeToEnclosingScope ( Node n ) { recordChange ( getEnclosingChangeScope ( n ) ) ; notifyChangeHandlers () ; }
{ return NodeUtil . precedence ( n . getToken () ) < minPrecedence ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
{ return precedence ( n ) < minPrecedence ; }
{ invalidatingPropRef = ! maybeCandidateDefinition ( t , n , parent ) ; }
JSType type
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
checkArgument ( child.parent == null ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
catch ( IllegalStateException e ) { assertTrue ( e . getMessage () . contains ( STRING_CONSTANT ) ) ; }
Preconditions . checkState ( ! maybeDecl . isInitializingDeclaration () ) ;
Preconditions . checkState ( references . get ( NUMBER_CONSTANT ) . isDeclaration () ) ;
{ deepestModule = graph . getDeepestCommonDependencyInclusive ( m , deepestModule ) ; }
{ return NodeUtil . precedence ( n . getToken () ) < minPrecedence ; }
Preconditions . checkNotNull ( js ) ;
Preconditions . checkState ( collectionRoot . isScript () || collectionRoot . isRoot () ) ;
{ Preconditions . checkNotNull ( options ) ; return warningsGuard . level ( error ) ; }
{ Preconditions . checkState ( changeScopeRoot . isScript () || changeScopeRoot . isFunction () ) ; recordChange ( changeScopeRoot ) ; notifyChangeHandlers () ; }
if ( currentChangeScope != null ) { Preconditions . checkState ( currentChangeScope . isScript () || currentChangeScope . isFunction () ) ; recordChange ( currentChangeScope ) ; }
Preconditions . checkState ( passes instanceof DefaultPassConfig , STRING_CONSTANT ) ;
Preconditions . checkState ( input . isExtern () , STRING_CONSTANT , input . getName () ) ;
Preconditions . checkState ( currentTracer != null , STRING_CONSTANT ) ;
Preconditions . checkState ( currentTracer == null ) ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
if ( ! compiler . hasErrors () ) { compiler . checkAndTranspileAndOptimize () ; compiler . completeCompilation () ; }
if ( ! compiler . hasErrors () ) { compiler . checkAndTranspileAndOptimize () ; compiler . completeCompilation () ; }
blockStack . get ( i ) . root == containingScope . getRootNode ()
if ( clone == null ) { verifyNewNode ( n ) ; } else { verifyNodeChange ( passNameMsg , n , clone ) ; }
grandparent == null || ( ! isPrototypePropertyDeclaration ( grandparent ) && ! isClassPropertyDeclaration ( parent . getFirstChild () , currentScope ) )
ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references . get ( i ) ;
ReferenceCollectingCallback.Reference ref
compiler . reportChangeToEnclosingScope ( expr ) ;
name . equals ( node . getQualifiedName () )
String newName
public InlineObjectLiteralsTest () { enableNormalize () ; }
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
{ return builder () . buildFromFile ( file ) ; }
{ n . getParent () . removeChild ( n ) ; }
if ( defined ) { compiler . reportChangeToEnclosingScope ( vnode . getParent () ) ; vnode . getParent () . removeChild ( vnode ) ; }
{ parent . getParent () . removeChild ( parent ) ; }
return enclosingNode != null && enclosingNode . getToken () != Token.FUNCTION ;
Node block = t . getScope () . getRootNode () ;
return parent != null && parent . getToken () == Token.ASSIGN && parent . getFirstChild () == n ;
parent . getParent () . removeChild ( parent ) ;
{ if ( isNamespacePlaceholder ( parent ) ) { compiler . reportChangeToEnclosingScope ( parent ) ; parent . getParent () . removeChild ( parent ) ; } }
{ parent . removeChild ( n ) ; if ( ! parent . hasChildren () ) { parent . getParent () . removeChild ( parent ) ; } }
assignmentParent . getParent () . removeChild ( assignmentParent ) ;
boolean isInClass = n . getParent () . getToken () == Token.CLASS_MEMBERS ;
@ Override public boolean isPropertyTestFunction ( Node call ) { return STRING_CONSTANT . equals ( call . getFirstChild () . getQualifiedName () ) ; }
{ parent . getParent () . removeChild ( parent ) ; }
qNameRoot != null && EXPORTS . equals ( qNameRoot . getQualifiedName () ) && NodeUtil . isLValue ( qNameRoot )
callbackBlock . getParent () . removeChild ( callbackBlock ) ;
onlyExport . getParent () . removeChild ( onlyExport ) ;
if ( ! name . equals ( anc . getFirstChild () . getQualifiedName () ) ) { return Ref.Type.ALIASING_GET ; }
isASTNormalized () && Token.NAME == constructorNameNode . getToken ()
{ if ( alreadyRemoved ( n ) ) { continue; } compiler . reportChangeToEnclosingScope ( n ) ; n . getParent () . removeChild ( n ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new Callback () ) ;
Preconditions . checkState ( ! name . equals ( ARGUMENTS ) ) ;
Preconditions . checkArgument ( ! idPrefix . isEmpty () ) ;
{ Preconditions . checkState ( n . isName () , n ) ; n . setString ( newName ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
if ( currentScript.isModule ) { rewriteShortObjectKey ( n ) ; }
{ testWarning ( js , warning , LanguageMode.ECMASCRIPT6 ) ; }
shouldRemove ( nameNode )
if ( isInferrableConst ( jsdoc , name , false ) ) { jsdoc = pullJsdocTypeFromAst ( compiler , jsdoc , name ) ; }
ReferenceCollectingCallback collector
ReferenceCollectingCallback collector
ReferenceCollectingCallback collector
public void testNgInjectAddsInjectToClassConstructor ( ) throws Exception { testEs6 ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
{ if ( null == str ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . str = str ; }
this . quoteKeywordProperties = options.quoteKeywordProperties ;
options . assumeStrictThis () || options . getLanguageIn () == LanguageMode.ECMASCRIPT5_STRICT
if ( options . shouldAmbiguateProperties () && ( options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED ) ) { passes . add ( ambiguateProperties ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
@ Override public void setUp () { setLanguage ( ECMASCRIPT_NEXT , ECMASCRIPT_NEXT ) ; behavior = null ; }
CrossModuleReferenceCollector collector = new CrossModuleReferenceCollector ( compiler , CrossModuleReferenceCollector.DO_NOTHING_BEHAVIOR , new Es6SyntacticScopeCreator ( compiler ) ) ;
builder . setTagAsStrict ( firstOutput && shouldEmitUseStrict () ) ;
public CompilerOptions setEmitUseStrict ( boolean emitUseStrict ) { this . emitUseStrict = emitUseStrict ; return this ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , error.description ) ;
assertEquals ( STRING_CONSTANT + STRING_CONSTANT , error.description ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal t = new NodeTraversal ( compiler , finder ) ;
NodeTraversal t = new NodeTraversal ( compiler , null ) ;
Preconditions . checkState ( reference . isName () ) ;
if ( unusedAssignment != null && ! isRead && ! hasErrors ) { checkForUnusedLocalVar ( v , unusedAssignment ) ; }
options . assumeStrictThis () || options . getLanguageIn () == ECMASCRIPT5_STRICT
ObjectsBuilder newObjs = new ObjectsBuilder ( ResolveConflictsBy.MEET ) ;
public RemoveSuperMethodsPassTest () { super ( DEFAULT_EXTERNS ) ; enableTypeCheck () ; }
while ( s.parent != null ) { if ( isDefinedLocally ( varName , false ) ) { return false ; } s = s.parent ; }
catch ( IllegalStateException e ) { assertEquals ( e . getMessage () , FixedPointGraphTraversal.NON_HALTING_ERROR_MSG ) ; }
catch ( MaxIterationsExceededException e ) { assertEquals ( e . getMessage () , STRING_CONSTANT + MAX_STEP + STRING_CONSTANT ) ; }
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , registry , builder ) ; }
options . assumeStrictThis () || options . isStrictModeInput ()
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , builder ) ; }
catch ( Exception e ) { compiler . report ( JSError . make ( COULD_NOT_DESERIALIZE_AST , filename ) ) ; }
options . assumeStrictThis () || options . getLanguageIn () == ECMASCRIPT5_STRICT
! NodeUtil . isValidQualifiedName ( compiler . getLanguageMode () , name )
key . isStringKey () && ! key . isQuotedString () && NodeUtil . isValidPropertyName ( compiler . getLanguageMode () , key . getString () )
Config.StrictMode strictMode = expectStrictModeInput () ? Config.StrictMode.STRICT : Config.StrictMode.SLOPPY ;
if ( expectStrictModeInput () ) { options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.ERROR ) ; }
return new InlineFunctions ( compiler , compiler . getUniqueNameIdSupplier () , options.inlineFunctions , options.inlineLocalFunctions , true , options . assumeStrictThis () || options . isStrictModeInput () , options.assumeClosuresOnlyCaptureReferences , options.maxFunctionSizeAfterInlining ) ;
public CompilerOptions setStrictModeInput ( boolean isStrictModeInput ) { this . isStrictModeInput = isStrictModeInput ; return this ; }
! NodeUtil . isValidQualifiedName ( compiler . getOptions () . getLanguageOut () , name )
Pattern . compile ( STRING_CONSTANT + STRING_CONSTANT )
! NodeUtil . isValidQualifiedName ( compiler . getLanguageMode () , name )
key . isStringKey () && ! key . isQuotedString () && NodeUtil . isValidPropertyName ( compiler . getOptions () . getLanguageOut () , key . getString () )
String finalMessage = STRING_CONSTANT + STRING_CONSTANT + message ;
STRING_CONSTANT + number + ( unsupported ? STRING_CONSTANT : STRING_CONSTANT ) + ( es6Modules ? STRING_CONSTANT : STRING_CONSTANT ) + ( typeScript ? STRING_CONSTANT : STRING_CONSTANT ) + STRING_CONSTANT
( ( FeatureSet ) other ) . unsupported == unsupported
this . number >= other.number && ( this . unsupported || ! other.unsupported )
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
{ if ( mockToString ) { return STRING_CONSTANT ; } return appendTo ( new StringBuilder () ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
{ parent . replaceChild ( assignNode , assignNode . getLastChild () . detach () ) ; }
builder . append ( CHAR_CONS ) ;
MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator () ;
MemoizedScopeCreator getTypedScopeCreator () { return typedScopeCreator ; }
typedScopeCreator = new MemoizedScopeCreator ( internalScopeCreator ) ;
scopeCreator = new MemoizedScopeCreator ( new TypedScopeCreator ( compiler ) ) ;
MemoizedScopeCreator scopeCreator
MemoizedScopeCreator scopeCreator
{ foundNodes . put ( name , n ) ; }
{ this . names = names ; foundNodes = new HashMap <> () ; }
Preconditions . checkState ( inputs.length > NUMBER_CONSTANT ) ;
List < SourceFile > externsInputs = ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , externs ) ) ;
test ( compiler , expected , error , warning ) ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; }
languageMode = options . getLanguageIn () ;
this . languageMode = options . getLanguageIn () ;
{ Compiler compiler = new Compiler () ; compiler . setLanguageMode ( acceptedLanguage ) ; return compiler ; }
validateEs6TypedFeature ( STRING_CONSTANT , n ) ;
{ validateEs6TypedFeature ( STRING_CONSTANT , n ) ; validateNodeType ( Token.DECLARE , n ) ; validateAmbientDeclarationHelper ( n . getFirstChild () ) ; }
{ validateEs6TypedFeature ( STRING_CONSTANT , n ) ; validateNodeType ( Token.TYPE_ALIAS , n ) ; validateChildCount ( n ) ; }
validateEs6Feature ( STRING_CONSTANT , n ) ;
validateEs6Feature ( STRING_CONSTANT , n ) ;
validateEs6TypedFeature ( STRING_CONSTANT , n ) ;
validateEs6Feature ( STRING_CONSTANT , n ) ;
validateEs6Feature ( STRING_CONSTANT , n ) ;
validateEs6Feature ( STRING_CONSTANT , n ) ;
{ validateEs6Feature ( STRING_CONSTANT , n ) ; validateNodeType ( Token.AWAIT , n ) ; validateWithinAsyncFunction ( n ) ; }
validateEs6Feature ( STRING_CONSTANT , n ) ;
{ if ( options.skipNonTranspilationPasses ) { whitespaceOnlyPasses () ; if ( options . lowerFromEs6 () ) { transpileAndDontCheck () ; } } else { check () ; } }
compiler . getOptions () . lowerFromEs6 ()
compiler . getOptions () . lowerFromEs6 ()
Node root2 = compiler . parseSyntheticCode ( source ) ;
if ( options.dartPass && ! options . getLanguageOut () . isEs6OrHigher () ) { checks . add ( dartSuperAccessorsPass ) ; }
options.rewritePolyfills = flags.rewritePolyfills && options . getLanguageIn () . isEs6OrHigher () ;
return replaceNode ( minCond . getPlaceholder () , minCond . getMinimized ( MinimizationStyle.PREFER_UNNEGATED ) ) ;
final int precedence
expectFeatures ( Feature.DESTRUCTURING , Feature.REST_PARAMETERS ) ;
! forTranspileOnly || ( compiler . getOptions () . getLanguageIn () . toFeatureSet () . contains ( FeatureSet.ES6 ) && TranspilationPasses . isScriptEs6ImplOrHigher ( scriptRoot ) )
{ for ( Node singleRoot : root . children () ) { if ( TranspilationPasses . isScriptEs6ImplOrHigher ( singleRoot ) ) { return true ; } } }
{ Preconditions . checkState ( script . isScript () ) ; if ( TranspilationPasses . isScriptEs6ImplOrHigher ( script ) ) { return true ; } }
isScriptEs6ImplOrHigher ( scriptRoot )
isScriptEs6ImplOrHigher ( singleRoot )
{ if ( isScriptEs6ImplOrHigher ( scriptRoot ) ) { for ( Callback callback : callbacks ) { NodeTraversal . traverseEs6 ( compiler , scriptRoot , callback ) ; } } }
{ if ( isScriptEs6ImplOrHigher ( singleRoot ) ) { for ( Callback callback : callbacks ) { NodeTraversal . traverseEs6 ( compiler , singleRoot , callback ) ; } } }
return isConst && ! hasAnnotatedType ( jsdoc ) && ! NodeUtil . isNamespaceDecl ( nameNode ) ;
rhs . replaceWith ( IR . cast ( IR . number ( NUMBER_CONSTANT ) , getQmarkTypeJSDoc () ) . srcrefTree ( rhs ) ) ;
new ProcessEs6Modules ( this ) . processFile ( root , forceRewrite ) ;
completeCompilation () ;
completeCompilation () ;
{ compiler . stage1Passes () ; if ( ! compiler . hasErrors () ) { compiler . stage2Passes () ; } compiler . completeCompilation () ; }
{ compiler . restoreState ( serializedInputStream ) ; if ( ! compiler . hasErrors () ) { compiler . stage2Passes () ; } compiler . completeCompilation () ; }
setFeatureSet ( featureSet . withoutModules () ) ;
features . hasEs6Modules ()
STRING_CONSTANT + featureSet . toLanguageModeString ()
for ( LanguageMode mode : LanguageMode . values () ) { if ( mode.featureSet . contains ( feature ) ) { return mode ; } }
if ( expectedFeatures != null ) { assertThat ( result.features ) . isEqualTo ( expectedFeatures ) ; }
if ( expectedFeatures != null ) { assertThat ( result.features ) . isEqualTo ( expectedFeatures ) ; }
expectFeatures ( Feature.DESTRUCTURING , Feature.LET_DECLARATIONS ) ;
expectFeatures ( Feature.CLASSES , Feature.CONST_DECLARATIONS ) ;
m.featureSet . contains ( Feature.ASYNC_FUNCTIONS )
expectFeatures ( Feature.DESTRUCTURING ) ;
expectFeatures ( Feature.EXTENDED_OBJECT_LITERALS ) ;
{ if ( ! compiler . getFeatureSet () . contains ( feature ) ) { violation ( STRING_CONSTANT + feature , n ) ; } }
{ if ( isValidSimpleName ( name ) ) { return true ; } else { return mode . contains ( Feature.KEYWORDS_AS_PROPERTIES ) && TokenStream . isKeyword ( name ) ; } }
features = features . require ( Feature.STRING_CONTINUATION ) ;
features = features . require ( feature ) ;
features = features . require ( feature ) ;
features = features . require ( Feature.SETTER ) ;
features = features . require ( Feature.GETTER ) ;
features = features . require ( Feature.KEYWORDS_AS_PROPERTIES ) ;
features = features . require ( factory . getFeatures () ) ;
{ features = features . require ( FeatureSet.TYPESCRIPT ) ; return nextToken () . type ; }
features = features . require ( Feature.DESTRUCTURING ) ;
features = features . require ( Feature.DESTRUCTURING ) ;
features = features . require ( Feature.ARRAY_PATTERN_REST ) ;
features = features . require ( Feature.DESTRUCTURING ) ;
features = features . require ( Feature.NEW_TARGET ) ;
features = features . require ( Feature.EXPONENT_OP ) ;
features = features . require ( Feature.ARROW_FUNCTIONS ) . require ( Feature.ASYNC_FUNCTIONS ) ;
features = features . require ( Feature.ARROW_FUNCTIONS ) ;
if ( TokenType.STAR_STAR_EQUAL . equals ( operator.type ) ) { features = features . require ( Feature.EXPONENT_OP ) ; }
{ features = features . require ( Feature.TRAILING_COMMA ) ; if ( config.warnTrailingCommas ) { errorReporter . reportWarning ( commaToken.location.start , STRING_CONSTANT ) ; } }
features = features . require ( Feature.REST_PARAMETERS ) ;
features = features . require ( Feature.DEFAULT_PARAMETERS ) ;
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
if ( Keywords . isKeyword ( name.value ) ) { features = features . require ( Feature.KEYWORDS_AS_PROPERTIES ) ; }
{ if ( hasConditionalAncestor ( parent . getParent () ) ) { info.allowMove = false ; } }
Collection < JSModule > modules
Preconditions . checkArgument ( root . isRoot () ) ;
assertPrettyPrintSame ( STRING_CONSTANT ) ;
Node parse ( String js ) { return parse ( js , false ) ; }
String [] parts = path . split ( Pattern . quote ( MODULE_SLASH ) ) ;
public void testConstTarget () { disableTypeCheck () ; testErrorEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , POLYMER_INVALID_DECLARATION ) ; }
private void assertNoWarningEs6 ( String js ) { testSameEs6 ( js ) ; }
private void assertAmbiguousEs6 ( String js ) { testSameEs6 ( js ) ; }
public void testAliasInModule () { enableUnusedLocalAssignmentCheck = true ; testSameEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSameEs6 ( STRING_CONSTANT ) ;
public void testEs6Class_testMethod () { testEs6 ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExtractableExport4 () { testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testExtractableExport3 () { testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ testEs6 ( wrapInFunction ( original ) , wrapInFunction ( expected ) ) ; }
public void testGoogScopeClassOutput () { testEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportEs6ArrowFunction () { testEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportConst () { testEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportLet () { testEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
public void testRemoveRepeatedProperties () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveUnnecessaryBodies () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testConstPropagationPrivateProperties2 () { testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testConstructorAlias4 () { testSameEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorAlias3 () { testSameEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGoogModuleWithEmptyDestructuringRequire () { testErrorEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , EXTRA_REQUIRE_WARNING ) ; }
testSameEs6 ( STRING_CONSTANT ) ;
testWarningEs6 ( STRING_CONSTANT , UNUSED_LABEL ) ;
testErrorEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ReplaceIdGenerators.CONDITIONAL_ID_GENERATOR_CALL ) ;
public void testClass () { testSameEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ReplaceIdGenerators.INVALID_GENERATOR_PARAMETER ) ; }
public void testRemovalMultipleAssignment3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemovalMultipleAssignment2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testDuplicate_destructuring () { testWarningEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , DUPLICATE_REQUIRE ) ; }
public void testDuplicate_shorthand () { testWarningEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , DUPLICATE_REQUIRE ) ; }
@ Override public void setUp () { injectNamespace = false ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
public void testPassModule () { testSameEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override public void setUp () { mode = CheckRequiresForConstructors.Mode.FULL_COMPILE ; }
{ testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , null ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
{ testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , null ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
public void testBadObjectLiteralCast1 () { testSame ( STRING_CONSTANT + STRING_CONSTANT , ClosureCodingConvention.OBJECTLIT_EXPECTED ) ; }
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
public void testNullUndefined () { testSame ( STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ; assertMismatches ( Collections . < TypeMismatch > emptyList () ) ; }
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ;
{ testSame ( STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ; assertMismatches ( ImmutableList . of ( fromNatives ( STRING_TYPE , NUMBER_TYPE ) ) ) ; }
testSame ( declarations + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
{ testSame ( STRING_CONSTANT + params + STRING_CONSTANT + arguments + STRING_CONSTANT , type ) ; }
testSame ( fooDfn + STRING_CONSTANT , WRONG_ARGUMENT_COUNT ) ;
public void testPathologicalCaseThatsOkAnyway () { testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , NAME_DEFINED_LATE_WARNING ) ; }
{ return ! found ; }
testWarning ( STRING_CONSTANT , STRING_CONSTANT , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
testWarning ( STRING_CONSTANT , STRING_CONSTANT , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSame ( typedefExterns , code , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT , value ( STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testCustomBanUnknownThisProp2 () { configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testCustomRestrictThrow2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
{ allowSourcelessWarnings () ; configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
testSame ( EXTERNS + STRING_CONSTANT , code + STRING_CONSTANT , null ) ;
testSame ( code + STRING_CONSTANT ) ;
{ configuration = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; testConformance ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
testSame ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ) ) ;
test ( input , input , null , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
testSame ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ) ) ;
public void testViolationWhitelisted2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
public void testViolationWhitelisted1 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
testSame ( STRING_CONSTANT ) ;
public void testNotViolation2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
{ testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
NodeTraversal t
Node export = n . getFirstChild () ;
public void testObjLit () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; assertUnreachable ( STRING_CONSTANT ) ; }
if ( options . needsTranspilationFrom ( FeatureSet.ES6 ) && ! options.skipTranspilationAndCrash ) { checks . add ( convertStaticInheritance ) ; }
catch ( IOException e ) { report ( JSError . make ( AbstractCompiler.READ_ERROR , input . getName () ) ) ; }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
defUse = new MustBeReachingVariableDef ( cfg , scope , compiler ) ;
liveness = new LiveVariablesAnalysis ( cfg , functionScope , compiler ) ;
useDef = new MaybeReachingVariableUse ( cfg , scope , compiler ) ;
LiveVariablesAnalysis liveness = new LiveVariablesAnalysis ( cfg , scope , compiler ) ;
public void testObjectDestructuringDefaultValsDoesntCrash () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringAssignNewVarNamesDoesntCrash () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringAssignWithoutDeclarationDoesntCrash () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringBasicAssignDoesntCrash () { testSame ( STRING_CONSTANT ) ; }
public void testArrayDestructuringVarAssignDoesntCrash () { testSame ( STRING_CONSTANT ) ; }
public void testArrayDestructuringSwapDoesntCrash () { testSame ( STRING_CONSTANT ) ; }
{ new GraphReachability <> ( controlFlowGraph , new ReachablePredicate () ) . compute ( controlFlowGraph . getEntry () . getValue () ) ; }
inheritsCall . useSourceInfoIfMissingFromForTree ( classNode ) ;
Node lp = scope . getRootNode () . getSecondChild () ;
assertEquals ( expected , cssNames ) ;
assertEquals ( expected , cssNames ) ;
assertEquals ( expected , cssNames ) ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; disableMultistageCompilation () ; }
catch ( IOException e ) { compiler . report ( JSError . make ( COULD_NOT_DESERIALIZE_AST , filename ) ) ; }
public void testArguments () { testConsts ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; }
allowExternsChanges ( true ) ;
allowExternsChanges ( true ) ;
allowExternsChanges ( true ) ;
enableCheckAccessControls ( true ) ;
enableCheckAccessControls ( true ) ;
if ( transpileEnabled && transpileExpected && ! compiler . hasErrors () ) { transpileToEs5 ( compiler , externsRoot , mainRoot ) ; }
public String getFilename () { return filename ; }
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; }
compareJsDoc = false ;
public GatherRawExportsTest () { super ( EXTERNS ) ; super . enableNormalize () ; }
public void testEs6ONoEs6 () { allowExternsChanges ( true ) ; testSame ( STRING_CONSTANT ) ; }
public Es6ExternsCheckTest () { super ( EXTERNS_BASE ) ; allowSourcelessWarnings () ; }
peepholePass . setRetraverseOnChange ( false ) ;
public ProcessDefinesTest () { super ( DEFAULT_EXTERNS + STRING_CONSTANT ) ; allowSourcelessWarnings () ; }
{ enableTypeCheck () ; allowExternsChanges ( true ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT , POSSIBLE_INEXISTENT_PROPERTY ) ; }
public RemoveUnusedClassPropertiesTest () { super ( EXTERNS ) ; enableGatherExternProperties () ; }
public RemoveUnusedVarsTest () { super ( STRING_CONSTANT ) ; enableNormalize () ; }
runSmartNameRemoval = true ;
allowExternsChanges ( true ) ;
{ allowExternsChanges ( true ) ; test ( STRING_CONSTANT , STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , null , null ) ; }
{ declarationCheck = ! sanityCheck ; this . enableCompareAsTree ( false ) ; testExternChanges ( extern , input , expectedExtern ) ; }
super . allowExternsChanges ( true ) ;
public void testIssue () { super . allowExternsChanges ( true ) ; test ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
allowExternsChanges ( true ) ;
public void testProvideInExterns () { allowExternsChanges ( true ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public J2clCheckPassTest () { super ( DEFAULT_EXTERNS ) ; enableTypeCheck () ; }
validateAstChangeMarking ( false ) ;
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
allowExternsChanges ( true ) ;
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ this . enableCompareAsTree ( false ) ; super . testExternChanges ( input , expectedExtern ) ; }
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; }
Node assign = IR . assign ( windowPropAccess , nameNode . getFirstChild () . detachFromParent () ) ;
{ value = key . getFirstChild () . detachFromParent () ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
binaryNamespaceName . putProp ( Node.ORIGINALNAME_PROP , currentScript.legacyNamespace ) ;
binaryNamespaceName . putProp ( Node.ORIGINALNAME_PROP , currentScript.legacyNamespace ) ;
exportedNamespaceName . putProp ( Node.ORIGINALNAME_PROP , legacyNamespace ) ;
binaryNamespaceName . putProp ( Node.ORIGINALNAME_PROP , legacyNamespace ) ;
Node initializer = n . getFirstChild () . detach () ;
Node extern = externs . getFirstChild () . detach () ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
{ testModules ( this , input , STRING_CONSTANT + expected ) ; }
if ( n . isArrayPattern () ) { validateArrayPattern ( Token.CATCH , caught ) ; } else { validateObjectPattern ( Token.CATCH , caught ) ; }
public void testNotStringLiteralConstantArgument3 () { testError ( CLOSURE_DEFS + STRING_CONSTANT , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ; }
public void testNotStringLiteralConstantArgument2 () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ; }
public void testNotStringLiteralConstantArgument1 () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ; }
public void testNotConstantArgument () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ; }
test ( options , source , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ;
shadowedVar != null && shadowedVar . isLocal ()
shadowedVar != null && ! shadowedVar . getScope () . isModuleScope ()
this . redeclarationHandler = new DefaultRedeclarationHandler () ;
ScopeScanner ( AbstractCompiler compiler , Scope scope ) { this ( compiler , SyntacticScopeCreator.DEFAULT_REDECLARATION_HANDLER , scope ) ; }
public Es6SyntacticScopeCreator ( AbstractCompiler compiler , ScopeFactory scopeFactory ) { this ( compiler , SyntacticScopeCreator.DEFAULT_REDECLARATION_HANDLER , scopeFactory ) ; }
{ this . random = random ; reset ( new HashSet < String > () , STRING_CONSTANT , null ) ; }
int count = RandomNameGenerator.FIRST_CHAR.length * ( RandomNameGenerator.NONFIRST_CHAR.length + NUMBER_CONSTANT ) ;
int count = RandomNameGenerator.FIRST_CHAR.length * ( RandomNameGenerator.NONFIRST_CHAR.length + NUMBER_CONSTANT ) ;
var . getParentNode () . isVar () && ! var . getParentNode () . getParent () . isForIn ()
Scope scope = new Es6SyntacticScopeCreator ( compiler ) . createScope ( root , null ) ;
this . changeProxy = new AstChangeProxy () ;
NodeTraversal . traverseEs6 ( compiler , root , new RemoveNonDeclarations () ) ;
map . clear () ;
for ( Assign assign : assignsByVar . get ( var ) ) { compiler . reportChangeToEnclosingScope ( assign.assignNode ) ; assign . remove () ; }
if ( externsRoot != null && n == externsRoot ) { externsScope = t . getScope () ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
if ( options.chromePass ) { checks . add ( chromePass ) ; }
options.chromePass = flags.chromePass ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
if ( maybeNormalizeFunctionDeclaration ( n , compiler ) ) { reportCodeChange ( n , STRING_CONSTANT ) ; }
{ if ( n . isFunction () ) { NormalizeStatements . maybeNormalizeFunctionDeclaration ( n , compiler ) ; } }
public void testRenameWithExterns1 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
test ( externs , code , code , null , null ) ;
test ( modules , expected , null , warning ) ;
{ test ( js , js ) ; }
{ test ( modules , expected , null ) ; }
{ assertNotNull ( warning ) ; test ( js , null , null , warning , description ) ; }
{ test ( js , expected , null , null ) ; }
{ testSame ( externs , source , null ) ; assertEquals ( expected , found ) ; found . clear () ; }
testSame ( externs , js , null ) ;
{ testSame ( CompilerTestCase.ACTIVE_X_OBJECT_DEF , STRING_CONSTANT , null ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
testSame ( CompilerTypeTestCase.DEFAULT_EXTERNS , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , null , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , null , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
test ( js , null , VarCheck.VAR_MULTIPLY_DECLARED_ERROR , null , message ) ;
test ( js , null , VarCheck.VAR_MULTIPLY_DECLARED_ERROR , null , message ) ;
{ String externs = STRING_CONSTANT ; String code = STRING_CONSTANT ; testSame ( externs , code , null ) ; }
{ String externs = STRING_CONSTANT ; String code = STRING_CONSTANT ; testSame ( externs , code , null ) ; }
test ( googModule , null , MISSING_MODULE_OR_PROVIDE , null , warning ) ;
public void testNamespaceResetInLocalScope2 () { test ( STRING_CONSTANT , STRING_CONSTANT , null , NAMESPACE_REDEFINED_WARNING ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
public void testNamespaceResetInLocalScope1 () { test ( STRING_CONSTANT , STRING_CONSTANT , null , NAMESPACE_REDEFINED_WARNING ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
public void testNamespaceResetInGlobalScope1 () { test ( STRING_CONSTANT , STRING_CONSTANT , null , NAMESPACE_REDEFINED_WARNING ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
{ setAcceptedLanguage ( lang ) ; test ( code , expected , null , warning ) ; }
{ test ( code , addLibraries ( code , libraries ) , null , warning ) ; }
{ testSame ( externs , STRING_CONSTANT , null ) ; assertEquals ( ImmutableSet . copyOf ( properties ) , getLastCompiler () . getExternProperties () ) ; }
testSame ( STRING_CONSTANT , STRING_CONSTANT , null ) ;
test ( externs , js , ( String ) null , null , ConstCheck.CONST_REASSIGNED_VALUE_ERROR ) ;
test ( externs , js , js , null , null ) ;
{ overrides . put ( STRING_CONSTANT , new Node ( Token.TRUE ) ) ; test ( STRING_CONSTANT , STRING_CONSTANT , null , ProcessDefines.UNKNOWN_DEFINE_WARNING ) ; }
{ overrides . put ( STRING_CONSTANT , new Node ( Token.TRUE ) ) ; test ( STRING_CONSTANT , STRING_CONSTANT , null , ProcessDefines.UNKNOWN_DEFINE_WARNING ) ; }
testSame ( OBJECT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , null ) ;
testSame ( OBJECT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT , null ) ;
test . test ( inputs , null , error ) ;
{ currentLocationAbstractionIdentifier = locationAbstractionIdentifier ; testSame ( SHARED_EXTERNS , js , null ) ; currentJsRoot = getLastCompiler () . jsRoot ; return currentAnalysis ; }
test ( js , js , null , MISSING_PROVIDE_WARNING , warning ) ;
test ( js , js , null , MISSING_PROVIDE_WARNING , warning ) ;
test ( js , js , null , MISSING_PROVIDE_WARNING , warning ) ;
testSame ( ALL_NATIVE_EXTERN_TYPES , STRING_CONSTANT , null ) ;
{ testSame ( kExterns + extraExterns , source , null ) ; assertEquals ( expected , noSideEffectCalls ) ; noSideEffectCalls . clear () ; }
public void testIssue2508576_1 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT , null ) ; }
public void testExternFunction () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT + STRING_CONSTANT , null ) ; }
public void testObjectLitExtern () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT , null ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT , null , Es6TypedToEs6Converter.CANNOT_CONVERT_BOUNDED_GENERICS ) ;
testSame ( externs , STRING_CONSTANT , null ) ;
tester . testSame ( STRING_CONSTANT , STRING_CONSTANT , null ) ;
public void testGlobalAliasWithProperties5 () { testSame ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , null ) ; }
testErrorExterns ( jsdoc + STRING_CONSTANT , null ) ;
public void testProvideInExterns () { allowExternsChanges () ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
{ test ( createModuleStar ( moduleInputs ) , expected , null ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
public void testEnum () { testSame ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , null ) ; }
testSame ( METHOD_DEFS , STRING_CONSTANT , null ) ;
test ( externs , input , expected , null , null ) ;
test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
public void testRenameWithExterns2 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public void testRenameWithExterns1 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
testSame ( externs , js , null ) ;
test ( externs , js , js , null , null ) ;
test ( externs , js , js , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
{ test ( js , null , null , null ) ; assertEquals ( fieldTypes , mapToString ( lastPass . getRenamedTypesForTesting () ) ) ; }
test ( DEFAULT_EXTERNS + externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
public void testSkipNativeFunctionMethod () { String js = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( js , null ) ; }
public void testJSDocDescInExterns () { testWarning ( STRING_CONSTANT , MISPLACED_MSG_ANNOTATION ) ; testSame ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
if ( Es6RewriteModules . isEs6ModuleRoot ( root ) ) { moduleRewriter . processFile ( root , forceRewrite ) ; }
Preconditions . checkState ( exportsNameNode . getString () . equals ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( importNode . getFirstChild () . isDestructuringLhs () ) ;
Preconditions . checkState ( currentScript.defaultExportRhs == null ) ;
Preconditions . checkArgument ( n . isStringKey () ) ;
Preconditions . checkState ( scriptRoot . isScript () ) ;
Preconditions . checkState ( c . isScript () ) ;
public void testES6AliasClassDeclarationWithoutNew () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testES6AliasClassDeclarationWithNew () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
if ( parent . isForIn () ) { return; }
public void testSimpleConstAliasInCode01 () { testSame ( STRING_CONSTANT ) ; }
{ Preconditions . checkState ( error.node . getParent () . isStringKey () ) ; fix . delete ( error.node . getParent () ) ; }
Preconditions . checkState ( regexMatcher . matches () , STRING_CONSTANT , error.description ) ;
Preconditions . checkState ( regexMatcher . matches () , STRING_CONSTANT , error.description ) ;
Preconditions . checkState ( fullNameMatcher . matches () , error.description ) ;
Preconditions . checkState ( name . isName () , name ) ;
mayWarnAboutGlobalThis ( expr , currentScope ) ;
mayWarnAboutGlobalThis ( expr , currentScope ) ;
Object o
public HierarchicalSet ( HierarchicalSet < T > parent ) { this . parent = parent ; }
if ( n . isObjectLit () && n . getParent () . isArrowFunction () ) { return true ; } else { return precedence ( n ) < minPrecedence ; }
{ for ( Var var : computeLiveness ( src ) . getEscapedLocals () ) { assertFalse ( var.name . equals ( name ) ) ; } }
public void visitCallSite ( NodeTraversal t , Node callNode , FunctionState fs ) ;
{ throw new IllegalStateException ( STRING_CONSTANT + child ) ; }
throw new IllegalStateException ( STRING_CONSTANT + parent . getFirstChild () ) ;
Map < String , Node > map = new HashMap <> () ;
ScopeCreator creator = new MemoizedScopeCreator ( SyntacticScopeCreator . makeUntyped ( compiler ) ) ;
ScopeCreator creator = new MemoizedScopeCreator ( SyntacticScopeCreator . makeUntyped ( compiler ) ) ;
{ Preconditions . checkState ( expected == null ) ; expected = expected ( ( ( Sources ) part ) . sources ) ; }
protected Sources srcs ( List < SourceFile > files ) { return new Sources ( files ) ; }
protected Sources srcs ( String [] srcTexts ) { return new Sources ( createSources ( STRING_CONSTANT , srcTexts ) ) ; }
protected Sources srcs ( String srcText ) { return new Sources ( maybeCreateSources ( filename , srcText ) ) ; }
{ testSame ( modules , null ) ; }
{ test ( modules , expected ( expected ) , null ) ; }
{ test ( createModuleStar ( moduleInputs ) , expected ( expected ) , null ) ; }
builder . setTypeRegistry ( this . typeRegistry ) ;
validateChildCount ( n , NUMBER_CONSTANT ) ;
@ Override protected FeatureSet featureSet () { return ES7 ; }
public Es6RewriteModules ( Compiler compiler ) { this . compiler = compiler ; }
@ Override protected FeatureSet featureSet () { return ES6 ; }
testModules ( STRING_CONSTANT , Es6RewriteModules.NAMESPACE_IMPORT_CANNOT_USE_STAR ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ;
TypeI getElementsType ( ) ;
{ return STRING_CONSTANT + type . toMaybeObjectType () . getElementsType () . toNonNullAnnotationString () + STRING_CONSTANT ; }
@ Override public TypeI getElementsType () { return null ; }
if ( forAnnotations ) { return sb . append ( this . primitiveType ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
Preconditions . checkState ( sum > NUMBER_CONSTANT ) ;
Preconditions . checkState ( s instanceof TypedScope , STRING_CONSTANT ) ;
Preconditions . checkState ( curNode != null ) ;
Preconditions . checkNotNull ( parent ) ;
Preconditions . checkState ( s . isGlobal () || s . isModuleScope () ) ;
type = Name.Type.CLASS ;
{ super . setUp () ; compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6_TYPED ) ; compilerOptions . setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
if ( current . isDeclared ( oldName , false ) ) { return; } else { current = current . getParent () ; }
if ( ! functionScope . isDeclared ( name , false ) ) { return; }
{ return n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ! jsScope . isDeclared ( ARGUMENT_ARRAY_ALIAS , false ) ; }
if ( ! jsScope . isDeclared ( name , false ) ) { return; }
{ this . warningsGuard = new ComposeWarningsGuard ( new SuppressDocWarningsGuard ( getDiagnosticGroups () . getRegisteredGroups () ) , warningsGuard ) ; }
ScopeScanner ( AbstractCompiler compiler , Scope scope ) { this ( compiler , DEFAULT_REDECLARATION_HANDLER , scope ) ; }
new ScopeScanner ( compiler , redeclarationHandler , scope ) . populate () ;
vars . remove ( var.name ) ;
Es6SyntacticScopeCreator createInternalScopeCreator ( AbstractCompiler compiler ) { return new Es6SyntacticScopeCreator ( compiler , new PersistentScopeFactory () ) ; }
NodeUtil . isEnhancedFor ( n )
{ logger . warning ( STRING_CONSTANT + scopeRoot ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () ) ; }
{ return new J2clClinitPrunerPass ( compiler ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels () ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true ) ; }
Preconditions . checkArgument ( nameNode . isQualifiedName () ) ;
Preconditions . checkArgument ( functionNode . isFunction () ) ;
Preconditions . checkArgument ( nameNode . isQualifiedName () ) ;
Preconditions . checkState ( NodeUtil . isStatement ( statement ) , statement ) ;
Preconditions . checkState ( functionBody . isNormalBlock () ) ;
Preconditions . checkArgument ( paramList . isParamList () ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) { processRequire ( expr ) ; } else { Preconditions . checkState ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) ; }
void markConstructorToProcess ( Node ctorNode ) { Preconditions . checkArgument ( ctorNode . isFunction () ) ; constructorsToProcess . add ( ctorNode ) ; }
index < funType . getMaxArguments ()
int getMaxArguments ( ) ;
int getMinArguments ( ) ;
{ if ( currentType . getMaxArguments () <= expectedType . getMaxArguments () ) { return expectedType ; } }
{ this ( res , new Number ( op1 ) , o , op2 ) ; }
{ this ( res , op1 , o , new Number ( op2 ) ) ; }
Preconditions . checkNotNull ( typeParameters ) ;
{ Preconditions . checkState ( this . nominalType == null ) ; this . nominalType = t ; return this ; }
{ Preconditions . checkState ( returnType == null ) ; returnType = t ; return this ; }
{ Preconditions . checkState ( restFormals == null ) ; restFormals = t ; return this ; }
Preconditions . checkArgument ( ! t . isBottom () ) ;
public FunctionTypeBuilder ( JSTypes commonTypes ) { this . commonTypes = Preconditions . checkNotNull ( commonTypes ) ; }
Preconditions . checkState ( noCycles ) ;
{ Preconditions . checkState ( parentClass . isInterface () ) ; warnings . add ( JSError . make ( funNode , CONFLICTING_EXTENDED_TYPE , STRING_CONSTANT , functionName ) ) ; }
Preconditions . checkState ( thisRoot . getToken () == Token.BANG ) ;
Preconditions . checkArgument ( params != null || jsdoc != null ) ;
Preconditions . checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
Preconditions . checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
Preconditions . checkState ( e != null , STRING_CONSTANT + STRING_CONSTANT ) ;
Preconditions . checkState ( td != null , STRING_CONSTANT + STRING_CONSTANT ) ;
Preconditions . checkNotNull ( n ) ;
Preconditions . checkNotNull ( commonTypes ) ;
{ Preconditions . checkState ( isInterface () ) ; isStructuralInterface = flag ; }
Preconditions . checkArgument ( isConstructor () || isInterface () ) ;
Preconditions . checkNotNull ( that ) ;
Preconditions . checkArgument ( interfaceType . isInterface () ) ;
Preconditions . checkState ( scriptRoot . isScript () ) ;
{ Preconditions . checkState ( n . getParent () . getFirstChild () == n ) ; return n . getParent () . cloneTree () . getFirstChild () ; }
Preconditions . checkState ( parent . isCall () ) ;
Preconditions . checkState ( parent . isObjectLit () ) ;
{ Preconditions . checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ; this . compiler = compiler ; }
Preconditions . checkState ( child . hasOneChild () ) ;
{ Preconditions . checkState ( n . isName () , n ) ; n . removeFirstChild () ; }
Preconditions . checkState ( ! typeMap . isEmpty () ) ;
public JSType getRestFormalsType () { Preconditions . checkState ( restFormals != null ) ; return restFormals ; }
Preconditions . checkNotNull ( inputId ) ;
Preconditions . checkArgument ( n . isDo () ) ;
Preconditions . checkArgument ( n . isVanillaFor () ) ;
Preconditions . checkArgument ( n . isWhile () ) ;
{ Preconditions . checkState ( isExprConditional ( n ) ) ; return n . getFirstFirstChild () ; }
{ Preconditions . checkState ( isSimpleAssignment ( n ) ) ; return n . getFirstChild () . getLastChild () ; }
Preconditions . checkState ( isSimpleAssignment ( n ) ) ;
Preconditions . checkState ( n . isSwitch () , n ) ;
Preconditions . checkState ( subtree . isAssign () ) ;
Preconditions . checkState ( n . isTry () , n ) ;
Preconditions . checkNotNull ( paramType , STRING_CONSTANT ) ;
Preconditions . checkState ( n . isAssign () ) ;
Preconditions . checkNotNull ( name ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( callOrNew . isCall () || callOrNew . isNew () ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkArgument ( qName != null && ownerName != null ) ;
Preconditions . checkArgument ( ! variableName . isEmpty () ) ;
{ Preconditions . checkNotNull ( inputId ) ; sourceName = NodeUtil . getSourceName ( n ) ; }
Preconditions . checkState ( cycleCount != maxIterations , NON_HALTING_ERROR_MSG ) ;
Preconditions . checkState ( defParent . isExprResult () ) ;
Preconditions . checkArgument ( use . isName () ) ;
Preconditions . checkState ( t . getScopeRoot () . isFunction () ) ;
Preconditions . checkState ( options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED ) ;
{ Preconditions . checkArgument ( ! callbacks . isEmpty () ) ; return new CombinedCompilerPass ( compiler , callbacks ) ; }
if ( checks . contains ( closureGoogScopeAliases ) ) { Preconditions . checkState ( checks . contains ( checkVariableReferences ) , STRING_CONSTANT ) ; }
if ( pass1Index != - NUMBER_CONSTANT && pass2Index != - NUMBER_CONSTANT ) { Preconditions . checkState ( pass1Index < pass2Index , msg ) ; }
{ for ( PassFactory pass : passes ) { Preconditions . checkState ( ! pass . isOneTimePass () ) ; } }
{ for ( PassFactory pass : passes ) { Preconditions . checkState ( pass . isOneTimePass () ) ; } }
Preconditions . checkState ( behaviorObjLit . isObjectLit () ) ;
Preconditions . checkState ( behaviorObjLit . isObjectLit () ) ;
Preconditions . checkArgument ( objectType . isUnknownType () ) ;
Preconditions . checkNotNull ( errorRoot ) ;
Preconditions . checkArgument ( scriptNodeCount == NUMBER_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ;
Preconditions . checkState ( moduleNode . isModuleBody () ) ;
Preconditions . checkArgument ( parent . isModuleBody () , parent ) ;
Preconditions . checkArgument ( parent . isModuleBody () , parent ) ;
{ Preconditions . checkArgument ( isEs6ModuleRoot ( root ) , root ) ; clearState () ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
Preconditions . checkArgument ( scriptNode . isScript () ) ;
Preconditions . checkState ( objLit . isObjectLit () ) ;
Preconditions . checkState ( objLit . isObjectLit () ) ;
Preconditions . checkState ( DEFAULT_EXTERNS . length () != externs . length () ) ;
Preconditions . checkArgument ( n . isCall () ) ;
Preconditions . checkArgument ( subtree . isCall () ) ;
Preconditions . checkArgument ( subtree . isCall () ) ;
{ Preconditions . checkNotNull ( original ) ; return original != this . node || this . isChanged () ; }
{ Preconditions . checkState ( this . isNot () ) ; return ( normalizeChildren ( node , children ) [ NUMBER_CONSTANT ] ) . change () ; }
Preconditions . checkNotNull ( n . getParent () ) ;
Preconditions . checkState ( n . getParent () != null ) ;
{ Preconditions . checkNotNull ( edgeAnnotationStack , STRING_CONSTANT ) ; popAnnotations ( edgeAnnotationStack ) ; }
{ Preconditions . checkNotNull ( nodeAnnotationStack , STRING_CONSTANT ) ; popAnnotations ( nodeAnnotationStack ) ; }
{ Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
Preconditions . checkNotNull ( name ) ;
Preconditions . checkArgument ( n . isFunction () ) ;
Preconditions . checkArgument ( NodeUtil . isCallOrNew ( call ) , STRING_CONSTANT ) ;
Preconditions . checkArgument ( function . isFunction () , STRING_CONSTANT ) ;
Preconditions . checkState ( value . getParent () == null ) ;
Preconditions . checkState ( DefinitionUseSiteFinder . isCallOrNewSite ( site ) ) ;
Preconditions . checkState ( compiler . getLifeCycleStage () == LifeCycleStage.NORMALIZED ) ;
{ Preconditions . checkState ( isVarBlock ( n ) ) ; return n . getFirstChild () ; }
{ Preconditions . checkState ( isReturnExpressBlock ( n ) ) ; return n . getFirstFirstChild () ; }
{ Preconditions . checkState ( isFoldableExpressBlock ( n ) ) ; return n . getFirstChild () ; }
Preconditions . checkArgument ( n . isNot () ) ;
Preconditions . checkState ( fnNode . isFunction () || type . isFunctionType () ) ;
Preconditions . checkNotNull ( registry ) ;
{ Preconditions . checkArgument ( ! ( scope instanceof TypedScope ) ) ; return new Arguments ( scope ) ; }
Preconditions . checkNotNull ( lValue ) ;
{ Preconditions . checkState ( parent == scope . getParent () ) ; }
Preconditions . checkState ( currentInfo != null ) ;
{ super ( source ) ; Preconditions . checkNotNull ( source ) ; this . excerpt = excerpt ; }
Preconditions . checkState ( newExpr . isNew () ) ;
Preconditions . checkState ( newExpr . isNew () ) ;
Preconditions . checkArgument ( fnNode . isFunction () ) ;
Preconditions . checkArgument ( unsafe != null ) ;
{ Preconditions . checkState ( ! NodeUtil . isFunctionObjectApply ( callNode ) ) ; argMap . put ( THIS_MARKER , NodeUtil . newUndefinedNode ( callNode ) ) ; }
Preconditions . checkNotNull ( thisType ) ;
Preconditions . checkState ( namespace . hasExternsRoot () ) ;
{ Preconditions . checkArgument ( namespace . hasExternsRoot () ) ; this . namespace = namespace ; return this ; }
Preconditions . checkState ( TokenStream . isJSIdentifier ( tempVarName ) ) ;
Preconditions . checkNotNull ( sourceString ) ;
Preconditions . checkState ( ! member . isStaticMember () ) ;
Preconditions . checkNotNull ( constructor ) ;
{ Preconditions . checkState ( hasProcessBeenRun , STRING_CONSTANT ) ; return definitionNodeByDefinitionSite . values () ; }
Preconditions . checkNotNull ( site ) ;
Preconditions . checkState ( ! hasProcessBeenRun , STRING_CONSTANT ) ;
{ Preconditions . checkState ( grandparent . isLabel () ) ; throw new IllegalStateException ( STRING_CONSTANT ) ; }
Preconditions . checkState ( functionBody . getParent () . isFunction () ) ;
Preconditions . checkArgument ( n . isLabel () ) ;
Preconditions . checkState ( n . isFunction () , n ) ;
Preconditions . checkState ( t . getScope () . isFunctionBlockScope () ) ;
{ Preconditions . checkState ( this . knownConstants . isEmpty () ) ; this . knownConstants = knownConstants ; }
{ Preconditions . checkState ( ! NodeUtil . isFunctionObjectApply ( callNode ) ) ; }
Preconditions . checkArgument ( callSiteType != CallSiteType.UNSUPPORTED ) ;
if ( type == DecompositionType.DECOMPOSABLE ) { return CallSiteType.DECOMPOSABLE_EXPRESSION ; } else { Preconditions . checkState ( type == DecompositionType.UNDECOMPOSABLE ) ; }
Preconditions . checkState ( this != callSiteType ) ;
Preconditions . checkState ( this != callSiteType ) ;
Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
Preconditions . checkState ( fnRecursionName != null ) ;
Preconditions . checkArgument ( ! Iterables . isEmpty ( options ) , STRING_CONSTANT ) ;
{ Preconditions . checkNotNull ( realSource ) ; this . realSource = realSource ; this . reportParseErrors = reportParseErrors ; }
Preconditions . checkState ( initialization . getGrandparent () . isExprResult () ) ;
Preconditions . checkState ( value != null ) ;
Preconditions . checkState ( NodeUtil . isNameDeclaration ( varNode ) , varNode ) ;
Preconditions . checkArgument ( o instanceof DeferredCheck ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
Preconditions . checkState ( insideQualifiedName ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkArgument ( pname == null || pname . isIdentifier () ) ;
Preconditions . checkNotNull ( type ) ;
{ Preconditions . checkArgument ( ! varName . contains ( STRING_CONSTANT ) ) ; return env . putType ( varName , type ) ; }
{ Preconditions . checkArgument ( ! pname . contains ( STRING_CONSTANT ) ) ; return env . getType ( pname ) ; }
Preconditions . checkArgument ( expr . isNew () || expr . isCall () ) ;
Preconditions . checkArgument ( callNode . isCall () || callNode . isNew () ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkArgument ( thisExpr . isThis () ) ;
Preconditions . checkState ( propAccessNode . isGetProp () || propAccessNode . isGetElem () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( propAccessNode . isGetProp () || propAccessNode . isGetElem () ) ;
Preconditions . checkNotNull ( funType ) ;
Preconditions . checkState ( receiver == null || isFwd ) ;
Preconditions . checkState ( ! formalType . isBottom () ) ;
Preconditions . checkArgument ( call . isCall () ) ;
Preconditions . checkState ( logicalOp == Token.AND ) ;
Preconditions . checkState ( n != null , STRING_CONSTANT ) ;
TypeEnv outEnv = Preconditions . checkNotNull ( getOutEnv ( dn ) ) ;
if ( fnType . getFunType () == null ) { Preconditions . checkState ( fnType . isUnknown () ) ; return this . commonTypes . qmarkFunction () ; }
Preconditions . checkState ( qnameRoot . isName () ) ;
{ Preconditions . checkArgument ( usingNameNode . isName () ) ; return referencesByNameNode . get ( usingNameNode ) ; }
Preconditions . checkArgument ( otherLocation instanceof VisibilityBasedEffectLocation ) ;
Preconditions . checkArgument ( otherLocation instanceof VisibilityBasedEffectLocation ) ;
{ Preconditions . checkArgument ( isStorageNode ( node ) ) ; return NodeUtil . isLValue ( node ) ; }
Preconditions . checkArgument ( isStorageNode ( node ) ) ;
Preconditions . checkArgument ( variableReference . isName () ) ;
{ Preconditions . checkNotNull ( internalScopeCreator ) ; internalScopeCreator . patchGlobalScope ( topScope , scriptRoot ) ; }
Preconditions . checkArgument ( n . isFunction () ) ;
Preconditions . checkState ( variableNode != null ) ;
Preconditions . checkArgument ( n . getChildCount () > NUMBER_CONSTANT ) ;
{ Preconditions . checkNotNull ( isDisposalStack ) ; if ( ! isDisposalStack . isEmpty () ) { return isDisposalStack . peek () ; } return null ; }
{ Preconditions . checkNotNull ( isConstructorStack ) ; if ( ! isDisposalStack . isEmpty () ) { return isConstructorStack . peek () ; } return null ; }
Preconditions . checkArgument ( checkingPolicy != DisposalCheckingPolicy.OFF ) ;
{ Preconditions . checkState ( call . isCall () ) ; call . putBooleanProp ( Node.FREE_CALL , true ) ; return call ; }
{ Preconditions . checkState ( parent . isCall () ) ; compiler . report ( JSError . make ( parent , GOOG_CLASS_DESCRIPTOR_NOT_VALID ) ) ; }
Preconditions . checkNotNull ( reader ) ;
{ Preconditions . checkNotNull ( whitelist ) ; this . whitelist = normalizeWhitelist ( whitelist ) ; }
Preconditions . checkState ( isRegistered () ) ;
boolean isCorrectRegisterFunction ( TweakFunction registerFunction ) { Preconditions . checkNotNull ( registerFunction ) ; return this . registerFunction == registerFunction ; }
Preconditions . checkState ( firstScript . isScript () ) ;
Property nameProp = Preconditions . checkNotNull ( getOrCreateProperty ( n ) ) ;
{ Preconditions . checkArgument ( blockNode . isNormalBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
Preconditions . checkArgument ( assignedAt . isQualifiedName () ) ;
{ Preconditions . checkArgument ( lhs . isQualifiedName () ) ; writes . addLast ( new PropertyWrite ( lhs ) ) ; }
Preconditions . checkState ( this . namespaceType == null ) ;
Preconditions . checkArgument ( parent . isExprResult () ) ;
Preconditions . checkState ( ! NodeUtil . isObjectLitKey ( n ) ) ;
Preconditions . checkState ( expressionRoot != null ) ;
Preconditions . checkNotNull ( qualifiedName ) ;
Preconditions . checkArgument ( lastLink.nextLink == null ) ;
Preconditions . checkState ( parametersList . isParamList () ) ;
Preconditions . checkNotNull ( traversal ) ;
Preconditions . checkNotNull ( traversal ) ;
void setIn ( L in ) { Preconditions . checkNotNull ( in ) ; this . in = in ; }
Preconditions . checkState ( outBefore . size () == state.out . size () ) ;
void setOut ( L out ) { Preconditions . checkNotNull ( out ) ; this . out = out ; }
void setIn ( L in ) { Preconditions . checkNotNull ( in ) ; this . in = in ; }
{ this . compilerOptions = Preconditions . checkNotNull ( compilerOptions ) ; return this ; }
Preconditions . checkState ( fnNode . isFunction () ) ;
Preconditions . checkState ( callNode . isCall () ) ;
{ super ( registry , null , null , isNativeType , constructor . getTemplateTypeMap () ) ; Preconditions . checkNotNull ( constructor ) ; this . constructor = constructor ; }
{ Preconditions . checkState ( parent . isVar () ) ; parent . removeChild ( nameNode ) ; }
{ Preconditions . checkState ( NodeUtil . createsBlockScope ( root ) , scope ) ; symbolStack . push ( new NameContext ( anonymousNode , scope ) ) ; }
Preconditions . checkArgument ( object != null , STRING_CONSTANT ) ;
Preconditions . checkNotNull ( data ) ;
{ Preconditions . checkState ( fileName . equals ( file . getName () ) ) ; sourceFile = file ; }
Preconditions . checkState ( first . isString () ) ;
Preconditions . checkArgument ( nameNode . isName () ) ;
Preconditions . checkArgument ( ancestors.length > NUMBER_CONSTANT ) ;
Preconditions . checkNotNull ( t ) ;
public JSTypeExpression getTypeExprForErrorReporting () { Preconditions . checkState ( state == State.DURING_RESOLUTION ) ; return typeExpr ; }
Preconditions . checkState ( state != State.RESOLVED ) ;
public JSType getType () { Preconditions . checkState ( state == State.RESOLVED ) ; return type ; }
Preconditions . checkNotNull ( typeExpr ) ;
Preconditions . checkState ( compiler . getLifeCycleStage () == LifeCycleStage.NORMALIZED ) ;
Preconditions . checkState ( null == m . put ( type , top ) ) ;
Preconditions . checkState ( exportDefinition . hasInlinableName ( currentScript.exportsToInline . keySet () ) ) ;
Preconditions . checkState ( n . isScript () , n ) ;
Preconditions . checkState ( currentScript.willCreateExportsObject || currentScript.hasCreatedExportObject ) ;
Preconditions . checkArgument ( importNode . getFirstChild () . isDestructuringLhs () , importNode ) ;
Preconditions . checkState ( currentScript.defaultExportRhs == null , currentScript.defaultExportRhs ) ;
Preconditions . checkArgument ( n . isStringKey () , n ) ;
Preconditions . checkState ( scriptRoot . isScript () , scriptRoot ) ;
Preconditions . checkState ( c . isScript () , c ) ;
Preconditions . checkState ( returnNode . isReturn () , returnNode ) ;
{ Preconditions . checkArgument ( containsModule ( legacyNamespace ) ) ; return scriptDescriptionsByGoogModuleNamespace . get ( legacyNamespace ) . declareLegacyNamespace ; }
Preconditions . checkArgument ( NodeUtil . isGet ( n ) ) ;
Preconditions . checkState ( left . isString () ) ;
Preconditions . checkArgument ( n . isGetElem () ) ;
Preconditions . checkArgument ( n . isNew () ) ;
Preconditions . checkArgument ( n . isCall () ) ;
{ Preconditions . checkArgument ( n . isNew () ) ; if ( inForcedStringContext ( n ) ) { return tryFoldInForcedStringContext ( n ) ; } return n ; }
Preconditions . checkArgument ( node . isAdd () ) ;
Preconditions . checkArgument ( n . isAssign () ) ;
Preconditions . checkArgument ( n . isInstanceOf () ) ;
Preconditions . checkState ( n . hasOneChild () , n ) ;
Preconditions . checkArgument ( originalTypeofNode . isTypeOf () ) ;
Preconditions . checkState ( objLit . isObjectLit () ) ;
Preconditions . checkState ( objLit . isObjectLit () ) ;
Preconditions . checkState ( n . isScript () ) ;
Preconditions . checkState ( passName . equals ( logStats.pass ) ) ;
Preconditions . checkArgument ( mode != TracerMode.OFF , STRING_CONSTANT ) ;
Preconditions . checkArgument ( declaration . isName () || declaration . isStringKey () ) ;
{ Preconditions . checkState ( isCallOrNew ( call ) ) ; return getNthSibling ( call . getSecondChild () , index ) ; }
{ Preconditions . checkState ( function . isFunction () ) ; return getNthSibling ( function . getSecondChild () . getFirstChild () , index ) ; }
{ Preconditions . checkArgument ( fnNode . isFunction () ) ; return fnNode . getSecondChild () ; }
{ Preconditions . checkArgument ( n . isNormalBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
{ Preconditions . checkArgument ( n . isTry () ) ; return n . getSecondChild () ; }
{ Preconditions . checkArgument ( n . isTry () ) ; return n . getChildCount () == NUMBER_CONSTANT ; }
Preconditions . checkArgument ( NodeUtil . isObjectDefinePropertiesDefinition ( definePropertiesCall ) ) ;
{ Preconditions . checkState ( isLValue ( n ) ) ; lhsNodes . add ( n ) ; }
{ Preconditions . checkArgument ( function . isFunction () ) ; return isNameReferenced ( function . getLastChild () , STRING_CONSTANT , MATCH_NOT_THIS_BINDING ) ; }
{ Preconditions . checkArgument ( fn . isFunction () , fn ) ; return fn . getLastChild () ; }
Preconditions . checkState ( block . isNormalBlock () ) ;
Preconditions . checkState ( tryNode . isTry () ) ;
Preconditions . checkState ( n . isName () , n ) ;
Preconditions . checkState ( objlit . isObjectLit () ) ;
Preconditions . checkState ( n . isObjectLit () || n . isClassMembers () ) ;
{ Preconditions . checkState ( n . isNew () , n ) ; return n . isOnlyModifiesThisCall () ; }
{ Preconditions . checkState ( n . isCall () , n ) ; return ( n . getSideEffectFlags () & Node.FLAG_LOCAL_RESULTS ) > NUMBER_CONSTANT ; }
Preconditions . checkState ( node . hasTwoChildren () , node ) ;
{ Preconditions . checkArgument ( n . isClass () ) ; return n . getLastChild () ; }
Preconditions . checkState ( n . isFunction () || n . isClass () ) ;
Preconditions . checkState ( n . isFunction () || n . isClass () ) ;
Preconditions . checkArgument ( obj . isObjectLit () ) ;
{ Preconditions . checkState ( this . declaration == null ) ; this . declaration = ref ; }
if ( otherScopeParent == null ) { Preconditions . checkState ( globalScope == null , STRING_CONSTANT ) ; }
Preconditions . checkNotNull ( declNode ) ;
Preconditions . checkState ( fn . isConstructor () || fn . isInterface () ) ;
Preconditions . checkState ( fn . isConstructor () || fn . isInterface () ) ;
Preconditions . checkArgument ( NodeUtil . isVarDeclaration ( node ) ) ;
{ super ( IR . getprop ( IR . objectlit () , name . cloneNode () ) , true ) ; Preconditions . checkArgument ( name . isString () ) ; }
{ super ( inExterns ) ; Preconditions . checkArgument ( node . isAssign () ) ; assignment = node ; }
{ super ( node , inExterns ) ; Preconditions . checkArgument ( NodeUtil . isFunctionExpression ( node ) ) ; }
{ super ( inExterns ) ; Preconditions . checkArgument ( node . isFunction () ) ; function = node ; }
Preconditions . checkNotNull ( lValue ) ;
Preconditions . checkArgument ( destructuringLhs . isDestructuringLhs () ) ;
{ Preconditions . checkState ( lhs . isName () ) ; checkShortName ( t , lhs , callNode . getLastChild () . getString () ) ; }
Preconditions . checkState ( callNode . isCall () ) ;
Preconditions . checkState ( currentModule == null ) ;
Preconditions . checkState ( script . isScript () ) ;
Preconditions . checkState ( newReachable . getAnnotation () != REACHABLE ) ;
Preconditions . checkState ( n . isGetProp () , n ) ;
Preconditions . checkState ( isNamespacePlaceholder ( decl ) ) ;
Preconditions . checkState ( isNamespacePlaceholder ( decl ) ) ;
{ Preconditions . checkState ( newModule == minimumModule , STRING_CONSTANT ) ; }
Preconditions . checkArgument ( explicitNode != node ) ;
Preconditions . checkState ( n . isCall () ) ;
Preconditions . checkNotNull ( providedModule , n ) ;
Preconditions . checkState ( parent . isExprResult () ) ;
Preconditions . checkState ( n . isGetProp () , n ) ;
{ Preconditions . checkNotNull ( dep ) ; Preconditions . checkState ( dep != this , STRING_CONSTANT , this ) ; deps . add ( dep ) ; }
Preconditions . checkState ( inputs . contains ( other ) ) ;
Preconditions . checkState ( matches . size () == NUMBER_CONSTANT , matches ) ;
Preconditions . checkState ( currentStatement . isDo () ) ;
Preconditions . checkNotNull ( compiler ) ;
{ super ( registry , templateTypeMap ) ; setReferencedType ( Preconditions . checkNotNull ( referencedType ) ) ; }
{ Preconditions . checkState ( hasReferenceName () ) ; return getReferenceName () . hashCode () ; }
Preconditions . checkState ( caseBody . isNormalBlock () ) ;
Preconditions . checkState ( first . getString () . isEmpty () ) ;
Preconditions . checkState ( n . isName () , n ) ;
Preconditions . checkNotNull ( inputId ) ;
Preconditions . checkState ( other instanceof NominalType ) ;
{ Preconditions . checkArgument ( pname . isIdentifier () ) ; return this . rawType . getSubtypesWithProperty ( pname . getLeftmostName () ) ; }
{ Preconditions . checkArgument ( pname . isIdentifier () ) ; return this . rawType . isPropDefinedOnSubtype ( pname . getLeftmostName () ) ; }
Preconditions . checkState ( nt1.rawType . equals ( nt2.rawType ) ) ;
Preconditions . checkState ( this . rawType . equals ( other.rawType ) ) ;
Preconditions . checkState ( this . inheritsFromIObjectReflexive () && other . inheritsFromIObjectReflexive () ) ;
Preconditions . checkArgument ( other . isStructuralInterface () ) ;
Preconditions . checkState ( typeMap . size () == NUMBER_CONSTANT ) ;
Preconditions . checkState ( this . rawType . isFrozen () ) ;
{ Preconditions . checkState ( this . rawType . isFrozen () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
Preconditions . checkState ( this . rawType . isFrozen () ) ;
Preconditions . checkState ( isUninstantiatedGenericType () ) ;
Preconditions . checkState ( types . size () == typeParams . size () ) ;
public RawNominalType getRawNominalType () { Preconditions . checkState ( ! this . rawType . isFrozen () ) ; return this . rawType ; }
{ Preconditions . checkState ( n . isFunction () , n ) ; return true ; }
Preconditions . checkNotNull ( value ) ;
if ( invalidatingPropRef ) { Preconditions . checkNotNull ( propName ) ; invalidateProperty ( propName ) ; }
Preconditions . checkArgument ( ! values . isEmpty () ) ;
Preconditions . checkState ( n . isCall () , n ) ;
{ Preconditions . checkState ( child . getParent () == n ) ; normalizeNodeTypes ( child ) ; }
Preconditions . checkNotNull ( reference ) ;
public JSTypeExpression getTypeExprForErrorReporting () { Preconditions . checkState ( this . state == State.DURING_RESOLUTION ) ; return typeExpr ; }
Preconditions . checkState ( this . state != State.RESOLVED ) ;
public JSType getPropType () { Preconditions . checkState ( this . state == State.RESOLVED ) ; return enumPropType ; }
public JSType getEnumeratedType () { Preconditions . checkState ( this . state == State.RESOLVED ) ; return declaredType ; }
Preconditions . checkNotNull ( typeExpr ) ;
Preconditions . checkNotNull ( colorToNodeMap , STRING_CONSTANT ) ;
Preconditions . checkArgument ( propertyName . isString () ) ;
Preconditions . checkArgument ( superSet . isAssign () ) ;
private int getMaskForBitIndex ( int bitIndex ) { Preconditions . checkArgument ( bitIndex >= NUMBER_CONSTANT , STRING_CONSTANT ) ; return NUMBER_CONSTANT < < bitIndex ; }
Preconditions . checkArgument ( node . isGetProp () ) ;
Preconditions . checkNotNull ( preservedNamespaces , STRING_CONSTANT ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkState ( ! isDefined ( qnameNode ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkState ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkState ( s != null ) ;
{ Preconditions . checkArgument ( ! fnName . contains ( STRING_CONSTANT ) ) ; return getScopeHelper ( new QualifiedName ( fnName ) ) != null ; }
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( qnameNode . isQualifiedName () ) ;
{ Preconditions . checkState ( this . isTopLevel () ) ; this . unknownTypeNames = ImmutableSet . copyOf ( names ) ; }
boolean isPrototypeMethod () { Preconditions . checkArgument ( root != null ) ; return NodeUtil . isPrototypeMethod ( root ) ; }
Preconditions . checkNotNull ( declaredType ) ;
Node getBody () { Preconditions . checkArgument ( root . isFunction () ) ; return NodeUtil . getFunctionBody ( root ) ; }
Preconditions . checkNotNull ( commonTypes ) ;
Preconditions . checkNotNull ( clinitName ) ;
Preconditions . checkNotNull ( typei ) ;
Preconditions . checkArgument ( callSite . isCall () || callSite . isNew () ) ;
Preconditions . checkArgument ( callType == Token.CALL || callType == Token.NEW ) ;
Preconditions . checkArgument ( NodeUtil . isNameDeclaration ( node . getParent () ) ) ;
{ Preconditions . checkNotNull ( sideEffectInfo ) ; updateSideEffectsForNode ( sideEffectInfo , traversal , node , enclosingFunction ) ; }
Preconditions . checkNotNull ( functionInfo ) ;
Preconditions . checkNotNull ( cacheCall ) ;
this . compiler = Preconditions . checkNotNull ( compiler ) ;
Preconditions . checkArgument ( userOrderedInputs . containsAll ( rootInputs ) ) ;
Preconditions . checkState ( msgBuilder != null ) ;
Preconditions . checkState ( ! STRING_CONSTANT . equals ( projectId ) ) ;
Preconditions . checkState ( nameNode . isName () ) ;
Preconditions . checkArgument ( n . isAnd () || n . isOr () ) ;
Preconditions . checkNotNull ( replacementFnType ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkNotNull ( resultType ) ;
Preconditions . checkNotNull ( var ) ;
protected boolean isASTNormalized () { Preconditions . checkNotNull ( compiler ) ; return compiler . getLifeCycleStage () . isNormalized () ; }
{ Preconditions . checkNotNull ( compiler ) ; return compiler . areNodesEqualForInlining ( n1 , n2 ) ; }
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( result != null ) ;
Preconditions . checkState ( n . isNew () || n . isCall () ) ;
Preconditions . checkNotNull ( templateType , STRING_CONSTANT ) ;
Preconditions . checkState ( index >= NUMBER_CONSTANT ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkState ( node . isSuper () ) ;
Preconditions . checkArgument ( arrowFunction . isArrowFunction () ) ;
Preconditions . checkArgument ( ! envs . isEmpty () ) ;
{ Preconditions . checkArgument ( ! n . contains ( STRING_CONSTANT ) ) ; return typeMap . get ( n ) ; }
Preconditions . checkState ( typeMap . size () >= SIZE_THRESHOLD ) ;
{ Preconditions . checkState ( root . isRoot () ) ; if ( root . getChangeTime () != NUMBER_CONSTANT ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
if ( n . isScript () ) { Preconditions . checkState ( this . script == null ) ; this . script = n ; }
Preconditions . checkState ( root . isScript () ) ;
Preconditions . checkState ( root . isScript () ) ;
Preconditions . checkState ( script . isScript () ) ;
Preconditions . checkState ( script . isScript () ) ;
Preconditions . checkState ( script . isScript () ) ;
Preconditions . checkState ( script . isScript () ) ;
Preconditions . checkState ( ORDER_CODE_REPLACEMENTS . isOrdered ( replacements ) ) ;
Preconditions . checkState ( ORDER_CODE_REPLACEMENTS . isOrdered ( replacements ) ) ;
Preconditions . checkState ( options.sourceMapDetailLevel != null ) ;
Preconditions . checkState ( n . isNormalBlock () , n ) ;
Preconditions . checkState ( line >= NUMBER_CONSTANT ) ;
Preconditions . checkState ( sourceMapDetailLevel != null ) ;
Preconditions . checkState ( this . namespaceType == null ) ;
{ Preconditions . checkState ( m == null ) ; }
Preconditions . checkState ( line < nextLine || col <= nextCol ) ;
{ Preconditions . checkNotNull ( part , STRING_CONSTANT ) ; parts . add ( part ) ; return this ; }
Preconditions . checkNotNull ( name , STRING_CONSTANT ) ;
Preconditions . checkState ( scope . isFunctionScope () , scope ) ;
Preconditions . checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ;
Preconditions . checkNotNull ( compiler ) ;
Preconditions . checkNotNull ( name ) ;
Preconditions . checkState ( hasProcessBeenRun , STRING_CONSTANT ) ;
if ( doSanityChecks && sourceFile != null ) { Preconditions . checkState ( sourceFile . equals ( n . getSourceFileName () ) ) ; }
Preconditions . checkState ( token == JsDocToken.PIPE ) ;
Preconditions . checkArgument ( token == JsDocToken.LEFT_CURLY ) ;
Preconditions . checkArgument ( token == JsDocToken.LEFT_CURLY ) ;
Preconditions . checkState ( annotation == Annotation.IMPLEMENTS ) ;
Preconditions . checkNotNull ( inputId ) ;
Preconditions . checkNotNull ( inputId ) ;
Preconditions . checkNotNull ( data ) ;
{ super ( symbolName , value ) ; this . exportPath = Preconditions . checkNotNull ( exportPath ) ; }
Preconditions . checkArgument ( fn . isFunction () ) ;
{ Preconditions . checkState ( pathDefinition . isVar () ) ; pathDefinition . setJSDocInfo ( jsdoc ) ; }
{ Preconditions . checkState ( valueToExport . isObjectLit () ) ; initializer = createExternObjectLit ( valueToExport ) ; }
Preconditions . checkState ( node . isName () ) ;
public boolean isLive ( Var v ) { Preconditions . checkNotNull ( v ) ; return liveSet . get ( v.index ) ; }
Preconditions . checkNotNull ( other ) ;
{ Preconditions . checkNotNull ( other ) ; this . liveSet = ( BitSet ) other.liveSet . clone () ; }
Time ( String name ) { Preconditions . checkNotNull ( name ) ; this . name = name ; }
Event ( T value ) { Preconditions . checkNotNull ( value ) ; this . value = value ; }
Preconditions . checkArgument ( newSourceInd < sources . size () ) ;
Preconditions . checkArgument ( token.type == TokenType.STRING ) ;
{ Preconditions . checkState ( config.keepGoing == Config.RunMode.KEEP_GOING ) ; bodyNode = IR . block () ; }
Preconditions . checkArgument ( scriptNode . isScript () ) ;
Preconditions . checkState ( ret . isString () ) ;
Preconditions . checkState ( work . isEmpty () ) ;
Preconditions . checkState ( ! frozen ) ;
{ Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
public ConstParamCheck ( AbstractCompiler compiler ) { this . compiler = Preconditions . checkNotNull ( compiler ) ; }
Preconditions . checkState ( meaning != null ) ;
{ super ( commonTypes ) ; this . objs = Preconditions . checkNotNull ( objs ) ; }
{ super ( commonTypes ) ; this . objs = Preconditions . checkNotNull ( objs ) ; }
@ Override protected ImmutableSet < EnumType > getEnums () { return Preconditions . checkNotNull ( enums ) ; }
@ Override protected ImmutableSet < ObjectType > getObjs () { return Preconditions . checkNotNull ( objs ) ; }
@ Override public final Iterable < TypeI > getParameterTypes () { return Preconditions . checkNotNull ( getFunType () ) . getParameterTypes () ; }
{ Preconditions . checkState ( this . isSingletonObj () ) ; return this . getNominalTypeIfSingletonObj () . isClassy () ; }
Preconditions . checkState ( this . isSingletonObj () ) ;
{ Preconditions . checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getPropertyDefSite ( propertyName ) ; }
{ Preconditions . checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getOwnPropertyDefSite ( propertyName ) ; }
Preconditions . checkState ( this . isSingletonObj () ) ;
Preconditions . checkState ( this . isSingletonObj () ) ;
{ Preconditions . checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getReturnType () ; }
{ Preconditions . checkState ( this . isFunctionType () ) ; return this . getFunTypeIfSingletonObj () . getMinArity () ; }
Preconditions . checkState ( this . isFunctionType () ) ;
{ Preconditions . checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getThisType () ; }
Preconditions . checkState ( this . isFunctionType () ) ;
{ Preconditions . checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getInstanceTypeOfCtor () != null ; }
Preconditions . checkState ( this . isFunctionType () ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
Preconditions . checkState ( ! getObjs () . isEmpty () ) ;
Preconditions . checkArgument ( type != null ) ;
Preconditions . checkNotNull ( arrayType ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
if ( getObjs () . isEmpty () ) { Preconditions . checkState ( ! getEnums () . isEmpty () ) ; return this ; }
Preconditions . checkState ( ! areSubtypes ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkState ( this . isSingletonObj () ) ;
Preconditions . checkState ( ! getObjs () . isEmpty () ) ;
private JSType ( JSTypes commonTypes ) { Preconditions . checkNotNull ( commonTypes ) ; this . commonTypes = commonTypes ; }
Preconditions . checkState ( node . isName () , node ) ;
public boolean isLive ( Var v ) { Preconditions . checkNotNull ( v ) ; return liveSet . get ( v.index ) ; }
Preconditions . checkNotNull ( other ) ;
{ Preconditions . checkNotNull ( other ) ; this . liveSet = ( BitSet ) other.liveSet . clone () ; }
Preconditions . checkNotNull ( keys ) ;
Preconditions . checkNotNull ( namedType ) ;
{ Preconditions . checkNotNull ( name ) ; nonNullableTypeNames . add ( name ) ; }
Preconditions . checkArgument ( source == null || source . isFunction () ) ;
Preconditions . checkState ( source . isFunction () , source ) ;
{ Preconditions . checkState ( namesToTypes . containsKey ( name ) ) ; register ( t , name ) ; }
{ Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) , STRING_CONSTANT ) ; namesToTypes . put ( name , type ) ; }
public TemplateType getObjectIndexKey () { Preconditions . checkNotNull ( iObjectIndexTemplateKey ) ; return this . iObjectIndexTemplateKey ; }
Preconditions . checkState ( NodeUtil . isNameDeclaration ( n ) ) ;
Preconditions . checkArgument ( ! members . isEmpty () , STRING_CONSTANT ) ;
Preconditions . checkArgument ( nt . isGeneric () , nt ) ;
Preconditions . checkArgument ( nameNode . getParent () . isVar () ) ;
Preconditions . checkArgument ( funNode . isFunction () ) ;
Preconditions . checkState ( n . isOr () || n . isAnd () ) ;
Preconditions . checkState ( n . isGetElem () ) ;
return Preconditions . checkNotNull ( funType ) . toFunctionType () ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkState ( declNode . isGetProp () ) ;
Preconditions . checkArgument ( fn . isFunction () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkNotNull ( lendsName ) ;
Preconditions . checkState ( qnameNode . isName () || qnameNode . isGetProp () ) ;
Preconditions . checkState ( qnameNode . isName () || qnameNode . isGetProp () ) ;
Preconditions . checkArgument ( fn . isFunction () ) ;
Preconditions . checkState ( ! fnName . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkState ( qnameNode . isQualifiedName () ) ;
Preconditions . checkState ( qnameNode . isQualifiedName () ) ;
{ if ( maybeAssign . isAssign () ) { maybeAssign . putBooleanProp ( Node.ANALYZED_DURING_GTI , true ) ; } else { Preconditions . checkState ( maybeAssign . isExprResult () ) ; } }
Preconditions . checkState ( ! currentScope . isNamespace ( qname ) ) ;
{ PropertyDef propdef = Preconditions . checkNotNull ( getPropDefFromClass ( superType , pname ) ) ; inheritedPropDefs = ImmutableSet . of ( propdef ) ; }
{ JSType t = castTypes . get ( n ) ; Preconditions . checkNotNull ( t ) ; return t ; }
{ Preconditions . checkState ( renameStrategy == RenameStrategy.MAPPED ) ; return new MappedNameSupplier ( mappings ) ; }
Preconditions . checkNotNull ( refNode ) ;
Preconditions . checkState ( moduleSpecifier . isString () ) ;
{ Preconditions . checkState ( root . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
Preconditions . checkNotNull ( declaration ) ;
Preconditions . checkState ( parent . isClassMembers () ) ;
Preconditions . checkState ( parent . isObjectLit () ) ;
Preconditions . checkState ( obj instanceof AstChange ) ;
{ Preconditions . checkArgument ( value . isInterface () ) ; return new SubtypeCache ( this . m . with ( key , value ) ) ; }
{ Preconditions . checkState ( mayBeExpression ( expr ) ) ; return new Node ( token , expr ) ; }
Preconditions . checkState ( function . isFunction () ) ;
{ Preconditions . checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.SPREAD , expr ) ; }
Preconditions . checkState ( mayBeExpression ( value ) ) ;
{ Preconditions . checkState ( expr . isString () ) ; return new Node ( Token.REGEXP , expr ) ; }
for ( Node expr : exprs ) { Preconditions . checkState ( mayBeExpressionOrEmpty ( expr ) ) ; arraylit . addChildToBack ( expr ) ; }
Preconditions . checkState ( mayBeExpression ( target ) ) ;
for ( Node arg : args ) { Preconditions . checkState ( mayBeExpression ( arg ) ) ; newcall . addChildToBack ( arg ) ; }
for ( Node arg : args ) { Preconditions . checkState ( mayBeExpression ( arg ) , arg ) ; call . addChildToBack ( arg ) ; }
{ Preconditions . checkState ( name . isLabelName () ) ; return new Node ( Token.CONTINUE , name ) ; }
{ Preconditions . checkState ( name . isLabelName () ) ; return new Node ( Token.BREAK , name ) ; }
Preconditions . checkState ( finallyBody . isNormalBlock () ) ;
{ Preconditions . checkState ( ! name . isEmpty () ) ; return Node . newString ( Token.LABEL_NAME , name ) ; }
{ Preconditions . checkState ( body . isNormalBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
{ Preconditions . checkState ( mayBeExpression ( expr ) , expr ) ; return new Node ( Token.EXPR_RESULT , expr ) ; }
{ Preconditions . checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.RETURN , expr ) ; }
for ( Node stmt : stmts ) { Preconditions . checkState ( mayBeStatementNoReturn ( stmt ) ) ; paramList . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { Preconditions . checkState ( mayBeStatementNoReturn ( stmt ) ) ; block . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { Preconditions . checkState ( mayBeStatement ( stmt ) ) ; paramList . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { Preconditions . checkState ( mayBeStatement ( stmt ) ) ; block . addChildToBack ( stmt ) ; }
{ Preconditions . checkState ( mayBeStatement ( stmt ) ) ; Node block = new Node ( Token.BLOCK , stmt ) ; return block ; }
{ Preconditions . checkState ( param . isName () || param . isRest () ) ; paramList . addChildToBack ( param ) ; }
{ Preconditions . checkState ( param . isName () || param . isRest () ) ; return new Node ( Token.PARAM_LIST , param ) ; }
String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName () ) ;
{ Preconditions . checkState ( ! aliasReference . hasChildren () ) ; aliasReference . addChildToFront ( replacement ) ; }
Preconditions . checkState ( subns.namespaceType != null ) ;
Preconditions . checkState ( this . namespaceType == null ) ;
Preconditions . checkState ( this . namespaceType == null ) ;
Preconditions . checkState ( ! prop . isOptional () ) ;
this . defSite = Preconditions . checkNotNull ( defSite ) ;
{ Preconditions . checkState ( templateJs == null , STRING_CONSTANT ) ; this . templateJs = refasterJsTemplate ; }
Preconditions . checkState ( templateJs == null , STRING_CONSTANT ) ;
Preconditions . checkArgument ( ctorType . isConstructor () ) ;
{ Preconditions . checkState ( parent . isFunction () ) ; parent . setJSType ( varType ) ; }
Preconditions . checkState ( n . isGetElem () , n ) ;
Preconditions . checkNotNull ( n ) ;
{ Preconditions . checkState ( nameNode . isQualifiedName () ) ; return nameNode . getLastChild () . getString () . startsWith ( STRING_CONSTANT ) ; }
Preconditions . checkState ( nameNode != null ) ;
Preconditions . checkState ( ! name . isEmpty () ) ;
Preconditions . checkState ( ! current.renameMap . containsKey ( name ) ) ;
Preconditions . checkNotNull ( interfaceType ) ;
Preconditions . checkNotNull ( node ) ;
Preconditions . checkArgument ( ! isIdentifier () ) ;
{ Preconditions . checkArgument ( ! isIdentifier () ) ; return new QualifiedName ( parts . subList ( NUMBER_CONSTANT , parts . size () ) ) ; }
Preconditions . checkArgument ( n . isCast () ) ;
Preconditions . checkState ( first . getParent () == last . getParent () ) ;
{ Preconditions . checkState ( n . getParent () . isGetProp () , n ) ; nodeToRename = n ; }
Preconditions . checkState ( parentNode . isNormalBlock () , STRING_CONSTANT ) ;
Preconditions . checkArgument ( mode != TypeInferenceMode.BOTH ) ;
Preconditions . checkArgument ( getCfg () . hasNode ( useNode ) ) ;
Preconditions . checkArgument ( n . isCall () || n . isNew () ) ;
Preconditions . checkState ( n . isNew () ) ;
Preconditions . checkState ( n . isCall () ) ;
Preconditions . checkState ( n . isCall () , n ) ;
Preconditions . checkArgument ( NodeUtil . isAssociative ( n . getToken () ) ) ;
Preconditions . checkArgument ( node . isGetProp () ) ;
Preconditions . checkState ( block . isNormalBlock () ) ;
Preconditions . checkArgument ( isZipEntry ( zipURL ) ) ;
Preconditions . checkState ( notAlreadyOutstanding ) ;
Preconditions . checkState ( Thread . currentThread () == startThread ) ;
Preconditions . checkArgument ( type instanceof TypeDeclarationNode ) ;
Preconditions . checkArgument ( functionName != null ) ;
Preconditions . checkArgument ( parameterName != null ) ;
Preconditions . checkState ( labeledVariable . isVar () ) ;
int exitCodeValue = Preconditions . checkNotNull ( exitCode ) ;
{ Preconditions . checkNotNull ( entryPoints ) ; this . entryPoints = entryPoints ; return this ; }
{ Preconditions . checkState ( NUMBER_CONSTANT == Iterables . size ( inputs ) ) ; return; }
Preconditions . checkState ( compiler . getOptions () . outputJs == OutputJs.NORMAL ) ;
Preconditions . checkState ( specs != null ) ;
Preconditions . checkState ( zipEntryName . contains ( filename ) ) ;
Preconditions . checkNotNull ( input ) ;
{ this . exitCodeReceiver = Preconditions . checkNotNull ( newExitCodeReceiver ) ; }
Preconditions . checkArgument ( inputsSupplier == null ^ modulesSupplier == null ) ;
Preconditions . checkState ( this . namespaceType == null ) ;
{ NominalType builtinObj = Preconditions . checkNotNull ( this . commonTypes . getObjectType () , STRING_CONSTANT ) ; protoNT = builtinObj ; }
Preconditions . checkState ( ! this . isFrozen ) ;
{ Preconditions . checkState ( ! this . isFrozen ) ; super . addProperty ( pname , defSite , type , isConstant ) ; }
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
if ( isClass () ) { Preconditions . checkState ( this . name . equals ( STRING_CONSTANT ) ) ; return getAllPropsOfClass () ; }
Preconditions . checkState ( isInterface () ) ;
Preconditions . checkState ( isClass () ) ;
Preconditions . checkState ( ancestor . isInterface () ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ancestor . isClass () ) ;
{ Preconditions . checkState ( ! this . isFrozen ) ; this . ctorFn = ctorFn ; }
public boolean isStruct () { Preconditions . checkState ( isFrozen () || isClass () ) ; return this . objectKind . isStruct () ; }
JSType getPrototypeObject () { Preconditions . checkState ( this . isFrozen ) ; return this . protoObject ; }
Preconditions . checkNotNull ( objectKind ) ;
Preconditions . checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
Preconditions . checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
Preconditions . checkNotNull ( var ) ;
Preconditions . checkState ( function . isFunction () ) ;
Preconditions . checkState ( function . isFunction () ) ;
if ( modifyCallSites ) { Preconditions . checkNotNull ( defFinder ) ; callSiteOptimizer = new CallSiteOptimizer ( compiler , defFinder ) ; }
Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
Preconditions . checkNotNull ( ref . getTwin () ) ;
Preconditions . checkState ( isObjKey || isQName ) ;
Preconditions . checkState ( ref.node . getParent () . isExprResult () ) ;
{ Preconditions . checkState ( languageIn != LanguageMode.NO_TRANSPILE ) ; this . languageIn = languageIn ; }
{ Preconditions . checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
Preconditions . checkNotNull ( entryPoints ) ;
{ Preconditions . checkArgument ( funAstSize > NUMBER_CONSTANT ) ; this . maxFunctionSizeAfterInlining = funAstSize ; }
Preconditions . checkState ( value instanceof String ) ;
Preconditions . checkState ( oldName . equals ( p.oldName ) ) ;
Map < String , String > getRenamingMap () { Preconditions . checkNotNull ( renamingMap ) ; return renamingMap ; }
Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
Preconditions . checkArgument ( n . isScript () ) ;
Preconditions . checkState ( ! compiler . hasErrors () ) ;
{ Preconditions . checkArgument ( classNode . isClass () ) ; return classNode . getFirstChild () . isName () && parent . isName () ; }
{ Preconditions . checkArgument ( classByAlias . containsKey ( original ) ) ; classByAlias . put ( alias , classByAlias . get ( original ) ) ; }
Preconditions . checkState ( subclassMember . isAssign () , subclassMember ) ;
Preconditions . checkState ( staticGetProp . isGetProp () ) ;
Preconditions . checkArgument ( o instanceof ObjectType ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
Preconditions . checkArgument ( qname . isIdentifier () ) ;
Preconditions . checkArgument ( qname . isIdentifier () ) ;
{ Preconditions . checkArgument ( qname . isIdentifier () ) ; Property p = getLeftmostProp ( qname ) ; return p != null ; }
{ Preconditions . checkState ( p != null ) ; return p . getType () . getProp ( qname . getAllButLeftmost () ) ; }
Preconditions . checkNotNull ( this . ns ) ;
Preconditions . checkState ( isLoose || other.isLoose ) ;
Preconditions . checkNotNull ( pname ) ;
Preconditions . checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ;
Preconditions . checkNotNull ( resultNominalType ) ;
Preconditions . checkNotNull ( nominalType ) ;
{ return new ObjectType ( commonTypes , commonTypes . getObjectType () , Preconditions . checkNotNull ( commonTypes.BOTTOM_PROPERTY_MAP ) , null , null , false , ObjectKind.UNRESTRICTED ) ; }
Preconditions . checkNotNull ( dNode ) ;
Preconditions . checkNotNull ( dNode ) ;
Preconditions . checkState ( NodeUtil . isStatementBlock ( parent ) ) ;
Preconditions . checkArgument ( ret . isReturn () ) ;
Preconditions . checkArgument ( node . isNormalBlock () ) ;
Preconditions . checkArgument ( o instanceof Property ) ;
Preconditions . checkArgument ( inferredType != null ) ;
Preconditions . checkNotNull ( compiler ) ;
Preconditions . checkState ( isGeneric () ) ;
{ Preconditions . checkState ( isGeneric () ) ; return substituteParametricGenerics ( typeMap ) ; }
{ for ( String typeParam : this . typeParameters ) { Preconditions . checkState ( ! typeMap . containsKey ( typeParam ) ) ; } }
Preconditions . checkState ( this . isLoose () || f2 . isLoose () ) ;
{ Preconditions . checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ; f1 . isSubtypeOfHelper ( f2 , true , subSuperMap , boxedInfo ) ; }
Preconditions . checkArgument ( f1 . isLoose () || f2 . isLoose () ) ;
Preconditions . checkArgument ( ! isTopFunction () ) ;
{ Preconditions . checkState ( ! isTopFunction () ) ; return requiredFormals . size () ; }
{ Preconditions . checkState ( ! isTopFunction () ) ; return outerVarPreconditions . get ( name ) ; }
Preconditions . checkState ( ! isTopFunction () ) ;
public JSType getRestFormalsType () { Preconditions . checkNotNull ( restFormals ) ; return restFormals ; }
Preconditions . checkState ( isUniqueConstructor () ) ;
Preconditions . checkNotNull ( commonTypes ) ;
Preconditions . checkArgument ( call . isCall () ) ;
{ Preconditions . checkState ( script . isScript () ) ; visit ( script ) ; }
{ Preconditions . checkArgument ( groupIndex >= NUMBER_CONSTANT && groupIndex <= NUMBER_CONSTANT ) ; this . groupIndex = groupIndex ; }
{ Integer priority = priorities . get ( n ) ; Preconditions . checkNotNull ( priority ) ; return priority ; }
Preconditions . checkState ( handler . isTry () ) ;
Preconditions . checkState ( cur . getParent () != null , STRING_CONSTANT ) ;
{ Preconditions . checkState ( next . isCase () ) ; createEdge ( node , Branch.ON_FALSE , next ) ; }
{ Preconditions . checkState ( exceptionHandler . peek () == parent ) ; exceptionHandler . pop () ; }
Preconditions . checkArgument ( keyValPairs.length % NUMBER_CONSTANT == NUMBER_CONSTANT ) ;
Preconditions . checkArgument ( objectLit . isObjectLit () ) ;
Preconditions . checkState ( rootNode . isFunction () ) ;
Preconditions . checkNotNull ( prevUsedRenameMap . getNewNameToOriginalNameMap () ) ;
{ Preconditions . checkState ( this . newName == null ) ; this . newName = newName ; }
{ Preconditions . checkState ( this . fn == null ) ; this . fn = fn ; }
Preconditions . checkArgument ( changed != null ) ;
Preconditions . checkState ( functionState . hasExistingFunctionDefinition () ) ;
Preconditions . checkState ( n . isName () , n ) ;
Preconditions . checkState ( name . isName () ) ;
Preconditions . checkState ( NodeUtil . isGet ( child ) ) ;
Preconditions . checkArgument ( fn . isFunction () ) ;
Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
{ Preconditions . checkState ( c . isScript () ) ; hotSwapScript ( c , null ) ; }
{ Preconditions . checkState ( ownerFunction == null || type == null ) ; ownerFunction = type ; }
Preconditions . checkArgument ( before . isExprResult () , STRING_CONSTANT ) ;
Preconditions . checkState ( descriptor . isObjectLit () ) ;
Preconditions . checkArgument ( js.length == NUMBER_CONSTANT , STRING_CONSTANT ) ;
{ JSModule module = input . getModule () ; Preconditions . checkNotNull ( module ) ; entryPointInputsPerModule . put ( module , input ) ; }
Preconditions . checkState ( n . isSwitch () ) ;
Preconditions . checkState ( allCatchNodes . hasOneChild () ) ;
Preconditions . checkState ( n . hasOneChild () , n ) ;
{ Preconditions . checkArgument ( compiler . getLifeCycleStage () . isNormalized () ) ; this . compiler = compiler ; }
public int getArgIndex () { Preconditions . checkState ( this . argIndex >= NUMBER_CONSTANT ) ; return this . argIndex ; }
public JSType getExpectedType () { return Preconditions . checkNotNull ( this . expected ) ; }
public JSType getFoundType () { return Preconditions . checkNotNull ( this . found ) ; }
public String getPropName () { return Preconditions . checkNotNull ( this . propName ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopeNodes , this , false ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler , true ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () , true ) ; }
{ return new J2clClinitPrunerPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true , true ) ; }
EnvTypePair pair = analyzeExprFwd ( prop , recvLvalue.env , indexType . isBottom () ? UNKNOWN : indexType ) ;
builder . put ( typeParam , t . isBottom () ? UNKNOWN : t ) ;
pair = analyzeExprFwd ( index , pair.env , indexType . isBottom () ? UNKNOWN : indexType ) ;
{ builder . addRetType ( actualRetType . isBottom () ? TOP : actualRetType ) ; }
moduleResolutionMode = ModuleLoader.ResolutionMode.LEGACY ;
public void testEs6ThisWithImportModule () { testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , Es6CheckModule.ES6_MODULE_REFERENCES_THIS ) ; }
String result = STRING_CONSTANT + STRING_CONSTANT ;
String result = STRING_CONSTANT ;
if ( forAnnotations ) { return sb . append ( getReferenceName () ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler , true ) ; }
{ @ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler , true ) ; } }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new UnreachableCodeElimination ( compiler , removeNoOpStatements ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () ) ; }
{ return new J2clClinitPrunerPass ( compiler ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels () ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true ) ; }
Node objectLit = n . getFirstChild () . getFirstChild () . getFirstChild () ;
return new ParseResult ( root , comments , features , p . getInlineSourceMap () ) ;
{ this ( config , errorReporter , source , offset , false , true ) ; }
@ Override MustDef createEntryLattice () { return new MustDef ( jsScope . getVarIterable () ) ; }
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , registry , builder ) ; }
{ if ( interf . inheritsFromIObjectReflexive () ) { result . add ( interf . instantiateGenerics ( typeMap ) ) ; } }
for ( NominalType interf : this . rawType . getInterfaces () ) { result . add ( interf . instantiateGenerics ( typeMap ) ) ; }
return this . rawType . getSuperClass () . instantiateGenerics ( typeMap ) ;
return JSType . fromObjectType ( ObjectType . fromNominalType ( tmp . instantiateGenerics ( typeMap ) ) ) ;
return nominal == null ? null : nominal . instantiateGenerics ( this . commonTypes . MAP_TO_UNKNOWN ) . getInstanceAsJSType () ;
! isInvalidatingType ( dest )
! props . containsKey ( propName ) && ! isInvalidatingType ( type ) && NodeUtil . isImmutableValue ( value ) && NodeUtil . isExecutedExactlyOnce ( value )
{ fn = fn == null ? null : fn . withLoose () ; props = joinPropsLoosely ( commonTypes , obj1.props , obj2.props ) ; }
{ props = joinPropsLoosely ( commonTypes , obj1.props , obj2.props ) ; }
if ( doSlicing ) { pair.env = envPutType ( pair.env , name , declType != null ? declType : UNKNOWN ) ; }
preciseType = declType == null ? requiredType : declType ;
{ JSType result = ft . getSuperPrototype () ; pair.type = result != null ? result : UNDEFINED ; return pair ; }
{ JSType tmp = t . getIndexedType () ; return tmp == null ? UNKNOWN : tmp ; }
declRetType = declRetType == null ? UNKNOWN : declRetType ;
throw new IllegalStateException ( STRING_CONSTANT ) ;
{ return new InstrumentFunctions ( compiler , functionNames , options.instrumentationTemplate , options.appNameStr ) ; }
{ variableMap = runVariableRenaming ( compiler , prevVariableMap , externs , root ) ; }
propertyMap = rprop . getPropertyMap () ;
anonymousFunctionNameMap = naf . getFunctionMap () ;
{ return new CrossModuleMethodMotion ( compiler , crossModuleIdGenerator , options.removeUnusedPrototypePropertiesInExterns , options.crossModuleCodeMotionNoStubMethods ) ; }
stringMap = pass . getStringMap () ;
idGeneratorMap = pass . getSerializedIdMappings () ;
functionNames = pass . getFunctionNames () ;
cssNames = newCssNames ;
{ return new CrossModuleMethodMotion ( compiler , new CrossModuleMethodMotion.IdGenerator () , canMoveExterns , noStubs ) ; }
public static Matcher googModuleOrProvide () { return anyOf ( functionCall ( STRING_CONSTANT ) , functionCall ( STRING_CONSTANT ) ) ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveGoogProvidesAndRequires || this . shouldGenerateTypedExterns () ; }
preserveGoogProvidesAndRequires = false ;
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
parse ( STRING_CONSTANT ) ;
skipStringLiteralEscapeSequence () ;
private boolean skipStringLiteralChar () { if ( peek ( CHAR_CONS ) ) { return skipStringLiteralEscapeSequence () ; } nextChar () ; return true ; }
objType == null || types . contains ( objType ) || objType . isUnknownObject () || objType . isUnknownType () || objType . isBottom ()
return objType . isUnknownObject () || ( ft != null && ft . isConstructor () && isInvalidatingType ( ft . getInstanceType () ) ) ;
return isUnknown () || ( isUnknownObject () && isLoose () ) || ( ft != null && ft . isTopFunction () ) ;
JSType type
JSType type
JSType type
boolean mustReplaceThisAndArguments () { return thisAndArgumentsContext . isAsyncContext () ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
checkArgument ( expr . isCall () ) ;
checkArgument ( n . isFunction () || ( n . isName () && NodeUtil . isCallOrNewTarget ( n ) ) ) ;
return analyzeCallNodeArgsFwdWhenError ( call , inEnv ) ;
parent . getParent () . isCall () && NodeUtil . isCallOrNewTarget ( parent )
{ checkArgument ( ! pname . contains ( STRING_CONSTANT ) ) ; return env . getType ( pname ) ; }
for ( FunctionTypeI impl : constructor . getSubTypes () ) { list . add ( impl . getInstanceType () ) ; }
if ( constructor != null ) { for ( FunctionTypeI subType : constructor . getSubTypes () ) { addRelatedInstance ( subType , related ) ; } }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives || this . shouldGenerateTypedExterns () ; }
preserveClosurePrimitives = false ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.TEMPLATE_ARGUMENT_MISMATCH , NewTypeInference.WRONG_ARGUMENT_COUNT ) ;
testSame ( TEST_EXTERNS + externs , STRING_CONSTANT , GlobalTypeInfo.REDECLARED_PROPERTY ) ;
testSame ( TEST_EXTERNS + externs , STRING_CONSTANT , GlobalTypeInfo.REDECLARED_PROPERTY ) ;
symbolTable = compilerState.symbolTable ;
this . symbolTable = compiler.symbolTable ;
return getSymbolTable () . getImplicitInterfaceUses () ;
return getSymbolTable () . getMismatches () ;
symbolTable = null ;
@ Override protected CompilerPass create ( final AbstractCompiler compiler ) { return compiler . getSymbolTable () ; }
passes . add ( makePassFactory ( STRING_CONSTANT , compiler . getSymbolTable () ) ) ;
this . symbolTable = ( GlobalTypeInfo ) compiler . getSymbolTable () ;
testSame ( DEFAULT_EXTERNS , STRING_CONSTANT , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ;
test ( options , STRING_CONSTANT , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ;
typeCheck ( js , GlobalTypeInfo.CTOR_IN_DIFFERENT_SCOPE , NewTypeInference.MISTYPED_ASSIGN_RHS ) ;
typeCheck ( js , GlobalTypeInfo.ANONYMOUS_NOMINAL_TYPE , GlobalTypeInfo.ANONYMOUS_NOMINAL_TYPE , NewTypeInference.MISTYPED_ASSIGN_RHS ) ;
typeCheck ( STRING_CONSTANT , GlobalTypeInfo.INEXISTENT_PARAM ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfo.WRONG_PARAMETER_COUNT ) ;
public void testUnknownTypeReferenceDoesntCrash () { typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ; }
typeCheck ( STRING_CONSTANT , GlobalTypeInfo.INEXISTENT_PARAM ) ;
public void testVarDecls () { typeCheck ( STRING_CONSTANT , GlobalTypeInfo.ONE_TYPE_FOR_MANY_VARS ) ; typeCheck ( STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; typeCheck ( STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; }
typeCheck ( STRING_CONSTANT , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ;
typeCheck ( STRING_CONSTANT , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ;
ignoreWarnings ( GlobalTypeInfo.INTERFACE_METHOD_NOT_IMPLEMENTED , TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfo.INVALID_PROP_OVERRIDE ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) ) ;
parseWarning ( STRING_CONSTANT , TRAILING_COMMA_MESSAGE ) ;
parseWarning ( STRING_CONSTANT , TRAILING_COMMA_MESSAGE ) ;
parseWarning ( js , warning , warning ) ;
Node ast
features = features . union ( factory . getFeatures () ) ;
ImmutableMap . < Pattern , DiagnosticType > builder () . put ( Pattern . compile ( STRING_CONSTANT ) , TRAILING_COMMA )
{ features = features . union ( FeatureSet.TYPESCRIPT ) ; return nextToken () . type ; }
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) , getRequiresEs6Message ( Feature.ARRAY_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) , getRequiresEs6Message ( Feature.ARRAY_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.TRAILING_COMMA ) ) ;
parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.TRAILING_COMMA ) ) ;
parseWarning ( js , warning ) ;
@ Nullable Node ast
features = factory . getFeatures () ;
ImmutableMap . < Pattern , DiagnosticType > builder () . put ( Pattern . compile ( STRING_CONSTANT + STRING_CONSTANT ) , TRAILING_COMMA )
{ features = features . with ( Feature.ACCESSIBILITY_MODIFIER ) ; return nextToken () . type ; }
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new CheckRequiresForConstructors ( compiler , CheckRequiresForConstructors.Mode.FULL_COMPILE ) ; }
new CheckRequiresForConstructors ( compiler , CheckRequiresForConstructors.Mode.SINGLE_FILE )
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckRequiresForConstructors ( compiler , CheckRequiresForConstructors.Mode.FULL_COMPILE ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new CheckRequiresForConstructors ( compiler , CheckRequiresForConstructors.Mode.SINGLE_FILE ) ; }
public void testFailGoogArray () { mode = CheckRequiresForConstructors.Mode.SINGLE_FILE ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testFailConstant () { mode = CheckRequiresForConstructors.Mode.SINGLE_FILE ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckRequiresForConstructors ( compiler , mode ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; mode = CheckRequiresForConstructors.Mode.FULL_COMPILE ; }
if ( current . isDeclaredSloppy ( oldName , false ) ) { return; } else { current = current . getParent () ; }
if ( ! functionBlockScope . isDeclaredSloppy ( name , false ) ) { return; }
{ return n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ! jsScope . isDeclaredSloppy ( ARGUMENT_ARRAY_ALIAS , false ) ; }
if ( ! jsScope . isDeclaredSloppy ( name , false ) ) { return; }
n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ( ! jsScope . isDeclaredSloppy ( ARGUMENT_ARRAY_ALIAS , false ) || ! childDeclared )
assertTrue ( fBlockScope . isDeclaredSloppy ( STRING_CONSTANT , false ) ) ;
assertTrue ( fBlockScope . isDeclaredSloppy ( STRING_CONSTANT , false ) ) ;
assertTrue ( fBlockScope . isDeclaredSloppy ( STRING_CONSTANT , false ) ) ;
public static Matcher googModuleOrProvide () { return anyOf ( functionCall ( STRING_CONSTANT ) , functionCall ( STRING_CONSTANT ) ) ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveGoogProvidesAndRequires || this . shouldGenerateTypedExterns () ; }
preserveGoogProvidesAndRequires = false ;
maybeProcessAccessibilityModifier ( member , tree.access ) ;
maybeProcessAccessibilityModifier ( n , tree.access ) ;
maybeProcessAccessibilityModifier ( member , functionTree.access ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; }
{ env = analyzeExprBwd ( prop . getFirstChild () , env , enumeratedType ) . env ; }
EnvTypePair pair = analyzeExprBwd ( prop . getFirstChild () , env , reqPtype ) ;
EnvTypePair pair = analyzeExprFwd ( prop . getFirstChild () , env , enumeratedType ) ;
EnvTypePair pair = analyzeExprFwd ( prop . getFirstChild () , env , reqPtype , specPtype ) ;
PropertyDef propdef = checkNotNull ( getPropDefFromClass ( superType , pname ) ) ;
return state . getOut () . mayUseMap . get ( jsScope . getVar ( name ) ) ;
return state . getIn () . reachingDef . get ( jsScope . getVar ( name ) ) ;
Var dep = jsScope . getVar ( n . getString () ) ;
@ Override MustDef createEntryLattice () { return new MustDef ( returnAllVars () ) ; }
Iterable < ? extends Var > vars
{ Pattern pattern = new Pattern () ; pattern.regExp = RegExp . compile ( string ) ; return pattern ; }
node = new Node <> ( e ) ;
Map < Node < E > , ImmutableSet.Builder < E > > groupsTmp = new HashMap <> () ;
E e
@ Override public void add ( E e ) { union ( e , e ) ; }
{ for ( E elem : other . elements () ) { union ( elem , other . find ( elem ) ) ; } }
public void testUnusedLocalConst_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUnusedEs6 ( STRING_CONSTANT ) ; }
public void testUnusedLocalConst () { enableUnusedLocalAssignmentCheck = true ; assertUnusedEs6 ( STRING_CONSTANT ) ; }
public void testUnusedLocalLet_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUnusedEs6 ( STRING_CONSTANT ) ; }
{ enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; assertUnusedEs6 ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
assertUnusedEs6 ( STRING_CONSTANT ) ;
public void testDefaultParam_withES6Modules () { assertEarlyReferenceError ( STRING_CONSTANT ) ; assertNoWarningEs6 ( STRING_CONSTANT ) ; }
public void testES6Module_destructuring () { enableUnusedLocalAssignmentCheck = true ; assertNoWarningEs6 ( STRING_CONSTANT ) ; }
public void testUnusedCompoundAssign_withES6Modules () { assertNoWarningEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testUsedInShorthandObjLit_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUndeclaredEs6 ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
assertUndeclaredEs6 ( STRING_CONSTANT ) ;
public void testForOf () { assertEarlyReferenceError ( STRING_CONSTANT ) ; assertNoWarningEs6 ( STRING_CONSTANT ) ; }
public void testRedeclare_withES6Modules () { assertRedeclare ( STRING_CONSTANT ) ; assertNoWarningEs6 ( STRING_CONSTANT ) ; }
assertNoWarningEs6 ( STRING_CONSTANT ) ;
parent . isVar ()
Pattern includeFilePattern
{ overrideDefines ( collectDefines ( root ) ) ; }
new ProcessDefines ( compiler , ImmutableMap . copyOf ( replacements ) ) . injectNamespace ( namespaceForChecks ) . process ( externs , jsRoot ) ;
Set < String > defines = new ProcessDefines ( compiler , null ) . collectDefines ( root ) . keySet () ;
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.ES3 ; }
EnumSet . of ( TokenType.IDENTIFIER , TokenType.TYPE , TokenType.DECLARE , TokenType.MODULE , TokenType.NAMESPACE ) . contains ( type )
! peekId () && ! EnumSet . of ( TokenType.VOID , TokenType.OPEN_PAREN , TokenType.OPEN_CURLY , TokenType.TYPEOF ) . contains ( peekType () )
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
Function < String , Void > recordPropertyName
recordPropertyName ( getProp . getLastChild () . getString () , getProp ) ;
recordPropertyName ( pname , qnameNode ) ;
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.ES3 ; }
new ProcessDefines ( compiler , ImmutableMap . copyOf ( replacements ) , options.checksOnly ) . injectNamespace ( namespaceForChecks ) . process ( externs , jsRoot ) ;
new ProcessDefines ( compiler , overrides , false ) . injectNamespace ( namespace ) . process ( externs , js ) ;
Set < String > defines = new ProcessDefines ( compiler , null , false ) . collectDefines ( externs , root ) . keySet () ;
( n . isName () ) && isDeclaration ( n )
public boolean isAsyncFunction () { return getBooleanProp ( ASYNC_FN ) ; }
public boolean isArrowFunction () { return getBooleanProp ( ARROW_FN ) ; }
if ( key . isEmpty () ) { continue; }
isInvalidatingType ( recvType ) || isStructuralInterfacePrototype ( recv )
{ if ( isInvalidatingType ( type ) ) { invalidate () ; return false ; } rootTypesByNode . put ( node , type ) ; }
if ( isInvalidatingType ( top ) ) { invalidate () ; return; }
new PolymerPass ( compiler ) . process ( externs , root ) ;
PolymerClassDefinition def = parseAndExtractClassDef ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDef ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDef ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDef ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerPassStaticUtils . extractProperties ( behaviorValue , compiler )
List < MemberDefinition > properties = PolymerPassStaticUtils . extractProperties ( behaviorValue , compiler ) ;
new PolymerPass ( compiler ) . process ( externsRoot , mainRoot ) ;
rhs . matchesQualifiedName ( ABSTRACT_METHOD_NAME ) || ( GlobalTypeInfo . isCtorDefinedByCall ( lhs ) && ! isFunctionBind ( rhs . getFirstChild () , inEnv , true ) )
( GlobalTypeInfo . isCtorDefinedByCall ( nameNode ) && ! isFunctionBind ( rhs . getFirstChild () , inEnv , true ) )
Property p = this . rawType . getProp ( pname ) ;
Property p = this . rawType . getOwnProp ( pname ) ;
if ( maybeWin != null ) { return maybeWin . getProp ( pname ) ; }
( ns . hasProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , propDeclType , previousPropType ) )
GlobalTypeInfo . isCtorDefinedByCall ( getProp )
classType . hasCtorProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , propDeclType , previousPropType )
GlobalTypeInfo . isCtorDefinedByCall ( nameNode )
Property p = getProp ( pname ) ;
Property p = getPropFromClass ( pname ) ;
return this . nominalType . getProp ( pname ) ;
if ( nom != null ) { return nom . getProp ( pname ) ; }
{ return new PeepholeOptimizationsPass ( compiler , new ExploitAssigns () ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return createPeepholeOptimizationsPass ( compiler ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return createPeepholeOptimizationsPass ( compiler ) ; }
{ return new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , new ExploitAssigns () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , new PeepholeCollectPropertyAssignments () ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeSubstituteAlternateSyntax ( late ) ) ;
final CompilerPass simplifier = new PeepholeOptimizationsPass ( compiler , new PeepholeSimplifyRegExp () ) ;
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () ) ;
{ return new PeepholeOptimizationsPass ( compiler , new ReorderConstantExpression () ) ; }
{ PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new StatementFusion ( favorsCommas ) ) ; return peepholePass ; }
computeEscaped ( jsScope , jsScopeChild , escaped , compiler , scopeCreator ) ;
computeEscaped ( jsScope . getParent () , jsScope , escaped , compiler , scopeCreator ) ;
computeEscaped ( jsScope . getParent () , jsScope , escaped , compiler , scopeCreator ) ;
if ( isObjLit ) { declareVarsForObjLitValues ( n , alias , rvalue , varNode , varNode . getPrevious () , varParent ) ; }
super ( inExterns ) ;
super ( isExtern ) ;
{ super ( inExterns ) ; checkArgument ( node . isAssign () ) ; assignment = node ; }
{ super ( inExterns ) ; Preconditions . checkArgument ( node . isClass () ) ; c = node ; }
{ super ( inExterns ) ; checkArgument ( node . isFunction () ) ; function = node ; }
super ( inExterns ) ;
Property p = this . rawType . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
if ( maybeWin != null ) { return maybeWin . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ; }
superType . isInterface () && current . isClass () && ! isCtorDefinedByCall ( current ) && ! current . mayHaveProp ( pname )
superClass . isAbstractClass () && superClass . hasAbstractMethod ( pname ) && ! rawType . isAbstractClass () && ! rawType . mayHaveOwnProp ( pname )
@ Override public boolean apply ( Node n ) { return isFunctionDeclaration ( n ) || n . isVar () ; }
parent . isVar ()
n . getParent () . isVar ()
NodeUtil . isVarOrSimpleAssignLhs ( n , parent )
if ( NodeUtil . isVarOrSimpleAssignLhs ( n , parent ) ) { if ( referring != null ) { recordReference ( referringName , name , RefType.REGULAR ) ; } return; }
{ if ( NodeUtil . isVarOrSimpleAssignLhs ( parent , grandparent ) ) { validProperties . add ( propName ) ; } else { return false ; } }
NodeUtil . isVarOrSimpleAssignLhs ( n , n . getParent () )
! NodeUtil . isVarOrSimpleAssignLhs ( callNode , parent )
if ( NodeUtil . isVarOrSimpleAssignLhs ( n , parent ) ) { return; }
dest . isString () && NodeUtil . isExprAssign ( grandParent ) && NodeUtil . isVarOrSimpleAssignLhs ( n , parent )
{ if ( nextParent == null || ! NodeUtil . isVarOrSimpleAssignLhs ( nextNode , nextParent ) ) { readsState = true ; } }
! NodeUtil . isVarOrSimpleAssignLhs ( name , name . getParent () )
public void testEs6EnhancedObjLiteralsPropertyShorthand () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; }
public void testES6ClassComputedProperty () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
int propType
int propType
int propType
public void putBooleanProp ( int propType , boolean value ) { putIntProp ( propType , value ? NUMBER_CONSTANT : NUMBER_CONSTANT ) ; }
int propType
int propType
int propType
public boolean getBooleanProp ( int propType ) { return getIntProp ( propType ) != NUMBER_CONSTANT ; }
int propType
int propType
int propType
int propType
int propType
int propType
@ Override public int getType () { return propType ; }
int propType
int propType
final int prop
Set < Var > escaped
Set < N > entrySet = new HashSet <> () ;
Set < N > nodes = new HashSet <> () ;
String lValueName = NodeUtil . getBestLValueName ( NodeUtil . getBestLValue ( rValue ) ) ;
isStatementBlock ( parent ) || isSwitchCase ( node )
assertThat ( computeEscapedLocals ( STRING_CONSTANT ) ) . isEmpty () ;
validateChildCount ( n ) ;
{ validateChildCount ( n ) ; validateExpression ( n . getFirstChild () ) ; validateExpression ( n . getLastChild () ) ; }
private void validateUnaryOp ( Node n ) { validateChildCount ( n ) ; validateExpression ( n . getFirstChild () ) ; }
new ReorderConstantExpression ()
{ if ( parent . isParamList () ) { return true ; } else if ( parent . isVar () ) { return n . hasChildren () ; } }
List < Scope > allScopes = liveness . getScopeStack () ;
assertThat ( statements . get ( NUMBER_CONSTANT ) . isMovableDeclaration () ) . isTrue () ;
{ if ( parent . isParamList () ) { return true ; } else if ( NodeUtil . isNameDeclaration ( parent ) ) { return n . hasChildren () ; } }
QualifiedName setterPname = new QualifiedName ( JSType . createSetterPropName ( pname . getLeftmostName () ) ) ;
QualifiedName getterPname = new QualifiedName ( JSType . createGetterPropName ( pname ) ) ;
thisProps = ! thisNt . isBuiltinObject () && thisNt . isStructuralInterface () ? thisNt . getAllPropsOfInterface () : this . props . keySet ()
{ otherPropNames = otherNt . getAllPropsOfInterface () ; if ( otherPropNames == null ) { return false ; } }
scopeRoots . push ( node ) ;
{ validateChildCount ( n ) ; validateAssignmentTarget ( n . getFirstChild () ) ; validateExpression ( n . getLastChild () ) ; }
{ validateAssignmentTarget ( n ) ; }
public void testInvalidAnnotation5 ( ) throws Exception { testWarning ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
public void testInvalidAnnotation4 ( ) throws Exception { testWarning ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
if ( ! t . getScope () . isHoistScope () ) { return; }
{ if ( t . getScope () . isHoistScope () ) { pop ( blockStack ) ; } }
if ( t . getScope () . isHoistScope () ) { blockStack . add ( new BasicBlock ( parent , n ) ) ; }
if ( t . getScope () . isHoistScope () ) { pop ( blockStack ) ; }
if ( t . getScope () . isHoistScope () ) { blockStack . add ( new BasicBlock ( parent , n ) ) ; }
Node hoistRoot = t . getClosestHoistScope () . getRootNode () ;
{ if ( n . isVar () && t . getScope () != t . getClosestHoistScope () ) { hoistVarIfNeeded ( t , n , parent ) ; } }
if ( scopeType == ScopeType.EXEC_CONTEXT ) { return t . getClosestHoistScope () . getRootNode () == currentScript.rootNode ; } else { return n . getParent () == currentScript.rootNode ; }
Node scopeRoot = t . getClosestHoistScope () . getRootNode () ;
if ( ! n . hasChildren () ) { rewriteEs6ObjectLiteralShorthandPropertySyntax ( n , compiler ) ; reportCodeChange ( n , STRING_CONSTANT ) ; }
if ( n . isYieldFor () ) { checkNotNull ( first ) ; add ( STRING_CONSTANT ) ; }
yield . setYieldFor ( tree.isYieldFor ) ;
if ( isGlobal () || isModuleScope () ) { throw new IllegalStateException ( STRING_CONSTANT + this ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new ClosureOptimizePrimitives ( compiler , propertyRenamingEnabled ) ; }
{ enableTypeCheck () ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
DiagnosticType warning
{ super . setUp () ; disableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
enableTypeCheck () ;
testWarning ( STRING_CONSTANT , RhinoErrorReporter.TOO_MANY_TEMPLATE_PARAMS ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , RhinoErrorReporter.TOO_MANY_TEMPLATE_PARAMS ) ; }
{ if ( parent . isParamList () ) { return true ; } else if ( parent . isVar () ) { return n . hasChildren () ; } }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ;
if ( hasParamWithNumberObjectLit ( fnNode ) ) { functionState . setInline ( false ) ; }
if ( NodeUtil . tryMergeBlock ( n ) ) { reportCodeChange () ; return null ; }
NodeUtil . tryMergeBlock ( moduleBody ) ;
NodeUtil . tryMergeBlock ( callbackBlock ) ;
NodeUtil . tryMergeBlock ( scopeClosureBlock ) ;
if ( newChild . isNormalBlock () ) { NodeUtil . tryMergeBlock ( newChild ) ; }
NodeUtil . tryMergeBlock ( moduleBody ) ;
Exception cause
catch ( Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
Exception unexpectedException
abstract void throwInternalError ( String msg , Exception cause ) ;
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isGeneric () ? nt . getRawNominalTypeAfterTypeChecking () . getInstanceAsJSType () : null ; }
if ( ! init . isEmpty () && ! init . isVar () ) { init = trySimplifyUnusedResult ( init , false ) ; }
if ( n . isVar () && n . hasOneChild () && n . getFirstFirstChild () != null ) { return true ; }
{ TemplatizedType t = toMaybeTemplatizedType () ; return t == null ? null : t . getReferencedType () ; }
JSType declRetType = this . currentScope . getDeclaredFunctionType () . getReturnType () ;
JSType declRetType = this . currentScope . getDeclaredFunctionType () . getReturnType () ;
DeclaredFunctionType dft = this . currentScope . getDeclaredFunctionType () ;
if ( STRING_CONSTANT . equals ( name ) ) { if ( ! hasThis () ) { return null ; } return getDeclaredFunctionType () . getThisType () ; }
return this . registry . evaluateTypeExpression ( expr , typeEnv ) ;
TypeI type = typeEnv . getType ( name ) ;
Node mapFunctionBody = getFunctionBody ( mapFunction ) ;
this . registry = compiler . getTypeRegistry () ;
ImmutableList < String > names
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isGeneric () ? nt . getRawNominalType () . getInstanceAsJSType () : null ; }
return globalScope . getType ( typeName ) ;
ImmutableSet . of ( TokenType.IDENTIFIER , TokenType.TYPE , TokenType.DECLARE , TokenType.MODULE , TokenType.NAMESPACE ) . contains ( type )
! peekId () && ! ImmutableSet . of ( TokenType.VOID , TokenType.OPEN_PAREN , TokenType.OPEN_CURLY , TokenType.TYPEOF ) . contains ( peekType () )
compiler = multistageSerializeAndDeserialize ( compiler , inputs , recentChange ) ;
{ functionBody . removeChild ( current ) ; insertAfter = addToFront ( functionBody , current , insertAfter ) ; reportCodeChange ( functionBody , STRING_CONSTANT ) ; }
reportCodeChange ( n , STRING_CONSTANT ) ;
reportCodeChange ( n , STRING_CONSTANT ) ;
boolean hasUnfilledTemplateKeys () { return numUnfilledTemplateKeys () > NUMBER_CONSTANT ; }
compiler . getOptions () . setStrictModeInput ( false ) ;
Object getObjectValue ( ) ;
compiler . addToDebugLog ( STRING_CONSTANT + defineName ) ;
catch ( RuntimeException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
compiler . addToDebugLog ( STRING_CONSTANT + name + STRING_CONSTANT + newName ) ;
compiler . addToDebugLog ( STRING_CONSTANT + var.name ) ;
t . getCompiler () . addToDebugLog ( STRING_CONSTANT + fn . getName () ) ;
{ return new IntPropListItem ( getType () , intValue , next ) ; }
{ return new ObjectPropListItem ( getType () , objectValue , next ) ; }
public void testRestParam () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
var . setStaticSourceFile ( input . getSourceFile () ) ;
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
assertPassOrder ( checks , chromePass , checkJsDoc , STRING_CONSTANT ) ;
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
ImmutableList < String > typeParameters
ImmutableList < String > typeParameters
public List < String > getTypeParameters () { return typeParameters ; }
builder . addTypeParameters ( nt . getTypeParameters () ) ;
this . typeParameters = ImmutableList . of () ;
ImmutableList < String > typeParameters
public boolean isDeleted () { return getBooleanProp ( DELETED ) ; }
@ Nullable PropListItem getPropListHeadForTesting () { return propListHead ; }
public int getSourcePosition () { return sourcePosition ; }
public int getCharno () { return extractCharno ( sourcePosition ) ; }
public int getLineno () { return extractLineno ( sourcePosition ) ; }
public int getLength () { return this . length ; }
public boolean hasProps () { return propListHead != null ; }
public boolean hasChildren () { return first != null ; }
parent . isVar ()
{ validateExpression ( n . getLastChild () ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; super . enableNormalize () ; }
public void toStringIsEqualTo ( String typeString ) { assertEquals ( actual () . toString () , typeString ) ; }
if ( n . isParamList () ) { requiresTypes = true ; return; }
checks . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
passName . equals ( Compiler.PARSING_PASS_NAME )
checks . add ( createEmptyPass ( PassNames.AFTER_STANDARD_CHECKS ) ) ;
passName . equals ( PassNames.PARSE_INPUTS )
n . getParent () . isVar () && n . isName ()
checkState ( e != null , STRING_CONSTANT + STRING_CONSTANT ) ;
TypeI type = typeEnv . getNamespaceType ( name ) ;
Typedef td = Typedef . make ( jsdoc . getTypedefType () ) ;
options . setPackageJsonEntryNames ( ImmutableList . of ( STRING_CONSTANT , CompilerOptions.PACKAGE_JSON_MAIN ) ) ;
packageJsonEntryNames = ImmutableList . of ( CompilerOptions.PACKAGE_JSON_MAIN ) ;
checks . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
passName . equals ( Compiler.PARSING_PASS_NAME )
{ Node nameNode = n . getFirstChild () ; renamer . addDeclaredName ( nameNode . getString () , true ) ; }
{ ObjectType obj = getObjTypeIfSingletonObj () ; return obj != null && obj . hasOwnProperty ( new QualifiedName ( propertyName ) ) ; }
{ checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getOwnPropertyDefSite ( propertyName ) ; }
classType . mayHaveOwnProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , typeInJsdoc , previousPropType )
if ( this . classProps . containsKey ( pname ) || this . protoProps . containsKey ( pname ) ) { return; }
this . allProps = builder . addAll ( classProps . keySet () ) . addAll ( protoProps . keySet () ) . build () ;
Property p = getOwnProp ( pname , propAccess ) ;
Property p = getOwnProp ( pname , propAccess ) ;
this . externs = makeCompilerInput ( externs , true ) ;
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
{ for ( Var var : scriptToVarMap . get ( script ) ) { super . undeclareInteral ( var ) ; } }
visitForOf ( n , parent ) ;
compiler . ensureLibraryInjected ( STRING_CONSTANT + function . toLowerCase ( Locale.US ) , false ) ;
CompilerInput newInput = ( CompilerInput ) deserialize ( serialize ( input ) ) ;
@ Override public FeatureSet featureSet () { return ES8 ; }
madeChange = true ;
visitForOf ( t , n , parent ) ;
preloadEs6RuntimeFunction ( compiler , function ) ;
@ Override public FeatureSet featureSet () { return ES8_MODULES ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
JSType t = getInstanceType ( typeName ) ;
return this . globalScope . getInstanceType ( typeName ) ;
{ tmpEnv = collectTypesForFreeVarsFwd ( callee , tmpEnv ) ; }
TypeEnv outEnv = collectTypesForFreeVarsFwd ( expr , inEnv ) ;
TypeEnv exitEnv = getInEnv ( this . cfg . getImplicitReturn () ) ;
public void testTypeTransformationNoneType () { inFunction ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; verify ( STRING_CONSTANT , JSTypeNative.NO_TYPE ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
handleGet ( module , scope , n , parent , prefix , Ref.Type.PROTOTYPE_GET ) ;
handleGet ( module , scope , n , parent , name , type ) ;
{ if ( n . isEmpty () && parent . isClassMembers () ) { compiler . reportChangeToEnclosingScope ( n ) ; n . detach () ; } }
NodeTraversal . traverseEs6 ( compiler , root , new RemoveEmptyClassMembers ( compiler ) ) ;
compiler . ensureLibraryInjected ( STRING_CONSTANT + function . toLowerCase ( Locale.US ) , false ) ;
visitForOf ( n , parent ) ;
{ builder . addRetType ( firstNonBottom ( actualRetType , TOP ) ) ; }
for ( ObjectTypeI interfaceType : funType . getAncestorInterfaces () ) { interfaces . add ( interfaceType . toAnnotationString () ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT , record . toAnnotationString () ) ;
assertEquals ( STRING_CONSTANT , record . toAnnotationString () ) ;
if ( ! runOptimizeCalls ) { passes . add ( getRemoveUnusedVars ( STRING_CONSTANT , false ) ) ; }
checks . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
t . reportCodeChange () ;
if ( n . getChildCount () != NUMBER_CONSTANT ) { return false ; }
grandparent . isStringKey () && NodeUtil . isObjectDefinePropertiesDefinition ( grandparent . getParent () . getParent () )
Node statementNode = rhsNode . getParent () . getParent () ;
if ( call . getChildCount () != NUMBER_CONSTANT || ! legacyNamespaceNode . isString () ) { t . report ( legacyNamespaceNode , INVALID_GET_NAMESPACE ) ; return; }
if ( call . getChildCount () != NUMBER_CONSTANT || ! namespaceNode . isString () ) { t . report ( namespaceNode , INVALID_FORWARD_DECLARE_NAMESPACE ) ; return; }
NodeTraversal . traverseEs6 ( compiler , fnName . getParent () . getParent () , uniquifier ) ;
if ( entry . isObjectLit () ) { checkState ( entryName == STRING_CONSTANT ) ; processBrowserFieldAdvancedUsage ( dirName , entry ) ; }
if ( line . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT ) { return line . indexOf ( STRING_CONSTANT ) ; }
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; reportCodeChange () ; return null ; }
{ checkState ( this . setUpRan , STRING_CONSTANT ) ; ignoredWarnings . addAll ( Arrays . asList ( warnings ) ) ; }
{ @ Override public boolean apply ( Node n ) { return name . equals ( n . getQualifiedName () ) ; } }
assertEquals ( null , noInline ) ;
catch ( IllegalStateException e ) { assertEquals ( FixedPointGraphTraversal.NON_HALTING_ERROR_MSG , e . getMessage () ) ; }
Node fNode = root . getFirstChild () . getFirstChild () ;
{ testSame ( kExterns + extraExterns , source ) ; assertEquals ( expected , noSideEffectCalls ) ; noSideEffectCalls . clear () ; }
Node classNode = root . getFirstChild () . getFirstChild () . getFirstChild () ;
Node fNode = root . getFirstChild () . getFirstChild () . getFirstChild () ;
catch ( IllegalArgumentException expected ) { assertTrue ( expected . getMessage () . contains ( STRING_CONSTANT + STRING_CONSTANT ) ) ; }
js = renameFunctionDefinition + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
js = renameFunctionDefinition + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
js = renameFunctionDefinition + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
checkState ( n . isName () || n . isStringKey () , STRING_CONSTANT , n ) ;
public void testImportedNameCollision () { testSame ( STRING_CONSTANT ) ; checkSynthesizedExtern ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override public FeatureSet featureSet () { return ES8_MODULES ; }
{ checkArgument ( n . isTry () ) ; return n . getChildCount () == NUMBER_CONSTANT ; }
{ iterableType = iterable . getTypeI () . toMaybeObjectType () ; typeParam = iterableType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ; }
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; allowExternsChanges () ; enableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node , parent ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node , parent ) ;
newEmptyClinitMethod = true ;
if ( options . getNewTypeInference () && options . getRunOTIafterNTI () ) { addOldTypeCheckerPasses ( checks , options ) ; }
Renamer renamer = nameStack . peek () ;
{ if ( NodeUtil . isFunctionBlock ( t . getScopeRoot () ) ) { return; } if ( ! t . inGlobalScope () ) { nameStack . pop () ; } }
new PureFunctionIdentifier.Driver ( compiler , null ) . process ( externs , root ) ;
new PureFunctionIdentifier.DriverInJ2cl ( compiler , null ) . process ( externs , root ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( returnType != null ) { builder . append ( CHAR_CONS ) ; returnType . appendTo ( builder , ctx ) ; }
if ( options . getNewTypeInference () && options . getRunOTIafterNTI () && ! options.checksOnly ) { addOldTypeCheckerPasses ( checks , options ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
{ super . setUp () ; enableNormalize () ; enableTypeCheck () ; }
lit . setJSType ( exportedObjectLit . getJSType () ) ;
{ super . setUp () ; allowExternsChanges () ; enableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; enableParseTypeInfo () ; }
disableTypeCheck () ;
{ disableTypeCheck () ; assertExternProperties ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
disableTypeCheck () ;
public void tagAsStrict () { add ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { enableTypeCheck () ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties4 () { enableTypeCheck () ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
enableTypeCheck () ;
{ enableTypeCheck () ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty2 () { enableTypeCheck () ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testConstructorProperty1 () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
enableTypeCheck () ;
v != null || isShadowingDisallowed ( name , s )
if ( options.j2clPassMode . shouldAddJ2clPasses () ) { passes . add ( j2clConstantHoisterPass ) ; passes . add ( j2clOptBundlePass ) ; }
boolean shouldPrintExterns () { return this . printExterns ; }
return new TypeSubject ( THROW_ASSERTION_ERROR , actualPropType ) ;
t . inGlobalScope () && isDeclaration ( n ) && ! n . getBooleanProp ( Node.IS_NAMESPACE ) && ! isWhitelisted ( n )
assertFalse ( NodeUtil . isFunctionDeclaration ( getFunctionNode ( STRING_CONSTANT ) ) ) ;
disableTypeCheck () ;
disableTypeCheck () ;
enableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
warning ( TYPE_MISMATCH_WARNING )
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
enableTypeCheck () ;
checkState ( curNode != null ) ;
boolean isFunctionExpression = ( parent != null ) && NodeUtil . isFunctionExpression ( n ) ;
checkState ( s . isGlobal () || s . isModuleScope () ) ;
checkArgument ( child.parent == null , STRING_CONSTANT , child , parent , this ) ;
passes . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
public void testJSDocCopiedForClasses () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectLiteralMethods () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectLiteralShorthand () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDefaultParameter () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition3 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition2 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition1 () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testArrowFunction () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testNonTopLevelDestructuring () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectDescructuringError2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testObjectDescructuringError1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testDestructuringError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testYieldExpression () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testInlineEmptyFunction6 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
NodeTraversal . traverseEs6ScopeRoots ( compiler , null , Lists . newArrayList ( fooFunction , barFunction , bazFunction ) , callback , callback , false ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT ) ;
if ( NodeUtil . isBleedingFunctionName ( n ) ) { renameBleedingFunctionName ( n ) ; }
public void testMakeLocalNamesUniqueWithContext10 () { this . useDefaultRenamer = true ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testMakeLocalNamesUniqueWithContext9 () { this . useDefaultRenamer = true ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ newNode = IR . assign ( getprop , rhs . cloneNode () ) ; }
{ FunctionType getterType = typeRegistry . createFunctionType ( objectType ) ; codingConvention . applySingletonGetterOld ( functionType , getterType , objectType ) ; }
if ( superCtor != null && subCtor != null ) { codingConvention . applySubclassRelationship ( superCtor , subCtor , relationship.type ) ; }
when ( mockCompiler . compile ( FOO_JS , STRING_CONSTANT ) ) . thenReturn ( new BaseTranspiler.CompileResult ( STRING_CONSTANT , NO_ERRORS , false , STRING_CONSTANT ) ) ;
when ( mockCompiler . compile ( FOO_JS , STRING_CONSTANT ) ) . thenReturn ( new BaseTranspiler.CompileResult ( STRING_CONSTANT , NO_ERRORS , true , STRING_CONSTANT ) ) ;
inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ replacement = replacement . useSourceInfoIfMissingFrom ( node ) ; node . replaceWith ( replacement ) ; reportCodeChange () ; }
if ( codeChanged ) { reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
{ maybeBreak . detach () ; reportCodeChange () ; }
reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; reportCodeChange () ; return right ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ Node replacement = measuredNodeReplacement . applyTo ( original ) ; reportCodeChange () ; return replacement ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
this . reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
{ n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
compileFilesError ( SourceFile.DUPLICATE_ZIP_CONTENTS , zipFile1 , zipFile2 ) ;
if ( options.j2clPassMode . equals ( CompilerOptions.J2clPassMode.AUTO ) ) { checks . add ( j2clSourceFileChecker ) ; }
j2clPassMode = J2clPassMode.OFF ;
checkState ( child.parent == this , STRING_CONSTANT , child , parent ) ;
checkState ( child.parent == this ) ;
assertThat ( result.transpiled ) . isFalse () ;
assertThat ( result.transpiled ) . isTrue () ;
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new Transpiler ( mockCompiler , STRING_CONSTANT ) ; compiler = new Transpiler.CompilerSupplier () ; }
Files . asCharSink ( jsFile , Charsets.UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , Charsets.UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , Charsets.UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , Charsets.UTF_8 ) . write ( code ) ;
{ this . def = def ; this . use = use ; }
if ( ! rewriteState . containsModule ( legacyNamespace ) ) { unrecognizedRequires . add ( new UnrecognizedRequire ( call , legacyNamespace , false ) ) ; }
inFunction ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
this . analyzer = new AnalyzePrototypeProperties ( compiler , moduleGraph , canModifyExterns , false ) ;
AnalyzePrototypeProperties analyzer = new AnalyzePrototypeProperties ( compiler , null , canModifyExterns , anchorUnusedVars ) ;
compilationLevelParsed = COMPILATION_LEVEL_MAP . get ( Ascii . toUpperCase ( compilationLevel ) ) ;
if ( cacheEntry.input == null ) { cacheEntry.input = new CompilerInput ( source ) ; }
boolean transformed = ! result.transpiledFiles . isEmpty () ;
@ Override public FeatureSet featureSet () { return ES8 ; }
public void testInlineIntoNestedNonHoistedNamedFunctions () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
jsDoc != null && jsDoc . isConstant () && jsDoc . getType () == null
newNode . useSourceInfoWithoutLengthIfMissingFromForTree ( sourceInfoNode ) ;
expr . useSourceInfoWithoutLengthIfMissingFromForTree ( parent ) ;
checkState ( n . isFunction () || n . isClass () ) ;
boolean shouldAmbiguateProperties () { return this . ambiguateProperties ; }
boolean shouldDisambiguateProperties () { return this . disambiguateProperties ; }
boolean shouldInlineProperties () { return inlineProperties ; }
{ return new Es6RewriteClass ( compiler ) ; }
decl . maybeRemoveRhs ( compiler ) ;
n . isForIn ()
public void testFor () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.NULLABLE_DEREFERENCE ) ;
typeCheck ( CLOSURE_DEFS + STRING_CONSTANT ) ;
typeCheck ( CLOSURE_BASE + STRING_CONSTANT ) ;
List < Node > replacements
if ( ! isPrettyPrint () || this == registry . getNativeType ( JSTypeNative.FUNCTION_INSTANCE_TYPE ) ) { return sb . append ( STRING_CONSTANT ) ; }
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
if ( hasReferenceName () ) { return sb . append ( getReferenceName () ) ; }
{ checkArgument ( qnameNode . isQualifiedName () ) ; declarations . add ( PotentialDeclaration . from ( qnameNode , scope ) ) ; }
boolean isImport = rhs != null && isImportRhs ( rhs ) ;
this . mode = TypeInferenceMode.OTI_ONLY ;
public void testInherits6 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testInherits4 () { testSame ( STRING_CONSTANT ) ; }
public void testInherits3 () { testSame ( STRING_CONSTANT ) ; }
public void testInherits2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
! callClassType . isBottom () && ! callClassType . isUnknownType ()
public void testLoggerOnObject3b () { this . mode = TypeInferenceMode.OTI_ONLY ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
! sanityCheck
if ( devMode ) { runSanityCheck () ; if ( hasErrors () ) { return null ; } }
maybeSanityCheck () ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new SanityCheck ( compiler ) ; }
if ( options.devMode == DevMode.EVERY_PASS ) { phaseOptimizer . setSanityCheck ( sanityCheck ) ; }
if ( options.devMode == DevMode.START_AND_END ) { runSanityCheck () ; }
if ( doSanityChecks && sourceFile != null ) { checkState ( sourceFile . equals ( n . getSourceFileName () ) ) ; }
{ declarationCheck = ! sanityCheck ; disableCompareAsTree () ; testExternChanges ( extern , input , expectedExtern ) ; }
sanityCheck = true ;
public void testViolatedModuleDependencyNonStrictNotPromoted () { sanityCheck = true ; strictModuleDepErrorLevel = CheckLevel.ERROR ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testMissingModuleDependencySkipNonStrictNotPromoted () { sanityCheck = true ; strictModuleDepErrorLevel = CheckLevel.ERROR ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public void testViolatedModuleDependencySkipNonStrict () { sanityCheck = true ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testMissingModuleDependencySkipNonStrict () { sanityCheck = true ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
sanityCheck = false ;
@ Override public ObjectBuilder prototype () { return prototype ; }
@ Override public ObjectBuilder instance () { return instance ; }
@ Override public ObjectBuilder constructor () { return constructor ; }
convention . applySingletonGetter ( new NominalTypeBuilderNti ( lateProps , rawType ) , getInstanceType ) ;
new FunctionTypeBuilder ( getCommonTypes () ) . addReqFormal ( getCommonTypes () . getNativeType ( U2U_CONSTRUCTOR_TYPE ) )
testSame ( STRING_CONSTANT ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ reportBadGoogBaseUse ( t , n , STRING_CONSTANT ) ; }
{ compiler . report ( JSError . make ( node , INVALID_SUPER_CALL ) ) ; }
if ( initializer != null ) { inferredType = simpleInferExprType ( initializer ) ; }
return bindComponents.thisValue == null ? null : simpleInferExprType ( bindComponents.thisValue ) ;
currentScope . isConstructor ()
JSType rhsType = simpleInferExprType ( rhs ) ;
JSType newPropType = rhs == null ? null : simpleInferExprType ( rhs ) ;
JSType recvType = simpleInferExprType ( recv ) ;
JSType t = initializer == null ? null : simpleInferExprType ( initializer ) ;
if ( initializer != null ) { inferredType = simpleInferExprType ( initializer ) ; }
JSType t = simpleInferExprType ( prop . getFirstChild () ) ;
checkState ( n . isName () , n ) ;
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this , true ) ; cjs . process ( null , root ) ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT , } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
String requireName = require . getSecondChild () . getString () ;
{ this ( compiler , true ) ; }
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this ) ; cjs . process ( null , root ) ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
String requireName = ProcessCommonJSModules . getCommonJsImportPath ( require ) ;
{ this . compiler = compiler ; }
if ( STRING_CONSTANT . equals ( type . getDisplayName () ) ) { return true ; }
case REMOVE_RHS :
void markProvided ( String providedName ) { providedNamespaces . add ( providedName ) ; }
void markNameProcessed ( String fullyQualifiedName ) { seenNames . add ( fullyQualifiedName ) ; }
{ return new ObjectLiteralPropertyDefinition ( parent , n , n . getFirstChild () , isExtern ) ; }
List < Var > orderedVars = new LinkedList <> () ;
List < Var > orderedVars = new LinkedList <> () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; }
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this , true ) ; cjs . process ( null , root ) ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT , } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
String requireName = require . getSecondChild () . getString () ;
{ this ( compiler , true ) ; }
public void testDontPreserveUnknownTypeDeclarations () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
if ( isUnknown () ) { return this ; }
typeCheck ( LINE_JOINER . join ( FORWARD_DECLARATION_DEFINITIONS , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testWarning ( STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
checkArgument ( nameNode . isQualifiedName () ) ;
options . needsTranspilationFrom ( FeatureSet.ES6_MODULES ) || options.transformAMDToCJSModules || options.processCommonJSModules
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
caseMatches = PeepholeFoldConstants . evaluateComparison ( Token.SHEQ , cond , caseLabel , false ) ;
new PeepholeMinimizeConditions ( late , useTypesForOptimization )
optimizations . add ( new PeepholeMinimizeConditions ( late , useTypesForOptimization ) ) ;
new PeepholeMinimizeConditions ( late , false )
new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false ) , new PeepholeFoldConstants ( true , false ) )
TernaryValue result = evaluateComparison ( n . getToken () , left , right , shouldUseTypes ) ;
Double rightValObj = NodeUtil . getNumberValue ( right , shouldUseTypes ) ;
Double result = NodeUtil . getNumberValue ( n , shouldUseTypes ) ;
new PeepholeMinimizeConditions ( late , false )
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeMinimizeConditions ( late , useTypes ) ) ;
Node n = parseError ( STRING_CONSTANT , STRING_CONSTANT ) ;
replacement . setJSType ( call . getJSType () ) ;
{ checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ; f1 . isSubtypeOfHelper ( f2 , true , subSuperMap , boxedInfo ) ; }
{ return isSubtypeOfHelper ( other , true , subSuperMap , null ) ; }
{ return isSubtypeOfHelper ( other , false , SubtypeCache . create () , null ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false , false ) ; }
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
void process ( Node externs , Node root , DefinitionUseSiteFinder definitions ) ;
public void testCallOrApply ( ) throws Exception { testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = newlineJoin ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; disableCompareAsTree () ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false ) ; }
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
void process ( Node externs , Node root , ReferenceMap references ) ;
public void testCallOrApply ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
options . setEmitUseStrict ( emitUseStrict ) ;
passes = new LinkedList <> () ;
passes = new LinkedList <> () ;
{ passes = new LinkedList <> () ; addInlineVariables () ; addPeephole () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
passes = new LinkedList <> () ;
passes = new LinkedList <> () ;
passes = new LinkedList <> () ;
{ passes = new LinkedList <> () ; addDeadCodeElimination () ; addInlineVariables () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
passes = new LinkedList <> () ;
{ passes = new LinkedList <> () ; addInlineVariables () ; addPeephole () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ messages = new LinkedList <> () ; mode = JsMessage.Style.LEGACY ; compilerOptions = null ; renameMessages = false ; }
return getTopObject () . getNominalTypeIfSingletonObj () . getPrototypePropertyOfCtor () ;
JSType proto = getNominalTypeIfSingletonObj () . getPrototypePropertyOfCtor () ;
return superClass == null ? null : superClass . getPrototypePropertyOfCtor () ;
checkState ( n . isCall () , n ) ;
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalArgumentException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
ref.scope . isGlobal ()
ref.scope . getClosestHoistScope () . isGlobal ()
Result result = compiler . compile ( EXTERNS , inputs , options ) ;
try { compiler . compile ( EXTERNS , inputs , options ) ; } catch ( RuntimeException e ) { fail ( STRING_CONSTANT ) ; }
Result result = compiler . compile ( EXTERNS , inputs , options ) ;
Result result = compiler . compile ( EXTERNS , inputs , options ) ;
if ( type . contains ( STRING_CONSTANT ) ) { type = type . substring ( NUMBER_CONSTANT , type . lastIndexOf ( STRING_CONSTANT ) ) ; } else { return; }
String shortName = parent . getQualifiedName () . substring ( parent . getQualifiedName () . lastIndexOf ( STRING_CONSTANT ) + NUMBER_CONSTANT ) ;
suffixes . add ( polyfillName . substring ( polyfillName . lastIndexOf ( STRING_CONSTANT ) + NUMBER_CONSTANT ) ) ;
{ return STRING_CONSTANT + cls.target . getQualifiedName () . replaceAll ( STRING_CONSTANT , STRING_CONSTANT ) + STRING_CONSTANT ; }
Map < Node < E > , ImmutableSet.Builder < E > > groupsTmp = Maps . newLinkedHashMap () ;
Map < String , Integer > map = Maps . newHashMap () ;
NodeUtil . getLhsNodesOfDeclaration ( n )
NodeUtil . getLhsNodesOfDeclaration ( n )
{ for ( Node lhs : NodeUtil . getLhsNodesOfDeclaration ( n ) ) { declareVar ( s , lhs ) ; } }
names = NodeUtil . getLhsNodesOfDeclaration ( c ) ;
NodeUtil . getLhsNodesOfDeclaration ( decl )
NodeUtil . getLhsNodesOfDeclaration ( varNode )
NodeUtil . getLhsNodesOfDeclaration ( declaration )
Preconditions . checkNotNull ( sideEffectInfo , STRING_CONSTANT , function ) ;
if ( NodeUtil . getLhsNodesOfDeclaration ( nameDecl ) . size () > NUMBER_CONSTANT ) { continue; }
Iterable < Node > allVars = NodeUtil . getLhsNodesOfDeclaration ( n ) ;
NodeUtil . getLhsNodesOfDeclaration ( paramList )
ref.scope . isGlobal ()
public void failing_testLocalAliasWithLet3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void failing_testLocalAliasWithLet2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageIn = LanguageMode.ECMASCRIPT3 ;
List < Node > arrayFoldedChildren = new LinkedList <> () ;
List < Var > orderedVars = new LinkedList <> () ;
Deque < ScriptDescription > scriptDescriptions = new LinkedList <> () ;
List < Var > orderedVars = new LinkedList <> () ;
this . orderedVars = new LinkedList <> () ;
this . orderedVars = new LinkedList <> () ;
this . orderedVars = new LinkedList <> () ;
List < Node > newVars = new LinkedList <> () ;
languageIn = LanguageMode.ECMASCRIPT_2017 ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false , false ) ; }
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
void process ( Node externs , Node root , DefinitionUseSiteFinder definitions ) ;
public void testCallOrApply ( ) throws Exception { testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = newlineJoin ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
languageIn = LanguageMode.ECMASCRIPT3 ;
public void testConst () { inFunction ( STRING_CONSTANT ) ; }
languageIn = LanguageMode.ECMASCRIPT_2017 ;
varify () ;
varify () ;
Node varName
checkLocalityOfMarkedCalls ( source , ImmutableList . < String > of () ) ;
checkLocalityOfMarkedCalls ( source , ImmutableList . < String > of () ) ;
assertFalse ( NodeUtil . evaluatesToLocalValue ( n ) ) ;
languageIn = LanguageMode.ECMASCRIPT3 ;
languageIn = LanguageMode.ECMASCRIPT_2017 ;
return STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + sourceName ;
String fullExportedName = currentScript . getBinaryNamespace () + exportDefinition . getExportPostfix () ;
Node binaryNamespaceName = IR . name ( currentScript . getBinaryNamespace () ) ;
if ( ! currentScript.isModule ) { return; }
if ( ! currentScript.isModule ) { return; }
if ( ! currentScript.isModule ) { return; }
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) ;
checkState ( currentScript.isModule , currentScript ) ;
if ( ! currentScript.isModule || ! n . getString () . equals ( STRING_CONSTANT ) || ! isAssignTarget ( n ) ) { return; }
languageIn = LanguageMode.ECMASCRIPT3 ;
if ( et != null && et . enumLiteralHasKey ( pname ) ) { return et . getEnumeratedType () ; }
{ type = locals . get ( name ) ; }
{ locals . put ( name , newDeclType ) ; }
String fullExportedName = currentScript . getBinaryNamespace () . get () + exportDefinition . getExportPostfix () ;
Node binaryNamespaceName = IR . name ( currentScript . getBinaryNamespace () . get () ) ;
if ( ! currentScript . isModule () ) { return; }
if ( ! currentScript . isModule () ) { return; }
if ( ! currentScript . isModule () ) { return; }
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) . get () ;
checkState ( currentScript . isModule () , currentScript ) ;
if ( ! currentScript . isModule () || ! n . getString () . equals ( STRING_CONSTANT ) || ! isAssignTarget ( n ) ) { return; }
checkState ( n . isName () , n ) ;
finder . visitTree ( getAstRoot ( compiler ) ) ;
{ return STRING_CONSTANT + cls.target . getQualifiedName () . replace ( STRING_CONSTANT , STRING_CONSTANT ) + STRING_CONSTANT ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
statementNode . isVar ()
checkState ( declNode . isGetProp () ) ;
{ getGlobalScope () . addNamespaceLit ( qnameNode ) ; return true ; }
compilerOptions . setPreserveGoogProvidesAndRequires ( true ) ;
compilerOptions . setPreserveGoogProvidesAndRequires ( true ) ;
keyNode . isStringKey () || keyNode . isMemberFunctionDef ()
Node externsRoot = parse ( compiler , STRING_CONSTANT + STRING_CONSTANT ) ;
Node externsRoot = parse ( compiler , STRING_CONSTANT + STRING_CONSTANT ) ;
{ helperExposeExpression ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; helperExposeExpression ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
return this . gti . getCastTypes () . get ( n ) ;
JSType jsdocType = symbolTable . getPropDeclaredType ( prop ) ;
pair.type = symbolTable . getCastType ( expr ) ;
JSType jsdocType = symbolTable . getPropDeclaredType ( prop ) ;
JSType toType = symbolTable . getCastType ( expr ) ;
visitNamespacePropertyDeclaration ( getProp , recv , pname ) ;
JSType propDeclType = getDeclaredObjLitProps () . get ( prop ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ; return options ; }
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ; }
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String body = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ;
String body = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , js ) ;
String fileoverview = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; assertThat ( getLastCompiler () . injected ) . isEmpty () ; }
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ testFunctionNamesAndIds ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } ) ; }
{ testFunctionNamesAndIds ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } ) ; }
{ testFunctionNamesAndIds ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , } ) ; }
assertEarlyReferenceError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEarlyReferenceError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String legacyScript = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Node script = compiler . parseSyntheticCode ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testReference ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , false ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
test ( modules , new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT , STRING_CONSTANT , } ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
foldSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( createModuleChain ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT } )
test ( createModuleStar ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( modules , new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) } ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { STRING_CONSTANT , STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , VarCheck.UNDEFINED_VAR_ERROR ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
{ test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String externs = LINE_JOINER . join ( DEFAULT_EXTERNS , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
String localVar = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSets ( STRING_CONSTANT , js , output , STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
Preconditions . checkState ( isFunctionExpression ( n ) ) ;
return checkForNewObjects || ! isFunctionExpression ( n ) ;
t . inGlobalHoistScope () && ! NodeUtil . isFunctionExpression ( n )
if ( isEs6ModuleRoot ( root ) ) { return true ; }
if ( FindModuleDependencies . isEs6ModuleRoot ( root ) ) { moduleType = ModuleType.ES6 ; }
testModules ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) )
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler ) ; }
if ( NodeUtil . isFunctionExpression ( parent ) ) { break; }
{ FindStaticMembers findStaticMembers = new FindStaticMembers () ; TranspilationPasses . processTranspile ( compiler , scriptRoot , findStaticMembers ) ; processInherits ( findStaticMembers.inheritsCalls ) ; }
processInherits ( findStaticMembers.inheritsCalls ) ;
String src = LINE_JOINER . join ( lines ) ;
String src = LINE_JOINER . join ( lines ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertChangesRecorded ( code , new NameChangingCallback () ) ; }
{ String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertChangesRecorded ( code , new NameChangingCallback () ) ; }
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.NULLABLE_DEREFERENCE ) ;
if ( ! fn . isFromExterns () ) { getScopes () . add ( fnScope ) ; }
node . useSourceInfoWithoutLengthIfMissingFromForTree ( basisNode ) ;
{ return new JSErrorSubject ( THROW_ASSERTION_ERROR , error ) ; }
{ return new NodeSubject ( THROW_ASSERTION_ERROR , node ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
TranspilationPasses . processTranspile ( compiler , externs , this ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this , new SelfReferenceRewriter () ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , this , new SelfReferenceRewriter () ) ; }
TranspilationPasses . processTranspile ( compiler , scriptRoot , findStaticMembers ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ if ( maybeExternMethod ( first ) ) { return DecompositionType.UNDECOMPOSABLE ; } else { return DecompositionType.DECOMPOSABLE ; } }
checkState ( allowObjectCallDecomposing () , STRING_CONSTANT ) ;
Node name = NodeUtil . newQName ( compiler , prototypeAlias + STRING_CONSTANT + declar.memberName , declar.node , declar.memberName ) ;
Node var = NodeUtil . newVarNode ( prototypeAlias , null ) . useSourceInfoIfMissingFromForTree ( injectionPoint ) ;
declNode . isAssign ()
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isLiteralObject () || nt . isBuiltinObject () ; }
boolean isPropertyRemovable ( String propertyName ) { return isEntirelyRemovable || unreferencedPropertiesMayBeRemoved && ! referencedPropertyNames . contains ( propertyName ) ; }
resultPair = analyzeCastFwd ( expr , inEnv , specializedType ) ;
Name superclassNameObj = getOrCreateName ( superclassName , false ) ;
abstract void verify ( Compiler compiler ) ;
currentArgumentsAccess = new LinkedList <> () ;
cur = instance.declarations . getLast () . node ;
PrototypeMemberDeclaration first = instance.declarations . getFirst () ;
List < SourceFile > files = new LinkedList <> () ;
List < SourceFile > files = new LinkedList <> () ;
List < SourceFile > files = new LinkedList <> () ;
List < String > entryPoints = new LinkedList <> () ;
List < MemberDefinition > allProperties = new LinkedList <> () ;
if ( lValue . isRest () ) { lValue = lValue . getFirstChild () ; }
VarInfo varInfo = getVarInfo ( classScope . getVar ( classNameNode . getString () ) ) ;
{ VarInfo varInfo = getVarInfo ( var ) ; varInfo . addRemovable ( new RemovableBuilder () . buildDestructuringAssign ( c , c ) ) ; }
VarInfo varInfo = getVarInfo ( var ) ;
VarInfo varInfo = getVarInfo ( var ) ;
VarInfo varInfo = getVarInfo ( checkNotNull ( scope . getVar ( nameNode . getString () ) ) ) ;
VarInfo varInfo = getVarInfo ( scope . getVar ( nameNode . getString () ) ) ;
VarInfo exceptionVarInfo = getVarInfo ( scope . getVar ( exceptionNameNode . getString () ) ) ;
{ VarInfo varInfo = getVarInfo ( var ) ; varInfo . addRemovable ( new RemovableBuilder () . buildDestructuringAssign ( restNode , target ) ) ; }
VarInfo classVarInfo = getVarInfo ( classVar ) ;
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
throw new IllegalStateException ( STRING_CONSTANT ) ;
checkState ( ! NodeUtil . isObjectLitKey ( n ) ) ;
Preconditions . checkState ( isCallOrNew ( invocation ) ) ;
Scope scope
Preconditions . checkState ( current . isGetProp () , STRING_CONSTANT , current ) ;
Preconditions . checkState ( current . isLabel () ) ;
Preconditions . checkState ( isControlStructure ( parent ) ) ;
Preconditions . checkState ( n . isClassMembers () || n . isObjectLit () ) ;
Preconditions . checkState ( n . isClassMembers () || n . isObjectLit () ) ;
Preconditions . checkArgument ( callNode . isNew () , STRING_CONSTANT , callNode . getToken () ) ;
boolean isMarkedConst = n . isConst () || ( jsdoc != null && jsdoc . isConstant () ) ;
Queue < Property > propertyQueue = new LinkedList <> ( propertiesSet ) ;
{ if ( n . isFunction () ) { break; } this . ancestors . add ( NUMBER_CONSTANT , n ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; }
assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ;
Var v
Node definitionRValue
isStaticCtorProp ( getProp , currentScope )
JSModule module
{ if ( inExterns ) { visitExterns ( traversal , node , parent ) ; } else { visitCode ( traversal , node ) ; } }
JSModule module
DefinitionProvider definitionProvider
if ( defs == null ) { return; }
@ VisibleForTesting Multimap < String , UseSite > getUseSitesByName () { return LinkedHashMultimap . create ( useSitesByName ) ; }
public void testAnnotationInExterns_new5 ( ) throws Exception { assertPureCallsMarked ( STRING_CONSTANT + STRING_CONSTANT , ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
return new RemoveUnusedVars ( compiler , ! removeOnlyLocals , preserveAnonymousFunctionNames ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false ) ; }
new RemoveUnusedVars ( compiler , true , false ) . process ( externs , root ) ;
{ new RemoveUnusedVars ( compiler , removeGlobal , preserveFunctionExpressionNames ) . process ( externs , root ) ; }
{ visitScript ( t , n , parent ) ; }
assertThat ( packageJsonMainEntries ) . containsEntry ( STRING_CONSTANT , NodeModuleResolver.JSC_BROWSER_BLACKLISTED_MARKER ) ;
checkArgument ( fnNode . isFunction () ) ;
LinkedHashMap < String , Node > actualMap = FunctionArgumentInjector . getFunctionCallParameterMap ( fn , call , getNameSupplier () ) ;
public void testFindModifiedParameters12 () { assertThat ( FunctionArgumentInjector . findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters2 () { assertThat ( FunctionArgumentInjector . findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters1 () { assertThat ( FunctionArgumentInjector . findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters0 () { assertThat ( FunctionArgumentInjector . findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
Boolean replaceParent = true ;
tracer = new Tracer ( STRING_CONSTANT ) ;
{ if ( edgeAnnotationStack == null ) { edgeAnnotationStack = new LinkedList <> () ; } pushAnnotations ( edgeAnnotationStack , getEdges () ) ; }
{ if ( nodeAnnotationStack == null ) { nodeAnnotationStack = new LinkedList <> () ; } pushAnnotations ( nodeAnnotationStack , getNodes () ) ; }
if ( LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t . getScope () . getVarCount () ) { return; }
if ( LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < blockScope . getVarCount () + functionScope . getVarCount () ) { return; }
i < LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE + NUMBER_CONSTANT
if ( var . getParentNode () . isParamList () ) { varInfo.propertyAssignmentsWillPreventRemoval = true ; varInfo.unreferencedPropertiesMayBeRemoved = false ; }
exceptionVarInfo . setCannotRemoveAnything () ;
canonicalTotallyUnremovableVarInfo . setCannotRemoveAnything () ;
Set < String > namesToAlias
Set < String > needAliases
LinkedHashMap < String , Node > argMap
if ( LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE < t . getScope () . getVarCount () ) { return; }
return LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE > orderedVars . size () ;
i < LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE + NUMBER_CONSTANT
if ( ! n . isVar () ) { return; }
parent . isVar () && nameNode . hasOneChild ()
parent . isVar ()
removeUnusedProperties && r . isNamedPropertyAssignment () && ! referencedPropertyNames . contains ( r . getPropertyName () )
removeUnusedProperties && removable . isNamedPropertyAssignment () && ! referencedPropertyNames . contains ( removable . getPropertyName () )
! n . isString () && ! isConstantNameNode ( n , knownConstants )
if ( rValue == null || ! rValue . isFunction () || NodeUtil . isVarArgsFunction ( rValue ) ) { return false ; }
if ( NodeUtil . isVarArgsFunction ( fnc ) ) { return false ; }
computeEscapedEs6 ( jsScope , escaped , compiler , scopeCreator ) ;
computeEscapedEs6 ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
computeEscapedEs6 ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
isConstructorCall ( expr )
private Scope newScope () { return Scope . createGlobalScope ( new Node ( Token.SCRIPT ) ) ; }
@ Override public void setUp () { allowMethodCallDecomposing = false ; }
testModules ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
{ test ( createCompilerOptions () , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testES6Modules () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testB3473189 () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
BlackHoleErrorManager . silence ( compiler ) ;
String classAndItsMethodAliasedAsExtern = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
String getPropertyName () { checkState ( isNamedPropertyAssignment () ) ; return checkNotNull ( propertyName ) ; }
if ( toRemove . isParamList () ) {} else { throw new IllegalStateException ( STRING_CONSTANT ) ; }
@ Override public boolean isApplied ( CompilerOptions options ) { return options.collapseProperties ; }
assertTrue ( options.collapseProperties ) ;
assertTrue ( options.collapseProperties ) ;
assertTrue ( options.collapseProperties ) ;
assertTrue ( options.collapseProperties ) ;
@ Override public FeatureSet featureSet () { return ES5 ; }
public void testNoGlobalSchopeChanges () { testSame ( STRING_CONSTANT ) ; }
return ! n . getFirstChild () . isVar () ;
return new RemoveUnusedVars ( compiler , ! removeOnlyLocals , preserveAnonymousFunctionNames , false ) ;
( getTypeDeprecationInfo ( t . getTypedScope () . getTypeOfThis () ) != null )
TypedVar var
TypedVar var
@ Override boolean isMethodDeclaration () { return true ; }
boolean isIndependentlyRemovableNamedProperty () { return isPrototypeObjectNamedPropertyAssignment () || isMethodDeclaration () ; }
boolean isMethodDeclaration () { return false ; }
isGlobal && ! removeGlobals && ! removeUnusedProperties
removeUnusedProperties && removable . isNamedProperty ()
if ( removeUnusedProperties ) { removeUnreferencedProperties () ; }
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedVars () ) ; }
{ passes . add ( flowSensitiveInlineVariables ) ; if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( lastRemoveUnusedVars () ) ; } }
new RemoveUnusedVars.Builder ( compiler ) . removeGlobals ( true ) . build () . process ( externs , root ) ;
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedCode () ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new RewriteGlobalFunctionStatementsToVarAssignmentsCallback () ) ;
new SimpleDependencyInfo.Builder ( closureRelativePath , filePath ) . setProvides ( provides ) . setRequires ( requires ) . setWeakRequires ( weakRequires ) . setLoadFlags ( loadFlags ) . build ()
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( removeUnusedCode ) ; }
atLeast8 = mode == Mode.ES8_OR_GREATER ;
ImmutableCollection < String > getWeakRequires ( ) ;
Collection < String > getRequires ( ) ;
Collection < String > getProvides ( ) ;
public void testDefaultParam_argIsUnknown () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testDefaultParam_argIsUndefined () { test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void disabled_testArrayPatternParam () { testSame ( STRING_CONSTANT ) ; }
visitParamList ( t , n , parent ) ;
Annotation annotation = annotationNames . get ( annotationName ) ;
config.languageMode != LanguageMode.TYPESCRIPT
if ( config.languageMode == LanguageMode.ECMASCRIPT3 ) { errorReporter . error ( SETTER_ERROR_MESSAGE , sourceName , lineno ( node ) , NUMBER_CONSTANT ) ; return true ; }
if ( config.languageMode == LanguageMode.ECMASCRIPT3 ) { errorReporter . error ( GETTER_ERROR_MESSAGE , sourceName , lineno ( node ) , NUMBER_CONSTANT ) ; return true ; }
if ( config.languageMode == LanguageMode.ECMASCRIPT3 ) { errorReporter . warning ( INVALID_ES3_PROP_NAME , sourceName , node . getLineno () , node . getCharno () ) ; }
{ checkState ( config.keepGoing == Config.RunMode.KEEP_GOING ) ; bodyNode = IR . block () ; }
if ( options.removeUnusedPrototypeProperties ) { passes . add ( removeUnusedPrototypeProperties ) ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . build () ; }
options . setCollapseProperties ( true ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new CollapseProperties ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new CollapseProperties ( compiler ) ; }
@ Override public void apply ( CompilerOptions options , boolean value ) { options . setCollapseProperties ( value ) ; }
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
new CollapseProperties ( compiler ) . process ( externs , js ) ;
if ( p != null && ! p . canCollapse () ) { continue; }
if ( ! canCollapseChildNames || ! n . canCollapse () ) { return; }
if ( ! canCollapseChildNames || ! n . canCollapse () ) { return; }
isObjLit && n . canEliminate ()
isObjLit && n . canEliminate ()
if ( n . canCollapse () ) { updateGlobalNameDeclaration ( n , alias , canCollapseChildNames ) ; }
collapseProperties = false ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CollapseProperties ( compiler ) ; }
CollapseProperties collapseProperties = new CollapseProperties ( compiler ) ;
if ( shouldRunRemoveUnusedCode () ) { passes . add ( removeUnusedCode ) ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . removeLocalVars ( true ) . build () ; }
if ( parent . isVar () || parent . isFunction () ) { return true ; }
if ( options.removeUnusedPrototypeProperties ) { passes . add ( removeUnusedPrototypeProperties ) ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . build () ; }
{ options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ; }
for ( String filename : files ) { if ( fix ) { fix ( filename ) ; } else { lint ( filename ) ; } }
passes . add ( extraSmartNamePass ) ;
String qualifiedName = aliasVar . getInitialValue () . getQualifiedName () ;
String aliasExpanded = checkNotNull ( aliasDefinition . getQualifiedName () ) ;
allowGlobalFunctionInlining = false ;
public void testLocalFunctionInliningOnly4 () { this . allowGlobalFunctionInlining = false ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalFunctionInliningOnly3 () { this . allowGlobalFunctionInlining = false ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalFunctionInliningOnly2 () { this . allowGlobalFunctionInlining = false ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
allowGlobalFunctionInlining = true ;
{ options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_NEXT ) ; options . setLanguageOut ( value ? CompilerOptions.LanguageMode.ECMASCRIPT5 : CompilerOptions.LanguageMode.NO_TRANSPILE ) ; }
boolean includesGlobals () { return this == ALL ; }
addToDebugLog ( STRING_CONSTANT + file . getName () ) ;
checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
Node superClassNameNode = NodeUtil . newQName ( compiler , superClassString ) . useSourceInfoIfMissingFrom ( metadata.superClassNameNode ) ;
public void testIssue618_2 () { this . removeGlobal = false ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
VarInfo varInfo = traverseVar ( classScope . getVar ( classNameNode . getString () ) ) ;
VarInfo varInfo = traverseVar ( scope . getVar ( classNameNode . getString () ) ) ;
VarInfo varInfo = traverseVar ( checkNotNull ( scope . getVar ( nameNode . getString () ) ) ) ;
VarInfo varInfo = traverseVar ( scope . getVar ( nameNode . getString () ) ) ;
VarInfo exceptionVarInfo = traverseVar ( scope . getVar ( exceptionNameNode . getString () ) ) ;
rhs == null || isTypedRhs ( rhs ) || NodeUtil . isCallTo ( rhs , STRING_CONSTANT ) || isImportRhs ( rhs )
getAllSymbolsSorted ()
public Iterable < Symbol > getAllSymbols () { return Collections . unmodifiableCollection ( symbols . values () ) ; }
foldSame ( STRING_CONSTANT ) ;
getAllSymbolsSorted ()
getAllSymbolsSorted ()
{ validateObjectLitStringKey ( c ) ; }
if ( parent . isObjectPattern () ) { return ! ( n . isStringKey () && n . hasChildren () ) ; }
if ( node . isStringKey () && ! node . hasChildren () ) { t . report ( node , SHORTHAND_ASSIGNMENT_IN_ENUM ) ; }
if ( ! key . hasChildren () ) { maybeWarn = true ; }
passes . add ( removeUnusedCodeOnce ) ;
options . setInlineFunctions ( false ) ;
options . setInlineFunctions ( true ) ;
options . setInlineFunctions ( true ) ;
options . setInlineFunctions ( true ) ;
{ this . inlineFunctions = inlineFunctions ; }
Iterables . addAll ( allSymbols , table . getAllSymbols () ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; }
boolean isIndependentlyRemovableNamedProperty () { return isPrototypeObjectNamedPropertyAssignment () || isClassOrPrototypeNamedProperty () ; }
if ( isClassMemberFunction ( functionNode ) ) { return STRING_CONSTANT . equals ( functionNode . getParent () . getString () ) ; }
isClassMemberFunction ( functionNode )
{ if ( isImport ) { currentFile . recordImport ( name . getString () ) ; } else { currentFile . recordDeclaration ( name , t . getScope () ) ; } }
String name = ConvertToTypedInterface . getPrototypeNameOfMethod ( functionNode ) ;
if ( isConstructor ( n ) && n . getLastChild () . hasChildren () ) { currentFile . markConstructorToProcess ( n ) ; }
newJsdoc == null && isThisProp ( nameNode )
if ( isClassMethod ( n ) ) { currentFile . recordMethod ( n , t . getScope () ) ; }
! isConstructor ( n )
{ if ( isTypeCompatible ( receiverType , method.type ) ) { unusedMethodPolyfills . remove ( method ) ; } }
checkArgument ( functionNode . isFunction () ) ;
private boolean isAssignmentToPrototype ( Node n ) { return n . isAssign () && isPrototypeGetProp ( n . getFirstChild () ) ; }
long nodeCount = graph . getNodes () . size () ;
checkState ( n . isName () || n . isStringKey () || n . isImportStar () , STRING_CONSTANT , n ) ;
if ( NodeUtil . isAssignmentTarget ( n ) ) { return n ; }
if ( NodeUtil . isAssignmentTarget ( n ) ) { return n ; }
if ( NodeUtil . isAssignmentTarget ( n ) ) { return n ; }
boolean isPrototypeProperty () { return isPrototypeObjectNamedPropertyAssignment () || isClassOrPrototypeNamedProperty () ; }
removeUnusedThisProperties && removable . isThisNamedPropertyAssignment ()
RemovableBuilder builder = new RemovableBuilder () . setIsThisNamedPropertyAssignment ( true ) ;
{ fsCalled . setRemove ( false ) ; if ( ! minimizeCost ( fsCalled ) ) { fsCalled . setInline ( false ) ; } }
{ Node rootNode = scopeRoots . get ( i - NUMBER_CONSTANT ) ; if ( Scope . isHoistScopeRootNode ( rootNode ) ) { return rootNode ; } }
public boolean isHoistScope () { return Scope . isHoistScopeRootNode ( getScopeRoot () ) ; }
checkState ( ( NodeUtil . isNameDeclaration ( parent ) && var.scope . isGlobal () ) || NodeUtil . isFunctionDeclaration ( parent ) ) ;
if ( aliasVar != null ) { return aliasVar.scope . isGlobal () ; }
Node name = importSpec . getFirstChild () ;
validateChildCountIn ( n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
validateChildCountIn ( n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
Builder removeUnusedConstructorProperties ( boolean value ) { this . removeUnusedConstructorProperties = value ; return this ; }
this . removeUnusedConstructorProperties = builder.removeUnusedConstructorProperties ;
Scope s = getScope () ;
refinedScope != null && getScope () != refinedScope
checkState ( name != null && ! name . isEmpty () ) ;
String name = ClassUtil . getPrototypeNameOfMethod ( functionNode ) ;
NodeUtil . deleteNode ( getStatement () , compiler ) ;
Node oldStatement = getStatement () ;
Node getStatement () { return NodeUtil . getEnclosingStatement ( lhs ) ; }
@ Override public boolean hasReferenceName () { return referencedObjType == null ? null : referencedObjType . hasReferenceName () ; }
passes . add ( extraSmartNamePass ) ;
testModules ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
if ( NodeUtil . mayHaveSideEffects ( objExpression ) ) { replaceExpressionWith ( incOrDecNode , objExpression . detach () ) ; } else { removeExpressionCompletely ( incOrDecNode ) ; }
if ( NodeUtil . mayHaveSideEffects ( objExpression ) ) { replaceExpressionWith ( referenceNode , objExpression . detach () ) ; } else { removeExpressionCompletely ( referenceNode ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
Arguments ( Scope scope ) { super ( STRING_CONSTANT , null , scope , - NUMBER_CONSTANT , null ) ; }
@ Override public TypedScope getScope ( TypedVar var ) { return var.scope ; }
ScopeCreator scopeCreator = createScopeCreator () ;
Scope s
private void pushScope ( Scope s ) { pushScope ( s , false ) ; }
Scope refinedScope
Scope scope
Scope s
Scope parent
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Var var = new Var ( name , nameNode , this , vars . size () , input ) ;
{ scope . declare ( name , n , input ) ; }
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Scope hoistedScope = t . getClosestHoistScope () ;
Scope parent
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ return new FeatureSet ( Sets . union ( features , other.features ) ) ; }
public FeatureSet withoutTypes () { return new FeatureSet ( Sets . difference ( features , LangVersion.TYPESCRIPT . features () ) ) ; }
private FeatureSet ( Set < Feature > features ) { this . features = ImmutableSet . copyOf ( features ) ; }
{ test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
! scope . isDeclared ( name , false ) && ! ( scope . isLocal () && name . equals ( ARGUMENTS ) )
if ( STRING_CONSTANT . equals ( name ) && NodeUtil . isVanillaFunction ( scope . getRootNode () ) ) { return scope . getArgumentsVar () ; }
@ Override public TypedScope getScope ( TypedVar var ) { return ( TypedScope ) var.scope ; }
public S getScope () { return scope ; }
if ( ! isFunctionScope () || rootNode . isArrowFunction () ) { return parent . getArgumentsVar () ; }
optimizations . add ( new MinimizeExitPoints ( compiler ) ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , null , template ) ;
assertChanges ( externs , originalCode , null , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( STRING_CONSTANT , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( STRING_CONSTANT , originalCode , expectedCode , template ) ;
public void clearTemplates () { templates = null ; matchedTemplate = null ; }
checkNotNull ( funType ) ;
this . moduleLoader = new ModuleLoader ( null , options.moduleRoots , inputs , ModuleLoader.PathResolver.RELATIVE , options.moduleResolutionMode , null ) ;
options . setModuleResolutionMode ( ModuleLoader.ResolutionMode.NODE ) ;
if ( ProcessCommonJSModules . isCommonJsImport ( n ) ) { visitRequireCall ( t , n , parent ) ; }
public JsonFileSpec ( String src , String path ) { this ( src , path , null ) ; }
if ( var . getParentNode () . isParamList () ) { varInfo.propertyAssignmentsWillPreventRemoval = true ; }
catch ( RuntimeException e ) { fail ( STRING_CONSTANT ) ; }
@ Override public boolean preventsRemovalOfVariableWithNonLocalOrNonLiteralValueOrPrototype () { return true ; }
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testNewOperatior3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNewOperatior2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNewOperatior1 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
return getLeastSupertype ( this , that ) ;
checkState ( n . hasOneChild () ) ;
Node newDeclaration = IR . declaration ( lhsToSplit . detach () , rhs , n . getToken () ) . srcref ( n ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
Map < String , TypeI > props = new HashMap <> () ;
checkState ( mayBeStatement ( stmt ) ) ;
NameDeclarationStatement removable = builder . setAssignedValue ( valueNode ) . buildNameDeclarationStatement ( declarationStatement ) ;
( parent . isForIn () )
public void testLoggerMethodCallByVariableType () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( grandparent != null && grandparent . isVar () ) { return false ; }
ParseTree right = parseUnaryExpression () ;
return findModifiedParameters ( fnNode . getLastChild () , null , names , unsafeNames , false ) ;
public void testDirectPrototypeAssignment2 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testPropertyInference6 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
catch ( IOException e ) { compiler . report ( JSError . make ( AbstractCompiler.READ_ERROR , sourceFile . getName () ) ) ; }
{ compiler . getErrorManager () . report ( CheckLevel.ERROR , JSError . make ( AbstractCompiler.READ_ERROR , getName () ) ) ; return SimpleDependencyInfo.EMPTY ; }
{ testClosureTypesMultipleWarnings ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , ImmutableList . of ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ) ; }
boolean allowDupe = VarCheck . hasDuplicateDeclarationSuppression ( referenceNode , v ) ;
public void testMissingProperty30 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
TemplateAstMatcher astMatcher = new TemplateAstMatcher ( compiler . getTypeIRegistry () , templateRoot , TypeMatchingStrategy.LOOSE ) ;
return fnThisType . isUnknownType () ? null : fnThisType . toObjectType () ;
IR . string ( modulePath . toString () )
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new CheckMissingSuper ( compiler ) ; }
checks . add ( checkMissingSuper ) ;
passes . add ( checkMissingSuper ) ;
{ visitInterfaceGetprop ( t , assign , object , pname , lvalue , rvalue ) ; }
visitGetProp ( t , n , parent ) ;
checkArgument ( scriptNode . isScript () ) ;
{ Node enclosingNode = NodeUtil . getEnclosingNode ( n , loopPredicate ) ; return enclosingNode != null && ! enclosingNode . isFunction () ; }
{ return new Es6RewriteClass ( compiler , ! compiler . getOptions () . inIncrementalCheckMode () ) ; }
assertTypeEquals ( typeRegistry . getNativeType ( JSTypeNative.BOOLEAN_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
suppressors . put ( STRING_CONSTANT , new DiagnosticGroupWarningsGuard ( new DiagnosticGroup ( DiagnosticGroups.CHECK_TYPES , DiagnosticGroups.STRICT_MISSING_PROPERTIES ) , CheckLevel.OFF ) ) ;
if ( ! rewriteState . containsModule ( legacyNamespace ) ) { unrecognizedRequires . add ( new UnrecognizedRequire ( call , legacyNamespace , false , false ) ) ; }
public boolean inIncrementalCheckMode () { return incrementalCheckMode != IncrementalCheckMode.OFF ; }
Node originalFunction = functionContext.function . get () ;
if ( getRhs () == null ) { return; }
{ for ( PotentialDeclaration decl : currentFile . getDeclarations () . get ( name ) ) { processDeclaration ( decl ) ; } }
jsdoc == null || ! jsdoc . containsDeclaration () || ConvertToTypedInterface . isConstToBeInferred ( jsdoc , jsdocNode )
if ( ! isConstToBeInferred ( originalJsdoc , nameNode ) ) { return; }
boolean isImport = isImportRhs ( rhs ) ;
lhsToSplit . isDestructuringLhs () && ! isImportRhs ( lhsToSplit . getLastChild () )
isConstToBeInferred ( jsdoc , nameNode ) && ! nameNode . isFromExterns () && ! JsdocUtil . isPrivate ( jsdoc )
checkState ( caseBody . isNormalBlock () ) ;
checkState ( first . getString () . isEmpty () ) ;
testSame ( externs , code ) ;
testSame ( EXTERNS , STRING_CONSTANT ) ;
testSame ( CompilerTypeTestCase.DEFAULT_EXTERNS , STRING_CONSTANT ) ;
testSame ( externs , code ) ;
testSame ( externs , code ) ;
testSame ( externs , STRING_CONSTANT ) ;
{ testSame ( externs , source ) ; assertEquals ( expected , found ) ; found . clear () ; }
testSame ( externs , js ) ;
testSame ( SHARED_EXTERNS , js ) ;
testSame ( ALL_NATIVE_EXTERN_TYPES , STRING_CONSTANT ) ;
public void testIssue2508576_1 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testClassExtern () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testObjectLitExtern2 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testObjectLitExtern1 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
testSame ( externs , STRING_CONSTANT ) ;
tester . testSame ( STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( METHOD_DEFS , STRING_CONSTANT ) ;
testSame ( externs , js ) ;
testSame ( externs , js ) ;
testSame ( externs , js ) ;
private void testSameEs6Strict ( String js ) { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( js , js ) ; }
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String externs = DEFAULT_EXTERNS . replace ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Map < String , StaticTypedSlot < JSType > > slots = new LinkedHashMap <> () ;
parent . isVar ()
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil.isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil.isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil.isNameDeclaration ) ;
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil : : isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil : : isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil : : isNameDeclaration ) ;
add ( first . getNext () ) ;
{ return null ; }
public void testFindExpressionRoot5 () { assertThat ( findExpressionRoot ( STRING_CONSTANT , STRING_CONSTANT ) ) . isNull () ; }
if ( that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; } else { return FALSE ; }
{ registerMismatchAndReport ( n , INVALID_OPERAND_TYPE , msg , type , getNativeType ( NUMBER_TYPE ) , null , null ) ; }
this . allValueTypes = typeRegistry . createUnionType ( STRING_TYPE , NUMBER_TYPE , BOOLEAN_TYPE , NULL_TYPE , VOID_TYPE ) ;
{ return ! isStringifiable ( templatizedType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ) ; }
allDeps . addAll ( input . getRequires () ) ;
input . getKnownRequires ()
public abstract Builder setRequires ( Collection < String > requires ) ;
writeJsArray ( out , info . getRequires () ) ;
ImmutableList < String > getRequires ( ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( STRING_CONSTANT ) )
ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT )
userOrderedInput . getRequires ()
input . getRequires ()
{ input . addOrderedRequire ( require ) ; }
public void addRequire ( String require ) { extraRequires . add ( require ) ; }
String require
requires . addAll ( deps . getRequires () ) ;
for ( String require : dependency . getRequires () ) { addDependency ( require , seen , list ) ; }
rootInput . getRequires ()
public void testGithubIssue2818 () { noInline ( STRING_CONSTANT ) ; noInline ( STRING_CONSTANT ) ; inline ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ assertNotNull ( warning ) ; test ( externs ( externs ) , srcs ( js ) , warning ( warning , description ) ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( inputs ) , warning ( warning , description ) ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( js ) , warning ( warning , description ) ) ; }
{ assertNotNull ( error ) ; test ( srcs ( inputs ) , error ( error , description ) ) ; }
{ assertNotNull ( error ) ; test ( srcs ( js ) , error ( error , description ) ) ; }
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR , message ) ) ;
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR , message ) ) ;
test ( externs ( externs ) , srcs ( STRING_CONSTANT ) , expected ( STRING_CONSTANT ) , warning ( e , STRING_CONSTANT + STRING_CONSTANT ) ) ;
testError ( srcs ( js ) , error ( BAD_PRIVATE_PROPERTY_ACCESS , STRING_CONSTANT ) ) ;
error ( BAD_PRIVATE_PROPERTY_ACCESS , STRING_CONSTANT )
error ( BAD_PRIVATE_PROPERTY_ACCESS , STRING_CONSTANT )
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_FOR_GOOG_SCOPE , warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_WARNING , warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_WARNING , warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_STRICT_WARNING , warningText ) ) ; }
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , expected ( expected ) , warning ( warning , description ) ) ;
allDeps . addAll ( input . getRequiredSymbols () ) ;
input . getKnownRequiredSymbols ()
public abstract Builder setRequires ( Collection < Require > requires ) ;
writeJsArray ( out , Require . asSymbolList ( info . getRequires () ) ) ;
ImmutableList < Require > getRequires ( ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) ) )
ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) , googRequireSymbol ( STRING_CONSTANT ) )
userOrderedInput . getRequiredSymbols ()
input . getRequiredSymbols ()
{ input . addOrderedRequire ( Require . compilerModule ( require ) ) ; }
public void addRequire ( Require require ) { extraRequires . add ( require ) ; }
Require require
requires . addAll ( deps . getRequiredSymbols () ) ;
for ( String require : dependency . getRequiredSymbols () ) { addDependency ( require , seen , list ) ; }
rootInput . getRequiredSymbols ()
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
TranspilationPasses . addEs6ModulePass ( factories ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler ) ; }
n . putBooleanProp ( Node.GOOG_MODULE_ALIAS , true ) ;
inline ( STRING_CONSTANT , STRING_CONSTANT ) ;
inline ( STRING_CONSTANT , STRING_CONSTANT ) ;
for ( TemplateType ignore : obj . getTemplateTypeMap () . getTemplateKeys () ) { unknowns . add ( getNativeType ( UNKNOWN_TYPE ) ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testIssue70b () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.ES6_FEATURE ) ; }
public void testIssue70a () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.ES6_FEATURE ) ; }
rewriteGeneratorBody ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( node . hasChildren () && node . getLastChild () . isString () ) { info.importedModules . add ( node . getLastChild () . getString () ) ; }
MemoizedTypedScopeCreator typedScopeCreator = getTypedScopeCreator () ;
MemoizedTypedScopeCreator getTypedScopeCreator () { return typedScopeCreator ; }
scopeCreator = new MemoizedTypedScopeCreator ( new TypedScopeCreator ( compiler ) ) ;
MemoizedTypedScopeCreator scopeCreator
MemoizedTypedScopeCreator scopeCreator
allDeps . addAll ( input . getRequires () ) ;
input . getKnownRequires ()
public abstract Builder setRequires ( Collection < String > requires ) ;
writeJsArray ( out , info . getRequires () ) ;
ImmutableList < String > getRequires ( ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( STRING_CONSTANT ) )
ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT )
userOrderedInput . getRequires ()
input . getRequires ()
{ input . addOrderedRequire ( require ) ; }
public void addRequire ( String require ) { extraRequires . add ( require ) ; }
String require
requires . addAll ( deps . getRequires () ) ;
for ( String require : dependency . getRequires () ) { addDependency ( require , seen , list ) ; }
rootInput . getRequires ()
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives || this . shouldGenerateTypedExterns () ; }
inline ( lines ( STRING_CONSTANT ) , lines ( STRING_CONSTANT ) ) ;
public void testNoInlineGetEle () { noInline ( STRING_CONSTANT ) ; }
public void testNoInlineGetProp () { noInline ( STRING_CONSTANT ) ; }
@ Override public StaticTypedScope < JSType > getParentScope () { return getFunctionScope () . getParentScope () ; }
Scope usageScope
List < String > provides = Lists . newArrayList ( depInfo . getProvides () ) ;
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
{ return testForEquality ( that ) . equals ( UNKNOWN ) ; }
this . nullOrUndefined = typeRegistry . createUnionType ( NULL_TYPE , VOID_TYPE ) ;
rewriteGeneratorBodyWithVars ( STRING_CONSTANT , STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
context . writeGeneratedNode ( IR . ifNode ( condition , context . createJumpToBlock ( startCase , n ) ) . useSourceInfoFrom ( n ) ) ;
IR . ifNode ( IR . not ( condition ) . useSourceInfoFrom ( condition ) , context . createJumpToBlock ( endCase , n ) ) . useSourceInfoFrom ( n )
IR . ifNode ( IR . not ( condition ) . useSourceInfoFrom ( condition ) , context . createJumpToBlock ( endCase , n ) ) . useSourceInfoFrom ( n )
if ( options . needsTranspilationFrom ( ES_NEXT ) ) { TranspilationPasses . addEs2018Passes ( passes ) ; passes . add ( setFeatureSet ( ES8 ) ) ; }
parseWarning ( STRING_CONSTANT , getRequiresEsNextMessage ( Feature.OBJECT_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEsNextMessage ( Feature.OBJECT_PATTERN_REST ) ) ;
if ( options . needsTranspilationFrom ( ES_NEXT ) ) { TranspilationPasses . addEs2018Passes ( checks ) ; checks . add ( setFeatureSet ( ES8 ) ) ; }
return rhs . isQualifiedName () || NodeUtil . isCallTo ( rhs , STRING_CONSTANT ) ;
if ( replacements . isEmpty () ) { return STRING_CONSTANT ; }
allJsDocParams = ( info == null ) ? new HashSet < String > () : new HashSet <> ( info . getParameterNames () )
domHelperType = compiler . getTypeIRegistry () . getType ( STRING_CONSTANT ) ;
{ super ( compiler , requirement ) ; errorObjType = compiler . getTypeIRegistry () . getType ( STRING_CONSTANT ) ; }
TypeI methodClassType = registry . getType ( r.type ) ;
TypeI typeWithBannedProp = registry . getType ( prop.type ) ;
{ TypeI type = registry . getType ( typeName ) ; if ( type != null ) { types . add ( type ) ; } }
{ return metadata . getCompiler () . getTypeRegistry () . getType ( type ) ; }
TypeI mathType = compiler . getTypeIRegistry () . getType ( STRING_CONSTANT ) ;
JSType type = typeRegistry . getType ( dottedName ) ;
TypeI methodClassType = registry . getType ( className ) ;
JSType type = compiler . getTypeIRegistry () . getType ( STRING_CONSTANT ) ;
{ return registry . getType ( typeName ) ; }
Scope scope = t . getScope () ;
ImmutableList.Builder < Callback > callbacks = ImmutableList . < Callback > builder () ;
TranspilationPasses . addEs6Passes ( passes ) ;
Predicates . < Node > alwaysTrue ()
parent . isAssign () && parent . getFirstChild () == getProp && parent . getFirstChild () . getLastChild () . getString () . equals ( STRING_CONSTANT )
parent . isAssign () && parent . getFirstChild () == getProp && getProp . getLastChild () . getString () . equals ( STRING_CONSTANT )
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil.isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil.isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil.isNameDeclaration ) ;
StreamSupport . stream ( fixChoices . spliterator () , false ) . map ( choices - > choices . getAlternatives () . get ( choiceIndex ) )
StreamSupport . stream ( fixChoices . spliterator () , false ) . map ( f - > f . getAlternatives () . size () )
newVar = scopeToDeclareIn . declare ( variableName , n , type , input , inferred ) ;
testNotEs6Typed ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testNotEs6Typed ( STRING_CONSTANT , STRING_CONSTANT ) ;
testNotEs6Typed ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ parse ( STRING_CONSTANT ) ; expectErrors ( STRING_CONSTANT ) ; parse ( STRING_CONSTANT ) ; testNotEs6Typed ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( Keywords . isKeyword ( importedName.value ) ) { reportError ( importedName , STRING_CONSTANT , importedName.value ) ; }
if ( Keywords . isKeyword ( importedName.value ) ) { reportExpectedError ( null , PredefinedName.AS ) ; }
this . scanner = new Scanner ( errorReporter , commentRecorder , source , offset ) ;
checkState ( nameNode . isName () ) ;
for ( Case currentCase : allCases ) { switchNode . addChildToBack ( currentCase.caseNode ) ; }
{ currentCase.embedInto . replaceWith ( currentCase.caseBlock . detach () ) ; it . remove () ; continue; }
this . context = new TranspilationContext ( originalGeneratorBody ) ;
ImmutableSortedSet . copyOf ( ENTRY_COMPARATOR , map . entrySet () )
{ this . cache = builder . build ( CacheLoader . from ( source - > delegate . transform ( source ) ) ) ; }
{ return x - > transform ( x ) ; }
{ return x - > function . apply ( x ) ; }
this . modulePaths = resolvePaths ( Iterables . transform ( Iterables . transform ( inputs , UNWRAP_DEPENDENCY_INFO ) , pathResolver ) , moduleRootPaths ) ;
{ maybeAddUsage ( t , n , typeNode , false , Predicates . < Node > alwaysTrue () ) ; }
Predicates . < Node > alwaysTrue ()
reserved = previousMap != null ? previousMap . getNewNameToOriginalNameMap () . keySet () : Collections . < String > emptySet ()
Arrays . sort ( arr , Ordering . < String > natural () ) ;
Predicates . < Node > alwaysTrue ()
return NodeUtil . has ( callNode , hasSpreadCallArgumentPredicate , Predicates . < Node > alwaysTrue () ) ;
return ! referencesArguments && ! NodeUtil . has ( block , p , Predicates . < Node > alwaysTrue () ) ;
for ( Node typeNode : info . getTypeNodes () ) { NodeUtil . visitPreOrder ( typeNode , fixJsdocTypeNodes , Predicates . < Node > alwaysTrue () ) ; }
{ return chars == null ? ImmutableSet . < Character > of () : ImmutableSet . copyOf ( Chars . asList ( chars ) ) ; }
invalidations = FluentIterable . from ( invalidationMap . get ( t ) ) . transform ( Suppliers . < JSError > supplierFunction () ) . limit ( MAX_INVALIDATION_WARNINGS_PER_PROPERTY )
this . invalidationMap = propertiesToErrorFor . isEmpty () ? null : LinkedHashMultimap . < TypeI , Supplier < JSError > > create () ;
for ( Node typeNode : info . getTypeNodes () ) { NodeUtil . visitPreOrder ( typeNode , replaceJsDocRefs , Predicates . < Node > alwaysTrue () ) ; }
return invocation . hasOneChild () ? ImmutableList . < Node > of () : invocation . getSecondChild () . siblings () ;
{ return getCount ( node , new MatchNameNode ( name ) , Predicates . < Node > alwaysTrue () ) ; }
return result == null ? ImmutableList . < Symbol > of () : ImmutableList . of ( result ) ;
{ return eval ( ttlAst , typeVars , ImmutableMap . < String , String > of () ) ; }
ImmutableSet . < String > of ()
Predicates . < DiGraphEdge < Node , ControlFlowGraph.Branch > > alwaysTrue ()
List < Ref > getRefs () { return refs == null ? ImmutableList . < Ref > of () : refs ; }
if ( customPasses == null ) { customPasses = LinkedHashMultimap . < CustomPassExecutionTime , CompilerPass > create () ; }
{ this ( compiler , behavior , creator , Predicates . < Var > alwaysTrue () ) ; }
return NodeUtil . has ( node , pred , Predicates . < Node > alwaysTrue () ) ;
return new JSTypeExpression ( typeNode , PolymerPass.VIRTUAL_FILE ) ;
TypeI type = registry . getType ( target . getFirstFirstChild () . getQualifiedName () ) ;
JSType type = compiler . getTypeRegistry () . getType ( STRING_CONSTANT ) ;
{ final JSType voidType = compiler . getTypeIRegistry () . getNativeType ( JSTypeNative.VOID_TYPE ) ; return voidType . isSubtype ( returnType ) ; }
TypeI type = compiler . getTypeIRegistry () . getType ( typeName ) ;
{ return isTheObjectType () || isStringObjectType () || isDateType () || isRegexpType () || isArrayType () || isNumberObjectType () || isBooleanObjectType () || hasOverridenNativeProperty ( STRING_CONSTANT ) ; }
@ Override public boolean matchesNumberContext () { return isNumberObjectType () || isDateType () || isBooleanObjectType () || isStringObjectType () || hasOverridenNativeProperty ( STRING_CONSTANT ) ; }
public void testMissingProperty33 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty22 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty21 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty18 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty15 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty12 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty11 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty10 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty9 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
JSTypeExpression expr = new JSTypeExpression ( getCallArgument ( ttlAst , NUMBER_CONSTANT ) , STRING_CONSTANT ) ;
compiler . getOptions () . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES6 )
if ( options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES6 ) ) { passes . add ( optimizeToEs6 ) ; }
if ( options.dartPass && ! options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
{ CompilerOptions options = super . getDefaultOptions () ; options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ; options . setLanguageOut ( LanguageMode.ECMASCRIPT5 ) ; return options ; }
return ( nameNode . getFirstChild () != null || isLhsOfEnhancedForExpression ( nameNode ) ) ;
if ( node . isQuotedString () || node . getFirstChild () == null ) { return; }
{ if ( pos >= js . length () ) { return null ; } else { return js . substring ( pos , js . length () ) ; } }
Collections . sort ( declList , DECLARATIONS_FIRST ) ;
{ JSType newType = objType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ; redeclareSimpleVar ( informed , item , newType ) ; }
abstract JSType resolveInternal ( ErrorReporter t , StaticTypedScope < JSType > scope ) ;
@ Override JSType resolveInternal ( ErrorReporter t , StaticTypedScope < JSType > scope ) { return this ; }
@ Override JSType resolveInternal ( ErrorReporter t , StaticTypedScope < JSType > scope ) { return this ; }
@ Override JSType resolveInternal ( ErrorReporter t , StaticTypedScope < JSType > scope ) { return this ; }
ErrorReporter t
private String transpileEs6Module ( String s ) { return transpile ( transpile ( s , es6ModuleTranspiler ) ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModulesToCommonJsModules ( compiler ) ; }
! type . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) )
! jsType . isUnknownType () && ! jsType . isAllType () && jsType . isSubtype ( providedJsType )
if ( that . isUnknownType () || that . isSubtype ( getNativeType ( JSTypeNative.NUMBER_STRING_BOOLEAN ) ) || that . isObject () ) { return UNKNOWN ; }
assertFalse ( arrayOfString . isSubtype ( createUnionType ( arrayOfNumber , NULL_VOID ) ) ) ;
if ( that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL ) ) ) { return UNKNOWN ; }
if ( isEmptyType () || that . isEmptyType () ) { return isSubtype ( that ) || that . isSubtype ( this ) ; }
{ JSType alternate = alternatesList . get ( i ) ; if ( alternate . isSubtype ( arrayType ) ) { return true ; } }
public final boolean isSymbol () { return isSubtype ( getNativeType ( JSTypeNative.SYMBOL_VALUE_OR_OBJECT_TYPE ) ) ; }
public final boolean isNumber () { return isSubtype ( getNativeType ( JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE ) ) ; }
public final boolean isString () { return isSubtype ( getNativeType ( JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE ) ) ; }
assertTrue ( x . isSubtype ( windowCtor . getInstanceType () ) ) ;
assertTrue ( x . isSubtype ( windowCtor . getInstanceType () ) ) ;
assertTrue ( y . isSubtype ( getNativeType ( STRING_TYPE ) ) ) ;
{ return type . isSubtype ( getNativeType ( ARRAY_TYPE ) ) ? null : type ; }
{ JSType arrayType = getNativeType ( ARRAY_TYPE ) ; return arrayType . isSubtype ( type ) ? arrayType : null ; }
if ( resultEqualsValue ) { return ctorType . getGreatestSubtype ( type ) ; } else { return type . isSubtype ( ctorType ) ? null : type ; }
assertTrue ( unknown . isSubtype ( STRING_TYPE ) ) ;
assertTrue ( NULL_TYPE . isSubtype ( nullOrUnknown ) ) ;
assertTrue ( STRING_CONSTANT + varType + STRING_CONSTANT + name + STRING_CONSTANT + type + STRING_CONSTANT , varType . isSubtype ( type ) ) ;
return thisType . isSubtype ( thatType ) || thatType . isSubtype ( thisType ) ;
{ if ( thisType . isFunctionType () ) { return true ; } else { return thisType . isSubtype ( functionType ) || functionType . isSubtype ( thisType ) ; } }
if ( isStructural && ! thisUnresolved && ! thatUnresolved ) { return rightType . isSubtype ( leftType ) ; } else { return rightType . isSubtypeWithoutStructuralTyping ( leftType ) ; }
return new BooleanOutcomePair ( jsType . getPossibleToBooleanOutcomes () , registry . getNativeType ( BOOLEAN_TYPE ) . isSubtype ( jsType ) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY , flowScope , flowScope ) ;
outcome.booleanValues == BooleanLiteralSet.EMPTY && getNativeType ( BOOLEAN_TYPE ) . isSubtype ( type )
argObjectType . isSubtype ( referencedParamType )
{ if ( this . isSubtype ( rawThat ) ) { return this ; } else if ( rawThat . isSubtype ( this ) ) { return filterNoResolvedType ( rawThat ) ; } }
@ Override public boolean isSubtype ( JSType that ) { return isSubtype ( that , ImplCache . create () , SubtypingMode.NORMAL ) ; }
if ( that . isUnknownType () || that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; }
{ final JSType voidType = compiler . getTypeRegistry () . getNativeType ( JSTypeNative.VOID_TYPE ) ; return voidType . isSubtype ( returnType ) ; }
! argType . isSubtype ( paramType )
! rightType . isSubtype ( leftType )
! leftType . isNoType () && ! rightType . isSubtype ( leftType )
! switchType . canTestForShallowEqualityWith ( caseType ) && ( caseType . autoboxesTo () == null || ! caseType . autoboxesTo () . isSubtype ( switchType ) )
! type . isNoType () && ! type . isUnknownType () && type . isSubtype ( nullOrUndefined ) && ! containsForwardDeclaredUnresolvedName ( type )
! type . isSubtype ( getNativeType ( NUMBER_STRING_SYMBOL ) )
! type . isSubtype ( getNativeType ( NUMBER_STRING ) )
! type . matchesNumberContext () && ! type . isSubtype ( allBitwisableValueTypes )
! type . isSubtype ( getNativeType ( NUMBER_TYPE ) )
if ( ! anyObjectType . isSubtype ( type ) && ! type . isEmptyType () ) { mismatch ( t , n , msg , type , anyObjectType ) ; }
if ( ! objType . isNoType () && ! objType . isUnknownType () && objType . isSubtype ( getNativeType ( NULL_VOID ) ) ) { return; }
if ( castType . restrictByNotNullOrUndefined () . isSubtype ( exprType ) || expr . isObjectLit () ) { expr . setJSType ( castType ) ; }
if ( funcTarget . hasInstanceType () ) { if ( type . isSubtype ( funcTarget . getInstanceType () ) ) { return null ; } return type ; }
if ( t . isUnknownType () || t . isNoResolvedType () || ! t . isSubtype ( type ) ) { restricted . addAlternate ( t ) ; }
if ( ! alternate . isUnknownType () && that . isSubtype ( alternate ) ) { return this ; }
if ( that . isUnknownType () || that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
boolean isConstToBeInferred () { return isConstToBeInferred ( getJsDoc () , getLhs () ) ; }
maybeWarnForConstWithoutExplicitType ( compiler , jsdoc , nameNode ) ;
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new J2clPass ( compiler ) ; }
if ( astValidationEnabled ) { ( new AstValidator ( compiler ) ) . validateRoot ( root ) ; }
new PureFunctionIdentifier.DriverInJ2cl ( compiler , null ) . process ( externs , root ) ;
exportedNameToLocalQName . put ( name , name ) ;
exportedNameToLocalQName . put ( name , name ) ;
exportedNameToLocalQName . put ( STRING_CONSTANT , name ) ;
Map.Entry < String , String > entry
functionNames = compilerState.functioNames ;
this . functioNames = compiler.functionNames ;
assertTrue ( moduleScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( moduleScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( blockScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( fooScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( forOfScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( functionBlockScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( functionScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( functionBlockScope . isDeclared ( STRING_CONSTANT , false ) ) ;
catch ( FlagUsageException e ) { assertThat ( e ) . hasMessage ( STRING_CONSTANT ) ; }
return s != null ? s : createScope ( n , createScope ( NodeUtil . getEnclosingScopeRoot ( n . getParent () ) ) ) ;
TypeInference dfa = new TypeInference ( compiler , cfg , rai , assumedScope , ASSERTION_FUNCTION_MAP ) ;
return v != null && v . isLocal () && v . isMarkedEscaped () && v . getScope () == syntacticScope ;
if ( isUnflowable ( syntacticScope . getVar ( varName ) ) ) { return; }
isLocallyInferred = ( var != syntacticScope . getSlot ( qualifiedName ) ) ;
ttlObj = new TypeTransformation ( compiler , syntacticScope ) ;
TypedVar var = syntacticScope . getVar ( qKeyName ) ;
TypedVar var = syntacticScope . getVar ( qName ) ;
TypedVar var = syntacticScope . getVar ( varName ) ;
{ type = info . getType () . evaluate ( syntacticScope , registry ) ; }
if ( info != null && info . hasType () ) { n . setJSType ( info . getType () . evaluate ( syntacticScope , registry ) ) ; }
if ( rename ) { NodeTraversal . traverseEs6 ( compiler , js , new Renamer ( compiler ) ) ; }
registry . createNullableType ( registry . getType ( STRING_CONSTANT ) )
assertTrue ( findNameType ( STRING_CONSTANT , lastLocalScope ) . isEquivalentTo ( registry . getType ( STRING_CONSTANT ) ) ) ;
{ super ( registry , reference , sourceName , lineno , charno ) ; }
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , jsdoc . getImplementedInterfaces () . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , types . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , interfaces . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , NUMBER_CONSTANT , NUMBER_CONSTANT ) , jsdoc . getBaseType () ) ;
{ assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , parse ( STRING_CONSTANT ) . getBaseType () ) ; }
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , interfaces . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( createNullableType ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
resolvedNamedTypes . putAll ( scope , unresolvedNamedTypes . removeAll ( scope ) ) ;
public void clearNamedTypes () { resolvedNamedTypes . clear () ; unresolvedNamedTypes . clear () ; }
{ checkArgument ( ! name . contains ( STRING_CONSTANT ) , STRING_CONSTANT ) ; namesToTypes . put ( name , type ) ; }
{ return ! checkEquivalenceHelper ( that , EquivalenceMethod.DATA_FLOW ) ; }
{ if ( constructorI . checkEquivalenceHelper ( constructorJ , EquivalenceMethod.IDENTITY ) ) { shouldCheck = false ; } }
{ assertEquals ( expected , resolve ( actual ) ) ; }
! newType . isEquivalentTo ( varType )
{ this ( Functions . < String > identity () , errorManager ) ; }
Node ast = parseSyntheticCode ( STRING_CONSTANT + resourceName + STRING_CONSTANT , originalCode ) ;
if ( scope . isDeclared ( qName , false ) ) { continue; }
! scope . isDeclared ( qName , false ) && n . isUnscopedQualifiedName ()
if ( ! name . isEmpty () && ! usageScope . isDeclared ( name , true ) ) { return true ; }
if ( current . isDeclared ( oldName , false ) ) { return; } else { current = current . getParent () ; }
varsInFunctionBody . contains ( refName ) && ! scope . isDeclared ( refName , true )
n . isName () && ! t . getScope () . isDeclared ( n . getString () , true )
return v != null && v . isLocal () && v . isMarkedEscaped () && v . getScope () . getClosestNonBlockScope () == cfgRootScope ;
this . cfgRootScope = syntacticScope ;
curScope . isDeclared ( assignment.oldName , true )
while ( t . getScope () . isDeclared ( pseudoName , true ) ) { pseudoName += STRING_CONSTANT ; }
assertTrue ( fooScope . isDeclared ( STRING_CONSTANT , false ) ) ;
if ( ! scope . isDeclared ( NodeUtil.JSC_PROPERTY_NAME_FN , true ) ) { scope . declare ( NodeUtil.JSC_PROPERTY_NAME_FN , null , null ) ; }
AbstractVar < , > var = getSubject () . getVar ( name ) ;
AbstractVar < , > var = getSubject () . getVar ( name ) ;
if ( t . getScope () . isDeclared ( alias , true ) ) { compiler . report ( JSError . make ( n , TYPE_ALIAS_ALREADY_DECLARED , alias ) ) ; }
if ( ! getRootNode () . isFunction () ) { return getClosestNonBlockScope () . getTypeOfThis () ; }
if ( isUnflowable ( currentScope . getVar ( varName ) ) ) { return; }
isLocallyInferred = ( var != currentScope . getSlot ( qualifiedName ) ) ;
backwardsInferenceFromCallSite ( n , ct ) ;
backwardsInferenceFromCallSite ( n , fnType ) ;
TypedVar var = currentScope . getVar ( qKeyName ) ;
boolean unflowable = isInferred && isUnflowable ( currentScope . getVar ( varName ) ) ;
{ type = info . getType () . evaluate ( currentScope , registry ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null ) ; }
return MODULE_EXPORTS_PREFIX + this . legacyNamespace . replace ( CHAR_CONS , CHAR_CONS ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , GOOG_MODULE_USES_GOOG_MODULE_GET ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null , false , ResolutionMode.BROWSER ) ; }
return getBinaryModuleNamespace ( legacyNamespace ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , MODULE_USES_GOOG_MODULE_GET ) ; }
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , error ( DisambiguateProperties.Warnings.INVALIDATION_ON_TYPE ) . withMessageContaining ( STRING_CONSTANT ) ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , error ( DisambiguateProperties.Warnings.INVALIDATION_ON_TYPE ) . withMessageContaining ( STRING_CONSTANT ) ) ;
{ test ( srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , error ( DisambiguateProperties.Warnings.INVALIDATION ) . withMessageContaining ( STRING_CONSTANT ) ) ; }
{ test ( srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , error ( DisambiguateProperties.Warnings.INVALIDATION ) . withMessageContaining ( STRING_CONSTANT ) ) ; }
TypedVar fnVar = scope . getVar ( fnName ) ;
Node rootNode = scope . getRootNode () ;
private GlobalScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
if ( scope . hasOwnSlot ( qName ) ) { continue; }
TypedVar ownerVar = scope . getVar ( slotName ) ;
TypedVar slot = scope . getVar ( name ) ;
{ return rValueInfo . getType () . evaluate ( scope , typeRegistry ) ; }
{ return createEnumTypeFromNodes ( rValue , lValue . getQualifiedName () , info ) ; }
return scope . isGlobal () || ! type . isReturnTypeInferred () ;
parent == null || ! parent . isFunction () || n == parent . getFirstChild () || parent == scope . getRootNode ()
if ( this . getFunctionScope () != that . getFunctionScope () ) { return false ; }
return slot != null ? slot : getFunctionScope () . getSlot ( var . getName () ) ;
{ return getSlot ( getVarFromFunctionScope ( name ) ) ; }
ScopedName var = getVarFromFunctionScope ( symbol ) ;
{ return new LinkedFlowScope ( new FlatFlowScopeCache ( scope ) ) ; }
{ if ( type != null ) { type = type . resolve ( errorReporter , scope ) ; } }
public TemplateType getObjectIndexKey () { checkNotNull ( iObjectIndexTemplateKey ) ; return this . iObjectIndexTemplateKey ; }
public TemplateType getObjectElementKey () { return this . iObjectElementTemplateKey ; }
new InvalidatingTypes.Builder ( registry ) . recordInvalidations ( this . invalidationMap ) . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () )
Node root = NodeUtil . getEnclosingNode ( n , TypeInference : : createsContainerScope ) ;
AbstractScope ( Node rootNode ) { this . rootNode = rootNode ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null ) ; }
return MODULE_EXPORTS_PREFIX + this . legacyNamespace . replace ( CHAR_CONS , CHAR_CONS ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , GOOG_MODULE_USES_GOOG_MODULE_GET ) ; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
{ if ( moduleType == ModuleType.GOOG_MODULE ) { moduleType = ModuleType.LEGACY_GOOG_MODULE ; } else { compiler . report ( JSError . make ( declaresNamespace , DECLARE_LEGACY_NAMESPACE_OUTSIDE_GOOG_MODULE ) ) ; } }
if ( Keywords . isKeyword ( name.value ) ) { features = features . with ( Feature.KEYWORDS_AS_PROPERTIES ) ; }
{ if ( moduleType == ModuleType.GOOG_MODULE ) { moduleType = ModuleType.LEGACY_GOOG_MODULE ; } else { compiler . report ( JSError . make ( declaresLegacyNamespace , DECLARE_LEGACY_NAMESPACE_OUTSIDE_GOOG_MODULE ) ) ; } }
n . isVar ()
if ( n . isVar () ) { return n . getFirstChild () ; } else if ( NodeUtil . isExprAssign ( n ) ) { return n . getFirstFirstChild () ; }
if ( ! child . isVar () && ! NodeUtil . isExprAssign ( child ) ) { continue; }
parent != null && parent . isVar ()
Node node = withType ( IR . number ( id ) . useSourceInfoFrom ( sourceNode ) , numberType ) ;
sourceNode . replaceWith ( IR . breakNode () ) ;
IR . block ( callContextMethodResult ( sourceNode , STRING_CONSTANT , section . getNumber ( sourceNode ) ) , IR . breakNode () . useSourceInfoFrom ( sourceNode ) ) . useSourceInfoFrom ( sourceNode )
{ writeGeneratedNode ( n ) ; writeGeneratedNode ( IR . breakNode () . useSourceInfoFrom ( n ) ) ; currentCase.mayFallThrough = false ; }
var != null && var . getScope () == getSubject ()
{ checkState ( scope != getSubject () , STRING_CONSTANT ) ; expectScope ( STRING_CONSTANT , scope , scope ) ; }
private DeclarationSubject ( AbstractVar < , > var ) { this . var = var ; }
ImmutableList < AbstractVar < , > > declared = ImmutableList . copyOf ( getSubject () . getAllAccessibleVariables () ) ;
if ( replace . isVar () ) { replace . replaceWith ( NodeUtil . newExpr ( replacement ) ) ; } else { replace . replaceWith ( replacement ) ; }
ref . getParent () . isVar ()
parent . isVar ()
{ return ( n . isVar () || n . isFunction () ) && isWhitelistedName ( n . getFirstChild () . getString () ) ; }
if ( parent . isFunction () || parent . isVar () || parent . isNew () ) { return; }
checkArgument ( returnNode . isReturn () ) ;
{ return ! isValidIndex ( index + offset ) ? CHAR_CONS : source.contents . charAt ( index + offset ) ; }
private char nextChar () { if ( isAtEnd () ) { return CHAR_CONS ; } return source.contents . charAt ( index ++ ) ; }
String value = this . source . contents . substring ( startOffset , index ) ;
NodeTraversal . traverseEs6 ( compiler , root , finder ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseEs6 ( this , n , sia ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new Callback () ) ; }
{ FindPrimitives pass = new FindPrimitives () ; NodeTraversal . traverseEs6 ( compiler , root , pass ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new GatherCollapses () ) ;
{ mode = Mode.SINGLE_FILE ; reset () ; NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ reset () ; NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ; }
NodeTraversal . traverseEs6 ( compiler , originalRoot , cb ) ;
NodeTraversal . traverseRootsEs6 ( compiler , pass , externs , root ) ;
NodeTraversal . traverseEs6 ( compiler , function . getLastChild () , finder ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
NodeTraversal . traverseEs6 ( compiler , cfgNode , gatherCb ) ;
NodeTraversal . traverseEs6 ( compiler , n , gatherCb ) ;
NodeTraversal . traverseEs6 ( compiler , cfgNode , gatherCb ) ;
NodeTraversal . traverseEs6 ( compiler , t . getScopeRoot () , new GatherCandidates () ) ;
{ checkArgument ( isEs6ModuleRoot ( root ) , root ) ; clearState () ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
if ( isEs6ModuleRoot ( scriptNode ) ) { processFile ( scriptNode ) ; } else { NodeTraversal . traverseEs6 ( compiler , scriptNode , new RewriteRequiresForEs6Modules () ) ; }
NodeTraversal . traverseEs6 ( compiler , root , namingCallback ) ;
{ symbolMap = getCssRenamingMap () ; NodeTraversal . traverseEs6 ( compiler , root , new Traversal () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , js , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ;
NodeTraversal . traverseEs6 ( compiler , root , findExportableNodes ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ checkArgument ( scriptNode . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , scriptNode , this ) ; }
{ if ( ! rules . isEmpty () ) { NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ; } }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , enclosingFunction , checkAssigns ) ;
if ( renameMessages ) { RenameMessagesVisitor renameMessagesVisitor = new RenameMessagesVisitor () ; NodeTraversal . traverseEs6 ( compiler , root , renameMessagesVisitor ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new LabelFinder () ) ;
NodeTraversal . traverseEs6ScopeRoots ( compiler , null , changedScopeRoots , cb , cb , false ) ;
NodeTraversal . traverseEs6 ( compiler , root , definitionsGatherer ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ;
NodeTraversal . traverseEs6 ( compiler , js , new Normalize.NormalizeStatements ( compiler , false ) ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new ReductionGatherer ( reducers , reductionMap ) ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , pass ) ;
{ NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopeNodes , new PeepCallback () , false ) ; if ( ! retraverseOnChange ) { break; } }
NodeTraversal . traverseEs6 ( compiler , NodeUtil . getLoopCodeBlock ( loopNode ) , continueStatementUpdater ) ;
NodeTraversal . traverseEs6 ( compiler , body , traversal ) ;
NodeTraversal . traverseEs6 ( compiler , root , getterSetterCollector ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new SourceInformationAnnotator ( STRING_CONSTANT , false ) ) ; }
{ NodeTraversal . traverseEs6 ( compiler , checkNotNull ( root ) , this ) ; }
NodeTraversal . traverseEs6 ( compiler , NodeUtil . getFunctionBody ( constructor ) , finder ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , namingCallback ) ;
{ NodeTraversal . traverseEs6 ( compiler , externs , this ) ; compiler . setExternProperties ( ImmutableSet . copyOf ( externProperties ) ) ; }
NodeTraversal . traverseEs6 ( compiler , root , extractionInfo ) ;
{ NodeTraversal . traverseEs6 ( compiler , js , new DeadAssignmentsElimination ( compiler ) ) ; }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
do { codeChanged = false ; NodeTraversal . traverseEs6 ( compiler , root , new EliminationPass ( cfg ) ) ; } while ( codeChanged ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , externs , findExternsCallback ) ;
NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , block , new UnmarkedNodeTranspiler () ) ;
{ YieldFinder yieldFinder = new YieldFinder () ; NodeTraversal . traverseEs6 ( compiler , n , yieldFinder ) ; return yieldFinder . getYieldNode () ; }
NodeTraversal . traverseEs6 ( compiler , wrapper , context . new UnmarkedNodeTranspiler () ) ;
NodeTraversal . traverseEs6 ( compiler , originalGeneratorBody , new YieldNodeMarker () ) ;
NodeTraversal . traverseEs6 ( compiler , body , this ) ;
{ if ( Es6RewriteModules . isEs6ModuleRoot ( script ) ) { NodeTraversal . traverseEs6 ( compiler , script , new Rewriter ( compiler , script ) ) ; } }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , superSet . getLastChild () , this ) ;
NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopes , new EmptyClinitPruner () , false ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , originalRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , tree , test ) ;
NodeTraversal . traverseEs6 ( compiler , tree , test ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , externs , this ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseEs6ScopeRoots ( compiler , null , changedScopeRoots , new UseSiteGatheringCallback () , false ) ;
{ super . process ( externs , source ) ; NodeTraversal . traverseEs6 ( compiler , source , new UseSiteGatheringCallback () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ PolymerPassSuppressBehaviors suppressBehaviorsCallback = new PolymerPassSuppressBehaviors ( compiler ) ; NodeTraversal . traverseEs6 ( compiler , root , suppressBehaviorsCallback ) ; }
{ requiresLineNumbers = false ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , originalRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ CheckProvidesCallback callback = new CheckProvidesCallback ( codingConvention ) ; NodeTraversal . traverseEs6 ( compiler , scriptRoot , callback ) ; }
{ NodeTraversal . traverseEs6 ( compiler , callback , new RenameCallback ( aliasName , renamed ) ) ; aliasName = renamed ; break; }
NodeTraversal . traverseEs6 ( compiler , callbackBlock , new DefineCallbackReturnCallback () ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , new TransformAMDModulesCallback () ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , script , this ) ;
NodeTraversal . traverseEs6 ( compiler , googRoot , this ) ;
NodeTraversal . traverseEs6 ( compiler , constructorBody , replaceThisWithSuperThis ) ;
NodeTraversal . traverseEs6 ( compiler , functionBody , checkForDefinedReturnValue ) ;
NodeTraversal . traverseEs6 ( compiler , parsed.ast , new Traverser ( info ) ) ;
{ checkState ( root . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new Callback () ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
NodeTraversal . traverseEs6 ( compiler , root , traversal ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , callbacks . get ( NUMBER_CONSTANT ) ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
{ requiresTypes = false ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , externs , this ) ; addWindowProperties () ; }
NodeTraversal . traverseRootsEs6 ( compiler , renamer , externs , root ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseEs6 ( compiler , body , updater ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , findFunction ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , findParameter ) ;
NodeTraversal . traverseEs6 ( compiler , externs , externsCallback ) ;
NodeTraversal . traverseEs6 ( compiler , root , new Strip () ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , scriptRoot , traverser ) ;
NodeTraversal . traverseEs6 ( compiler , root , new ProcessProperties () ) ;
for ( Callback callback : callbacks ) { scriptRoot . putBooleanProp ( Node.TRANSPILED , true ) ; NodeTraversal . traverseEs6 ( compiler , scriptRoot , callback ) ; }
for ( Callback callback : callbacks ) { singleRoot . putBooleanProp ( Node.TRANSPILED , true ) ; NodeTraversal . traverseEs6 ( compiler , singleRoot , callback ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , collector ) ;
NodeTraversal . traverseEs6 ( compiler , scriptRoot , finder ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new ProcessProperties () ) ;
{ new InferConsts ( compiler ) . process ( externs , root ) ; NodeTraversal . traverseEs6 ( compiler , root , constFinder ) ; }
NodeTraversal . traverseEs6 ( compiler , tree , cb ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , new ExportTestFunctionsNodes () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , externs , findExternsCallback ) ; }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseEs6 ( compiler , script , test ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseEs6 ( compiler , root , new ProcessVars () ) ;
{ checkNotNull ( root ) ; checkState ( root . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
return new IdentifierToken ( getTokenRange ( beginToken ) , value . intern () ) ;
NodeTraversal . traverseEs6 ( compiler , rootNode , callback ) ;
NodeTraversal . traverseEs6 ( compiler , script , cb ) ;
NodeTraversal . traverseEs6 ( metadata . getCompiler () , script , callback ) ;
{ checkArgument ( parent . isFunction () || parent . isVar () || parent . isParamList () || parent . isCatch () ) ; }
NodeTraversal . traverseTyped ( compiler , root , new DiscoverEnumsAndTypedefs ( typeRegistry ) ) ;
assertEquals ( STRING_CONSTANT , x . getType () . toString () ) ;
assertEquals ( STRING_CONSTANT , bar . getType () . toString () ) ;
assertEquals ( STRING_CONSTANT , f . getPropertyType ( STRING_CONSTANT ) . toString () ) ;
if ( item . isVar () ) { item = item . getFirstChild () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTranspile () ; }
NodeTraversal . traverseEs6 ( compiler , root , new IdentifyGlobalEnumsAndTypedefsAsNonNullable ( typeRegistry ) ) ;
ReferenceCollectingCallback refCollector = new ReferenceCollectingCallback ( this , ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR , SyntacticScopeCreator . makeUntyped ( this ) ) ;
private TypeCheckResult parseAndTypeCheckWithScope ( String js ) { return parseAndTypeCheckWithScope ( DEFAULT_EXTERNS , js ) ; }
private Node parseAndTypeCheck ( String js ) { return parseAndTypeCheck ( DEFAULT_EXTERNS , js ) ; }
{ testTypes ( DEFAULT_EXTERNS + STRING_CONSTANT + externs , js , diag , false ) ; }
{ testTypes ( externs , js , ( String ) null , false ) ; }
{ testTypes ( DEFAULT_EXTERNS , js , description , isError ) ; }
public void testCovariantIThenable3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testSymbol2 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testSymbol1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch6 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch5 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch4 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch2 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeCovariant2 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeCovariant1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
Node js1Node = parseAndTypeCheck ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
Node js1Node = parseAndTypeCheck ( STRING_CONSTANT + STRING_CONSTANT ) ;
{ TypeCheckResult p = parseAndTypeCheckWithScope ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testAddingMethodsUsingPrototypeIdiomComplexNamespace ( p ) ; }
{ TypeCheckResult p = parseAndTypeCheckWithScope ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testAddingMethodsUsingPrototypeIdiomComplexNamespace ( p ) ; }
Node js1Node = parseAndTypeCheck ( STRING_CONSTANT + STRING_CONSTANT ) ;
public void testFunctionBind5 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind4 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind3 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind2 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind1 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall8 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall7 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall6 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall5 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall3 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall2 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall1 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testAbstractMethodCall13 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall12 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall10 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall8 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall7 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall5 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testIssue1201b () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testThis14 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess9 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess8 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess7 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess6 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess4 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess3 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess2 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess1 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testGetelemStruct_noErrorForGettingWellKnownSymbol () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testGetelemStruct_noErrorForSettingWellKnownSymbol () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testForOf8 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf6 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf5 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf4 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
assertTypeEquals ( type , OBJECT_TYPE ) ;
{ Node n = parseAndTypeCheck ( STRING_CONSTANT ) ; assertTypeEquals ( ERROR_TYPE , n . getFirstFirstChild () . getJSType () ) ; }
assertTypeEquals ( NUMBER_TYPE , type ) ;
assertTypeEquals ( NUMBER_TYPE , type ) ;
assertTypeEquals ( STRING_CONSTANT , NUMBER_TYPE , googFooGetprop2ObjectType . getPropertyType ( STRING_CONSTANT ) ) ;
public void testName5 () { assertTypeEquals ( REGEXP_FUNCTION_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName4 () { assertTypeEquals ( DATE_FUNCTION_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName3 () { assertTypeEquals ( ARRAY_FUNCTION_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName2 () { assertTypeEquals ( OBJECT_FUNCTION_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName1 () { assertTypeEquals ( VOID_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
assertTypeEquals ( ARRAY_TYPE , a . getType () ) ;
assertTypeEquals ( VOID_TYPE , n . getJSType () ) ;
{ Node falseNode = typeCheck ( new Node ( Token.FALSE ) ) ; assertTypeEquals ( BOOLEAN_TYPE , falseNode . getJSType () ) ; }
{ Node trueNode = typeCheck ( new Node ( Token.TRUE ) ) ; assertTypeEquals ( BOOLEAN_TYPE , trueNode . getJSType () ) ; }
{ Node n = typeCheck ( Node . newString ( STRING_CONSTANT ) ) ; assertTypeEquals ( STRING_TYPE , n . getJSType () ) ; }
{ Node n = typeCheck ( Node . newNumber ( NUMBER_CONSTANT ) ) ; assertTypeEquals ( NUMBER_TYPE , n . getJSType () ) ; }
{ TypeCheckResult p = parseAndTypeCheckWithScope ( STRING_CONSTANT ) ; assertTypeEquals ( NUMBER_TYPE , p.scope . getVar ( STRING_CONSTANT ) . getType () ) ; }
{ Node number = createUntypedNumber ( n ) ; number . setJSType ( NUMBER_TYPE ) ; return number ; }
{ Node n = new Node ( Token.NULL ) ; n . setJSType ( NULL_TYPE ) ; return n ; }
public void testTransformationWithUnionInMaprecord () { testTTL ( UNKNOWN_TYPE , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithInvalidMaprecord () { testTTL ( UNKNOWN_TYPE , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithInvalidNestedMapunion () { testTTL ( UNKNOWN_TYPE , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testTransformationWithNestedMapunionInMapFunctionBody () { testTTL ( STRING_TYPE , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithNestedExpressionInBooleanSecondParam () { testTTL ( STRING_TYPE , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithNestedExpressionInBooleanFirstParam () { testTTL ( STRING_TYPE , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
child . inferSlotType ( STRING_CONSTANT , NUMBER_TYPE ) ;
JSDocInfo jsDoc = node . getParent () . isVar () ? node . getParent () . getJSDocInfo () : node . getJSDocInfo () ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories ) ;
shouldAddTypes ? this . contextType . getPropertyType ( fieldName ) : null
String embedded = transpiled + STRING_CONSTANT + URLEncoder . encode ( sourceMap ) + STRING_CONSTANT ;
var . getParentNode () != null && var . getType () == null && var . getParentNode () . isVar ()
assertTypeEquals ( typeRegistry . getNativeType ( GENERATOR_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
assertTypeEquals ( typeRegistry . getNativeType ( ITERATOR_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
assertTypeEquals ( typeRegistry . getNativeType ( ITERABLE_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
JSType type = registry . getType ( reference ) ;
ObjectType regType = ObjectType . cast ( registry . getType ( qualifiedName ) ) ;
{ warnImplicitlyNullable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; noWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
options . setPreserveGoogProvidesAndRequires ( true ) ;
JSType windowType = getType ( STRING_CONSTANT ) ;
private void registerGlobalType ( JSType type ) { registerGlobalType ( type , type . toString () ) ; }
{ typesIndexedByProperty . clear () ; eachRefTypeIndexedByProperty . clear () ; initializeBuiltInTypes () ; namesToTypes . clear () ; initializeRegistry () ; }
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks , options ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes , options ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes , compiler . getOptions () ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories , compiler . getOptions () ) ;
NodeUtil . isLoopStructure ( s . getRootNode () )
actualYieldType = actualYieldType . dereference () . getTemplateTypeMap () . getResolvedTemplateType ( typeRegistry . getIterableTemplate () ) ;
var . getParentNode () != null && var . getType () == null && NodeUtil . isNameDeclaration ( var . getParentNode () )
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.NTI_ONLY ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; String source = STRING_CONSTANT ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.OTI_ONLY ;
this . mode = TypeInferenceMode.OTI_ONLY ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
warningOtiNti ( TYPE_MISMATCH_WARNING , MISTYPED_ASSIGN_RHS )
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ super . setUp () ; this . mode = TypeInferenceMode.NEITHER ; enableRunTypeCheckAfterProcessing () ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefinePropertiesQuotesPreventRemoval () { this . mode = TypeInferenceMode.BOTH ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { this . mode = TypeInferenceMode.BOTH ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty1 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.NEITHER ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; late = false ; useTypes = true ; numRepetitions = NUMBER_CONSTANT ; mode = TypeInferenceMode.NEITHER ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.BOTH ; }
this . mode = TypeInferenceMode.OTI_ONLY ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.NEITHER ; }
public void testClassWithEmptyMembers () { this . mode = TypeInferenceMode.NEITHER ; testError ( STRING_CONSTANT , StrictModeCheck.DUPLICATE_CLASS_METHODS ) ; }
public void testStaticAndNonstaticSetterWithSameName () { this . mode = TypeInferenceMode.NEITHER ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticGetterWithSameName () { this . mode = TypeInferenceMode.NEITHER ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticMethodWithSameName () { this . mode = TypeInferenceMode.NEITHER ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testComputedPropInClass () { this . mode = TypeInferenceMode.NEITHER ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
public void testArguments6 () { this . mode = TypeInferenceMode.NEITHER ; testSame ( STRING_CONSTANT ) ; }
public void testUnknownVariable4 () { this . mode = TypeInferenceMode.NEITHER ; testSameEs6Strict ( STRING_CONSTANT ) ; testSameEs6Strict ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ super . setUp () ; this . mode = TypeInferenceMode.NEITHER ; enableRunTypeCheckAfterProcessing () ; }
{ super . setUp () ; late = true ; useTypes = true ; this . mode = TypeInferenceMode.NEITHER ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.BOTH ; }
{ this . mode = TypeInferenceMode.NEITHER ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.NEITHER ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; this . mode = TypeInferenceMode.NEITHER ; enableRunTypeCheckAfterProcessing () ; }
public void disable_testClassMethodUnused2 () { this . mode = TypeInferenceMode.NEITHER ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { this . mode = TypeInferenceMode.NEITHER ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassPropUnused1 () { this . mode = TypeInferenceMode.NEITHER ; unused ( STRING_CONSTANT ) ; }
new CodePrinter.Builder ( parse ( js , TypeInferenceMode.OTI_ONLY ) )
Node parse ( String js ) { return parse ( js , TypeInferenceMode.NEITHER ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.BOTH ; }
testSame ( externs ( lines ( MINIMAL_EXTERNS , STRING_CONSTANT , STRING_CONSTANT ) ) , srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , warningOtiNti ( TypeValidator.TYPE_MISMATCH_WARNING , NewTypeInference.INVALID_ARGUMENT_TYPE ) )
test ( srcs ( STRING_CONSTANT ) , warningOtiNti ( TOO_MANY_TEMPLATE_PARAMS , INVALID_GENERICS_INSTANTIATION ) ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( srcs ( STRING_CONSTANT ) , warningOtiNti ( TOO_MANY_TEMPLATE_PARAMS , INVALID_GENERICS_INSTANTIATION ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_boxedNumberVsZero () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_while () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ super . setUp () ; late = true ; this . mode = TypeInferenceMode.NEITHER ; ignoreWarnings ( DiagnosticGroups.NEW_CHECK_TYPES_EXTRA_CHECKS ) ; }
for ( DeferredSetType deferred : deferredSetTypes ) { deferred . resolve ( currentScope ) ; }
a . resolve ( null , EMPTY_SCOPE ) ;
{ if ( type != null ) { this . type = type . resolve ( errorReporter , scope ) ; } }
activeXObject . resolve ( null , scope ) ;
namedA . resolve ( null , scope ) ;
for ( NamedType type : unresolvedNamedTypes . get ( scope ) ) { type . resolve ( reporter , scope ) ; }
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories ) ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = STRING_CONSTANT ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; ignoreWarnings ( NewTypeInference.GLOBAL_THIS , NewTypeInference.INEXISTENT_PROPERTY ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
public void testAbstractClass () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT , warning ( INSTANTIATE_ABSTRACT_CLASS ) ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableTranspile () ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefinePropertiesQuotesPreventRemoval () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties1 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testES6StaticProperty2 () { this . mode = TypeInferenceMode.DISABLED ; testSame ( STRING_CONSTANT ) ; }
public void testES6StaticProperty () { this . mode = TypeInferenceMode.DISABLED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testConstructorProperty2 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty1 () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.DISABLED ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
this . mode = TypeInferenceMode.CHECKED ;
public void testClassWithEmptyMembers () { this . mode = TypeInferenceMode.DISABLED ; testError ( STRING_CONSTANT , StrictModeCheck.DUPLICATE_CLASS_METHODS ) ; }
public void testStaticAndNonstaticSetterWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticGetterWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticMethodWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testComputedPropInClass () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
public void testArguments6 () { this . mode = TypeInferenceMode.DISABLED ; testSame ( STRING_CONSTANT ) ; }
public void testUnknownVariable4 () { this . mode = TypeInferenceMode.DISABLED ; testSameEs6Strict ( STRING_CONSTANT ) ; testSameEs6Strict ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
{ super . setUp () ; late = true ; useTypes = true ; this . mode = TypeInferenceMode.DISABLED ; }
{ this . mode = TypeInferenceMode.DISABLED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.DISABLED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
public void disable_testClassMethodUnused2 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassPropUnused1 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; }
new CodePrinter.Builder ( parse ( js , TypeInferenceMode.CHECKED ) )
Node parse ( String js ) { return parse ( js , TypeInferenceMode.DISABLED ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTranspile () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; ignoreWarnings ( DiagnosticGroups.NEW_CHECK_TYPES_EXTRA_CHECKS ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_boxedNumberVsZero () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_while () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
return options . getNewTypeInference () ? getGlobalTypeInfo () : getTypeRegistry () ;
this . addTypes = MostRecentTypechecker.NTI . equals ( compiler . getMostRecentTypechecker () ) ;
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.NTI . equals ( compiler . getMostRecentTypechecker () ) ; }
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.NTI . equals ( compiler . getMostRecentTypechecker () ) ; }
this . addTypes = MostRecentTypechecker.NTI . equals ( compiler . getMostRecentTypechecker () ) ;
public boolean isTypecheckingEnabled () { return this . checkTypes || this . useNewTypeInference ; }
DiagnosticGroup ignored = new DiagnosticGroup ( TypeCheck.INEXISTENT_PROPERTY , NewTypeInference.GLOBAL_THIS , NewTypeInference.INEXISTENT_PROPERTY , NewTypeInference.INVALID_ARGUMENT_TYPE , TypeValidator.TYPE_MISMATCH_WARNING ) ;
ignoreWarnings ( GlobalTypeInfoCollector.INTERFACE_METHOD_NOT_IMPLEMENTED , TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED ) ;
public void testTypeMismatch () { ignoreWarnings ( NewTypeInference.MISTYPED_ASSIGN_RHS , TypeValidator.TYPE_MISMATCH_WARNING ) ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
validator . expectCanAssignTo ( t , loopVarNode , declaredType , actualType , STRING_CONSTANT ) ;
checkArgument ( setKey . isSetterDef () , setKey ) ;
newGeneratorBody . addChildBefore ( varStatement , newGeneratorBody . getLastChild () ) ;
newGeneratorBody . addChildBefore ( n , newGeneratorBody . getLastChild () ) ;
if ( prop != null ) { if ( NodeUtil . isStringLiteralValue ( prop ) ) { continue; } return violation ; }
NodeUtil . isLhsOfAssign ( propAccess ) && ( NodeUtil . isLiteralValue ( propAccess . getNext () , false ) || NodeUtil . isStringLiteralValue ( propAccess . getNext () ) )
if ( NodeUtil . isStringLiteralValue ( ast ) ) { paramNodeMatches . set ( paramIndex , ast ) ; return true ; }
{ return NodeUtil . isStringLiteralValue ( ast ) ; }
{ if ( ! isCompileTimeConstant ( traversal . getScope () , argument ) ) { compiler . report ( traversal . makeError ( argument , CONST_NOT_STRING_LITERAL_ERROR ) ) ; } }
String lastPart = typeString . substring ( typeString . lastIndexOf ( STRING_CONSTANT ) + NUMBER_CONSTANT ) ;
int index = name . indexOf ( STRING_CONSTANT ) ;
checkArgument ( setKey == null || setKey . isSetterDef () , setKey ) ;
List < LocationMapping > sourceMapLocationMappings
{ locationMappings . add ( new SourceMap.LocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
Path path
Path path
Path path
Path path
Path path
Path path
Path path
public void setSourceMapLocationMappings ( List < SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
{ switch ( n . getToken () ) { case FOR_OF : visitForOf ( t , n , parent ) ; break; default: break; } }
this . registry = compiler . getTypeIRegistry () ;
TypeI type
@ Override public JSType getReturnType () { return call.returnType ; }
builder . setTypeRegistry ( getTypeIRegistry () ) ;
newName . setTypeI ( child . getTypeI () ) ;
n . setTypeI ( type ) ;
TypeI type = srcObj . getTypeI () ;
TypeI attrsType = attrs . getTypeI () ;
TypeI type = srcObj . getTypeI () ;
ObjectTypeI targetType = target . getTypeI () . toMaybeObjectType () ;
String typeName = n . getFirstChild () . getTypeI () . toString () ;
TypeI type = n . getTypeI () ;
TypeI type = n . getTypeI () ;
{ return n . getTypeI () != null && isKnown ( n ) && invalidDeref ( n ) && ! isWhitelistedType ( n ) ; }
TypeI thrown = n . getFirstChild () . getTypeI () ;
{ super ( compiler , requirement ) ; errorObjType = compiler . getTypeIRegistry () . getGlobalType ( STRING_CONSTANT ) ; }
TemplateAstMatcher astMatcher = new TemplateAstMatcher ( compiler . getTypeIRegistry () , templateRoot , typeMatchingStrategy ) ;
FunctionTypeI restrictedCallType
FunctionTypeI restrictedCallType
FunctionTypeI functionType
TypeI type = n . getTypeI () ;
{ return isAssertionCall ( n . getParent () ) || n . getTypeIBeforeCast () != null ; }
{ TypeI type = n . getTypeI () ; return ( type == null || type . isSomeUnknownType () ) ; }
{ TypeI type = n . getTypeI () ; return ( type == null || type . isUnknownType () ) ; }
{ TypeI type = n . getTypeI () ; return type != null && type . isTop () ; }
nativeObjectType = compiler . getTypeIRegistry () . getNativeType ( JSTypeNative.OBJECT_TYPE ) ;
public TypeSubject ( FailureMetadata failureMetadata , TypeI type ) { super ( failureMetadata , type ) ; }
TypeI type
{ TypeI type = n . getTypeI () ; return ( type != null && type . isFunctionType () ) ; }
replacement . setTypeI ( getNativeStringType () ) ;
ObjectTypeI prototypeOrInstance ( ) ;
void declarePrototypeProperty ( String name , TypeI type , Node defSite ) ;
void declareInstanceProperty ( String name , TypeI type , Node defSite ) ;
void declareConstructorProperty ( String name , TypeI type , Node defSite ) ;
private String formatTypeVar ( TypeI var ) { return var . toAnnotationString ( Nullability.IMPLICIT ) ; }
TypeIRegistry registry
@ Override public FunctionType getOwnerFunction () { return null ; }
@ Override public boolean isPrototypeObject () { return isFunctionPrototypeType () ; }
Builder ( TypeIRegistry registry ) { this . registry = registry ; }
FunctionTypeI getterType
replacement . setTypeI ( call . getTypeI () ) ;
for ( Node n : nodeList ) { n.typei = ( TypeI ) in . readObject () ; }
for ( Node n : nodeList ) { out . writeObject ( n.typei ) ; }
dst . setTypeI ( this . typei ) ;
@ Nullable public final JSType getJSTypeBeforeCast () { return ( JSType ) getTypeIBeforeCast () ; }
TypeI type = expr . getTypeI () ;
TypeI type = n . getTypeI () ;
Node stringKey = withType ( IR . stringKey ( name , n . getFirstChild () . detach () ) , n . getTypeI () ) ;
this . registry = compiler . getTypeIRegistry () ;
@ Nullable TypeI typeI
n . getTypeI () == null
TypeI type
TypeI type = getType ( typeObj ) ;
TypeI type = getType ( obj ) ;
TypeI objlitType = getType ( n ) ;
TypeI type = getType ( n . getFirstChild () ) ;
return n . isGetProp () && n . getLastChild () . getString () . equals ( STRING_CONSTANT ) && n . getFirstChild () . getTypeI () . isStructuralInterface () ;
TypeI recvType = getType ( recv ) ;
TypeI type
TypeI type
mathDotPowCall = withType ( IR . call ( mathPow . get () . cloneTree () , left , right ) , n . getTypeI () ) . useSourceInfoIfMissingFromForTree ( n )
TypeI type = fnNode . getTypeI () ;
TypeI type = n . getTypeI () ;
TypeI type = n . getTypeI () ;
TypeI jsType
TypeI jsType
Node assign = withType ( IR . assign ( copiedVarName , varName . removeFirstChild () ) , varName . getTypeI () ) . useSourceInfoFrom ( varName ) ;
Node newThis = withType ( context . getScopedName ( GENERATOR_THIS ) , n . getTypeI () ) ;
IR . returnNode ( withType ( IR . call ( createGenerator , withType ( genFuncName . cloneNode () , generatorFunction . getTypeI () ) , program ) , originalGenReturnType ) )
TypeIRegistry registry
TypeIRegistry registry
FunctionTypeI getterType
TypeI type
new InvalidatingTypes.Builder ( compiler . getTypeIRegistry () ) . disallowGlobalThis () . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () ) . build ()
TypeI type
ImmutableMap < String , TypeI > typeVars
TypeIRegistry registry
this . registry = compiler . getTypeIRegistry () ;
TypeIRegistry typeRegistry
ObjectTypeI objectType
ObjectTypeI objectType
TypeI type = n . getTypeI () ;
this . typeRegistry = compiler . getTypeIRegistry () ;
public Builder setTypeRegistry ( TypeIRegistry registry ) { this . registry = registry ; return this ; }
CodePrinter.Builder builder = new CodePrinter.Builder ( externsRoot ) . setPrettyPrint ( true ) . setOutputTypes ( true ) . setTypeRegistry ( compiler . getTypeIRegistry () ) ;
lit . setTypeI ( exportedObjectLit . getTypeI () ) ;
TypeI type = n . getTypeI () ;
StaticTypedScope < ? extends TypeI > scope
@ Override public TypeI getType () { return null ; }
lastCompiler . getTypeIRegistry ()
lastCompiler . getTypeIRegistry ()
TypeI typeI = getPropLhs . getTypeI () ;
TypeIRegistry typeRegistry
actual = new CodePrinter.Builder ( script ) . setCompilerOptions ( options ) . setTypeRegistry ( compiler . getTypeIRegistry () ) . build () . trim ()
if ( n . getTypeI () == null ) { throw new IllegalStateException ( STRING_CONSTANT + n + STRING_CONSTANT + STRING_CONSTANT ) ; }
TemplateAstMatcher matcher = new TemplateAstMatcher ( lastCompiler . getTypeIRegistry () , templateRoot . getFirstChild () , typeMatchingStrategy ) ;
ObjectTypeI objectType
@ Nullable ObjectTypeI referenceType
TypeI type = name . getTypeI () ;
TypeI type
TypeI type
TypeI type
TypeI type
new InvalidatingTypes.Builder ( compiler . getTypeIRegistry () ) . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () ) . addAllTypeMismatches ( compiler . getImplicitInterfaceUses () ) . build ()
TypeI receiverType = determineReceiverType ( n ) ;
TypeIRegistry typeRegistry
TypeI type = firstArg . getTypeI () ;
FunctionTypeI getterType
TypeIRegistry registry
public void applySingletonGetter ( NominalTypeBuilder classType , FunctionTypeI getterType ) ;
List < ? extends LocationMapping > sourceMapLocationMappings
{ locationMappings . add ( new SourceMap.PrefixLocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
URI path
URI path
URI path
URI path
URI path
URI path
URI path
public void setSourceMapLocationMappings ( List < ? extends SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
if ( c . getString () . equals ( STRING_CONSTANT ) ) { windowInExterns = true ; continue; }
mostRecentTypechecker = compilerState.mostRecentTypeChecker ;
this . mostRecentTypeChecker = compiler.mostRecentTypechecker ;
this . compiler . setMostRecentTypechecker ( MostRecentTypechecker.OTI ) ;
compiler . setMostRecentTypechecker ( MostRecentTypechecker.OTI ) ;
this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ;
compiler . setMostRecentTypechecker ( MostRecentTypechecker.OTI ) ;
abstract MostRecentTypechecker getMostRecentTypechecker ( ) ;
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ; }
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ; }
this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
if ( c . getString () . equals ( WINDOW_NAME ) ) { windowInExterns = true ; continue; }
{ super . setUp () ; compiler . getOptions () . setWarningLevel ( DiagnosticGroups.MISSING_OVERRIDE , CheckLevel.WARNING ) ; compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.WARNING ) ; }
if ( prevUsedRenameMap != null ) { reusePreviouslyUsedVariableMap () ; }
if ( ! validator . expectIterable ( t , n , actualYieldType , STRING_CONSTANT ) ) { return; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
if ( c . getString () . equals ( STRING_CONSTANT ) ) { windowInExterns = true ; continue; }
public ModuleLoader.ResolutionMode getModuleResolutionMode () { return this . moduleResolutionMode ; }
ObjectType objectType
ObjectType objectType
if ( iterableType != null ) { typeParam = iterableType . getTemplateTypeMap () . getResolvedTemplateType ( registry . getIterableTemplate () ) ; }
JSType newType = objType . getTemplateTypeMap () . getResolvedTemplateType ( registry . getIterableTemplate () ) ;
defineSlot ( astParameter , functionNode , paramType , inferred ) ;
{ defineSlot ( fnNameNode , fnNode , fnNode . getJSType () , false ) ; }
if ( candidate . isGetProp () ) { defineSlot ( candidate , candidate . getParent () , getNativeType ( NO_TYPE ) , false ) ; }
defineSlot ( n , parent , valueType , inferred ) ;
if ( NodeUtil . isFunctionDeclaration ( n ) ) { defineSlot ( n . getFirstChild () , n , functionType ) ; }
{ boolean inferred = keyType == null ; defineSlot ( keyNode , objLit , qualifiedName , keyType , inferred ) ; }
! type . matchesNumberContext () && ! type . matchesStringContext () && ! type . matchesStringContext ()
{ return isSubtype ( ( JSType ) that , ImplCache . createWithoutStructuralTyping () , SubtypingMode.NORMAL ) ; }
FunctionType makeIteratorType = registry . createFunctionType ( ( JSType ) iteratorType , paramBuilder . build () ) ;
List < LocationMapping > sourceMapLocationMappings
{ locationMappings . add ( new SourceMap.LocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
Path path
Path path
Path path
Path path
Path path
Path path
Path path
public void setSourceMapLocationMappings ( List < SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , newMode , sourceUrl , path , sourceMapCache ) ; }
visitImport ( n ) ;
return dereferencePointer ( n . getFirstChild () , scope ) ;
return tightenTypeAfterDereference ( n . getFirstChild () , scope ) ;
{ testTypes ( DEFAULT_EXTERNS + STRING_CONSTANT + externs , js , description , false ) ; }
{ testTypes ( DEFAULT_EXTERNS , js , diagnosticType , isError ) ; }
{ testTypes ( DEFAULT_EXTERNS , js , description , isError ) ; }
public void testGenerator_yieldAll_string () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_yieldAll1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_return2 () { testTypes ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_noDeclaredReturnType3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_returnsIterator2 () { testTypes ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_returnsIterable2 () { testTypes ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator3 () { testTypes ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_StringObject2 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_StringObject1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_string1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_array3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType6a () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType5 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType4a () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrayLitSpread () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
StaticTypedScope < JSType > getDeclarationScope ( ) ;
FlowScope createChildFlowScope ( StaticTypedScope < JSType > scope ) ;
{ if ( sym instanceof StaticTypedSlot ) { return ( ( StaticTypedSlot < JSType > ) sym ) . isTypeInferred () ; } return true ; }
{ if ( s instanceof StaticTypedScope ) { return ( ( StaticTypedScope < JSType > ) s ) . getTypeOfThis () ; } return null ; }
{ if ( sym instanceof StaticTypedSlot ) { return ( ( StaticTypedSlot < JSType > ) sym ) . getType () ; } return null ; }
StaticTypedSlot < JSType > slot
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > typeEnv
@ Override StaticTypedScope < T > getScope ( ) ;
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
@ Override public T getTypeOfThis () { return null ; }
T getTypeOfThis ( ) ;
StaticTypedScope < JSType > scope
if ( n . isAssignAdd () ) { updateScopeForTypeChange ( scope , left , leftType , type ) ; }
visitParameterList ( t , n , functionType ) ;
visitParameterList ( t , n , fnType ) ;
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
while ( current.parent != null && current.lastSlot == current.parent.lastSlot ) { current = current.parent ; }
n . isCall () || n . isYield ()
return dereferencePointer ( n . getFirstChild () , scope ) ;
updateTypeOfParameters ( n , fnType ) ;
updateTypeOfArguments ( n , fnType ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
updateTypeOfParameters ( n , fnType ) ;
if ( ! options.checksOnly ) { passes . add ( es6ForOf ) ; }
testWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
if ( isAliasDefinition ( decl ) ) { return; }
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
if ( n . isAssignAdd () ) { updateScopeForAssignment ( scope , left , leftType , type ) ; }
child . inferSlotType ( STRING_CONSTANT , getNativeNumberType () ) ;
flowScope . inferSlotType ( STRING_CONSTANT , type ) ;
if ( this . optimizesToSameScope ( that ) ) { return true ; }
FlowScope output = input . createChildFlowScope ( scopeCreator . createScope ( root ) ) ;
FlowScope informed = blindScope . createChildFlowScope () ;
assign . useSourceInfoIfMissingFromForTree ( member ) ;
{ scope = traverse ( name . getFirstChild () , scope ) ; }
List < String > moduleNameRegexList = options.modulesToPrintAfterEachPassRegexList ;
{ return new CrossModuleMethodMotion ( compiler , compiler . getCrossModuleIdGenerator () , options.removeUnusedPrototypePropertiesInExterns , options.crossModuleCodeMotionNoStubMethods ) ; }
{ return new CrossModuleCodeMotion ( compiler , compiler . getModuleGraph () , options.parentModuleCanSeeSymbolsDeclaredInChildren ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RescopeGlobalSymbols ( compiler , options.renamePrefixNamespace , options.renamePrefixNamespaceAssumeCrossModuleNames ) ; }
parentModuleCanSeeSymbolsDeclaredInChildren = false ;
assertTrue ( REGEXP_TYPE . canBeCalled () ) ;
public boolean isAbstract () { return isAbstract ; }
return treatThisTypesAsCovariant ( other , implicitImplCache ) && this . call . isSubtype ( other.call , implicitImplCache , subtypingMode ) ;
public ObjectType getPrototypeProperty () { return getPrototype () ; }
public boolean isReturnTypeInferred () { return call.returnTypeInferred ; }
public JSType getReturnType () { return call.returnType ; }
@ Override public boolean canBeCalled () { return true ; }
public void setDict () { propAccess = PropAccess.DICT ; }
public void setStruct () { propAccess = PropAccess.STRUCT ; }
if ( ft != null ) { functionNode . setJSType ( ft . convertMethodToFunction () ) ; }
type == null || type . isUnknownType () || type . isUnresolved () || type . isTop ()
return ! type . isTop () && ( type . isNullable () || type . isVoidable () ) ;
targetType . isUnknownType () || targetType . isUnresolved () || targetType . isTop () || targetType . isEquivalentTo ( registry . getNativeType ( JSTypeNative.OBJECT_TYPE ) )
{ JSType type = n . getJSType () . restrictByNotNullOrUndefined () ; return type . isBottom () ; }
{ JSType type = n . getJSType () ; return type != null && type . isTop () ; }
obj != null && obj . isPrototypeObject ()
return restricted . isBottom () ? type : restricted ;
retType != null && ! retType . isBottom () && ! funType . isInterface ()
type . isEnumElement ()
if ( objType . isPrototypeObject () ) { constructor = objType . getOwnerFunction () ; } else { constructor = objType . getConstructor () ; }
type . isEnumElement ()
{ return type . isEnumObject () || type . isBoxableScalar () ; }
if ( type . isEnumElement () ) { return getTypesToSkipForType ( type . getEnumeratedTypeOfEnumElement () ) ; }
if ( ! t . isObjectType () || t . isTop () ) { return; }
type . isTop () || type . isUnknownType ()
type . isTop () || type . isUnknownType ()
ObjectType getReferencedObjTypeInternal () { return referencedObjType ; }
JSType getReferencedTypeInternal () { return referencedType ; }
return subtype . isBottom () ;
if ( body . isBottom () || body . isEquivalentTo ( getObjectType () ) ) { continue; }
return result . isBottom () ? getUnknownType () : result ;
if ( type . isEnumElement () ) { return type . getEnumeratedTypeOfEnumElement () ; }
! callClassType . isBottom () && ! callClassType . isSomeUnknownType ()
if ( type == null || type . isUnknownType () || type . isTop () ) { return allowLooseMatches ? MatchResult.LOOSE_MATCH : MatchResult.NO_MATCH ; }
{ return type == null ? null : type . autoboxAndGetObject () ; }
@ Override public boolean matchesSymbolContext () { return true ; }
@ Override public boolean matchesStringContext () { return true ; }
@ Override public boolean matchesObjectContext () { return true ; }
@ Override public boolean matchesNumberContext () { return true ; }
@ Override public boolean isConstructor () { return false ; }
@ Override public boolean isVoidable () { return true ; }
@ Override public boolean isNullable () { return true ; }
@ Override public boolean isNoObjectType () { return false ; }
type . isPrototypeObject ()
if ( ! receiverType . meetWith ( type ) . isBottom () ) { return true ; }
return type != null && type . containsArray () ;
propdef . setJSType ( null ) ;
visitImport ( t . getInput () . getPath () , n ) ;
@ Override public boolean isApplied ( CompilerOptions options ) { return options.crossModuleMethodMotion ; }
@ Override public boolean isApplied ( CompilerOptions options ) { return options.crossModuleCodeMotion ; }
ensureTyped ( t , n ) ;
{ ensureTyped ( t , name , valueType ) ; }
ensureTyped ( t , n ) ;
ensureTyped ( t , n ) ;
ensureTyped ( t , n , type ) ;
ensureTyped ( t , iterableNode ) ;
if ( ! options.checksOnly ) { passes . add ( lateConvertEs6ToEs3 ) ; }
if ( topScope == null ) { regenerateGlobalTypedScope ( compiler , root . getParent () ) ; } else { compiler . getTypeRegistry () . resolveTypesInScope ( topScope ) ; }
if ( recordUnresolvedTypes ) { unresolvedNamedTypes . put ( scope , namedType ) ; }
{ whitespaceOnlyPasses () ; if ( options . needsTranspilationFrom ( FeatureSet.ES6 ) ) { transpileAndDontCheck () ; } }
FeatureSet features = ( FeatureSet ) script . getProp ( Node.FEATURE_SET ) ;
n . isNormalBlock () && ! loneBlocks . isEmpty () && loneBlocks . peek () == n
( parent . isScript () || ( parent . isNormalBlock () && ! parent . isSyntheticBlock () && ! parent . isAddedBlock () ) )
if ( ! subtree . isScript () && ! subtree . isNormalBlock () ) { return subtree ; }
body . isNormalBlock () && ! body . hasChildren ()
{ return ( n . isNormalBlock () && n . isSyntheticBlock () ) || n . isScript () ; }
checkState ( block . isNormalBlock () ) ;
if ( ! block . isNormalBlock () ) { return null ; }
stmt . isEmpty () || ( stmt . isNormalBlock () && ! stmt . hasChildren () )
n . isNormalBlock ()
! n . isNormalBlock ()
statement . isNormalBlock ()
! target . getParent () . isScript () && ! target . getParent () . isNormalBlock () && ! target . getParent () . isModuleBody ()
n . isNormalBlock ()
n . isNormalBlock ()
n . isNormalBlock ()
n . isNormalBlock ()
parent != null && ( parent . isNormalBlock () || parent . isScript () )
! body . isNormalBlock ()
n . isFunction () && ! NodeUtil . getFunctionBody ( n ) . isNormalBlock ()
{ checkArgument ( blockNode . isNormalBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
if ( n . isNormalBlock () ) { visitBlock ( n ) ; }
node . isFunction () && ! NodeUtil . getFunctionBody ( node ) . isNormalBlock ()
if ( ! n . isScript () && ! n . isNormalBlock () ) { return; }
if ( body . isNormalBlock () ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
if ( ! n . isNormalBlock () || ! n . hasChildren () || ! isGoogModuleCall ( n . getFirstChild () ) ) { return false ; }
{ checkArgument ( n . isNormalBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
n . isNormalBlock ()
checkState ( addingRoot . isNormalBlock () || addingRoot . isModuleBody () || addingRoot . isScript () ) ;
{ return n . isNormalBlock () && n . getParent () != null && n . getParent () . isFunction () ; }
checkState ( block . isNormalBlock () ) ;
node . isNormalBlock ()
{ return n . isRoot () || n . isScript () || n . isNormalBlock () || n . isModuleBody () ; }
if ( ! block . isNormalBlock () ) { return false ; }
if ( n . isEmpty () || ( n . isNormalBlock () && ! n . hasChildren () ) ) { return; }
next != null && next . isNormalBlock ()
! body . isNormalBlock () || body . hasChildren ()
if ( ! n . isFunction () || ! n . getLastChild () . isNormalBlock () ) { return; }
checkState ( jumpBlock . isNormalBlock () ) ;
checkState ( block . isNormalBlock () ) ;
checkState ( catchBody . isNormalBlock () ) ;
context . transpileUnmarkedBlock ( n . isNormalBlock () || n . isAddedBlock () ? n : IR . block ( n ) ) ;
checkState ( newGeneratorHoistBlock . isNormalBlock () , newGeneratorHoistBlock ) ;
c . isNormalBlock ()
c . isNormalBlock ()
checkState ( caseBody . isNormalBlock () , caseBody ) ;
! labeledStatement . isNormalBlock ()
last . isNormalBlock ()
scopeRoot . isNormalBlock () && scopeRoot . getParent () . isFunction ()
NodeUtil . isControlStructureCodeBlock ( n , c ) && ! c . isNormalBlock ()
n . isFunction () && parent != null && parent . isNormalBlock () && ! parent . getParent () . isFunction ()
if ( ! body . isNormalBlock () || ! body . hasOneChild () || ! body . getFirstChild () . isReturn () ) { return; }
s . isFunctionScope () && s . getRootNode () . getLastChild () . isNormalBlock ()
if ( n . isExprResult () || n . isNormalBlock () ) { return; }
checkState ( n . isNormalBlock () , n ) ;
! originalBody . isNormalBlock ()
for ( Node child : node . children () ) { if ( child . isNormalBlock () ) { blocks . add ( child ) ; } }
! isArrow && ! isSignature && ! bodyNode . isNormalBlock ()
! irNode . isNormalBlock ()
n . isFunction () && n . getParent () . isNormalBlock () && ! n . getGrandparent () . isFunction ()
{ return n . isNormalBlock () && n . hasChildren () && isReturnTypeNullable ( n . getParent () ) && ! hasSingleThrow ( n ) ; }
{ return node . getParent () . isExprResult () && node . getGrandparent () . isNormalBlock () && isClinitMethod ( node . getGrandparent () . getParent () ) ; }
checkState ( body . isNormalBlock () , body ) ;
{ checkState ( expr . isName () ) ; checkState ( body . isNormalBlock () ) ; return new Node ( Token.CATCH , expr , body ) ; }
checkState ( finallyBody . isNormalBlock () ) ;
checkState ( tryBody . isNormalBlock () ) ;
{ checkState ( body . isNormalBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
checkState ( body . isNormalBlock () ) ;
checkState ( body . isNormalBlock () ) ;
checkState ( body . isNormalBlock () ) ;
{ checkState ( body . isNormalBlock () ) ; checkState ( mayBeExpression ( cond ) ) ; return new Node ( Token.WHILE , cond , body ) ; }
{ checkState ( body . isNormalBlock () ) ; checkState ( mayBeExpression ( cond ) ) ; return new Node ( Token.DO , body , cond ) ; }
{ checkState ( mayBeExpression ( cond ) ) ; checkState ( then . isNormalBlock () ) ; return new Node ( Token.IF , cond , then ) ; }
checkState ( body . isNormalBlock () || mayBeExpression ( body ) ) ;
checkState ( body . isNormalBlock () ) ;
checkState ( body . getNext () == null && body . isNormalBlock () , body ) ;
{ Node functionBody = NodeUtil . getFunctionBody ( n ) ; if ( ! functionBody . isNormalBlock () ) { return; } }
boolean isVar = NodeUtil . isNameDeclaration ( parent ) && parent . getParent () . isNormalBlock () ;
isGoogScopeFunctionBody ( enclosingFunctionBody ) && scopeRoot . isNormalBlock () && ! scopeRoot . getParent () . isFunction ()
! n . getParent () . isScript () && ! n . getParent () . isNormalBlock ()
if ( newChild . isNormalBlock () ) { NodeUtil . tryMergeBlock ( newChild , false ) ; }
if ( node . isNormalBlock () ) { node . setToken ( Token.SCRIPT ) ; }
deleteWhitespaceBefore && parent != null && ( parent . isScript () || parent . isNormalBlock () )
checkState ( parentNode . isNormalBlock () , STRING_CONSTANT ) ;
checkState ( block . isNormalBlock () ) ;
! body . isNormalBlock ()
for ( ; ! currentParent . isScript () && ! currentParent . isNormalBlock () ; current = currentParent , currentParent = currentParent . getParent () ) {}
checkState ( ifBlock . isNormalBlock () , ifBlock ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( innerBlock . isNormalBlock () , innerBlock ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( block . isNormalBlock () ) ;
checkArgument ( node . isNormalBlock () ) ;
{ return getRootNode () . isNormalBlock () && getRootNode () . hasOneChild () && getRootNode () . getFirstChild () . isCatch () ; }
block . isNormalBlock () && block . getParent () . isTry () && block . getParent () . getFirstChild () == block
if ( parent . getParent () != null && parent . getParent () . isArrowFunction () && ! parent . isNormalBlock () ) { return false ; }
! setFunction . hasChildren () || ! setFunction . getLastChild () . isNormalBlock () || ! setFunction . getSecondChild () . isParamList ()
if ( ! getFunction . hasChildren () || ! getFunction . getLastChild () . isNormalBlock () ) { return false ; }
block . isNormalBlock ()
if ( ! favorsCommaOverSemiColon && ! block . isNormalBlock () ) { return false ; }
if ( ! n . isNormalBlock () || ! n . hasChildren () ) { return; }
! ( parent . isScript () || ( grandparent != null && grandparent . isFunction () && parent . isNormalBlock () ) )
JSType calleeTypeI = checkNotNull ( callee . getJSType () , callNode ) ;
assertFalse ( numbers . isSubtype ( EVAL_ERROR_TYPE ) ) ;
if ( options . getLanguageOut () . toFeatureSet () . contains ( ES6 ) ) { passes . add ( optimizeToEs6 ) ; }
if ( options.dartPass && ! options . getLanguageOut () . toFeatureSet () . contains ( ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
checkState ( options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES5 ) , STRING_CONSTANT ) ;
{ if ( outputTypes ) { return Format.TYPED ; } if ( prettyPrint || options . getLanguageOut () == LanguageMode.ECMASCRIPT6_TYPED ) { return Format.PRETTY ; } return Format.COMPACT ; }
if ( ! options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES5 ) ) { throw new InvalidOptionsException ( STRING_CONSTANT ) ; }
if ( ! languageOutIsAtLeast ( polyfill.polyfillVersion ) ) { traversal . report ( node , INSUFFICIENT_OUTPUT_VERSION_ERROR , name , compiler . getOptions () . getLanguageOut () . toString () ) ; }
{ if ( incrementalCheckMode == IncrementalCheckMode.GENERATE_IJS ) { return false ; } return this . quoteKeywordProperties || languageOut == LanguageMode.ECMASCRIPT3 ; }
{ return getLanguageIn () . toFeatureSet () . has ( feature ) && ! getLanguageOut () . toFeatureSet () . has ( feature ) ; }
{ return getLanguageIn () . toFeatureSet () . contains ( languageLevel ) && ! getLanguageOut () . toFeatureSet () . contains ( languageLevel ) ; }
{ checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
FeatureSet languageOutFeatures = compiler . getOptions () . getLanguageOut () . toFeatureSet () ;
FeatureSet languageOutFeatures = compiler . getOptions () . getLanguageOut () . toFeatureSet () ;
public void testArrowception () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testArrowFunctionInObject () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . compiler = compiler ; this . thisContextStack = new ArrayDeque <> () ; }
private LocalScopeBuilder ( TypedScope scope ) { super ( scope ) ; thisTypeForProperties = getThisTypeForCollectingProperties () ; }
assertThat ( compiler . hasErrors () ) . isFalse () ;
{ if ( inTypeSummary ( error ) ) { return CheckLevel.WARNING ; } return null ; }
{ this . outputFeatureSet = featureSet ; }
@ JsOverlay public final List < T > asList () { return new JsArrayList < T > ( this ) ; }
{ objectSet ( this , key , value ) ; return this ; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es7ToEs6Converter ( compiler ) ; }
GlobalScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder ( globalScope ) ;
String path = ModuleNames . escapePath ( moduleAddress ) ;
String path = ModuleNames . escapePath ( moduleAddress ) ;
{ return new ModulePath ( normalize ( ModuleNames . escapePath ( pathResolver . apply ( path ) ) , moduleRootPaths ) ) ; }
visitImport ( n ) ;
private void skipOctalDigits () { while ( isOctalDigit ( peekChar () ) ) { nextChar () ; } }
if ( ! currentInfo . isConstant () ) { currentInfo . setConstant ( true ) ; populated = true ; return true ; } else { return false ; }
isConst = nameNode . getParent () . isConst () || isExportLhs ( nameNode ) || ( jsdoc != null && jsdoc . hasConstAnnotation () )
assertThat ( jsdoc . isConstant () ) . isFalse () ;
return parent == null || ! NodeUtil . createsScope ( n ) ;
JSType ownerType
final Token type
final String name
final String name
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . getGoogNamespaces () ) . isEmpty () ;
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
{ currentModule . setModuleType ( ModuleType.COMMON_JS , t , n ) ; return; }
return shouldDescend ( n , parent ) ;
@ Nullable JSType ownerType
Token type
String name
String name
assertTypeEquals ( registry . createOptionalType ( STRING_TYPE ) , info . getParameterType ( STRING_CONSTANT ) ) ;
{ JSDocInfo info = parse ( STRING_CONSTANT ) ; assertTypeEquals ( registry . createOptionalType ( NUMBER_TYPE ) , info . getParameterType ( STRING_CONSTANT ) ) ; }
{ expandObjectLitAssignment ( t , root , export.scope ) ; return; }
@ JsMethod ( name = STRING_CONSTANT , namespace = STRING_CONSTANT )
{ validator . expectStringOrNumber ( t , n , leftType , STRING_CONSTANT ) ; }
return parent == null || ! NodeUtil . createsScope ( n ) ;
JSType ownerType
final Token type
final String name
final String name
@ JsMethod ( namespace = STRING_CONSTANT )
@ JsMethod ( name = STRING_CONSTANT , namespace = STRING_CONSTANT )
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , es6ModuleTranspiler , newMode , sourceUrl , path , sourceMapCache ) ; }
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , newMode , sourceUrl , path , sourceMapCache ) ; }
Node restRhs = newName ( this . rhsResultName ) ;
{ int baseHash = super . hashCode () ; if ( templateTypes . isEmpty () ) { return baseHash ; } return Objects . hash ( templateTypes , baseHash ) ; }
{ NodeTraversal . traverse ( compiler , rootNode , new CoverageInstrumentationCallback ( compiler , instrumentationData , reach ) ) ; }
abstract ImmutableSet.Builder < String > es6ImportSpecifiersBuilder ( ) ;
abstract ImmutableSet.Builder < String > requiredTypesBuilder ( ) ;
abstract ImmutableSet.Builder < String > googNamespacesBuilder ( ) ;
public void testSettersForbidden2 () { parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden4 () { parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden3 () { parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden2 () { parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
validateDefaultValue ( n , info ) ;
testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ;
options . setTranspileEs6ModulesToCjsModules ( true ) ;
@ Override public boolean isVarArgsParameter ( Node parameter ) { return parameter . isVarArgs () ; }
Node originalRoot = input . getAstRoot ( this ) ;
return input . getAstRoot ( this ) ;
findDeps . process ( input . getAstRoot ( this ) ) ;
Node root = input . getAstRoot ( this ) ;
return root ;
{ if ( ! isParsed () ) { parse ( compiler ) ; root . setInputId ( inputId ) ; } return root ; }
this . root = root ;
if ( ! options.checksOnly ) { passes . add ( es6RewriteRestAndSpread ) ; }
{ matchedNodeInfo = MatchedNodeInfo . create ( node , isInClosurizedFile ( node , new NodeMetadata ( compiler ) ) ) ; return this ; }
validateRest ( type , c ) ;
validateRest ( type , c ) ;
{ validateRest ( Token.PARAM_LIST , c ) ; }
public void disabled_testForOf4 () { testTypes ( STRING_CONSTANT ) ; }
AbstractCommandLineRunner () { this ( System.in , System.out , System.err ) ; }
boolean shouldDeclareOnGlobalThis = isGlobalVar && ( NodeUtil . isNameDeclaration ( parent ) || parent . isFunction () ) ;
JSType maybeThisType = info . getThisType () . evaluate ( scope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( scope , typeRegistry ) ; returnTypeInferred = false ; }
JSType maybeThisType = info . getThisType () . evaluate ( templateScope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( templateScope , typeRegistry ) ; returnTypeInferred = false ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
if ( ! compiler . hasHaltingErrors () ) { TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , features ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , new GeneratorFunctionsTranspiler () ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , new GeneratorFunctionsTranspiler () ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
checkState ( source . isFunction () , source ) ;
JSType returnType = explicitReturnExpected ( n ) ;
case RESOLVE_IMPORT_PATHS :
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new Es6RewriteImportPaths ( compiler ) ; }
SourceFile expectedEs6 = SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testSpreadLibInjection () { testSame ( STRING_CONSTANT ) ; assertThat ( getLastCompiler () . injected ) . containsExactly ( STRING_CONSTANT ) ; }
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new Es6RewriteClass ( compiler , true ) ; }
if ( this == that ) { return true ; }
public final boolean isGlobalThisType () { return this == registry . getNativeType ( JSTypeNative.GLOBAL_THIS ) ; }
public final boolean isUnresolvedOrResolvedUnknown () { return isNoResolvedType () || isNamedType () && isUnknownType () ; }
assertTrue ( objectType . getImplicitPrototype () == OBJECT_TYPE ) ;
{ JSType referencedType = getReferencedType () ; if ( referencedType == this ) { handleTypeCycle ( reporter ) ; } }
defineVar ( n ) ;
defineVars ( n ) ;
if ( context . isAsyncContext () ) { convertAsyncFunction ( context ) ; }
JSType maybeThisType = info . getThisType () . evaluate ( scope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( scope , typeRegistry ) ; returnTypeInferred = false ; }
MockControl < T > mockControl = new MockControl < T > ( mockitoState ) ;
MockitoBehaviorTest . class
public void andThrows ( Throwable throwable ) { behavior . lastInvocationWasStubbed () ; stubber . addThrowable ( throwable ) ; }
public void andReturn ( T value ) { behavior . lastInvocationWasStubbed () ; stubber . addReturnValue ( value ) ; }
VerifyingRecorderTest . class
VerifyingModeTest . class
{ stub ( mock . simpleMethod () ) . andThrows ( null ) ; }
{ stub ( mock . simpleMethod () ) . andThrows ( new Exception () ) ; }
VerifyingMode mode
{ return verify ( mock , VerifyingMode . times ( wantedNumberOfInvocations ) ) ; }
< T > T verify ( T mock , VerifyingMode verifyingMode ) ;
stub ( mock . size () ) . andThrows ( new RuntimeException () ) ;
stub ( mock . size () ) . andThrows ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . andThrows ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . andThrows ( error ) ;
stub ( reader . read () ) . andThrows ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . andThrows ( expected ) ;
stub ( mock . simpleMethod () ) . andThrows ( new RuntimeException () ) ;
state . verifyingStarted ( VerifyingMode . atLeastOnce () ) ;
assertNull ( Mockito.mockitoState . pullControlToBeStubbed () ) ;
MockitoStateImplTest . class
state = new MockitoStateImpl () ;
{ MockControl < T > control = MockUtil . getControl ( mock ) ; mockitoState . stubbingStarted () ; return control ; }
mockitoState . validateState () ;
mockitoState . validateState () ;
{ MockUtil . validateMock ( mock ) ; mockitoState . verifyingStarted ( mode ) ; return mock ; }
MockControl < T > mockControl = new MockControl < T > ( mockitoState , new MatchersBinder () ) ;
{ mockitoState . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable ) ) ; }
public void addReturnValue ( Object value ) { mockitoState . stubbingCompleted () ; addResult ( Result . createReturnResult ( value ) ) ; }
MockitoStateImpl state = new MockitoStateImpl () ;
assertNull ( Mockito.mockitoState . pullStubable () ) ;
void verify ( RegisteredInvocations registeredInvocations , InvocationMatcher wanted , OngoingVerifyingMode mode ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder ( STRING_CONSTANT ) ) ;
{ setStackTrace ( STRING_CONSTANT ) ; setCauseStackTrace ( STRING_CONSTANT ) ; remove () ; assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder () ) ; }
assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
@ Test ( expected = VerificationError . class )
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . oneArg ( true ) ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
@ Test ( expected = NumberOfInvocationsError . class )
@ Test ( expected = NumberOfInvocationsError . class )
verifyingRecorder . recordInvocation ( invocationMatcher ) ;
verifyingRecorder = new VerifyingRecorder < T > ( new AllInvocationsFinder () ) ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk () ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk () ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk () ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk () ;
InvocationsCalculator calculator = new InvocationsCalculatorImpl ( invocations ) ;
verifyingRecorder = new VerifyingRecorder < T > () ;
Invocation differentMethod = new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ;
Invocation differentMethod = new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ;
simpleMethod = new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ;
OngoingVerifyingModeTest . class
OngoingVerifyingMode mode
void verify ( InvocationsCalculator calculator , InvocationMatcher wanted , OngoingVerifyingMode mode ) ;
public void reset () { stubbingInProgress = false ; ongoingVerifyingMode = null ; invocationSequenceNumber = NUMBER_CONSTANT ; }
{ calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ; }
{ calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ; }
HasStackTrace firstUndesired = calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ;
{ return verify ( mock , OngoingVerifyingMode . times ( wantedNumberOfInvocations ) ) ; }
< T > T verify ( T mock , OngoingVerifyingMode ongoingVerifyingMode ) ;
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ) ;
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ) ;
OngoingVerifyingMode mode
OngoingVerifyingMode mode
OngoingVerifyingMode mode
OngoingVerifyingMode mode
OngoingVerifyingMode mode
OngoingVerifyingMode mode = OngoingVerifyingMode . atLeastOnce () ;
OngoingVerifyingMode mode = OngoingVerifyingMode . atLeastOnce () ;
OngoingVerifyingMode mode
OngoingVerifyingMode mode
for ( Object mock : mocks ) { MockUtil . validateMock ( mock ) ; strictOrderVerifier . addMockToBeVerifiedInOrder ( mock ) ; }
if ( i . isVerifiedInOrder () ) { continue; }
{ if ( mode . orderOfInvocationsMatters () ) { return chunker . getFirstUnverifiedInvocationChunk ( mode . getAllMocksToBeVerifiedInSequence () ) ; } else { return registeredInvocations ; } }
public boolean orderOfInvocationsMatters () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
if ( mocks.length == NUMBER_CONSTANT ) { Exceptions . mocksHaveToBePassedWhenCreatingStrictly () ; }
if ( stubable == null ) { Exceptions . missingMethodInvocation () ; }
if ( ! mocksToBeVerifiedSrictly . contains ( mock ) ) { Exceptions . strictlyRequiresFamiliarMock () ; }
if ( unverified != null ) { Exceptions . zeroInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
if ( unverified != null ) { Exceptions . noMoreInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
List < Verifier > verifiers = Arrays . asList ( new MissingInvocationVerifier () , new NumberOfInvocationsVerifier () ) ;
Result result
for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( wanted ) ) { return s . getResult () . answer () ; } }
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable ) ) ; }
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( VerificationMode . times ( NUMBER_CONSTANT ) ) ) ;
assertThat ( chunk , collectionHasExactlyInOrder ( simpleMethodInvocation , simpleMethodInvocationTwo ) ) ;
VerificationMode mode = VerificationMode . strict ( NUMBER_CONSTANT , Arrays . < Object > asList ( STRING_CONSTANT ) ) ;
strictly . verify ( mockOne , NUMBER_CONSTANT ) . varargsObject ( NUMBER_CONSTANT , textOne , textOne ) ;
strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( textOne ) ;
strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ;
{ strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; }
{ strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
{ strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ;
strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ;
{ strictly . verify ( two , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
strictly . verify ( two , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ;
verify ( map , NUMBER_CONSTANT ) . put ( anyObject () , anyObject () ) ;
verify ( list , NUMBER_CONSTANT ) . add ( STRING_CONSTANT ) ;
verify ( mock , NUMBER_CONSTANT ) . add ( STRING_CONSTANT ) ;
Mockito . verify ( mock , NUMBER_CONSTANT ) . add ( STRING_CONSTANT ) ;
{ Mockito . verify ( mock , NUMBER_CONSTANT ) . clear () ; fail () ; }
verify ( mockOne , NUMBER_CONSTANT ) . varargsObject ( NUMBER_CONSTANT , textOne , textOne ) ;
verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( textOne ) ;
verify ( mock , NUMBER_CONSTANT ) . oneArg ( two ) ;
{ return new VerificationMode ( wantedNumberOfInvocations , mocksToBeVerifiedStrictly ) ; }
assertNotNull ( STRING_CONSTANT , verifier.calculator ) ;
void verify ( InvocationsCalculator calculator , InvocationMatcher wanted , VerificationMode mode ) ;
verifier . verify ( calculatorStub , wanted , mode ) ;
verifier . verify ( calculatorStub , wanted , mode ) ;
verifiers = Arrays . asList ( new MissingInvocationVerifier () , new NumberOfInvocationsVerifier ( new Reporter () ) , new NoMoreInvocationsVerifier () )
assertNotNull ( STRING_CONSTANT , verifierStub.calculator ) ;
assertThat ( verifierStub.calculator . getInvocations () , collectionHasExactlyInOrder ( differentMethod . getInvocation () ) ) ;
assertThat ( verifierStub.calculator . getInvocations () , collectionHasExactlyInOrder ( simpleMethod ) ) ;
{ this . invocations = invocations ; return returnedByCalculator ; }
{ returnedByCalculator = null ; verifier . verify ( null , null , VerificationMode . noMoreInteractions () ) ; }
{ VerificationMode . times ( - NUMBER_CONSTANT ) ; fail () ; }
if ( mode . numberOfInvocationsMode () ) { return; }
if ( mode . isExplicit () ) { return; }
{ if ( mode . isStrict () ) { return chunker . getFirstUnverifiedInvocationChunk ( mode . getAllMocksToBeVerifiedInSequence () ) ; } else { return registeredInvocations ; } }
if ( mode . isExplicit () ) { marker . markInvocationsAsVerified ( invocations , wanted , mode ) ; }
public boolean exactNumberOfInvocationsMode () { return ! atLeastOnceMode () && isExplicit () ; }
public boolean missingMethodMode () { return isExplicit () && ( atLeastOnceMode () || wantedInvocationCount == NUMBER_CONSTANT ) ; }
public boolean isExplicit () { return verification == Verification.EXPLICIT ; }
public boolean isStrict () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
public boolean atLeastOnceMode () { return wantedInvocationCount == null ; }
if ( mode . isStrict () ) { markVerifiedStrictly ( invocations ) ; } else { markVerified ( wanted , invocations ) ; }
public void say ( String message ) ;
public void say ( Object message ) ;
public String throwsError ( int count ) throws Error ;
public String throwsIOException ( int count ) throws IOException ;
public String throwsNothing ( boolean value ) ;
public boolean withBooleanVarargs ( int value , boolean . . . b ) ;
if ( mocks.length == NUMBER_CONSTANT ) { reporter . mocksHaveToBePassedWhenCreatingStrictly () ; }
{ MockControl < T > control = MockUtil . getControl ( mock ) ; mockingProgress . stubbingStarted () ; return control ; }
{ MockUtil . validateMock ( mock ) ; mockingProgress . verificationStarted ( mode ) ; return mock ; }
MockControl < T > mockControl = new MockControl < T > ( mockingProgress , new MatchersBinder () ) ;
assertNull ( Mockito.mockingProgress . pullStubable () ) ;
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
MockControlTest . class
for ( Object mock : mocks ) { MockUtil . getControl ( mock ) . verifyNoMoreInteractions () ; }
{ List < Invocation > invocationsOfSingleMock = MockUtil . getControl ( mock ) . getRegisteredInvocations () ; allInvocations . addAll ( invocationsOfSingleMock ) ; }
@ Test ( expected = MockitoException . class ) public void shouldScreamWhenNullPassed () { getControl ( null ) ; }
@ Test ( expected = NotAMockException . class ) public void shouldScreamWhenNotAMockPassed () { getControl ( STRING_CONSTANT ) ; }
try { getControl ( o ) ; fail () ; } catch ( NotAMockException e ) {}
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( VerificationError e ) {}
{ mock . clear () ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {} }
{ mock . clear () ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {} }
VerificationError e
VerificationError e
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
{ UndesiredInvocation cause = buildUndesiredInvocationCause ( actualInvocationStackTrace , STRING_CONSTANT , undesired ) ; throw new VerificationError ( join ( STRING_CONSTANT ) , cause ) ; }
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError expected ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationError e ) {}
Invocation unverified = calculator . getFirstUnverified ( invocations ) ;
public NoMoreInvocationsVerifier () { this ( new InvocationsCalculator () , new Reporter () ) ; }
Invocation actual = calculator . findActualInvocation ( invocations , wanted ) ;
int actualCount = calculator . countActual ( invocations , wanted ) ;
public MissingInvocationVerifier () { this ( new InvocationsCalculator () , new Reporter () ) ; }
{ calculator.invocationToReturn = null ; verifier . verify ( null , null , VerificationMode . noMoreInteractions () ) ; }
{ verifier . verify ( invocations , wanted , times ( NUMBER_CONSTANT ) ) ; assertSame ( wanted , calculatorStub.wanted ) ; }
@ Test public void shouldPassBecauseActualInvocationFound () { calculatorStub.actualCountToReturn = NUMBER_CONSTANT ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsCalculator () ) ; }
Invocation unverified = analyzer . getFirstUnverified ( invocations ) ;
return actualbyName != null ? actualbyName : getFirstUnverified ( invocations ) ;
{ verify ( sub ) . say ( CrazyMatchers . contains ( STRING_CONSTANT ) ) ; fail () ; }
mockingProgress . reportStubable ( this ) ;
OngoingStubbing pullStubable ( ) ;
void reportStubable ( OngoingStubbing ongoingStubbing ) ;
VerificationMode mode
VerificationModeTest . class
VerificationMode mode
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationMode mode ) ;
verifier . verify ( invocations , null , VerificationMode . noMoreInteractions () ) ;
VerificationMode mode
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
{ return VerificationMode . times ( wantedNumberOfInvocations ) ; }
{ return VerificationMode . atLeastOnce () ; }
state . verificationStarted ( VerificationMode . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationMode . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationMode . atLeastOnce () ) ;
VerificationMode mode = VerificationMode . times ( NUMBER_CONSTANT ) ;
VerificationMode mode
public void verify ( VerificationMode mode ) { verify ( null , mode ) ; }
VerificationMode mode
VerificationMode mode
{ analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ; }
{ analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ; }
HasStackTrace firstUndesired = analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ;
VerificationMode mode
VerificationMode mode
{ VerificationMode mode = VerificationMode . noMoreInteractions () ; recorder . verify ( mode ) ; assertNull ( markerStub.mode ) ; }
VerificationMode mode = new VerificationModeBuilder () . strict () ;
VerificationMode mode = VerificationMode . atLeastOnce () ;
VerificationMode mode = VerificationMode . atLeastOnce () ;
VerificationMode mode
VerificationMode verificationMode = mockingProgress . pullVerificationMode () ;
VerificationMode mode = new VerificationModeBuilder () . strict () ;
VerificationMode mode = new VerificationModeBuilder () . strict () ;
public MissingInvocationVerifier () { this ( new InvocationsAnalyzer () , new Reporter () ) ; }
{ setStackTrace ( STRING_CONSTANT ) ; setCauseStackTrace ( STRING_CONSTANT ) ; remove () ; assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder () ) ; }
{ analyzerStub.actualCountToReturn = NUMBER_CONSTANT ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsAnalyzer () ) ; }
assertEquals ( verifierStub.mode , mode ) ;
three . simpleMethod () ;
public VerificationModeImpl strict () { return VerificationModeImpl . strict ( null , Arrays . asList ( new Object () ) ) ; }
StackTrackeFilteringTest . class
{ Mockito . verify ( mock , times ( NUMBER_CONSTANT ) ) . clear () ; fail () ; }
@ Before public void setup () { mock = Mockito . mock ( LinkedList . class ) ; }
catch ( TooLittleActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
catch ( VerificationError e ) {}
wantedInvocation . matchesMockArgsAndMethodNameButMethodNotEqual ( actualInvocation )
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
{ mock . clear () ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {} }
{ mock . clear () ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {} }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
try { verifyNoMoreInteractions ( mockTwo ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
catch ( TooManyActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
@ Test ( expected = VerificationError . class )
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
NoInteractionsWantedError e
NoInteractionsWantedError e
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
VerificationError e
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooManyActualInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooManyActualInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooLittleActualInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
catch ( NoInteractionsWantedError e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWantedError e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { verifyNoMoreInteractions ( mockTwo ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
catch ( TooManyActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocationsError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
VerificationError error
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
TooManyActualInvocationsError e
TooLittleActualInvocationsError e
catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
catch ( VerificationError e ) {}
@ Test ( expected = VerificationError . class )
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
throw new NoInteractionsWantedError ( join ( STRING_CONSTANT ) , cause ) ;
public void wantedButNotInvoked ( String wanted ) { throw new VerificationError ( join ( STRING_CONSTANT , wanted ) ) ; }
throw new VerificationError ( join ( STRING_CONSTANT , STRING_CONSTANT , wanted ) , cause ) ;
VerificationError e
VerificationError e
@ Test ( expected = TooLittleActualInvocationsError . class )
try { verify ( mock ) . oneArg ( same ( three ) ) ; fail () ; } catch ( VerificationError e ) {}
try { verify ( mock ) . clear () ; fail () ; } catch ( TooManyActualInvocationsError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationError expected ) {}
@ Test ( expected = VerificationError . class ) public void shouldFailVerification ( ) throws Exception { verify ( mock ) . clear () ; }
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
@ Test ( expected = VerificationError . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = VerificationError . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
catch ( TooLittleActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
@ Test ( expected = TooLittleActualInvocationsError . class )
@ Test ( expected = TooManyActualInvocationsError . class )
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
try { strictly . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
TooLittleActualInvocationsError e
TooManyActualInvocationsError e
TooManyActualInvocationsError e
VerificationError e
VerificationError e
chunked = chunker . chunk ( Collections . < Integer > emptyList () , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
List < ObjectsChunk < Integer > > chunked = chunker . chunk ( asList ( NUMBER_CONSTANT ) , new EqualitySeer () ) ;
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
catch ( TooManyActualInvocations e ) {}
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocations e ) {}
try { strictly . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
strictly . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ;
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
@ Test ( expected = InvocationDiffersFromActual . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = InvocationDiffersFromActual . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooLittleActualInvocations e ) {}
@ Test ( expected = TooLittleActualInvocations . class )
@ Test ( expected = TooManyActualInvocations . class )
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsAnalyzer () , new ActualInvocationsFinder () ) ; }
public boolean strictMode () { return ! mocksToBeVerifiedStrictly . isEmpty () ; }
Invocation unverified = analyzer . findFirstUnverified ( invocations ) ;
public NoMoreInvocationsVerifier () { this ( new InvocationsAnalyzer () , new Reporter () ) ; }
{ Invocation similar = analyzer . findSimilarInvocation ( invocations , wanted , mode ) ; reportMissingInvocationError ( wanted , similar ) ; }
public MissingInvocationVerifier () { this ( new InvocationsAnalyzer () , new ActualInvocationsFinder () , new Reporter () ) ; }
{ analyzer.invocationToReturn = null ; verifier . verify ( null , null , VerificationModeImpl . noMoreInteractions () ) ; }
analyzerStub.similarToReturn = actualInvocation ;
analyzerStub.similarToReturn = null ;
{ verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ; assertSame ( invocations , analyzerStub.invocations ) ; }
List < Invocation > chunk = finder . findFirstStrictlyUnverified ( invocations , wanted ) ;
List < Invocation > chunk = finder . findFirstStrictlyUnverified ( invocations , wanted ) ;
ActualInvocationsFinder finder
public NoMoreInvocationsVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
ActualInvocationsFinder finder
public MissingInvocationVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
finder = new ActualInvocationsFinderStub () ;
finderStub = new ActualInvocationsFinderStub () ;
finderStub = new ActualInvocationsFinderStub () ;
ActualInvocationsFinder finder
public StrictlyNumberOfInvocationsVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
if ( mode . strictMode () ) { invocations = invocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedStrictly () ) ; } else { invocations = registeredInvocations ; }
ActualInvocationsFinder finder
public NumberOfInvocationsVerifier () { this ( new Reporter () , new ActualInvocationsFinder () ) ; }
ActualInvocationsFinder finder
public StrictlyMissingInvocationVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
List < Object > mocksToBeVerifiedStrictly
List < Object > mocksToBeVerifiedStrictly
HasStackTrace lastInvocation = getLastSafely ( chunk ) ;
HasStackTrace lastInvocation = getLastSafely ( actualInvocations ) ;
stub ( mock . booleanReturningMethod ( NUMBER_CONSTANT ) ) . andReturn ( true ) ;
stub ( mock . simpleMethod () ) . andThrow ( new RuntimeException () ) ;
{ stub ( mock . simpleMethod () ) . andThrow ( null ) ; }
{ stub ( mock . simpleMethod () ) . andThrow ( new Exception () ) ; }
return handler ;
stub ( mock . size () ) . andThrow ( new RuntimeException () ) ;
stub ( mock . size () ) . andThrow ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( error ) ;
stub ( reader . read () ) . andThrow ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( expected ) ;
stub ( mock . oneArg ( anyString () ) ) . andReturn ( STRING_CONSTANT ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . andReturn ( Boolean.FALSE ) ;
mockingProgress . reportStubbable ( this ) ;
OngoingStubbing pullStubbable ( ) ;
void reportStubbable ( OngoingStubbing ongoingStubbing ) ;
strictly = createStrictOrderVerifier ( mock , mockTwo ) ;
strictly = createStrictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
{ Strictly strictly = createStrictOrderVerifier ( mock ) ; strictly . verify ( null ) ; fail () ; }
{ createStrictOrderVerifier () ; fail () ; }
Strictly strictly = createStrictOrderVerifier ( mock ) ;
{ Strictly strictly = createStrictOrderVerifier ( mock ) ; strictly . verify ( mockTwo ) . simpleMethod () ; }
@ Test ( expected = MockitoException . class ) public void shouldNotCreateStrictlyWithoutMocks () { createStrictOrderVerifier () ; }
Strictly strictly = createStrictOrderVerifier ( mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mock ) ;
Strictly strictly = createStrictOrderVerifier ( mockDatabase ) ;
strictly = createStrictOrderVerifier ( mockOne ) ;
strictly = createStrictOrderVerifier ( mockOne ) ;
strictly = createStrictOrderVerifier ( mockOne , mockThree ) ;
strictly = createStrictOrderVerifier ( mock , mockTwo ) ;
strictly = createStrictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
strictly = createStrictOrderVerifier ( mockOne ) ;
strictly = createStrictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
strictly = createStrictOrderVerifier ( one , two , three ) ;
Object actual
Object argument
{ for ( IArgumentMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < IArgumentMatcher > matchers ) { this . matchers = matchers ; }
List < IArgumentMatcher > matchers
public Not ( IArgumentMatcher first ) { this . first = first ; }
public void reportMatcher ( IArgumentMatcher matcher ) { matcherStack . push ( matcher ) ; }
{ for ( IArgumentMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < IArgumentMatcher > matchers ) { this . matchers = matchers ; }
List < IArgumentMatcher > matchers
List < IArgumentMatcher > matchers
return findFirstUnverified ( invocations , wanted . getInvocation () . getMock () ) ;
{ return LastArguments . instance () . reportMatcher ( matcher ) . < T > nullValue () ; }
{ return LastArguments . instance () . reportMatcher ( new StartsWith ( prefix ) ) . < String > nullValue () ; }
public static String anyString () { isA ( String . class ) ; return null ; }
{ LastArguments . instance () . reportNot () ; return false ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return first ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return null ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return first ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return null ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return false ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return null ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return false ; }
{ return reportMatcher ( matcher ) . < T > nullValue () ; }
public static double doubleThat ( CustomMatcher < Double > matcher ) { return reportMatcher ( matcher ) . doubleValue () ; }
public static float floatThat ( CustomMatcher < Float > matcher ) { return reportMatcher ( matcher ) . floatValue () ; }
public static long longThat ( CustomMatcher < Long > matcher ) { return reportMatcher ( matcher ) . longValue () ; }
public static int intThat ( CustomMatcher < Integer > matcher ) { return reportMatcher ( matcher ) . intValue () ; }
public static short shortThat ( CustomMatcher < Short > matcher ) { return reportMatcher ( matcher ) . shortValue () ; }
public static byte byteThat ( CustomMatcher < Byte > matcher ) { return reportMatcher ( matcher ) . byteValue () ; }
public static boolean booleanThat ( CustomMatcher < Boolean > matcher ) { return reportMatcher ( matcher ) . booleanValue () ; }
public static char charThat ( CustomMatcher < Character > matcher ) { return reportMatcher ( matcher ) . charValue () ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . < String > nullValue () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . < String > nullValue () ; }
{ return reportMatcher ( new Matches ( regex ) ) . < String > nullValue () ; }
{ return reportMatcher ( new Contains ( substring ) ) . < String > nullValue () ; }
public static Object notNull () { return reportMatcher ( NotNull.NOT_NULL ) . nullValue () ; }
public static Object isNull () { return reportMatcher ( Null.NULL ) . nullValue () ; }
{ return reportMatcher ( new Same ( value ) ) . nullValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . nullValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . shortValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . longValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . intValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . floatValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . doubleValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . charValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . byteValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . booleanValue () ; }
{ return reportMatcher ( new InstanceOf ( clazz ) ) . nullValue () ; }
public static Object anyObject () { return reportMatcher ( Any.ANY ) . nullValue () ; }
public static short anyShort () { return reportMatcher ( Any.ANY ) . shortValue () ; }
public static double anyDouble () { return reportMatcher ( Any.ANY ) . doubleValue () ; }
public static float anyFloat () { return reportMatcher ( Any.ANY ) . floatValue () ; }
public static long anyLong () { return reportMatcher ( Any.ANY ) . longValue () ; }
public static int anyInt () { return reportMatcher ( Any.ANY ) . intValue () ; }
public static char anyChar () { return reportMatcher ( Any.ANY ) . charValue () ; }
public static byte anyByte () { return reportMatcher ( Any.ANY ) . byteValue () ; }
public static boolean anyBoolean () { return reportMatcher ( Any.ANY ) . booleanValue () ; }
public boolean booleanValue () { return false ; }
public < T > T nullValue () { return null ; }
public short shortValue () { return NUMBER_CONSTANT ; }
public byte byteValue () { return NUMBER_CONSTANT ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnChar () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnNull () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnFalse () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnNull () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnChar () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnFalse () ; }
{ return LastArguments . instance () . reportNot () . returnNull () ; }
{ return LastArguments . instance () . reportOr () . returnNull () ; }
{ return LastArguments . instance () . reportAnd () . returnNull () ; }
{ return reportMatcher ( new Find ( regex ) ) . returnNull () ; }
{ return reportMatcher ( new Same ( value ) ) . returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new InstanceOf ( clazz ) ) . returnNull () ; }
strictly = strictly ( mock , mockTwo ) ;
assertFalse ( strict ( NUMBER_CONSTANT , asList ( new Object () ) ) . exactNumberOfInvocationsMode () ) ;
List < Invocation > unverified = ListUtil . filter ( invocations , new RemoveVerifiedStrictly () ) ;
strictly = strictly ( mock , mockTwo ) ;
detects ( new OnStrictVerify () , UnfinishedVerificationException . class ) ;
detects ( new OnStrictVerify () , UnfinishedStubbingException . class ) ;
detects ( new OnStrictVerify () , UnfinishedStubbingException . class ) ;
inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ;
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
@ Test ( expected = InvocationDiffersFromActual . class )
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
catch ( VerifcationInOrderFailed e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
@ Test ( expected = VerifcationInOrderFailed . class )
@ Override public void wantedButNotInvoked ( String wanted ) { this . wanted = wanted ; }
@ Test ( expected = VerifcationInOrderFailed . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { inOrder . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = VerifcationInOrderFailed . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
finderStub.firstUnverifiedChunkToReturn . add ( invocation ) ;
finderStub.firstUnverifiedChunkToReturn . addAll ( asList ( first , second ) ) ;
finderStub.firstUnverifiedChunkToReturn . addAll ( asList ( first , second ) ) ;
finderStub.firstUnverifiedChunkToReturn . add ( differentMethod ) ;
assertTrue ( finderStub.firstUnverifiedChunkToReturn . isEmpty () ) ;
List < Invocation > chunk = finder . findValidMatchingChunk ( invocations , wanted , mode ) ;
{ reporter . wantedButNotInvoked ( wanted . toString () ) ; }
@ Override public void wantedButNotInvoked ( Object wanted ) { this . wanted = wanted ; }
assertEquals ( wanted . toString () , reporterStub.wanted ) ;
Object wanted
public void wantedButNotInvoked ( Object wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted . toString () ) ) ; }
@ Override public void wantedButNotInvoked ( Object wanted ) { this . wanted = wanted ; }
Object wanted
if ( unverified != null ) { reporter . noMoreInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
String undesired
assertEquals ( firstUnverified . toString () , reporterStub.undesired ) ;
String wanted
String wanted
assertEquals ( wanted . toString () , reporterStub.wanted ) ;
assertEquals ( wanted . toString () , reporterStub.wanted ) ;
Object previous
Object previous
Invocation previousInOrder = finder . findPreviousInOrder ( invocations , wanted ) ;
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
@ Test ( expected = VerifcationInOrderFailed . class )
catch ( VerifcationInOrderFailed e ) {}
@ Test ( expected = VerifcationInOrderFailed . class )
try { inOrder . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
@ Test ( expected = VerifcationInOrderFailed . class )
@ Test ( expected = VerifcationInOrderFailed . class )
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
public String printActual () { return actual ; }
public String printWanted () { return wanted ; }
stub ( mockCalculator . countArticlesInPolish ( STRING_CONSTANT ) ) . toReturn ( NUMBER_CONSTANT ) ;
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { REPORTER . mocksHaveToBePassedAsArguments () ; } }
CustomMatcher < T > matcher
{ for ( ArgumentMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
List < ArgumentMatcher > matchers
public Not ( ArgumentMatcher first ) { this . first = first ; }
public ReturnValues reportMatcher ( ArgumentMatcher matcher ) { matcherStack . push ( matcher ) ; return new ReturnValues () ; }
{ for ( ArgumentMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
private static ReturnValues reportMatcher ( ArgumentMatcher < > matcher ) { return LastArguments . instance () . reportMatcher ( matcher ) ; }
CustomMatcher < Double > matcher
CustomMatcher < Float > matcher
CustomMatcher < Long > matcher
CustomMatcher < Integer > matcher
CustomMatcher < Short > matcher
CustomMatcher < Byte > matcher
CustomMatcher < Boolean > matcher
CustomMatcher < Character > matcher
List < ArgumentMatcher > matchers
T actual
List < ArgumentMatcher > matchers
if ( mode . wantedCountIsZero () && noMatchFound ) { return; }
catch ( TooManyActualInvocations e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( TooManyActualInvocations e ) {}
catch ( InvocationDiffersFromActual e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
@ Test ( expected = InvocationDiffersFromActual . class )
@ Test ( expected = InvocationDiffersFromActual . class )
@ Test ( expected = InvocationDiffersFromActual . class )
@ Test ( expected = InvocationDiffersFromActual . class )
catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
InvocationDiffersFromActual e
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual expected ) {}
IncorectBindingPuzzleFixedTest . class
Printable undesired
Printable wanted
Printable wanted
Printable wanted
@ Override public void wantedButNotInvoked ( Printable wanted ) { this . wanted = wanted ; }
Printable undesired
Printable wanted
Printable wanted
Printable wanted
Printable wanted
Printable wanted
public void wantedButNotInvoked ( Printable wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted . toString () ) ) ; }
@ Override public void wantedButNotInvoked ( Printable wanted ) { this . wanted = wanted ; }
if ( matchers == null ) { this . matchers = buildMatchers ( invocation ) ; } else { this . matchers = matchers ; }
mock . simpleMethod ( null , null ) ;
argumentsMatch ( actual . getArguments () )
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferentException e
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferentException e
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferentException e
catch ( ArgumentsAreDifferentException e ) {}
catch ( ArgumentsAreDifferentException e ) {}
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferentException e
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( ArgumentsAreDifferentException expected ) {}
ArgumentsAreDifferentException e
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
assertTrue ( invocation . isSimilarTo ( overloadedInvocation ) ) ;
assertFalse ( invocation . isSimilarTo ( overloadedInvocation ) ) ;
assertFalse ( simpleMethod . isSimilarTo ( onDifferentMock ) ) ;
assertFalse ( simpleMethod . isSimilarTo ( verified ) ) ;
invocation . getMock () . equals ( actual . getMock () ) && invocation . getMethod () . equals ( actual . getMethod () ) && argumentsMatch ( actual )
assertTrue ( STRING_CONSTANT + value . getMessage () + STRING_CONSTANT + text , cause . getMessage () . contains ( text ) ) ;
assertTrue ( STRING_CONSTANT + value . getMessage () + STRING_CONSTANT + text , ( ( Throwable ) value ) . getMessage () . contains ( text ) ) ;
assertThat ( mock . toString () , equalTo ( STRING_CONSTANT ) ) ;
assertThat ( mock . toString () , equalTo ( STRING_CONSTANT ) ) ;
if ( verificationMode != null ) { verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return EmptyReturnValues . emptyValueFor ( method . getReturnType () ) ; }
if ( mode . inOrderMode () ) { invocations = globalInvocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedInOrder () ) ; } else { invocations = registeredInvocations ; }
EmptyReturnValuesTest . class
return MockitoConfiguration . emptyValues () . valueFor ( invocation ) ;
if ( verificationMode != null ) { verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . emptyValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
MockitoSampleTest . class
@ After public void resetDefaultReturnValues () { MockitoConfiguration . resetCustomReturnValues () ; myDefaultReturnValues . clearSmartStubs () ; }
return MockitoConfiguration . defaultReturnValues () . valueFor ( invocation ) ;
@ Before public void configureDefaultReturnValues () { myDefaultReturnValues = new MyDefaultReturnValues () ; MockitoConfiguration . setCustomReturnValues ( myDefaultReturnValues ) ; }
{ verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . defaultReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
@ Before public void configureDefaultReturnValues () { MockitoConfiguration . setCustomReturnValues ( new MyDefaultReturnValues () ) ; }
invocation . isToString ()
Invocation invocation
Invocation invocation
Invocation invocation
Invocation invocation
return emptyValueFor ( returnType ) ;
assertEquals ( CHAR_CONS , mock . charReturningMethod ( NUMBER_CONSTANT ) ) ;
{ FakeReturnValues fakeReturnValues = getFakeReturnValues () ; fakeReturnValues . configure ( mocks ) ; }
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertThat ( m . getMatchers () , collectionHasExactlyInOrder ( new Equals ( STRING_CONSTANT ) ) ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
{ return MockUtil . createMock ( classToMock , MOCKING_PROGRESS ) ; }
String mockDescription = STRING_CONSTANT + MockNamer . nameForMock ( mock ) + STRING_CONSTANT + mock . hashCode () ;
MockHandler handler = new MockHandler ( state , new ExceptionThrowingBinder () ) ;
assertThat ( filtered , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
stub ( mock . oneArg ( not ( contains ( STRING_CONSTANT ) ) ) ) . toReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( and ( contains ( STRING_CONSTANT ) , contains ( STRING_CONSTANT ) ) ) ) . toReturn ( STRING_CONSTANT ) ;
try { getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List mock = Mockito . mock ( List . class ) ; assertNotNull ( getMockHandler ( mock ) ) ; }
{ f . set ( testClass , Mockito . mock ( f . getType () ) ) ; }
assertThat ( verifierStub.invocations , collectionHasExactlyInOrder ( simpleMethod , differentMethod . getInvocation () ) ) ;
assertThat ( verifierStub.invocations , collectionHasExactlyInOrder ( simpleMethod ) ) ;
assertThat ( STRING_CONSTANT , e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ;
if ( mode . inOrderMode () ) { invocations = globalInvocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedInOrder () ) ; } else { invocations = getRegisteredInvocations () ; }
{ return Modifier . isFinal ( clazz . getModifiers () ) ; }
{ if ( mocksReturningFakes . contains ( invocation . getMock () ) ) { return returnFake ( invocation ) ; } else { return defaultValueFor ( invocation ) ; } }
return MockitoConfiguration . instance () . getReturnValues () . valueFor ( invocation ) ;
MockitoConfiguration config = MockitoConfiguration . instance () ;
{ verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . instance () . getReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
{ super . run ( notifier ) ; MockitoConfiguration . instance () . resetReturnValues () ; }
{ Object test = super . createTest () ; MockitoConfiguration . instance () . setReturnValues ( new FriendlyReturnValues () ) ; return test ; }
{ super ( invocation . getInvocation () , invocation . getMatchers () ) ; this . result = result ; }
private Result ( IAnswer value ) { this . value = value ; }
public void addConsecutiveReturnValue ( Object value ) { stubbed . getFirst () . addResult ( Result . createReturnResult ( value ) ) ; }
ResultTest . class
{ validateThrowable ( throwable ) ; stubbed . getFirst () . addAnswer ( Result . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
Result result
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
Answer result = AnswerFactory . createThrowResult ( new RuntimeException () , filterStub ) ;
{ AnswerFactory . createThrowResult ( new RuntimeException () , new StackTraceFilter () ) . answer () ; }
{ Answer result = AnswerFactory . createReturnResult ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
{ validateThrowable ( throwable ) ; stubbed . getFirst () . addAnswer ( AnswerFactory . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( AnswerFactory . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
assertEquals ( null , mock . oneArg ( null ) ) ;
assertEquals ( null , mock . oneArg ( null ) ) ;
{ Answer result = AnswerFactory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
Answer answer = AnswerFactory . createReturningAnswer ( value ) ;
{ return isA ( String . class ) ; }
public String toString () { return toString ( argumentsToMatchers () ) ; }
{ result . answer () ; fail () ; }
{ factory . createThrowingAnswer ( new RuntimeException () , null ) . answer () ; }
{ Answer result = factory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) { return s . answer () ; } }
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , not ( notNull () ) , eq ( STRING_CONSTANT ) ) ) . toReturn ( STRING_CONSTANT ) ;
{ try { stubber . addThrowable ( null ) ; fail () ; } catch ( MockitoException e ) {} }
stubber . addReturnValue ( STRING_CONSTANT ) ;
{ state . stubbingStarted () ; stubber . addReturnValue ( STRING_CONSTANT ) ; state . validateState () ; }
{ stubber . addThrowable ( new Exception () ) ; fail () ; }
Answer < T > answer
Answer < T > answer
Answer < T > answer
{ stubber . addConsecutiveThrowable ( throwable ) ; return this ; }
{ stubber . addConsecutiveReturnValue ( value ) ; return this ; }
Answer < T > answer
{ verifyingRecorder . eraseLastInvocation () ; stubber . addThrowable ( throwable ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addReturnValue ( value ) ; return new ConsecutiveStubbing () ; }
{ stubber . addThrowableForVoidMethod ( throwable ) ; return this ; }
try { stubber . resultFor ( simpleMethod ) ; fail () ; } catch ( MyException e ) {}
public void setMock ( Object mock ) {}
ClassWithDodgyConstructor mock = factory . createMock ( ClassWithDodgyConstructor . class , new MockAwareStub () ) ;
ClassWithoutConstructor proxy = factory . createMock ( ClassWithoutConstructor . class , new MockAwareStub () ) ;
SomeInterface proxy = factory . createMock ( SomeInterface . class , new MockAwareStub () ) ;
void setMock ( T mock ) ;
{ return MockUtil . createMock ( classToMock , null , MOCKING_PROGRESS ) ; }
return delegate . intercept ( proxy , method , args , null ) ;
stubber = new Stubber ( mockingProgress ) ;
{ MOCKING_PROGRESS . stubbingStarted () ; return new MethodSelectorImpl ( null ) ; }
{ MOCKING_PROGRESS . stubbingStarted () ; return new MethodSelectorImpl ( toBeReturned ) ; }
@ Before public void setUp () { StateResetter . reset () ; mock = Mockito . mock ( IMethods . class ) ; }
{ StateResetter . reset () ; mock = mock ( IMethods . class ) ; }
{ doReturn ( STRING_CONSTANT ) . when ( null ) . toString () ; fail () ; }
{ stubber . addConsecutiveAnswer ( answer ) ; return this ; }
{ stubber . addConsecutiveAnswer ( new ThrowsException ( throwable ) ) ; return this ; }
{ stubber . addConsecutiveAnswer ( new Returns ( value ) ) ; return this ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( new ThrowsException ( throwable ) ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( new Returns ( value ) ) ; return new ConsecutiveStubbing () ; }
{ stubber . addAnswerForVoidMethod ( answer ) ; return this ; }
public VoidMethodStubbable < T > toReturn () { stubber . addAnswerForVoidMethod ( new Returns () ) ; return this ; }
{ stubber . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
this . stubber = new Stubber ( mockingProgress ) ;
return handler . voidMethodStubbable () ;
try { mockitoStubber . addVoidMethodForStubbing ( new InvocationMatcher ( simpleMethod ) ) ; fail () ; } catch ( MockitoException e ) {}
mockitoStubber . addVoidMethodForStubbing ( new InvocationMatcher ( simpleMethod ) ) ;
@ SuppressWarnings ( STRING_CONSTANT ) public void setAnswersForStubbing ( List < Answer > answers ) { mockitoStubber . addAnswersForVoidMethod ( answers ) ; }
{ return MockUtil . createMock ( classToMock , name , MOCKING_PROGRESS , null ) ; }
doReturn () . doReturn () . doThrow ( new RuntimeException () ) . when ( mock ) . voidMethod () ;
{ validator . validate ( new ReturnsVoid () , new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ; }
{ validator . validate ( new ReturnsVoid () , new InvocationBuilder () . simpleMethod () . toInvocation () ) ; }
Stubber doReturn ( ) ;
ReturnsVoid answer
if ( answer instanceof DoesNothing ) { validateVoidReturn ( ( DoesNothing ) answer , invocation ) ; }
detects ( new OnDoReturn () , UnfinishedVerificationException . class ) ;
detects ( new OnDoReturn () , UnfinishedStubbingException . class ) ;
detects ( new OnDoReturn () , UnfinishedStubbingException . class ) ;
enhancer . setClassLoader ( MockFactory . class . getClassLoader () ) ;
AtLeastOnceVerificationTest . class
Invocation invocation
try { mockitoStubber . getResultFor ( simpleMethod ) ; fail () ; } catch ( MyException e ) {}
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
mockingProgress . reportOngoingStubbing ( new OngoingStubbingImpl () ) ;
mode . atLeastOnceMode () || ! mode . matchesActualCount ( firstChunk . size () )
public boolean neverWanted () { return ! atLeastOnceMode () && wantedInvocationCount == NUMBER_CONSTANT ; }
public boolean tooManyActualInvocations ( int actualCount ) { return ! atLeastOnceMode () && wantedInvocationCount < actualCount ; }
public boolean tooLittleActualInvocations ( int actualCount ) { return ! atLeastOnceMode () && wantedInvocationCount > actualCount ; }
public boolean missingMethodMode () { return explicitMode () && ( atLeastOnceMode () || wantedInvocationCount > NUMBER_CONSTANT ) ; }
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new VerificationModeImpl ( wantedNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.EXPLICIT ) ; }
stub ( mockTwo . toString () ) . toReturn ( STRING_CONSTANT ) ;
stub ( mock . booleanReturningMethod () ) . toReturn ( true ) ;
{ stub ( mock . simpleMethod () ) . toThrow ( null ) ; }
{ stub ( mock . simpleMethod () ) . toThrow ( new Exception () ) ; }
stub ( mock . size () ) . toThrow ( new RuntimeException () ) ;
stub ( mock . size () ) . toThrow ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( error ) ;
stub ( reader . read () ) . toThrow ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( expected ) ;
stub ( mock . oneArg ( anyString () ) ) . toReturn ( STRING_CONSTANT ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . toReturn ( Boolean.FALSE ) ;
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new DeprecatedConsecutiveStubbing () ; }
mockingProgress . reportOngoingStubbing ( new DeprecatedOngoingStubbingImpl () ) ;
stub ( mock . simpleMethod () ) . toThrow ( new RuntimeException () ) ;
Mockito . stub ( mock . add ( STRING_CONSTANT ) ) . toReturn ( true ) ;
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( ArgumentsAreDifferent expected ) {}
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
if ( mode . explicitMode () ) { return; }
boolean atLeast = atLeastMode () && actualCount >= minInvocationCount ;
public boolean exactNumberOfInvocationsMode () { return ! inOrderMode () && explicitMode () ; }
public static VerificationModeImpl noMoreInteractions () { return new VerificationModeImpl ( null , null , Collections . emptyList () , Verification.NO_MORE_WANTED ) ; }
{ HasStackTrace lastInvocation = finder . getLastStackTrace ( actualInvocations ) ; reporter . tooLittleActualInvocationsInAtLeastMode ( mode . minimumCount () , actualCount , wanted , lastInvocation ) ; }
MockFactoryTest . class
@ Test public void shouldNeverVerifyWhenVerificationIsInAtLeastMode ( ) throws Exception { verifier . verify ( null , null , VerificationModeImpl . atLeastOnce () ) ; }
@ Test public void shouldNeverVerifyWhenVerificationIsExplicit ( ) throws Exception { verifier . verify ( null , null , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ; }
mode . atLeastMode ()
mode . inOrderMode ()
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode
public boolean appliesTo ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) . inOrderMode () ; }
VerificationModeImpl mode
public boolean appliesTo ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) . missingMethodMode () ; }
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationModeImpl mode ) ;
VerificationModeImpl mode
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode = atLeastOnce () ;
private VerificationModeDecoder decode ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) ; }
VerificationModeImpl mode = atLeastOnce () ;
public VerificationModeDecoder ( VerificationModeImpl mode ) { this . mode = mode ; }
VerificationModeImpl mode = VerificationModeImpl . times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode
public void verify ( VerificationModeImpl mode ) { verify ( null , mode ) ; }
VerificationModeImpl mode
public boolean appliesTo ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) . exactNumberOfInvocationsMode () ; }
VerificationModeImpl mode
public boolean appliesTo ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) . missingMethodInOrderMode () ; }
VerificationModeImpl mode
VerificationModeImpl inOrderMode = new VerificationModeBuilder () . inOrder () ;
VerificationModeImpl mode = VerificationModeImpl . atLeastOnce () ;
VerificationModeImpl verificationMode = mockingProgress . pullVerificationMode () ;
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new VerificationModeImpl ( minNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.AT_LEAST ) ; }
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new VerificationModeImpl ( wantedNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.EXPLICIT ) ; }
verifyingRecorder = createRecorder () ;
VerificationMode mode
VerificationMode mode
verifier . verify ( invocations , wanted , atLeastOnce () ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedDifferentMethod ) , atLeastOnce () ) ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedSimpleMethod ) , atLeastOnce () ) ;
VerificationMode mode
private VerificationModeDecoder decode ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) ; }
{ return VerificationModeImpl . atLeast ( minNumberOfInvocations ) ; }
{ return VerificationModeImpl . atLeastOnce () ; }
{ return VerificationModeImpl . times ( wantedNumberOfInvocations ) ; }
VerificationModeImplTest . class
state . verificationStarted ( VerificationModeImpl . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
VerificationMode mode = atLeastOnce () ;
public VerificationModeDecoder ( VerificationMode mode ) { this . mode = mode ; }
VerificationMode mode = VerificationModeImpl . times ( NUMBER_CONSTANT ) ;
VerificationMode mode
{ mode . verify ( getRegisteredInvocations () , wanted ) ; }
@ Override public InvocationMatcher getWanted () { return wanted ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . < String > returnNull () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . < String > returnNull () ; }
{ return reportMatcher ( new Matches ( regex ) ) . < String > returnNull () ; }
{ return reportMatcher ( new Contains ( substring ) ) . < String > returnNull () ; }
{ return ( Collection ) anyObject () ; }
{ return ( Map ) anyObject () ; }
{ return ( List ) anyObject () ; }
{ return ( String ) anyObject () ; }
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ; }
{ missingInvocation . verify ( data . getAllInvocations () , data . getWanted () , this ) ; }
@ Override public String toString () { return STRING_CONSTANT + wantedCount () + STRING_CONSTANT + mocksToBeVerifiedInOrder ; }
AtLeastXVerificationTest . class
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
verifyingRecorder = new VerifyingRecorder () ;
VerifyingRecorderTest . class
{ VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getVerifiableInvocations () , null ) ; VerificationModeFactory . noMoreInteractions () . verify ( data ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getVerifiableInvocations () , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
catch ( MockitoException e ) {}
catch ( MockitoAssertionError e ) {}
catch ( MockitoException e ) {}
if ( ! ( mode instanceof VerificationInOrderMode ) ) { throw new MockitoException ( STRING_CONSTANT ) ; }
public boolean neverWanted () { return ! atLeastMode () && mode . wantedCount () == NUMBER_CONSTANT ; }
public boolean tooManyActualInvocations ( int actualCount ) { return ! atLeastMode () && mode . wantedCount () < actualCount ; }
public boolean tooLittleActualInvocations ( int actualCount ) { return ! atLeastMode () && mode . wantedCount () > actualCount ; }
public static MockitoVerificationMode times ( int wantedNumberOfInvocations ) { return new MockitoVerificationMode ( wantedNumberOfInvocations , Verification.EXPLICIT ) ; }
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode
MockitoVerificationMode atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
MockitoVerificationMode mode
private VerificationModeDecoder decode ( MockitoVerificationMode mode ) { return new VerificationModeDecoder ( mode ) ; }
MockitoVerificationModeTest . class
public VerificationModeDecoder ( MockitoVerificationMode mode ) { this . mode = mode ; }
MockitoVerificationMode mode
MockitoVerificationMode mode
return Mockito . verify ( mock , new InOrderVerificationModeWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ;
Times mode
List < Invocation > chunk = finder . findMatchingChunk ( invocations , wanted , mode ) ;
{ if ( wantedNumberOfInvocations < NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedInvocationCount = wantedNumberOfInvocations ; }
{ if ( wantedNumberOfInvocations <= NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedInvocationCount = wantedNumberOfInvocations ; }
numberOfCalls . verify ( allInvocations , wanted , this ) ;
wantedCount () > NUMBER_CONSTANT
verifier . verify ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . verify ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . verify ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . verify ( invocations , wanted ) ;
verifier . verify ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted ) ; }
verifier . verify ( invocations , wanted ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
if ( wantedCount == NUMBER_CONSTANT ) { missingInvocation . verify ( allInvocations , wanted , this ) ; }
if ( wantedCount == NUMBER_CONSTANT ) { missingInvocation . verify ( data . getAllInvocations () , data . getWanted () ) ; }
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
{ verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; }
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier = new MissingInvocationInOrderChecker ( finderStub , reporterStub ) ;
verifier . check ( invocations , wanted ) ;
verifier . check ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . check ( invocations , wanted ) ; }
verifier . check ( invocations , wanted ) ;
verifier = new MissingInvocationChecker ( finderStub , reporterStub ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier = new NumberOfInvocationsChecker ( reporterStub , finderStub ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
verifier = new NumberOfInvocationsInOrderChecker ( finderStub , reporter ) ;
numberOfCalls . verify ( allInvocations , wanted , wantedCount ) ;
numberOfInvocations . verify ( data . getAllInvocations () , data . getWanted () , wantedCount ) ;
if ( stubbing == null ) { REPORTER . missingMethodInvocation () ; }
T value
Object value
public DeprecatedOngoingStubbing < T > toReturn ( Object value ) { return toAnswer ( new Returns ( value ) ) ; }
public NewOngoingStubbing < T > thenReturn ( Object value ) { return thenAnswer ( new Returns ( value ) ) ; }
{ return MockUtil . createMock ( classToMock , MOCKING_PROGRESS , name , null ) ; }
{ return mock ( classToMock , null ) ; }
MockHandler handler = new MockHandler ( null , state , new ExceptionThrowingBinder () ) ;
{ return Configuration . instance () . getReturnValues () . valueFor ( invocation ) ; }
if ( mockedType . getSigners () != null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MOCKITO_NAMING_POLICY ) ; }
MockingProgressImpl state = new MockingProgressImpl () ;
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnFalse () ; }
{ return LastArguments . instance () . reportNot () . returnChar () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . < T > returnNull () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnChar () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . < T > returnNull () ; }
{ return LastArguments . instance () . reportOr () . returnFalse () ; }
{ return LastArguments . instance () . reportAnd () . < T > returnNull () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnChar () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnFalse () ; }
public void reset () { stubbingInProgress = false ; verificationMode = null ; LastArguments . instance () . reset () ; }
LastArguments . instance () . validateState () ;
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnFalse () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnFalse () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnFalse () ; }
public void reset () { stubbingInProgress = false ; verificationMode = null ; getLastArguments () . reset () ; }
getLastArguments () . validateState () ;
LastArguments lastArguments
private boolean shouldPrint () { return ! unusedStubs . isEmpty () ; }
public void stubbingCompleted ( Invocation invocation ) { stubbedInvocations . add ( invocation ) ; stubbingInProgress = false ; }
public ExperimentalMockitoJUnitRunner ( Class < > klass ) throws InitializationError { super ( klass ) ; }
public void addUnstubbedInvocation ( Invocation invocation ) { unstubbedInvocations . add ( invocation ) ; }
public byte [] naughtyMethodUnderTestWhichDoesNotFailBecauseItReturnsAValue ( String filename ) { return this . reader . readFromFile ( STRING_CONSTANT ) ; }
if ( ! invocation . isVoid () && answer == null ) { mockingProgress . getDebuggingHelper () . addUnstubbedInvocation ( invocation ) ; }
public void stubbingCompleted ( Invocation invocation ) { debuggingHelper . addStubbedInvocation ( invocation ) ; stubbingInProgress = false ; }
public void print () { System.out . println () ; }
void print ( Object what ) ;
if ( ! invocation . isVoid () && answer == null ) { mockingProgress . getDebuggingHelper () . addPotentiallyUnstubbed ( invocationMatcher ) ; }
public ExperimentalMockitoJUnitRunner ( Class < > klass ) throws InitializationError { super ( klass ) ; logger = new MockitoLoggerImpl () ; }
void println ( Object what ) ;
{ if ( hasData () ) { WarningsPrinter warningsPrinter = new WarningsPrinter ( stubbedInvocations , potentiallyUnstubbedInvocations ) ; warningsPrinter . print ( logger ) ; } }
public void addPotentiallyUnstubbed ( InvocationMatcher invocationMatcher ) { if ( ! collectingData ) { return; } potentiallyUnstubbedInvocations . add ( invocationMatcher ) ; }
public ExperimentalMockitoJUnitRunnerPMStub ( ) throws InitializationError { super ( ExperimentalMockitoJUnitRunnerPMTest . class ) ; }
String loggedInfo = logger . getLoggedInfo () ;
String loggedInfo = logger . getLoggedInfo () ;
String loggedInfo = logger . getLoggedInfo () ;
String loggedInfo = logger . getLoggedInfo () ;
public void log ( Object what ) { loggedInfo . append ( what ) ; }
{ return MockitoProperties.DEFAULT_RETURN_VALUES . valueFor ( invocation ) ; }
{ unusedStubbingThatQualifiesForWarning () ; notifier . fireTestFailure ( null ) ; assertTrue ( debuggingInfo . hasData () ) ; }
EmptyReturnValues reportMatcher ( Matcher matcher ) ;
{ return mock ( classToMock , name , null , USING_GLOBAL_CONFIG ) ; }
{ return mock ( classToMock , null , null , USING_GLOBAL_CONFIG ) ; }
DefaultReturnValuesTest . class
Foo mock = mock ( Foo . class , SMART_NULLS ) ;
Foo mock = mock ( Foo . class , SMART_NULLS ) ;
@ Before public void setup () { mock = mock ( IMethods . class , Mockito.SMART_NULLS ) ; }
String mockName
catch ( NoSuchMethodException e ) { throw new RuntimeException ( STRING_CONSTANT ) ; }
{ validateState () ; resetOngoingStubbing () ; verificationMode = ( VerificationMode ) verify ; }
verify ( mock ) ;
unfinishedVerificationHere () ;
{ unfinishedVerificationHere () ; fail () ; }
this . stackTrace = filter . filterStackTrace ( stackTrace ) ;
if ( callback instanceof MethodInterceptorFilter ) { return ( MethodInterceptorFilter ) callback ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
StackTrackeChangingTest . class
STRING_CONSTANT + actualCount + STRING_CONSTANT
{ matcherStack . push ( matcher ) ; return new HandyReturnValues () ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
assertEquals ( expectedMessage , actualMessage ) ;
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NeverWantedButInvoked e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
reporter . tooLittleActualInvocationsInAtLeastMode ( wantedCount , actualCount , wanted , lastInvocation ) ;
reporter . tooLittleActualInvocations ( wantedCount , actualCount , wanted , lastInvocation ) ;
STRING_CONSTANT + pluralize ( wantedCount ) + STRING_CONSTANT
reporter . tooLittleActualInvocationsInOrder ( wantedCount , actualCount , wanted , lastInvocation ) ;
reporter . tooLittleActualInvocationsInOrderInAtLeastMode ( wantedCount , actualCount , wanted , lastInvocation ) ;
catch ( SmartNullPointerException e ) { assertThat ( e . getCause () , hasMethodInStackTraceAt ( NUMBER_CONSTANT , STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
try { inOrder . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( spy ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure f ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
@ Test ( expected = VerifcationInOrderFailure . class )
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
{ String message = createTooLittleInvocationsMessage ( discrepancy , wanted , lastActualStackTrace ) ; throw new VerifcationInOrderFailure ( join ( STRING_CONSTANT + message ) ) ; }
throw new VerifcationInOrderFailure ( join ( STRING_CONSTANT + message ) ) ;
VerifcationInOrderFailure e
VerifcationInOrderFailure e
VerifcationInOrderFailure e
VerifcationInOrderFailure e
catch ( VerifcationInOrderFailure e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
private void misplacedArgumentMatcher () { anyString () ; }
if ( stubbingInProgress ) { stubbingInProgress = false ; reporter . unfinishedStubbing () ; }
assertEquals ( expectedMessage , actualMessage ) ;
mockitoStubber . setInvocationForPotentialStubbing ( new InvocationBuilder () . toInvocationMatcher () ) ;
{ return new VoidMethodStubbableImpl ( mock ) ; }
if ( stubbingInProgress ) { stubbingInProgress = false ; reporter . unfinishedStubbing ( debuggingInfo . getLastInvocationLocation () ) ; }
mockitoStubber . setInvocationForPotentialStubbing ( new InvocationBuilder () . toInvocationMatcher () , null ) ;
{ return new VoidMethodStubbableImpl < T > ( mock , mockitoStubber ) ; }
public void reset () { stubbingInProgress = false ; verificationMode = null ; getArgumentMatcherStorage () . reset () ; }
public void stubbingCompleted ( Invocation invocation ) { debuggingInfo . addStubbedInvocation ( invocation ) ; stubbingInProgress = false ; }
assertEquals ( invocation . getStackTrace () , reporterStub.stackTrace ) ;
assertSame ( third . getStackTrace () , reporterStub.stackTrace ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
assertSame ( second . getStackTrace () , reporterStub.stackTrace ) ;
HasStackTrace hasStackTrace
reporter . argumentsAreDifferent ( syncingPrinter . getWanted () , syncingPrinter . getActual () , similar . getStackTrace () ) ;
if ( unverified != null ) { new Reporter () . noMoreInteractionsWanted ( unverified , unverified . getStackTrace () ) ; }
assertSame ( actualInvocation . getStackTrace () , reporterStub.actualInvocationStackTrace ) ;
assertNull ( reporterStub.actualInvocationStackTrace ) ;
assertSame ( previous . getStackTrace () , reporterStub.previousStackTrace ) ;
{ Throwable filtered = throwable . fillInStackTrace () ; filter . filterStackTrace ( new HasStackTraceThrowableWrapper ( filtered ) ) ; throw filtered ; }
HasStackTrace firstUndesired
HasStackTrace firstUndesired
if ( previousInOrder == null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder , previousInOrder . getStackTrace () ) ; }
int expectedMatchersSize = invocation . getArguments () . length ;
final boolean overloadedButSameArgs = ! methodEquals && argumentsMatch ( candidate ) ;
Location lastLocation = finder . getLastStackTrace ( actualInvocations ) ;
Location lastInvocation = finder . getLastStackTrace ( actualInvocations ) ;
Location lastInvocation = finder . getLastStackTrace ( chunk ) ;
Location lastLocation = finder . getLastStackTrace ( chunk ) ;
if ( unverified != null ) { new Reporter () . noMoreInteractionsWanted ( unverified , unverified . getLocation () ) ; }
if ( previousInOrder == null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder , previousInOrder . getLocation () ) ; }
@ Override public String toString () { return this . firstTraceElement . toString () ; }
if ( matcherStack . isEmpty () ) { return null ; }
{ return doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return doAnswer ( new DoesNothing () ) ; }
{ return doAnswer ( new ThrowsException ( toBeThrown ) ) ; }
{ verifyNoMoreInteractions ( mocks ) ; }
{ return verify ( mock , times ( NUMBER_CONSTANT ) ) ; }
{ return mock ( classToMock , null , ( T ) null , returnValues ) ; }
{ return mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
ret . getClass () . isArray () ;
assertNull ( Mockito.MOCKING_PROGRESS . pullOngoingStubbing () ) ;
{ return MockitoCore . inOrder ( mocks ) ; }
{ return MockitoCore . doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return MockitoCore . doAnswer ( new DoesNothing () ) ; }
{ return MockitoCore . doAnswer ( answer ) ; }
{ return MockitoCore . doAnswer ( new ThrowsException ( toBeThrown ) ) ; }
{ return MockitoCore . stubVoid ( mock ) ; }
{ MockitoCore . verifyNoMoreInteractions ( mocks ) ; }
{ MockitoCore . verifyNoMoreInteractions ( mocks ) ; }
{ return MockitoCore . verify ( mock , mode ) ; }
{ MockitoCore . reset ( mock ) ; }
{ return MockitoCore . verify ( mock , times ( NUMBER_CONSTANT ) ) ; }
{ return MockitoCore . when ( methodCall ) ; }
{ return MockitoCore . stub ( methodCall ) ; }
{ return MockitoCore . mock ( classToMock , null , ( T ) null , returnValues ) ; }
{ return MockitoCore . mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return MockitoCore . mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
return MockitoCore . mock ( ( Class ) class1 , null , null , this ) ;
for ( T m : mocks ) { MockUtil . resetMock ( m , MOCKING_PROGRESS , Mockito.RETURNS_DEFAULTS ) ; }
MOCKING_PROGRESS . stubbingStarted () ;
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { REPORTER . mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
{ MOCKING_PROGRESS . stubbingStarted () ; return ( NewOngoingStubbing ) stub () ; }
{ MOCKING_PROGRESS . stubbingStarted () ; return ( DeprecatedOngoingStubbing ) stub () ; }
ConfigurationAccess . getConfig () . overrideCleansStackTrace ( true ) ;
ConfigurationAccess . getConfig () . overrideCleansStackTrace ( true ) ;
{ mock = mock ( IMethods . class , Mockito.RETURNS_SMART_NULLS ) ; ConfigurationAccess . getConfig () . overrideCleansStackTrace ( true ) ; }
{ ConfigurationAccess . getConfig () . overrideCleansStackTrace ( true ) ; first () ; second () ; third () ; fourth () ; }
@ Before public void init () { StateMaster . validate () ; MockitoAnnotations . initMocks ( this ) ; }
StateMaster . validate () ;
{ return isA ( clazz ) ; }
{ unfilteredStackTrace = getStackTrace () ; StackTraceFilter filter = new StackTraceFilter () ; filter . filterStackTrace ( this ) ; }
filter . filterStackTrace ( this ) ;
filter . filterStackTrace ( t ) ;
filter . filterStackTrace ( this ) ;
this . firstTraceElement = filter . filterStackTrace ( stackTrace ) [ NUMBER_CONSTANT ] ;
@ Before public void cleanStackTraces () { super . makeStackTracesClean () ; }
filter . filterConditionally ( t ) ;
catch ( MockitoException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( NeverWantedButInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e , messageContains ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( MockitoException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( InvalidUseOfMatchersException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
catch ( MockitoException e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( mockTwo . toString () , contains ( STRING_CONSTANT ) ) ;
catch ( MockitoException e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
final boolean overloadedButSameArgs = ! methodEquals && argumentsMatch ( candidate . getArguments () ) ;
{ return anyObject () ; }
Invocation i = new Invocation ( mock , method , args , sequenceNumber ) ;
UnderTest mock = mock ( UnderTest . class ) ;
public Person ( int age ) { this . age = age ; }
if ( arguments . isEmpty () ) { new Reporter () . argumentValueNotYetCaptured () ; } else { return ( T ) arguments . getLast () ; }
{ anyObject () ; try { MockitoTroubleshooter . validateFrameworkState () ; fail () ; } catch ( InvalidUseOfMatchersException e ) {} }
try { MockitoTroubleshooter . validateFrameworkState () ; fail () ; } catch ( UnfinishedStubbingException e ) {}
{ verify ( mock ) ; try { MockitoTroubleshooter . validateFrameworkState () ; fail () ; } catch ( UnfinishedVerificationException e ) {} }
{ return ( List ) arguments ; }
{ Mockito . argThat ( this ) ; return null ; }
{ notifier . addListener ( new FrameworkUsageValidator ( notifier ) ) ; super . run ( notifier ) ; }
{ if ( classProvider . hasJUnit45OrHigher () ) { return classProvider . newInstance ( STRING_CONSTANT , klass ) ; } else { return classProvider . newInstance ( STRING_CONSTANT , klass ) ; } }
RunnerFactory ( ClassProvider classProvider ) { this . classProvider = classProvider ; }
{ super ( klass ) ; }
this . runTest ( notifier ) ;
catch ( Throwable t ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , t ) ; }
@ Test public void shouldCallRealMethdsEvenDelegatedToOtherSelfMethod () { String name = mock . getName () ; assertEquals ( STRING_CONSTANT , name ) ; }
protected String guessName () { return defaultName ; }
public String getName () { return guessName () ; }
{ try { new ShallowCopyTool () . copy ( optionalInstance , mock ) ; } catch ( UnableToCopyFieldValue e ) {} }
if ( MockUtil . isMock ( instance ) ) { return returnValues . valueFor ( invocation ) ; } else { return methodProxy . invoke ( instance , args ) ; }
{ return new VoidMethodStubbableImpl ( mock ) ; }
{ return MOCKITO_CORE . mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , null , null , RETURNS_DEFAULTS ) ; }
assertTrue ( MockUtil . isMock ( classMock ) ) ;
assertTrue ( MockUtil . isMock ( interfaceMock ) ) ;
MockName name = MockUtil . getMockName ( mock ) ;
try { MockUtil . getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List mock = Mockito . mock ( List . class ) ; assertNotNull ( MockUtil . getMockHandler ( mock ) ) ; }
MockHandler < T > handler = MockUtil . getMockHandler ( mock ) ;
if ( mock == null ) { reporter . nullPassedWhenCreatingInOrder () ; } else if ( ! MockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder () ; }
{ if ( mock == null ) { reporter . nullPassedToVerifyNoMoreInteractions () ; } MockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions () ; }
for ( T m : mocks ) { MockUtil . resetMock ( m , mockingProgress ) ; }
if ( mock == null ) { reporter . nullPassedToVerify () ; } else if ( ! MockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify () ; }
{ mockingProgress . validateState () ; mockingProgress . resetOngoingStubbing () ; return MockUtil . createMock ( classToMock , mockingProgress , ( MockSettingsImpl ) mockSettings ) ; }
MockUtil . getMockHandler ( withFinal ) ;
List < Invocation > fromSingleMock = MockUtil . getMockHandler ( mock ) . getRegisteredInvocations () ;
if ( MockUtil . isMock ( throwable ) ) { throw throwable ; }
MockUtil . isMock ( instance )
{ mock ( IMethods . class , configureWith () . extraInterfaces ( ( Class [] ) null ) ) ; }
@ Test public void shouldScreamWhenExtraIsTheSame () { mock ( IMethods . class , configureWith () . extraInterfaces ( IMethods . class ) ) ; }
@ Test public void shouldScreamWhenNonInterfacePassed () { mock ( IMethods . class , configureWith () . extraInterfaces ( LinkedList . class ) ) ; }
{ mock ( IMethods . class , configureWith () . extraInterfaces ( List . class , null ) ) ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , configureWith () . spiedInstance ( object ) . defaultBehavior ( RETURNS_DEFAULTS ) )
{ return MOCKITO_CORE . mock ( classToMock , configureWith () . defaultBehavior ( returnValues ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , configureWith () . name ( name ) . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , configureWith () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ mock ( IMethods . class , configureWith () . extraInterfaces ( IMethods . class ) ) ; fail () ; }
{ mock ( Foo . class , configureWith () . extraInterfaces ( Foo . class ) ) ; fail () ; }
{ mock ( Foo . class , configureWith () . extraInterfaces ( ( Class [] ) null ) ) ; fail () ; }
{ mock ( Foo . class , configureWith () . extraInterfaces () ) ; fail () ; }
{ mock ( Foo . class , configureWith () . extraInterfaces ( IFoo . class , null ) ) ; fail () ; }
Foo mock = mock ( Foo . class , configureWith () . extraInterfaces ( IFoo . class , IBar . class ) ) ;
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . defaultBehavior ( returnValues ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ assertEquals ( STRING_CONSTANT , values . valueFor ( invocationOf ( StringMethods . class , STRING_CONSTANT ) ) ) ; }
ret = ( String [] ) values . valueFor ( invocationOf ( StringMethods . class , STRING_CONSTANT ) )
IMethods mock = mock ( IMethods . class , withSettings () . defaultBehavior ( RETURNS_SMART_NULLS ) . name ( STRING_CONSTANT ) ) ;
public static MockSettings withSettings () { return new MockSettingsImpl () . defaultBehavior ( RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . doAnswer ( new CallsRealMethod () ) ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultBehavior ( RETURNS_DEFAULTS ) )
{ return mock ( classToMock , withSettings () . name ( name ) . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ return mock ( classToMock , withSettings () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ return mockSettings . getReturnValues () . valueFor ( invocation ) ; }
{ MockSettingsImpl settings = ( MockSettingsImpl ) Mockito . withSettings () ; assertEquals ( Mockito.RETURNS_DEFAULTS , settings . getReturnValues () ) ; }
EmptyReturnValuesTest . class
{ ConfigurationAccess . getConfig () . overrideCleansStackTrace ( false ) ; ConfigurationAccess . getConfig () . overrideReturnValues ( null ) ; }
runner = new VerboseMockitoJUnitRunner ( DummyTest . class ) ;
public Object answer ( InvocationOnMock invocation ) throws Throwable { return invocation . invokeSuper () ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultAnswer ( RETURNS_DEFAULTS ) )
catch ( Throwable t ) { new ConditionalStackTraceFilter () . filter ( t ) ; throw t ; }
this . firstTraceElement = filter . filter ( stackTrace ) [ NUMBER_CONSTANT ] ;
StackTraceElement [] filtered = filter . filter ( throwable . getStackTrace () , NUMBER_CONSTANT ) ;
this . firstTraceElement = filter . filter ( stackTrace , NUMBER_CONSTANT ) [ NUMBER_CONSTANT ] ;
StackTraceElement [] filtered = filter . filter ( new StackTraceElement [ NUMBER_CONSTANT ] , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
line = printer . getArgumentsLine ( ( List ) Arrays . asList ( new Equals ( NUMBER_CONSTANT ) , NotNull.NOT_NULL ) , PrintSettings . verboseArgs () )
printer . getArgumentsBlock ( ( List ) Arrays . asList ( new Equals ( NUMBER_CONSTANT ) , new Equals ( NUMBER_CONSTANT ) ) , PrintSettings . verboseArgs () )
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseVariant () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseVariant () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
Matcher . . . toBePrintedVerbosely
public void setMatchersToBePrintedVerbosely ( Matcher [] toBePrintedVerbosely ) { this . verboseMatchers = Arrays . asList ( toBePrintedVerbosely ) ; }
Matcher . . . verboselyPrinted
{ withPrintSettings . add ( ( ( CanPrintArgumentVerbosely ) matcher ) . getVerboseSelfDescribing () ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseSelfDescribing () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseSelfDescribing () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
SelfDescribing getVerboseSelfDescribing ( ) ;
CanDescribeVerbosely equals = new Equals ( NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , StringDescription . toString ( m . withExtraTypeInfo () ) ) ;
try { verify ( withFinal ) . finalMethod ( anyObject () ) ; fail () ; } catch ( UnfinishedVerificationException e ) {}
public BDDOngoingStubbingImpl ( NewOngoingStubbing < T > ongoingStubbing ) { this . mockitoOngoingStubbing = ongoingStubbing ; }
Field createInfoField = methodProxy . getClass () . getDeclaredField ( STRING_CONSTANT ) ;
{ return getInterceptor ( mock ) . getDelegate () ; }
{ Mockito . argThat ( capturingMatcher ) ; return null ; }
{ Mockito . argThat ( capturingMatcher ) ; return new HandyReturnValues () . returnFor ( clazz ) ; }
ArgumentCaptor < String > captor = new ArgumentCaptor < String > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
ArgumentCaptor < String > argument = new ArgumentCaptor < String > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
ArgumentCaptor < Person > person = new ArgumentCaptor < Person > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
ArgumentCaptor < String > argument = new ArgumentCaptor < String > () ;
newMessage += STRING_CONSTANT + debuggingInfo . getWarnings () ;
newMessage += STRING_CONSTANT + debuggingInfo . getWarnings () + STRING_CONSTANT ;
private String thisStubWasNotUsed ( Invocation i ) { return join ( STRING_CONSTANT , i , i . getLocation () , STRING_CONSTANT ) ; }
{ this ( unusedStubs , unstubbedInvocations , true ) ; }
invocationMarker . markVerified ( invocations , wanted ) ;
{ if ( wantedNumberOfInvocations <= NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedCount = wantedNumberOfInvocations ; }
for ( T m : mocks ) { mockUtil . resetMock ( m , mockingProgress ) ; }
private int hashCodeForMock ( Object mock ) { return new Integer ( System . identityHashCode ( mock ) ) ; }
{ return getInterceptor ( mock ) . getMockHandler () ; }
if ( Invocation . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
public static boolean isToString ( InvocationOnMock invocation ) { return isToString ( invocation . getMethod () ) ; }
equalsMethod . equals ( method )
if ( hashCodeMethod . equals ( method ) ) { return hashCodeForMock ( proxy ) ; }
MethodInterceptorFilter newFilter = new MethodInterceptorFilter ( Object . class , newMockHandler ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( classToMock , mockHandler ) ;
if ( ObjectMethodsGuru . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
public static boolean isToString ( InvocationOnMock invocation ) { return ObjectMethodsGuru . isToString ( invocation . getMethod () ) ; }
markFirstOccurence ( chunk , wantedMatcher ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) Arrays . asList ( new Equals ( STRING_CONSTANT ) , capturingMatcher ) ) ;
{ try { return argumentsMatch ( actualArgs ) ; } catch ( Throwable t ) { return false ; } }
{ return methodProxy . invokeSuper ( target , arguments ) ; }
public CGLIBProxyRealMethod ( MethodProxy methodProxy ) { this . methodProxy = methodProxy ; }
public FilteredCGLIBProxyRealMethod ( MethodProxy methodProxy ) { this ( new CGLIBProxyRealMethod ( methodProxy ) ) ; }
proxy . setCallbacks ( new Callback [] { interceptor , NoOp.INSTANCE } ) ;
{ return methodProxy . getMethodProxy () . invokeSuper ( target , arguments ) ; }
Method method
Any mock = mock ( Any . class ) ;
public Method getMethod () { return invocation . getMethod () ; }
Method getMethod ( ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHandler ) ;
Invocation i = new Invocation ( mock , new DelegatingMockitoMethod ( method ) , args , sequenceNumber , null ) ;
{ new ObjectOutputStream ( new ByteArrayOutputStream () ) . writeObject ( new MethodInterceptorFilter ( null ) ) ; }
assertFalse ( new SerializableMockitoMethod ( testBaseToStringMethod ) . equals ( mockMethod ) ) ;
mockMethod = new SerializableMockitoMethod ( toStringMethod ) ;
Class < > getReturnType ( ) ;
MockitoMethod mockitoMethod = new SerializableMockitoMethod ( method ) ;
Invocation i = new Invocation ( mock , new SerializableMockitoMethod ( method ) , args , sequenceNumber , null ) ;
assertFalse ( new MockitoMethod ( testBaseToStringMethod ) . equals ( mockMethod ) ) ;
mockMethod = new MockitoMethod ( toStringMethod ) ;
MockitoMethod method
public MockitoMethod getMethod () { return invocation . getMethod () ; }
MockitoMethod getMethod ( ) ;
Invocation i = new Invocation ( mock , new MockitoMethod ( method ) , args , sequenceNumber , null ) ;
{ if ( invocation . getMethod () . isDeclaredOnInterface () ) { reporter . cannotCallRealMethodOnInterface () ; } }
public SerializableMethod getMethod () { return invocation . getMethod () ; }
SerializableMethod getMethod ( ) ;
{ if ( this . getMethod () . isDeclaredOnInterface () ) { new Reporter () . cannotCallRealMethodOnInterface () ; } return realMethod . invoke ( mock , rawArguments ) ; }
SerializableMethod method
{ if ( isPrimitiveWrapper ( clazz ) ) { return primitiveWrapperOf ( clazz ) ; } return primitiveValueFor ( clazz ) ; }
@ Override protected MethodProxy getMethodProxy () { return methodProxy ; }
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
List < Invocation > allInvocations = ongoingStubbing . getRegisteredInvocations () . getAll () ;
{ registeredInvocations . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing < T > ( mockitoStubber ) ; }
{ registeredInvocations . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing < T > ( mockitoStubber ) ; }
OngoingStubbingImpl < T > ongoingStubbing = new OngoingStubbingImpl < T > ( mockitoStubber , mockitoStubber . getRegisteredInvocations () ) ;
public void addAnswer ( Answer answer ) { addAnswer ( answer , false ) ; }
public MockHandler ( MockHandler < T > oldMockHandler ) { this ( oldMockHandler.mockName , oldMockHandler.mockingProgress , oldMockHandler.matchersBinder , oldMockHandler.mockSettings ) ; }
return mockHandler . handle ( invocation ) ;
{ return ( MockHandler ) getInterceptor ( mock ) . getMockHandler () ; }
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHanlder , ( MockSettingsImpl ) withSettings () ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHanlder , ( MockSettingsImpl ) withSettings () ) ;
Mockito . verify ( mockHanlder , never () ) . handle ( any ( Invocation . class ) ) ;
Mockito . verify ( mockHanlder , never () ) . handle ( any ( Invocation . class ) ) ;
{ mockingProgress . validateState () ; mockingProgress . resetOngoingStubbing () ; return mockUtil . createMock ( classToMock , mockingProgress , ( MockSettingsImpl ) mockSettings ) ; }
public MockName getMockName ( Object mock ) { return getMockHandler ( mock ) . getMockName () ; }
MockHandler () { this ( new ThreadSafeMockingProgress () , new MatchersBinder () , new MockSettingsImpl () ) ; }
{ mockitoStubber . addAnswerForVoidMethod ( answer ) ; return this ; }
public VoidMethodStubbable < T > toReturn () { mockitoStubber . addAnswerForVoidMethod ( new DoesNothing () ) ; return this ; }
{ mockitoStubber . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
{ try { mockitoStubber . addAnswer ( new ThrowsException ( null ) ) ; fail () ; } catch ( MockitoException e ) {} }
{ state . stubbingStarted () ; mockitoStubber . addAnswer ( new Returns ( STRING_CONSTANT ) ) ; state . validateState () ; }
{ mockitoStubber . addAnswer ( new ThrowsException ( new Exception () ) ) ; fail () ; }
@ SuppressWarnings ( STRING_CONSTANT ) public void setAnswersForStubbing ( List < Answer > answers ) { mockitoStubber . setAnswersForStubbing ( answers ) ; }
{ return new VoidMethodStubbableImpl < T > ( mock , mockitoStubber ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( mockitoStubber . getInvocations () , null ) ; VerificationModeFactory . noMoreInteractions () . verify ( data ) ; }
this . mockitoStubber = new MockitoStubber ( mockingProgress ) ;
{ mockitoStubber . addConsecutiveAnswer ( answer ) ; return this ; }
{ mockitoStubber . addConsecutiveAnswer ( answer ) ; return this ; }
if ( i . stubInfo () != null ) { System.out . println ( STRING_CONSTANT + i . stubInfo () . stubbingLocation () ) ; }
void printInvocations ( Object . . . mocks ) ;
{ return MOCKITO_CORE . mock ( classToMock , mockSettings , true ) ; }
void varargs ( String . . . string ) ;
void varargs ( Object . . . object ) ;
List < Invocation > invocations = finder . getAllInvocations ( asList ( mockOne , mockOne , mockOne ) ) ;
List < Invocation > invocations = finder . getAllInvocations ( asList ( mockOne , mockTwo ) ) ;
List < Invocation > allInvocations = new AllInvocationsFinder () . getAllInvocations ( mocksToBeVerifiedInOrder ) ;
public void log ( Object what ) { System.out . println ( what . toString () ) ; }
public void stubbingCompleted ( Invocation invocation ) { debuggingInfo . addStubbedInvocation ( invocation ) ; stubbingInProgress = null ; }
void foundUstubbed ( InvocationMatcher unstubbed ) ;
for ( InvocationMatcher i : allInvocations ) { findingsListener . foundUstubbed ( i ) ; }
verify ( listener , only () ) . foundUstubbed ( unstubbedInvocation ) ;
{ this ( new MockitoLoggerImpl () , new RunnerFactory () . create ( klass ) ) ; }
public void cleanStackTraces () { super . makeStackTracesClean () ; }
public MockUtil ( CreationValidator creationValidator ) { this . creationValidator = creationValidator ; }
private boolean isEmpty ( String warnings ) { return warnings == null || warnings . isEmpty () ; }
SimpleTest test = new SimpleTest () ;
SimpleTest test = new SimpleTest () ;
@ Test ( expected = WantedButNotInvoked . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
if ( instance == null ) { throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
String log = Mockito . debug () . printInvocations ( mock , mockTwo ) ;
String log = Mockito . debug () . printInvocations ( mock , mockTwo ) ;
String log = Mockito . debug () . printInvocations ( mock , mockTwo ) ;
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMock @ Captor ArgumentCaptor captor ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMock @ Mock List mock ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMock @ Spy List mock ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMock Object iAmNull = null ; } ) ; }
null != field . getAnnotation ( InjectMock . class )
if ( field . isAnnotationPresent ( annotation ) ) { new Reporter () . unsupportedCombinationOfAnnotations ( annotation . getSimpleName () , InjectMock . class . getSimpleName () ) ; }
field . isAnnotationPresent ( InjectMock . class )
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT ) ;
{ checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
return mockitoCore . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ;
if ( invocation . isVoid () ) { reporter . cannotStubVoidMethodWithAReturnValue () ; }
{ VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl . getInvocations () , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
{ try { Thread . sleep ( sleep ) ; } catch ( InterruptedException ie ) { throw new MockitoException ( STRING_CONSTANT ) ; } }
try { t . verify ( data ) ; } catch ( MockitoAssertionError e ) {}
@ Override public InvocationMatcher getWanted () { return wanted ; }
@ Override public InOrderContext getOrderingContext () { return inOrder ; }
{ throw new MockitoException ( join ( STRING_CONSTANT + methodName + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ return ( T ) anyObject () ; }
Object instance = field . get ( testClass ) ;
{ throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + field . getType () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + field . getType () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + field . getType () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + field . getType () + STRING_CONSTANT ) ; }
NestedClassWithNoArgConstructor ( String _1arg ) {}
if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify () ; }
validateState () ;
Invocation . isToString ( invocation )
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
new Reporter () . smartNullPointerException ( obj , location ) ;
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + formatMethodCall () + STRING_CONSTANT ; }
null != field . getAnnotation ( Mock . class )
Object testClass
int index = filter . accept ( actualMethod ) ;
notifyInvocationListener ( invocation ) ;
MockHandler handler
{ given ( handler . getMockSettings () . getDefaultAnswer () ) . willReturn ( SOME_ANSWER ) ; stubOrdinaryInvocationWithReturnValue ( handler , null ) ; }
doThrow ( new RuntimeException () ) . when ( throwingListener )
{ return nextStrategy != null && nextStrategy . processInjection ( field , fieldOwner , mockCandidates ) ; }
public OngoingMockInjection tryPropertyOrFieldInjection () { appendStrategy ( new PropertyAndSetterInjection () ) ; return this ; }
public OngoingMockInjection tryConstructorInjection () { appendStrategy ( new ConstructorInjection () ) ; return this ; }
{ assert wasAccessible != null ; try { accessibleObject . setAccessible ( wasAccessible ) ; } catch ( Throwable t ) {} }
AllInvocationsFinder finder = new AllInvocationsFinder () ;
Foo foo = mock ( Foo . class , withSettings () . callback ( listener1 ) . callback ( listener2 ) ) ;
Foo foo = mock ( Foo . class , withSettings () . callback ( listener ) ) ;
Foo foo = mock ( Foo . class , withSettings () . callback ( listener1 ) . callback ( listener2 ) ) ;
Foo foo = mock ( Foo . class , withSettings () . callback ( listener ) ) ;
given ( handler . getMockSettings () . getInvocationListener () ) . willReturn ( Arrays . asList ( listener ) ) ;
@ Test ( expected = MockitoException . class ) public void shouldThrowCorrectExceptionForNullInvocationListener ( ) throws Exception { new Reporter () . nullInvocationListenerAdded () ; }
{ for ( InvocationListener listener : mockSettings . getInvocationListener () ) { notifyListenerOfInvocationWithException ( invocation , exception , listener ) ; } }
{ for ( InvocationListener listener : mockSettings . getInvocationListener () ) { notifyListenerOfInvocationWithReturnValue ( invocation , returnValue , listener ) ; } }
{ assertFalse ( mockSettingsImpl . hasInvocationListeners () ) ; mockSettingsImpl . verboseLogging () ; assertContainsType ( mockSettingsImpl . getInvocationListeners () , LogInvocationsToStdOutListener . class ) ; }
MethodCallReport mcr
public void invocationListenersRequiresAtLeastOneListener () { throw new MockitoException ( join ( STRING_CONSTANT ) ) ; }
public void invocationListenerDoesNotAcceptNullParameters () { throw new MockitoException ( join ( STRING_CONSTANT ) ) ; }
{ mockSettingsImpl . invocationListeners ( invocationListener , null ) ; }
{ mockSettingsImpl . invocationListeners () ; }
{ notifier . handle ( invocation ) ; }
{ notifier . handle ( invocation ) ; }
{ mapOngoingStubbing . thenReturn ( STRING_CONSTANT ) ; }
{ super ( new URL [] { obtainClassPath ( SimplePerRealmReloadingClassLoader . class ) } , parentClassLoader ) ; this . reloadClassPredicate = reloadClassPredicate ; }
{ super ( new URL [] { obtainClassPath ( SimplePerRealmReloadingClassLoader . class ) } ) ; this . reloadClassPredicate = reloadClassPredicate ; }
return report . fieldWasInitialized () ;
mocks . addAll ( scanMocks ( testClassInstance , clazz ) ) ;
@ Test public void inject_mocks_even_in_declared_spy ( ) throws Exception { assertNotNull ( spiedReceiver.antena ) ; assertNotNull ( spiedReceiver.tuner ) ; }
new InjectMocksScanner ( testClassInstance , clazz ) . addTo ( mockDependentFields ) ;
String canThrowException ( ) throws ChangedCharSetException , CharacterCodingException ;
{ return ( MockHandlerInterface ) getInterceptor ( mock ) . getHandler () ; }
MockSettingsImpl settings
MockSettingsImpl mockSettings
MockSettingsImpl settings
MockSettingsImpl settings
public void setTheField ( final File theField ) { setTheFieldWasUsed = true ; this . theField = theField ; }
Class configClass = null ;
private void misplacedBooleanArgumentMatcher () { anyBoolean () ; }
private void misplacedIntArgumentMatcher () { anyInt () ; }
private void misplacedArgumentMatcher () { anyObject () ; }
List < Matcher > pullMatchers ( ) ;
Set < Object > mocks = new HashSet < Object > () ;
Set < Object > mocks = new HashSet < Object > () ;
{ this . delegatedInstance = delegatedInstance ; return defaultAnswer ( new ReturnsDelegate ( this . delegatedInstance ) ) ; }
public Integer getSequenceNumber () { return sequenceNumber ; }
int expectedMatchersSize = invocation . getArgumentsCount () ;
if ( isDeclaredOnInterface () ) { new Reporter () . cannotCallRealMethodOnInterface () ; }
List matchers = i . argumentsToMatchers () ;
public String toString () { return invocation . toString ( matchers , new PrintSettings () ) ; }
{ this . matchers = invocation . argumentsToMatchers () ; }
List matchers = Invocation . argumentsToMatchers ( i . getArguments () ) ;
{ this . matchers = Invocation . argumentsToMatchers ( invocation . getArguments () ) ; }
public String print ( Invocation invocation ) { return print ( Invocation . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
public String toString () { return new PrintSettings () . print ( argumentsToMatchers ( getArguments () ) , this ) ; }
this . arguments = expandVarArgs ( mockitoMethod . isVarArgs () , args ) ;
Location firstUndesired
Location firstUndesired
Location lastActualLocation
Location lastLocation = finder . getLastLocation ( actualInvocations ) ;
{ Location location = verificationMode . getLocation () ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; }
if ( stubbingInProgress != null ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; }
Location last = finder . getLastLocation ( invocations ) ;
Location lastLocation = null ;
Location actualLocation
{ this . actualMatcher = actualMatcher ; this . location = new Location () ; }
String loc = new Location ( filterReturningEmptyArray ) . toString () ;
Location actualLocation
throw new NoInteractionsWanted ( join ( STRING_CONSTANT , new Location () , STRING_CONSTANT , undesired . getLocation () , scenario ) ) ;
Location lastActualLocation
Location lastActualLocation
Location firstUndesired
Location firstUndesired
join ( STRING_CONSTANT , STRING_CONSTANT , wanted . toString () , new Location () , STRING_CONSTANT , previous . toString () , previous . getLocation () , STRING_CONSTANT )
new Location ()
Location location
Location location
public Location getLocation () { return invocation . getLocation () ; }
public Localized ( T object ) { this . object = object ; location = new Location () ; }
Location lastLocation = finder . getLastLocation ( chunk ) ;
this . location = new Location () ;
{ s . markStubUsed ( invocation ) ; invocation . markStubbed ( new StubInfo ( s ) ) ; return s ; }
{ out += line ( STRING_CONSTANT + i . stubInfo () . stubbedAt () ) ; }
invocation . markStubbed ( new StubInfo ( stubbedInvocation ) ) ;
isMultiline () || ( ! matchers . isEmpty () && invocationString . length () > Invocation.MAX_LINE_LENGTH )
Invocation invocation
Object answerTo ( Invocation invocation ) throws Throwable { return findAnswerFor ( invocation ) . answer ( invocation ) ; }
Invocation invocation = invocationForStubbing . getInvocation () ;
Invocation nullDereference
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation actual
Invocation actual
Invocation invocation
Invocation actual
Invocation compareTo = this . getLastInvocation () ;
List < Invocation > allInvocations
Invocation previous = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
assertNull ( finder . getLastLocation ( Collections . < Invocation > emptyList () ) ) ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
List < Invocation > unusedStubs
Invocation invocation
Invocation invocation
List < Invocation > getAllInvocations ( ) ;
Invocation invocation
public boolean isOut ( Invocation invocation ) { return ! orderingContext . isVerified ( invocation ) ; }
public boolean isOut ( Invocation invocation ) { return ! wanted . matches ( invocation ) ; }
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation actualInvocation = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
List < Invocation > getInvocations ( ) ;
public void stubbingCompleted ( Invocation invocation ) { threadSafely () . stubbingCompleted ( invocation ) ; }
WarningsFinder finder = new WarningsFinder ( Arrays . < Invocation > asList () , Arrays . < InvocationMatcher > asList ( unstubbedInvocation ) ) ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation
Invocation invocation
Invocation invocation
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
given ( handler.invocationContainerImpl . findAnswerFor ( any ( Invocation . class ) ) ) . willReturn ( value ) ;
Invocation invocation
Invocation invocation
Invocation invocation
Invocation invocationOnClass = getLastInvocation () ;
Invocation previous = new InvocationBuilder () . toInvocation () ;
Invocation actual = new InvocationBuilder () . toInvocation () ;
Invocation invocationOnInterface = new InvocationBuilder () . toInvocation () ;
public void foundUnusedStub ( Invocation unused ) { logger . log ( STRING_CONSTANT + unused . getLocation () + STRING_CONSTANT ) ; }
Invocation unused
Invocation undesired
Invocation undesired
List < Invocation > unusedStubs
List < Invocation > unusedStubs
Invocation i
Invocation candidate
Invocation candidate
Invocation actual
public Invocation getInvocation () { return this . invocation ; }
public InvocationMatcher ( Invocation invocation ) { this ( invocation , Collections . < Matcher > emptyList () ) ; }
Invocation invocation
public void markVerified ( Invocation i ) { verified . add ( i ) ; }
public boolean isVerified ( Invocation invocation ) { return verified . contains ( invocation ) ; }
public void markVerified ( Invocation i ) { inOrderContext . markVerified ( i ) ; }
public boolean isVerified ( Invocation i ) { return inOrderContext . isVerified ( i ) ; }
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation
public ExposedInvocation ( Invocation toBeExposed ) { methodProxy = ( ( HasCGLIBMethodProxy ) toBeExposed.realMethod ) . getMethodProxy () ; }
public String print ( Invocation invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
Invocation invocation
Mockito . verify ( handler , never () ) . handle ( any ( Invocation . class ) ) ;
Mockito . verify ( handler , never () ) . handle ( any ( Invocation . class ) ) ;
public boolean isOut ( Invocation invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
public void add ( Invocation invocation ) { invocations . add ( invocation ) ; }
List < Invocation > getAllInvocations ( ) ;
Invocation invocation
PublicInvocation theInvocation
public MethodInfo ( PublicInvocation theInvocation ) { this . method = theInvocation . getMethod () ; }
InvocationImpl invocation = invocationForStubbing . getInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl actual
InvocationImpl actual
InvocationImpl actual
InvocationImpl compareTo = this . getLastInvocation () ;
List < InvocationImpl > allInvocations
InvocationImpl previous = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
List < InvocationImpl > unusedStubs
InvocationImpl invocation
InvocationImpl invocation
List < InvocationImpl > getAllInvocations ( ) ;
List < InvocationImpl > chunk
InvocationImpl invocation
public boolean isOut ( InvocationImpl invocation ) { return ! orderingContext . isVerified ( invocation ) ; }
public boolean isOut ( InvocationImpl invocation ) { return ! wanted . matches ( invocation ) ; }
List < InvocationImpl > invocations
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl actualInvocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
List < InvocationImpl > getInvocations ( ) ;
public void stubbingCompleted ( InvocationImpl invocation ) { threadSafely () . stubbingCompleted ( invocation ) ; }
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
{ public InvocationMatcher bindMatchers ( ArgumentMatcherStorage argumentMatcherStorage , InvocationImpl invocation ) { throw new InvalidUseOfMatchersException () ; } }
InvocationImpl invocation
InvocationImpl invocationOnClass = getLastInvocation () ;
InvocationImpl actual = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocationOnInterface = new InvocationBuilder () . toInvocation () ;
public void foundUnusedStub ( InvocationImpl unused ) { logger . log ( STRING_CONSTANT + unused . getLocation () + STRING_CONSTANT ) ; }
InvocationImpl unused
InvocationImpl undesired
InvocationImpl undesired
List < InvocationImpl > unusedStubs
List < InvocationImpl > unusedStubs
InvocationImpl i
InvocationImpl candidate
InvocationImpl candidate
InvocationImpl actual
public InvocationImpl getInvocation () { return this . invocation ; }
public InvocationMatcher ( InvocationImpl invocation ) { this ( invocation , Collections . < Matcher > emptyList () ) ; }
InvocationImpl invocation
public void markVerified ( InvocationImpl i ) { verified . add ( i ) ; }
public boolean isVerified ( InvocationImpl invocation ) { return verified . contains ( invocation ) ; }
public void markVerified ( InvocationImpl i ) { inOrderContext . markVerified ( i ) ; }
public boolean isVerified ( InvocationImpl i ) { return inOrderContext . isVerified ( i ) ; }
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation
public String print ( InvocationImpl invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
InvocationImpl invocation
public boolean isOut ( InvocationImpl invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
public void add ( InvocationImpl invocation ) { invocations . add ( invocation ) ; }
List < InvocationImpl > getAllInvocations ( ) ;
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl lastActualLocation
LocationImpl lastLocation = finder . getLastLocation ( actualInvocations ) ;
{ LocationImpl location = verificationMode . getLocation () ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; }
if ( stubbingInProgress != null ) { LocationImpl temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; }
LocationImpl last = finder . getLastLocation ( invocations ) ;
LocationImpl lastLocation = null ;
LocationImpl actualLocation
LocationImpl actualLocation
LocationImpl location
LocationImpl lastActualLocation
LocationImpl lastActualLocation
LocationImpl lastActualInvocation
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl actualLocation
LocationImpl location
LocationImpl location
public LocationImpl getLocation () { return invocation . getLocation () ; }
LocationImpl lastLocation = finder . getLastLocation ( chunk ) ;
InvocationImpl invocation
Object answerTo ( InvocationImpl invocation ) throws Throwable { return findAnswerFor ( invocation ) . answer ( invocation ) ; }
InvocationImpl nullDereference
InvocationImpl invocation
for ( InvocationImpl i : unusedStubs ) { findingsListener . foundUnusedStub ( i ) ; }
{ markVerified ( chunk , wanted ) ; for ( InvocationImpl i : chunk ) { context . markVerified ( i ) ; } }
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl previous = new InvocationBuilder () . toInvocation () ;
InvocationImpl previousInOrder = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
InvocationImpl invocation
assertNull ( finder . getLastLocation ( Collections . < InvocationImpl > emptyList () ) ) ;
WarningsFinder finder = new WarningsFinder ( Arrays . < InvocationImpl > asList ( stub ) , Arrays . < InvocationMatcher > asList ( wrongArg ) ) ;
WarningsFinder finder = new WarningsFinder ( Arrays . < InvocationImpl > asList () , Arrays . < InvocationMatcher > asList ( unstubbedInvocation ) ) ;
return new LinkedList < InvocationImpl > ( invocationsInOrder ) ;
synchronized ( invocations ) { copiedList = new LinkedList < InvocationImpl > ( invocations ) ; }
Discrepancy discrepancy
Discrepancy discrepancy
Discrepancy discrepancy
Discrepancy discrepancy
{ new Reporter () . tooLittleActualInvocations ( new Discrepancy ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new InvocationBuilder () . toInvocation () , null ) ; }
STRING_CONSTANT + Pluralizer . pluralize ( wantedCount ) + STRING_CONSTANT
PrintableInvocation invocation
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
public void markStubUsed ( PrintableInvocation usedAt ) { this . usedAt = usedAt ; }
@ Override public void wantedButNotInvoked ( PrintableInvocation wanted ) { this . wanted = wanted ; }
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
public void wantedButNotInvoked ( PrintableInvocation wanted ) { throw new WantedButNotInvoked ( createWantedButNotInvokedMessage ( wanted ) ) ; }
public StubInfoImpl ( PrintableInvocation stubbedAt ) { this . stubbedAt = stubbedAt ; }
{ return new MockingDetails ( toInspect , new MockUtil () ) ; }
Invocation invocationOnClass = getLastInvocation () ;
InvocationTest . class
MockitoAnnotations.Mock annotation
new ReturnsIdentity ( NUMBER_CONSTANT )
{ validator . validate ( new ReturnsIdentity ( ReturnsIdentity.LAST_ARGUMENT ) , new InvocationBuilder () . simpleMethod () . toInvocation () ) ; fail () ; }
validator . validate ( new ReturnsIdentity ( NUMBER_CONSTANT ) , new InvocationBuilder () . method ( STRING_CONSTANT ) . arg ( STRING_CONSTANT ) . toInvocation () ) ;
{ return ( Answer < T > ) new ReturnsIdentity ( position ) ; }
{ ( ( Factory ) mock ) . setCallback ( NUMBER_CONSTANT , new MethodInterceptorFilter ( newHandler , settings ) ) ; }
MockitoInvocationHandler handler
InvocationNotifierHandler oldHandler = ( InvocationNotifierHandler ) mockMaker . getHandler ( mock ) ;
if ( isMockOrSpy ( instance ) ) { mockUtil . redefineMockNameIfSurrogate ( instance , field . getName () ) ; return instance ; }
Class . . . extraInterfaces
Class < > [] extraInterfaces
Class < > [] extraInterfaces
mockUtil . redefineMockNameIfSurrogate ( mock , STRING_CONSTANT ) ;
mockUtil . redefineMockNameIfSurrogate ( mock , STRING_CONSTANT ) ;
public void validateExtraInterfaces ( Class classToMock , Class . . . interfaces ) { extraInterfacesValidated = true ; }
T mock = mockUtil . createMock ( classToMock , ( MockSettingsImpl ) mockSettings ) ;
public MockSettingsImpl getMockSettings () { return mockHandler . getMockSettings () ; }
MockSettingsImpl settings
@ SuppressWarnings ( STRING_CONSTANT ) MockHandler < > handler = new MockHandler () ;
MockSettingsImpl settings = oldHandler . getMockSettings () ;
MockSettingsImpl mockSettings
name . isSurrogate ()
{ if ( getMockName ( mock ) . isSurrogate () ) { getMockHandler ( mock ) . getMockSettings () . redefineMockName ( newName ) ; } }
{ this . mockName = toInstanceName ( classToMock ) ; this . surrogate = true ; }
IMethods methods = mock ( IMethods . class , withSettings () . forwardTo ( new MethodsImpl () ) ) ;
List < String > mockedList = mock ( List . class , withSettings () . forwardTo ( delegatedList ) ) ;
List < String > mock = mock ( List . class , withSettings () . forwardTo ( delegatedList ) ) ;
List < String > mock = mock ( List . class , withSettings () . forwardTo ( delegatedList ) ) ;
MockSettingsInfo settings
MockSettingsInfo settings
MockSettingsInfo mockSettings
public MockSettingsInfo getMockSettings () { return mockHandler . getMockSettings () ; }
MockSettingsInfo settings
MockSettingsInfo settings = oldHandler . getMockSettings () ;
MockSettingsInfo mockSettings
mockingProgress . mockingStarted ( mock , typeToMock , settings ) ;
{ mockingProgress . setListener ( null ) ; mockingProgress . mockingStarted ( null , null , null ) ; }
MockHandlerTest . class
MockHandler < T > mockHandler
newHandler = new InvocationNotifierHandler < T > ( new MockHandler < T > ( settings ) , settings )
MockHandlerInterface mockitoHandler = cast ( handler ) ;
MockHandlerInterface handler
MockitoInvocationHandler newHandler
MockitoInvocationHandler handler
MockitoInvocationHandler newHandler
given ( iMethods . varargsObject ( eq ( NUMBER_CONSTANT ) , anyVararg () ) ) . will ( returnsArgAtPosition ( NUMBER_CONSTANT ) ) ;
MockHandlerImpl < T > mockHandler
{ return primitiveOf ( type ) ; }
result = NUMBER_CONSTANT * result + ( onClass != null ? onClass . hashCode () : NUMBER_CONSTANT ) ;
registerTypeVariablesOn ( clazz ) ;
< O extends K > O typeVarWithTypeParams ( ) ;
< S , T extends S > T twoTypeParams ( ) ;
List < ? super Integer > returningWildcard ( ) ;
return typeVariable . equals ( ( ( BoundedType ) o ) . typeVariable ) ;
public MockSettings parameterizedInfo ( MockitoGenericMetadata mockitoGenericMetadata ) { this . mockitoGenericMetadata = mockitoGenericMetadata ; return this ; }
MockitoGenericMetadata returnTypeGenericMetadata
public void setMockitoGenericMetadata ( MockitoGenericMetadata mockitoGenericMetadata ) { this . mockitoGenericMetadata = mockitoGenericMetadata ; }
{ VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
this . invocationContainerImpl = new InvocationContainerImpl ( mockingProgress ) ;
RegisteredInvocationsTest . class
{ return mockSettings . isStubOnly () ? new RegisteredInvocationsStubOnly () : new RegisteredInvocationsAll () ; }
RegisteredInvocationsAllTest . class
{ return mockSettings . isStubOnly () ? new RegisteredInvocationsStubOnly () : new DefaultRegisteredInvocations () ; }
catch ( NotAMockException e ) {}
@ After public void yesIKnowSomeMatchersAreMisplaced () { resetState () ; }
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingBecauseWrongStubbingSyntaxInConfigurationMethod . class ) ;
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingBecauseIncorrectStubbingSyntax . class ) ;
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingBecauseIncorrectAnnotationUsage . class ) ;
GenericMetadataSupport genericMetadata = from ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = from ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = from ( StringBuilder . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , StringBuilder . class ) ) ;
GenericMetadataSupport genericMetadata = from ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = from ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
{ if ( mockitoGenericMetadata == null ) { this . mockitoGenericMetadata = GenericMetadataSupport . from ( typeToMock ) ; } return mockitoGenericMetadata ; }
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
return recordDeepStubMock ( returnTypeGenericMetadata . toMock ( this ) , container ) ;
static MockMaker findPlatformMockMaker () { return findPluginImplementation ( MockMaker . class , new CglibMockMaker () ) ; }
{ if ( ! isTypeMockable ( classToMock ) ) { new Reporter () . cannotMockFinalClass ( classToMock ) ; } }
{ return mock ( returnTypeGenericMetadata . rawType () , withSettingsUsing ( returnTypeGenericMetadata ) ) ; }
if ( ! new MockCreationValidator () . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; }
if ( ! ClassImposterizer.INSTANCE . canImposterise ( clazz ) ) { return null ; }
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + pluginType , e ) ; }
NotSerializableToBeMocked ( Observable o ) { super ( o ) ; }
MockCreationSettings mockSettings = new MockUtil () . getMockHandler ( mockitoMock ) . getMockSettings () ;
public boolean isSpy ( Object mock ) { return mock instanceof MockitoSpy && isMock ( mock ) ; }
{ if ( Factory . class . isAssignableFrom ( cl ) ) { return STRING_CONSTANT ; } else { return STRING_CONSTANT ; } }
{ return ! STRING_CONSTANT . equals ( marker ) ; }
public boolean isMock ( Object mock ) { return mock instanceof MockitoMock ; }
public boolean isSpy ( Object mock ) { return mock instanceof MockitoSpy && isMock ( mock ) ; }
public boolean isMock ( Object mock ) { return mock != null && isMockitoMock ( mock ) ; }
catch ( ObjectStreamException e ) { Assertions . assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
{ SimpleSerializationUtil . serializeAndBack ( mockWithPrivateConstructor ) ; }
this . serializable = copy.serializable ;
AClassToBeMockedInThisTestOnlyAndInCallablesOnly mock = Mockito . mock ( AClassToBeMockedInThisTestOnlyAndInCallablesOnly . class , Mockito . withSettings () . serializable () ) ;
{ if ( mockUtil . isMock ( cl ) ) { return MOCKITO_PROXY_MARKER ; } else { return NOTHING ; } }
public boolean isMock ( Object mock ) { return mock instanceof MockitoMock && isMockitoMock ( mock ) ; }
verify ( mock , timeout ( NUMBER_CONSTANT ) . never () ) . clear () ;
public VerificationMode never () { new Reporter () . atMostShouldNotBeUsedWithTimeout () ; return null ; }
{ new Reporter () . atMostShouldNotBeUsedWithTimeout () ; return null ; }
verify ( target , timeout ( TEST_MILLIS ) . times ( TIMES * nThreads ) ) . targetMethod ( STRING_CONSTANT ) ;
public int getTreshhold () { return pollingPeriod ; }
{ return new After ( wrappedVerification . getDelay () , verificationMode ) ; }
assertEquals ( expectedTimeout , ( ( Timeout ) t ) . wrappedVerification . getTimeout () ) ;
{ return new Timeout ( wrappedVerification . getPollingPeriod () , wrappedVerification . getTimeout () , newVerificationMode ) ; }
{ super ( new VerificationWithTimeoutImpl ( pollingPeriod , millis , delegate ) ) ; }
{ return new After ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDelay () , verificationMode ) ; }
{ super ( new VerificationAfterDelayImpl ( pollingPeriod , delayMillis , verificationMode ) ) ; }
{ if ( canRecoverFromFailure ( delegate ) ) { error = e ; sleep ( pollingPeriod ) ; } else { throw e ; } }
ClassLoader cl = isolatedClassLoader () . withCurrentCodeSourceUrls () . withPrivateCopyOf ( STRING_CONSTANT ) . withPrivateCopyOf ( STRING_CONSTANT ) . build () ;
{ cl . loadClass ( STRING_CONSTANT ) ; }
{ cl . loadClass ( CLASS_NAME_USING_INTERFACE ) ; }
{ cl . loadClass ( CLASS_NAME_USING_INTERFACE ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = typeVariable ; }
{ Type actualType = getActualTypeArgumentFor ( typeParameter ) ; actualTypeArguments . put ( typeParameter , actualType ) ; }
return wildCardBoundedType ;
return new TypeVarBoundedType ( typeParameter ) ;
{ for ( TypeVariable typeParameter : typeParameters ) { contextualActualTypeParameters . put ( typeParameter , boundsOf ( typeParameter ) ) ; } }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = new SerializableTypeVariable ( typeVariable ) ; }
{ Type actualType = getActualTypeArgumentFor ( typeParameter ) ; actualTypeArguments . put ( new SerializableTypeVariable ( typeParameter ) , actualType ) ; }
return new SerializableBoundedType ( wildCardBoundedType ) ;
return new SerializableBoundedType ( new TypeVarBoundedType ( typeParameter ) ) ;
{ return mockitoCore . mock ( returnTypeGenericMetadata . rawType () , withSettingsUsing ( returnTypeGenericMetadata ) ) ; }
private ReturnsDeepStubs returnsDeepStubsAnswerUsing ( final GenericMetadataSupport returnTypeGenericMetadata ) { return new NotSerializableGenericsAwareReturnsDeepStubs ( returnTypeGenericMetadata ) ; }
return makeDeepMock ( invocation , returnTypeGenericMetadata ) ;
{ return verify ( mock , mode ) ; }
public T should () { return verify ( mock ) ; }
{ return Mockito . verify ( mock , mode ) ; }
public T should () { return Mockito . verify ( mock ) ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnFalse () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnFalse () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnFalse () ; }
T extends Object
if ( ! cleaner . isOut ( unfilteredStackTrace . get ( i ) ) ) { continue; }
{ return ( T ) primitiveOrWrapperDefaultValues . get ( primitiveOrWrapperType ) ; }
{ return primitiveOrWrapperDefaultValues . containsKey ( type ) ; }
{ if ( clazz . isPrimitive () ) { return clazz ; } return ( Class < T > ) primitiveTypes . get ( clazz ) ; }
{ if ( isEquals == false ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }
{ if ( isEquals == false ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }
if ( isEquals == false ) { return this ; }
int millis
int millis
int delayMillis
public int getDuration () { return durationMillis ; }
public int getPollingPeriod () { return pollingPeriodMillis ; }
int sleep
{ verifyNoMoreInteractions ( null ) ; }
{ inOrder ( null ) ; }
{ verifyNoMoreInteractions ( null ) ; }
String expectedCause = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
String expectedCause = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
@ Override public int hashCode () { return method != null ? method . hashCode () : NUMBER_CONSTANT ; }
durationChecker . isVerificationStillInProgress ( startTime )
this . durationChecker = new DurationCheckerImpl ( durationMillis ) ;
when ( timer . isUp ( anyLong () ) ) . thenReturn ( true , true , true , true , true , false ) ;
public void reset () { mockingProgress . reset () ; }
Mockito . when ( clazzMock . isValid () ) . thenReturn ( true ) ;
catch ( MockitoException e ) { Assertions . assertThat ( e . getMessage () ) . contains ( MockitoLimitations.NON_PUBLIC_PARENT ) ; }
{ return type == null ? STRING_CONSTANT : type . getCanonicalName () + STRING_CONSTANT + type . getClassLoader () + STRING_CONSTANT ; }
ClassImposterizer imposterizer = new ClassImposterizer ( new CachingObjenesisInstanceFactory () ) ;
return new ClassImposterizer ( new CachingObjenesisInstanceFactory () ) . imposterise ( new MethodInterceptorFilter ( mockitoHandler , settings ) , settings . getTypeToMock () , settings . getExtraInterfaces () ) ;
imposterizer = new ClassImposterizer ( new ConstructorInstanceFactory () ) ;
Factory proxy = instanceFactory . newInstance ( proxyClass ) ;
STRING_CONSTANT + instanceFactory . getClass () . getSimpleName ()
ClassImposterizer imposterizer = new ClassImposterizer ( new CachingObjenesisInstantiator () ) ;
new ClassImposterizer ( new CachingObjenesisInstantiator () )
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
ClassImposterizerTest . class
new DefaultClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
DefaultClassImposterizerTest . class
CglibClassImposterizerTest . class
new CglibClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
cglibHacker . setMockitoNamingPolicy ( mockitoMethodProxy ) ;
{ return methodProxy . invokeSuper ( target , arguments ) ; }
FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod ( mockitoMethodProxy ) ;
{ sourceJarComparator . addPair ( left , right ) ; }
boolean jars = sourceJarComparator . areEqual () ;
mock = mock ( List . class , delegatesTo ( new FakeListWithWrongMethods <> () ) )
mock = mock ( List . class , delegatesTo ( new FakeListWithWrongMethods <> () ) )
mock = mock ( List . class , delegatesTo ( new FakeList <> () ) )
mock = mock ( List . class , delegatesTo ( new FakeList <> () ) )
mock = mock ( List . class , delegatesTo ( new FakeList <> () ) )
{ return new ArrayList <> () ; }
{ return new ArrayList <> () ; }
BinaryComparator.Result result = binaryComparator . compareFiles () ;
{ binaryComparator . setPair ( left , right ) ; }
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
ClassImposterizer imposterizer = new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () ) ;
{ if ( settings . isUsingConstructor () ) { return new ConstructorInstantiator () ; } else { return INSTANCE ; } }
imposterizer = new ClassImposterizer ( new ConstructorInstantiator () ) ;
catch ( InstantationException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
public String toString () { return author + STRING_CONSTANT + commits . size () ; }
{ email = commit . getEmail () ; author = commit . getAuthor () ; commits . add ( commit ) ; }
public String getEmail () { return email ; }
GitCommit commit
GitCommit commit
{ return new GitContributionsProvider ( runner ) ; }
{ return new GitContributionsProvider ( new GitLogProvider ( runner ) ) ; }
DefaultContributionSet contributions = new DefaultContributionSet () ;
if ( commit . getMessage () . contains ( STRING_CONSTANT ) ) { return; }
Map.Entry < String , DefaultContribution > entry
if ( ! m . matches () ) { throw new ReleaseNotesException ( STRING_CONSTANT + releaseNotesContent ) ; }
if ( out == null ) { throw new ReleaseNotesException ( STRING_CONSTANT + envVariableName + STRING_CONSTANT ) ; }
int id
public GitHubImprovementsProvider ( GitHubAuthToken authToken ) { this . authToken = authToken ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return new GloballyConfiguredAnswer () . answer ( invocation ) ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return Answers.CALLS_REAL_METHODS . get () . answer ( invocation ) ; }
String content = IOUtil . readStream ( response ) ;
catch ( NoSuchMethodException noDefaultConstructor ) { throw new MockitoException ( STRING_CONSTANT + type ) ; }
{ return new Then < T > ( mock ) ; }
try { closeable . close () ; } catch ( IOException e ) { throw new MockitoException ( STRING_CONSTANT + closeable ) ; }
catch ( IOException e ) { throw new MockitoException ( STRING_CONSTANT + reader ) ; }
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + output ) ; }
assertEquals ( asList ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , IOUtil . readLines ( new FileReader ( file ) ) ) ;
if ( ! pluginSwitcher . isEnabled ( pluginClassName ) ) { continue; }
String foundPluginClass = new PluginFinder ( pluginSwitcher ) . findPluginClass ( Iterables . toIterable ( resources ) ) ;
LinkedList < ReleaseStep > targets = new LinkedList < ReleaseStep > () ;
{ jUnitRule . apply ( new ExceptionStatement () , Description.EMPTY ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
{ injectTestCase = new InjectTestCase () ; jUnitRule = new JUnitRule ( injectTestCase ) ; }
mockSettings . defaultAnswer ( annotation . answer () . get () ) ;
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return Answers.RETURNS_DEFAULTS . get () . answer ( invocation ) ; }
Operation getStep ( int stepNumber ) ;
return new DefaultGitAuthor ( currentLocalUser , currentLocalEmail ) ;
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
{ return ( T ) reportMatcher ( Any.ANY ) . returnNull () ; }
{ return ( T ) reportMatcher ( new InstanceOf ( clazz ) ) . returnFor ( clazz ) ; }
{ return ( T ) reportMatcher ( new InstanceOf ( Object . class ) ) . returnNull () ; }
public static VersionTool getVersionTool () { return new DefaultVersionTool () ; }
int millis
public ClassLoader build () { return new InMemoryClassLoader ( inMemoryClassObjects ) ; }
catch ( ArgumentsAreDifferent e ) { error = handleVerifyException ( e ) ; }
if ( paramsMatch ( types , params ) ) { return ( T ) constructor . newInstance ( params ) ; }
catch ( InstantationException e ) { throw new MockitoException ( STRING_CONSTANT + proxyClass . getSuperclass () . getSimpleName () + STRING_CONSTANT , e ) ; }
int result = mockType . hashCode () ;
if ( ! mockType . equals ( mockKey.mockType ) ) return false ;
Class < > mockedType
{ return ( Class < ? extends T > ) previousClasses . get ( mockKey ) ; }
@ Origin Method method
@ Origin Method method
@ Origin Method method
Class < > proxyClass = new ByteBuddyMockMaker () . getOrMakeMock ( typeToMock , extraInterfaces , true ) ;
{ return ( Class < ? extends T > ) PREVIOUS_CLASSES . get ( mockKey ) ; }
PREVIOUS_CLASSES . put ( mockKey , mockType ) ;
T mock = silentConstructor . instantiate ( mockedType ) ;
if ( ! ( handler instanceof InternalMockHandler ) ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
Class < > proxyClass = new ByteBuddyMockMaker () . getOrMakeMock ( typeToMock , extraInterfaces ) ;
Class < > proxyClass = new CachingBytecodeGenerator () . get ( typeToMock , extraInterfaces ) ;
assumeTrue ( cache . size () == NUMBER_CONSTANT ) ;
assumeTrue ( cachingMockBytecodeGenerator.avoidingClassLeakageCache . size () == NUMBER_CONSTANT ) ;
byteBuddy . subclass ( mockedType , ConstructorStrategy.Default.NO_CONSTRUCTORS ) . name ( nameFor ( mockedType ) )
{ return thiz . getMockitoInterceptor () . getAcrossJVMSerializationFeature () . writeReplace ( thiz ) ; }
{ this . handler = handler ; this . mockCreationSettings = mockCreationSettings ; acrossJVMSerializationFeature = new AcrossJVMSerializationFeature () ; }
ClassImposterizerTest . class
Collections . sort ( unsortedFields , new PropertyAndSetterInjection.FieldTypeAndNameComparator () ) ;
Collections . sort ( unsortedFields , new PropertyAndSetterInjection.FieldTypeAndNameComparator () ) ;
Collections . sort ( declaredFields , superTypesLast ) ;
Collections . sort ( unsortedFields , cmp ) ;
ArrayList < Improvement > pagedImprovements = new ArrayList <> () ;
STRING_CONSTANT + mockMethod + STRING_CONSTANT + new MockUtil () . getMockName ( mock )
STRING_CONSTANT + mockMethod + STRING_CONSTANT + new MockUtil () . getMockName ( mock )
STRING_CONSTANT + new MockUtil () . getMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT
STRING_CONSTANT + new MockUtil () . getMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT
@ Before public void setup () { mock = Mockito . mock ( IMethods . class ) ; }
try { validator . validate ( new CallsRealMethods () , invocationOnInterface ) ; fail () ; } catch ( MockitoException e ) {}
catch ( MockitoException e ) {}
{ return new Timeout ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDuration () , newVerificationMode ) ; }
{ super ( new VerificationOverTimeImpl ( pollingPeriodMillis , millis , delegate , true ) ) ; }
{ return new After ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDuration () , verificationMode ) ; }
{ try { Thread . sleep ( sleep ) ; } catch ( InterruptedException ie ) {} }
{ this ( pollingPeriodMillis , durationMillis , delegate , returnOnSuccess , new Timer ( durationMillis ) ) ; }
@ Origin ( cacheMethod = true ) Method invokedMethod
@ Origin ( cacheMethod = true ) Method invokedMethod
@ Origin ( cacheMethod = true ) Method invokedMethod
ArrayList < Improvement > pagedImprovements = new ArrayList <> () ;
try { argument . getValue () ; fail () ; } catch ( MockitoException e ) {}
Mockito . verify ( c.invocationMarker ) . markVerified ( eq ( asList ( invocation ) ) , any ( CapturesArgumensFromInvocation . class ) ) ;
CapturesArgumensFromInvocation wanted
CapturesArgumensFromInvocation wanted
CapturesArgumensFromInvocation wanted
{ injectionOccurred |= injectMockCandidates ( fieldClass , newMockSafeHashSet ( mockCandidates ) , fieldInstanceNeedingInjection ) ; fieldClass = fieldClass . getSuperclass () ; }
if ( interceptor == null ) { return null ; }
{ ( ( MockMethodInterceptor.MockAccess ) mock ) . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( newHandler ) , settings ) ) ; }
MockMethodInterceptor.MockAccess mockAccess = ( MockMethodInterceptor.MockAccess ) mockInstance ;
{ return StringDescription . toString ( m ) . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertSame ( m , m . withExtraTypeInfo () ) ; }
ContainsExtraTypeInformation equals10 = new Equals ( NUMBER_CONSTANT ) ;
{ return new MatchersPrinter () . print ( m ) . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
{ ContainsExtraTypeInformation equals = new Equals ( NUMBER_CONSTANT ) ; assertFalse ( equals . typeMatches ( null ) ) ; }
{ ContainsExtraTypeInformation equals = new Equals ( null ) ; assertFalse ( equals . typeMatches ( NUMBER_CONSTANT ) ) ; }
ContainsExtraTypeInformation equals = new Equals ( NUMBER_CONSTANT ) ;
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . withExtraTypeInfo () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . withExtraTypeInfo () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
Set < Class > interfaces
Set < Class > interfaces
Class classToMock
Class classToMock
Class classToMock
Class classToMock
Set < Class > extraInterfaces
Set < Class > interfaces
Set < Class > interfaces
the_mock_type = cachingMockBytecodeGenerator . get ( withMockFeatures ( classloader_with_life_shorter_than_cache . loadClass ( STRING_CONSTANT ) , Collections . < Class > emptySet () , false ) )
Set < Class > extraInterfaces
{ byteBuddy = new ByteBuddy ( ClassFileVersion.JAVA_V5 ) . withDefaultMethodAttributeAppender ( MethodAttributeAppender.ForInstrumentedMethod.INSTANCE ) . withAttribute ( TypeAttributeAppender.ForSuperType.INSTANCE ) ; random = new Random () ; }
private static HandyReturnValues reportMatcher ( ArgumentMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
{ for ( Matcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < Matcher > matchers ) { this . matchers = matchers ; }
InvocationMatcher invocationWithMatchers = new InvocationMatcher ( invocation , ( List < Matcher > ) ( List ) lastMatchers ) ;
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( describe ( m ) , m . getTypedDescription () ) ; }
public Not ( Matcher first ) { this . first = first ; }
Matcher m
assertEquals ( name + STRING_CONSTANT , describe ( compareTo ) ) ;
{ for ( Matcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < Matcher > matchers ) { this . matchers = matchers ; }
if ( actualMatcher instanceof ContainsTypedDescription ) { return ( ( ContainsTypedDescription ) actualMatcher ) . getTypedDescription () ; } else { return HamcrestPrinter . print ( actualMatcher ) ; }
Matcher actualMatcher
Matcher matcher
private static HandyReturnValues reportMatcher ( Matcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
Matcher < Double > matcher
Matcher < Float > matcher
Matcher < Long > matcher
Matcher < Integer > matcher
Matcher < Short > matcher
Matcher < Byte > matcher
Matcher < Boolean > matcher
Matcher < Character > matcher
Matcher m
Matcher m = matchers . get ( position ) ;
List < Matcher > matchers
{ String descStr = describe ( new Equals ( null ) ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( CHAR_CONS ) ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( STRING_CONSTANT ) ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
List < Matcher > matchers
@ Test public void matchesToString () { assertEquals ( STRING_CONSTANT , describe ( new Matches ( STRING_CONSTANT ) ) ) ; }
@ Test public void findToString () { assertEquals ( STRING_CONSTANT , describe ( new Find ( STRING_CONSTANT ) ) ) ; }
@ Test public void containsToString () { assertEquals ( STRING_CONSTANT , describe ( new Contains ( STRING_CONSTANT ) ) ) ; }
@ Test public void endsWithToString () { assertEquals ( STRING_CONSTANT , describe ( new EndsWith ( STRING_CONSTANT ) ) ) ; }
@ Test public void startsWithToString () { assertEquals ( STRING_CONSTANT , describe ( new StartsWith ( STRING_CONSTANT ) ) ) ; }
@ Test public void notToString () { assertEquals ( STRING_CONSTANT , describe ( new Not ( new Equals ( NUMBER_CONSTANT ) ) ) ) ; }
assertEquals ( STRING_CONSTANT , describe ( new Equals ( o ) ) ) ;
@ Test public void equalsToStringWithChar () { assertEquals ( STRING_CONSTANT , describe ( new Equals ( CHAR_CONS ) ) ) ; }
@ Test public void equalsToStringWithString () { assertEquals ( STRING_CONSTANT , describe ( new Equals ( STRING_CONSTANT ) ) ) ; }
assertEquals ( STRING_CONSTANT , describe ( new Same ( o ) ) ) ;
@ Test public void sameToStringWithChar () { assertEquals ( STRING_CONSTANT , describe ( new Same ( CHAR_CONS ) ) ) ; }
@ Test public void sameToStringWithString () { assertEquals ( STRING_CONSTANT , describe ( new Same ( STRING_CONSTANT ) ) ) ; }
{ return reportMatcher ( new Find ( regex ) ) . < String > returnNull () ; }
public String describe () { return STRING_CONSTANT ; }
public String describe () { return STRING_CONSTANT ; }
public String describe () { return STRING_CONSTANT ; }
public String describe () { return STRING_CONSTANT ; }
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( m . describe () , m . getTypedDescription () ) ; }
ContainsTypedDescription equals10 = new Equals ( NUMBER_CONSTANT ) ;
{ return m . describe () . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
assertEquals ( name + STRING_CONSTANT , compareTo . describe () ) ;
Equals matcherWithBadDescription = new Equals ( NUMBER_CONSTANT ) { public String describe () { return STRING_CONSTANT ; } } ;
out . append ( new Equals ( array [ i ] ) . describe () ) ;
public String describe () { return STRING_CONSTANT ; }
{ ContainsTypedDescription equals = new Equals ( NUMBER_CONSTANT ) ; assertFalse ( equals . typeMatches ( null ) ) ; }
{ ContainsTypedDescription equals = new Equals ( null ) ; assertFalse ( equals . typeMatches ( NUMBER_CONSTANT ) ) ; }
ContainsTypedDescription equals = new Equals ( NUMBER_CONSTANT ) ;
{ String descStr = new Equals ( null ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( CHAR_CONS ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
public String describe () { return STRING_CONSTANT ; }
@ Test public void matchesToString () { assertEquals ( STRING_CONSTANT , new Matches ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void findToString () { assertEquals ( STRING_CONSTANT , new Find ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void containsToString () { assertEquals ( STRING_CONSTANT , new Contains ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void endsWithToString () { assertEquals ( STRING_CONSTANT , new EndsWith ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void startsWithToString () { assertEquals ( STRING_CONSTANT , new StartsWith ( STRING_CONSTANT ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new And ( matchers ) . describe () ) ;
@ Test public void notToString () { assertEquals ( STRING_CONSTANT , new Not ( new Equals ( NUMBER_CONSTANT ) ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new Or ( matchers ) . describe () ) ;
assertEquals ( STRING_CONSTANT , new Equals ( o ) . describe () ) ;
@ Test public void equalsToStringWithChar () { assertEquals ( STRING_CONSTANT , new Equals ( CHAR_CONS ) . describe () ) ; }
@ Test public void equalsToStringWithString () { assertEquals ( STRING_CONSTANT , new Equals ( STRING_CONSTANT ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new Same ( o ) . describe () ) ;
@ Test public void sameToStringWithChar () { assertEquals ( STRING_CONSTANT , new Same ( CHAR_CONS ) . describe () ) ; }
@ Test public void sameToStringWithString () { assertEquals ( STRING_CONSTANT , new Same ( STRING_CONSTANT ) . describe () ) ; }
public String describe () { return describe ( wanted ) ; }
{ out . add ( new FormattedText ( matcher . toString () ) ) ; }
MockitoMatcher matcher
private static HandyReturnValues reportMatcher ( MockitoMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
{ for ( MockitoMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < MockitoMatcher > matchers ) { this . matchers = matchers ; }
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , Arrays . < MockitoMatcher > asList ( new Equals ( NUMBER_CONSTANT ) , m ) ) ;
List < MockitoMatcher > matchers
List < MockitoMatcher > matchers
public Not ( MockitoMatcher first ) { this . first = first ; }
MockitoMatcher m
MockitoMatcher m
{ for ( MockitoMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < MockitoMatcher > matchers ) { this . matchers = matchers ; }
MockitoMatcher matcher
MockitoMatcher matcher
private static HandyReturnValues reportMatcher ( MockitoMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
MockitoMatcher < Double > matcher
MockitoMatcher < Float > matcher
MockitoMatcher < Long > matcher
MockitoMatcher < Integer > matcher
MockitoMatcher < Short > matcher
MockitoMatcher < Byte > matcher
MockitoMatcher < Boolean > matcher
MockitoMatcher < Character > matcher
MockitoMatcher m
MockitoMatcher m = matchers . get ( position ) ;
List < MockitoMatcher > matchers
List < MockitoMatcher > matchers
@ After public void resetState () { super . resetState () ; }
assertEquals ( expectedMock , returnedMock ) ;
assertEquals ( STRING_CONSTANT , dog . bark () ) ;
assertEquals ( STRING_CONSTANT , dog . bark () ) ;
if ( throwables == null ) { thenThrow ( ( Throwable ) null ) ; }
public ThrowsExceptionClass ( Class < ? extends Throwable > throwableClass ) { this . throwableClass = throwableClass ; }
{ return MOCKITO_CORE . doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return MOCKITO_CORE . doAnswer ( new DoesNothing () ) ; }
{ return MOCKITO_CORE . doAnswer ( answer ) ; }
{ return MOCKITO_CORE . doAnswer ( new CallsRealMethods () ) ; }
verify ( mock ) . simpleMethod ( anyObject () ) ;
when ( mock . oneArg ( anyObject () ) ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . oneArg ( anyObject () ) ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . oneArg ( any () ) ) . thenReturn ( STRING_CONSTANT ) ;
Instantiator instantiator = new InstantiatorProvider () . getInstantiator ( settings ) ;
byteBuddy = new ByteBuddy () . withDefaultMethodAttributeAppender ( new MethodAttributeAppender.ForInstrumentedMethod ( AnnotationAppender.ValueFilter.AppendDefaults.INSTANCE ) ) . withAttribute ( new TypeAttributeAppender.ForSuperType ( AnnotationAppender.ValueFilter.AppendDefaults.INSTANCE ) ) ;
for ( AllTestsRunner t : threads ) { t . join () ; failed = failed ? true : t . isFailed () ; }
{ pomComparator . setPair ( left , right ) ; }
ContributionsProvider contributionsProvider = Vcs . getGitProvider ( Exec . getProcessRunner ( workDir ) ) ;
ContributionsProvider contributionsProvider = Vcs . getGitProvider ( Exec.INSTANCE . getProcessRunner ( workDir ) ) ;
public MockBytecodeGenerator () { byteBuddy = new ByteBuddy () ; random = new Random () ; }
runner . addListener ( new TextListener ( System.out ) ) ;
{ return invocation . getMock () == invocation . getArguments () [ NUMBER_CONSTANT ] ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
{ return ( String ) invocation . getArguments () [ NUMBER_CONSTANT ] ; }
{ return ( String ) invocation . getArguments () [ NUMBER_CONSTANT ] ; }
{ return ( String ) invocation . getArguments () [ NUMBER_CONSTANT ] ; }
String arg = ( String ) invocation . getArguments () [ NUMBER_CONSTANT ] ;
ImportLogBean bean = ( ImportLogBean ) invocation . getArguments () [ NUMBER_CONSTANT ] ;
{ validateIndexWithinInvocationRange ( invocation ) ; return invocation . getArguments () [ actualArgumentPosition ( invocation ) ] ; }
int secondArgument = invocationOnInterface . getArgumentAt ( NUMBER_CONSTANT , int . class ) ;
{ ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; }
runner = new MockitoJUnit44Runner ( DummyTest . class ) ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
{ try { new ReturnsElementsOf ( null ) ; fail () ; } catch ( MockitoException e ) {} }
{ this . jUnitRule = new JUnitRule () ; }
{ assertEquals ( STRING_CONSTANT , e . getMessage () ) ; assertTrue ( logger . getLoggedInfo () . startsWith ( STRING_CONSTANT ) ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , listener . getStubbingInfo () ) ;
{ ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; }
{ return CoreMatchers . is ( type ) ; }
assertThat ( runner , is ( JUnit45AndHigherRunnerImpl . class ) ) ;
assertThat ( runner , is ( JUnit44RunnerImpl . class ) ) ;
assertThat ( mock , is ( List . class ) ) ;
assertTrue ( result . wasSuccessful () ) ;
{ return runnerProvider . newInstance ( STRING_CONSTANT , klass ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { runner . filter ( filter ) ; }
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
{ return CoreMatchers . isA ( ( Class ) type ) ; }
stubVoid ( mock ) . toThrow ( new RuntimeException () ) . on () . clone () ;
stubVoid ( mock ) . toThrow ( new RuntimeException () ) . on () . clone () ;
stubVoid ( mock ) . toThrow ( expected ) . on () . clear () ;
{ return new MockitoJUnitRule () ; }
stubVoid ( mock ) . toAnswer ( recordCall ) . on () . voidMethod () ;
{ jUnitRule . apply ( new UnfinishedStubbingStatement () , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
{ jUnitRule . apply ( new ExceptionStatement () , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
jUnitRule . apply ( new DummyStatement () , injectTestCase ) . evaluate () ;
public void reportOngoingStubbing ( IOngoingStubbing iOngoingStubbing ) { threadSafely () . reportOngoingStubbing ( iOngoingStubbing ) ; }
collector . verify ( methods ) . simpleMethod () ;
{ IMethods methods = mock ( IMethods . class ) ; collector . verify ( methods ) . simpleMethod () ; }
public VerificationCollectorImpl () { this . resetBuilder () ; }
new FieldSetter ( testClass , field ) . set ( newFieldInstance ) ;
new FieldSetter ( testClass , field ) . set ( newFieldInstance ) ;
InternalMockHandler handler = new MockHandlerFactory () . create ( settings ) ;
InternalMockHandler handler = new MockHandlerFactory () . create ( settings ) ;
if ( ! new BeanPropertySetter ( injectee , candidateFieldToBeInjected ) . set ( matchingMock ) ) { new FieldSetter ( injectee , candidateFieldToBeInjected ) . set ( matchingMock ) ; }
new FieldSetter ( descInstance , classNameField ) . set ( proxyClass . getCanonicalName () ) ;
{ new FieldSetter ( instance , field ) . set ( value ) ; }
MockHandler newHandler = new MockHandlerFactory () . create ( settings ) ;
MockHandler mockHandler = new MockHandlerFactory () . create ( settings ) ;
{ new FieldSetter ( testInstance , field ) . set ( mock ) ; }
{ new FieldSetter ( testClass , field ) . set ( mock ) ; }
catch ( Throwable listenerThrowable ) { new Reporter () . invocationListenerThrewException ( listener , listenerThrowable ) ; }
catch ( Throwable listenerThrowable ) { new Reporter () . invocationListenerThrewException ( listener , listenerThrowable ) ; }
{ if ( method . isAbstract () ) { new Reporter () . cannotCallAbstractRealMethod () ; } return realMethod . invoke ( mock , rawArguments ) ; }
if ( expectedMatchersSize != recordedMatchersSize ) { new Reporter () . invalidUseOfMatchers ( expectedMatchersSize , lastMatchers ) ; }
public NonGreedyNumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () , new Reporter () , new InvocationMarker () ) ; }
if ( ! invocationContainerImpl . hasInvocationForPotentialStubbing () ) { new Reporter () . incorrectUseOfApi () ; }
public NumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () , new Reporter () ) ; }
catch ( RuntimeException e ) { new Reporter () . cannotInjectDependency ( candidateFieldToBeInjected , matchingMock , e ) ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { new Reporter () . invocationListenerDoesNotAcceptNullParameters () ; }
{ if ( usingConstructor && mode == SerializableMode.ACROSS_CLASSLOADERS ) { new Reporter () . usingConstructorWithFancySerializable ( mode ) ; } }
if ( delegatedInstance . getClass () . isAssignableFrom ( classToMock ) ) { new Reporter () . mockedTypeIsInconsistentWithDelegatedInstanceType ( classToMock , delegatedInstance ) ; }
if ( ! classToMock . equals ( spiedInstance . getClass () ) ) { new Reporter () . mockedTypeIsInconsistentWithSpiedInstanceType ( classToMock , spiedInstance ) ; }
for ( Class i : extraInterfaces ) { if ( classToMock == i ) { new Reporter () . extraInterfacesCannotContainMockedType ( classToMock ) ; } }
if ( throwableClass == null || ! Throwable . class . isAssignableFrom ( throwableClass ) ) { new Reporter () . notAnException () ; }
{ if ( mockSettings . isStubOnly () ) { new Reporter () . stubPassedToVerify () ; } return new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; }
{ this . defaultAnswer = defaultAnswer ; if ( defaultAnswer == null ) { new Reporter () . defaultAnswerDoesNotAcceptNullParameter () ; } return this ; }
if ( o . isToString ( wanted . getMethod () ) ) { new Reporter () . cannotVerifyToString () ; }
{ if ( argumentPosition != LAST_ARGUMENT && argumentPosition < NUMBER_CONSTANT ) { new Reporter () . invalidArgumentRangeAtIdentityAnswerCreationTime () ; } return argumentPosition ; }
if ( unverified != null ) { new Reporter () . noMoreInteractionsWantedInOrder ( unverified ) ; }
{ if ( ! methodInfo . isVoid () ) { reporter . onlyVoidMethodsCanBeSetToDoNothing () ; } }
{ if ( methodInfo . isAbstract () ) { reporter . cannotCallAbstractRealMethod () ; } }
public MissingInvocationChecker () { this ( new InvocationsFinder () , new Reporter () ) ; }
{ if ( ! superMethod . isInvokable () ) { new Reporter () . cannotCallAbstractRealMethod () ; } return superMethod . invoke () ; }
{ if ( alreadyAssigned ) { new Reporter () . moreThanOneAnnotationNotAllowed ( field . getName () ) ; } }
if ( foundSize > maxNumberOfInvocations ) { new Reporter () . wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; }
{ if ( alreadyAssigned ) { new Reporter () . moreThanOneAnnotationNotAllowed ( field . getName () ) ; } }
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { reporter . mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
if ( stubbing == null ) { mockingProgress . reset () ; reporter . missingMethodInvocation () ; }
for ( StackTraceElement element : target ) { if ( CLEANER . apply ( element ) ) { filtered . add ( element ) ; } }
{ assertThat ( cleaner . apply ( type ( className ) ) ) . describedAs ( STRING_CONSTANT , className ) . isFalse () ; }
{ assertThat ( cleaner . apply ( type ( className ) ) ) . describedAs ( STRING_CONSTANT , className ) . isTrue () ; }
invocationMarker . markVerified ( actualInvocations , wanted ) ;
marker . markVerified ( next , wanted ) ;
public NonGreedyNumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () , new InvocationMarker () ) ; }
invocationMarker . markVerifiedInOrder ( chunk , wanted , context ) ;
marker . markVerified ( chunk . get ( NUMBER_CONSTANT ) , wantedMatcher ) ;
invocationMarker . markVerified ( actualInvocations , wanted ) ;
invocationMarker . markVerifiedInOrder ( chunk , wanted , orderingContext ) ;
invocationMarker . markVerified ( found , wanted ) ;
{ Mockito . argThat ( capturingMatcher ) ; return handyReturnValues . returnFor ( clazz ) ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnFalse () ; }
{ return reportMatcher ( matcher ) . returnChar () ; }
{ return Primitives . defaultValueForPrimitiveOrWrapper ( type ) ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnFalse () ; }
{ return reportMatcher ( matcher ) . returnChar () ; }
{ return reportMatcher ( matcher ) . < T > returnNull () ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . returnString () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . returnString () ; }
{ return reportMatcher ( new Matches ( regex ) ) . returnString () ; }
{ return reportMatcher ( new Contains ( substring ) ) . returnString () ; }
{ return ( T ) reportMatcher ( NotNull.NOT_NULL ) . returnNull () ; }
{ return reportMatcher ( NotNull.NOT_NULL ) . returnNull () ; }
{ return ( T ) reportMatcher ( Null.NULL ) . returnNull () ; }
{ return reportMatcher ( Null.NULL ) . returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnChar () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnFalse () ; }
{ return ( T ) reportMatcher ( AnyVararg.ANY_VARARG ) . returnNull () ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnNull () ; }
assertNull ( new ThreadSafeMockingProgress () . pullOngoingStubbing () ) ;
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnFalse () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnFalse () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnFalse () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new Find ( regex ) ) . returnNull () ; }
HandyReturnValues reportMatcher ( ArgumentMatcher matcher ) ;
{ if ( ENABLED && candidate . getMethodName () . contains ( STRING_CONSTANT ) ) { return false ; } return defaultCleaner . isOut ( candidate ) ; }
new ArgumentMatcher < String > () { public boolean matches ( Object argument ) { return true ; } }
Object argument
Object argument
public void setAnswersForStubbing ( List < Answer > answers ) { answersForStubbing . addAll ( answers ) ; }
public void setAnswersForStubbing ( List < Answer > answers ) { mockHandler . setAnswersForStubbing ( answers ) ; }
MockCreationSettings settings
Long longPretendingAnInt = new Long ( NUMBER_CONSTANT ) ;
Class clazz
verify ( mock ) . simpleMethod ( ( Object ) anyObject () ) ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( new HamcrestArgumentMatcher ( matcher ) ) ; }
Map map () { return null ; }
LinkedList linkedList () { return null ; }
List list () { return null ; }
public InOrderImpl ( List < Object > mocksToBeVerifiedInOrder ) { this . mocksToBeVerifiedInOrder . addAll ( mocksToBeVerifiedInOrder ) ; }
public int compareTo ( HasCompare redHerring ) ;
public int foo ( HasCompare other ) ;
public int compareTo ( HasCompareToButDoesNotImplementComparable other ) ;
public NullResultGuardian ( InternalMockHandler delegate ) { this . delegate = delegate ; }
assertFalse ( mockUtil . isSpy ( ( Class ) null ) ) ;
List < Answer > answers
assertEquals ( ( Double ) NUMBER_CONSTANT , captor . getValue () ) ;
Assert . assertNotNull ( readObject ) ;
void setAnswersForStubbing ( List < Answer > answers ) ;
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + pluginType , e ) ; }
public ArgumentMatcher getMatcher () { return matcher ; }
ArgumentMatcher matcher
void mockingStarted ( Object mock , Class classToMock ) ;
createdMocks = new LinkedList () ;
Class classToMock
void mockingStarted ( Object mock , Class classToMock ) ;
OngoingStubbing pullOngoingStubbing ( ) ;
void reportOngoingStubbing ( OngoingStubbing ongoingStubbing ) ;
void reportMatcher ( ArgumentMatcher matcher ) ;
int secondArgument = invocationOnInterface . getArgument ( NUMBER_CONSTANT ) ;
public void mockingStarted ( Object mock , Class classToMock ) { toBeFilled . add ( mock ) ; }
public CollectCreatedMocks ( List toBeFilled ) { this . toBeFilled = toBeFilled ; }
Class classToMock
public void reportOngoingStubbing ( OngoingStubbing iOngoingStubbing ) { threadSafely () . reportOngoingStubbing ( iOngoingStubbing ) ; }
{ copy ( from , to , from . getClass () , to . getClass () ) ; }
Class lhsClass = lhs . getClass () ;
Class reflectUpToClass
Class expected
Iterable < String > lines
Class actualType
Class typeToMock
Class type
Class [] argTypes
for ( Class anInterface : interfaces ) { types . add ( anInterface . getName () ) ; }
Class classToMock
Class mockedType
Class type
for ( Class i : extraInterfaces ) { if ( classToMock == i ) { throw extraInterfacesCannotContainMockedType ( classToMock ) ; } }
new SerializableMethod ( type . getMethod ( methodName , new Class [ NUMBER_CONSTANT ] ) )
{ mock ( IMethods . class , withSettings () . extraInterfaces ( ( Class [] ) null ) ) ; }
Class currentExploredClass = clazz
{ mock . add ( String . valueOf ( i ) ) ; }
Answer answer
Answer answer
public BDDStubber will ( Answer answer ) { return new BDDStubberImpl ( mockitoStubber . doAnswer ( answer ) ) ; }
public BDDStubber willAnswer ( Answer answer ) { return new BDDStubberImpl ( mockitoStubber . doAnswer ( answer ) ) ; }
Answer answer
Answer answer
return ( List ) matchers ;
Class . . . extraInterfaces
HoldingAReference ( WeakReference < Class > a ) { this . a = a ; }
Invocation next = finder . findFirstMatchingUnverifiedInvocation ( invocations , wanted , context ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedDifferentMethod ) ) ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedSimpleMethod ) ) ;
Invocation unverified = new InvocationsFinder () . findFirstUnverifiedInOrder ( data . getOrderingContext () , invocations ) ;
Invocation unverified = new InvocationsFinder () . findFirstUnverified ( data . getAllInvocations () ) ;
verify ( ( Iterable ) iterable ) . iterator () ;
Assert . assertNotNull ( ( ( Iterable ) iterable ) . iterator () ) ;
public int size ( Collection collection ) { return collection . size () ; }
public int size ( Map map ) { return map . size () ; }
ConstructorInjection.SimpleArgumentResolver resolver = new ConstructorInjection.SimpleArgumentResolver ( newSetOf ( new HashSet () , new ByteArrayOutputStream () ) ) ;
notifier . setAnswersForStubbing ( new ArrayList < Answer > () ) ;
public Set getHistogram2 () { return histogram2 ; }
public Set getHistogram1 () { return histogram1 ; }
public TreeSet getSearchTree () { return searchTree ; }
public List getAList () { return aList ; }
FailingConstructor ( Set set ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
public some_class_with_parametered_constructor ( List collaborator ) { constructor_instantiation ++ ; }
public ByteBuddyMockMaker () { cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator () ; }
public GreaterOrEqual ( Comparable < T > value ) { super ( value ) ; }
public CompareTo ( Comparable < T > value ) { this . wanted = value ; }
UnmockableHashCodeAndEquals mock = mock ( UnmockableHashCodeAndEquals . class ) ;
public GreaterThan ( Comparable < T > value ) { super ( value ) ; }
public LessOrEqual ( Comparable < T > value ) { super ( value ) ; }
public CompareEqual ( Comparable < T > value ) { super ( value ) ; }
Comparable < T > value
Comparable < T > value
Comparable < T > value
Comparable < T > value
Comparable < T > value
public LessThan ( Comparable < T > value ) { super ( value ) ; }
MethodTransformer.Simple . withModifiers ( SynchronizationState.PLAIN )
public Method getJavaMethod ( ) ;
public Class < > [] getExceptionTypes ( ) ;
public Class < > [] getParameterTypes ( ) ;
public Class < > getReturnType ( ) ;
public String getName ( ) ;
Object writeReplace ( ) throws ObjectStreamException ;
{ return o1 == null && o2 == null ; }
@ Before public void initialize_dependencies () { underTest = new ConstructorInjection ( resolver ) ; }
public VerificationMode only ( ) ;
public VerificationMode atLeastOnce ( ) ;
public VerificationMode never ( ) ;
mockingProgress . stubbingCompleted ( invocation ) ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( new HamcrestArgumentMatcher < T > ( matcher ) ) ; }
mockingProgress . setVerificationStrategy ( MockingProgressImpl . getDefaultVerificationStrategy () ) ;
{ mockingProgress . setVerificationStrategy ( MockingProgressImpl . getDefaultVerificationStrategy () ) ; }
assertThat ( new ThreadSafeMockingProgress () . pullOngoingStubbing () ) . isNull () ;
ThreadSafeMockingProgress p = new ThreadSafeMockingProgress () ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return false ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return null ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return null ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return false ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return null ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return false ; }
InvocationContainerImpl invocations = new InvocationContainerImpl ( new ThreadSafeMockingProgress () , new MockSettingsImpl () ) ;
mockingProgress . validateState () ;
mockingProgress . validateState () ;
mockingProgress . mockingStarted ( mock , typeToMock ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( null ) , AnyVararg.ANY_VARARG ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( NUMBER_CONSTANT ) , AnyVararg.ANY_VARARG ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( NUMBER_CONSTANT ) , AnyVararg.ANY_VARARG ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( AnyVararg.ANY_VARARG ) ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
public void filter ( Filter filter ) throws NoTestsRemainException { filterRequested = true ; runner . filter ( filter ) ; }
MockitoJUnitListener listener = new MockitoJUnitListener ( notifier ) ;
assertTrue ( result . wasSuccessful () ) ;
{ return runnerProvider . newInstance ( STRING_CONSTANT , klass ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { runner . filter ( filter ) ; }
notifier . fireTestFailure ( new Failure ( unnecessaryStubbings , new Reporter () . formatUnncessaryStubbingException ( testClass , stubbings . values () ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
public void filter ( Filter filter ) throws NoTestsRemainException { filterRequested = true ; runner . filter ( filter ) ; }
MockitoJUnitListener listener = new MockitoJUnitListener ( notifier ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
{ try { return new ArgumentsComparator () . argumentsMatch ( this , actualArgs ) ; } catch ( Throwable t ) { return false ; } }
return invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && new ArgumentsComparator () . argumentsMatch ( this , actual ) ;
! new TestMethodsFinder () . hasTestMethods ( klass )
MockCreationSettings < > settings
MockCreationSettings mockSettings
{ reportMatcher ( new InstanceOf ( Collection . class ) ) ; return new LinkedList () ; }
{ reportMatcher ( new InstanceOf ( Map . class ) ) ; return new HashMap () ; }
{ reportMatcher ( new InstanceOf ( Set . class ) ) ; return new HashSet () ; }
{ reportMatcher ( new InstanceOf ( List . class ) ) ; return new LinkedList () ; }
assertThat ( chunk , hasExactlyInOrder ( simpleMethodInvocation , simpleMethodInvocationTwo , simpleMethodInvocationThree ) ) ;
assertThat ( chunk , hasExactlyInOrder ( simpleMethodInvocation , simpleMethodInvocationTwo , simpleMethodInvocationThree ) ) ;
assertThat ( chunk , hasExactlyInOrder ( simpleMethodInvocation , simpleMethodInvocationTwo ) ) ;
assertThat ( filtered , hasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( t , hasOnlyThoseClassesInStackTrace ( STRING_CONSTANT ) ) ;
assertThat ( t , hasOnlyThoseClassesInStackTrace ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( result ) . isSuccessful () ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , UnfinishedStubbingException . class ) ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , TooLittleActualInvocations . class ) ;
{ Result result = runner . run ( SomeFeature . class ) ; assertThat ( result ) . isSuccessful () ; }
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT ) ) ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT ) ) ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT ) ) ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , MyAssertionError . class ) ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , UnnecessaryStubbingException . class ) ;
assertThat ( result ) . isSuccessful () ;
assertThat ( timer . isCounting () , is ( false ) ) ;
assertThat ( timer . isCounting () , is ( true ) ) ;
catch ( RuntimeException e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
{ reportMatcher ( new InstanceOf ( Iterable . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Collection . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Map . class ) ) ; return new HashMap ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Set . class ) ) ; return new HashSet ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( List . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( String . class ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Short . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Double . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Float . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Long . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Integer . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Character . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Byte . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Boolean . class ) ) ; return false ; }
public void save ( Person capture ) ;
public MyIterator < T > iterator ( ) ;
public Integer getValue ( Integer param ) ;
public Object otherMethod ( Object param ) ;
public Object someMethod ( Object param ) ;
public String targetMethod ( String arg ) ;
public void setSpy ( List spy ) { this . spy = spy ; }
public List getList () { return list ; }
assertContainsIgnoringCase ( STRING_CONSTANT , log ) ;
catch ( NeverWantedButInvoked e ) { assertNotContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NoInteractionsWanted e ) { assertNotContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , STRING_CONSTANT + mockTwo ) ;
assertContains ( STRING_CONSTANT , mockTwo . toString () ) ;
assertContains ( STRING_CONSTANT , STRING_CONSTANT + mockTwo ) ;
catch ( NeverWantedButInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( InstantiationException e ) { assertContains ( STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( SmartNullPointerException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NoInteractionsWanted e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , out ) ;
catch ( NoInteractionsWanted e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , name ) ;
assertContains ( STRING_CONSTANT , name ) ;
assertContains ( STRING_CONSTANT , name ) ;
catch ( InvalidUseOfMatchersException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NeverWantedButInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( AssertionError e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
{ String expected = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; assertContains ( expected , e . getMessage () ) ; }
catch ( UnfinishedVerificationException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
{ assertContains ( STRING_CONSTANT , e . getMessage () ) ; e . getCause () . getMessage () . equals ( STRING_CONSTANT ) ; }
assertContains ( STRING_CONSTANT , failure . getException () . getMessage () ) ;
assertTrue ( new MockUtil () . isMock ( classMock ) ) ;
assertTrue ( new MockUtil () . isMock ( interfaceMock ) ) ;
Class < > mockType = mockUtil . getMockHandler ( mock ) . getMockSettings () . getTypeToMock () ;
InternalMockHandler < Object > handler = new MockUtil () . getMockHandler ( mock ) ;
{ if ( mockUtil . typeMockabilityOf ( aClass ) . mockable () ) { constructorMockableParamsSize ++ ; } }
assertTrue ( isMock ( subClass.list ) ) ;
InternalMockHandler < Object > handler = new MockUtil () . getMockHandler ( mock ) ;
MockCreationSettings < > mockSettings = new MockUtil () . getMockSettings ( mockitoMock ) ;
new MockUtil () . isMock ( instance )
assertNotNull ( mockUtil . getMockSettings ( mock ) ) ;
assertNotNull ( mockUtil . getMockHandler ( mock ) ) ;
TypeMockability typeMockability = mockUtil . typeMockabilityOf ( classToMock ) ;
String mockName = mockUtil . getMockName ( mocks . iterator () . next () ) . toString () ;
{ if ( candidateFieldToBeInjected . getName () . equals ( mockUtil . getMockName ( mock ) . toString () ) ) { mockNameMatches . add ( mock ) ; } }
if ( new MockUtil () . isMock ( throwable ) ) { throw throwable ; }
if ( isMockOrSpy ( instance ) ) { mockUtil . maybeRedefineMockName ( instance , field . getName () ) ; return instance ; }
{ assertNotNull ( notInitializedSpy ) ; assertNotNull ( notInitializedSpy . getAList () ) ; assertTrue ( mockUtil . isMock ( notInitializedSpy ) ) ; }
@ Test public void should_inject_mocks_in_spy () { assertNotNull ( initializedSpy . getAList () ) ; assertTrue ( mockUtil . isMock ( initializedSpy ) ) ; }
MockCreationSettings parentMockSettings = new MockUtil () . getMockSettings ( parentMock ) ;
InternalMockHandler < Object > handler = new MockUtil () . getMockHandler ( invocation . getMock () ) ;
String qualifiedName = new MockUtil () . getMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () ;
new MockUtil () . isMock ( instance )
public MockingDetails mockingDetails ( Object toInspect ) { return new DefaultMockingDetails ( toInspect , new MockUtil () ) ; }
InvocationContainer invocationContainer = new MockUtil () . getMockHandler ( m ) . getInvocationContainer () ;
{ if ( mock == null ) { throw nullPassedWhenCreatingInOrder () ; } if ( ! mockUtil . isMock ( mock ) ) { throw notAMockPassedWhenCreatingInOrder () ; } }
InvocationContainer invocations = mockUtil . getMockHandler ( mock ) . getInvocationContainer () ;
for ( T m : mocks ) { mockUtil . getMockHandler ( m ) . getInvocationContainer () . clearInvocations () ; }
for ( T m : mocks ) { mockUtil . resetMock ( m ) ; }
if ( ! mockUtil . isMock ( mock ) ) { throw notAMockPassedToVerify ( mock . getClass () ) ; }
T mock = mockUtil . createMock ( creationSettings ) ;
List < Invocation > invocations = finder . find ( asList ( mockOne , mockOne , mockOne ) ) ;
List < Invocation > invocations = finder . find ( asList ( mockOne , mockTwo ) ) ;
List < Invocation > invocations = new VerifiableInvocationsFinder () . find ( inOrder . getMocksToBeVerifiedInOrder () ) ;
List < Invocation > all = new AllInvocationsFinder () . find ( createdMocks ) ;
List < Invocation > invocations = allInvocationsFinder . find ( asList ( mocks ) ) ;
assumeTrue ( ClassFileVersion . forCurrentJavaVersion () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
assumeTrue ( ClassFileVersion . forCurrentJavaVersion () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
when ( sorter . sort ( anyList () ) ) . thenReturn ( null ) ;
verify ( mockHandler ) . setAnswersForStubbing ( anyList () ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
{ results . add ( new SuperTypesLastSorter () . sort ( Arrays . asList ( o ) ) ) ; }
List < Field > sortedFields = new SuperTypesLastSorter () . sort ( unsortedFields ) ;
List < Field > l = new SuperTypesLastSorter () . sort ( Arrays . asList ( o1 , o2 ) ) ;
return new SuperTypesLastSorter () . sort ( declaredFields ) ;
new ArrayUtils () . isEmpty ( args )
public boolean isOut ( Invocation invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
public InvocationMatcher getWanted () { return wanted ; }
if ( new ObjectMethodsGuru () . isToString ( currentInvocation . getMethod () ) ) { return STRING_CONSTANT + unstubbedInvocation . toString () ; }
List < > mocks
if ( ! filterRequested && listener . isSussessful () ) { reporter . report ( testClass , notifier ) ; }
@ Test public void shouldNotifyListenerSafely ( ) throws Exception { mockingProgress . setListener ( null ) ; mockingProgress . mockingStarted ( null , null ) ; }
mockingProgress () . mockingStarted ( mock , typeToMock ) ;
throw cannotInitializeForInjectMocksAnnotation ( field . getName () , e ) ;
{ if ( value == null ) { throw new NullPointerException ( checkedValue + STRING_CONSTANT ) ; } return value ; }
@ Test ( expected = NullPointerException . class )
@ Test ( expected = NullPointerException . class )
@ Test ( expected = NullPointerException . class )
@ Test ( expected = NullPointerException . class )
public TypeVariable typeVariable () { return typeVariable ; }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = typeVariable ; }
TypeVariable [] typeParameters
if ( type instanceof TypeVariable ) { return new TypeVariableReturnType ( this , method . getTypeParameters () , ( TypeVariable ) type ) ; }
if ( wildCardBoundedType . firstBound () instanceof TypeVariable ) { return boundsOf ( ( TypeVariable ) wildCardBoundedType . firstBound () ) ; }
TypeVariable typeVariable
assertNotEquals ( NUMBER_CONSTANT , to.privateTransientField ) ;
assertNotEquals ( NUMBER_CONSTANT , to.finalField ) ;
Class classToMock
int size () { return unused . size () ; }
assumeTrue ( ClassFileVersion . forThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
assumeTrue ( ClassFileVersion . forThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
String getAuthor ( ) ;
String getAuthorId ( ) ;
public String toText () { return commits . size () + STRING_CONSTANT + author ; }
public String getAuthor () { return author ; }
public String getAuthorId () { return email ; }
UnusedStubbings ( Collection < Stubbing > unused ) { this . unused = unused ; }
if ( type instanceof Class ) { return new NotGenericReturnTypeSupport ( type ) ; }
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT ) ;
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT ) ;
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT ) ;
generatedMockClass = generate ( features ) ;
@ Test public void shouldRunInMultipleThreads ( ) throws Exception { assertFalse ( STRING_CONSTANT , runInMultipleThreads ( NUMBER_CONSTANT ) ) ; }
Class < ? extends T > type = bytecodeGenerator . mockClass ( mockWithFeaturesFrom ( settings ) ) ;
Class < ? extends T > mockedProxyType = createProxyClass ( mockWithFeaturesFrom ( settings ) ) ;
dispatcher == null || ! dispatcher . isMocked ( mock )
public AbstractByteBuddyMockMakerTest ( MockMaker mockMaker ) { this . mockMaker = mockMaker ; }
generatedMockClass = generate ( features ) ;
{ return invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && argumentsMatch ( this , actual ) ; }
given ( mock ( ConstructorArgumentResolver . class ) . resolveTypeInstances ( any ( Class [] . class ) ) )
withModifiers ( SynchronizationState.PLAIN )
{ addStep ( task , config . get ( STRING_CONSTANT ) ) ; return this ; }
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher getWanted ( ) ;
private RemoveNotMatching ( InvocationMatcher wanted ) { this . wanted = wanted ; }
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted = data . getWanted () ;
InvocationMatcher wanted = data . getWanted () ;
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wantedMatcher = data . getWanted () ;
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted = data . getWanted () ;
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted = data . getWanted () ;
public String print ( InvocationMatcher invocationMatcher ) { return print ( invocationMatcher . getMatchers () , invocationMatcher . getInvocation () ) ; }
CapturesArgumentsFromInvocation wanted
CapturesArgumentsFromInvocation wanted
CapturesArgumentsFromInvocation wanted
VerificationDataInOrderImpl dataInOrder = new VerificationDataInOrderImpl ( inOrder , invocations , data . getWanted () ) ;
MatchableInvocation wanted = data . getWanted () ;
{ assertNotNull ( listener ) ; mockingProgress () . removeListener ( listener ) ; return this ; }
{ assertNotNull ( listener ) ; mockingProgress () . addListener ( listener ) ; return this ; }
@ Before public void setUp () { executor = newSingleThreadScheduledExecutor () ; stopWatch = createNotStarted () ; }
@ Advice.BoxedReturn ( readOnly = false ) Object returned
@ Advice.BoxedArguments Object [] arguments
private ExcludeHandler ( RootDoc root ) { this . root = root ; }
public Invocation getInvocation () { return invocation ; }
{ return isMockitoMock ( mock ) && getMockSettings ( mock ) . getDefaultAnswer () == Mockito.CALLS_REAL_METHODS ; }
isMockitoMock ( mock )
mockingProgress () . stubbingCompleted ( invocation ) ;
AnnotationEngine customizedEngine = new DefaultAnnotationEngine () {} ;
AnnotationEngine annotationEngine = new GlobalConfiguration () . getAnnotationEngine () ;
{ throw new IllegalArgumentException ( String . format ( STRING_CONSTANT , classLoader ) ) ; }
public ExcludingURLClassLoaderBuilder without ( String . . . privatePrefixes ) { privateCopyPrefixes . addAll ( asList ( privatePrefixes ) ) ; return this ; }
ClassLoader cl = isolatedClassLoader () . withCurrentCodeSourceUrls () . withPrivateCopyOf ( CLASS_NAME_USING_INTERFACE ) . withPrivateCopyOf ( INTERFACE_NAME ) . build () ;
Statement statement
mock . simpleMethod ( NUMBER_CONSTANT ) ;
public void doAssert ( Throwable throwable ) { Assertions . assertThat ( throwable ) . isInstanceOf ( expected ) . hasMessage ( expectedMessage ) ; }
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
public void beforeTest ( Object testClassInstance , String testMethodName ) { MockitoAnnotations . initMocks ( testClassInstance ) ; }
public JUnitRule silent () { return new JUnitRule ( logger , true ) ; }
{ return new JUnitRule ( new ConsoleMockitoLogger () , false ) ; }
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
@ Test public void rule_validates_mockito_usage ( ) throws Throwable { rule . expectThrowable ( UnfinishedVerificationException . class ) ; verify ( mock ) ; }
rule . expectThrowable ( PotentialStubbingProblem . class ) ;
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectThrowable ( UnnecessaryStubbingException . class ) ;
rule . expectThrowable ( RuntimeException . class , STRING_CONSTANT ) ;
{ rule . expectThrowable ( UnfinishedStubbingException . class ) ; when ( mock . simpleMethod () ) ; }
{ rule . expectThrowable ( RuntimeException . class , STRING_CONSTANT ) ; throw new RuntimeException ( STRING_CONSTANT ) ; }
void doAssert ( Throwable throwable ) ;
notifyStubbedAnswerLookUp ( invocation , stubbedInvocation ) ;
List < StubbingLookUpListener > getStubbingLookUpListeners ( ) ;
public MockitoRule silent () { return new JUnitRule ( logger , Strictness.SILENT ) ; }
case SILENT :
{ return new JUnitRule ( new ConsoleMockitoLogger () , JUnitRule.Strictness.WARN ) ; }
settings . getStubbingLookupListeners ()
mockingProgress . verificationStarted ( new MockAwareVerificationMode ( mock , actualMode ) ) ;
new AnswersValidator () . validateDefaultAnswerReturnedValue ( invocation , ret ) ;
public int wantedArgumentPosition () { return wantedArgumentPosition ; }
public boolean returnsNull () { return value == null ; }
public void reportMatcher ( ArgumentMatcher matcher ) { matcherStack . push ( new LocalizedMatcher ( matcher ) ) ; }
{ this ( new StrictRunner ( new RunnerFactory () . create ( klass ) , klass ) ) ; }
{ super ( new StrictRunner ( new RunnerFactory () . create ( klass ) , klass ) ) ; }
RunnerImpl runner = provider . newInstance ( STRING_CONSTANT , this . getClass () ) ;
RunnerImpl runner
MockitoJUnitRunner ( RunnerImpl runner ) throws InvocationTargetException { this . runner = runner ; }
ClassLoadingStrategy.Default.INJECTION . with ( features.mockedType . getProtectionDomain () )
@ Override public boolean mockable () { return instrumentation . isModifiableClass ( type ) && ! EXCLUDES . contains ( type ) ; }
assertThat ( MockMethodAdvice . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ) . isSameAs ( throwable ) ;
throwable = MockMethodAdvice . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ;
if ( i != successCount ) { throw new AssertionError ( STRING_CONSTANT + successCount + STRING_CONSTANT + i + STRING_CONSTANT ) ; }
Result result = runner . run ( StubbingArgMismatchTest . class ) ;
Result result = runner . run ( UnnecessaryStubbingTest . class ) ;
{ return mock ( classToMock , withSettings () . defaultAnswer ( RETURNS_DEFAULTS ) ) ; }
return new AndroidClassLoadingStrategy ( target ) ;
MockSettings settings = withSettings () . defaultAnswer ( Mockito.CALLS_REAL_METHODS ) . name ( field . getName () ) ;
Mockito . mock ( instance . getClass () , withSettings () . spiedInstance ( instance ) . defaultAnswer ( Mockito.CALLS_REAL_METHODS ) . name ( field . getName () ) )
NestedClassWithNoArgConstructor ( String f ) {}
catch ( MockitoException e ) { Assertions . assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { Assertions . assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
throw paramsException ( cls , null ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
if ( ! argMismatchStubbings . isEmpty () ) { mismatchesReported = true ; Reporter . potentialStubbingProblemByJUnitRule ( invocation , argMismatchStubbings ) ; }
try { Mockito . framework () . addListener ( listener ) ; } catch ( RedundantListenerException e ) { throw new UnfinishedMockingException ( STRING_CONSTANT ) ; }
Failure f = result . getFailures () . iterator () . next () ;
mocking . finishMocking () ;
mocking . finishMocking () ;
mocking . finishMocking () ;
mocking . finishMocking () ;
{ mock . simpleMethod ( NUMBER_CONSTANT ) ; mock . otherMethod () ; mocking . finishMocking () ; logger . assertEmpty () ; }
assertThat ( new Runnable () { public void run () { mocking . finishMocking () ; } } ) . throwsException ( UnnecessaryStubbingException . class )
{ this . currentStrictness = strictness ; this . stubbingLookupListener . currentStrictness = strictness ; }
event . getFailure () == null && ! stubbingLookupListener.mismatchesReported
try { Mockito . framework () . addListener ( listener ) ; } catch ( RedundantListenerException e ) { Reporter . unfinishedMocking () ; }
JUnitResultAssert . assertThat ( result ) . fails ( UnfinishedMockingSessionException . class , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
JUnitResultAssert . assertThat ( result ) . succeeds ( NUMBER_CONSTANT ) ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , PotentialStubbingProblem . class ) ;
return Decamelizer . decamelizeMatcher ( matcher . getClass () . getSimpleName () ) ;
return JUnitTool . createArgumentsAreDifferentException ( message , wanted , actual ) ;
withModifiers ( SynchronizationState.PLAIN , Visibility.PUBLIC )
assertThat ( InlineByteBuddyMockMaker . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ) . isSameAs ( throwable ) ;
throwable = InlineByteBuddyMockMaker . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ;
if ( paramsMatch ( types , params ) ) { matchingConstructors . add ( constructor ) ; }
assertEquals ( STRING_CONSTANT , mock . forObject ( ( Object ) null ) ) ;
catch ( Throwable throwable ) { return null ; }
method . getName () . equals ( STRING_CONSTANT )
m . getName () . equals ( STRING_CONSTANT )
return method . getName () . equals ( STRING_CONSTANT ) ;
if ( unused . size () == NUMBER_CONSTANT ) { return; }
Type genericInterface = findGenericInteface ( match , targetBaseInterface ) ;
public Class < > [] getParameterTypes () { return method . getParameterTypes () ; }
this . arguments = ArgumentsProcessor . expandVarArgs ( mockitoMethod . isVarArgs () , args ) ;
parameterTypes = method . getParameterTypes () ;
this . arguments = ArgumentsProcessor . expandVarArgs ( mockitoMethod . isVarArgs () , arguments ) ;
{ if ( ! wantedArgumentPositionIsValidForInvocation ( invocation , argumentPosition ) ) { throw Reporter . invalidArgumentPositionRangeAtInvocationTime ( invocation , wantedArgumentPosition == LAST_ARGUMENT , wantedArgumentPosition ) ; } }
validateArgumentTypeCompatibility ( invocation , argumentPosition ) ;
public InOrderImpl ( List < ? extends Object > mocksToBeVerifiedInOrder ) { this . mocksToBeVerifiedInOrder . addAll ( mocksToBeVerifiedInOrder ) ; }
Assertions . assertThat ( m . getAllValues () ) . containsSequence ( STRING_CONSTANT , STRING_CONSTANT ) ;
Iterable < Object > mocks
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
given ( iMethods . varargsObject ( eq ( NUMBER_CONSTANT ) , anyVararg () ) ) . will ( returnsArgAt ( NUMBER_CONSTANT ) ) ;
public String foo () { return STRING_CONSTANT ; }
UnusedStubbings stubbings = new UnusedStubbings ( ( List ) asList () ) ;
List < StubbedInvocationMatcher > getStubbedInvocations ( ) ;
InternalMockHandler < T > mockHandler
{ ( ( MockAccess ) mock ) . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( newHandler ) , settings ) ) ; }
mockAccess . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( handler ) , settings ) ) ;
public NullResultGuardian ( InternalMockHandler < T > delegate ) { this . delegate = delegate ; }
InternalMockHandler < > handler = createMockHandler ( settings ) ;
InternalMockHandler < > handler = createMockHandler ( settings ) ;
InternalMockHandler handler
@ SuppressWarnings ( STRING_CONSTANT ) public < M > M getMock () { return ( M ) invocationContainerImpl . invokedMock () ; }
public void setAnswersForStubbing ( List < Answer < > > answers ) { invocationContainerImpl . setAnswersForStubbing ( answers ) ; }
this . invocationContainerImpl = new InvocationContainerImpl ( mockSettings ) ;
InvocationMatcher invocation
MockUtil . getMockHandler ( mock ) . setAnswersForStubbing ( answers ) ;
MockUtil . getMockHandler ( mock ) . getInvocationContainer () . setAnswersForStubbing ( answers ) ;
List < ? extends Stubbing > stubbings = mockHandler () . getInvocationContainer () . getStubbedInvocations () ;
InvocationContainer invocationContainer
InvocationContainer invocations
InvocationContainer invocations = getMockHandler ( mock ) . getInvocationContainer () ;
for ( T m : mocks ) { getMockHandler ( m ) . getInvocationContainer () . clearInvocations () ; }
MockCreationSettings < T > creationSettings = impl . confirm ( typeToMock ) ;
private MockHandler < Object > mockHandler () { assertGoodMock () ; return getMockHandler ( toInspect ) ; }
given ( handler.invocationContainer . findAnswerFor ( any ( InvocationImpl . class ) ) ) . willReturn ( value ) ;
{ if ( interceptor == null ) { return stubValue ; } return interceptor . doIntercept ( mock , invokedMethod , arguments , InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE ) ; }
return interceptor . doIntercept ( mock , invokedMethod , arguments , new InterceptedInvocation.SuperMethod.FromCallable ( superCall ) ) ;
Mockito . verify ( mock ) ;
{ InterceptedInvocation.RealMethod.FromCallable superMethod = new InterceptedInvocation.RealMethod.FromCallable ( realMethod ) ; return MockMethodInterceptor . createInvocation ( target , method , args , superMethod , settings ) ; }
InterceptedInvocation.RealMethod realMethod ;
{ if ( interceptor == null ) { return stubValue ; } return interceptor . doIntercept ( mock , invokedMethod , arguments , InterceptedInvocation.RealMethod.IsIllegal.INSTANCE ) ; }
return interceptor . doIntercept ( mock , invokedMethod , arguments , new InterceptedInvocation.RealMethod.FromCallable ( superCall ) ) ;
InterceptedInvocation.RealMethod realMethod
InterceptedInvocation.RealMethod realMethod
InterceptedInvocation.RealMethod realMethod
InterceptedInvocation.RealMethod realMethod
return ! node . getSort () . isResolved () || ! node . getRepresentative () . represents ( origin ) ;
if ( ! MockUtil . isMock ( mock ) ) { throw notAMockPassedToWhenMethod () ; }
UnusedStubbings stubbings = new UnusedStubbings ( Arrays . < Stubbing > asList () ) ;
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . invocationListenerDoesNotAcceptNullParameters () ; }
{ this . verificationStartedListeners . addAll ( Arrays . asList ( listeners ) ) ; return this ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . methodDoesNotAcceptNullParameters ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ if ( mock == null ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT ) ; } this . mock = mock ; }
VerificationStartedEvent event = new DefaultVerificationStartedEvent () ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event () ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event () ;
@ Test public void does_not_do_anything_when_list_is_empty ( ) throws Exception { VerificationStartedNotifier . notifyVerificationStarted ( ( List ) emptyList () , null ) ; }
public static MockitoMock getMockitoMock ( Object mock ) { return new MockitoMock ( mockMaker . getHandler ( mock ) ) ; }
mock = ( T ) VerificationStartedNotifier . notifyVerificationStarted ( handler . getMockSettings () . getVerificationStartedListeners () , mock ) ;
catch ( Exception e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
@ Test public void does_not_do_anything_when_list_is_empty ( ) throws Exception { VerificationStartedNotifier . notifyVerificationStarted ( ( List ) emptyList () , mockitoMock ) ; }
catch ( NotAMockException e ) { TestCase . assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { TestCase . assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { TestCase . assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { TestCase . assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
assertEquals ( NUMBER_CONSTANT , captor . getValue () ) ;
SerializableClass proxy = mockMaker . createMock ( serializableSettingsFor ( SerializableClass . class , SerializableMode.BASIC ) , dummyH () ) ;
OtherClass mock = mockMaker . createMock ( settingsWithConstructorFor ( OtherClass . class ) , dummyH () ) ;
SomeClass mock = mockMaker . createMock ( settingsFor ( SomeClass . class , SomeInterface . class ) , dummyH () ) ;
ClassWithDodgyConstructor mock = mockMaker . createMock ( settingsFor ( ClassWithDodgyConstructor . class ) , dummyH () ) ;
ClassWithoutConstructor proxy = mockMaker . createMock ( settingsFor ( ClassWithoutConstructor . class ) , dummyH () ) ;
SomeInterface proxy = mockMaker . createMock ( settingsFor ( SomeInterface . class ) , dummyH () ) ;
public Object getOuterClassInstance () { return outerClassInstance ; }
public SerializableMode getSerializableMode () { return serializableMode ; }
public MockName getMockName () { return mockName ; }
public Object getSpiedInstance () { return spiedInstance ; }
public Object getOuterClassInstance () { return outerClassInstance ; }
public Object getSpiedInstance () { return spiedInstance ; }
public MockName getMockName () { return mockName ; }
new SerializationFeatureKey ( params.mockedType , params.interfaces , params.serializableMode )
{ this . bytecodeGenerator = bytecodeGenerator ; typeCache = new TypeCache.WithInlineExpunction < SerializationFeatureKey > ( weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT ) ; }
{ return selfCallInfo . checkSuperCall ( instance ) && isMock ( instance ) ; }
if ( ! threads . awaitTermination ( NUMBER_CONSTANT , TimeUnit.MILLISECONDS ) ) { Assert . fail () ; }
if ( ! threads . awaitTermination ( NUMBER_CONSTANT , TimeUnit.MILLISECONDS ) ) { Assert . fail () ; }
Assert . assertEquals ( STRING_CONSTANT , mock . getFoo () ) ;
Assert . assertEquals ( STRING_CONSTANT , mock . getValue () ) ;
{ TestedObject mock = mock ( TestedObject . class , CALLS_REAL_METHODS ) ; Assert . assertEquals ( STRING_CONSTANT , mock . getValue () ) ; }
Assert . assertEquals ( STRING_CONSTANT , mock.value ) ;
{ when ( mock . getValue () ) . thenCallRealMethod () ; Assert . assertEquals ( STRING_CONSTANT , mock . getValue () ) ; }
{ verify ( mock , after ( NUMBER_CONSTANT ) . atLeast ( NUMBER_CONSTANT ) ) . oneArg ( CHAR_CONS ) ; Assert . fail ( STRING_CONSTANT ) ; }
sb . append ( STRING_CONSTANT + mock ) . append ( STRING_CONSTANT ) ;
classLoader == null ? BOOTSTRAP_LOCK : classLoader
{ return ! selfCallInfo . isSelfInvocation ( instance ) && isMock ( instance ) ; }
@ Override public boolean isMock ( Object instance ) { return interceptors . containsKey ( instance ) ; }
public Throwable getFailure () { return testFailure ; }
assertEquals ( filterLineNo ( STRING_CONSTANT + STRING_CONSTANT ) , filterLineNo ( logger . getLoggedInfo () ) ) ;
assertEquals ( filterLineNo ( STRING_CONSTANT + STRING_CONSTANT ) , filterLineNo ( logger . getLoggedInfo () ) ) ;
String getTestMethodName ( ) ;
catch ( org.mockito.internal.creation.instance.InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + type . getSimpleName () + STRING_CONSTANT , e ) ; }
catch ( org.mockito.internal.creation.instance.InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + mockedProxyType . getSuperclass () . getSimpleName () + STRING_CONSTANT , e ) ; }
catch ( InstantiationException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Test ( expected = InstantiationException . class )
if ( explosive . get () != null ) { throw new RuntimeException ( STRING_CONSTANT ) ; }
return pluginType . cast ( new InstantiatorProvider2Wrapper ( create ( InstantiatorProvider2 . class , className ) ) ) ;
{ instantiatorProvider = new InstantiatorProviderWrapper ( ( InstantiatorProvider ) impl ) ; }
{ return MockMethodInterceptor . createInvocation ( target , method , args , superMethod , settings ) ; }
this . mock . equals ( other.mock )
public String returnA () { return STRING_CONSTANT ; }
if ( ref == null ) { throw new IllegalStateException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . instanceRef = new SerializeableWeakReference < Object > ( instance ) ;
T ref = super . get () ;
this . instanceRef = new WeakReference < Object > ( instance ) ;
{ if ( throwableType == null ) { mockingProgress () . reset () ; throw notAnException () ; } return thenThrow ( newInstance ( throwableType ) ) ; }
{ new ThrowsException ( new IOException () ) . validateFor ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ; }
{ new ThrowsException ( new CharacterCodingException () ) . validateFor ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ; }
new ThrowsException ( throwableToRaise ) . answer ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ;
new ThrowsException ( mock ( Exception . class ) ) . answer ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ;
new ThrowsException ( new IllegalStateException ( STRING_CONSTANT ) ) . answer ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ;
{ if ( throwableType == null ) { return abortNullExceptionType () ; } return thenThrow ( newInstance ( throwableType ) ) ; }
List < Object > testInstances
for ( Annotation firstParamAnnotation : firstParamAnnotations ) { if ( annotationClass . isAssignableFrom ( firstParamAnnotation . getClass () ) ) { return ( T ) firstParamAnnotation ; } }
{ if ( field . isAnnotationPresent ( u ) ) { throw unsupportedCombinationOfAnnotations ( annotation . getSimpleName () , annotation . getClass () . getSimpleName () ) ; } }
if ( isPrimitiveOrWrapper ( valueClass ) && isPrimitiveOrWrapper ( referenceType ) ) { return Primitives . primitiveTypeOf ( valueClass ) . isAssignableFrom ( referenceType ) ; }
assertThat ( subList . isEmpty () ) ;
@ SuppressWarnings ( STRING_CONSTANT )
if ( isComingFromJDK ( type ) || isComingFromSignedJar ( type ) || isComingFromSealedPackage ( type ) ) { typeName = STRING_CONSTANT + typeName ; }
assumeFalse ( System . getProperty ( STRING_CONSTANT ) . startsWith ( STRING_CONSTANT ) ) ;
{ super ( Opcodes.ASM5 , cv ) ; this . typeDescription = typeDescription ; }
@ SuppressWarnings ( STRING_CONSTANT ) private MockitoExtension () { this ( Strictness.STRICT_STUBS ) ; }
if ( rawArguments == matcherCount && isLastMatcherVargargMatcher ( matchers ) ) { return MATCH_EACH_VARARGS_WITH_LAST_MATCHER ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . legendLabelURLGenerator = generator ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . legendLabelToolTipGenerator = generator ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . urlGenerator = generator ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . toolTipGenerator = generator ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . simpleLabels = simple ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . labelShadowPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . labelOutlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . labelOutlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . labelBackgroundPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . labelLinkMargin = margin ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . labelLinksVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . maximumLabelWidth = width ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . labelGap = gap ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . labelGenerator = generator ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . shadowYOffset = offset ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . shadowXOffset = offset ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . shadowPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . sectionOutlineStrokeMap . put ( key , stroke ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . sectionOutlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . sectionOutlinePaintMap . put ( key , paint ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . sectionOutlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . sectionOutlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . sectionPaintMap . put ( key , paint ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . sectionPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . ignoreZeroValues = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . ignoreNullValues = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . circular = circular ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
if ( this . interiorGap != percent ) { this . interiorGap = percent ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . startAngle = angle ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . radiusGridlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . radiusGridlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . radiusGridlinesVisible != visible ) { this . radiusGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . angleGridlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . angleGridlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . angleGridlinesVisible != visible ) { this . angleGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . angleLabelsVisible != visible ) { this . angleLabelsVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . cornerTextItems . clear () ; this . notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( removed ) { this . notifyListeners ( new PlotChangeEvent ( this ) ) ; }
this . notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . urlGenerator = generator ; this . notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . toolTipGenerator = generator ; this . notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . seriesOutlineStrokeList . setStroke ( series , stroke ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . seriesOutlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . seriesOutlinePaintList . setPaint ( series , paint ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . seriesOutlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . seriesPaintList . setPaint ( series , paint ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . seriesPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . axisLabelGap = gap ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . interiorGap != percent ) { this . interiorGap = percent ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . maxValue = value ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . startAngle = angle ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . headPercent = percent ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . webFilled = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . sectionDepth = sectionDepth ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . outerSeparatorExtension = percent ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . innerSeparatorExtension = percent ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . separatorsVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . intervals . clear () ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . dialOutlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . drawBorder = draw ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . dialBackgroundPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . tickLabelPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . tickLabelFont = font ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . tickLabelsVisible != visible ) { this . tickLabelsVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . units = units ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . gap = gap ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . rangeCrosshairPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . rangeCrosshairStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . rangeCrosshairValue = value ; if ( isRangeCrosshairVisible () && notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
if ( this . rangeCrosshairLockedOnData != flag ) { this . rangeCrosshairLockedOnData = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . rangeCrosshairVisible != flag ) { this . rangeCrosshairVisible = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . domainCrosshairPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . domainCrosshairStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . domainCrosshairValue = value ; if ( isDomainCrosshairVisible () && notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
if ( this . domainCrosshairLockedOnData != flag ) { this . domainCrosshairLockedOnData = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . domainCrosshairVisible != flag ) { this . domainCrosshairVisible = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . annotations != null ) { this . annotations . clear () ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . rangeMarkers != null ) { this . rangeMarkers . clear () ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . domainMarkers != null ) { this . domainMarkers . clear () ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . colorBar = axis ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . colorBarLocation = edge ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . gap = gap ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . gap = gap ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . columnRadius = r ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . bulbRadius = r ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . useSubrangePaint = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . followDataInSubranges = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . subrangePaint [ range ] = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . showValueLines = b ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . valuePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . valueFont = f ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . axisLocation = location ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . valueLocation = location ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . units != u ) { this . units = u ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ if ( paint != null ) { this . thermometerPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
{ if ( s != null ) { this . thermometerStroke = s ; notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . limit = limit ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ super . setFixedRangeAxisSpace ( space ) ; setFixedRangeAxisSpaceForSubplots ( space ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . gap = gap ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . drawBorder = status ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . labelType != type ) { this . labelType = type ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . darkerSides = darker ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . depthFactor = factor ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . renderingHints . put ( RenderingHints.KEY_TEXT_ANTIALIASING , val ) ; this . notifyListeners ( new ChartChangeEvent ( this ) ) ; }
{ this . notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . datasetToScaleMap . set ( index , new Integer ( scaleIndex ) ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
{ result = iterateXYRangeBounds ( dataset ) ; }
{ result = iterateCategoryRangeBounds ( dataset , includeInterval ) ; }
public void datasetChanged ( DatasetChangeEvent event ) { this . notifyListeners ( event ) ; }
double gap = Math . max ( NUMBER_CONSTANT , height - sumOfLabelHeights ) ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
Range r = DatasetUtilities . findRangeBounds ( d , false ) ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
double delta = NUMBER_CONSTANT ;
XYSeries series = new XYSeries ( STRING_CONSTANT ) ;
{ if ( stroke instanceof BasicStroke ) { this . setData ( stroke ) ; } else { throw new RuntimeException ( STRING_CONSTANT ) ; } }
double maxWidth = space * getMaxItemWidth () ;
{ super(); setBaseToolTipGenerator ( toolTipGenerator ) ; setURLGenerator ( urlGenerator ) ; setShapesVisible ( false ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
public long getSerialIndex () { return this . time . getTime () ; }
{ return this . time . getTime () ; }
public long getMiddleMillisecond () { return this . time . getTime () ; }
{ return this . time . getTime () ; }
public long getLastMillisecond () { return this . time . getTime () ; }
{ return this . time . getTime () ; }
public long getFirstMillisecond () { return this . time . getTime () ; }
difference = this . time . getTime () - t1.time . getTime () ;
public int hashCode () { return this . time . hashCode () ; }
{ FixedMillisecond m = ( FixedMillisecond ) object ; return this . time . equals ( m . getTime () ) ; }
long t = this . time . getTime () ;
long t = this . time . getTime () ;
public Date getTime () { return this . time ; }
{ this . time = time ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
public Date getUpperDate () { return this . upperDate ; }
public Date getLowerDate () { return this . lowerDate ; }
entities != null && dataArea . contains ( xx , yy )
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
public Date getEnd () { return this . end ; }
public Date getStart () { return this . start ; }
RelativeDateFormat rdf = new RelativeDateFormat ( c0 . getTimeInMillis () ) ;
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
final long skip
if ( pointCount < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( periodCount < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
this . setChart ( chart ) ;
this . setLayout ( layout ) ;
this . setLayout ( layout ) ;
this . setLayout ( layout ) ;
{ this ( parent , style ) ; this . setColor ( color ) ; }
if ( dataset != null ) { this . setDataset ( dataset ) ; }
Paint paint = lookupSectionPaint ( key , true ) ;
Paint paint = lookupSectionPaint ( key , true ) ;
Paint paint = lookupSectionPaint ( key , true ) ;
SWTEventListener listener
if ( currentGridBandIsDark ) { g2 . setPaint ( this . gridBandPaint ) ; } else { g2 . setPaint ( Color.white ) ; }
if ( currentGridBandIsDark ) { g2 . setPaint ( this . gridBandPaint ) ; } else { g2 . setPaint ( Color.white ) ; }
this . autoPopulateSeriesStroke = false ;
g2 . setPaint ( Color.gray ) ;
g2 . setPaint ( Color.gray ) ;
Paint paint = renderer . getItemPaint ( row , column ) ;
new Object [] { new Integer ( - s ) , new Double ( negBase ) }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
{ if ( this . year < SerialDate.MAXIMUM_YEAR_SUPPORTED ) { return new Year ( this . year + NUMBER_CONSTANT ) ; } else { return null ; } }
if ( ( year < SerialDate.MINIMUM_YEAR_SUPPORTED ) || ( year > SerialDate.MAXIMUM_YEAR_SUPPORTED ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + year + STRING_CONSTANT ) ; }
final TimeZone zone
{ return createStandardDateTickUnits ( TimeZone . getDefault () ) ; }
Calendar calendar = Calendar . getInstance ( this . timeZone ) ;
Calendar calendar = Calendar . getInstance ( this . timeZone ) ;
assertEquals ( false , r . getAutoPopulateSeriesStroke () ) ;
if ( item == dataset . getItemCount ( series ) - NUMBER_CONSTANT ) { drawFirstPassShape ( g2 , pass , series , item , s.seriesPath ) ; }
this . minorTickCount = NUMBER_CONSTANT ;
{ this . minorTickMarkOutsideLength = length ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . minorTickMarkInsideLength = length ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
{ this . tickMarkStroke = stroke ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . tickMarkOutsideLength = length ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . tickMarkInsideLength = length ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( flag != this . tickMarksVisible ) { this . tickMarksVisible = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . tickLabelInsets = insets ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
{ this . tickLabelFont = font ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( flag != this . minorTickMarksVisible ) { this . minorTickMarksVisible = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( flag != this . tickLabelsVisible ) { this . tickLabelsVisible = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
{ this . axisLineVisible = visible ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . labelAngle = angle ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . labelInsets = insets ; if ( notify ) { notifyListeners ( new AxisChangeEvent ( this ) ) ; } }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
{ this . labelFont = font ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( flag != this . visible ) { this . visible = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
public static Test suite () { return new TestSuite ( CategoryAxisTests . class ) ; }
catch ( Exception e ) { success = false ; }
catch ( Exception e ) { success = false ; }
renderer1 . setToolTipGenerator ( StandardXYToolTipGenerator . getTimeSeriesInstance () ) ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
this . shell . setText ( ResourceBundle . getBundle ( STRING_CONSTANT ) . getString ( STRING_CONSTANT ) ) ;
ResourceBundle resources = ResourceBundle . getBundle ( baseName ) ;
ResourceBundle resources = ResourceBundle . getBundle ( baseResourceClass ) ;
result = NUMBER_CONSTANT * result + this . unit ;
TimeSeries overwritten = new TimeSeries ( STRING_CONSTANT + getKey () , series . getTimePeriodClass () ) ;
{ throw new SeriesException ( STRING_CONSTANT ) ; }
{ this ( name , DEFAULT_DOMAIN_DESCRIPTION , DEFAULT_RANGE_DESCRIPTION , Day . class ) ; }
drawZoomRectangle ( g2 ) ;
if ( ! useBuffer ) { drawZoomRectangle ( g2 , true ) ; }
{ return zoomFillPaint ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; System.err . println ( STRING_CONSTANT ) ; }
return new Color ( g , g , g ) ;
this . shadowsVisible = true ;
this . shadowsVisible = true ;
if ( dataset == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
Calendar calendar = Calendar . getInstance ( zone ) ;
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
Paint paint = renderer . getItemPaint ( row , column ) ;
StrokeChooserPanel panel = new StrokeChooserPanel ( null , this . availableStrokeSamples ) ;
StrokeChooserPanel panel = new StrokeChooserPanel ( null , this . availableStrokeSamples ) ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
{ this ( label , first , last , TimeZone . getDefault () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
TimeSeries result = new TimeSeries ( name , source . getTimePeriodClass () ) ;
TimeSeries series1 = new TimeSeries ( STRING_CONSTANT , Month . class ) ;
calendar . add ( unit . getCalendarField () , unit . getCount () ) ;
public boolean isOutlineVisible () { return outlineVisible ; }
{ return maxY ; }
{ return minY ; }
{ return maxX ; }
{ return minX ; }
clone.zValues = DataUtilities . clone ( zValues ) ;
public Stroke getLabelOutlineStroke () { return labelOutlineStroke ; }
s1 . updateByIndex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
s1 . updateByIndex ( NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
rangeAxis . resizeRange ( factor , anchorY ) ;
rangeAxis . resizeRange ( factor , anchorY ) ;
domainAxis . resizeRange ( factor , anchorX ) ;
{ return STRING_CONSTANT + ImageMapUtilities . htmlEscape ( toolTipText ) + STRING_CONSTANT ; }
{ if ( ! Double . isNaN ( hiY ) ) { result = Math . min ( result , hiY ) ; } }
this . domainAxis . resizeRange ( factor , anchorX ) ;
{ super ( renderer ) ; this . renderer = renderer ; }
this . rangePannable = true ;
( mods & InputEvent.CTRL_MASK ) == InputEvent.CTRL_MASK
if ( entities != null ) { addItemEntity ( entities , dataset , row , column , hotspot ) ; }
public NumberAxis3D ( String label ) { super ( label ) ; setAxisLineVisible ( false ) ; }
this . stripOutlineVisible = false ;
TimeSeries series = new TimeSeries ( name , start . getClass () ) ;
catch ( Exception e ) { success = false ; }
Line2D line = new Line2D.Double ( startX , startY , endX , endY ) ;
if ( this . showBase ) { result . append ( this . baseLabel ) ; result . append ( STRING_CONSTANT ) ; }
{ this . legendShape . setShape ( series , shape ) ; fireChangeEvent () ; }
{ return this . legendShape . getShape ( series ) ; }
return super . hashCode () ;
double ol = getTickMarkOutsideLength () ;
double transY0 = restrictValueToDataArea ( getRangeBase () , plot , dataArea ) ;
Paint seriesPaint = getFirstBarPaint () ;
double value = Double.NaN ;
Rectangle2D titleArea = new Rectangle2D.Double () ;
double x0 = dataArea . getX () ;
TimeSeriesDataItem item = series . getDataItem ( i ) ;
{ return getDataItem ( index ) . getValue () ; }
{ return getDataItem ( index ) . getPeriod () ; }
XYDataItem item = getDataItem ( index ) ;
{ return getDataItem ( index ) . getY () ; }
{ return getDataItem ( index ) . getX () ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
{ return this . coefficients . clone () ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
{ return this . dataset ; }
double maxRadius = plot . getMaxRadius () ;
notifyListeners ( new DatasetChangeEvent ( this , this ) ) ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
Line2D line = new Line2D.Double ( startX , startY , endX , endY ) ;
{ super ( info ) ; this . area = new Polygon () ; this . line = new Line2D.Double () ; }
{ this . shapesVisible = shapesVisible ; }
JPopupMenu result = new JPopupMenu ( STRING_CONSTANT ) ;
String text = STRING_CONSTANT ;
public boolean isCounterClockwise () { return counterClockwise ; }
public double getAngleOffset () { return angleOffset ; }
outlinePaint != null && outlineStroke != null
{ XYSeriesCollection c1 = new XYSeriesCollection () ; assertTrue ( c1 instanceof PublicCloneable ) ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( PropertyVetoException e ) { throw new IllegalArgumentException ( e . getMessage () , e ) ; }
this . shadowGenerator = new DefaultShadowGenerator () ;
this . shadowGenerator = new DefaultShadowGenerator () ;
this . maxY = minIgnoreNaN ( this . maxY , yy ) ;
if ( ! file . exists () ) { throw new ServletException ( STRING_CONSTANT + file . getAbsolutePath () + STRING_CONSTANT ) ; }
public boolean isRadiusMinorGridlinesVisible () { return radiusMinorGridlinesVisible ; }
assertTrue ( plot != null ) ;
catch ( Exception e ) { fail ( e . toString () ) ; }
catch ( Exception e ) { fail ( e . toString () ) ; }
catch ( Exception e ) { fail ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; System.err . println ( STRING_CONSTANT ) ; }
result = Range . combine ( result , r ) ;
boolean include = true ;
{ setItemLabelsVisible ( BooleanUtilities . valueOf ( visible ) ) ; }
{ setBaseItemLabelsVisible ( BooleanUtilities . valueOf ( visible ) ) ; }
{ setSeriesItemLabelsVisible ( series , BooleanUtilities . valueOf ( visible ) ) ; }
{ setSeriesShapesFilled ( series , BooleanUtilities . valueOf ( flag ) ) ; }
{ setShapesFilled ( BooleanUtilities . valueOf ( filled ) ) ; }
{ setSeriesShapesVisible ( series , BooleanUtilities . valueOf ( visible ) ) ; }
{ setShapesVisible ( BooleanUtilities . valueOf ( visible ) ) ; }
{ setSeriesLinesVisible ( series , BooleanUtilities . valueOf ( visible ) ) ; }
{ setLinesVisible ( BooleanUtilities . valueOf ( visible ) ) ; }
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return c . getTime () . getTime () - NUMBER_CONSTANT ;
return c . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
if ( dimension > NUMBER_CONSTANT ) { space . ensureAtLeast ( dimension , edge ) ; }
return c . getTimeInMillis () ;
if ( counterClockwise ) angleDegrees = - angleDegrees ;
if ( sectionKeys . size () == NUMBER_CONSTANT ) { return; }
{ this . stepped = stepped ; return; }
{ this . paletteName = paletteName ; return; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
LegendItem result = null ;
if ( this . data . size () == NUMBER_CONSTANT ) { return; }
ValueAxis valueAxis = null ;
double dim = NUMBER_CONSTANT ;
Line2D line = null ;
Line2D line = null ;
boolean paintLine = false ;
ValueAxis valueAxis = null ;
ValueAxis valueAxis = null ;
Range adjusted = null ;
AxisState state = null ;
Rectangle2D bounds = null ;
CategoryToolTipGenerator result = null ;
try { clone = super . clone () ; } catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
Range adjusted = null ;
EntityBlockParams ebp = null ;
ToolTipTagFragmentGenerator toolTipTagFragmentGenerator = null ;
int result = NUMBER_CONSTANT ;
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
public void valueBound ( HttpSessionBindingEvent event ) { return; }
public void init ( ) throws ServletException { return; }
float l = NUMBER_CONSTANT ;
double result = NUMBER_CONSTANT ;
catch ( Exception e ) { e . printStackTrace () ; }
catch ( PropertyVetoException e ) { throw new IllegalArgumentException ( e ) ; }
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . tickMarkPosition = position ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
double result = Double.NaN ;
{ this . labelInfo = info ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . minorTickMarkOutsideLength = length ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . minorTickMarkInsideLength = length ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . minorTickMarkPaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . minorTickMarkStroke = stroke ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . minorTickTimePeriodClass = c ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . minorTickMarksVisible = visible ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . majorTickTimePeriodClass = c ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . autoRangeTimePeriodClass = c ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
this . dateFormat = dateFormat ;
{ this . categoryLabelToolTips . clear () ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
{ ParamChecks . nullNotPermitted ( positions , STRING_CONSTANT ) ; this . categoryLabelPositions = positions ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . maximumCategoryLabelWidthRatio = ratio ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . maximumCategoryLabelLines = lines ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . categoryMargin = margin ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . upperMargin = margin ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . lowerMargin = margin ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
Range adjusted = null ;
{ this . minorTickCount = count ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . standardTickUnits = source ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . autoTickUnitSelection = flag ; if ( notify ) { notifyListeners ( new AxisChangeEvent ( this ) ) ; } }
if ( notify ) { notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
{ ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ; this . defaultAutoRange = range ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( notify ) { notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( notify ) { notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( this . inverted != flag ) { this . inverted = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . rightArrow = arrow ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . leftArrow = arrow ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . downArrow = arrow ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . upArrow = arrow ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . negativeArrowVisible = visible ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . positiveArrowVisible = visible ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( this . verticalTickLabels != flag ) { this . verticalTickLabels = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandAlternatePaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandPaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( this . gridBandsVisible != flag ) { this . gridBandsVisible = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . numberFormatOverride = formatter ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( notify ) { notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
Date result = null ;
@ Override public int hashCode () { return super . hashCode () ; }
assertTrue ( url2 == url1 ) ;
assertTrue ( tt2 == tt ) ;
assertTrue ( url2 == url1 ) ;
assertTrue ( tt2 == tt ) ;
{ return ChartFactory . createPieChart3D ( STRING_CONSTANT , dataset , true , true , false ) ; }
return ChartFactory . createPieChart ( STRING_CONSTANT , data , true , true , false ) ;
{ return createXYAreaChart ( title , xAxisLabel , yAxisLabel , dataset ) ; }
try { series2 . setKey ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException e ) {}
this . maxY = minIgnoreNaN ( this . maxY , yy ) ;
double gap = hh * getInteriorGap () ;
Date result = null ;
Line2D line = null ;
Line2D line = null ;
boolean paintLine = false ;
CategoryAxis axis = null ;
RectangleEdge result = null ;
ItemLabelPosition position = null ;
ItemLabelPosition position = null ;
( float ) regions [ NUMBER_CONSTANT ] . getMaxX ()
double result = NUMBER_CONSTANT ;
StringBuffer tag = new StringBuffer () ;
StringBuffer result = new StringBuffer () ;
StringBuffer result = new StringBuffer () ;
StringBuffer result = new StringBuffer () ;
StringBuffer sb = new StringBuffer () ;
ToolTipTagFragmentGenerator toolTipTagFragmentGenerator = null ;
Shape box = null ;
Shape box = null ;
ItemLabelPosition position = null ;
ItemLabelPosition position = null ;
double space = NUMBER_CONSTANT ;
int historyIdx = NUMBER_CONSTANT ;
Range result = null ;
String result = null ;
double startX = NUMBER_CONSTANT ;
BlockContainer result = null ;
boolean include = true ;
String label = null ;
boolean paintLine = false ;
int izV = NUMBER_CONSTANT ;
int izV = NUMBER_CONSTANT ;
DrawingSupplier result = null ;
Arc2D notch = null ;
double space = NUMBER_CONSTANT ;
double yyAverage = NUMBER_CONSTANT ;
double aRadius = NUMBER_CONSTANT ;
Line2D line = null ;
Line2D line = null ;
int series = NUMBER_CONSTANT ;
int series = NUMBER_CONSTANT ;
double rectWidth = NUMBER_CONSTANT ;
double rectHeight = NUMBER_CONSTANT ;
boolean visible = false ;
Paint p = null ;
@ Test
DefaultXYDataset d = new DefaultXYDataset () { public DomainOrder getDomainOrder () { return DomainOrder.DESCENDING ; } } ;
DefaultXYDataset d = new DefaultXYDataset () { public DomainOrder getDomainOrder () { return DomainOrder.ASCENDING ; } } ;
DefaultXYDataset d = new DefaultXYDataset () { public DomainOrder getDomainOrder () { return DomainOrder.DESCENDING ; } } ;
DefaultXYDataset d = new DefaultXYDataset () { public DomainOrder getDomainOrder () { return DomainOrder.ASCENDING ; } } ;
boolean success = false ;
boolean success = false ;
boolean success = false ;
boolean success = false ;
boolean success = false ;
boolean success = false ;
boolean success = false ;
new Rectangle2D.Double ( Math . min ( x1 , x2 ) , dataArea . getMinY () , Math . abs ( x2 - x1 ) , dataArea . getWidth () )
return DIRECTIONS [ index ] ;
{ if ( y <= this . minY || y >= this . maxY ) { findBoundsByIteration () ; } }
findBoundsByIteration () ;
if ( removed ) { findBoundsByIteration () ; if ( notify ) { fireSeriesChanged () ; } }
if ( removed ) { findBoundsByIteration () ; if ( notify ) { fireSeriesChanged () ; } }
{ findBoundsByIteration () ; }
{ findBoundsByIteration () ; }
Line2D extendedSeparator = extendLine ( separator , this . innerSeparatorExtension , this . outerSeparatorExtension ) ;
setRange ( calculateValue ( log1 ) , calculateValue ( log2 ) ) ;
{ this . attributedLabels . set ( section , label ) ; }
{ super ( labelFormat , numberFormat , percentFormat ) ; this . attributedLabels = new ObjectList () ; }
CategoryPlot p2 = null ;
CategoryPlot p2 = null ;
CategoryPlot p2 = null ;
{ this . itemURLGeneratorList . set ( series , generator ) ; fireChangeEvent () ; }
{ this . toolTipGeneratorList . set ( series , generator ) ; fireChangeEvent () ; }
{ return ( CategoryToolTipGenerator ) this . toolTipGeneratorList . get ( series ) ; }
{ this . itemLabelGeneratorList . set ( series , generator ) ; fireChangeEvent () ; }
this . datasets . set ( index , dataset ) ;
this . rangeAxisLocations . set ( index , location ) ;
int result = this . rangeAxes . indexOf ( axis ) ;
this . rangeAxes . set ( index , axis ) ;
this . domainAxisLocations . set ( index , location ) ;
this . domainAxes . set ( index , axis ) ;
{ this . toolTipGeneratorList . set ( series , generator ) ; fireChangeEvent () ; }
{ return ( XYToolTipGenerator ) this . toolTipGeneratorList . get ( series ) ; }
{ this . itemLabelGeneratorList . set ( series , generator ) ; fireChangeEvent () ; }
{ return ( XYItemLabelGenerator ) this . itemLabelGeneratorList . get ( series ) ; }
{ this . legendTextFont . set ( series , font ) ; fireChangeEvent () ; }
{ return ( Font ) this . legendTextFont . get ( series ) ; }
{ this . negativeItemLabelPositionList . set ( series , position ) ; if ( notify ) { fireChangeEvent () ; } }
{ this . positiveItemLabelPositionList . set ( series , position ) ; if ( notify ) { fireChangeEvent () ; } }
{ this . itemLabelFontList . set ( series , font ) ; if ( notify ) { fireChangeEvent () ; } }
{ return ( Font ) this . itemLabelFontList . get ( series ) ; }
int result = this . rangeAxes . indexOf ( axis ) ;
int result = this . domainAxes . indexOf ( axis ) ;
this . renderers . set ( index , renderer ) ;
this . datasets . set ( index , dataset ) ;
this . rangeAxisLocations . set ( index , location ) ;
this . rangeAxes . set ( index , axis ) ;
this . rangeAxes . set ( NUMBER_CONSTANT , axis ) ;
this . domainAxisLocations . set ( index , location ) ;
this . domainAxes . set ( index , axis ) ;
try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace () ; }
if ( nDataPoints > this . valueHistory . length ) { throw new IllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
try { copy . add ( clone ) ; } catch ( SeriesException e ) { System.err . println ( STRING_CONSTANT ) ; }
{ super ( null , null , rangeAxis , null ) ; this . subplots = new java.util.ArrayList () ; }
{ super ( null , domainAxis , null , null ) ; this . subplots = new java.util.ArrayList () ; }
double adj = - percent * length ;
{ return this . fmImage . createGraphics () . getFontRenderContext () ; }
ChartPanel chartPanel = new ChartPanel ( chart ) ;
public FixedMillisecond ( long millisecond ) { this ( new Date ( millisecond ) ) ; }
int response = JOptionPane . showConfirmDialog ( this , fileExists , STRING_CONSTANT , JOptionPane.OK_CANCEL_OPTION ) ;
int response = JOptionPane . showConfirmDialog ( this , fileExists , STRING_CONSTANT , JOptionPane.OK_CANCEL_OPTION ) ;
XYDataset data
ChartPanel panel = new ChartPanel ( chart ) ;
ChartPanel panel = new ChartPanel ( chart ) ;
this . panel = new ChartPanel ( this . chart ) ;
r1 . setBaseLegendTextPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.green ) ) ;
g2 . draw ( new Line2D.Double ( xxMin , yymid - halfW , xxMin , yy + halfW ) ) ;
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . chartMouseListeners . remove ( listener ) ; }
if ( ! this . hasUniqueID ( handler ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + handler . getID () + STRING_CONSTANT ) ; }
viewer . hideZoomRectangle () ;
viewer . showZoomRectangle ( x , y , w , h ) ;
ValueAxis xAxis = this . getDomainAxisForDataset ( datasetIndex ) ;
updateCrosshairValues ( crosshairState , x , y , datasetIndex , block . getCenterX () , block . getCenterX () , orientation ) ;
if ( entities != null ) { addEntity ( entities , block , dataset , series , item , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ result . put ( key , ObjectUtilities . clone ( value ) ) ; }
{ result . add ( ObjectUtilities . clone ( obj ) ) ; }
if ( this . data != null ) { clone.data = ArrayUtilities . clone ( this . data ) ; }
result = NUMBER_CONSTANT * result + ObjectUtilities . hashCode ( this . fillPaint ) ;
if ( ! PaintUtilities . equal ( this . groupPaint , that.groupPaint ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
{ stream . defaultReadObject () ; this . chartArea = ( Rectangle2D ) SerialUtilities . readShape ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . chartArea , stream ) ; }
if ( ! PaintUtilities . equal ( p1 , p2 ) ) { return false ; }
Paint paint = SerialUtilities . readPaint ( in ) ;
Shape rotatedBox = ShapeUtilities . rotateShape ( box , position . getAngle () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Shape rotatedBox = ShapeUtilities . rotateShape ( box , position . getAngle () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( ! ObjectUtilities . equal ( this . date , that.date ) ) { return false ; }
RefineryUtilities . centerFrameOnScreen ( demo ) ;
{ stream . defaultReadObject () ; setArea ( SerialUtilities . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( getArea () , stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendShape , stream ) ; }
{ stream . defaultReadObject () ; this . legendShape = SerialUtilities . readShape ( stream ) ; }
if ( ! ShapeUtilities . equal ( this . legendShape , that.legendShape ) ) { return false ; }
result.subplots = ( List ) ObjectUtilities . deepClone ( this . subplots ) ;
if ( ! ObjectUtilities . equal ( this . subplots , that.subplots ) ) { return false ; }
clone.legendItemShape = ShapeUtilities . clone ( this . legendItemShape ) ;
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
if ( ! ObjectUtilities . equal ( this . data , that.data ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendArea , stream ) ; }
{ stream . defaultReadObject () ; this . legendArea = SerialUtilities . readShape ( stream ) ; }
if ( ! ShapeUtilities . equal ( this . legendArea , that.legendArea ) ) { return false ; }
clone.legendArea = ShapeUtilities . clone ( this . legendArea ) ;
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendBar , stream ) ; }
{ stream . defaultReadObject () ; this . legendBar = SerialUtilities . readShape ( stream ) ; }
if ( ! ObjectUtilities . equal ( this . arrowStroke , that.arrowStroke ) ) { return false ; }
{ stream . defaultReadObject () ; this . subLabelPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . subLabelPaint , stream ) ; }
if ( ! ObjectUtilities . equal ( this . formatter , that.formatter ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . image , that.image ) ) { return false ; }
{ addEntity ( info , ShapeUtilities . createLineRegion ( line , NUMBER_CONSTANT ) , rendererIndex , toolTip , url ) ; }
clone.rows = ( List ) ObjectUtilities . deepClone ( this . rows ) ;
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
return ObjectUtilities . equal ( this . data , that.data ) ;
hash = NUMBER_CONSTANT * hash + ObjectUtilities . hashCode ( this . seriesKey ) ;
if ( ! ObjectUtilities . equal ( this . key , that.key ) ) { return false ; }
result.subplots = ( List ) ObjectUtilities . deepClone ( this . subplots ) ;
if ( ! ObjectUtilities . equal ( this . subplots , that.subplots ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendLine , stream ) ; }
{ stream . defaultReadObject () ; this . legendLine = SerialUtilities . readShape ( stream ) ; }
if ( ! ShapeUtilities . equal ( this . legendLine , that.legendLine ) ) { return false ; }
if ( this . legendLine != null ) { clone.legendLine = ShapeUtilities . clone ( this . legendLine ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendArea , stream ) ; }
{ stream . defaultReadObject () ; this . legendArea = SerialUtilities . readShape ( stream ) ; }
clone.legendArea = ShapeUtilities . clone ( this . legendArea ) ;
if ( ! ShapeUtilities . equal ( this . legendArea , that.legendArea ) ) { return false ; }
{ stream . defaultReadObject () ; this . bounds = ( Rectangle2D ) SerialUtilities . readShape ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . bounds , stream ) ; }
clone.bounds = ( Rectangle2D ) ShapeUtilities . clone ( this . bounds ) ;
if ( ! ObjectUtilities . equal ( this . id , that.id ) ) { return false ; }
return ObjectUtilities . equal ( this . data , that.data ) ;
result.subplots = ( List ) ObjectUtilities . deepClone ( this . subplots ) ;
if ( ! ObjectUtilities . equal ( this . subplots , that.subplots ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . gradientPaintTransformer , that.gradientPaintTransformer ) ) { return false ; }
{ stream . defaultReadObject () ; this . wallPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . wallPaint , stream ) ; }
if ( ! PaintUtilities . equal ( this . wallPaint , that.wallPaint ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . image , that.image ) ) { return false ; }
clone.legendItemShape = ShapeUtilities . clone ( this . legendItemShape ) ;
clone.tasks = ( List ) ObjectUtilities . deepClone ( this . tasks ) ;
{ StandardEntityCollection that = ( StandardEntityCollection ) obj ; return ObjectUtilities . equal ( this . entities , that.entities ) ; }
{ stream . defaultReadObject () ; this . backgroundPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . backgroundPaint , stream ) ; }
if ( ! PaintUtilities . equal ( this . backgroundPaint , that.backgroundPaint ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . seriesKey , that.seriesKey ) ) { return false ; }
clone.seriesList = ( List ) ObjectUtilities . deepClone ( this . seriesList ) ;
{ MatrixSeriesCollection c = ( MatrixSeriesCollection ) obj ; return ObjectUtilities . equal ( this . seriesList , c.seriesList ) ; }
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
return ObjectUtilities . equal ( this . data , that.data ) ;
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
{ stream . defaultReadObject () ; this . shadowPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . shadowPaint , stream ) ; }
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
return ObjectUtilities . equal ( this . data , that.data ) ;
if ( ! ObjectUtilities . equal ( getDescription () , that . getDescription () ) ) { return false ; }
RefineryUtilities . centerFrameOnScreen ( demo ) ;
clone.items = ( List ) ObjectUtilities . deepClone ( this . items ) ;
{ new Integer ( series ) , faces [ NUMBER_CONSTANT ] . getBounds2D () , BooleanUtilities . valueOf ( v0 < getBase () ) }
{ new Integer ( series ) , faces [ NUMBER_CONSTANT ] . getBounds2D () , BooleanUtilities . valueOf ( v0 < getBase () ) }
clone.bins = ( List ) ObjectUtilities . deepClone ( this . bins ) ;
if ( ! ObjectUtilities . equal ( this . gradientPaintTransformer , that.gradientPaintTransformer ) ) { return false ; }
{ setSeriesShapesFilled ( series , BooleanUtilities . valueOf ( filled ) ) ; }
{ setSeriesShapesVisible ( series , BooleanUtilities . valueOf ( visible ) ) ; }
{ setShapesVisible ( BooleanUtilities . valueOf ( visible ) ) ; }
{ setSeriesLinesVisible ( series , BooleanUtilities . valueOf ( visible ) ) ; }
{ setLinesVisible ( BooleanUtilities . valueOf ( visible ) ) ; }
RefineryUtilities . centerFrameOnScreen ( demo ) ;
result.subplots = ( List ) ObjectUtilities . deepClone ( this . subplots ) ;
if ( ! ObjectUtilities . equal ( this . subplots , that.subplots ) ) { return false ; }
clone.rangeAxis = ( ValueAxis ) ObjectUtilities . clone ( this . rangeAxis ) ;
if ( ! ObjectUtilities . equal ( this . image , that.image ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . data , that.data ) ) { return false ; }
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
{ stream . defaultReadObject () ; this . sublabelPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . sublabelPaint , stream ) ; }
if ( ! PaintUtilities . equal ( this . sublabelPaint , that.sublabelPaint ) ) { return false ; }
final Shape shape = ShapeUtilities . createTranslatedShape ( getItemShape ( seriesIndex , i ++ ) , x , y ) ;
{ this . seriesFilled . setBoolean ( series , BooleanUtilities . valueOf ( filled ) ) ; }
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
return ObjectUtilities . equal ( this . data , that.data ) ;
{ stream . defaultReadObject () ; this . area = SerialUtilities . readShape ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . area , stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendLine , stream ) ; }
{ stream . defaultReadObject () ; this . legendLine = SerialUtilities . readShape ( stream ) ; }
clone.legendLine = ShapeUtilities . clone ( this . legendLine ) ;
{ setShapesFilled ( BooleanUtilities . valueOf ( filled ) ) ; }
{ DefaultBoxAndWhiskerCategoryDataset dataset = ( DefaultBoxAndWhiskerCategoryDataset ) obj ; return ObjectUtilities . equal ( this . data , dataset.data ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendLine , stream ) ; }
{ stream . defaultReadObject () ; this . legendLine = SerialUtilities . readShape ( stream ) ; }
if ( this . legendLine != null ) { clone.legendLine = ShapeUtilities . clone ( this . legendLine ) ; }
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
{ stream . defaultReadObject () ; setArea ( SerialUtilities . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( getArea () , stream ) ; }
if ( ! ObjectUtilities . equal ( this . formatter , that.formatter ) ) { return false ; }
{ ValueDataset vd = ( ValueDataset ) obj ; return ObjectUtilities . equal ( this . value , vd . getValue () ) ; }
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! ObjectUtilities . equal ( this . additionalItemLabelGenerator , that.additionalItemLabelGenerator ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . data , that.data ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . y , that.y ) ) { return false ; }
if ( ! PaintUtilities . equal ( this . backgroundPaint , that.backgroundPaint ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . data , that.data ) ) { return false ; }
{ stream . defaultReadObject () ; this . defaultPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . defaultPaint , stream ) ; }
if ( ! PaintUtilities . equal ( this . defaultPaint , that.defaultPaint ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . defaultGroup , that.defaultGroup ) ) { return false ; }
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
return ObjectUtilities . equal ( this . data , that.data ) ;
{ if ( ! ShapeUtilities . equal ( s1 [ i ] , s2 [ i ] ) ) { return false ; } }
{ stream . defaultReadObject () ; setArea ( SerialUtilities . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( getArea () , stream ) ; }
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
if ( ! ObjectUtilities . equal ( this . data , that.data ) ) { return false ; }
{ stream . defaultReadObject () ; this . artifactPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . artifactPaint , stream ) ; }
if ( ! PaintUtilities . equal ( this . artifactPaint , that.artifactPaint ) ) { return false ; }
Stroke stroke = SerialUtilities . readStroke ( stream ) ;
SerialUtilities . writeStroke ( stroke , stream ) ;
if ( ! ObjectUtilities . equal ( s1 , s2 ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . seriesShapesFilled , that.seriesShapesFilled ) ) { return false ; }
{ this . seriesShapesFilled . setBoolean ( series , BooleanUtilities . valueOf ( filled ) ) ; fireChangeEvent () ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
Paint paint = SerialUtilities . readPaint ( stream ) ;
SerialUtilities . writePaint ( paint , stream ) ;
if ( ! PaintUtilities . equal ( p1 , p2 ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . drawable , that.drawable ) ) { return false ; }
{ stream . defaultReadObject () ; this . wallPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . wallPaint , stream ) ; }
if ( ! PaintUtilities . equal ( this . wallPaint , that.wallPaint ) ) { return false ; }
Shape shadowArc = ShapeUtilities . createTranslatedShape ( path , ( float ) shadowXOffset , ( float ) shadowYOffset ) ;
clone.legendLine = ShapeUtilities . clone ( this . legendLine ) ;
if ( ! ObjectUtilities . equal ( this . arrowStroke , that.arrowStroke ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . indexParamName , that.indexParamName ) ) { return false ; }
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
if ( ! ObjectUtilities . equal ( this . data , that.data ) ) { return false ; }
Object toAdd = ObjectUtilities . deepClone ( entry ) ;
{ anchor = ShapeUtilities . getPointInRectangle ( anchor . getX () , anchor . getY () , dataArea ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . wallPaint , stream ) ; }
{ stream . defaultReadObject () ; this . wallPaint = SerialUtilities . readPaint ( stream ) ; }
if ( ! PaintUtilities . equal ( this . wallPaint , that.wallPaint ) ) { return false ; }
{ this . drawShapes = BooleanUtilities . valueOf ( this . drawShapesCheckBox . isSelected () ) ; }
{ this . drawLines = BooleanUtilities . valueOf ( this . drawLinesCheckBox . isSelected () ) ; }
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! ObjectUtilities . equal ( this . title , that.title ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . obj , that.obj ) ) { return false ; }
{ stream . defaultReadObject () ; setArea ( SerialUtilities . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( getArea () , stream ) ; }
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
Week w = new Week ( gc . getTime () , zone ) ;
TimeSeries series1 = new TimeSeries ( STRING_CONSTANT , Day . class ) ;
TimeSeries s1 = new TimeSeries ( STRING_CONSTANT , Year . class ) ;
TimeSeries series = new TimeSeries ( STRING_CONSTANT , Day . class ) ;
boolean interval = includeInterval || this . domainIsPointsInTime ;
DateTickUnit a1 = new DateTickUnit ( DateTickUnit.DAY , NUMBER_CONSTANT ) ;
axis . setTickUnit ( new DateTickUnit ( DateTickUnit.MONTH , NUMBER_CONSTANT , sdf ) ) ;
{ this ( label , TimeZone . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
{ setMaxItemWidth ( percent ) ; }
public double getMaximumItemWidth () { return getMaxItemWidth () ; }
if ( tooltips ) { renderer . setBaseToolTipGenerator ( new StandardXYToolTipGenerator () ) ; }
renderer . setBaseToolTipGenerator ( new BoxAndWhiskerToolTipGenerator () ) ;
if ( tooltips ) { renderer . setBaseToolTipGenerator ( new StandardXYToolTipGenerator () ) ; }
if ( tooltips ) { renderer . setBaseToolTipGenerator ( new StandardXYZToolTipGenerator () ) ; }
renderer . setBaseToolTipGenerator ( new HighLowItemLabelGenerator () ) ;
renderer . setBaseToolTipGenerator ( new HighLowItemLabelGenerator () ) ;
renderer . setBaseToolTipGenerator ( toolTipGenerator ) ;
if ( tooltips ) { renderer . setBaseToolTipGenerator ( new StandardXYToolTipGenerator () ) ; }
renderer . setBaseToolTipGenerator ( tt ) ;
renderer . setBaseToolTipGenerator ( toolTipGenerator ) ;
r1 . setBasePaint ( Color.red ) ;
r1 . setBaseItemLabelGenerator ( new StandardCategoryItemLabelGenerator () ) ;
r1 . setBaseItemLabelGenerator ( new StandardCategoryItemLabelGenerator () ) ;
setBaseToolTipGenerator ( toolTipGenerator ) ;
renderer1 . setBaseToolTipGenerator ( StandardXYToolTipGenerator . getTimeSeriesInstance () ) ;
setBaseLegendShape ( this . legendLine ) ;
setBaseToolTipGenerator ( labelGenerator ) ;
setBaseToolTipGenerator ( new BoxAndWhiskerXYToolTipGenerator () ) ;
if ( result == null ) { result = this . baseLegendTextPaint ; }
if ( result == null ) { result = this . baseLegendTextFont ; }
if ( result == null ) { result = this . baseLegendShape ; }
if ( position == null ) { position = this . baseNegativeItemLabelPosition ; }
if ( position == null ) { position = this . basePositiveItemLabelPosition ; }
if ( result == null ) { result = this . baseItemLabelPaint ; }
if ( result == null ) { result = this . baseShape ; }
if ( result == null ) { result = this . baseOutlineStroke ; }
if ( result == null ) { result = this . baseStroke ; }
if ( seriesOutlinePaint == null ) { seriesOutlinePaint = this . baseOutlinePaint ; }
if ( seriesFillPaint == null ) { seriesFillPaint = this . baseFillPaint ; }
if ( generator == null ) { generator = this . baseToolTipGenerator ; }
if ( generator == null ) { generator = this . baseItemLabelGenerator ; }
setBaseToolTipGenerator ( toolTipGenerator ) ;
setBaseToolTipGenerator ( toolTipGenerator ) ;
assertEquals ( Color.GRAY , r . getBaseOutlinePaint () ) ;
assertEquals ( Color.WHITE , r . getBaseFillPaint () ) ;
assertEquals ( Color.BLUE , r . getBasePaint () ) ;
setBaseToolTipGenerator ( toolTipGenerator ) ;
if ( generator == null ) { generator = this . baseItemURLGenerator ; }
if ( result == null ) { result = this . baseToolTipGenerator ; }
if ( generator == null ) { generator = this . baseItemLabelGenerator ; }
if ( entities != null ) { addEntity ( entities , hotspot , dataset , series , item , transX , transY ) ; }
if ( ! dataAreaHotspot . isEmpty () ) { addEntity ( entities , dataAreaHotspot , dataset , series , item , transX1 , transY1 ) ; }
r1 . setErrorPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white ) ) ;
r1 . setErrorPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white ) ) ;
{ this ( new RectangleInsets ( top , left , bottom , right ) , Color.black ) ; }
chart . setBackgroundPaint ( Color.white ) ;
this . noDataMessagePaint = Color.black ;
public DialBackground () { this ( Color.white ) ; }
renderer . setSeriesPaint ( NUMBER_CONSTANT , Color.black ) ;
m1 = new CategoryMarker ( STRING_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow ) , new BasicStroke ( NUMBER_CONSTANT ) )
m1 = new CategoryMarker ( STRING_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow ) , new BasicStroke ( NUMBER_CONSTANT ) )
public StandardDialRange () { this ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white ) ; }
g2 . setPaint ( Color.gray ) ;
p1 . setSubrangePaint ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ) ;
baseline . setPaint ( Color.black ) ;
{ this ( label , Color.black ) ; }
this . arrowPaint = Color.black ;
{ this ( x1 , y1 , x2 , y2 , new BasicStroke ( NUMBER_CONSTANT ) , Color.black ) ; }
this . arrowPaint = Color.black ;
{ this ( x0 , y0 , x1 , y1 , new BasicStroke ( NUMBER_CONSTANT ) , Color.black ) ; }
a1 . setAxisLinePaint ( Color.red ) ;
{ this ( polygon , new BasicStroke ( NUMBER_CONSTANT ) , Color.black ) ; }
this . outlinePaint = Color.black ;
{ this ( shape , new BasicStroke ( NUMBER_CONSTANT ) , Color.black ) ; }
g2 . setPaint ( Color.black ) ;
this . sublabelPaint = Color.black ;
this . labelPaint = Color.black ;
public Crosshair ( double value ) { this ( value , Color.black , new BasicStroke ( NUMBER_CONSTANT ) ) ; }
LegendGraphic g1 = new LegendGraphic ( r , Color.black ) ;
LegendGraphic g1 = new LegendGraphic ( r , Color.black ) ;
this . defaultSectionPaint = Color.gray ;
g2 . setColor ( Color.black ) ;
this . axisLinePaint = Color.black ;
this . paint = Color.black ;
g2 . setPaint ( Color.blue ) ;
{ super ( datasetIndex ) ; this . paint = Color.red ; this . stroke = new BasicStroke ( NUMBER_CONSTANT , BasicStroke.CAP_ROUND , BasicStroke.JOIN_BEVEL ) ; }
this . shadowPaint = Color.gray ;
this . artifactPaint = Color.black ;
final ObjectInputStream stream
final ObjectOutputStream stream
final Graphics2D g2
final TextBlock block
final double offset
final double offset
final Paint paint
final Paint paint
final RectangleInsets gap
final Stroke stroke
final Paint paint
final ObjectInputStream stream
final ObjectOutputStream stream
this . boxPaint = Color.green ;
TextUtilities . drawRotatedString ( label , g2 , xx , yy , TextAnchor.CENTER , NUMBER_CONSTANT , TextAnchor.CENTER ) ;
Rectangle2D bounds = TextUtilities . getTextBounds ( label , g2 , fm ) ;
Rectangle2D r = TextUtilities . getTextBounds ( text , g2 , fm ) ;
Rectangle2D bounds = TextUtilities . getTextBounds ( tickLabel , g2 , g2 . getFontMetrics () ) ;
Rectangle2D bounds = TextUtilities . getTextBounds ( tickLabel , g2 , g2 . getFontMetrics () ) ;
TextUtilities . drawAlignedString ( valueStr , g2 , x , y , TextAnchor.TOP_CENTER ) ;
Rectangle2D tickLabelBounds = TextUtilities . getTextBounds ( tickLabel , g2 , fm ) ;
final Graphics2D g2
Rectangle2D bounds = TextUtilities . getTextBounds ( getText () , g2 , fm ) ;
Rectangle2D bounds = TextUtilities . getTextBounds ( getText () , g2 , fm ) ;
{ FontMetrics fm = g2 . getFontMetrics ( getLabelFont () ) ; bounds = TextUtilities . getTextBounds ( axisLabel , g2 , fm ) ; }
if ( tick . getText () != null ) { labelBounds = TextUtilities . getTextBounds ( tick . getText () , g2 , fm ) ; }
if ( tick . getText () != null ) { labelBounds = TextUtilities . getTextBounds ( tick . getText () , g2 , fm ) ; }
this . label = TextUtilities . createTextBlock ( this . text , font , this . paint ) ;
this . label = TextUtilities . createTextBlock ( text , font , this . paint ) ;
Rectangle2D bounds = TextUtilities . getTextBounds ( this . text , g2 , fm ) ;
Rectangle2D r = TextUtilities . getTextBounds ( this . internalMarkerCycleBoundTick . getText () , g2 , fm ) ;
Rectangle2D bounds = TextUtils . getTextBounds ( text , g2 , fm ) ;
final Paint paint
public DefaultShadowGenerator () { this ( NUMBER_CONSTANT , Color.black , NUMBER_CONSTANT , NUMBER_CONSTANT , - Math.PI / NUMBER_CONSTANT ) ; }
renderer . setSeriesPaint ( NUMBER_CONSTANT , Color.black ) ;
this . paint = Color.red ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.blue ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ;
r1 . setDefaultPaint ( Color.red ) ;
this . zoomOutlinePaint = Color.blue ;
g2 . setPaint ( Color.blue ) ;
new BlockBorder ( new RectangleInsets ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow ) )
o1 . addRangeCrosshair ( new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) , new BasicStroke ( NUMBER_CONSTANT ) ) )
o1 . addRangeCrosshair ( new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) , new BasicStroke ( NUMBER_CONSTANT ) ) )
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.blue ) ;
t1 . setBackgroundPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ) ;
t1 . setBackgroundPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow ) ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.blue ) ;
this . gridPaintSample = new PaintSample ( Color.blue ) ;
a1 . setSubLabelPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ) ;
c1 = new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) , new BasicStroke ( NUMBER_CONSTANT ) )
c1 = new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) , new BasicStroke ( NUMBER_CONSTANT ) )
XYDifferenceRenderer r1 = new XYDifferenceRenderer ( Color.red , Color.blue , false ) ;
XYDifferenceRenderer r1 = new XYDifferenceRenderer ( Color.red , Color.blue , false ) ;
this . incompletePaint = Color.red ;
r1 . setSeriesPaint ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow ) ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ;
{ this ( label , range , Color.yellow , new BasicStroke ( NUMBER_CONSTANT ) , null ) ; }
Color defaultColor = ( p instanceof Color ? ( Color ) p : Color.blue ) ;
XYLineAnnotation a1 = new XYLineAnnotation ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , stroke , Color.blue ) ;
XYLineAnnotation a1 = new XYLineAnnotation ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , stroke , Color.blue ) ;
XYLineAnnotation a1 = new XYLineAnnotation ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , stroke , Color.blue ) ;
a1 . setTickLabelPaint ( STRING_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white ) ) ;
this . downPaint = Color.red ;
a1 . setOutlinePaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ) ;
t1 . setBackgroundPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow ) ) ;
r1 . setShapePaint ( Color.red ) ;
s1 . setMajorTickPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white ) ) ;
s1 . setMajorTickPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white ) ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red ) ;
new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow )
b1 . setPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.green ) ) ;
b1 . setPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.green ) ) ;
f1 . setBackgroundPaint ( Color.blue ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.blue ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.blue ) ;
a1 . setPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ) ;
p1 . setAggregatedItemsPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red ) ) ;
{ int result = NUMBER_CONSTANT ; result = HashUtilities . hashCode ( result , this . visible ) ; return result ; }
{ int result = NUMBER_CONSTANT ; result = HashUtilities . hashCode ( result , this . formatPattern ) ; return result ; }
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . arrowPaint ) ;
{ int result = super . hashCode () ; result = HashUtilities . hashCode ( result , this . key ) ; return result ; }
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . paint ) ;
{ int result = super . hashCode () ; result = HashUtilities . hashCode ( result , this . isArrowAtTop ) ; return result ; }
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . paint ) ;
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . paint ) ;
{ return HashUtilities . hashCode ( super . hashCode () , this . stepPoint ) ; }
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . paint ) ;
{ int result = NUMBER_CONSTANT ; result = HashUtilities . hashCode ( result , this . formatPattern ) ; return result ; }
@ Override public int hashCode () { return HashUtilities . hashCodeForDoubleArray ( this . coefficients ) ; }
{ int result = NUMBER_CONSTANT ; result = HashUtilities . hashCode ( result , this . radius ) ; return result ; }
result = result * NUMBER_CONSTANT + HashUtilities . hashCodeForPaint ( this . arrowPaint ) ;
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . paint ) ;
{ int hash = super . hashCode () ; hash = HashUtilities . hashCode ( hash , this . errorIndicatorPaint ) ; return hash ; }
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . paint ) ;
ChartUtilities . saveChartAsJPEG ( tempFile , chart , width , height , info ) ;
ChartUtilities . saveChartAsPNG ( tempFile , chart , width , height , info ) ;
{ return STRING_CONSTANT + ImageMapUtilities . javascriptEscape ( toolTipText ) + STRING_CONSTANT ; }
{ return STRING_CONSTANT + ImageMapUtilities . htmlEscape ( toolTipText ) + STRING_CONSTANT ; }
{ return ImageMapUtilities . getImageMap ( name , info , toolTipTagFragmentGenerator , urlTagFragmentGenerator ) ; }
{ writer . println ( ImageMapUtilities . getImageMap ( name , info , toolTipTagFragmentGenerator , urlTagFragmentGenerator ) ) ; }
ImageMapUtilities . writeImageMap ( writer , name , info , toolTipTagFragmentGenerator , new StandardURLTagFragmentGenerator () ) ;
boolean visible = LineUtilities . clipLine ( line , dataArea ) ;
visible = LineUtilities . clipLine ( state.workingLine , dataArea ) ;
boolean visible = LineUtilities . clipLine ( line , dataArea ) ;
Line2D extendedSeparator = LineUtilities . extendLine ( separator , this . innerSeparatorExtension , this . outerSeparatorExtension ) ;
Range range = DatasetUtilities . findDomainBounds ( this . dataset , false ) ;
CategoryDataset dataset = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset dataset = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset dataset = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
! DatasetUtilities . isEmptyOrNull ( dataset )
CategoryDataset dataset = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
{ total = DatasetUtilities . calculateStackTotal ( ( TableXYDataset ) dataset , item ) ; value = value / total ; }
if ( this . renderAsPercentages ) { return new Range ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } else { return DatasetUtilities . findStackedRangeBounds ( ( TableXYDataset ) dataset ) ; }
Range r = DatasetUtilities . findRangeBounds ( dataset , false ) ;
Range r = DatasetUtilities . findDomainBounds ( dataset , false ) ;
CategoryDataset dataset = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
! DatasetUtilities . isEmptyOrNull ( this . dataset )
Range r = DatasetUtilities . findStackedRangeBounds ( dataset , this . seriesToGroupMap ) ;
{ if ( dataset != null ) { return DatasetUtilities . findZBounds ( dataset ) ; } else { return null ; } }
Range r = DatasetUtilities . findRangeBounds ( dataset , false ) ;
Range r = DatasetUtilities . findDomainBounds ( dataset , false ) ;
{ if ( dataset != null ) { return DatasetUtilities . findStackedRangeBounds ( ( TableXYDataset ) dataset ) ; } else { return null ; } }
{ if ( includeInterval ) { return this . intervalDelegate . getDomainBounds ( includeInterval ) ; } else { return DatasetUtilities . iterateDomainBounds ( this , includeInterval ) ; } }
if ( this . renderAsPercentages ) { return new Range ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } else { return DatasetUtilities . findStackedRangeBounds ( dataset ) ; }
{ if ( includeInterval ) { return this . intervalDelegate . getDomainBounds ( includeInterval ) ; } else { return DatasetUtilities . iterateDomainBounds ( this , includeInterval ) ; } }
double totalValue = DatasetUtilities . calculatePieDatasetTotal ( this . dataset ) ;
! DatasetUtilities . isEmptyOrNull ( this . dataset )
if ( this . dataset != null ) { state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset () ) ) ; }
if ( this . renderAsPercentages ) { return new Range ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } else { return DatasetUtilities . findStackedRangeBounds ( dataset , getBase () ) ; }
if ( d != null ) { result = Range . combine ( result , DatasetUtilities . findRangeBounds ( d ) ) ; }
! DatasetUtilities . isEmptyOrNull ( dataset )
CategoryDataset dataset = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
{ final XYDataset dataset = plot . getDataset ( i ) ; if ( ! DatasetUtilities . isEmptyOrNull ( dataset ) ) { return false ; } }
{ if ( dataset != null ) { return DatasetUtilities . findRangeBounds ( dataset , true ) ; } else { return null ; } }
Range r = DatasetUtilities . findRangeBounds ( d , true ) ;
boolean hasData = ! DatasetUtilities . isEmptyOrNull ( currentDataset ) ;
double total = DatasetUtilities . calculatePieDatasetTotal ( dataset ) ;
{ this ( DataUtilities . createNumberArray2D ( starts ) , DataUtilities . createNumberArray2D ( ends ) ) ; }
double total = DataUtilities . calculateColumnTotal ( dataset , column ) ;
if ( this . renderAsPercentages ) { total = DataUtilities . calculateColumnTotal ( dataset , index , validRows ) ; }
clone.zValues = DataUtilities . clone ( this . zValues ) ;
if ( ! DataUtilities . equal ( this . zValues , that.zValues ) ) { return false ; }
{ total = DataUtilities . calculateColumnTotal ( dataset , column , state . getVisibleSeriesArray () ) ; value = value / total ; }
Millisecond m2 = ( Millisecond ) TestUtilities . serialised ( m1 ) ;
XYSeries s2 = ( XYSeries ) TestUtilities . serialised ( s1 ) ;
GrayPaintScale g2 = ( GrayPaintScale ) TestUtilities . serialised ( g1 ) ;
StandardCategoryURLGenerator g2 = ( StandardCategoryURLGenerator ) TestUtilities . serialised ( g1 ) ;
GanttRenderer r2 = ( GanttRenderer ) TestUtilities . serialised ( r1 ) ;
XIntervalDataItem item2 = ( XIntervalDataItem ) TestUtilities . serialised ( item1 ) ;
CyclicNumberAxis a2 = ( CyclicNumberAxis ) TestUtilities . serialised ( a1 ) ;
SymbolAxis a2 = ( SymbolAxis ) TestUtilities . serialised ( a1 ) ;
XYBubbleRenderer r2 = ( XYBubbleRenderer ) TestUtilities . serialised ( r1 ) ;
PeriodAxisLabelInfo info2 = ( PeriodAxisLabelInfo ) TestUtilities . serialised ( info1 ) ;
TimeSeriesCollection c2 = ( TimeSeriesCollection ) TestUtilities . serialised ( c1 ) ;
XYIntervalDataItem item2 = ( XYIntervalDataItem ) TestUtilities . serialised ( item1 ) ;
XYBlockRenderer r2 = ( XYBlockRenderer ) TestUtilities . serialised ( r1 ) ;
XYTitleAnnotation a2 = ( XYTitleAnnotation ) TestUtilities . serialised ( a1 ) ;
XYIntervalSeriesCollection c2 = ( XYIntervalSeriesCollection ) TestUtilities . serialised ( c1 ) ;
DefaultIntervalCategoryDataset d2 = ( DefaultIntervalCategoryDataset ) TestUtilities . serialised ( d1 ) ;
HistogramDataset d2 = ( HistogramDataset ) TestUtilities . serialised ( d1 ) ;
PiePlot p2 = ( PiePlot ) TestUtilities . serialised ( p1 ) ;
BoxAndWhiskerXYToolTipGenerator g2 = ( BoxAndWhiskerXYToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
QuarterDateFormat qf2 = ( QuarterDateFormat ) TestUtilities . serialised ( qf1 ) ;
SpiderWebPlot p2 = ( SpiderWebPlot ) TestUtilities . serialised ( p1 ) ;
PeriodAxis a2 = ( PeriodAxis ) TestUtilities . serialised ( a1 ) ;
ColorBlock b2 = ( ColorBlock ) TestUtilities . serialised ( b1 ) ;
StandardTickUnitSource t2 = ( StandardTickUnitSource ) TestUtilities . serialised ( t1 ) ;
BarRenderer r2 = ( BarRenderer ) TestUtilities . serialised ( r1 ) ;
LegendGraphic g2 = ( LegendGraphic ) TestUtilities . serialised ( g1 ) ;
XYSplineRenderer r2 = ( XYSplineRenderer ) TestUtilities . serialised ( r1 ) ;
TimePeriodAnchor a2 = ( TimePeriodAnchor ) TestUtilities . serialised ( a1 ) ;
StatisticalLineAndShapeRenderer r2 = ( StatisticalLineAndShapeRenderer ) TestUtilities . serialised ( r1 ) ;
CategoryLabelPosition p2 = ( CategoryLabelPosition ) TestUtilities . serialised ( p1 ) ;
Quarter q2 = ( Quarter ) TestUtilities . serialised ( q1 ) ;
DefaultKeyedValues2D kv2D2 = ( DefaultKeyedValues2D ) TestUtilities . serialised ( kv2D1 ) ;
Day d2 = ( Day ) TestUtilities . serialised ( d1 ) ;
LegendItemCollection c2 = ( LegendItemCollection ) TestUtilities . serialised ( c1 ) ;
CustomXYToolTipGenerator g2 = ( CustomXYToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
DialCap c2 = ( DialCap ) TestUtilities . serialised ( c1 ) ;
BlockBorder b2 = ( BlockBorder ) TestUtilities . serialised ( b1 ) ;
LongNeedle n2 = ( LongNeedle ) TestUtilities . serialised ( n1 ) ;
GradientBarPainter p2 = ( GradientBarPainter ) TestUtilities . serialised ( p1 ) ;
CrosshairOverlay o2 = ( CrosshairOverlay ) TestUtilities . serialised ( o1 ) ;
DefaultDrawingSupplier r2 = ( DefaultDrawingSupplier ) TestUtilities . serialised ( r1 ) ;
MatrixSeries m2 = ( MatrixSeries ) TestUtilities . serialised ( m1 ) ;
XYAreaRenderer2 r2 = ( XYAreaRenderer2 ) TestUtilities . serialised ( r1 ) ;
TimeSeriesDataItem item2 = ( TimeSeriesDataItem ) TestUtilities . serialised ( item1 ) ;
FastScatterPlot p2 = ( FastScatterPlot ) TestUtilities . serialised ( p1 ) ;
CategoryLabelWidthType w2 = ( CategoryLabelWidthType ) TestUtilities . serialised ( w1 ) ;
StatisticalBarRenderer r2 = ( StatisticalBarRenderer ) TestUtilities . serialised ( r1 ) ;
Week w2 = ( Week ) TestUtilities . serialised ( w1 ) ;
PlotOrientation orientation2 = ( PlotOrientation ) TestUtilities . serialised ( orientation1 ) ;
KeyedObjects ko2 = ( KeyedObjects ) TestUtilities . serialised ( ko1 ) ;
DefaultPolarItemRenderer r2 = ( DefaultPolarItemRenderer ) TestUtilities . serialised ( r1 ) ;
VectorRenderer r2 = ( VectorRenderer ) TestUtilities . serialised ( r1 ) ;
DefaultHeatMapDataset d2 = ( DefaultHeatMapDataset ) TestUtilities . serialised ( d1 ) ;
IntervalCategoryToolTipGenerator g2 = ( IntervalCategoryToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
LogarithmicAxis a2 = ( LogarithmicAxis ) TestUtilities . serialised ( a1 ) ;
XYPlot p2 = ( XYPlot ) TestUtilities . serialised ( p1 ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtilities . serialised ( chart ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtilities . serialised ( chart ) ;
XYPlot p2 = ( XYPlot ) TestUtilities . serialised ( p1 ) ;
XYPlot p2 = ( XYPlot ) TestUtilities . serialised ( p1 ) ;
PaintScaleLegend l2 = ( PaintScaleLegend ) TestUtilities . serialised ( l1 ) ;
MultipleXYSeriesLabelGenerator g2 = ( MultipleXYSeriesLabelGenerator ) TestUtilities . serialised ( g1 ) ;
LayeredBarRenderer r2 = ( LayeredBarRenderer ) TestUtilities . serialised ( r1 ) ;
ComparableObjectItem item2 = ( ComparableObjectItem ) TestUtilities . serialised ( item1 ) ;
CategoryLabelEntity e2 = ( CategoryLabelEntity ) TestUtilities . serialised ( e1 ) ;
DialPointer i2 = ( DialPointer ) TestUtilities . serialised ( i1 ) ;
DialPointer i2 = ( DialPointer ) TestUtilities . serialised ( i1 ) ;
MarkerAxisBand a2 = ( MarkerAxisBand ) TestUtilities . serialised ( a1 ) ;
CategoryLineAnnotation a2 = ( CategoryLineAnnotation ) TestUtilities . serialised ( a1 ) ;
MeterPlot p2 = ( MeterPlot ) TestUtilities . serialised ( p1 ) ;
MeterPlot p2 = ( MeterPlot ) TestUtilities . serialised ( p1 ) ;
DefaultKeyedValues v2 = ( DefaultKeyedValues ) TestUtilities . serialised ( v1 ) ;
XYDataItem i2 = ( XYDataItem ) TestUtilities . serialised ( i1 ) ;
StandardXYItemLabelGenerator g2 = ( StandardXYItemLabelGenerator ) TestUtilities . serialised ( g1 ) ;
DefaultKeyedValue v2 = ( DefaultKeyedValue ) TestUtilities . serialised ( v1 ) ;
PolarPlot p2 = ( PolarPlot ) TestUtilities . serialised ( p1 ) ;
CompositeTitle t2 = ( CompositeTitle ) TestUtilities . serialised ( t1 ) ;
LogFormat f2 = ( LogFormat ) TestUtilities . serialised ( f1 ) ;
KeyedObjects2D ko2D2 = ( KeyedObjects2D ) TestUtilities . serialised ( ko2D1 ) ;
BoxAndWhiskerToolTipGenerator g2 = ( BoxAndWhiskerToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
ShortTextTitle t2 = ( ShortTextTitle ) TestUtilities . serialised ( t1 ) ;
ModuloAxis a2 = ( ModuloAxis ) TestUtilities . serialised ( a1 ) ;
CategoryTableXYDataset d2 = ( CategoryTableXYDataset ) TestUtilities . serialised ( d1 ) ;
Hour h2 = ( Hour ) TestUtilities . serialised ( h1 ) ;
TimeSeriesURLGenerator g2 = ( TimeSeriesURLGenerator ) TestUtilities . serialised ( g1 ) ;
XYPolygonAnnotation a2 = ( XYPolygonAnnotation ) TestUtilities . serialised ( a1 ) ;
CategoryAnchor a2 = ( CategoryAnchor ) TestUtilities . serialised ( a1 ) ;
LegendItemEntity e2 = ( LegendItemEntity ) TestUtilities . serialised ( e1 ) ;
ItemLabelAnchor a2 = ( ItemLabelAnchor ) TestUtilities . serialised ( a1 ) ;
AreaRendererEndType t2 = ( AreaRendererEndType ) TestUtilities . serialised ( t1 ) ;
CategoryPointerAnnotation a2 = ( CategoryPointerAnnotation ) TestUtilities . serialised ( a1 ) ;
Month m2 = ( Month ) TestUtilities . serialised ( m1 ) ;
WaterfallBarRenderer r2 = ( WaterfallBarRenderer ) TestUtilities . serialised ( r1 ) ;
PolynomialFunction2D f2 = ( PolynomialFunction2D ) TestUtilities . serialised ( f1 ) ;
SimpleTimePeriod p2 = ( SimpleTimePeriod ) TestUtilities . serialised ( p1 ) ;
TimeSeries s2 = ( TimeSeries ) TestUtilities . serialised ( s1 ) ;
XYBoxAndWhiskerRenderer r2 = ( XYBoxAndWhiskerRenderer ) TestUtilities . serialised ( r1 ) ;
StackedAreaRenderer r2 = ( StackedAreaRenderer ) TestUtilities . serialised ( r1 ) ;
XYSeriesCollection c2 = ( XYSeriesCollection ) TestUtilities . serialised ( c1 ) ;
NumberTickUnit t2 = ( NumberTickUnit ) TestUtilities . serialised ( t1 ) ;
XIntervalSeriesCollection c2 = ( XIntervalSeriesCollection ) TestUtilities . serialised ( c1 ) ;
PlumNeedle n2 = ( PlumNeedle ) TestUtilities . serialised ( n1 ) ;
Range r2 = ( Range ) TestUtilities . serialised ( r1 ) ;
MyComparableObjectSeries s2 = ( MyComparableObjectSeries ) TestUtilities . serialised ( s1 ) ;
DefaultKeyedValues2DDataset d2 = ( DefaultKeyedValues2DDataset ) TestUtilities . serialised ( d1 ) ;
XYLineAndShapeRenderer r2 = ( XYLineAndShapeRenderer ) TestUtilities . serialised ( r1 ) ;
ExtendedCategoryAxis a2 = ( ExtendedCategoryAxis ) TestUtilities . serialised ( a1 ) ;
ChartRenderingInfo i2 = ( ChartRenderingInfo ) TestUtilities . serialised ( i1 ) ;
ChartRenderingInfo i2 = ( ChartRenderingInfo ) TestUtilities . serialised ( i1 ) ;
XYErrorRenderer r2 = ( XYErrorRenderer ) TestUtilities . serialised ( r1 ) ;
XYErrorRenderer r2 = ( XYErrorRenderer ) TestUtilities . serialised ( r1 ) ;
StandardPieSectionLabelGenerator g2 = ( StandardPieSectionLabelGenerator ) TestUtilities . serialised ( g1 ) ;
YIntervalDataItem item2 = ( YIntervalDataItem ) TestUtilities . serialised ( item1 ) ;
TaskSeriesCollection c2 = ( TaskSeriesCollection ) TestUtilities . serialised ( c1 ) ;
OHLCSeriesCollection c2 = ( OHLCSeriesCollection ) TestUtilities . serialised ( c1 ) ;
LineFunction2D f2 = ( LineFunction2D ) TestUtilities . serialised ( f1 ) ;
DateTitle t2 = ( DateTitle ) TestUtilities . serialised ( t1 ) ;
HighLowItemLabelGenerator g2 = ( HighLowItemLabelGenerator ) TestUtilities . serialised ( g1 ) ;
StandardCategorySeriesLabelGenerator g2 = ( StandardCategorySeriesLabelGenerator ) TestUtilities . serialised ( g1 ) ;
XYDrawableAnnotation a2 = ( XYDrawableAnnotation ) TestUtilities . serialised ( a1 ) ;
Minute m2 = ( Minute ) TestUtilities . serialised ( m1 ) ;
Crosshair c2 = ( Crosshair ) TestUtilities . serialised ( c1 ) ;
AxisLocation location2 = ( AxisLocation ) TestUtilities . serialised ( location1 ) ;
TaskSeries s2 = ( TaskSeries ) TestUtilities . serialised ( s1 ) ;
PointerNeedle n2 = ( PointerNeedle ) TestUtilities . serialised ( n1 ) ;
MinMaxCategoryRenderer r2 = ( MinMaxCategoryRenderer ) TestUtilities . serialised ( r1 ) ;
StrokeMap m2 = ( StrokeMap ) TestUtilities . serialised ( m1 ) ;
StrokeMap m2 = ( StrokeMap ) TestUtilities . serialised ( m1 ) ;
MatrixSeriesCollection c2 = ( MatrixSeriesCollection ) TestUtilities . serialised ( c1 ) ;
ThermometerPlot p2 = ( ThermometerPlot ) TestUtilities . serialised ( p1 ) ;
ThermometerPlot p2 = ( ThermometerPlot ) TestUtilities . serialised ( p1 ) ;
CustomPieURLGenerator g2 = ( CustomPieURLGenerator ) TestUtilities . serialised ( g1 ) ;
StandardChartTheme t2 = ( StandardChartTheme ) TestUtilities . serialised ( t1 ) ;
DateRange r2 = ( DateRange ) TestUtilities . serialised ( r1 ) ;
BoxAndWhiskerItem i2 = ( BoxAndWhiskerItem ) TestUtilities . serialised ( i1 ) ;
StandardEntityCollection c2 = ( StandardEntityCollection ) TestUtilities . serialised ( c1 ) ;
DefaultCategoryDataset d2 = ( DefaultCategoryDataset ) TestUtilities . serialised ( d1 ) ;
XYItemEntity e2 = ( XYItemEntity ) TestUtilities . serialised ( e1 ) ;
ClusteredXYBarRenderer r2 = ( ClusteredXYBarRenderer ) TestUtilities . serialised ( r1 ) ;
NumberAxis a2 = ( NumberAxis ) TestUtilities . serialised ( a1 ) ;
ItemLabelPosition p2 = ( ItemLabelPosition ) TestUtilities . serialised ( p1 ) ;
TextTitle t2 = ( TextTitle ) TestUtilities . serialised ( t1 ) ;
LogAxis a2 = ( LogAxis ) TestUtilities . serialised ( a1 ) ;
XYDifferenceRenderer r2 = ( XYDifferenceRenderer ) TestUtilities . serialised ( r1 ) ;
DefaultMultiValueCategoryDataset d2 = ( DefaultMultiValueCategoryDataset ) TestUtilities . serialised ( d1 ) ;
Year y2 = ( Year ) TestUtilities . serialised ( y1 ) ;
CompassPlot p2 = ( CompassPlot ) TestUtilities . serialised ( p1 ) ;
DeviationRenderer r2 = ( DeviationRenderer ) TestUtilities . serialised ( r1 ) ;
PieLabelRecord p2 = ( PieLabelRecord ) TestUtilities . serialised ( p1 ) ;
StandardXYSeriesLabelGenerator g2 = ( StandardXYSeriesLabelGenerator ) TestUtilities . serialised ( g1 ) ;
CustomXYURLGenerator g2 = ( CustomXYURLGenerator ) TestUtilities . serialised ( g1 ) ;
XYCoordinate v2 = ( XYCoordinate ) TestUtilities . serialised ( v1 ) ;
StackedBarRenderer r2 = ( StackedBarRenderer ) TestUtilities . serialised ( r1 ) ;
IntervalBarRenderer r2 = ( IntervalBarRenderer ) TestUtilities . serialised ( r1 ) ;
CategoryToPieDataset d2 = ( CategoryToPieDataset ) TestUtilities . serialised ( d1 ) ;
CategoryItemEntity e2 = ( CategoryItemEntity ) TestUtilities . serialised ( e1 ) ;
Second s2 = ( Second ) TestUtilities . serialised ( s1 ) ;
StackedXYAreaRenderer2 r2 = ( StackedXYAreaRenderer2 ) TestUtilities . serialised ( r1 ) ;
YInterval i2 = ( YInterval ) TestUtilities . serialised ( i1 ) ;
VectorDataItem v2 = ( VectorDataItem ) TestUtilities . serialised ( v1 ) ;
MeanAndStandardDeviation m2 = ( MeanAndStandardDeviation ) TestUtilities . serialised ( m1 ) ;
StackedXYBarRenderer r2 = ( StackedXYBarRenderer ) TestUtilities . serialised ( r1 ) ;
DefaultTableXYDataset d2 = ( DefaultTableXYDataset ) TestUtilities . serialised ( d1 ) ;
TimePeriodValuesCollection c2 = ( TimePeriodValuesCollection ) TestUtilities . serialised ( c1 ) ;
SlidingCategoryDataset d2 = ( SlidingCategoryDataset ) TestUtilities . serialised ( d1 ) ;
StandardXYZToolTipGenerator g2 = ( StandardXYZToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
StandardPieToolTipGenerator g2 = ( StandardPieToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
XYInterval i2 = ( XYInterval ) TestUtilities . serialised ( i1 ) ;
DialValueIndicator i2 = ( DialValueIndicator ) TestUtilities . serialised ( i1 ) ;
XYIntervalSeries s2 = ( XYIntervalSeries ) TestUtilities . serialised ( s1 ) ;
CombinedRangeXYPlot plot2 = ( CombinedRangeXYPlot ) TestUtilities . serialised ( plot1 ) ;
EmptyBlock b2 = ( EmptyBlock ) TestUtilities . serialised ( b1 ) ;
HistogramBin b2 = ( HistogramBin ) TestUtilities . serialised ( b1 ) ;
LineAndShapeRenderer r2 = ( LineAndShapeRenderer ) TestUtilities . serialised ( r1 ) ;
DefaultBoxAndWhiskerCategoryDataset d2 = ( DefaultBoxAndWhiskerCategoryDataset ) TestUtilities . serialised ( d1 ) ;
DefaultCategoryItemRenderer r2 = ( DefaultCategoryItemRenderer ) TestUtilities . serialised ( r1 ) ;
StandardDialRange r2 = ( StandardDialRange ) TestUtilities . serialised ( r1 ) ;
AreaRenderer r2 = ( AreaRenderer ) TestUtilities . serialised ( r1 ) ;
DateTick t2 = ( DateTick ) TestUtilities . serialised ( t1 ) ;
CategoryLabelPositions p2 = ( CategoryLabelPositions ) TestUtilities . serialised ( p1 ) ;
LevelRenderer r2 = ( LevelRenderer ) TestUtilities . serialised ( r1 ) ;
ScatterRenderer r2 = ( ScatterRenderer ) TestUtilities . serialised ( r1 ) ;
StandardCategoryToolTipGenerator g2 = ( StandardCategoryToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
KeyedObject ko2 = ( KeyedObject ) TestUtilities . serialised ( ko1 ) ;
LabelBlock b2 = ( LabelBlock ) TestUtilities . serialised ( b1 ) ;
XYShapeAnnotation a2 = ( XYShapeAnnotation ) TestUtilities . serialised ( a1 ) ;
DefaultStatisticalCategoryDataset d2 = ( DefaultStatisticalCategoryDataset ) TestUtilities . serialised ( d1 ) ;
DefaultStatisticalCategoryDataset d2 = ( DefaultStatisticalCategoryDataset ) TestUtilities . serialised ( d1 ) ;
XYStepAreaRenderer r2 = ( XYStepAreaRenderer ) TestUtilities . serialised ( r1 ) ;
WindNeedle n2 = ( WindNeedle ) TestUtilities . serialised ( n1 ) ;
XYLineAnnotation a2 = ( XYLineAnnotation ) TestUtilities . serialised ( a1 ) ;
StandardCategoryItemLabelGenerator g2 = ( StandardCategoryItemLabelGenerator ) TestUtilities . serialised ( g1 ) ;
YIntervalSeries s2 = ( YIntervalSeries ) TestUtilities . serialised ( s1 ) ;
LegendItem item2 = ( LegendItem ) TestUtilities . serialised ( item1 ) ;
item2 = ( LegendItem ) TestUtilities . serialised ( item1 ) ;
KeyedValuesDataset d2 = ( KeyedValuesDataset ) TestUtilities . serialised ( d1 ) ;
XYBarDataset bd2 = ( XYBarDataset ) TestUtilities . serialised ( bd1 ) ;
OHLCDataItem i2 = ( OHLCDataItem ) TestUtilities . serialised ( i1 ) ;
DefaultKeyedValueDataset d2 = ( DefaultKeyedValueDataset ) TestUtilities . serialised ( d1 ) ;
Task t2 = ( Task ) TestUtilities . serialised ( t1 ) ;
CandlestickRenderer r2 = ( CandlestickRenderer ) TestUtilities . serialised ( r1 ) ;
MiddlePinNeedle n2 = ( MiddlePinNeedle ) TestUtilities . serialised ( n1 ) ;
PowerFunction2D f2 = ( PowerFunction2D ) TestUtilities . serialised ( f1 ) ;
XYShapeRenderer r2 = ( XYShapeRenderer ) TestUtilities . serialised ( r1 ) ;
CategoryAxis a2 = ( CategoryAxis ) TestUtilities . serialised ( a1 ) ;
OHLC i2 = ( OHLC ) TestUtilities . serialised ( i1 ) ;
XIntervalSeries s2 = ( XIntervalSeries ) TestUtilities . serialised ( s1 ) ;
BarRenderer r2 = ( BarRenderer ) TestUtilities . serialised ( r1 ) ;
ArrowNeedle n2 = ( ArrowNeedle ) TestUtilities . serialised ( n1 ) ;
SimpleHistogramDataset d2 = ( SimpleHistogramDataset ) TestUtilities . serialised ( d1 ) ;
YWithXInterval i2 = ( YWithXInterval ) TestUtilities . serialised ( i1 ) ;
EmptyBlock b2 = ( EmptyBlock ) TestUtilities . serialised ( b1 ) ;
ArcDialFrame f2 = ( ArcDialFrame ) TestUtilities . serialised ( f1 ) ;
XYTaskDataset d2 = ( XYTaskDataset ) TestUtilities . serialised ( d1 ) ;
Axis a2 = ( Axis ) TestUtilities . serialised ( a1 ) ;
XYTextAnnotation a2 = ( XYTextAnnotation ) TestUtilities . serialised ( a1 ) ;
XYPointerAnnotation a2 = ( XYPointerAnnotation ) TestUtilities . serialised ( a1 ) ;
CustomCategoryURLGenerator g2 = ( CustomCategoryURLGenerator ) TestUtilities . serialised ( g1 ) ;
StandardPieURLGenerator g2 = ( StandardPieURLGenerator ) TestUtilities . serialised ( g1 ) ;
IntervalCategoryItemLabelGenerator g2 = ( IntervalCategoryItemLabelGenerator ) TestUtilities . serialised ( g1 ) ;
LegendTitle t2 = ( LegendTitle ) TestUtilities . serialised ( t1 ) ;
VectorSeriesCollection c2 = ( VectorSeriesCollection ) TestUtilities . serialised ( c1 ) ;
WindItemRenderer r2 = ( WindItemRenderer ) TestUtilities . serialised ( r1 ) ;
HighLowRenderer r2 = ( HighLowRenderer ) TestUtilities . serialised ( r1 ) ;
DefaultHighLowDataset d2 = ( DefaultHighLowDataset ) TestUtilities . serialised ( d1 ) ;
VectorSeries s2 = ( VectorSeries ) TestUtilities . serialised ( s1 ) ;
StandardXYBarPainter p2 = ( StandardXYBarPainter ) TestUtilities . serialised ( p1 ) ;
TimeTableXYDataset d2 = ( TimeTableXYDataset ) TestUtilities . serialised ( d1 ) ;
OHLCItem item2 = ( OHLCItem ) TestUtilities . serialised ( item1 ) ;
TickLabelEntity e2 = ( TickLabelEntity ) TestUtilities . serialised ( e1 ) ;
StackedXYAreaRenderer r2 = ( StackedXYAreaRenderer ) TestUtilities . serialised ( r1 ) ;
GridArrangement f2 = ( GridArrangement ) TestUtilities . serialised ( f1 ) ;
StandardBarPainter p2 = ( StandardBarPainter ) TestUtilities . serialised ( p1 ) ;
Vector v2 = ( Vector ) TestUtilities . serialised ( v1 ) ;
TickUnits t2 = ( TickUnits ) TestUtilities . serialised ( t1 ) ;
CombinedDomainXYPlot plot2 = ( CombinedDomainXYPlot ) TestUtilities . serialised ( plot1 ) ;
DefaultBoxAndWhiskerXYDataset d2 = ( DefaultBoxAndWhiskerXYDataset ) TestUtilities . serialised ( d1 ) ;
LineNeedle n2 = ( LineNeedle ) TestUtilities . serialised ( n1 ) ;
XYStepRenderer r2 = ( XYStepRenderer ) TestUtilities . serialised ( r1 ) ;
CategoryTick t2 = ( CategoryTick ) TestUtilities . serialised ( t1 ) ;
YIntervalSeriesCollection c2 = ( YIntervalSeriesCollection ) TestUtilities . serialised ( c1 ) ;
DateTickUnit a2 = ( DateTickUnit ) TestUtilities . serialised ( a1 ) ;
RingPlot p2 = ( RingPlot ) TestUtilities . serialised ( p1 ) ;
LineBorder b2 = ( LineBorder ) TestUtilities . serialised ( b1 ) ;
PaintMap m2 = ( PaintMap ) TestUtilities . serialised ( m1 ) ;
PaintMap m2 = ( PaintMap ) TestUtilities . serialised ( m1 ) ;
ShipNeedle n2 = ( ShipNeedle ) TestUtilities . serialised ( n1 ) ;
DateAxis a2 = ( DateAxis ) TestUtilities . serialised ( a1 ) ;
FixedMillisecond m2 = ( FixedMillisecond ) TestUtilities . serialised ( m1 ) ;
KeyToGroupMap m2 = ( KeyToGroupMap ) TestUtilities . serialised ( m1 ) ;
DateTickMarkPosition p2 = ( DateTickMarkPosition ) TestUtilities . serialised ( p1 ) ;
TimePeriodValues s2 = ( TimePeriodValues ) TestUtilities . serialised ( s1 ) ;
GradientXYBarPainter p2 = ( GradientXYBarPainter ) TestUtilities . serialised ( p1 ) ;
CombinedDomainCategoryPlot plot2 = ( CombinedDomainCategoryPlot ) TestUtilities . serialised ( plot1 ) ;
IntervalXYDelegate d2 = ( IntervalXYDelegate ) TestUtilities . serialised ( d1 ) ;
FlowArrangement f2 = ( FlowArrangement ) TestUtilities . serialised ( f1 ) ;
NormalDistributionFunction2D f2 = ( NormalDistributionFunction2D ) TestUtilities . serialised ( f1 ) ;
MeterInterval m2 = ( MeterInterval ) TestUtilities . serialised ( m1 ) ;
SubCategoryAxis a2 = ( SubCategoryAxis ) TestUtilities . serialised ( a1 ) ;
SymbolicXYItemLabelGenerator g2 = ( SymbolicXYItemLabelGenerator ) TestUtilities . serialised ( g1 ) ;
OHLCSeries s2 = ( OHLCSeries ) TestUtilities . serialised ( s1 ) ;
StandardXYToolTipGenerator g2 = ( StandardXYToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
XYAreaRenderer r2 = ( XYAreaRenderer ) TestUtilities . serialised ( r1 ) ;
SimpleHistogramBin b2 = ( SimpleHistogramBin ) TestUtilities . serialised ( b1 ) ;
StandardDialFrame f2 = ( StandardDialFrame ) TestUtilities . serialised ( f1 ) ;
DefaultPieDataset d2 = ( DefaultPieDataset ) TestUtilities . serialised ( d1 ) ;
IntervalMarker m2 = ( IntervalMarker ) TestUtilities . serialised ( m1 ) ;
BubbleXYItemLabelGenerator g2 = ( BubbleXYItemLabelGenerator ) TestUtilities . serialised ( g1 ) ;
DefaultOHLCDataset d2 = ( DefaultOHLCDataset ) TestUtilities . serialised ( d1 ) ;
CategoryTextAnnotation a2 = ( CategoryTextAnnotation ) TestUtilities . serialised ( a1 ) ;
XYDotRenderer r2 = ( XYDotRenderer ) TestUtilities . serialised ( r1 ) ;
ValueMarker m2 = ( ValueMarker ) TestUtilities . serialised ( m1 ) ;
ValueMarker m2 = ( ValueMarker ) TestUtilities . serialised ( m1 ) ;
CategoryPlot p2 = ( CategoryPlot ) TestUtilities . serialised ( p1 ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtilities . serialised ( chart ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtilities . serialised ( chart ) ;
CategoryPlot p2 = ( CategoryPlot ) TestUtilities . serialised ( p1 ) ;
CategoryPlot p2 = ( CategoryPlot ) TestUtilities . serialised ( p1 ) ;
GroupedStackedBarRenderer r2 = ( GroupedStackedBarRenderer ) TestUtilities . serialised ( r1 ) ;
PieSectionEntity e2 = ( PieSectionEntity ) TestUtilities . serialised ( e1 ) ;
BoxAndWhiskerRenderer r2 = ( BoxAndWhiskerRenderer ) TestUtilities . serialised ( r1 ) ;
CombinedRangeCategoryPlot plot2 = ( CombinedRangeCategoryPlot ) TestUtilities . serialised ( plot1 ) ;
DefaultTableXYDataset d2 = ( DefaultTableXYDataset ) TestUtilities . serialised ( d1 ) ;
PiePlot3D p2 = ( PiePlot3D ) TestUtilities . serialised ( p1 ) ;
DialPlot p2 = ( DialPlot ) TestUtilities . serialised ( p1 ) ;
BorderArrangement b2 = ( BorderArrangement ) TestUtilities . serialised ( b1 ) ;
assertFalse ( TestUtilities . containsInstanceOf ( ec . getEntities () , XYItemEntity . class ) ) ;
StandardXYItemRenderer r2 = ( StandardXYItemRenderer ) TestUtilities . serialised ( r1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtilities . serialised ( c1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtilities . serialised ( c1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtilities . serialised ( c1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtilities . serialised ( c1 ) ;
YIntervalRenderer r2 = ( YIntervalRenderer ) TestUtilities . serialised ( r1 ) ;
DomainOrder d2 = ( DomainOrder ) TestUtilities . serialised ( d1 ) ;
SlidingGanttCategoryDataset d2 = ( SlidingGanttCategoryDataset ) TestUtilities . serialised ( d1 ) ;
PinNeedle n2 = ( PinNeedle ) TestUtilities . serialised ( n1 ) ;
PlotRenderingInfo p2 = ( PlotRenderingInfo ) TestUtilities . serialised ( p1 ) ;
XYBarRenderer r2 = ( XYBarRenderer ) TestUtilities . serialised ( r1 ) ;
XYBarRenderer r2 = ( XYBarRenderer ) TestUtilities . serialised ( r1 ) ;
CategoryMarker m2 = ( CategoryMarker ) TestUtilities . serialised ( m1 ) ;
StandardXYURLGenerator g2 = ( StandardXYURLGenerator ) TestUtilities . serialised ( g1 ) ;
FlowArrangement f2 = ( FlowArrangement ) TestUtilities . serialised ( f1 ) ;
XYBoxAnnotation a2 = ( XYBoxAnnotation ) TestUtilities . serialised ( a1 ) ;
DatasetGroup g2 = ( DatasetGroup ) TestUtilities . serialised ( g1 ) ;
CategoryStepRenderer r2 = ( CategoryStepRenderer ) TestUtilities . serialised ( r1 ) ;
BlockContainer c2 = ( BlockContainer ) TestUtilities . serialised ( c1 ) ;
MultiplePiePlot p2 = ( MultiplePiePlot ) TestUtilities . serialised ( p1 ) ;
TimePeriodValue tpv2 = ( TimePeriodValue ) TestUtilities . serialised ( tpv1 ) ;
RangeType r2 = ( RangeType ) TestUtilities . serialised ( r1 ) ;
MonthDateFormat mf2 = ( MonthDateFormat ) TestUtilities . serialised ( mf1 ) ;
final Rectangle2D area
final float s
final float s
final float s
final Shape shape
final ObjectInputStream stream
final ObjectOutputStream stream
entities != null && AbstractXYItemRenderer . isPointInRect ( dataArea , x , y )
entities != null && isPointInRect ( dataArea , xx , yy )
entities != null && isPointInRect ( dataArea , xx , yy )
final Graphics2D g2
final TextFragment fragment
final TextFragment fragment
public TextLine ( final String text ) { this ( text , TextFragment.DEFAULT_FONT ) ; }
final int month
final int code
final boolean shortened
final int weekday
final String title
final Object o
final String name
final Font font
final Font font
final Font font
final Font font
final Font font
final double height
final double height
final double width
final double width
final double width
final double width
final double width
final double width
final double height
final double height
final double height
final double height
final int d
final int serial
final String name
final String name
final Dialog dialog
final Window frame
final Window frame
final String name
final double height
final double width
final int maxrows
final TextLine line
final String name
final int index
final ObjectOutputStream stream
final int index
public ObjectList ( final int initialCapacity ) { super ( initialCapacity ) ; }
final String name
final Object object
final String classLoaderSource
final RectangleEdge edge
final String name
final int targetDOW
final int targetDOW
final int targetDOW
final int serial
final int relative
final int count
final String name
final int index
final int index
final String name
final Number value
final String name
final ObjectInputStream stream
final ObjectOutputStream stream
final Object object
protected AbstractObjectList ( final int initialCapacity ) { this ( initialCapacity , initialCapacity ) ; }
final String name
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ; this . rangeAxis = axis ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ; this . domainAxis = axis ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( location , STRING_CONSTANT ) ; this . shapeLocation = location ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . shapeAnchor = anchor ; }
{ ParamChecks . nullNotPermitted ( transformer , STRING_CONSTANT ) ; this . fillPaintTransformer = transformer ; }
{ ParamChecks . nullNotPermitted ( icon , STRING_CONSTANT ) ; this . minIcon = icon ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( icon , STRING_CONSTANT ) ; this . maxIcon = icon ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( icon , STRING_CONSTANT ) ; this . objectIcon = icon ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . groupStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . groupPaint = paint ; fireChangeEvent () ; }
{ super ( size , minorTickCount ) ; ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . formatter = formatter ; }
{ super ( size ) ; ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . formatter = formatter ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . fillPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( locale , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( theme , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( state , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( categories , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; if ( this . categoryLabelURLs . remove ( category ) != null ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; return ( String ) this . categoryLabelURLs . get ( category ) ; }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; this . categoryLabelURLs . put ( category , url ) ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; if ( this . categoryLabelToolTips . remove ( category ) != null ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; return ( String ) this . categoryLabelToolTips . get ( category ) ; }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; this . categoryLabelToolTips . put ( category , tooltip ) ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( positions , STRING_CONSTANT ) ; this . categoryLabelPositions = positions ; fireChangeEvent () ; }
{ super ( formatString , xFormat , yFormat ) ; ParamChecks . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zDateFormat = zFormat ; }
{ super ( formatString , xFormat , yFormat ) ; ParamChecks . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zFormat = zFormat ; }
{ ParamChecks . nullNotPermitted ( name , STRING_CONSTANT ) ; this . name = name ; }
{ ParamChecks . nullNotPermitted ( id , STRING_CONSTANT ) ; this . id = id ; }
ParamChecks . nullNotPermitted ( tickType , STRING_CONSTANT ) ;
{ super ( formatString , xFormat , yFormat ) ; ParamChecks . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zDateFormat = zFormat ; }
{ super ( formatString , xFormat , yFormat ) ; ParamChecks . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zFormat = zFormat ; }
ParamChecks . nullNotPermitted ( alignment , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( alignment , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( array , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( columnKey , STRING_CONSTANT ) ; return getCategoryIndex ( columnKey ) ; }
ParamChecks . nullNotPermitted ( categoryKeys , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( seriesKeys , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . categoryAnchor = anchor ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; this . category = category ; fireAnnotationChanged () ; }
ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ;
{ super ( area , toolTipText , urlText ) ; ParamChecks . nullNotPermitted ( plot , STRING_CONSTANT ) ; this . plot = plot ; }
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendShape = shape ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( prefix , STRING_CONSTANT ) ; this . prefix = prefix ; }
ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . foregroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . backgroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . chartMouseListeners . add ( ChartMouseListener . class , listener ) ; }
ParamChecks . nullNotPermitted ( file , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( overlay , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( overlay , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . zoomFillPaint = paint ; }
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . textAnchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . valueAnchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( insets , STRING_CONSTANT ) ; this . insets = insets ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . backgroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . formatter = formatter ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( value , STRING_CONSTANT ) ; this . templateValue = value ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . frameAnchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendItemShape = shape ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . aggregatedItemsPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; this . aggregatedItemsKey = key ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . dataExtractOrder = order ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( pieChart , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeCrosshairPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeCrosshairStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainCrosshairPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainCrosshairStroke = stroke ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( axisIndex , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( axisIndex , STRING_CONSTANT ) ;
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( origin , STRING_CONSTANT ) ; this . quadrantOrigin = origin ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeZeroBaselinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeZeroBaselineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainZeroBaselinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainZeroBaselineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeMinorGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeMinorGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainMinorGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainMinorGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . seriesRenderingOrder = order ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . datasetRenderingOrder = order ; fireChangeEvent () ; }
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . axisOffset = offset ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( period , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( format , STRING_CONSTANT ) ; this . formatPattern = format ; }
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . remove ( ChartChangeListener . class , listener ) ; }
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . add ( ChartChangeListener . class , listener ) ; }
ParamChecks . nullNotPermitted ( subtitle , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subtitle , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . padding = padding ; notifyListeners ( new ChartChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( renderingHints , STRING_CONSTANT ) ; this . renderingHints = renderingHints ; fireChartChanged () ; }
ParamChecks . nullNotPermitted ( plot , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( transformer , STRING_CONSTANT ) ; this . gradientTransformer = transformer ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( area , STRING_CONSTANT ) ; this . legendArea = area ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . barPainter = painter ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( bar , STRING_CONSTANT ) ; this . legendBar = bar ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( painter , STRING_CONSTANT ) ; XYBarRenderer.defaultBarPainter = painter ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . arrowPaint = paint ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . arrowStroke = stroke ; fireAnnotationChanged () ; }
ParamChecks . nullNotPermitted ( state , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . subLabelPaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . subLabelFont = font ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( subCategory , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( period , STRING_CONSTANT ) ; this . period = period ; this . value = value ; }
ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( image , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( columnKey , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( rowKey , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . columnKeys . indexOf ( key ) ; }
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( seriesKey , STRING_CONSTANT ) ; this . seriesKey = seriesKey ; this . itemIndex = itemIndex ; }
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( format , STRING_CONSTANT ) ; this . formatter = format ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . labelTextAnchor = anchor ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( adj , STRING_CONSTANT ) ; this . labelOffsetType = adj ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . labelOffset = offset ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . labelAnchor = anchor ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( color , STRING_CONSTANT ) ; this . labelBackgroundColor = color ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ super ( source ) ; ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ; this . annotation = annotation ; }
ParamChecks . nullNotPermitted ( hour , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( day , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( polygon , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; this . category2 = category ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; this . category1 = category ; fireAnnotationChanged () ; }
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( record , STRING_CONSTANT ) ; this . labels . add ( record ) ; }
{ ParamChecks . nullNotPermitted ( area , STRING_CONSTANT ) ; this . legendArea = area ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . artifactPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( scale , STRING_CONSTANT ) ; this . paintScale = scale ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; this . key = key ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( f , STRING_CONSTANT ) ; factory = f ; }
ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( bounds , STRING_CONSTANT ) ; this . bounds = bounds ; }
{ ParamChecks . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . padding = padding ; }
{ ParamChecks . nullNotPermitted ( frame , STRING_CONSTANT ) ; this . frame = frame ; }
{ ParamChecks . nullNotPermitted ( margin , STRING_CONSTANT ) ; this . margin = margin ; }
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . listenerList . remove ( RendererChangeListener . class , listener ) ; }
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . listenerList . add ( RendererChangeListener . class , listener ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . defaultLegendTextFont = font ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . defaultNegativeItemLabelPosition = position ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . defaultPositiveItemLabelPosition = position ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultItemLabelPaint = paint ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; setDefaultItemLabelFont ( font , true ) ; }
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . defaultShape = shape ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . defaultOutlineStroke = stroke ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . defaultStroke = stroke ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultOutlinePaint = paint ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultFillPaint = paint ; if ( notify ) { fireChangeEvent () ; } }
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandAlternatePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ; Range result = iterateToFindZBounds ( dataset , visibleSeriesKeys , xRange , includeInterval ) ; return result ; }
{ ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ; Range result = iterateZBounds ( dataset , includeInterval ) ; return result ; }
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( input , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( input , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; this . key = key ; this . value = value ; }
ParamChecks . nullNotPermitted ( fillType , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( renderer , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( renderer , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( plot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( chart , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( supplier , STRING_CONSTANT ) ; this . drawingSupplier = supplier ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandAlternatePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . errorIndicatorPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . thermometerPaint = paint ; }
{ ParamChecks . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . xyBarPainter = painter ; }
{ ParamChecks . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . barPainter = painter ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . shadowPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . itemLabelPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickLabelPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . axisLabelPaint = paint ; }
{ ParamChecks . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . axisOffset = offset ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . crosshairPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . baselinePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelLinkPaint = paint ; }
{ ParamChecks . nullNotPermitted ( style , STRING_CONSTANT ) ; this . labelLinkStyle = style ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . plotOutlinePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . plotBackgroundPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . legendItemPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . legendBackgroundPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . chartBackgroundPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . subtitlePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . titlePaint = paint ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . smallFont = font ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . regularFont = font ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . largeFont = font ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . extraLargeFont = font ; }
ParamChecks . nullNotPermitted ( name , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . labelGenerator = generator ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendItemShape = shape ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . baseSeriesOutlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . baseSeriesOutlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . baseSeriesPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . axisLineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . axisLinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( direction , STRING_CONSTANT ) ; this . direction = direction ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . dataExtractOrder = order ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( extract , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( task , STRING_CONSTANT ) ; this . tasks . add ( task ) ; fireSeriesChanged () ; }
{ ParamChecks . nullNotPermitted ( entity , STRING_CONSTANT ) ; this . entities . add ( entity ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . negativeBarPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . positiveBarPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . lastBarPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . firstBarPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( map , STRING_CONSTANT ) ; this . seriesToGroupMap = map ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( container , STRING_CONSTANT ) ; this . container = container ; }
{ ParamChecks . nullNotPermitted ( container , STRING_CONSTANT ) ; this . container = container ; this . backgroundPaint = null ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . guideLineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . guideLinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( scale , STRING_CONSTANT ) ; this . paintScale = scale ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . roseHighlightPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . roseCenterPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rosePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . shadowPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . barPainter = painter ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( painter , STRING_CONSTANT ) ; BarRenderer.defaultBarPainter = painter ; }
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . legendItemLabelGenerator = generator ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( interval , STRING_CONSTANT ) ; this . intervals . add ( interval ) ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . valuePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . valueFont = font ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( format , STRING_CONSTANT ) ; this . tickLabelFormat = format ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . needlePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . shape = shape ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ; return this . data . indexOf ( series ) ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( values , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( values , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( values , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( values , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( values , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . tickLabelFormatter = formatter ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickLabelPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . tickLabelFont = font ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . minorTickStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . minorTickPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . majorTickStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . majorTickPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . incompletePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . completePaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( alignment , STRING_CONSTANT ) ; this . textAlignment = alignment ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( location , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . secondFormatter = formatter ; }
{ ParamChecks . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . secondSuffix = suffix ; }
{ ParamChecks . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . minuteSuffix = suffix ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . minuteFormatter = formatter ; }
{ ParamChecks . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . hourSuffix = suffix ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . hourFormatter = formatter ; }
{ ParamChecks . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . daySuffix = suffix ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . dayFormatter = formatter ; }
{ ParamChecks . nullNotPermitted ( prefix , STRING_CONSTANT ) ; this . positivePrefix = prefix ; }
ParamChecks . nullNotPermitted ( date , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( type , STRING_CONSTANT ) ; this . endType = type ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( tasks , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . mercuryPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . valueFormat = formatter ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( f , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . padding = padding ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( base , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( base , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . rotationAnchor = anchor ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . textAnchor = anchor ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ; this . text = text ; fireAnnotationChanged () ; }
ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . minorTickMarkPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . minorTickMarkStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . minorTickTimePeriodClass = c ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . majorTickTimePeriodClass = c ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . autoRangeTimePeriodClass = c ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( zone , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( last , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( first , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; this . key = key ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . sublabelPaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . sublabelFont = font ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( radialAxis , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( composite , STRING_CONSTANT ) ; this . fillComposite = composite ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( zone , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( insets , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . noDataMessagePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . noDataMessageFont = font ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( rectangle , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( area , STRING_CONSTANT ) ; this . area = area ; }
ParamChecks . nullNotPermitted ( area , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( thresholdType , STRING_CONSTANT ) ; this . gapThresholdType = thresholdType ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . foregroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . backgroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( unit , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( rangeType , STRING_CONSTANT ) ; this . rangeType = rangeType ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( state , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( state , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickMarkPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( insets , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickLabelPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . axisLineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . axisLinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( location , STRING_CONSTANT ) ; this . labelLocation = location ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( insets , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( rect , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( scale , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( pointer , STRING_CONSTANT ) ; return this . pointers . indexOf ( pointer ) ; }
ParamChecks . nullNotPermitted ( pointer , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( layer , STRING_CONSTANT ) ; return this . layers . indexOf ( layer ) ; }
ParamChecks . nullNotPermitted ( layer , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( frame , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( t , STRING_CONSTANT ) ; this . gradientPaintTransformer = t ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
{ super ( area , toolTipText , urlText ) ; ParamChecks . nullNotPermitted ( title , STRING_CONSTANT ) ; this . title = title ; }
ParamChecks . nullNotPermitted ( edge , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( color , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ; setRange ( Range . expand ( range , getLowerMargin () , getUpperMargin () ) , turnOffAutoRange , notify ) ; }
ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ; this . defaultAutoRange = range ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . rightArrow = arrow ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . leftArrow = arrow ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . downArrow = arrow ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . upArrow = arrow ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( generator , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . contentAlignmentPoint = anchor ; }
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . volumePaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( x , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( x , STRING_CONSTANT ) ; this . x = x ; this . y = y ; }
ParamChecks . nullNotPermitted ( extract , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( hotspot , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . legendItemLabelGenerator = generator ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( plot , STRING_CONSTANT ) ; this . plot = plot ; }
ParamChecks . nullNotPermitted ( locale , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( arrangement , STRING_CONSTANT ) ; this . arrangement = arrangement ; }
ParamChecks . nullNotPermitted ( arrangement , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . sortOrder = order ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . itemLabelPadding = padding ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . itemPaint = paint ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . itemFont = font ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . legendItemGraphicPadding = padding ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . legendItemGraphicAnchor = anchor ; }
{ ParamChecks . nullNotPermitted ( edge , STRING_CONSTANT ) ; this . legendItemGraphicEdge = edge ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( sources , STRING_CONSTANT ) ; this . sources = sources ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . xPosition = position ; }
ParamChecks . nullNotPermitted ( defaultPaint , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . legendLabelGenerator = generator ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendItemShape = shape ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( distributor , STRING_CONSTANT ) ; this . labelDistributor = distributor ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . simpleLabelOffset = offset ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . labelPadding = padding ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . labelLinkStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelLinkPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( style , STRING_CONSTANT ) ; this . labelLinkStyle = style ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . defaultSectionOutlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultSectionOutlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultSectionPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( direction , STRING_CONSTANT ) ; this . direction = direction ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . anchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( label , STRING_CONSTANT ) ; this . label = label ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( label , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( group , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( defaultGroup , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ; return this . data . indexOf ( series ) ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( format , STRING_CONSTANT ) ; this . formatPattern = format ; }
ParamChecks . nullNotPermitted ( file , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( chart , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( directions , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( seriesKeys , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( subtask , STRING_CONSTANT ) ; this . subtasks . add ( subtask ) ; }
{ ParamChecks . nullNotPermitted ( description , STRING_CONSTANT ) ; this . description = description ; }
ParamChecks . nullNotPermitted ( description , STRING_CONSTANT ) ;
{ super ( area , toolTipText , urlText ) ; ParamChecks . nullNotPermitted ( chart , STRING_CONSTANT ) ; this . chart = chart ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stripOutlineStroke = stroke ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . stripOutlinePaint = paint ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( location , STRING_CONSTANT ) ; this . axisLocation = location ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( scale , STRING_CONSTANT ) ; this . scale = scale ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( columnKey , STRING_CONSTANT ) ; return this . keys . indexOf ( columnKey ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . artifactPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; this . store . put ( key , stroke ) ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; return ( Stroke ) this . store . get ( key ) ; }
{ ParamChecks . nullNotPermitted ( coefficients , STRING_CONSTANT ) ; this . coefficients = ( double [] ) coefficients . clone () ; }
ParamChecks . nullNotPermitted ( line , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( axisIndex , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ; this . cornerTextItems . add ( text ) ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . angleLabelPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . angleLabelFont = font ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( unit , STRING_CONSTANT ) ; this . angleTickUnit = unit ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( location , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( chart , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( chart , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( prefix , STRING_CONSTANT ) ; ServletUtilities.tempOneTimeFilePrefix = prefix ; }
{ ParamChecks . nullNotPermitted ( prefix , STRING_CONSTANT ) ; ServletUtilities.tempFilePrefix = prefix ; }
{ ParamChecks . nullNotPermitted ( type , STRING_CONSTANT ) ; this . type = type ; fireDatasetChanged () ; }
{ ParamChecks . nullNotPermitted ( transformer , STRING_CONSTANT ) ; this . fillPaintTransformer = transformer ; }
{ ParamChecks . nullNotPermitted ( line , STRING_CONSTANT ) ; this . line = line ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . linePaint = paint ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . lineStroke = stroke ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . fillPaint = paint ; }
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . shape = shape ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . columnKeys . indexOf ( key ) ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . rowKeys . indexOf ( key ) ; }
ParamChecks . nullNotPermitted ( period , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . tickMarkPosition = position ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( maximumDate , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( date , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( locale , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( zone , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . remove ( OverlayChangeListener . class , listener ) ; }
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . add ( OverlayChangeListener . class , listener ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . fillPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; this . store . put ( key , paint ) ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; return ( Paint ) this . store . get ( key ) ; }
ParamChecks . nullNotPermitted ( drawable , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( group , STRING_CONSTANT ) ; this . group = group ; }
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . separatorPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . separatorStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( color , STRING_CONSTANT ) ; this . centerTextColor = color ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . centerTextFont = font ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . centerTextFormatter = formatter ; }
{ ParamChecks . nullNotPermitted ( mode , STRING_CONSTANT ) ; this . centerTextMode = mode ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . negativePaint = paint ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . positivePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ; this . dataset = dataset ; }
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . arrowPaint = paint ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . arrowStroke = stroke ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( serialDate , STRING_CONSTANT ) ; this . serialDate = serialDate ; peg ( Calendar . getInstance () ) ; }
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ; return this . data . indexOf ( series ) ; }
ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( unit , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . baseFormatter = formatter ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeCrosshairPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeCrosshairStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainCrosshairStroke = stroke ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainCrosshairPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( marker , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeMinorGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeMinorGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeZeroBaselinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeZeroBaselineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . domainGridlinePosition = position ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . rowRenderingOrder = order ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . columnRenderingOrder = order ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . renderingOrder = order ; fireChangeEvent () ; }
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . axisOffset = offset ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ; this . orientation = orientation ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( format , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . advanceLineStroke = stroke ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . advanceLinePaint = paint ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . data . getValue ( key ) ; }
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . rotationAnchor = anchor ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . textAnchor = anchor ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ; this . text = text ; fireAnnotationChanged () ; }
ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( x , STRING_CONSTANT ) ; this . x = x ; this . obj = y ; }
{ super ( area , toolTipText , urlText ) ; ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ; this . axis = axis ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( period , STRING_CONSTANT ) ; this . period = period ; this . value = value ; }
String name
Point2D anchorPoint = RectangleAnchor . coordinates ( area , position . getCategoryAnchor () ) ;
Point2D anchorPoint = RectangleAnchor . coordinates ( shape . getBounds2D () , anchor ) ;
Point2D pt2 = RectangleAnchor . coordinates ( bounds , this . valueAnchor ) ;
return RectangleAnchor . coordinates ( anchorRect , anchor ) ;
return RectangleAnchor . coordinates ( anchorRect , anchor ) ;
Point2D anchorPoint = RectangleAnchor . coordinates ( imageRect , this . anchor ) ;
Point2D pt = RectangleAnchor . coordinates ( area , this . textAnchor ) ;
return RectangleAnchor . coordinates ( anchorRect , anchor ) ;
return RectangleAnchor . coordinates ( anchorRect , anchor ) ;
Point2D anchorPoint = RectangleAnchor . coordinates ( titleRect , this . anchor ) ;
g2 . setXORMode ( Color.orange ) ;
g2 . setXORMode ( Color.orange ) ;
if ( xor ) { g2 . setXORMode ( Color.gray ) ; }
this . overlays = new java.util.ArrayList () ;
if ( mep > NUMBER_CONSTANT ) { ep = getExplodePercent ( section ) / mep ; }
if ( ! isOrsonPDFAvailable () ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
chart.subtitles = new ArrayList () ;
return ( Title ) this . subtitles . get ( index ) ;
this . subtitles = new ArrayList () ;
this . chartPanel = new ChartPanel ( chart ) ;
public ClassUtils () {}
public StringEscapeUtils () {}
public WordUtils () {}
public CharUtils () {}
public CharSetUtils () {}
Null () {}
public ObjectUtils () {}
public BooleanUtils () {}
public Validate () {}
public ArrayUtils () {}
public NumberUtils () {}
public RandomStringUtils () {}
public EnumUtils () {}
public NumberUtils () {}
public ExceptionUtils () {}
public EnumUtils () {}
private Entry () {}
private Entry () {}
public StopWatch () {}
public DateUtils () {}
public DateFormatUtils () {}
public ClassUtils () { ; }
public StringEscapeUtils () { ; }
public WordUtils () { ; }
public CharUtils () { ; }
public CharSetUtils () { ; }
public ObjectUtils () { ; }
public EnumUtils () { ; }
public BooleanUtils () { ; }
public ArrayUtils () { ; }
public NumberUtils () { ; }
public RandomStringUtils () { ; }
{ try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {} return createBigInteger ( numeric ) ; }
{ try { if ( in != null ) { in . close () ; } } catch ( IOException ex ) {} }
{ try { if ( out != null ) { out . close () ; } } catch ( IOException ex ) {} }
{ try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {} return createBigInteger ( numeric ) ; }
public SystemUtils () {}
if ( last == CHAR_CONS ) {} else { lastIdx ++ ; }
public StringUtils () {}
{ try { if ( in != null ) { in . close () ; } } catch ( IOException ex ) { ; } }
{ try { if ( out != null ) { out . close () ; } } catch ( IOException ex ) { ; } }
TwoDigitMonthField () { ; }
TwoDigitYearField () { ; }
UnpaddedMonthField () { ; }
Null () { ; }
public DateUtils () { ; }
public DateFormatUtils () { ; }
public NumberUtils () { ; }
public ExceptionUtils () { ; }
public EnumUtils () { ; }
suite . addTestSuite ( VariableFormatTest . class ) ;
{ Object result = replaceObject ( source ) ; return ( result == null ) ? null : result . toString () ; }
sb . appendFixedWidthPadRight ( null , NUMBER_CONSTANT , CHAR_CONS ) ;
noPrimitives = new Class [] { String . class , ClassUtils . class }
assertEquals ( true , tenToTwenty . containsNumber ( nonComparable ) ) ;
Range r = new IntRange ( nonComparable ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparable ) ) ;
Range r = new FloatRange ( nonComparable ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparable ) ) ;
Range r = new DoubleRange ( nonComparable ) ;
assertEquals ( true , tenToTwenty . containsFloat ( nonComparable ) ) ;
assertEquals ( true , tenToTwenty . containsDouble ( nonComparable ) ) ;
assertEquals ( true , tenToTwenty . containsInteger ( nonComparable ) ) ;
assertEquals ( true , tenToTwenty . containsLong ( nonComparable ) ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparable ) ) ;
Range r = new LongRange ( nonComparable ) ;
{ return ( StrTokenizer ) TSV_TOKENIZER_PROTOTYPE . clone () ; }
{ return ( StrTokenizer ) CSV_TOKENIZER_PROTOTYPE . clone () ; }
int removeLen = endIndex = startIndex ;
{ return lastIndexOf ( str , size ) ; }
{ return lastIndexOf ( ch , NUMBER_CONSTANT ) ; }
{ return new String ( buf , size - length , size ) ; }
{ return new StringBuffer ( size ) . append ( buf , NUMBER_CONSTANT , size ) ; }
{ return new String ( buf , NUMBER_CONSTANT , size ) ; }
{ if ( str . charAt ( j ) != buf [ i + j ] ) { continue outer ; } }
{ if ( buf [ i ] == ch ) { return i ; } }
char [] thisBuf = buf ;
char [] thisBuf = buf ;
char [] thisBuf = buf ;
{ endIndex = validateRange ( startIndex , endIndex ) ; return new String ( buf , startIndex , endIndex - startIndex ) ; }
{ if ( buf [ pos ] != str . charAt ( i ) ) { return false ; } }
{ if ( buf [ i ] != str . charAt ( i ) ) { return false ; } }
if ( len > NUMBER_CONSTANT ) { System . arraycopy ( buf , endIndex , buf , startIndex , size - endIndex ) ; size -= len ; }
for ( int i = NUMBER_CONSTANT ; i < length ; i ++ ) { buf [ size ++ ] = padChar ; }
buf [ size ++ ] = ch ;
System . arraycopy ( chars , startIndex , buf , len , length ) ;
System . arraycopy ( chars , NUMBER_CONSTANT , buf , len , strLen ) ;
System . arraycopy ( str.buf , NUMBER_CONSTANT , buf , len , strLen ) ;
str . getChars ( NUMBER_CONSTANT , strLen , buf , len ) ;
str . getChars ( NUMBER_CONSTANT , strLen , buf , len ) ;
System . arraycopy ( buf , startIndex , destination , destinationIndex , endIndex - startIndex ) ;
System . arraycopy ( buf , NUMBER_CONSTANT , destination , NUMBER_CONSTANT , len ) ;
System . arraycopy ( buf , startIndex , chars , NUMBER_CONSTANT , len ) ;
System . arraycopy ( buf , NUMBER_CONSTANT , chars , NUMBER_CONSTANT , size ) ;
buf [ index ] = ch ;
{ if ( index < NUMBER_CONSTANT || index >= length () ) { throw new StringIndexOutOfBoundsException ( index ) ; } return buf [ index ] ; }
for ( int i = oldEnd ; i < newEnd ; i ++ ) { buf [ i ] = CHAR_CONS ; }
{ super(); if ( initialCapacity <= NUMBER_CONSTANT ) { initialCapacity = CAPACITY ; } buf = new char [ initialCapacity ] ; }
assertEquals ( true , sb.buf.length >= NUMBER_CONSTANT ) ;
if ( pos + len >= textLen ) { return NUMBER_CONSTANT ; }
{ return ( boolean [] ) add ( array , index , new Boolean ( element ) , Boolean.TYPE ) ; }
try { sb . setLength ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( StringIndexOutOfBoundsException e ) {}
try { sb . setLength ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( StringIndexOutOfBoundsException e ) {}
try { sb . deleteCharAt ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( StringIndexOutOfBoundsException e ) {}
{ if ( startPos < getPos () ) { getTokenList () . addLast ( Token . newTextToken ( startPos , getPos () - startPos ) ) ; } }
if ( last == CharUtils.CR ) { ; } else { lastIdx ++ ; }
tok . setIgnoredMatcher ( StrTokenizer.TRIM_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.TRIM_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.TRIM_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.NONE_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.NONE_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.TRIM_MATCHER ) ;
Matcher trimmer
{ setIgnoredMatcher ( new CharMatcher ( ignored ) ) ; }
Matcher ignored
{ setQuoteMatcher ( new CharMatcher ( quote ) ) ; }
Matcher quote
start == len && delim . isMatch ( chars , len , start - NUMBER_CONSTANT ) == NUMBER_CONSTANT
Matcher delim
Matcher delim
private void setVarStartMatcher ( StrTokenizer.Matcher varStartMatcher ) { this . varStartMatcher = varStartMatcher ; }
private void setVarEndMatcher ( StrTokenizer.Matcher varEndMatcher ) { this . varEndMatcher = varEndMatcher ; }
private void setEscVarMatcher ( StrTokenizer.Matcher escVarMatcher ) { this . escVarMatcher = escVarMatcher ; }
sb . replaceAll ( CHAR_CONS , CHAR_CONS ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
if ( cloned.chars != null ) { cloned.chars = ( char [] ) cloned.chars ; }
if ( cloned.chars != null ) { cloned.chars = cloned.chars ; }
public boolean isEmptyTokenAsNull () { return emptyAsNull ; }
{ if ( trimmer != null ) { this . trimmer = trimmer ; } return this ; }
public StrMatcher getTrimmerMatcher () { return trimmer ; }
{ if ( ignored != null ) { this . ignored = ignored ; } return this ; }
public StrMatcher getIgnoredMatcher () { return ignored ; }
{ if ( quote != null ) { this . quote = quote ; } return this ; }
public StrMatcher getQuoteMatcher () { return quote ; }
public StrMatcher getDelimiterMatcher () { return delim ; }
{ assertTrue ( ! bf_multi . isAllSet ( j ) ) ; assertTrue ( ! bf_zero . isAllSet ( j ) ) ; }
{ super ( msg == null ? STRING_CONSTANT : msg ) ; this . cause = cause ; }
{ super ( STRING_CONSTANT ) ; this . cause = cause ; }
{ super ( msg == null ? STRING_CONSTANT : msg ) ; }
public NotImplementedException () { super ( STRING_CONSTANT ) ; }
private void tokenize () { if ( tokens == null ) { this . tokens = readTokens () ; } }
sb . append ( true ) ;
assertLocaleLookupList ( LOCALE_EN_US_ZZZZ , null , new Locale [] { LOCALE_EN_US_ZZZZ , LOCALE_EN_US , new Locale ( STRING_CONSTANT ) } ) ;
assertLocaleLookupList ( LOCALE_EN_US_ZZZZ , null , new Locale [] { LOCALE_EN_US_ZZZZ , LOCALE_EN_US , new Locale ( STRING_CONSTANT , STRING_CONSTANT ) } ) ;
{ return str != null && str . length () > NUMBER_CONSTANT ; }
List list = new LinkedList () ;
List list = new LinkedList () ;
{ append ( str , off , len ) ; }
{ append ( cbuf , off , len ) ; }
public void write ( char [] cbuf ) { append ( cbuf ) ; }
public void write ( int c ) { append ( ( char ) c ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
{ return indexOf ( array , valueToFind , NUMBER_CONSTANT , tolerance ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , objectToFind ) != - NUMBER_CONSTANT ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null ) ; }
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , testTransients , null ) ; }
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , false , null ) ; }
{ return reflectionEquals ( lhs , rhs , testTransients , null ) ; }
{ return reflectionEquals ( lhs , rhs , false , null ) ; }
{ return reflectionCompare ( lhs , rhs , compareTransients , null ) ; }
{ return reflectionCompare ( lhs , rhs , false , null ) ; }
HashCodeBuilder . reflectionHashCode ( x , null )
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
assertSame ( input , tok . getContent () ) ;
public boolean hasPrevious () { tokenize () ; return tokenPos > NUMBER_CONSTANT ; }
public boolean hasNext () { tokenize () ; return tokenPos < tokens.length ; }
tokenize () ;
{ tokenize () ; return ( String [] ) tokens . clone () ; }
public int size () { tokenize () ; return tokens.length ; }
{ if ( ready () == false ) { return - NUMBER_CONSTANT ; } return charAt ( pos ++ ) ; }
String varValue = resolveVariable ( varName ) ;
if ( substitute ( buf , NUMBER_CONSTANT , length ) == false ) { return source . substring ( offset , length ) ; }
VariableResolver variableResolver
{ this ( new MapVariableResolver ( valueMap ) , prefix , suffix , escape ) ; }
{ this ( valueMap , prefix , suffix , DEFAULT_ESCAPE ) ; }
{ this ( new MapVariableResolver ( valueMap ) , DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ESCAPE ) ; }
{ return new StrSubstitutor ( System . getProperties () ) . replace ( source ) ; }
return ( Enum ) entry.map . get ( getName () ) ;
private Entry () { super(); }
return ( Enum ) entry.map . get ( getName () ) ;
private Entry () { super(); }
sub . replace ( builder ) ;
assertEquals ( NUMBER_CONSTANT , ExceptionUtils . getThrowableCount ( recursiveCause ) ) ;
recursiveCause = null ;
recursiveCause = new ExceptionWithCause ( a ) ;
private DefaultToStringStyle () { super(); }
protected DefaultToStringStyle () { super(); }
public Object getValue () { return new Boolean ( this . value ) ; }
public Object getValue () { return Boolean . valueOf ( this . value ) ; }
public Object getValue () { return new Boolean ( this . value ) ; }
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
{ StringWriter stringWriter = newStringWriter ( str ) ; this . unescape ( stringWriter , str ) ; return stringWriter . toString () ; }
{ StringWriter stringWriter = newStringWriter ( str ) ; this . escape ( stringWriter , str ) ; return stringWriter . toString () ; }
CharSet chars = evaluateSet ( set ) ;
CharSet chars = evaluateSet ( set ) ;
CharSet chars = evaluateSet ( set ) ;
assertSame ( CharSet.EMPTY , CharSet . getInstance ( null ) ) ;
stopTime = System . currentTimeMillis () ;
stopTime = - NUMBER_CONSTANT ;
stopTime = System . currentTimeMillis () ;
if ( this . runningState == STATE_RUNNING ) { stopTime = System . currentTimeMillis () ; }
protected void setUp ( ) throws Exception { super . setUp () ; }
if ( ! containsCsvChars ( str ) ) { return str ; }
MessageFormat f = createMessageFormat ( pattern ) ;
subformats . put ( INTEGER , NumberFormat . getIntegerInstance ( getLocale () ) ) ;
NumberFormat . getIntegerInstance ( Locale.US )
{ return splitByWholeSeparator ( str , separator , - NUMBER_CONSTANT ) ; }
{ clazz = Class . forName ( toProperClassName ( className ) , initialize , classLoader ) ; }
if ( StringUtils . containsAny ( quoteless , CSV_SEARCH_CHARS ) ) { str = StringUtils . replace ( quoteless , STRING_CONSTANT + CSV_QUOTE + CSV_QUOTE , CSV_QUOTE_STR ) ; }
catch ( IllegalArgumentException e ) {}
if ( replaceChars == null ) { replaceChars = STRING_CONSTANT ; }
{ if ( isEmpty ( str ) || isEmpty ( remove ) ) { return str ; } return replace ( str , remove , STRING_CONSTANT , - NUMBER_CONSTANT ) ; }
{ return new ExtendedMessageFormat ( pattern , locale , ExtendedMessageFormat . createDefaultMetaFormat ( locale ) ) ; }
assertEquals ( pattern , emf . toPattern () ) ;
assertEquals ( STRING_CONSTANT , pattern , emf . toPattern () ) ;
int mid = ( low + high ) > > NUMBER_CONSTANT ;
osName . toLowerCase () . startsWith ( STRING_CONSTANT )
{ return Integer . toHexString ( ch ) . toUpperCase () ; }
catch ( IOException ioe ) { ioe . printStackTrace () ; return null ; }
catch ( IOException ioe ) { ioe . printStackTrace () ; return null ; }
catch ( IOException ioe ) { ioe . printStackTrace () ; return null ; }
catch ( IOException ioe ) { ioe . printStackTrace () ; return null ; }
{ getRegistry () . remove ( toIdentityHashCodeInteger ( value ) ) ; }
{ getRegistry () . add ( toIdentityHashCodeInteger ( value ) ) ; }
{ return getRegistry () . contains ( toIdentityHashCodeInteger ( value ) ) ; }
roundUp = offset > NUMBER_CONSTANT ;
{ if ( this . runningState == STATE_UNSTARTED ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } return this . startTime ; }
this . startTime += ( System . currentTimeMillis () - this . stopTime ) ;
this . stopTime = System . currentTimeMillis () ;
this . stopTime = System . currentTimeMillis () ;
if ( this . runningState == STATE_RUNNING ) { this . stopTime = System . currentTimeMillis () ; }
public static Test suite () { return new TestSuite ( NestableExceptionTestCase . class ) ; }
public ExceptionUtilsTestCase ( String name ) { super ( name ) ; }
public static Test suite () { return new TestSuite ( NestableErrorTestCase . class ) ; }
public static Test suite () { return new TestSuite ( NestableRuntimeExceptionTestCase . class ) ; }
public String toString () { return STRING_CONSTANT ; }
{ return ( ( Boolean ) IS_SYNTHETIC . invoke ( m , null ) ) . booleanValue () ; }
objects [ NUMBER_CONSTANT ] = ( Object ) simple ;
objectsLevel2 [ NUMBER_CONSTANT ] = ( Object ) objects ;
{ if ( array == null ) { return null ; } return ( boolean [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( float [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( double [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( byte [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( char [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( short [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( int [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( long [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( Object [] ) array . clone () ; }
if ( cloned.chars != null ) { cloned.chars = ( char [] ) cloned.chars . clone () ; }
{ checkTokenized () ; return ( String [] ) tokens . clone () ; }
sb . appendln ( ( Object ) FOO ) ;
public String toString () { return toString ; }
public Throwable getCause () { return cause ; }
{ super ( msg ) ; }
{ super ( msg ) ; }
{ super ( msg ) ; }
String [] splitOnNullResults = StringUtils . splitByWholeSeparator ( STRING_CONSTANT , null ) ;
{ ObjectUtils . appendIdentityToString ( buffer , value ) ; }
{ ObjectUtils . appendIdentityToString ( this . getStringBuffer () , object ) ; return this ; }
String pBaseStr = p . getClass () . getName () ;
catch ( NumberFormatException nfe ) { throw new NestableRuntimeException ( STRING_CONSTANT + unicode , nfe ) ; }
final Nestable n = new UnhandledException ( t ) ;
{ super ( DEFAULT_MESSAGE ) ; this . cause = cause ; }
String entityValue = Entities.ISO8859_1_ARRAY [ i % Entities.ISO8859_1_ARRAY.length ] [ NUMBER_CONSTANT ] ;
String entityValue = Entities.HTML40_ARRAY [ i % Entities.HTML40_ARRAY.length ] [ NUMBER_CONSTANT ] ;
Collection collection
Collection collection
Iterator iterator
Iterator iterator
Iterator it
Iterator it
List tokens
List tokens
List list
{ mutNum . compareTo ( new Byte ( ( byte ) NUMBER_CONSTANT ) ) ; fail () ; }
{ return ( byte [] ) add ( array , index , new Byte ( element ) , Byte.TYPE ) ; }
{ result [ i ] = new Byte ( array [ i ] ) ; }
public Byte toByte () { return new Byte ( byteValue () ) ; }
public Object getValue () { return new Byte ( this . value ) ; }
Class type
Class type
Class type
Class clazz
Class clazz
List list = getCauseMethodNameList () ;
List list = getCauseMethodNameList () ;
Object obj
Object obj
Map registry
Map registry
Class clazz
List priorVariables
Collection excludeFields
Class reflectUpToClass
Class clazz
Class cls
Class cls
Class cls
Class cls
Class cls
Class clazz
Class reflectUpToClass
Collection excludeFields
Class cls
Class cls
Class clazz
Class clazz
Class reflectUpToClass
Collection collection
Collection excludeFieldNames
Class reflectUpToClass
Class cls
Class expected
Class lhsClass = lhs . getClass () ;
Class clazz
Class reflectUpToClass
Collection excludeFields
Class clss
Class clss = null ;
Class newArrayComponentType
Class cls = target . getClass () ;
Class cls = target . getClass () ;
Class cls
Class cls
Class cls
Class cls
Class cls = target . getClass () ;
Class cls = target . getClass () ;
Class cls
Class cls
Class cls
Class cls
Class cls
Class cls
Class cls
if ( methodNames == null ) { synchronized ( CAUSE_METHOD_NAMES ) { methodNames = CAUSE_METHOD_NAMES ; } }
{ synchronized ( CAUSE_METHOD_NAMES ) { return getCause ( throwable , CAUSE_METHOD_NAMES ) ; } }
if ( list . remove ( methodName ) ) { synchronized ( CAUSE_METHOD_NAMES ) { CAUSE_METHOD_NAMES = toArray ( list ) ; } }
if ( list . add ( methodName ) ) { synchronized ( CAUSE_METHOD_NAMES ) { CAUSE_METHOD_NAMES = toArray ( list ) ; } }
Iterator it
Iterator it
Iterator it
assertTrue ( ObjectUtils.NULL != null ) ;
public Object getValue () { return BooleanUtils . toBooleanObject ( this . value ) ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , obj , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ return ( boolean [] ) add ( array , index , BooleanUtils . toBooleanObject ( element ) , Boolean.TYPE ) ; }
{ if ( cls == null ) { return StringUtils.EMPTY ; } return getPackageName ( cls . getName () ) ; }
return NumberUtils . compare ( value , anotherVal ) ;
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = NumberUtils . compare ( lhs , rhs ) ; return this ; }
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = NumberUtils . compare ( lhs , rhs ) ; return this ; }
return NumberUtils . compare ( value , anotherVal ) ;
int compare = ( ( Comparable ) num1 ) . compareTo ( num2 ) ;
Map map
Collection collection
Comparator comparator
Object object
Object object
Object object
Class < > clazz
Object object
Object object
Object object
Map map
public String [] getExcludeFieldNames () { return this . excludeFieldNames ; }
{ unescapeJava ( out , str ) ; }
{ return unescapeJava ( str ) ; }
{ escapeJavaStyleString ( out , str , true , true ) ; }
{ return escapeJavaStyleString ( str , true , true ) ; }
{ escapeJavaStyleString ( out , str , false , false ) ; }
{ return escapeJavaStyleString ( str , false , false ) ; }
{ return UnescapeUtils.UNESCAPE_CSV . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_CSV . translate ( str ) ; }
{ return UnescapeUtils.UNESCAPE_XML . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_XML . translate ( str ) ; }
{ return UnescapeUtils.UNESCAPE_HTML4 . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_HTML4 . translate ( str ) ; }
{ return UnescapeUtils.UNESCAPE_ECMASCRIPT . translate ( str ) ; }
{ return UnescapeUtils.UNESCAPE_JAVA . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_ECMASCRIPT . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_JAVA . translate ( str ) ; }
void setValue ( Object value ) ;
Object getValue ( ) ;
Object value
Object value
String str
String str
String str
String str
modify ( truncated , field , false ) ;
modify ( gval , field , false ) ;
modify ( rounded , field , true ) ;
modify ( gval , field , true ) ;
{ throw new NullArgumentException ( STRING_CONSTANT ) ; }
if ( target == null ) { throw new NullArgumentException ( STRING_CONSTANT ) ; }
catch ( NumberFormatException nfe ) { throw new UnhandledException ( STRING_CONSTANT + unicode , nfe ) ; }
assertGetClassThrowsIllegalArgument ( null ) ;
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
buffer = new char [ capacity ] ;
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ result [ i ] = new Float ( array [ i ] ) ; }
{ result [ i ] = new Double ( array [ i ] ) ; }
{ result [ i ] = new Short ( array [ i ] ) ; }
{ result [ i ] = new Integer ( array [ i ] ) ; }
{ result [ i ] = new Long ( array [ i ] ) ; }
{ result [ i ] = new Character ( array [ i ] ) ; }
double [] array2
float [] array2
long [] array2
int [] array2
short [] array2
byte [] array2
char [] array2
boolean [] array2
object instanceof Map.Entry
if ( num1 instanceof Comparable == false ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( num instanceof Comparable == false ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
Iterator it = collection . iterator ()
Iterator it = collection . iterator ()
Iterator it = collection . iterator ()
Iterator it = collection . iterator ()
oos . writeObject ( new ClassNotFoundSerializationTest () ) ;
{ if ( object == null ) { return valueIfNull ; } return getPackageName ( object . getClass () . getName () ) ; }
{ if ( object == null ) { return valueIfNull ; } return getShortClassName ( object . getClass () . getName () ) ; }
{ if ( cls == null ) { return StringUtils.EMPTY ; } return cls . getPackage () . getName () ; }
isEscapingPlus ()
uu . setEscapingPlus ( true ) ;
isSet ( PARAM.escapePlus )
uu = new UnicodeUnescaper ( UnicodeUnescaper.PARAM.escapePlus ) ;
StringBuffer canonicalClassNameBuffer = new StringBuffer ( className ) ;
StringBuffer classNameBuffer = new StringBuffer () ;
StringBuffer arrayPrefix = new StringBuffer () ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer result = new StringBuffer () ;
StringBuffer buffer = new StringBuffer ( strLen ) ;
StringBuffer buffer = new StringBuffer ( strLen ) ;
StringBuffer buffer = new StringBuffer ( strLen ) ;
StringBuffer buffer = new StringBuffer ( strLen ) ;
new StringBuffer ( strLen ) . append ( Character . toLowerCase ( str . charAt ( NUMBER_CONSTANT ) ) ) . append ( str . substring ( NUMBER_CONSTANT ) )
new StringBuffer ( strLen ) . append ( Character . toTitleCase ( str . charAt ( NUMBER_CONSTANT ) ) ) . append ( str . substring ( NUMBER_CONSTANT ) )
StringBuffer buf = new StringBuffer ( outputLength ) ;
StringBuffer buf = new StringBuffer ( strLength ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( bufSize ) ;
StringBuffer buf = new StringBuffer ( bufSize ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buffer = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
toString = new StringBuffer ( NUMBER_CONSTANT ) . append ( getNumerator () ) . append ( CHAR_CONS ) . append ( getDenominator () ) . toString () ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buffer = new StringBuffer () ;
StringBuffer buf = new StringBuffer () ;
CharRange range = new CharRange ( CHAR_CONS ) ;
Collection collection
Collection collection
Class cls
Map map
Collection coll
Class cls
Class cls
Class [] parameterTypes
Class [] parameterTypes
Class exceptionType
Class c
assertFalse ( ClassUtils . isAssignable ( ( Class ) null , null , true ) ) ;
assertFalse ( ClassUtils . isAssignable ( ( Class ) null , null ) ) ;
assertEquals ( STRING_CONSTANT , ClassUtils . getPackageName ( ( Class ) null ) ) ;
assertEquals ( null , StringUtils . join ( ( Collection ) null , null ) ) ;
assertEquals ( null , StringUtils . join ( ( Collection ) null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . join ( ( Iterator ) null , null ) ) ;
assertEquals ( null , StringUtils . join ( ( Iterator ) null , CHAR_CONS ) ) ;
iMap = new HashMap () ;
Class [] c
sb . appendWithSeparators ( ( Iterator ) null , STRING_CONSTANT ) ;
sb . appendWithSeparators ( ( Collection ) null , STRING_CONSTANT ) ;
sb . appendAll ( ( Iterator ) null ) ;
sb . appendAll ( ( Collection ) null ) ;
public String getFormattedExceptionMessage ( String baseMessage ) { return this . exceptionContext . getFormattedExceptionMessage ( baseMessage ) ; }
public String getFormattedExceptionMessage ( String baseMessage ) { return this . exceptionContext . getFormattedExceptionMessage ( baseMessage ) ; }
Serializable value
Serializable value
StringBuilder buffer = new StringBuilder () ;
Class [] c
List list = tok . getTokenList () ;
values = new HashMap () ;
Map map = null ;
Map < String , FormatFactory > registry
Map registry
Map registry
String toString = ReflectionToStringBuilder . toStringExclude ( new TestFixture () , ( Collection ) null ) ;
String toString = ReflectionToStringBuilder . toStringExclude ( new TestFixture () , new ArrayList () ) ;
T object
T object
T object
T object
T object
T object
{ this ( object , getDefaultStyle () , null ) ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( this . getMinimum () , element ) < NUMBER_CONSTANT ; }
StringEscapeUtils . unescapeCsv ( writer , value ) ;
StringEscapeUtils . escapeCsv ( writer , value ) ;
StringEscapeUtils . unescapeJava ( writer , original ) ;
StringEscapeUtils . escapeJava ( writer , original ) ;
Comparator c
{ try { return initialize () ; } finally { if ( executor != null ) { executor . shutdown () ; } } }
{ executor = exec ; }
{ this . translators = translators ; }
{ return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE , index ) ; }
{ return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EXCEPTION_MESSAGE , index ) ; }
{ return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EXCEPTION_MESSAGE , index ) ; }
Object [] values2 = ArrayUtils . addAll ( values , i ) ;
Object [] values2 = ArrayUtils . add ( values , i ) ;
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , value ) ) ; } }
{ calendar . getTime () ; calendar = ( Calendar ) calendar . clone () ; calendar . setTimeZone ( mTimeZone ) ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( element , getMaximum () ) > NUMBER_CONSTANT ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( element , getMinimum () ) < NUMBER_CONSTANT ; }
return getCauseUsingFieldName ( throwable , STRING_CONSTANT ) ;
{ return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return noNullElements ( iterable , DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EXCEPTION_MESSAGE ) ; }
{ return noNullElements ( array , DEFAULT_NO_NULL_ELEMENTS_ARRAY_EXCEPTION_MESSAGE ) ; }
{ return notBlank ( chars , DEFAULT_NOT_BLANK_EXCEPTION_MESSAGE ) ; }
{ return notEmpty ( chars , DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EXCEPTION_MESSAGE ) ; }
{ return notEmpty ( map , DEFAULT_NOT_EMPTY_MAP_EXCEPTION_MESSAGE ) ; }
{ return notEmpty ( collection , DEFAULT_NOT_EMPTY_COLLECTION_EXCEPTION_MESSAGE ) ; }
{ return notEmpty ( array , DEFAULT_NOT_EMPTY_ARRAY_EXCEPTION_MESSAGE ) ; }
{ return notNull ( object , DEFAULT_IS_NULL_EXCEPTION_MESSAGE ) ; }
StrLookup variableResolver
StrLookup resolver = getVariableResolver () ;
StrLookup variableResolver
StrLookup variableResolver
StrLookup variableResolver
public StrSubstitutor () { this ( ( StrLookup ) null , DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ESCAPE ) ; }
{ return m != null && Modifier . isPublic ( m . getModifiers () ) && ! isSynthetic ( m ) ; }
validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
{ return registry . get () ; }
String str
if ( str == null || suffix == null ) { return ( str == null && suffix == null ) ; }
{ if ( str == null ) { return null ; } return new StringBuilder ( str ) . reverse () . toString () ; }
if ( ( str == null ) || ( searchStrs == null ) ) { return - NUMBER_CONSTANT ; }
smallestIndexOfDiff == - NUMBER_CONSTANT
if ( at == - NUMBER_CONSTANT ) { return EMPTY ; }
if ( isEmpty ( str ) || str . indexOf ( remove ) == - NUMBER_CONSTANT ) { return str ; }
if ( pos == - NUMBER_CONSTANT || pos == ( str . length () - separator . length () ) ) { return EMPTY ; }
if ( pos == - NUMBER_CONSTANT ) { return str ; }
if ( pos == - NUMBER_CONSTANT ) { return EMPTY ; }
if ( pos == - NUMBER_CONSTANT ) { return str ; }
return indexOfAnyBut ( cs , valid ) == - NUMBER_CONSTANT ;
{ if ( isEmpty ( cs ) || isEmpty ( searchChars ) ) { return - NUMBER_CONSTANT ; } return indexOfAny ( cs , searchChars . toCharArray () ) ; }
if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; }
{ if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; } return str . lastIndexOf ( searchStr , startPos ) ; }
{ if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; } return str . lastIndexOf ( searchStr ) ; }
{ if ( isEmpty ( str ) ) { return - NUMBER_CONSTANT ; } return str . lastIndexOf ( searchChar , startPos ) ; }
{ if ( isEmpty ( str ) ) { return - NUMBER_CONSTANT ; } return str . lastIndexOf ( searchChar ) ; }
{ if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; } return str . indexOf ( searchStr , startPos ) ; }
{ if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; } return str . indexOf ( searchStr ) ; }
( start != strLen ) && ( stripChars . indexOf ( str . charAt ( start ) ) != - NUMBER_CONSTANT )
{ if ( str == null ) { return null ; } return CharSequenceUtils . reverse ( str ) . toString () ; }
char searchChar
char searchChar
char searchChar
char searchChar
char searchChar
Class < > [] parameterTypes
Class < > [] parameterTypes
Class < > [] parameterTypes
Class < > [] parameterTypes
Object [] args
Object [] args
Object [] args
Object [] args
String [] parsePatterns
String [] parsePatterns
String [] strs
CharSequence [] css
Boolean [] array
boolean [] array
char [] delimiters
char [] delimiters
char [] delimiters
char [] delimiters
Class < > [] parameterTypes
Class < > [] parameterTypes
Object [] args
Object [] args
String [] searchStrings
assertEquals ( NUMBER_CONSTANT , new MutableDouble ( STRING_CONSTANT ) . floatValue () , NUMBER_CONSTANT ) ;
{ return reflectionCompare ( lhs , rhs , false , reflectUpToClass , null ) ; }
isAssignable ( midClass , superClass ) && isAssignable ( ( Type ) genericInterface , ( Type ) midClass )
listeners . fire () . propertyChange ( new PropertyChangeEvent ( this , STRING_CONSTANT , STRING_CONSTANT , property ) ) ;
{ Validate . notNull ( listener , STRING_CONSTANT ) ; listeners . add ( NUMBER_CONSTANT , listener ) ; }
{ final String [] array = ArrayUtilsTest . < String > toArrayPropagatingType () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtils . < String > toArray () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtilsTest . toArrayPropagatingType () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtils . toArray () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( - NUMBER_CONSTANT , StringUtils . indexOfDifference ( null ) ) ;
String [] results = null ;
String [] results = null ;
assertEquals ( null , StringUtils . concatWith ( null , null ) ) ;
assertEquals ( null , StringUtils . concat ( null ) ) ;
{ DateUtils . parseDate ( dateStr , null ) ; fail () ; }
{ if ( expression == false ) { throw new IllegalArgumentException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } }
return new StringBuilder ( annotationType == null ? null : annotationType . getName () ) . insert ( NUMBER_CONSTANT , CHAR_CONS ) . toString () ;
{ return isJavaVersionMatch ( JAVA_VERSION_TRIMMED , versionPrefix ) ; }
SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT )
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ;
{ return isAssignable ( cls , toClass , SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ) ; }
{ return isAssignable ( classArray , toClassArray , SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ) ; }
boolean atLeastJava14 = SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ;
if ( SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ) { assertEquals ( STRING_CONSTANT , new BigDecimal ( STRING_CONSTANT ) , NumberUtils . createNumber ( STRING_CONSTANT ) ) ; }
{ if ( SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ) { assertEquals ( message , expected , actual ) ; } }
static JavaVersion getJavaVersion ( final String nom ) { return getJavaVersion ( nom ) ; }
{ return ( options == null ) ? false : options . contains ( opt ) ; }
assertEquals ( true , StringUtils . isNumeric ( STRING_CONSTANT ) ) ;
assertEquals ( true , StringUtils . isAlphanumeric ( STRING_CONSTANT ) ) ;
assertEquals ( true , StringUtils . isAlpha ( STRING_CONSTANT ) ) ;
{ return format ( date , pattern , DateUtils.UTC_TIME_ZONE , locale ) ; }
{ return format ( new Date ( millis ) , pattern , DateUtils.UTC_TIME_ZONE , locale ) ; }
{ return format ( date , pattern , DateUtils.UTC_TIME_ZONE , null ) ; }
{ return format ( new Date ( millis ) , pattern , DateUtils.UTC_TIME_ZONE , null ) ; }
Pair < IDKey , IDKey > swappedPair = Pair . of ( pair.right , pair.left ) ;
{ return isEquals () ; }
{ return toComparison () ; }
public Integer build () { return toHashCode () ; }
HashCodeBuilder . class
HashCodeBuilder . class
new StringBuilder ( strLen ) . append ( Character . toLowerCase ( cs . charAt ( NUMBER_CONSTANT ) ) ) . append ( CharSequenceUtils . subSequence ( cs , NUMBER_CONSTANT ) )
new StringBuilder ( strLen ) . append ( Character . toTitleCase ( cs . charAt ( NUMBER_CONSTANT ) ) ) . append ( CharSequenceUtils . subSequence ( cs , NUMBER_CONSTANT ) )
String cs
return sequenceToString ( str . subSequence ( start , end ) ) ;
return sequenceToString ( str . subSequence ( start , str . length () ) ) ;
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
String [] set
Object [] array
Class < > parameterTypes []
Class < > [] classes
Class < > [] classes
Class < > [] toClassArray
char [] chars
char [] chars
return frames . toArray ( new String [ NUMBER_CONSTANT ] ) ;
return types . toArray ( new Type [ NUMBER_CONSTANT ] ) ;
CharSequence cs
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
String [] searchStrs
String [] searchStrs
char [] searchChars
String [] strs
CharSequence input
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
( idx = indexOfSequence ( str , sub , idx ) ) != INDEX_NOT_FOUND
tmp = lastIndexOfSequence ( str , search , str . length () ) ;
tmp = indexOfSequence ( str , search , NUMBER_CONSTANT ) ;
{ if ( searchChars == null ) { return false ; } return containsAny ( cs , toCharArraySequence ( searchChars ) ) ; }
{ if ( regionMatchesSequence ( str , true , i , searchStr , NUMBER_CONSTANT , len ) ) { return true ; } }
return indexOfSequence ( seq , searchSeq , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ;
{ if ( isEmpty ( seq ) ) { return false ; } return indexOfSequence ( seq , searchChar , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return StringUtils . lastIndexOfSequence ( seq , searchSeq , startPos ) ; }
return StringUtils . lastIndexOfSequence ( seq , searchSeq , seq . length () ) ;
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return StringUtils . lastIndexOfSequence ( seq , searchChar , startPos ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return StringUtils . lastIndexOfSequence ( seq , searchChar , seq . length () ) ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return StringUtils . indexOfSequence ( seq , searchSeq , startPos ) ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return StringUtils . indexOfSequence ( seq , searchSeq , NUMBER_CONSTANT ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return StringUtils . indexOfSequence ( seq , searchChar , startPos ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return StringUtils . indexOfSequence ( seq , searchChar , NUMBER_CONSTANT ) ; }
{ return value == NUMBER_CONSTANT ? false : true ; }
{ if ( bool == null ) { return valueIfNull ; } return bool . booleanValue () ? true : false ; }
{ if ( bool == null ) { return null ; } return ( bool . booleanValue () ? Boolean.FALSE : Boolean.TRUE ) ; }
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
if ( lastWasGap ) { buf [ count ++ ] = ch ; lastWasGap = false ; } else {}
String [] excludeFieldNames
String [] excludeFields
{ return reflectionCompare ( lhs , rhs , compareTransients , null , null ) ; }
{ return reflectionCompare ( lhs , rhs , false , null , null ) ; }
String [] excludeFields
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , testTransients , null , null ) ; }
String [] excludeFields
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null , null ) ; }
String [] excludeFields
{ return reflectionEquals ( lhs , rhs , testTransients , null , null ) ; }
String [] excludeFields
{ this . excludeFieldNames = excludeFieldNamesParam . clone () ; Arrays . sort ( this . excludeFieldNames ) ; }
StringBuilder builder = new StringBuilder ( ClassUtils . getShortClassName ( this , null ) ) ;
char [] chars
@ Override public R getRightElement () { return rightElement ; }
@ Override public L getLeftElement () { return leftElement ; }
Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeftElement () , pair . getRightElement () ) ;
public R getValue () { return getRightElement () ; }
public final L getKey () { return getLeftElement () ; }
{ R result = getRightElement () ; setRightElement ( value ) ; return result ; }
{ try { return getAccessibleConstructor ( cls . getConstructor ( parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return ( null ) ; } }
{ try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return ( null ) ; } }
Calendar c = new GregorianCalendar ( mTimeZone ) ;
Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ;
{ return getDateTimeInstance ( dateStyle , timeStyle , null , locale ) ; }
{ return getDateTimeInstance ( dateStyle , timeStyle , null , null ) ; }
{ return getTimeInstance ( style , timeZone , null ) ; }
{ return getTimeInstance ( style , null , locale ) ; }
{ return getTimeInstance ( style , null , null ) ; }
{ return getDateInstance ( style , timeZone , null ) ; }
{ return getDateInstance ( style , null , locale ) ; }
{ return getDateInstance ( style , null , null ) ; }
{ return getInstance ( pattern , null , locale ) ; }
{ return getInstance ( pattern , timeZone , null ) ; }
{ return getInstance ( pattern , null , null ) ; }
CharSequence _ellipsis = ObjectUtils . defaultIfNull ( ellipsis , STRING_CONSTANT ) ;
return padding ( pads , padChar ) . concat ( str ) ;
return str . concat ( padding ( pads , padChar ) ) ;
if ( inputLength == NUMBER_CONSTANT && repeat <= PAD_LIMIT ) { return padding ( repeat , str . charAt ( NUMBER_CONSTANT ) ) ; }
return pad ( pads , padChar ) . concat ( str ) ;
return str . concat ( pad ( pads , padChar ) ) ;
assertSame ( Locale.GERMANY , format1 . getLocale () ) ;
{ Integer count = eventCounts . get ( eventName ) ; return count == null ? NUMBER_CONSTANT : count ; }
{ R result = getRight () ; setRightElement ( value ) ; return result ; }
{ if ( isSet ( OPTION.semiColonRequired ) ) { return NUMBER_CONSTANT ; } else if ( isSet ( OPTION.errorIfNoSemiColon ) ) { throw new RuntimeException ( STRING_CONSTANT ) ; } }
int delimLen = ( delimiters == null ? - NUMBER_CONSTANT : delimiters.length ) ;
@ Override
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
if ( timeToLive < NUMBER_CONSTANT ) { throw new IllegalStateException ( STRING_CONSTANT + timeToLive + STRING_CONSTANT + text ) ; }
{ if ( StringUtils . isEmpty ( str ) ) { return null ; } return toCharacterObject ( str . charAt ( NUMBER_CONSTANT ) ) ; }
public Integer getValue () { return new Integer ( this . value ) ; }
Integer value = new Integer ( NUMBER_CONSTANT ) ;
mutNum . subtract ( new Integer ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Integer ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == new Integer ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , numA . equals ( new Integer ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableInt ( new Integer ( NUMBER_CONSTANT ) ) . intValue () ) ;
assertEquals ( false , f1 . equals ( new Integer ( NUMBER_CONSTANT ) ) ) ;
try { FieldUtils . writeField ( field , publicChild , new Integer ( Integer.MAX_VALUE ) ) ; } catch ( IllegalAccessException e ) {}
DurationFormatUtils.Token numToken = new DurationFormatUtils.Token ( new Integer ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
map . put ( STRING_CONSTANT , new Integer ( NUMBER_CONSTANT ) ) ;
map . put ( STRING_CONSTANT , new Integer ( NUMBER_CONSTANT ) ) ;
coll . add ( new Integer ( NUMBER_CONSTANT ) ) ;
coll . add ( new Integer ( NUMBER_CONSTANT ) ) ;
assertEquals ( false , sb1 . equals ( new Integer ( NUMBER_CONSTANT ) ) ) ;
sb . appendln ( new Integer ( NUMBER_CONSTANT ) ) ;
mutNum . subtract ( new Integer ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Integer ( NUMBER_CONSTANT ) ) ;
Integer i = new Integer ( NUMBER_CONSTANT ) ;
Integer val = new Integer ( NUMBER_CONSTANT ) ;
Integer val = new Integer ( NUMBER_CONSTANT ) ;
iInteger = new Integer ( NUMBER_CONSTANT ) ;
map . put ( STRING_CONSTANT , new Integer ( NUMBER_CONSTANT ) ) ;
Integer i = new Integer ( NUMBER_CONSTANT ) ;
public Long getValue () { return new Long ( this . value ) ; }
mutNum . subtract ( new Long ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Long ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == new Long ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( new Long ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableLong ( new Long ( NUMBER_CONSTANT ) ) . longValue () ) ;
mutNum . subtract ( new Short ( ( short ) NUMBER_CONSTANT ) ) ;
mutNum . add ( new Short ( ( short ) NUMBER_CONSTANT ) ) ;
public Short getValue () { return new Short ( this . value ) ; }
public Double getValue () { return new Double ( this . value ) ; }
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , new Double ( value ) ) ) ; } }
mutNum . subtract ( new Double ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Double ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == new Double ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( new Double ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableDouble ( new Double ( NUMBER_CONSTANT ) ) . doubleValue () , NUMBER_CONSTANT ) ;
try { FieldUtils . writeField ( field , publicChild , new Double ( Double.MAX_VALUE ) ) ; } catch ( IllegalAccessException e ) {}
mutNum . subtract ( new Float ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Float ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == new Float ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( new Float ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableFloat ( new Float ( NUMBER_CONSTANT ) ) . floatValue () , NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , new MutableObject < Double > ( new Double ( NUMBER_CONSTANT ) ) . toString () ) ;
public Float getValue () { return new Float ( this . value ) ; }
Object [] args = new Object [] { new Double ( STRING_CONSTANT ) } ;
args = new Object [] { STRING_CONSTANT , cal . getTime () , new Double ( STRING_CONSTANT ) }
{ throw new UnsupportedOperationException ( STRING_CONSTANT , new UnsupportedOperationException ( java6Exception ) ) ; }
assertEquals ( null , StringUtils . splitPreserveAllTokens ( null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . splitPreserveAllTokens ( null ) ) ;
assertEquals ( null , StringUtils . splitByWholeSeparatorPreserveAllTokens ( null , STRING_CONSTANT , - NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . splitByWholeSeparator ( null , STRING_CONSTANT , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . splitByWholeSeparator ( null , STRING_CONSTANT ) ) ;
assertEquals ( null , StringUtils . split ( null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . split ( null ) ) ;
public synchronized void delete () { listField . removeFirstOccurrence ( Integer . valueOf ( random . nextInt ( N ) ) ) ; }
separator = ( separator == null ? STRING_CONSTANT : separator ) ;
separator = ( separator == null ? STRING_CONSTANT : separator ) ;
separator = ( separator == null ? STRING_CONSTANT : separator ) ;
separator = separator == null ? STRING_CONSTANT : separator ;
separator = separator == null ? STRING_CONSTANT : separator ;
separator = separator == null ? STRING_CONSTANT : separator ;
return super . equals ( o ) && ( b == rhs.b ) ;
return ( a == rhs.a ) ;
assertEquals ( bf_zero . setShortValue ( ( short ) NUMBER_CONSTANT , ( short ) j ) , ( short ) ( NUMBER_CONSTANT ) ) ;
{ long bits = Double . doubleToLongBits ( value ) ; return ( int ) ( bits ^ ( bits > > > NUMBER_CONSTANT ) ) ; }
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
return super . equals ( o ) && ( b == rhs.b ) ;
return ( a == rhs.a ) ;
int d2 = ( tmodd1 == NUMBER_CONSTANT ) ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ;
long m = ( ( long ) x ) * ( ( long ) y ) ;
long m = ( ( long ) x ) * ( ( long ) y ) ;
( power % NUMBER_CONSTANT ) == NUMBER_CONSTANT
{ return ( ( double ) numerator ) / ( ( double ) denominator ) ; }
{ return ( ( float ) numerator ) / ( ( float ) denominator ) ; }
return ( result != null ) ? result : value ;
{ return ( initializer != null ) ? initializer . get () : null ; }
for ( E constant : values ) { total |= ( NUMBER_CONSTANT < < constant . ordinal () ) ; }
if ( str == null || prefix == null ) { return ( str == null && prefix == null ) ; }
if ( allStringsNull || ( longestStrLen == NUMBER_CONSTANT && ! anyStringNull ) ) { return INDEX_NOT_FOUND ; }
if ( length >= str . length () || length < ( middle . length () + NUMBER_CONSTANT ) ) { return str ; }
int noOfItems = ( endIndex - startIndex ) ;
int noOfItems = ( endIndex - startIndex ) ;
if ( match || ( preserveAllTokens && lastMatch ) ) { list . add ( str . substring ( start , i ) ) ; }
if ( match || ( preserveAllTokens && lastMatch ) ) { list . add ( str . substring ( start , i ) ) ; }
if ( ( separator == null ) || ( EMPTY . equals ( separator ) ) ) { return splitWorker ( str , null , max , preserveAllTokens ) ; }
pos < ( strLen - closeLen )
if ( pos == INDEX_NOT_FOUND || pos == ( str . length () - separator . length () ) ) { return EMPTY ; }
if ( str . length () <= ( pos + len ) ) { return str . substring ( pos ) ; }
return ( ret == Integer.MAX_VALUE ) ? INDEX_NOT_FOUND : ret ;
startPos > ( str . length () - searchStr . length () )
int endLimit = ( str . length () - searchStr . length () ) + NUMBER_CONSTANT ;
{ return ( schedFuture != null ) ? schedFuture : super . startTimer () ; }
int delimLen = ( delimiters == null ? - NUMBER_CONSTANT : delimiters.length ) ;
int delimLen = ( delimiters == null ? - NUMBER_CONSTANT : delimiters.length ) ;
( inputLineLength - offset ) > wrapLength
return super . equals ( o ) && ( b == rhs.b ) ;
return ( a == rhs.a ) ;
{ return ( options == null ) ? false : options . contains ( option ) ; }
{ boolean b = ( ch >= CHAR_CONS && ch <= CHAR_CONS ) ; t += b ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
root = ( root == null ? th : root ) ;
if ( cls == null ) { return ! ( toClass . isPrimitive () ) ; }
( pos + i ) >= len || chars [ pos + i ] != chars [ quoteStart + i ]
{ return ( obj == null ) ? NUMBER_CONSTANT : obj . hashCode () ; }
if ( ( object1 == null ) || ( object2 == null ) ) { return false ; }
dev = ( observed [ i ] - expected [ i ] ) ;
int remainder = ( len - pos ) ;
if ( coll == null || coll . size () == NUMBER_CONSTANT ) { return false ; }
Object [] original = new Object [] { true , false } ;
assertEquals ( STRING_CONSTANT , flag , t . isDaemon () ) ;
assertTrue ( triple . getRight () ) ;
assertFalse ( triple . getRight () ) ;
triple2 = Triple . of ( null , STRING_CONSTANT , NUMBER_CONSTANT )
fdf = getInstance ( STRING_CONSTANT ) ;
@ Override public Locale getLocale () { return locale ; }
@ Override public TimeZone getTimeZone () { return timeZone ; }
@ Override public String getPattern () { return pattern ; }
@ Override public Locale getLocale () { return mLocale ; }
@ Override public TimeZone getTimeZone () { return mTimeZone ; }
@ Override public String getPattern () { return mPattern ; }
DateFormatSymbols symbols = DateFormatSymbols . getInstance ( locale ) ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
if ( str . length () == NUMBER_CONSTANT || deepEmpty ( set ) ) { return STRING_CONSTANT ; }
if ( cls != null ) return cls ; else throw cnfe ;
public Object getValue () { return null ; }
public Locale getLocale () { return locale ; }
public TimeZone getTimeZone () { return timeZone ; }
public String getPattern () { return pattern ; }
new Runnable () { public void run () { endOfPeriod () ; } }
public Locale getLocale () { return mLocale ; }
public TimeZone getTimeZone () { return mTimeZone ; }
public String getPattern () { return mPattern ; }
public Locale getLocale ( ) ;
public Locale getLocale ( ) ;
@ Override public void setUp ( ) throws Exception { exceptionContext = new DefaultExceptionContext () ; super . setUp () ; }
@ Override
assertEquals ( false , new BitField ( NUMBER_CONSTANT ) . isSet ( clearedBit ) ) ;
assertEquals ( true , rangea . isNegated () ) ;
assertEquals ( true , rangea . isNegated () ) ;
assertEquals ( true , rangea . isNegated () ) ;
assertEquals ( false , rangea . isNegated () ) ;
assertEquals ( false , rangea . isNegated () ) ;
assertEquals ( false , rangea . isNegated () ) ;
assertEquals ( true , rangea . isNegated () ) ;
assertEquals ( false , rangea . isNegated () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( true , hc2a != NUMBER_CONSTANT ) ;
assertEquals ( true , sb.buffer.length >= NUMBER_CONSTANT ) ;
@ Override public int hashCode () { return b * NUMBER_CONSTANT + t ; }
{ return parseDateWithLeniency ( str , parsePatterns , false ) ; }
{ return parseDateWithLeniency ( str , parsePatterns , true ) ; }
DateParser parser = getInstance ( STRING_CONSTANT , TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
{ return getInstance ( FormatCache . getPatternForStyle ( dateStyle , null , locale ) , TimeZone . getDefault () , Locale . getDefault () ) ; }
DateFormatSymbols symbols = new DateFormatSymbols ( locale ) ;
if ( eraBC && format . equals ( SHORT_FORMAT ) && locale . toString () . equals ( STRING_CONSTANT ) ) { continue; }
if ( year < NUMBER_CONSTANT && locale . toString () . equals ( STRING_CONSTANT ) ) { continue; }
assertEquals ( locale . toString () + STRING_CONSTANT + formattedDate , expectedTime , actualTime ) ;
Strategy strategy = cache . get ( field ) ;
{ return getInstance ( FormatCache . getPatternForStyle ( dateStyle , null , locale ) , TimeZone . getDefault () , Locale . getDefault () ) ; }
return initializeCalls ;
return ++ initializeCalls ;
return REPEAT ;
this . value instanceof StringBuffer
StringBuffer buffer = new StringBuffer () ;
StringBuffer buffer = new StringBuffer () ;
StringBuffer result = new StringBuffer () ;
StringBuffer buffer = new StringBuffer () ;
StringBuffer expected = new StringBuffer () ;
StringBuffer sb = new StringBuffer ( dstInit ) ;
StringBuffer sb = new StringBuffer ( dstInit ) ;
StringBuffer sb = new StringBuffer ( dstInit ) ;
StringBuffer sb = new StringBuffer ( dstInit ) ;
throw new java.lang.IllegalArgumentException ( STRING_CONSTANT + nibble ) ;
throw new java.lang.IllegalArgumentException ( STRING_CONSTANT + nibble ) ;
HashMap < Boolean , MutableInt > occurrences = new HashMap < Boolean , MutableInt > ( values.length ) ;
{ System.out . println ( STRING_CONSTANT ) ; }
{ System.out . println ( STRING_CONSTANT ) ; }
{ output = ( int [] ) removeAll ( array , toRemove ) ; }
return ( boolean [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( double [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( float [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( long [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( char [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( int [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( short [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( byte [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
result = ( T [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) )
{ return format ( new Date ( millis ) ) ; }
Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ;
{ if ( str == null ) { return null ; } return WHITESPACE_BLOCK . matcher ( trim ( str ) ) . replaceAll ( STRING_CONSTANT ) ; }
{ if ( str == null ) { return null ; } return WHITESPACE_PATTERN . matcher ( trim ( str ) ) . replaceAll ( STRING_CONSTANT ) ; }
if ( isEmpty ( padStr ) ) { padStr = STRING_CONSTANT ; }
if ( isEmpty ( padStr ) ) { padStr = STRING_CONSTANT ; }
if ( isEmpty ( padStr ) ) { padStr = STRING_CONSTANT ; }
{ out . write ( STRING_CONSTANT + hex ( codepoint ) ) ; }
@ Override public boolean equals ( Object obj ) { return EqualsBuilder . reflectionEquals ( this , obj ) ; }
public void setObjectReference ( TestObjectReference reference ) { this . reference = reference ; }
public TestObjectReference ( int one ) { this . one = new TestObject ( one ) ; }
Object o
public TestBCanEqualA ( int b ) { this . b = b ; }
Object o
public TestACanEqualB ( int a ) { this . a = a ; }
boolean testTransients
public void setT ( int t ) { this . t = t ; }
public void setB ( int b ) { this . b = b ; }
Object o
public void setA ( int a ) { this . a = a ; }
Object o
public TestObject ( int a ) { this . a = a ; }
c = new Comparable () { @ Override public int compareTo ( Object other ) { return NUMBER_CONSTANT ; } }
MutableInt other
Object obj
Number operand
int operand
Number operand
int operand
Number value
int value
String value
Number value
int value
String input
String baseMessage
String label
String label
String format
Object obj
Range < T > other
Range < T > otherRange
Range < T > otherRange
Range < T > otherRange
Range < T > otherRange
T element
T element
T element
T element
T element
T element
T element
MutableDouble other
Object obj
Number operand
double operand
Number operand
double operand
Number value
double value
String value
Number value
double value
int codepoint
CharSequenceTranslator . . . translators
CharSequence input
boolean testTransients
boolean testTransients
String str
char [] cbuf
int c
@ Override public void mark ( int readAheadLimit ) { mark = pos ; }
int index
int startIndex
Object obj
StrBuilder other
StrBuilder other
StrMatcher matcher
StrMatcher matcher
String str
String str
char ch
char ch
StrMatcher matcher
StrMatcher matcher
String str
String str
char ch
char ch
StrMatcher matcher
String str
char ch
int length
int length
int length
int startIndex
int start
String str
String str
StrMatcher matcher
StrMatcher matcher
String str
String str
char ch
char ch
int startIndex
boolean value
int index
char separator
String separator
Iterator < > it
Iterable < > iterable
Object [] array
Iterator < > it
Iterable < > iterable
T . . . array
double value
float value
long value
int value
char ch
boolean value
char [] chars
StrBuilder str
StringBuilder str
StringBuffer str
String str
Object obj
double value
float value
long value
int value
char ch
boolean value
char [] chars
StrBuilder str
StringBuilder str
StringBuffer str
String str
CharSequence seq
Object obj
int startIndex
int index
int index
int capacity
int length
String newLine
String str
{ @ Override public void vetoableChange ( PropertyChangeEvent e ) { calledListeners . add ( this ) ; } }
{ @ Override public void vetoableChange ( PropertyChangeEvent e ) { listenerSupport . removeListener ( this ) ; } }
listenerSupport . addListener ( new VetoableChangeListener () { @ Override public void vetoableChange ( PropertyChangeEvent e ) {} } ) ;
boolean expression
T iterable
T [] array
T chars
T chars
T map
T collection
T [] array
T object
boolean expression
String input
String input
String input
String input
String input
String input
String input
String input
String input
String input
String input
String input
String name
String name
String name
String name
String name
ExecutorService exec
Throwable cause
String msg
JavaVersion requiredVersion
String property
String osNamePrefix
String versionPrefix
boolean flag
BasicThreadFactory factory
int unit
Date date
int count
int count
int count
int count
int count
Object obj
T value
T value
MutableLong other
Object obj
Number operand
long operand
Number operand
long operand
Number value
long value
String value
Number value
long value
int codepoint
int codepoint
int codepoint
JavaVersion requiredVersion
Throwable cause
protected String toUtf16Escape ( int codepoint ) { return STRING_CONSTANT + hex ( codepoint ) ; }
int codepoint
int codepoint
Object o
public void setA ( int a ) { this . a = a ; }
Object o
public TestObject ( int a ) { this . a = a ; }
byte holder
short holder
int holder
byte holder
short holder
int holder
int holder
int holder
short holder
int holder
short holder
int holder
int mask
Constructor < T > ctor
Class < T > cls
Class < T > cls
Class < T > cls
Class < T > cls
public InspectingClient ( TestFixture testFixture ) { this . testFixture = testFixture ; }
public MutatingClient ( TestFixture testFixture ) { this . testFixture = testFixture ; }
Fraction other
Object obj
Fraction fraction
Fraction fraction
Fraction fraction
Fraction fraction
int power
@ Override public boolean cancel ( boolean mayInterruptIfRunning ) { return false ; }
T value
T value
ConcurrentInitializer < T > initializer
ConcurrentInitializer < T > initializer
ExecutionException ex
Throwable ex
ExecutionException ex
ExecutionException ex
ExecutionException ex
ExecutionException ex
boolean enableSubstitutionInVariables
StrLookup < > variableResolver
String suffix
char suffix
StrMatcher suffixMatcher
String prefix
char prefix
StrMatcher prefixMatcher
char escapeCharacter
StrBuilder source
StringBuffer source
Object source
StrBuilder source
StringBuffer source
char [] source
String source
StrLookup < > variableResolver
Map < String , V > valueMap
Object source
Class < E > enumClass
Class < E > enumClass
Class < E > enumClass
Class < E > enumClass
Class < E > enumClass
Object obj2
Object value
String format
long durationMillis
long durationMillis
String msg
DateParser getInstance ( String format ) { return getInstance ( format , TimeZone . getDefault () , Locale . getDefault () ) ; }
String str
int threshold
String . . . strs
CharSequence . . . css
String str
String str
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
String str
String str
String str
String str
String str
int size
CharSequence cs
String str
String str
String str
String str
T . . . elements
String str
String str
String str
String str
String str
String str
CharSequence seq
String input
String . . . strs
String stripChars
String str
String str
String str
String str
String str
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
Boolean . . . array
boolean . . . array
Boolean . . . array
boolean . . . array
Boolean . . . array
boolean . . . array
boolean bool
boolean bool
boolean bool
Boolean bool
Boolean bool
Boolean bool
String str
String str
Boolean bool
boolean bool
boolean bool
Integer value
int value
int value
Boolean bool
Boolean bool
Boolean bool
Boolean bool
Boolean bool
Boolean bool
Object obj
@ Override public Date parse ( String source ) throws ParseException { return parser . parse ( source ) ; }
Calendar calendar
Date date
long millis
int style
int style
String pattern
Class < > clazz
String . . . excludeFieldNamesParam
boolean appendTransients
boolean appendStatics
Object array
Field field
Class < > clazz
Field field
Object object
Object [] array
Collection < String > collection
Object object
int nibble
int nibble
boolean [] src
boolean [] src
boolean [] src
char hexDigit
char hexDigit
char hexDigit
char hexDigit
public void testTwo ( ChildInterface obj ) {}
public void testTwo ( GrandParentObject obj ) {}
public void testTwo ( Object obj ) {}
public void testOne ( ParentObject obj ) {}
public void testOne ( GrandParentObject obj ) {}
public void testOne ( Object obj ) {}
Class < > c
Class < > [] c
@ Override public void setValue ( Object value ) {}
public void oneParameter ( String s ) {}
public String foo ( Object o ) { return STRING_CONSTANT ; }
public String foo ( String s ) { return STRING_CONSTANT ; }
public String foo ( double d ) { return STRING_CONSTANT ; }
public String foo ( Integer i ) { return STRING_CONSTANT ; }
public String foo ( int i ) { return STRING_CONSTANT ; }
public static String bar ( Object o ) { return STRING_CONSTANT ; }
public static String bar ( String s ) { return STRING_CONSTANT ; }
public static String bar ( Integer i ) { return STRING_CONSTANT ; }
CharRange r
Object obj
CharRange range
char ch
char ch
char ch
boolean negated
boolean fieldSeparatorAtEnd
boolean fieldSeparatorAtStart
boolean arrayContentDetail
boolean defaultFullDetail
boolean useFieldNames
boolean useIdentityHashCode
boolean useShortClassName
boolean useClassName
Class < > cls
Boolean fullDetailRequest
StringBuffer buffer
StringBuffer buffer
StringBuffer buffer
StringBuffer buffer
Object value
Object value
Object value
Callable < T > call
Callable < T > call
StrTokenizer tokenizer
StrTokenizer tokenizer
String data
StrTokenizer tokenizer
int superCompareTo
DatePrinter getInstance ( String format ) { return getInstance ( format , TimeZone . getDefault () , Locale . getDefault () ) ; }
String languageCode
String countryCode
Locale locale
Locale locale
public AClass ( AAClass < String > enclosingInstance ) { enclosingInstance . super ( ) ; }
String baseMessage
String label
String label
Throwable cause
String message
String format
Object obj
Pair < L , R > other
String str
CharMatcher ( char ch ) { super(); this . ch = ch ; }
char chars []
String str
String chars
char . . . chars
char ch
String str
String str
String str
char . . . delimiters
String str
String str
String str
String str
Object array
float [] array
double [] array
byte [] array
short [] array
int [] array
long [] array
float [] array
double [] array
byte [] array
short [] array
int [] array
long [] array
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
Object o
TestObject rhs
public void setA ( int a ) { this . a = a ; }
Object o
public TestObject ( int a ) { this . a = a ; }
Thread.UncaughtExceptionHandler handler
int prio
boolean f
String pattern
ThreadFactory factory
Thread t
Runnable r
Builder builder
Object obj
T obj
String [] eventTypes
Collection < > coll
String language
float [] array
double [] array
float [] array
double [] array
String key
Map < String , V > map
Map < String , V > map
Object obj
Object . . . keys
String pattern
public BackgroundInitializerTestImpl ( ExecutorService exec ) { super ( exec ) ; }
BackgroundInitializerTestImpl init
CollectionHolder ( T collection ) { this . collection = collection ; }
String format
Object obj
int codepoint
int codepoint
OPTION option
OPTION . . . options
int loopCount
int loopCount
int loopCount
public static void main ( String [] args ) { new CharUtilsPerfRun () . run () ; }
Throwable th
Throwable th
Throwable t
String stackTrace
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Type type
Type type
ParameterizedType parameterizedType
WildcardType wildcardType
WildcardType wildcardType
TypeVariable < > typeVariable
Type [] bounds
ParameterizedType type
String name
ExecutorService exec
ExecutorService execDestroy
ExecutorService externalExecutor
ExecutorService exec
Collection < > coll
ParsePosition pos
String desc
Object obj
String pattern
String pattern
private void assertGetClassThrowsClassNotFound ( String className ) throws Exception { assertGetClassThrowsException ( className , ClassNotFoundException . class ) ; }
private void assertGetClassThrowsNullPointerException ( String className ) throws Exception { assertGetClassThrowsException ( className , NullPointerException . class ) ; }
Class < > c
String [] strings
String canonicalName
Class < > cls
String canonicalName
Class < > cls
Object . . . array
String className
Class < > cls
Class < > . . . classes
Class < > cls
Class < > . . . classes
Class < > cls
Class < > type
Class < > type
boolean autoboxing
List < Class < > > classes
List < String > classNames
HashSet < Class < > > interfacesFound
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
String [] [] array
String toString
String toString
String toString
Object obj
@ Override public char charAt ( int index ) { return seq . charAt ( index ) ; }
public CustomCharSequence ( CharSequence seq ) { this . seq = seq ; }
char [] str
StrBuilder str
StringBuilder str
StringBuffer str
String str
String str
Throwable cause
boolean ignoreEmptyTokens
boolean emptyAsNull
StrMatcher trimmer
char ignored
StrMatcher ignored
char quote
StrMatcher quote
String delim
char delim
StrMatcher delim
List < String > list
String obj
String obj
char [] input
String input
char [] input
String input
char [] input
String input
char [] input
String input
String replaceTemplate
char ch
char ch
char ch
char ch
char ch
char ch
char ch
char ch
Character ch
char ch
Character ch
char ch
Character ch
char ch
String str
Character ch
String str
char ch
Field field
String formattedDate
int superHashCode
short [] array
short value
Object [] array
Object object
long [] array
long value
int [] array
int value
float [] array
float value
double [] array
double value
char [] array
char value
byte [] array
byte value
boolean [] array
boolean value
Object value
Object value
Object value
void warn ( String msg ) { System.err . println ( msg ) ; }
private void assertSupportedEncoding ( String name ) { assertTrue ( STRING_CONSTANT + name , CharEncoding . isSupported ( name ) ) ; }
Annotation a
java.lang.Class < > cls
T . . . items
T . . . items
T . . . values
T . . . values
Object obj
Object object
Object . . . objects
Object obj
T . . . values
boolean isEquals
boolean superEquals
boolean [] src
@ Override public char charAt ( int arg0 ) { return value . charAt ( arg0 ) ; }
String value
public void removePropertyChangeListener ( PropertyChangeListener listener ) { listeners . removeListener ( listener ) ; }
public void addPropertyChangeListener ( PropertyChangeListener listener ) { listeners . addListener ( listener ) ; }
protected void addVetoableChangeListener ( VetoableChangeListener listener ) {}
String property
public void addPropertyChangeListener ( PropertyChangeListener listener ) { throw new RuntimeException () ; }
public void addMultipleEventListener ( MultipleEventListener listener ) { listeners . addListener ( listener ) ; }
String eventName
Class < L > listenerType
public void eventOccurred ( PropertyChangeEvent e ) { count ++ ; }
new PropertyChangeListener () { @ Override public void propertyChange ( PropertyChangeEvent e ) {} }
String toString
String superToString
Object object
short [] array
short value
Object [] array
Object obj
long [] array
long value
int [] array
int value
float [] array
float value
double [] array
double value
char [] array
char value
byte [] array
byte value
boolean [] array
boolean value
Object object
Object object
Object object
ToStringStyle style
R value
R right
L left
public SimpleReflectionTestFixture ( Object o ) { this . o = o ; }
Object o
R right
M middle
L left
void warn ( String msg ) { System.err . println ( msg ) ; }
private void readObject ( ObjectInputStream in ) throws ClassNotFoundException { throw new ClassNotFoundException ( SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE ) ; }
{ @ Override public void write ( int arg0 ) throws IOException { throw new IOException ( SERIALIZE_IO_EXCEPTION_MESSAGE ) ; } }
ObjectStreamClass desc
byte [] objectData
InputStream inputStream
Serializable obj
T object
CharSequence cs
CharSequence [] . . . lookup
MutableByte other
Object obj
Number operand
byte operand
Number operand
byte operand
Number value
byte value
String value
Number value
byte value
Object obj
char ch
String str
String . . . set
String . . . setStrs
Formattable formattable
CharSequenceTranslator . . . translators
ObjectInputStream objectInputStream
ObjectOutputStream objectOutputStream
L listener
L listener
Class < L > listenerInterface
Class < T > listenerInterface
@ Override int modify ( int iValue ) { return iValue % NUMBER_CONSTANT ; }
@ Override int modify ( int iValue ) { return iValue % NUMBER_CONSTANT ; }
@ Override int modify ( int iValue ) { return iValue - NUMBER_CONSTANT ; }
Locale locale
int modify ( int iValue ) { return iValue ; }
NumberStrategy ( int field ) { this . field = field ; }
CopyQuotedStrategy ( String formatField ) { this . formatField = formatField ; }
int field
Calendar definingCalendar
int twoDigitYear
String source
@ Override public Object parseObject ( String source ) throws ParseException { return parse ( source ) ; }
ObjectInputStream in
Object obj
int limit
Object other
Object _value
Class < > c
Class < > [] c
public TestBean ( Object o ) { toString = STRING_CONSTANT ; }
public TestBean ( String s ) { toString = STRING_CONSTANT ; }
public TestBean ( double d ) { toString = STRING_CONSTANT ; }
public TestBean ( Integer i ) { toString = STRING_CONSTANT ; }
public TestBean ( int i ) { toString = STRING_CONSTANT ; }
MutableBoolean other
Object obj
Boolean value
boolean value
Boolean value
boolean value
CollectionHolder ( T collection ) { this . collection = collection ; }
String summaryObjectEndText
String summaryObjectStartText
String sizeEndText
String sizeStartText
String nullText
boolean fieldSeparatorAtEnd
boolean fieldSeparatorAtStart
String fieldSeparator
String fieldNameValueSeparator
String contentEnd
String contentStart
String arraySeparator
String arrayEnd
String arrayStart
boolean arrayContentDetail
boolean defaultFullDetail
boolean useFieldNames
boolean useIdentityHashCode
boolean useShortClassName
boolean useClassName
BitSet coll
HashSet < Integer > coll
int count
int count
int count
int count
int count
Object obj
boolean colon
NumberRule rule
NumberRule rule
TwoDigitNumberField ( int field ) { mField = field ; }
UnpaddedNumberField ( int field ) { mField = field ; }
String value
CharacterLiteral ( char value ) { mValue = value ; }
ObjectInputStream in
Object obj
Calendar calendar
Date date
Calendar c
long millis
R value
String val
String str
String str
String str
String str
String str
String str
MutableShort other
Object obj
Number operand
short operand
Number operand
short operand
Number value
short value
String value
Number value
short value
String baseMessage
String label
String label
Throwable cause
String message
MutableFloat other
Object obj
Number operand
float operand
Number operand
float operand
Number value
float value
String value
Number value
float value
Class < > destClass
Member m
int modifiers
AccessibleObject o
public NestableException ( Throwable t ) { super ( t ) ; }
public void setCause ( Throwable cause ) { this . cause = cause ; }
public ExceptionWithCause ( Throwable cause ) { super(); setCause ( cause ) ; }
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
T [] array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
Object [] array
boolean [] array
Boolean [] array
float [] array
Float [] array
double [] array
Double [] array
byte [] array
Byte [] array
short [] array
Short [] array
int [] array
Integer [] array
long [] array
Long [] array
char [] array
Character [] array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
Object [] array
Object array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
T [] array
Boolean [] array
Float [] array
Double [] array
Byte [] array
Character [] array
Short [] array
Integer [] array
Long [] array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
String [] array
Object [] array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
T [] array
Object [] array
Object array
Object array
EqualsBuilder equalsBuilder = new EqualsBuilder () ;
EqualsBuilder equalsBuilder = new EqualsBuilder () ;
TestSubObject rhs = ( TestSubObject ) o ;
TestObject rhs = ( TestObject ) o ;
OctalUnescaper oue = new OctalUnescaper () ;
try { intRange . elementCompareTo ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
{ String str = intRange . toString ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , str ) ; }
String str = intRange . toString () ;
char pad = CHAR_CONS ;
int anotherVal = other.value ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
{ double anotherVal = other.value ; return Double . compare ( value , anotherVal ) ; }
{ long bits = Double . doubleToLongBits ( value ) ; return ( int ) ( bits ^ bits > > > NUMBER_CONSTANT ) ; }
String str = super . getContent () ;
char buf [] = buffer ;
int strLen = str . length () ;
char [] thisBuf = buffer ;
char [] thisBuf = buffer ;
int len = str . length () ;
int len = str . length () ;
char [] buf = buffer ;
int newSize = size - removeLen + insertLen ;
int len = endIndex - startIndex ;
int len = chars.length ;
{ if ( iterable != null ) { for ( Object o : iterable ) { append ( o ) ; } } return this ; }
{ for ( Object element : array ) { append ( element ) ; } }
int len = length () ;
int len = length () ;
int len = length () ;
int len = length () ;
int len = length () ;
int len = length () ;
int len = length () ;
char [] old = buffer ;
char [] old = buffer ;
for ( BackgroundInitializer < > bi : childInitializers . values () ) { result += bi . getTaskCount () ; }
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
{ Integer [] iArray = null ; assertEquals ( null , ArrayUtils . toPrimitive ( iArray , Integer.MIN_VALUE ) ) ; }
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
StringBuffer buf = new StringBuffer ( STRING_CONSTANT ) ;
catch ( SecurityException ex ) { System.err . println ( STRING_CONSTANT + property + STRING_CONSTANT ) ; return null ; }
{ BasicThreadFactory factory = builder . build () ; checkFactoryDefaults ( factory ) ; }
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
long millisPerUnit = getMillisPerUnit ( unit ) ;
Calendar calendar = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
{ Calendar c = Calendar . getInstance () ; c . setTime ( date ) ; return c ; }
Calendar c = Calendar . getInstance () ;
Calendar c = Calendar . getInstance () ;
long anotherVal = other.value ;
String str = f . toProperString () ;
String str = f . toString () ;
try { f1 . compareTo ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( NullPointerException ex ) {}
try { f = f . abs () ; fail ( STRING_CONSTANT ) ; } catch ( ArithmeticException ex ) {}
try { f = f . negate () ; fail ( STRING_CONSTANT ) ; } catch ( ArithmeticException ex ) {}
Object obj = new Object () ;
TestSubObject rhs = ( TestSubObject ) o ;
TestObject rhs = ( TestObject ) o ;
{ try { return getAccessibleConstructor ( cls . getConstructor ( parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } }
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
int properNumerator = getProperNumerator () ;
Fraction other = ( Fraction ) obj ;
Fraction f = this . multiplyBy ( this ) ;
int gcd = greatestCommonDivisor ( numerator , denominator ) ;
catch ( ConcurrentException cex ) { throw new ConcurrentRuntimeException ( cex . getCause () ) ; }
V value = map . get ( key ) ;
try { return initialize ( initializer ) ; } catch ( ConcurrentException cex ) { throw new ConcurrentRuntimeException ( cex . getCause () ) ; }
{ ConcurrentRuntimeException crex = extractCauseUnchecked ( ex ) ; if ( crex != null ) { throw crex ; } }
{ ConcurrentException cex = extractCause ( ex ) ; if ( cex != null ) { throw cex ; } }
StrLookup < > resolver = getVariableResolver () ;
StrBuilder buf = new StrBuilder ( NUMBER_CONSTANT ) ;
StrBuilder buf = new StrBuilder ( source ) ;
E value
E constant
try { return Enum . valueOf ( enumClass , enumName ) ; } catch ( IllegalArgumentException ex ) { return null ; }
try { Enum . valueOf ( enumClass , enumName ) ; return true ; } catch ( IllegalArgumentException ex ) { return false ; }
Token tok2 = ( Token ) obj2 ;
int sz = tokens.length ;
{ DateParser parser = getInstance ( yMdHmsSZ , REYKJAVIK ) ; assertEquals ( REYKJAVIK , parser . getTimeZone () ) ; }
{ DateParser parser = getInstance ( yMdHmsSZ , SWEDEN ) ; assertEquals ( SWEDEN , parser . getLocale () ) ; }
{ DateParser parser = getInstance ( yMdHmsSZ ) ; assertEquals ( yMdHmsSZ , parser . getPattern () ) ; }
{ DateParser parser = getInstance ( YMD_SLASH ) ; assertTrue ( parser . toString () . startsWith ( STRING_CONSTANT ) ) ; }
Calendar cal = Calendar . getInstance () ;
int gmt = msg . indexOf ( STRING_CONSTANT ) ;
for ( CharSequence searchString : searchStrings ) { if ( StringUtils . endsWith ( string , searchString ) ) { return true ; } }
for ( CharSequence searchString : searchStrings ) { if ( StringUtils . startsWith ( string , searchString ) ) { return true ; } }
CharSequence tmp = s ;
int smallestIndexOfDiff = indexOfDifference ( strs ) ;
int at = indexOfDifference ( str1 , str2 ) ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int pads = size - str . length () ;
int pads = size - str . length () ;
char [] chars = str . toCharArray () ;
int pos = str . lastIndexOf ( separator ) ;
int pos = str . lastIndexOf ( separator ) ;
int pos = str . indexOf ( separator ) ;
int pos = str . indexOf ( separator ) ;
int strLen = seq . length () ;
{ String ts = trim ( str ) ; return isEmpty ( ts ) ? null : ts ; }
boolean element
for ( boolean element : array ) { if ( element ) { return true ; } }
for ( boolean element : array ) { if ( ! element ) { return false ; } }
FastDateFormat other = ( FastDateFormat ) obj ;
Object object = getObject () ;
char c = Character . forDigit ( nibble , NUMBER_CONSTANT ) ;
catch ( NoSuchMethodException e ) {}
char cur = current ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
CharRange other = ( CharRange ) obj ;
if ( start > end ) { char temp = start ; start = end ; end = temp ; }
Object item = array [ i ] ;
StrTokenizer tkn = new StrTokenizer ( STRING_CONSTANT ) ;
StrTokenizer tok = new StrTokenizer ( STRING_CONSTANT ) ;
StrTokenizer tok = new StrTokenizer ( STRING_CONSTANT ) ;
StrTokenizer tok = new StrTokenizer () ;
String input = STRING_CONSTANT ;
try { tokenizer . next () ; fail () ; } catch ( NoSuchElementException ex ) {}
CompareToBuilder compareToBuilder = new CompareToBuilder () ;
{ DatePrinter printer = getInstance ( YYYY_MM_DD , NEW_YORK ) ; assertEquals ( NEW_YORK , printer . getTimeZone () ) ; }
{ DatePrinter printer = getInstance ( YYYY_MM_DD , SWEDEN ) ; assertEquals ( SWEDEN , printer . getLocale () ) ; }
{ DatePrinter printer = getInstance ( YYYY_MM_DD ) ; assertEquals ( YYYY_MM_DD , printer . getPattern () ) ; }
{ DatePrinter printer = getInstance ( YYYY_MM_DD ) ; assertTrue ( printer . toString () . startsWith ( STRING_CONSTANT ) ) ; }
CharRange rangea = CharRange . isNot ( CHAR_CONS ) ;
CharRange rangea = CharRange . is ( CHAR_CONS ) ;
catch ( InterruptedException iex ) { Thread . currentThread () . interrupt () ; }
try { result = neu . translate ( input ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException iae ) {}
NumericEntityUnescaper neu = new NumericEntityUnescaper () ;
int len = chars.length ;
for ( char delimiter : delimiters ) { if ( ch == delimiter ) { return true ; } }
try { return Short . parseShort ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Byte . parseByte ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Double . parseDouble ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Float . parseFloat ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Long . parseLong ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Integer . parseInt ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
String o1 = STRING_CONSTANT ;
String o1 = STRING_CONSTANT ;
{ TestObject o1 = new TestObject ( NUMBER_CONSTANT ) ; CompareToBuilder . reflectionCompare ( o1 , null ) ; }
TestSubObject rhs = ( TestSubObject ) o ;
TestObject rhs = ( TestObject ) o ;
{ BasicThreadFactory factory = new BasicThreadFactory ( this ) ; reset () ; return factory ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
{ ExecutorService exec = Executors . newSingleThreadExecutor () ; new CallableBackgroundInitializer < Integer > ( null , exec ) ; }
{ try { coll . add ( null ) ; fail () ; } catch ( UnsupportedOperationException ex ) {} }
Locale locale = LocaleUtils . toLocale ( localeString ) ;
Locale locale = LocaleUtils . toLocale ( localeString ) ;
Locale locale = LocaleUtils . toLocale ( language ) ;
Object obj = map . get ( key ) ;
{ MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . isException ( STRING_CONSTANT ) ; }
{ MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getException ( STRING_CONSTANT ) ; }
{ MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getResultObject ( STRING_CONSTANT ) ; }
{ MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getInitializer ( STRING_CONSTANT ) ; }
catch ( IllegalStateException istex ) { initializer . get () ; }
ExecutorService exec = Executors . newCachedThreadPool () ;
MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer . get () ;
Object key
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
{ BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; assertFalse ( STRING_CONSTANT , init . isStarted () ) ; }
{ BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; init . get () ; }
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
{ BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; assertNull ( STRING_CONSTANT , init . getActiveExecutor () ) ; }
{ BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; init . start () ; checkInitialize ( init ) ; }
long total = System . currentTimeMillis () - start ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
{ StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , sb . toString () ) ; }
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
catch ( IndexOutOfBoundsException ex ) {}
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
Type rawType = parameterizedType . getRawType () ;
Type replacementType = typeVarAssigns . get ( type ) ;
Type bound
try { return Charset . isSupported ( name ) ; } catch ( IllegalCharsetNameException ex ) { return false ; }
for ( Object name : coll ) { if ( name != null ) { return true ; } }
char [] buffer = pattern . toCharArray () ;
ExtendedMessageFormat rhs = ( ExtendedMessageFormat ) obj ;
catch ( Exception e ) { assertTrue ( exceptionType . isAssignableFrom ( e . getClass () ) ) ; }
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
{ for ( String s : strings ) { if ( StringUtils . isNotEmpty ( s ) ) { return false ; } } }
StringBuilder canonicalClassNameBuffer = new StringBuilder ( className ) ;
int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ;
String toString = AnnotationUtils . toString ( testAnno ) ;
Person p = new Person () ;
CustomCharSequence other = ( CustomCharSequence ) obj ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder ( NUMBER_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
{ try { return cloneReset () ; } catch ( CloneNotSupportedException ex ) { return null ; } }
{ StrTokenizer tok = getTSVClone () ; tok . reset ( input ) ; return tok ; }
{ StrTokenizer tok = getTSVClone () ; tok . reset ( input ) ; return tok ; }
{ StrTokenizer tok = getCSVClone () ; tok . reset ( input ) ; return tok ; }
{ StrTokenizer tok = getCSVClone () ; tok . reset ( input ) ; return tok ; }
StrBuilder buf = new StrBuilder () ;
StrSubstitutor sub = new StrSubstitutor () ;
{ StrSubstitutor sub = new StrSubstitutor () ; assertEquals ( STRING_CONSTANT , sub . replace ( STRING_CONSTANT ) ) ; }
StrSubstitutor sub = new StrSubstitutor ( values ) ;
StrSubstitutor sub = new StrSubstitutor ( values ) ;
StrSubstitutor sub = new StrSubstitutor ( values ) ;
{ StrSubstitutor sub = new StrSubstitutor () ; assertEquals ( STRING_CONSTANT , sub . replace ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
StrSubstitutor sub = new StrSubstitutor ( values ) ;
StrSubstitutor sub = new StrSubstitutor ( values ) ;
StrSubstitutor sub = new StrSubstitutor ( values ) ;
try { mutNum . compareTo ( null ) ; fail () ; } catch ( NullPointerException ex ) {}
try { mutNum . setValue ( null ) ; fail () ; } catch ( NullPointerException ex ) {}
try { new MutableShort ( ( Number ) null ) ; fail () ; } catch ( NullPointerException ex ) {}
{ for ( short element : array ) { append ( element ) ; } }
{ for ( Object element : array ) { append ( element ) ; } }
{ for ( long element : array ) { append ( element ) ; } }
{ for ( int element : array ) { append ( element ) ; } }
{ for ( float element : array ) { append ( element ) ; } }
{ for ( double element : array ) { append ( element ) ; } }
{ for ( char element : array ) { append ( element ) ; } }
{ for ( byte element : array ) { append ( element ) ; } }
{ for ( boolean element : array ) { append ( element ) ; } }
StrMatcher matcher = StrMatcher . stringMatcher ( STRING_CONSTANT ) ;
StrMatcher matcher = StrMatcher . stringMatcher ( STRING_CONSTANT ) ;
StrMatcher matcher = StrMatcher . charSetMatcher ( STRING_CONSTANT ) ;
StrMatcher matcher = StrMatcher . charMatcher ( CHAR_CONS ) ;
StrMatcher matcher = StrMatcher . noneMatcher () ;
StrMatcher matcher = StrMatcher . quoteMatcher () ;
StrMatcher matcher = StrMatcher . doubleQuoteMatcher () ;
StrMatcher matcher = StrMatcher . singleQuoteMatcher () ;
StrMatcher matcher = StrMatcher . trimMatcher () ;
StrMatcher matcher = StrMatcher . splitMatcher () ;
StrMatcher matcher = StrMatcher . spaceMatcher () ;
StrMatcher matcher = StrMatcher . tabMatcher () ;
StrMatcher matcher = StrMatcher . commaMatcher () ;
int part1 = name . hashCode () * NUMBER_CONSTANT ;
T value
T value
StringBuffer buffer = new StringBuffer () ;
{ for ( Object object : objects ) { hash = hash * NUMBER_CONSTANT + ObjectUtils . hashCode ( object ) ; } }
if ( values != null ) { for ( T val : values ) { if ( val != null ) { return val ; } } }
{ try { return parentClass . getMethod ( methodName , parameterTypes ) ; } catch ( NoSuchMethodException e ) { return null ; } }
{ try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } }
String osName = System . getProperty ( STRING_CONSTANT ) ;
String javaVersion = System . getProperty ( STRING_CONSTANT ) ;
File dir = SystemUtils . getUserHome () ;
File dir = SystemUtils . getUserDir () ;
File dir = SystemUtils . getJavaIoTmpDir () ;
File dir = SystemUtils . getJavaHome () ;
String src = STRING_CONSTANT ;
String src = STRING_CONSTANT ;
String src = STRING_CONSTANT ;
String src = STRING_CONSTANT ;
{ Object [] array = null ; assertEquals ( NUMBER_CONSTANT , ObjectUtils . hashCodeMulti ( array ) ) ; }
String oldValue = this . property ;
{ Integer count = eventCounts . get ( eventName ) ; return count == null ? NUMBER_CONSTANT : count . intValue () ; }
catch ( RuntimeException e ) {}
int start = index + NUMBER_CONSTANT ;
long testResult = DateUtils . getFragmentInHours ( aCalendar , Calendar.YEAR ) ;
long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.YEAR ) ;
long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.YEAR ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.YEAR ) ;
long testResult = DateUtils . getFragmentInHours ( aCalendar , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInHours ( aDate , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInMinutes ( aDate , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.MONTH ) ;
long expectedValue = hours ;
long expectedValue = hours ;
{ long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.HOUR_OF_DAY ) ; assertEquals ( minutes , testResult ) ; }
{ long testResult = DateUtils . getFragmentInMinutes ( aDate , Calendar.HOUR_OF_DAY ) ; assertEquals ( minutes , testResult ) ; }
long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.HOUR_OF_DAY ) ;
long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.HOUR_OF_DAY ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.HOUR_OF_DAY ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.HOUR_OF_DAY ) ;
long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.MINUTE ) ;
{ long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.MINUTE ) ; assertEquals ( seconds , testResult ) ; }
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.MINUTE ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.MINUTE ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.SECOND ) ;
{ long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.SECOND ) ; assertEquals ( millis , testResult ) ; }
{ R result = getRight () ; setRight ( value ) ; return result ; }
String message = exceptionContext . getMessage () ;
String trace = ExceptionUtils . getStackTrace ( exceptionContext ) ;
InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture () ;
ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture () ;
SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture () ;
SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture () ;
SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture () ;
SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture () ;
Outer outer = new Outer () ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
Character c = new Character ( CHAR_CONS ) ;
Locale dflt = Locale . getDefault () ;
Locale dflt = Locale . getDefault () ;
Locale dflt = Locale . getDefault () ;
Locale dflt = Locale . getDefault () ;
Locale dflt = Locale . getDefault () ;
Calendar testCalendar = Calendar . getInstance () ;
try { DateUtils . toCalendar ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
GregorianCalendar cal = new GregorianCalendar () ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
IllegalArgumentException ex
long seed = System . currentTimeMillis () ;
long seed = System . currentTimeMillis () ;
catch ( SerializationException ex ) { return; }
{ Object test = SerializationUtils . clone ( null ) ; assertNull ( test ) ; }
try { SerializationUtils . deserialize ( new byte [ NUMBER_CONSTANT ] ) ; } catch ( SerializationException ex ) { return; }
try { SerializationUtils . deserialize ( ( byte [] ) null ) ; } catch ( IllegalArgumentException ex ) { return; }
catch ( SerializationException ex ) { return; }
catch ( SerializationException ex ) { return; }
try { SerializationUtils . deserialize ( ( InputStream ) null ) ; } catch ( IllegalArgumentException ex ) { return; }
{ try { SerializationUtils . serialize ( null , null ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { SerializationUtils . serialize ( iMap , null ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
Exception ex = new Exception () ;
catch ( IllegalArgumentException expected ) {}
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
{ ByteArrayOutputStream baos = new ByteArrayOutputStream ( NUMBER_CONSTANT ) ; serialize ( obj , baos ) ; return baos . toByteArray () ; }
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
int sz = cs . length () ;
int sz = cs . length () ;
String message = exceptionContext . getMessage () ;
String trace = ExceptionUtils . getStackTrace ( exceptionContext ) ;
byte anotherVal = other.value ;
CharSet other = ( CharSet ) obj ;
{ for ( CharRange range : set ) { if ( range . contains ( ch ) ) { return true ; } } return false ; }
int sz = set.length ;
try { CharUtils . toIntValue ( CHAR_CONS ) ; } catch ( IllegalArgumentException ex ) {}
try { CharUtils . toChar ( ( Character ) null ) ; } catch ( IllegalArgumentException ex ) {}
{ for ( L listener : listeners ) { method . invoke ( listener , args ) ; } return null ; }
for ( String textKeyValue : keyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
FastDateParser other = ( FastDateParser ) obj ;
ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor ( THREAD_POOL_SIZE ) ;
IDKey idKey = ( IDKey ) other ;
{ boolean anotherVal = other.value ; return value == anotherVal ? NUMBER_CONSTANT : ( value ? NUMBER_CONSTANT : - NUMBER_CONSTANT ) ; }
BitSet toRemove = new BitSet () ;
try { StrLookup . systemPropertiesLookup () . lookup ( null ) ; fail () ; } catch ( NullPointerException ex ) {}
Integer i = Integer . valueOf ( NUMBER_CONSTANT ) ;
TimeZoneDisplayKey other = ( TimeZoneDisplayKey ) obj ;
TimeZone zone = calendar . getTimeZone () ;
{ int len = mValues [ i ] . length () ; if ( len > max ) { max = len ; } }
FastDatePrinter other = ( FastDatePrinter ) obj ;
{ for ( Rule rule : mRules ) { rule . appendTo ( buf , calendar ) ; } return buf ; }
{ Calendar c = newCalendar () ; c . setTime ( date ) ; return applyRules ( c , buf ) ; }
{ Calendar c = newCalendar () ; c . setTime ( date ) ; return applyRulesToString ( c ) ; }
{ Calendar c = newCalendar () ; c . setTimeInMillis ( millis ) ; return applyRulesToString ( c ) ; }
try { NumberUtils . createNumber ( STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( NumberFormatException nfe ) {}
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
short anotherVal = other.value ;
{ float anotherVal = other.value ; return Float . compare ( value , anotherVal ) ; }
{ try { throw new ExceptionWithoutCause () ; } catch ( Throwable t ) { return t ; } }
MessageFormat result = new MessageFormat ( pattern ) ;
for ( Locale locale : locales ) { checkBuiltInFormat ( pattern , registry , args , locale ) ; }
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
Boolean b = array [ i ] ;
Float b = array [ i ] ;
Double b = array [ i ] ;
Byte b = array [ i ] ;
Short b = array [ i ] ;
Integer b = array [ i ] ;
Long b = array [ i ] ;
Character b = array [ i ] ;
catch ( IllegalStateException e ) {}
{ final BigDecimal value = NumberUtils . createBigDecimal ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final BigInteger value = NumberUtils . createBigInteger ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final Long value = NumberUtils . createLong ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final Integer value = NumberUtils . createInteger ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final Double value = NumberUtils . createDouble ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final Float value = NumberUtils . createFloat ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ return cache . getDateTimeInstance ( null , style , timeZone , locale ) ; }
{ return cache . getDateTimeInstance ( null , style , timeZone , null ) ; }
{ return cache . getDateTimeInstance ( null , style , null , locale ) ; }
{ return cache . getDateTimeInstance ( null , style , null , null ) ; }
{ return cache . getDateTimeInstance ( style , null , timeZone , locale ) ; }
{ return cache . getDateTimeInstance ( style , null , timeZone , null ) ; }
{ return cache . getDateTimeInstance ( style , null , null , locale ) ; }
{ return cache . getDateTimeInstance ( style , null , null , null ) ; }
return org.apache.commons.lang3.SerializationUtils . < T > deserialize ( new ByteArrayInputStream ( objectData ) ) ;
exceptionContext = new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () {} ) ;
exceptionContext = new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () ) ;
Strategy strategy = cache . get ( Integer . valueOf ( field ) ) ;
if ( nullText != null && nullText . length () == NUMBER_CONSTANT ) { nullText = null ; }
if ( str . length () == NUMBER_CONSTANT ) { return ArrayUtils.EMPTY_STRING_ARRAY ; }
if ( separator . length () == NUMBER_CONSTANT ) { return EMPTY ; }
return str . length () == NUMBER_CONSTANT ? null : str ;
if ( str . length () == NUMBER_CONSTANT || deepEmpty ( set ) ) { return StringUtils.EMPTY ; }
final Integer max = TypeUtilsTest . stub () ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () {} )
{ if ( this . runningState == STATE_UNSTARTED ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } return this . startTimeMillis ; }
if ( this . splitState != STATE_SPLIT ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
{ return new GenericArrayTypeImpl ( componentType ) ; }
{ FieldUtils . readDeclaredField ( ( Object ) null , STRING_CONSTANT , true ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readDeclaredField ( ( Object ) null , STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readField ( ( Field ) null , publicChild , true ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readField ( ( Field ) null , publicChild ) ; fail ( STRING_CONSTANT ) ; }
assertEquals ( null , LocaleUtils . toLocale ( ( String ) null ) ) ;
final Iterable < E > values
final Iterable < E > values
{ return new FastDateParser ( format , timeZone , locale ) ; }
assertEquals ( null , StringUtils . normalizeSpace ( null ) ) ;
assertEquals ( null , StringUtils . difference ( null , null ) ) ;
assertEquals ( null , StringUtils . abbreviate ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . reverseDelimited ( null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . reverse ( null ) ) ;
assertEquals ( null , StringUtils . leftPad ( null , NUMBER_CONSTANT , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . leftPad ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . rightPad ( null , NUMBER_CONSTANT , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . rightPad ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . repeat ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . replaceChars ( null , CHAR_CONS , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . deleteWhitespace ( null ) ) ;
assertArrayEquals ( null , StringUtils . splitPreserveAllTokens ( null , CHAR_CONS ) ) ;
assertArrayEquals ( null , StringUtils . splitPreserveAllTokens ( null ) ) ;
assertArrayEquals ( null , StringUtils . split ( null , CHAR_CONS ) ) ;
assertArrayEquals ( null , StringUtils . split ( null ) ) ;
assertEquals ( minutes + ( ( hours * DateUtils.MILLIS_PER_HOUR ) + ( days * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_MINUTE , testResult )
assertEquals ( minutes + ( ( hours * DateUtils.MILLIS_PER_HOUR ) + ( days * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_MINUTE , testResult )
( ( minutes * DateUtils.MILLIS_PER_MINUTE ) + ( hours * DateUtils.MILLIS_PER_HOUR ) + ( days * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_SECOND
( ( minutes * DateUtils.MILLIS_PER_MINUTE ) + ( hours * DateUtils.MILLIS_PER_HOUR ) + ( days * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_SECOND
( days * DateUtils.MILLIS_PER_DAY )
( days * DateUtils.MILLIS_PER_DAY )
assertEquals ( null , StringUtils . swapCase ( null ) ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
final Class context
final Class context
list0 = new ArrayList < Object > ( Arrays . asList () )
assertEquals ( STRING_CONSTANT , StringUtils . join () ) ;
return readField ( field , target ) ;
return readField ( field , target ) ;
writeField ( field , target , value ) ;
writeField ( field , target , value ) ;
writeField ( field , ( Object ) null , value ) ;
writeStaticField ( field , value ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toShort ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toDouble ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toFloat ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toLong ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toInt ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toShort ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toDouble ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toFloat ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toLong ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toInt ( ( String ) null ) == NUMBER_CONSTANT ) ;
{ return new DiffResult ( lhs , rhs , diffs , style ) ; }
{ super ( message , cause ) ; }
public NotImplementedException ( final Throwable cause ) { super ( cause ) ; }
{ super ( message ) ; }
{ pos += Character . charCount ( Character . codePointAt ( input , pt ) ) ; }
return input . length () ;
Date centuryStart
{ return getFragment ( calendar , fragment , Calendar.DAY_OF_YEAR ) ; }
{ return getFragment ( calendar , fragment , Calendar.HOUR_OF_DAY ) ; }
{ return getFragment ( calendar , fragment , Calendar.MINUTE ) ; }
{ return getFragment ( calendar , fragment , Calendar.SECOND ) ; }
{ return getFragment ( calendar , fragment , Calendar.MILLISECOND ) ; }
{ return getFragment ( date , fragment , Calendar.DAY_OF_YEAR ) ; }
{ return getFragment ( date , fragment , Calendar.HOUR_OF_DAY ) ; }
{ return getFragment ( date , fragment , Calendar.MINUTE ) ; }
{ return getFragment ( date , fragment , Calendar.SECOND ) ; }
{ return getFragment ( date , fragment , Calendar.MILLISECOND ) ; }
return - NUMBER_CONSTANT ;
final Integer iVal = keyValues . get ( value ) ;
regex . append ( CHAR_CONS ) ;
final Integer iVal = lKeyValues . get ( value . toLowerCase () ) ;
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( locale ) : new TextStrategy ( field , definingCalendar , locale ) ;
for ( final String textKeyValue : keyValues . keySet () ) { sb . append ( textKeyValue ) . append ( CHAR_CONS ) ; }
for ( final String textKeyValue : keyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
shift = i * NUMBER_CONSTANT + srcPos ;
shift = i * NUMBER_CONSTANT + srcPos ;
shift = i * NUMBER_CONSTANT + srcPos ;
shift = i * NUMBER_CONSTANT + dstPos ;
shift = i * NUMBER_CONSTANT + dstPos ;
shift = i * NUMBER_CONSTANT + dstPos ;
shift = i * NUMBER_CONSTANT + dstPos ;
SimpleClass obj
public SimpleClass ( boolean booleanField ) { this . booleanField = booleanField ; }
T value
String fieldName
StringBuilder source
CharSequence source
StringBuilder sb = new StringBuilder () ;
StringBuilder sb = new StringBuilder () ;
{ for ( Token token : tokens ) { if ( token . getValue () == value ) { return true ; } } return false ; }
char firstChar = str . charAt ( NUMBER_CONSTANT ) ;
char firstChar = str . charAt ( NUMBER_CONSTANT ) ;
CharSequence . . . css
CharSequence . . . css
protected BooleanDiff ( String fieldName ) { super ( fieldName ) ; }
Method m
Method m
@ Override public void consume ( T t ) {}
TypeTestClass class1 = new TypeTestClass () ;
@ Override public boolean equals ( Object obj ) { return EqualsBuilder . reflectionEquals ( this , obj , false ) ; }
TypeTestClass obj
String [] element
String [] element
Locale locale
Locale locale
Locale locale
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
GenericArrayType g
WildcardType w
ParameterizedType p
TypeVariable < > v
Class < > c
TypeVariable < > var
Type type
Object obj
Object obj
Object obj
Type componentType
Type . . . bounds
Type . . . bounds
double result = RandomUtils . nextDouble ( NUMBER_CONSTANT , Double.MAX_VALUE ) ;
float result = RandomUtils . nextFloat ( NUMBER_CONSTANT , Float.MAX_VALUE ) ;
long result = RandomUtils . nextLong ( NUMBER_CONSTANT , Long.MAX_VALUE ) ;
int result = RandomUtils . nextInt ( NUMBER_CONSTANT , Integer.MAX_VALUE ) ;
long result = RandomUtils . nextLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double result = RandomUtils . nextFloat ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double result = RandomUtils . nextDouble ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
int result = RandomUtils . nextInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
@ Override public void consume ( String t ) { super . consume ( t ) ; }
Field field
Class < > cls
{ String pattern = STRING_CONSTANT ; FastDateFormat . getInstance ( pattern ) ; }
{ int tmpHash = ObjectUtils . hashCode ( object ) ; hash = hash * NUMBER_CONSTANT + tmpHash ; }
Interfaces interfacesBehavior
char ch
char ch
Calendar c = Calendar . getInstance () ;
Object obj
String [] zone
{ int trial = century + twoDigitYear ; return twoDigitYear >= startYear ? trial : trial + NUMBER_CONSTANT ; }
Calendar definingCalendar
for ( final CharSequence searchString : searchStrings ) { if ( StringUtils . endsWith ( string , searchString ) ) { return true ; } }
for ( final CharSequence searchString : searchStrings ) { if ( StringUtils . startsWith ( string , searchString ) ) { return true ; } }
{ return StringUtils . isEmpty ( str ) ? defaultStr : str ; }
{ return StringUtils . isBlank ( str ) ? defaultStr : str ; }
{ return ! StringUtils . isBlank ( cs ) ; }
{ return ! StringUtils . isEmpty ( cs ) ; }
{ return isDigits ( StringUtils . replaceOnce ( StringUtils . substring ( str , NUMBER_CONSTANT ) , STRING_CONSTANT , StringUtils.EMPTY ) ) ; }
modify ( ceiled , field , MODIFY_CEILING ) ;
modify ( gval , field , MODIFY_CEILING ) ;
modify ( truncated , field , MODIFY_TRUNCATE ) ;
modify ( gval , field , MODIFY_TRUNCATE ) ;
modify ( rounded , field , MODIFY_ROUND ) ;
modify ( gval , field , MODIFY_ROUND ) ;
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
{ type = array . getClass () ; }
appendQuotedString ( pattern , pos , sb , false ) ;
getQuotedString ( pattern , pos , false ) ;
appendQuotedString ( pattern , pos , stripCustom , true ) ;
{ regex . append ( PATTERN ) ; return true ; }
{ if ( value < NUMBER_CONSTANT ) { appendDigits ( buffer , value ) ; } else { buffer . append ( Integer . toString ( value ) ) ; } }
exec . awaitTermination ( Long.MAX_VALUE , TimeUnit.MILLISECONDS ) ;
{ System.out . println ( STRING_CONSTANT + osName ) ; }
return osName . startsWith ( osNamePrefix ) && osVersion . startsWith ( osVersionPrefix ) ;
return isOSNameMatch ( osName , osNamePrefix ) && osVersion . startsWith ( osVersionPrefix ) ;
{ fail ( STRING_CONSTANT + osName ) ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
final int halflength = ( shorter . length () / NUMBER_CONSTANT ) + NUMBER_CONSTANT ;
( f . getName () . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT )
( field . getName () . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT )
( f . getName () . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT )
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }
{ if ( isEquals == false ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
if ( isEquals == false ) { return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = superEquals ; return this ; }
modType == ModifyType.CEILING || ( modType == ModifyType.ROUND && roundUp )
{ result = DateUtils . setMilliseconds ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setSeconds ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setMinutes ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setHours ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setDays ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setMonths ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
try { date = DateUtils . parseDateStrictly ( dateStr , parsers ) ; fail () ; } catch ( final ParseException ex ) {}
{ regex . append ( validTimeZoneChars ) ; return true ; }
{ regex . append ( VALID_TZ ) ; return true ; }
{ regex . append ( validTimeZoneChars ) ; return true ; }
return true ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
expected . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ this ( pattern , timeZone , locale , null ) ; }
text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT . format ( cal ) ;
final String actualValue = FastDateFormat . getInstance ( PATTERN ) . format ( cal ) ;
{ return applyRules ( calendar , buf ) ; }
if ( tokenLen == NUMBER_CONSTANT ) { rule = TimeZoneNumberRule.INSTANCE_ISO_8601 ; } else { rule = TimeZoneNumberRule.INSTANCE_COLON ; }
if ( ! threadGroup . isDestroyed () ) threadGroup . destroy () ;
this . typeArguments = typeArguments ;
@ Override public boolean test ( @ SuppressWarnings ( STRING_CONSTANT ) final Thread thread ) { return true ; }
@ Override public boolean test ( @ SuppressWarnings ( STRING_CONSTANT ) final ThreadGroup threadGroup ) { return true ; }
if ( threadGroups . isEmpty () ) { return Collections.EMPTY_LIST ; }
super ( object , style , buffer ) ;
{ super ( object , style , buffer ) ; }
{ super ( object , style ) ; }
{ super ( object ) ; }
@ Override public boolean test ( @ SuppressWarnings ( STRING_CONSTANT ) final Thread thread ) { return true ; }
@ Override public boolean test ( @ SuppressWarnings ( STRING_CONSTANT ) final ThreadGroup threadGroup ) { return true ; }
if ( threadGroups . isEmpty () ) { return Collections.EMPTY_LIST ; }
tz = tzNames . get ( value ) ;
{ regex . append ( VALID_TZ ) ; return true ; }
for ( final String textKeyValue : lKeyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
@ SuppressWarnings ( STRING_CONSTANT ) final Map < String , String > propertiesMap = ( Map ) properties ;
ISO8601TimeZoneStrategy ( String pattern ) { this . pattern = pattern ; }
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
{ this ( pattern , timeZone , locale , null , true ) ; }
final String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
final String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
final DateParser fdp = FastDateFormat . getInstance ( STRING_CONSTANT , kst , Locale.KOREA ) ;
{ return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString () ; }
assertTrue ( BooleanUtils . toBoolean ( new StringBuffer ( STRING_CONSTANT ) . append ( STRING_CONSTANT ) . toString () ) ) ;
final char newChar = Character . toUpperCase ( firstChar ) ;
{ try { throw new IOException () ; } catch ( Exception e ) { return ExceptionUtils . rethrow ( e ) ; } }
if ( length <= NUMBER_CONSTANT || index >= size ) { return STRING_CONSTANT ; }
{ return STRING_CONSTANT ; }
{ return STRING_CONSTANT ; }
if ( str == null ) { str = STRING_CONSTANT ; }
if ( str == null ) { str = STRING_CONSTANT ; }
if ( count == NUMBER_CONSTANT ) { return STRING_CONSTANT ; } else if ( count < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + count + STRING_CONSTANT ) ; }
return pattern . matcher ( decomposed ) . replaceAll ( STRING_CONSTANT ) ;
{ if ( summaryObjectEndText == null ) { summaryObjectEndText = STRING_CONSTANT ; } this . summaryObjectEndText = summaryObjectEndText ; }
{ if ( summaryObjectStartText == null ) { summaryObjectStartText = STRING_CONSTANT ; } this . summaryObjectStartText = summaryObjectStartText ; }
{ if ( sizeEndText == null ) { sizeEndText = STRING_CONSTANT ; } this . sizeEndText = sizeEndText ; }
{ if ( sizeStartText == null ) { sizeStartText = STRING_CONSTANT ; } this . sizeStartText = sizeStartText ; }
{ if ( nullText == null ) { nullText = STRING_CONSTANT ; } this . nullText = nullText ; }
{ if ( fieldSeparator == null ) { fieldSeparator = STRING_CONSTANT ; } this . fieldSeparator = fieldSeparator ; }
{ if ( fieldNameValueSeparator == null ) { fieldNameValueSeparator = STRING_CONSTANT ; } this . fieldNameValueSeparator = fieldNameValueSeparator ; }
{ if ( contentEnd == null ) { contentEnd = STRING_CONSTANT ; } this . contentEnd = contentEnd ; }
{ if ( contentStart == null ) { contentStart = STRING_CONSTANT ; } this . contentStart = contentStart ; }
{ if ( arraySeparator == null ) { arraySeparator = STRING_CONSTANT ; } this . arraySeparator = arraySeparator ; }
{ if ( arrayEnd == null ) { arrayEnd = STRING_CONSTANT ; } this . arrayEnd = arrayEnd ; }
{ if ( arrayStart == null ) { arrayStart = STRING_CONSTANT ; } this . arrayStart = arrayStart ; }
if ( locale . getCountry () . length () > NUMBER_CONSTANT ) { list . add ( new Locale ( locale . getLanguage () , STRING_CONSTANT ) ) ; }
if ( delimiters != null && delimiters.length == NUMBER_CONSTANT ) { return STRING_CONSTANT ; }
if ( th == null ) { return STRING_CONSTANT ; }
if ( pos >= count ) { addToken ( tokenList , STRING_CONSTANT ) ; }
return new StringBuilder ( annotationType == null ? STRING_CONSTANT : annotationType . getName () ) . insert ( NUMBER_CONSTANT , CHAR_CONS ) . toString () ;
{ return obj == null ? STRING_CONSTANT : obj . toString () ; }
appendDisplayNames ( definingCalendar , locale , field , regex , lKeyValues ) ;
{ return parseDateWithLeniency ( str , null , parsePatterns , false ) ; }
public TestBean ( final Object o ) { toString = STRING_CONSTANT ; }
public TestBean ( final String s ) { toString = STRING_CONSTANT ; }
public TestBean ( final double d ) { toString = STRING_CONSTANT ; }
public TestBean ( final Integer i ) { toString = STRING_CONSTANT ; }
public TestBean ( final int i ) { toString = STRING_CONSTANT ; }
public TestBean () { toString = STRING_CONSTANT ; }
{ return ( boolean [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( double [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( float [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( long [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( char [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( int [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( short [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( byte [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( T [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ assertEquals ( str , toString ) ; assertEquals ( args , varArgs ) ; }
{ return getCause ( throwable , CAUSE_METHOD_NAMES ) ; }
if ( STRING_CONSTANT . equals ( nom ) ) { return JAVA_1_8 ; } else if ( STRING_CONSTANT . equals ( nom ) ) { return JAVA_1_9 ; }
assertEquals ( STRING_CONSTANT , JAVA_1_9 , get ( STRING_CONSTANT ) ) ;
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( definingCalendar , locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
final boolean isValid = NumberUtils . isNumber ( val ) ;
if ( srcArgs.length < normalArgsLen ) return Float.MAX_VALUE ;
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
final boolean hasSign = ( firstChar == CHAR_CONS || firstChar == CHAR_CONS ) ;
final String javaVersion = System . getProperty ( STRING_CONSTANT ) ;
if ( ArrayUtils . isEmpty ( css ) ) { return true ; }
if ( ArrayUtils . isEmpty ( css ) ) { return true ; }
if ( ArrayUtils . isEmpty ( css ) ) { return true ; }
if ( ArrayUtils . isEmpty ( css ) ) { return true ; }
final Set < String > labels = new HashSet < String > () ;
final List < Object > values = new ArrayList < Object > () ;
{ contextValues . add ( new ImmutablePair < String , Object > ( label , value ) ) ; return this ; }
{ return new Range < T > ( fromInclusive , toInclusive , comparator ) ; }
final List < VetoableChangeListener > calledListeners = new ArrayList < VetoableChangeListener > () ;
{ expectedSource = source ; changedValues = new ArrayList < Boolean > () ; }
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
triple = new MutableTriple < Integer , String , Boolean > ()
final List < ThreadGroup > result = new ArrayList < ThreadGroup > ( count ) ;
final List < Thread > result = new ArrayList < Thread > ( count ) ;
final Collection < Thread > result = new ArrayList < Thread > () ;
final HashMap < Integer , String > map = new HashMap < Integer , String > () ;
{ return new ConstantFuture < T > ( value ) ; }
{ priorVariables = new ArrayList < String > () ; priorVariables . add ( new String ( chars , offset , length ) ) ; }
final Map < String , String > valueMap = new HashMap < String , String > () ;
final Map < String , E > map = new LinkedHashMap < String , E > () ;
final Map < DateParser , Integer > map = new HashMap < DateParser , Integer > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > () ;
final ArrayList < String > substrings = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > ( array.length ) ;
if ( m == null ) { REGISTRY . set ( new WeakHashMap < Object , Object > () ) ; }
countries = new ArrayList < Locale > () ;
langs = new ArrayList < Locale > () ;
final List < Locale > list = new ArrayList < Locale > ( NUMBER_CONSTANT ) ;
typeVarAssigns = new HashMap < TypeVariable < > , Type > ()
{ return new ImmutablePair < L , R > ( left , right ) ; }
final List < Field > allFieldsInteger = new ArrayList < Field > ( fieldsInteger ) ;
final Collection < String > coll = new ArrayList < String > () ;
final Collection < String > coll = new ArrayList < String > () ;
final List < String > coll = new ArrayList < String > () ;
final List < String > coll = new ArrayList < String > () ;
final Map < String , Integer > map = new HashMap < String , Integer > () ;
final Map < String , Integer > map = new HashMap < String , Integer > () ;
final Collection < Integer > coll = new ArrayList < Integer > () ;
final Collection < Integer > coll = new ArrayList < Integer > () ;
this . eventTypes = new HashSet < String > ( Arrays . asList ( eventTypes ) ) ;
final CallableBackgroundInitializer < Integer > init = new CallableBackgroundInitializer < Integer > ( call ) ;
{ new CallableBackgroundInitializer < Object > ( null ) ; }
final Set < Locale > jdkLocaleSet = new HashSet < Locale > ( jdkLocaleList ) ;
{ return new MapStrLookup < V > ( map ) ; }
pair = new MutablePair < Integer , String > ( NUMBER_CONSTANT , STRING_CONSTANT )
final MutablePair < Integer , String > pair = new MutablePair < Integer , String > () ;
final AtomicReference < InterruptedException > iex = new AtomicReference < InterruptedException > () ;
tasks = new ArrayList < Callable < Integer > > ()
List < TimeZone > timeZones = new ArrayList < TimeZone > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > frames = new ArrayList < String > () ;
final List < Throwable > list = new ArrayList < Throwable > () ;
final Set < Type > types = new HashSet < Type > ( bounds.length ) ;
final Set < > set = Collections . unmodifiableSet ( new HashSet < Object > () ) ;
final Set < > set = Collections . unmodifiableSet ( new HashSet < Object > () ) ;
final List < Class < > > list = new ArrayList < Class < > > () ;
final List < String > list = new ArrayList < String > () ;
final List < Class < > > candidateClasses = new ArrayList < Class < > > () ;
final List < String > classNames = new ArrayList < String > ( classes . size () ) ;
final List < Class < > > classes = new ArrayList < Class < > > () ;
final List < String > excludeList = new ArrayList < String > () ;
final List < String > excludeList = new ArrayList < String > () ;
final List < String > excludeList = new ArrayList < String > () ;
final List < String > tokenList = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > ( tokens.length ) ;
final MutableObject < String > obj = new MutableObject < String > ( replaceTemplate ) ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
values = new HashMap < String , String > () ;
final List < Field > annotatedFields = new ArrayList < Field > () ;
final List < Field > allFields = new ArrayList < Field > () ;
if ( registry == null ) { registry = new HashSet < IDKey > () ; REGISTRY . set ( registry ) ; }
final HashMap < T , MutableInt > occurrences = new HashMap < T , MutableInt > ( items.length ) ;
final TreeSet < T > sort = new TreeSet < T > ( comparator ) ;
final TreeSet < T > sort = new TreeSet < T > () ;
final List < Method > annotatedMethods = new ArrayList < Method > () ;
final Set < Method > result = new LinkedHashSet < Method > () ;
{ return new MutablePair < L , R > ( left , right ) ; }
final List < Object > list = new ArrayList < Object > () ;
iMap = new HashMap < Object , Object > () ;
this . diffs = new ArrayList < Diff < > > () ;
this . listeners = new CopyOnWriteArrayList < L > ( srcListeners ) ;
final ArrayList < L > serializableListeners = new ArrayList < L > () ;
{ return new EventListenerSupport < T > ( listenerInterface ) ; }
final Set < String > sorted = new TreeSet < String > ( LONGER_FIRST_LOWERCASE ) ;
{ caches [ field ] = new ConcurrentHashMap < Locale , Strategy > ( NUMBER_CONSTANT ) ; }
patterns = new ArrayList < StrategyAndWidth > () ;
tasks = new ArrayList < Callable < Integer > > ()
final HashSet < Integer > toRemove = new HashSet < Integer > () ;
final Map < String , Object > map = new HashMap < String , Object > () ;
final List < Rule > rules = new ArrayList < Rule > () ;
{ return new ImmutablePair < L , R > ( left , right ) ; }
final HashSet < Locale > testLocales = new HashSet < Locale > () ;
final HashMap < Boolean , MutableInt > occurrences = new HashMap < Boolean , MutableInt > ( NUMBER_CONSTANT ) ;
final HashMap < Double , MutableInt > occurrences = new HashMap < Double , MutableInt > ( values.length ) ;
final HashMap < Float , MutableInt > occurrences = new HashMap < Float , MutableInt > ( values.length ) ;
final HashMap < Long , MutableInt > occurrences = new HashMap < Long , MutableInt > ( values.length ) ;
final HashMap < Character , MutableInt > occurrences = new HashMap < Character , MutableInt > ( values.length ) ;
final HashMap < Integer , MutableInt > occurrences = new HashMap < Integer , MutableInt > ( values.length ) ;
final HashMap < Short , MutableInt > occurrences = new HashMap < Short , MutableInt > ( values.length ) ;
final Map < Byte , MutableInt > occurrences = new HashMap < Byte , MutableInt > ( values.length ) ;
final HashMap < T , MutableInt > occurrences = new HashMap < T , MutableInt > ( values.length ) ;
final String s = new ConstantInitializer < Object > ( null ) . toString () ;
checkEquals ( new ConstantInitializer < String > ( STRING_CONSTANT ) , false ) ;
@ Before public void setUp ( ) throws Exception { init = new ConstantInitializer < Integer > ( VALUE ) ; }
private NotVisibleException ( Throwable cause ) { this . cause = cause ; }
Boolean . . . values
PropertyChangeEvent evt
Object source
long time
class LANG1261ParentObject { @ Override public boolean equals ( Object o ) { return true ; } }
TimeZone tz
int max
StringBuilder decomposed
int maxWidth
public Customer ( String name ) { this . name = name ; }
public Bank ( String name ) { this . name = name ; }
Object object
Object object
Number . . . args
String . . . args
Number . . . args
String . . . args
public static String numOverload ( Number . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Long . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Integer . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Double . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Float . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Short . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Byte . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( String . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Object . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Number . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Long . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Integer . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Double . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Float . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Boolean . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Short . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Character . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Byte . . . args ) { return STRING_CONSTANT ; }
public int [] unboxing ( int . . . values ) { return values ; }
String valueAsString
String valueAsString
TimeZone tz
public CircuitBreakingException ( Throwable cause ) { super ( cause ) ; }
public CircuitBreakingException ( String message ) { super ( message ) ; }
String key
public FastDatePrinterTimeZonesTest ( TimeZone timeZone ) { this . timeZone = timeZone ; }
Class < ? extends Throwable > type
Throwable throwable
Throwable throwable
Throwable throwable
long nanos
int spaces
Long increment
long threshold
int len
@ Override protected long fetchCheckInterval ( EventCountCircuitBreaker breaker ) { return breaker . getClosingInterval () ; }
@ Override protected long fetchCheckInterval ( EventCountCircuitBreaker breaker ) { return breaker . getOpeningInterval () ; }
int delta
State state
State newState
int increment
Integer increment
Method method
PropertyChangeListener listener
PropertyChangeListener listener
State newState
State state
boolean allowDuplicate
FastDateParser parser
FastDateParser parser
FastDateParser parser
@ Override int modify ( FastDateParser parser , final int iValue ) { return iValue - NUMBER_CONSTANT ; }
int tokenLen
ISO8601TimeZoneStrategy ( String pattern ) { createPattern ( pattern ) ; }
FastDateParser parser
FastDateParser parser
void createPattern ( String regex ) { this . pattern = Pattern . compile ( regex ) ; }
void createPattern ( StringBuilder regex ) { createPattern ( regex . toString () ) ; }
char c
char c
ListIterator < StrategyAndWidth > lt
SystemDefaults defaults
SystemDefaults defaults
int . . . args
String . . . s
Calendar calendar
Calendar calendar
int tokenLen
int value
Object obj
Constructor < > constructor
Method method
private static Executable of ( Constructor < > constructor ) { return new Executable ( constructor ) ; }
private static Executable of ( Method method ) { return new Executable ( method ) ; }
boolean [] array
char [] array
byte [] array
short [] array
long [] array
int [] array
int offset
int offset
int offset
int offset
int offset
int offset
int offset
int offset
int offset
{ int last = value ; this . value += operand . intValue () ; return last ; }
{ int last = value ; this . value += operand ; return last ; }
{ int last = value ; value -- ; return last ; }
{ int last = value ; value ++ ; return last ; }
{ double last = value ; this . value += operand . doubleValue () ; return last ; }
{ double last = value ; this . value += operand ; return last ; }
{ double last = value ; value -- ; return last ; }
{ double last = value ; value ++ ; return last ; }
{ StopWatch sw = new StopWatch () ; sw . start () ; return sw ; }
catch ( UnsupportedOperationException e ) {}
catch ( UnsupportedOperationException e ) {}
catch ( UnsupportedOperationException e ) {}
int result = mutNum . getAndDecrement () ;
int result = mutNum . decrementAndGet () ;
int result = mutNum . getAndIncrement () ;
int result = mutNum . incrementAndGet () ;
{ long last = value ; this . value += operand . longValue () ; return last ; }
{ long last = value ; this . value += operand ; return last ; }
{ long last = value ; value -- ; return last ; }
{ long last = value ; value ++ ; return last ; }
Exception ex
double result = mutableDouble . addAndGet ( - NUMBER_CONSTANT ) ;
double result = mutableDouble . getAndAdd ( NUMBER_CONSTANT ) ;
double result = mutNum . getAndDecrement () ;
double result = mutNum . decrementAndGet () ;
double result = mutNum . getAndIncrement () ;
double result = mutNum . incrementAndGet () ;
Calendar calendar = Calendar . getInstance () ;
DateParser parser = getInstance ( YMD_SLASH ) ;
Calendar cal = Calendar . getInstance ( tz ) ;
for ( CharSequence searchCharSequence : searchCharSequences ) { if ( contains ( cs , searchCharSequence ) ) { return true ; } }
{ for ( CharSequence next : searchStrings ) { if ( equalsIgnoreCase ( string , next ) ) { return true ; } } }
{ for ( CharSequence next : searchStrings ) { if ( equals ( string , next ) ) { return true ; } } }
{ double balance = NUMBER_CONSTANT ; for ( Transaction tx : transactions ) { balance += tx.amount ; } return balance ; }
{ String date = STRING_CONSTANT ; DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT . parse ( date ) ; }
Calendar calendar = Calendar . getInstance () ;
Calendar cal = Calendar . getInstance ( SWEDEN ) ;
Calendar cal = Calendar . getInstance ( tz ) ;
catch ( InterruptedException iex ) {}
Pattern patternToWrapOn = Pattern . compile ( wrapOn ) ;
{ try { return System . getProperty ( key ) ; } catch ( SecurityException scex ) {} }
StringBuilder sb = new StringBuilder () ;
ExecutorService exec = Executors . newSingleThreadExecutor () ;
long result = mutNum . getAndDecrement () ;
long result = mutNum . decrementAndGet () ;
long result = mutNum . getAndIncrement () ;
long result = mutNum . incrementAndGet () ;
catch ( IllegalAccessException e ) { return null ; }
int lastHold = start ;
StringBuilder sb = new StringBuilder () ;
TimeZone utc = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
long randomResult = RandomUtils . nextLong () ;
float randomResult = RandomUtils . nextFloat () ;
double randomResult = RandomUtils . nextDouble () ;
int randomResult = RandomUtils . nextInt () ;
byte result = mutNum . getAndDecrement () ;
byte result = mutNum . decrementAndGet () ;
byte result = mutNum . getAndIncrement () ;
byte result = mutNum . incrementAndGet () ;
short result = mutNum . getAndDecrement () ;
short result = mutNum . decrementAndGet () ;
short result = mutNum . getAndIncrement () ;
short result = mutNum . incrementAndGet () ;
{ StateStrategy strategy = STRATEGY_MAP . get ( state ) ; return strategy ; }
long time = now () ;
StringBuilder sb = new StringBuilder ( NUMBER_CONSTANT ) ;
Format fdf = FastDateFormat . getInstance ( pattern ) ;
ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
{ ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( zeroThreshold ) ; assertTrue ( STRING_CONSTANT , circuit . incrementAndCheckState ( NUMBER_CONSTANT ) ) ; }
ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
float result = mutableFloat . addAndGet ( NUMBER_CONSTANT ) ;
float result = mutableFloat . getAndAdd ( NUMBER_CONSTANT ) ;
float result = mutNum . getAndDecrement () ;
float result = mutNum . decrementAndGet () ;
float result = mutNum . getAndIncrement () ;
float result = mutNum . incrementAndGet () ;
{ byte last = value ; this . value += operand . byteValue () ; return last ; }
{ byte last = value ; this . value += operand ; return last ; }
{ byte last = value ; value -- ; return last ; }
{ byte last = value ; value ++ ; return last ; }
Diff < > diff
StringBuilder regex = new StringBuilder () ;
int sIdx = idx + pos . getIndex () ;
char c = value . charAt ( i ) ;
ParsePosition pp = new ParsePosition ( NUMBER_CONSTANT ) ;
char c = pattern . charAt ( currentIdx ) ;
Calendar cal = Calendar . getInstance () ;
Locale save = Locale . getDefault () ;
TimeZone save = TimeZone . getDefault () ;
catch ( Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; }
catch ( Exception e ) { return ExceptionUtils . < Boolean > rethrow ( e ) ; }
int value = calendar . get ( Calendar.DAY_OF_WEEK ) ;
catch ( IOException ioe ) { ExceptionUtils . rethrow ( ioe ) ; }
{ short last = value ; this . value += operand . shortValue () ; return last ; }
{ short last = value ; this . value += operand ; return last ; }
{ short last = value ; value -- ; return last ; }
{ short last = value ; value ++ ; return last ; }
{ float last = value ; this . value += operand . floatValue () ; return last ; }
{ float last = value ; this . value += operand ; return last ; }
{ float last = value ; value -- ; return last ; }
{ float last = value ; value ++ ; return last ; }
catch ( Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , TestThrowable . class ) ) ; }
catch ( Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , IOException . class ) ) ; }
catch ( Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , RuntimeException . class ) ) ; }
catch ( Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , Error . class ) ) ; }
try { throw new IOException () ; } catch ( Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; }
int [] clonedIndices = clone ( indices ) ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
short aux = array [ offset1 ] ;
Object aux = array [ offset1 ] ;
long aux = array [ offset1 ] ;
int aux = array [ offset1 ] ;
float aux = array [ offset1 ] ;
double aux = array [ offset1 ] ;
char aux = array [ offset1 ] ;
byte aux = array [ offset1 ] ;
boolean aux = array [ offset1 ] ;
String encoding = STRING_CONSTANT ;
String methodStr = m . toString () ;
methodName . equals ( method . getName () ) && ArrayUtils . isEquals ( parameterTypes , method . getParameterTypes () )
Memoizer < Integer , Integer > memoizer = new Memoizer < Integer , Integer > ( computable ) ;
Memoizer < Integer , Integer > memoizer = new Memoizer < Integer , Integer > ( computable ) ;
Memoizer < Integer , Integer > memoizer = new Memoizer < Integer , Integer > ( computable ) ;
if ( ! isEquals ) return this ;
final StrategyParser fm = new StrategyParser ( pattern , definingCalendar ) ;
public void setCycle ( TestRecursiveCycleObject cycle ) { this . cycle = cycle ; }
public TestRecursiveCycleObject ( int n ) { this . n = n ; this . cycle = this ; }
public TestRecursiveInnerObject ( int n ) { this . n = n ; }
int offset
boolean testRecursive
String . . . excludeFields
Class < > reflectUpToClass
boolean testRecursive
boolean testTransients
final Locale [] availableLocales = ChoiceFormat . getAvailableLocales () ;
{ mRule . appendTo ( buffer , CalendarReflection . getWeekYear ( calendar ) ) ; }
if ( b . compareTo ( BigDecimal . valueOf ( d ) ) == NUMBER_CONSTANT ) { return d ; }
{ spaceToWrapAt = matcher . start () ; }
@ SuppressWarnings ( STRING_CONSTANT ) final String [] sa = ArrayUtils . add ( stringArray , NUMBER_CONSTANT , aString ) ;
final T . . . array
assertPatternsEqual ( STRING_CONSTANT + locale , expectedPattern , emf . toPattern () ) ;
assertPatternsEqual ( STRING_CONSTANT , pattern , emf . toPattern () ) ;
{ if ( newLine == null ) { append ( SystemUtils.LINE_SEPARATOR ) ; return this ; } return append ( newLine ) ; }
{ assertEquals ( baseStr + STRING_CONSTANT + SystemUtils.LINE_SEPARATOR + STRING_CONSTANT , new ToStringBuilder ( base ) . toString () ) ; }
if ( newLineStr == null ) { newLineStr = SystemUtils.LINE_SEPARATOR ; }
final String systemNewLine = SystemUtils.LINE_SEPARATOR ;
final String systemNewLine = SystemUtils.LINE_SEPARATOR ;
final String linebreak = SystemUtils.LINE_SEPARATOR ;
final String linebreak = SystemUtils.LINE_SEPARATOR ;
{ if ( fieldName == null ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; } super . appendFieldStart ( buffer , FIELD_NAME_PREFIX + fieldName + FIELD_NAME_PREFIX ) ; }
assertFalse ( CharUtils . isAscii ( CHAR_COPY ) ) ;
intRange = Range . between ( ( int ) NUMBER_CONSTANT , ( int ) NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( ( int ) NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( ( int ) NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( ( int ) NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( ( int ) NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( ( float ) NUMBER_CONSTANT ) . toHashCode () ) ;
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( ( double ) NUMBER_CONSTANT ) . toHashCode () ) ;
assertNull ( LocaleUtils . toLocale ( ( String ) null ) ) ;
sb . replace ( NUMBER_CONSTANT , NUMBER_CONSTANT , ( String ) null ) ;
sb . setNullText ( ( String ) null ) ;
sb . setNewLineText ( ( String ) null ) ;
final StrBuilder sb5 = new StrBuilder ( ( String ) null ) ;
final GenericDeclaration d = ( ( TypeVariable < > ) var ) . getGenericDeclaration () ;
assertEquals ( STRING_CONSTANT , ClassUtils . getSimpleName ( ( Class < > ) null ) ) ;
assertEquals ( STRING_CONSTANT , BooleanUtils . toString ( ( Boolean ) null , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEquals ( null , BooleanUtils . toStringYesNo ( ( Boolean ) null ) ) ;
assertEquals ( null , BooleanUtils . toStringOnOff ( ( Boolean ) null ) ) ;
assertEquals ( null , BooleanUtils . toStringTrueFalse ( ( Boolean ) null ) ) ;
assertEquals ( null , BooleanUtils . toIntegerObject ( ( Boolean ) null ) ) ;
assertTrue ( BooleanUtils . isNotFalse ( ( Boolean ) null ) ) ;
assertFalse ( BooleanUtils . isFalse ( ( Boolean ) null ) ) ;
assertTrue ( BooleanUtils . isNotTrue ( ( Boolean ) null ) ) ;
assertFalse ( BooleanUtils . isTrue ( ( Boolean ) null ) ) ;
assertSame ( StrMatcher . noneMatcher () , StrMatcher . stringMatcher ( ( String ) null ) ) ;
assertEquals ( BAR , ObjectUtils . toString ( ( Object ) null , BAR ) ) ;
assertEquals ( STRING_CONSTANT , ObjectUtils . toString ( ( Object ) null ) ) ;
{ DateUtils . isSameLocalTime ( Calendar . getInstance () , ( Calendar ) null ) ; }
{ DateUtils . isSameLocalTime ( ( Calendar ) null , Calendar . getInstance () ) ; }
{ DateUtils . isSameInstant ( Calendar . getInstance () , ( Calendar ) null ) ; }
{ DateUtils . isSameInstant ( ( Calendar ) null , Calendar . getInstance () ) ; }
{ DateUtils . isSameInstant ( new Date () , ( Date ) null ) ; }
{ DateUtils . isSameInstant ( ( Date ) null , new Date () ) ; }
{ DateUtils . isSameDay ( Calendar . getInstance () , ( Calendar ) null ) ; }
{ DateUtils . isSameDay ( ( Calendar ) null , Calendar . getInstance () ) ; }
{ DateUtils . isSameDay ( new Date () , ( Date ) null ) ; }
{ DateUtils . isSameDay ( ( Date ) null , new Date () ) ; }
array = ArrayUtils . removeElement ( ( boolean [] ) null , true ) ;
array = ArrayUtils . removeElement ( ( Object [] ) null , STRING_CONSTANT ) ;
assertSame ( ( ( ExceptionWithCause ) cyclicCause . getCause () ) . getCause () , throwables . get ( NUMBER_CONSTANT ) ) ;
assertSame ( ( ( ExceptionWithCause ) cyclicCause . getCause () ) . getCause () , throwables [ NUMBER_CONSTANT ] ) ;
assertSame ( ( ( ExceptionWithCause ) cyclicCause . getCause () ) . getCause () , ExceptionUtils . getRootCause ( cyclicCause ) ) ;
{ if ( value <= start || value >= end ) { throw new IllegalArgumentException ( String . format ( message ) ) ; } }
{ if ( value <= start || value >= end ) { throw new IllegalArgumentException ( String . format ( message ) ) ; } }
{ if ( value < start || value > end ) { throw new IllegalArgumentException ( String . format ( message ) ) ; } }
{ if ( value < start || value > end ) { throw new IllegalArgumentException ( String . format ( message ) ) ; } }
longRange = Range . between ( ( long ) NUMBER_CONSTANT , ( long ) NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( ( long ) NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( ( long ) NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( ( long ) NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( ( long ) NUMBER_CONSTANT ) ;
{ Assert . assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , NUMBER_CONSTANT ) ) ; }
{ Assert . assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , - NUMBER_CONSTANT ) ) ; }
return parseLocale ( str , len ) ;
classes . add ( cls ) ;
assertTrue ( trace . indexOf ( TEST_MESSAGE ) >= NUMBER_CONSTANT ) ;
assertTrue ( trace . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ;
assertTrue ( trace . indexOf ( TEST_MESSAGE ) >= NUMBER_CONSTANT ) ;
assertTrue ( trace . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ;
assertTrue ( ! contextMessage . contains ( TEST_MESSAGE ) ) ;
assertTrue ( ! stackTrace . contains ( ExceptionUtils.WRAPPED_MARKER ) ) ;
assertTrue ( ! stackTrace . contains ( ExceptionUtils.WRAPPED_MARKER ) ) ;
final HashSet < Integer > toRemove = new HashSet < Integer > () ;
super . appendDetail ( buffer , fieldName , array ) ;
final List < Object > list = new ArrayList <> () ;
public TestEmptySubObject ( final int a ) { super ( a ) ; }
public TestSubObject () { super ( NUMBER_CONSTANT ) ; }
public static String getFieldName () { return STRING_CONSTANT ; }
public TestSubObject () { super ( NUMBER_CONSTANT ) ; }
{ Validate . noNullElements ( values ) ; return generateBitVector ( enumClass , Arrays . < E > asList ( values ) ) ; }
public TestSubObject () { super ( NUMBER_CONSTANT ) ; }
final List < String > strColl = Arrays . asList ( new String [] { STRING_CONSTANT } ) ;
final List < String > strColl = Arrays . asList ( new String [] { STRING_CONSTANT } ) ;
public BackgroundInitializerTestImpl () { super(); }
{ return options == null ? false : options . contains ( option ) ; }
{ return TypeUtils . < T > wrap ( ( Type ) type ) ; }
if ( typeArguments == null ) { typeArguments = Collections . < TypeVariable < > , Type > emptyMap () ; }
assertSame ( StrMatcher . noneMatcher () , StrMatcher . charSetMatcher ( new char [ NUMBER_CONSTANT ] ) ) ;
assertNull ( ObjectUtils . firstNonNull ( new Object [ NUMBER_CONSTANT ] ) ) ;
public void event2 ( PropertyChangeEvent e ) ;
public void event1 ( PropertyChangeEvent e ) ;
public SelfInstanceTwoVarsReflectionTestFixture () { this . typeIsSelf = this ; }
public SelfInstanceVarReflectionTestFixture () { this . typeIsSelf = this ; }
{ Validate . isTrue ( objectData != null , STRING_CONSTANT ) ; return SerializationUtils . < T > deserialize ( new ByteArrayInputStream ( objectData ) ) ; }
@ SuppressWarnings ( STRING_CONSTANT ) public NestableException () { super(); }
assertTrue ( StringUtils . containsOnly ( str , new char [] { CHAR_CONS } ) ) ;
assertTrue ( StringUtils . containsOnly ( str , new char [] { CHAR_CONS } ) ) ;
assertTrue ( StringUtils . containsOnly ( str , new char [] { CHAR_CONS } ) ) ;
final List < Object > list = new ArrayList <> ( NUMBER_CONSTANT ) ;
final List < Object > list = new ArrayList <> ( arraylistInitialCapacity ) ;
final List < Object > list = new ArrayList <> () ;
for ( int i = oldEnd ; i < newEnd ; i ++ ) { buffer [ i ] = CHAR_CONS ; }
if ( isEmpty ( str ) || wrapChar == CHAR_CONS ) { return str ; }
if ( isEmpty ( str ) || wrapWith == CHAR_CONS ) { return str ; }
{ if ( isEmpty ( str ) || wrapWith == CHAR_CONS ) { return str ; } return wrapWith + str + wrapWith ; }
assertNull ( StringUtils . unwrap ( null , CHAR_CONS ) ) ;
{ if ( expression == false ) { throw new IllegalStateException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( DEFAULT_IS_TRUE_EX_MESSAGE ) ; } }
if ( obj instanceof Fraction == false ) { return false ; }
if ( obj instanceof FastDateFormat == false ) { return false ; }
if ( toClass . isPrimitive () == false ) { return false ; }
{ if ( isAsciiNumeric ( ch ) == false ) { return defaultValue ; } return ch - NUMBER_CONSTANT ; }
{ return ObjectUtils . equals ( object1 , object2 ) == false ; }
if ( obj instanceof TypeLiteral == false ) { return false ; }
if ( obj instanceof CharSet == false ) { return false ; }
public boolean isFalse () { return value == false ; }
public boolean isTrue () { return value == true ; }
if ( obj instanceof FastDatePrinter == false ) { return false ; }
final I arg
final Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeft () , pair . getRight () ) ;
if ( hasNext == false ) { throw new NoSuchElementException () ; }
if ( obj instanceof CharRange == false ) { return false ; }
try { CharUtils . toIntValue ( CHAR_CONS ) ; } catch ( final IllegalArgumentException ex ) {}
if ( tzId . equalsIgnoreCase ( STRING_CONSTANT ) ) { continue; }
{ cal . setTimeZone ( TimeZone . getTimeZone ( STRING_CONSTANT + value ) ) ; }
{ cal . setTimeZone ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
{ return toAppendTo . append ( ( ( String ) obj ) . toUpperCase () ) ; }
expected . append ( args [ NUMBER_CONSTANT ] . toString () . toUpperCase () ) ;
assertFalse ( StringUtils . equalsAny ( FOO , FOO . toUpperCase () ) ) ;
{ return toAppendTo . append ( ( ( String ) obj ) . toLowerCase () ) ; }
timeZone = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
{ final TimeZone timeZone = TimeZone . getTimeZone ( STRING_CONSTANT ) ; assertFormats ( expectedValue , pattern , timeZone , createFebruaryTestDate ( timeZone ) ) ; }
final Calendar c = Calendar . getInstance ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
final Calendar c = Calendar . getInstance ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
final Calendar c = Calendar . getInstance ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
final Calendar c = Calendar . getInstance ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
TimeZone . setDefault ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
final TimeZone utc = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
final TimeZone utc = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( l , Double.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( l , Float.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( l , Long.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
{ final Integer [] iArray = null ; assertEquals ( null , ArrayUtils . toPrimitive ( iArray , Integer.MIN_VALUE ) ) ; }
assertEquals ( null , ArrayUtils . toPrimitive ( l , Integer.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( s , Short.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b , Byte.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b , Character.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( null , false ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , ArrayUtils . toMap ( null ) ) ;
assertEquals ( null , StringUtils . strip ( null ) ) ;
assertEquals ( null , StringUtils . trim ( null ) ) ;
assertEquals ( null , StringUtils . substring ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , tok . getContent () ) ;
assertEquals ( null , tokenizer . nextToken () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , StringEscapeUtils . unescapeJson ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeJson ( null ) ) ;
assertEquals ( null , StringEscapeUtils . unescapeCsv ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeCsv ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeEcmaScript ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeEcmaScript ( null ) ) ;
assertEquals ( null , StringEscapeUtils . unescapeJava ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeJava ( null ) ) ;
assertEquals ( null , WordUtils . swapCase ( null ) ) ;
assertEquals ( null , WordUtils . initials ( null ) ) ;
assertEquals ( null , WordUtils . uncapitalize ( null , null ) ) ;
assertEquals ( null , WordUtils . uncapitalize ( null ) ) ;
assertEquals ( null , WordUtils . capitalizeFully ( null , null ) ) ;
assertEquals ( null , WordUtils . capitalizeFully ( null ) ) ;
assertEquals ( null , WordUtils . capitalize ( null , null ) ) ;
assertEquals ( null , WordUtils . capitalize ( null ) ) ;
{ assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , NUMBER_CONSTANT ) ) ; }
{ assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , - NUMBER_CONSTANT ) ) ; }
assertEquals ( null , ClassUtils . getAllInterfaces ( null ) ) ;
assertEquals ( null , ClassUtils . getAllSuperclasses ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringYesNo ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringOnOff ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringTrueFalse ( null ) ) ;
assertEquals ( null , BooleanUtils . toBooleanObject ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEquals ( null , BooleanUtils . toIntegerObject ( null , six , seven , null ) ) ;
assertEquals ( null , BooleanUtils . toIntegerObject ( null ) ) ;
assertEquals ( null , BooleanUtils . toBooleanObject ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
assertEquals ( null , BooleanUtils . toBooleanObject ( ( Integer ) null ) ) ;
assertEquals ( null , ObjectUtils . identityToString ( null ) ) ;
{ assertEquals ( null , CharUtils . unicodeEscaped ( null ) ) ; assertEquals ( STRING_CONSTANT , CharUtils . unicodeEscaped ( CHARACTER_A ) ) ; }
assertEquals ( null , CharUtils . toString ( null ) ) ;
assertEquals ( null , new MutableObject <> () . getValue () ) ;
assertEquals ( null , StringUtils . getDigits ( null ) ) ;
assertEquals ( null , StringUtils . wrap ( null , null ) ) ;
assertEquals ( null , StringUtils . rotate ( null , NUMBER_CONSTANT ) ) ;
Assert . assertNotEquals ( summer . getTime () , standard . getTime () ) ;
Assert . assertEquals ( cal . getTime () , date ) ;
@ Test public void testInvokeMethodForceAccessNoArgs ( ) throws Exception { Assert . assertEquals ( STRING_CONSTANT , MethodUtils . invokeMethod ( testBean , true , STRING_CONSTANT ) ) ; }
Assert . assertEquals ( STRING_CONSTANT , TypeUtils . toString ( method . getGenericReturnType () ) ) ;
Assert . assertTrue ( TypeUtils . isAssignable ( fromType , failingToType ) ) ;
Assert . assertArrayEquals ( expectedArray , TypeUtils . normalizeUpperBounds ( typeArray ) ) ;
@ Test public void testUTC () { Assert . assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testZ () { Assert . assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testBareGmt () { Assert . assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testGetGmtTimeZone () { Assert . assertEquals ( NUMBER_CONSTANT , FastTimeZone . getGmtTimeZone () . getRawOffset () ) ; }
{ Assert . assertEquals ( REPEAT , future . get () . intValue () ) ; }
{ watch . getStartTime () ; Assert . assertTrue ( watch . getStartTime () >= beforeStopWatch ) ; }
{ Assert . assertTrue ( toString . indexOf ( SECRET_VALUE ) > NUMBER_CONSTANT ) ; this . validateNonSecretField ( toString ) ; }
{ Assert . assertEquals ( ArrayUtils.INDEX_NOT_FOUND , toString . indexOf ( SECRET_VALUE ) ) ; this . validateNonSecretField ( toString ) ; }
Assert . assertEquals ( expected , hostName ) ;
Assert . assertEquals ( value , SerializationUtils . deserialize ( serialized ) ) ;
Assert . assertEquals ( isoForm , printer . format ( vulgar ) ) ;
Assert . assertEquals ( vulgar . getTime () , cal . getTime () ) ;
ReflectionToStringBuilder oldBuilder = new ReflectionToStringBuilder ( BOTH_NULL ) ;
String value
StringBuilder builder = new StringBuilder ( count ) ;
String group
String group
CharSequence cs
boolean excludeNullValues
catch ( NoSuchMethodException expected ) {}
CharRange a = CharRange . is ( CHAR_CONS ) ;
T object
for ( char chr : chrs ) { if ( chars . contains ( chr ) == expect ) { buffer . append ( chr ) ; } }
{ boolean result = RandomUtils . nextBoolean () ; assertTrue ( result == true || result == false ) ; }
Object other
@ Override public boolean inDaylightTime ( Date date ) { return false ; }
@ Override public void setRawOffset ( int offsetMillis ) { throw new UnsupportedOperationException () ; }
Class < > anInterface
{ super(); for ( String s : set ) { add ( s ) ; } }
TimeZone tz = FastTimeZone . getGmtTimeZone ( timeZone ) ;
String . . . s
double [] array
float [] array
long [] array
int [] array
short [] array
char [] array
byte [] array
boolean [] array
Object [] array
{ list . add ( throwable ) ; throwable = ExceptionUtils . getCause ( throwable ) ; }
assertTrue ( STRING_CONSTANT , delta < NUMBER_CONSTANT ) ;
{ return performStateCheck ( NUMBER_CONSTANT ) ; }
this . typeArguments = typeArguments . clone () ;
daemonFlag = null ;
{ daemonFlag = Boolean . valueOf ( f ) ; return this ; }
daemonFlag = builder.daemonFlag ;
public final Boolean getDaemonFlag () { return daemonFlag ; }
daemonFlag = builder.daemon ;
{ return valueAsString . startsWith ( getArrayStart () ) && valueAsString . startsWith ( getArrayEnd () ) ; }
{ return str == null ? EMPTY : str ; }
final String sanitizedSeparator = defaultString ( separator , StringUtils.EMPTY ) ;
if ( str == null || suffix == null ) { return str == null && suffix == null ; }
if ( str == null || prefix == null ) { return str == null && prefix == null ; }
{ bypassReflectionClasses = new ArrayList < Class < > > () ; bypassReflectionClasses . add ( String . class ) ; }
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
for ( Field field : allFields ) { if ( field . getName () . equals ( STRING_CONSTANT ) ) { expected ++ ; } }
for ( Field field : allFields ) { if ( field . getName () . equals ( STRING_CONSTANT ) ) { expected ++ ; } }
{ buffer . append ( CHAR_CONS ) . append ( value ) . append ( CHAR_CONS ) ; }
super . appendFieldStart ( buffer , FIELD_NAME_QUOTE + fieldName + FIELD_NAME_QUOTE ) ;
if ( ! iterator . hasNext () ) { return Objects . toString ( first , STRING_CONSTANT ) ; }
final StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
int [] indexesToRemove = new int [] {} ;
return str . length () > NUMBER_CONSTANT ;
if ( diffs . size () == NUMBER_CONSTANT ) { return OBJECTS_SAME_STRING ; }
Validate . notNull ( chars ) ;
Validate . notNull ( collection ) ;
Validate . notNull ( array ) ;
Validate . notNull ( iterable ) ;
Validate . notNull ( array ) ;
{ return SystemUtils.IS_OS_WINDOWS ? System . getenv ( STRING_CONSTANT ) : System . getenv ( STRING_CONSTANT ) ; }
return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ;
return StrSubstitutor . replace ( source , valueMap ) ;
if ( StringUtils . isEmpty ( str ) ) { return str ; }
{ return replaceFirst ( text , regex , StringUtils.EMPTY ) ; }
return pattern . matcher ( decomposed ) . replaceAll ( StringUtils.EMPTY ) ;
private Object readResolve () { return ToStringStyle.JSON_STYLE ; }
private Object readResolve () { return ToStringStyle.NO_CLASS_NAME_STYLE ; }
private Object readResolve () { return ToStringStyle.MULTI_LINE_STYLE ; }
private Object readResolve () { return ToStringStyle.SIMPLE_STYLE ; }
private Object readResolve () { return ToStringStyle.SHORT_PREFIX_STYLE ; }
private Object readResolve () { return ToStringStyle.NO_FIELD_NAMES_STYLE ; }
private Object readResolve () { return ToStringStyle.DEFAULT_STYLE ; }
Throwable root = ExceptionUtils . getRootCause ( th ) ;
final Throwable [] throwables = ExceptionUtils . getThrowables ( throwable ) ;
{ return TypeUtils . wrap ( ( Type ) type ) ; }
{ Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , STRING_CONSTANT , owner , raw ) ; useOwner = owner ; }
{ parameterizedTypeArguments = new HashMap <> ( typeArguments ) ; parameterizedTypeArguments . putAll ( TypeUtils . getTypeArguments ( p ) ) ; }
{ return ClassUtils . getPackageName ( getCanonicalName ( canonicalName ) ) ; }
{ return ClassUtils . getShortClassName ( getCanonicalName ( canonicalName ) ) ; }
private Object readResolve () { return ObjectUtils.NULL ; }
{ final int tmpHash = ObjectUtils . hashCode ( object ) ; hash = hash * NUMBER_CONSTANT + tmpHash ; }
{ return ! ObjectUtils . equals ( object1 , object2 ) ; }
{ Validate . isTrue ( objectData != null , STRING_CONSTANT ) ; return SerializationUtils . deserialize ( new ByteArrayInputStream ( objectData ) ) ; }
{ return ( T ) SerializationUtils . deserialize ( SerializationUtils . serialize ( msg ) ) ; }
{ return MemberUtils . isMatchingExecutable ( Executable . of ( method ) , parameterTypes ) ; }
{ return MemberUtils . isMatchingExecutable ( Executable . of ( method ) , parameterTypes ) ; }
final int srcLength = ArrayUtils . getLength ( array ) ;
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
{ _mask = mask ; _shift_count = mask != NUMBER_CONSTANT ? Integer . numberOfTrailingZeros ( mask ) : NUMBER_CONSTANT ; }
{ return iValue != NUMBER_CONSTANT ? iValue + NUMBER_CONSTANT : Calendar.SUNDAY ; }
mRule . appendTo ( buffer , value != Calendar.SUNDAY ? value - NUMBER_CONSTANT : NUMBER_CONSTANT ) ;
if ( lhs ) { comparison = + NUMBER_CONSTANT ; } else { comparison = - NUMBER_CONSTANT ; }
if ( rhs == null ) { comparison = + NUMBER_CONSTANT ; return this ; }
