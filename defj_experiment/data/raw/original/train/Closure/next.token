expr . setLineno ( expr . getLineno () + templateLineno ) ;
if ( definitionNodes . contains ( useSite ) ) { return null ; }
FeatureSet features = ast . getFeatures ( compiler ) ;
if ( tags == FALSY_MASK ) { return builder . append ( STRING_CONSTANT ) ; } else { return builder . append ( STRING_CONSTANT ) . append ( tags ) ; }
output.compiledCode = writeOutput ( compiler , flags.outputWrapper ) ;
options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.OFF ) ;
resultPair = analyzeCastFwd ( expr , inEnv , specializedType ) ;
options . setWarningLevel ( DiagnosticGroups.MISSING_PROVIDE , CheckLevel.WARNING ) ;
resultPair = analyzeCastFwd ( expr , inEnv ) ;
resultPair = analyzeCastFwd ( expr , inEnv , specializedType ) ;
public void testEs6ONoEs6 () { allowExternsChanges ( true ) ; testSame ( STRING_CONSTANT ) ; }
options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.OFF ) ;
public final Node getNext () { return next ; }
public final Token getToken () { return token ; }
if ( type == null && isConstant ) { type = this . commonTypes . UNKNOWN ; }
return scope . getCommonTypes () . UNKNOWN ;
@ Deprecated public AssertionFunctionSpec ( String functionName ) { this ( functionName , null ) ; }
this . commonTypes . STRING . isSubtypeOf ( this ) && this . commonTypes . getNumberInstance () . mayHaveProp ( pname )
if ( type == null && isConstant ) { type = this . commonTypes . UNKNOWN ; }
if ( isUnknown () ) { return this . commonTypes . UNKNOWN ; }
if ( isBottom () || isUnknown () || hasTruthyMask () ) { return this . commonTypes . UNKNOWN ; }
if ( this . isUnknown () ) { return this . commonTypes . TRUTHY ; }
{ globalThisType = this . commonTypes . TOP_OBJECT . withLoose () ; }
{ Preconditions . checkState ( function . isFunction () ) ; expandedDefinitions . add ( functionSideEffectMap . get ( function ) ) ; }
n . hasOneChild () && t . inGlobalScope ()
if ( varNode . hasMoreThanOneChild () && varType != null ) { warnings . add ( JSError . make ( varNode , ONE_TYPE_FOR_MANY_VARS ) ) ; }
n . hasOneChild () && parent == googScopeBlock
initializer . isVar () && initializer . hasOneChild ()
if ( n . hasOneChild () && NodeUtil . isStatement ( n ) ) { processName ( n . getFirstChild () , n ) ; }
if ( ! currentStatement . hasChildren () ) { return; }
typeNode != null && typeNode . isString ()
if ( inputId == null ) { setInputId ( NodeUtil . getInputId ( node ) , getSourceName ( node ) ) ; }
if ( inputId == null ) { setInputId ( NodeUtil . getInputId ( node ) , getSourceName ( node ) ) ; }
String name = getQualifiedName ( node ) ;
options.rewritePolyfills = flags.rewritePolyfills && options . getLanguageIn () . isEs6OrHigher () ;
JSType t = getTypeFromComment ( jsdoc , registry , typeParameters ) ;
builder . append ( paramType . toNonNullString ( forAnnotations ) ) . append ( STRING_CONSTANT ) ;
builder . append ( STRING_CONSTANT ) . append ( paramType . toNonNullString ( forAnnotations ) ) ;
{ b . append ( p . getJSType () . toNonNullString ( forAnnotations ) ) ; }
b . append ( call.returnType . toNonNullString ( forAnnotations ) ) ;
sb . append ( getPropertyType ( property ) . toNonNullString ( forAnnotations ) ) ;
if ( n . isFromExterns () ) { this . recordPropertyName . apply ( propName ) ; }
recordPropertyName ( getProp . getLastChild () . getString () , getProp ) ;
if ( NodeUtil . isPropertyTest ( compiler , n ) || isPropertyAbsentTest ( n ) ) { recordPropertyName ( n . getLastChild () . getString () , n ) ; }
recordPropertyName ( pname , qnameNode ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
compiler . getOptions () . setUseTypesForLocalOptimization ( true ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
if ( ! allDefinitionsEquivalent ( singleSiteDefinitions ) ) { return false ; }
NodeTraversal . traverseChangedFunctions ( compiler , new FunctionVisitor ( blacklistedPropNames ) ) ;
@ Override void endCaseBody () { super . endCaseBody () ; indent -- ; }
assertThat ( compiler . getErrors () ) . isEmpty () ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
options . setLanguage ( LanguageMode.ECMASCRIPT8 ) ;
JSType objectWithBadKey = findObjectWithNonStringifiableKey ( realType , new HashSet < JSType > () ) ;
Config config = findMatching ( name , n . getSourceFileName () ) ;
if ( currentScript.defaultExportLocalName != null ) { assignNode . getParent () . detach () ; return; }
boolean nameIsExported = name . equals ( currentScript.defaultExportLocalName ) ;
public J2clCheckPassTest () { super ( DEFAULT_EXTERNS ) ; enableTypeCheck () ; }
TypeI jsType
TypeI jsType
void setMask ( int mask ) { bitmask |= mask ; }
if ( info . isNoSideEffects () ) {} else { sideEffectInfo . setTaintsGlobalState () ; }
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
( config.parseTypeSyntax && peek ( TokenType.OPEN_PAREN ) ) || peek ( TokenType.OPEN_ANGLE )
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
JSDocInfo info = NodeUtil . getBestJSDocInfo ( node ) ;
FunctionInformation sideEffectInfo = new FunctionInformation () ;
FunctionInformation representativeNode = new FunctionInformation () ;
if ( modulePath == null ) { t . makeError ( typeNode , COMMON_JS_MODULE_LOAD_ERROR , moduleName ) ; return; }
if ( modulePath == null ) { compiler . report ( t . makeError ( require , COMMON_JS_MODULE_LOAD_ERROR , requireName ) ) ; return; }
assertPasses ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String treeDiff = node . checkTreeEquals ( actual () ) ;
public ImmutableMap < String , Stats > getStats () { calcTotalStats () ; return this . summary ; }
maybeWarnForInvalidDestructuring ( t , lhs . getParent () , legacyNamespace ) ;
{ options . setWarningLevel ( DiagnosticGroups.MISSING_OVERRIDE , value ? CheckLevel.WARNING : CheckLevel.OFF ) ; }
this . output . print ( Joiner . on ( STRING_CONSTANT ) . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
NodeTraversal . traverseEs6 ( compiler , scriptRoot , new Es6RenameReferences ( renameTable ) ) ;
NodeTraversal . traverseEs6 ( compiler , root , new Es6RenameReferences ( renameTable ) ) ;
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode ) ;
this . functionSideEffectMap = ArrayListMultimap . create () ;
return IR . exprResult ( assign ) . useSourceInfoIfMissingFromForTree ( var ) ;
{ if ( Matchers . googRequire () . matches ( child . getFirstChild () , metadata ) ) { return true ; } }
Matchers . googRequire () . matches ( child . getFirstChild () , metadata )
{ eatPredefinedString ( PredefinedName.FROM ) ; moduleSpecifier = ( LiteralToken ) eat ( TokenType.STRING ) ; }
public void testRequireUseStrict1 () { configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
testWarning ( STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT ) ;
testWarning ( STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
madeChange = true ;
{ parent . removeChild ( node ) ; madeChange = true ; }
Pattern argPattern = Pattern . compile ( STRING_CONSTANT , Pattern.DOTALL ) ;
new ByteArrayInputStream ( inputString . getBytes ( UTF_8 ) )
new ByteArrayInputStream ( inputString . getBytes ( UTF_8 ) )
new ByteArrayInputStream ( inputString . getBytes ( UTF_8 ) )
new ByteArrayInputStream ( inputString . getBytes ( UTF_8 ) )
inputSourceMaps . put ( jsonFile . getPath () , new SourceMapInput ( sourceMap ) ) ;
{ if ( child != n . getFirstChild () ) { cc . listSeparator () ; } add ( child ) ; }
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; break; } }
final Node extendsClause = n . getSecondChild () ;
{ test ( createCompilerOptions () , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; } }
NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.INCOMPATIBLE_STRICT_COMPARISON ) ;
builder . setTagAsStrict ( firstOutput && options . isEmitUseStrict () && options . getLanguageOut () . isStrict () ) ;
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; break; } }
com.google.javascript.jscomp.parsing.parser.Parser.Config es6config = newParserConfig ( config ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , WARNING ) ;
@ Override protected CodingConvention getCodingConvention () { return codingConvention ; }
{ super . setUp () ; codingConvention = new GoogleCodingConvention () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT8 ) ; }
if ( config.languageMode != LanguageMode.TYPESCRIPT ) { errorReporter . warning ( STRING_CONSTANT + feature , sourceName , lineno ( node ) , charno ( node ) ) ; }
Config config = ParserRunner . createConfig ( mode , Config.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , Config.RunMode.KEEP_GOING , null , true , StrictMode.SLOPPY ) ;
builder . setTagAsStrict ( firstOutput && shouldEmitUseStrict () ) ;
if ( expectStrictModeInput () ) { options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.ERROR ) ; }
options . setEmitUseStrict ( flags.emitUseStrict ) ;
public void testDoWhileLoopBranch ( ) throws Exception { compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
{ googRequireNode = IR . constNode ( IR . name ( shortName ) , googRequireNode ) ; }
return getConstJSDoc ( oldJSDoc , expr ) ;
if ( ! hasConstructor ) { addSyntheticConstructor ( t , n ) ; }
! NodeUtil . isCallTo ( value , STRING_CONSTANT ) && ! ( info != null && info . isConstructorOrInterface () )
if ( NodeUtil . isCallTo ( destructuringLhsNode . getLastChild () , STRING_CONSTANT ) ) { return; }
var != null && var . getInitialValue () != null && ! NodeUtil . isCallTo ( var . getInitialValue () , STRING_CONSTANT )
if ( aliasVarNodeRhs == null || ! NodeUtil . isCallTo ( aliasVarNodeRhs , STRING_CONSTANT ) ) { t . report ( call , INVALID_GET_ALIAS ) ; return; }
String exportedNamespace = currentScript . getExportedNamespace () ;
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) ;
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) ;
if ( isExportPropertyAssignment ( n ) ) { recordExportsPropertyAssignment ( t , n ) ; }
{ typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; typeCheck ( STRING_CONSTANT , JSTypeCreatorFromJSDoc.INHERITANCE_CYCLE , NewTypeInference.UNDEFINED_SUPER_CLASS ) ; }
IR . call ( IR . getprop ( IR . superNode () , IR . string ( STRING_CONSTANT ) ) , IR . thisNode () , IR . name ( STRING_CONSTANT ) )
assertNull ( LanguageMode . fromString ( STRING_CONSTANT ) ) ;
sourceMap . appendTo ( out , outputFile . getName () ) ;
{ if ( n . isSuper () ) { visitSuper ( t , n , parent ) ; } }
add ( last ) ;
assertValidOrderForChecks ( checks ) ;
assertValidOrderForChecks ( passes ) ;
CompilerPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeFoldConstants ( late , useTypes ) ) ;
if ( ! ( rval >= NUMBER_CONSTANT && rval < NUMBER_CONSTANT ) ) { return n ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , EARLY_REFERENCE ) ; }
declaresFunctionOrClass ( n )
public DeclaredTypeRegistry getScope () { return this . scope ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , VariableReferenceCheck.EARLY_REFERENCE ) ; }
if ( isCallInLoop ) { fixUnitializedVarDeclarations ( newBlock , newBlock ) ; }
{ super . setUp () ; codingConvention = new GoogleCodingConvention () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ; }
if ( ! targetType . getGreatestSubtype ( type ) . isBottom () ) { unusedMethodPolyfills . remove ( method ) ; }
new PeepholeReplaceKnownMethods ( late , useTypesForOptimization )
new PeepholeReplaceKnownMethods ( late , false )
new PeepholeReplaceKnownMethods ( late , useTypesForOptimization )
public boolean isBuiltinObject () { return this . rawType . isBuiltinObject () ; }
boolean isClassy () { return ! isFunction () && ! isBuiltinObject () && ! isLiteralObject () ; }
if ( this . equals ( proto ) ) { Preconditions . checkState ( this . isUnknownObject () , STRING_CONSTANT , this ) ; return null ; }
return isUnknown () || ( isUnknownObject () && isLoose () ) || ( ft != null && ft . isTopFunction () ) ;
return nt . isBuiltinObject () || nt . isPropDefinedOnSubtype ( pname ) ;
Preconditions . checkArgument ( name . equals ( JSTypes.OBJLIT_CLASS_NAME ) || name . equals ( STRING_CONSTANT ) || name . equals ( STRING_CONSTANT ) , STRING_CONSTANT , name ) ;
return this . commonTypes . getEmptyObjectLiteral () ;
if ( this == other || other . isBuiltinObject () ) { return true ; }
if ( ! isBuiltinObject () ) { this . subtypes . add ( subtype ) ; }
public RemoveUnusedPolyfillsTest () { super ( EXTERNS ) ; }
return Ascii . toUpperCase ( Long . toString ( nonnegativeHash , NUMBER_CONSTANT ) ) ;
{ CompilerOptions.J2clPassMode j2clPassMode = CompilerOptions.J2clPassMode . valueOf ( Ascii . toUpperCase ( flags.j2clPassMode ) ) ; options . setJ2clPass ( j2clPassMode ) ; }
String lowerParam = Ascii . toLowerCase ( param ) ;
compilationLevelParsed = COMPILATION_LEVEL_MAP . get ( Ascii . toUpperCase ( compilationLevel ) ) ;
addParserWarning ( STRING_CONSTANT , Ascii . toLowerCase ( visibility . toString () ) ) ;
{ result = Ascii . toUpperCase ( result . toString () ) ; }
String canonicalizedName = Ascii . toUpperCase ( value . trim () ) . replaceFirst ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ Node parent = n . getParent () ; return NodeUtil . wasCasted ( n ) || isAssertionCall ( parent ) ; }
return getTopObject () ;
! t . isSubtypeOf ( this . commonTypes . getTopObject () ) && ( ! t . hasTypeVariable () || t . hasScalar () )
JSType objLitType = commonTypes . getEmptyObjectLiteral () ;
{ globalThisType = this . commonTypes . getTopObject () . withLoose () ; }
this == other || other.ns != null || ! other.nominalType . equals ( this . commonTypes . getObjectType () )
boolean isInhabitable () { return this != this . commonTypes . getBottomObject () ; }
objType != null && ! objType.nominalType . isClassy () && ! objType . isLoose ()
if ( nameNode == null ) { return; }
{ return false ; }
if ( name != null ) { this . definitionNodeByDefinitionSite . remove ( node ) ; this . nameDefinitionMultimap . remove ( name , def ) ; }
pattern . replaceWith ( IR . name ( tempVarName ) ) ;
patternParam . replaceWith ( newParam ) ;
callNode . replaceWith ( replacement . useSourceInfoIfMissingFrom ( callNode ) ) ;
candidateDefinition . replaceWith ( varNode ) ;
parent . replaceWith ( replacement ) ;
n . replaceWith ( replacement ) ;
n . replaceWith ( replacement ) ;
first . replaceWith ( name ) ;
n . replaceWith ( placeholder ) ;
{ Node parent = n . getParent () ; parent . replaceWith ( fncBlock ) ; }
n . replaceWith ( call ) ;
msgNode . replaceWith ( newValue ) ;
statement . replaceWith ( newStatement ) ;
assignNode . replaceWith ( rhs ) ;
if ( enclosing != null && enclosing . isGeneratorFunction () ) { n . replaceWith ( IR . name ( GENERATOR_THIS ) ) ; }
n . replaceWith ( replacement ) ;
n . replaceWith ( elem ) ;
n . replaceWith ( elem ) ;
n . replaceWith ( lengthNode ) ;
n . replaceWith ( newNode ) ;
n . replaceWith ( newNumber ) ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; reportCodeChange () ; return result ; }
n . replaceWith ( newStringNode ) ;
n . replaceWith ( replacement ) ;
n . replaceWith ( newNode ) ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; reportCodeChange () ; return replacementNode ; }
originalTypeofNode . replaceWith ( newNode ) ;
n . replaceWith ( replacement ) ;
callNode . replaceWith ( objNode ) ;
n . replaceWith ( newNode ) ;
subtree . replaceWith ( replacement ) ;
subtree . replaceWith ( replacement ) ;
{ parent . replaceWith ( IR . empty () ) ; }
grandparent . replaceWith ( functionNode ) ;
n . replaceWith ( var ) ;
n . replaceWith ( replacement ) ;
target . replaceWith ( value . cloneTree () ) ;
node . replaceWith ( replacement ) ;
n . replaceWith ( stringNode ) ;
callNode . replaceWith ( objNode ) ;
callNode . replaceWith ( objNode ) ;
{ original . replaceWith ( replacement ) ; return replacement ; }
if ( replaceParent ) { parent . replaceWith ( replacement ) ; } else { parent . replaceChild ( n , replacement ) ; }
superCall . replaceWith ( superErrorExpr ) ;
obj . replaceWith ( result ) ;
n . replaceWith ( attachTypeExpr ) ;
loadModuleStatement . replaceWith ( moduleBlockNode ) ;
n . replaceWith ( legacyQname ) ;
exprResultNode . replaceWith ( exportsObjectCreationNode ) ;
call . replaceWith ( exportedNamespaceName ) ;
{ aliasReference . replaceWith ( replacement ) ; }
expressionWithScopeCall . replaceWith ( scopeClosureBlock ) ;
{ newValue . useSourceInfoIfMissingFromForTree ( msgNode ) ; msgNode . replaceWith ( newValue ) ; compiler . reportCodeChange () ; }
callNode . replaceWith ( replacementNode . detach () ) ;
member . replaceWith ( memberVariable ) ;
{ forCondition . replaceWith ( IR . empty () ) ; reportCodeChange () ; }
n . replaceWith ( whileNode ) ;
condition . replaceWith ( replacementConditionNode ) ;
n . replaceWith ( replacement ) ;
n . replaceWith ( caseBlock . detach () ) ;
{ if ( result . getParent () != null ) { result . detach () ; } n . replaceWith ( result ) ; }
{ subtree . replaceWith ( right . detach () ) ; reportCodeChange () ; return right ; }
{ oldRoot . replaceWith ( newRoot ) ; }
n . replaceWith ( call ) ;
n . replaceWith ( not ) ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
n . replaceWith ( replacement ) ;
enclosingCall . replaceWith ( baseCall ) ;
callNode . replaceWith ( replacement ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ;
public void testNgInjectSetVisibility ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
Node scopeMethodCall = findScopeMethodCall ( t . getScopeRoot () ) ;
Node n = t . getScopeRoot () ;
return list . isEmpty () ? null : list ;
return list ;
public abstract Node getRoot ( ) ;
String getContent ( ) ;
String getName ( ) ;
{ return Strings . nullToEmpty ( sourceMapCache . get ( path ) ) ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate , CacheBuilder . newBuilder () ) ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate ) ; }
{ return STRING_CONSTANT ; }
String output = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
if ( ! n . hasXChildren ( NUMBER_CONSTANT ) ) { return n ; }
if ( castType . restrictByNotNullOrUndefined () . isSubtype ( exprType ) || expr . isObjectLit () ) { expr . setJSType ( castType ) ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate , CacheBuilder . newBuilder () ) ; }
{ return Strings . nullToEmpty ( sourceMapCache . get ( path ) ) ; }
options . setLanguageOut ( LanguageMode.ECMASCRIPT5 ) ;
return new RawNominalType ( commonTypes , defSite , name , typeParameters , Kind.RECORD , objKind , false ) ;
return new RawNominalType ( commonTypes , defSite , name , typeParameters , Kind.INTERFACE , objKind , false ) ;
ImmutableCollection < ExportInfo > exports
if ( isUnknownType () ) { return true ; }
return list . isEmpty () ? null : list ;
if ( ! hasConstructor ) { addSyntheticConstructor ( n ) ; }
IR . comma ( IR . comma ( IR . comma ( getTmpError , copyMessage ) , setStack ) , IR . thisNode () ) . useSourceInfoIfMissingFromForTree ( superCall )
{ compiler . report ( JSError . make ( constructor , CANNOT_CONVERT , STRING_CONSTANT + superClassQName ) ) ; }
this . ancestorInterfaces = new HashMap <> () ;
script . addChildToFront ( googProvide . useSourceInfoIfMissingFromForTree ( script ) ) ;
require . useSourceInfoIfMissingFromForTree ( importDecl ) ;
newChild . useSourceInfoWithoutLengthIfMissingFrom ( child ) ;
{ node . useSourceInfoWithoutLengthIfMissingFromForTree ( basisNode ) ; node . setOriginalName ( originalName ) ; }
newNode . useSourceInfoWithoutLengthIfMissingFromForTree ( sourceInfoNode ) ;
expr . useSourceInfoWithoutLengthIfMissingFromForTree ( parent ) ;
newChild . useSourceInfoIfMissingFrom ( child ) ;
Node name
if ( strictMismatch ) { mismatches . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordImplicitInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( caseType , switchType ) ; }
if ( strictMismatch ) { implicitStructuralInterfaceUses . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordStructuralInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
{ recordStructuralInterfaceUses ( caseType , switchType ) ; }
@ Override Iterable < TypeMismatch > getImplicitInterfaceUses () { return getTypeValidator () . getImplicitInterfaceUses () ; }
if ( strictMismatch ) { implicitInterfaceUses . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordImplicitInterfaceUses ( n , argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( n , rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; }
if ( options . getTracerMode () . isOn () && tracker != null ) { tracker . recordPassStop ( passName , result ) ; }
if ( options . getTracerMode () . isOn () && tracker != null ) { tracker . recordPassStart ( passName , true ) ; }
{ return compilerExecutor . runInCompilerThread ( callable , options != null && options . getTracerMode () . isOn () ) ; }
options . setTracerMode ( config.tracerMode ) ;
testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExport5 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
for ( Reference ref : refCollection ) { processReference ( collector , ref , info , v ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
Map < String , DependencyInfo > parsedFiles = new LinkedHashMap <> () ;
Map < String , DependencyInfo > depsFiles = new LinkedHashMap <> () ;
Map < String , DependencyInfo > providesMap = new LinkedHashMap <> () ;
( ! allowLoosePropertyAccessOnNode ( n ) || objectType . isStruct () )
{ if ( canCreate ) { return createName ( name ) ; } return allNames . get ( name ) ; }
if ( ! Double . isNaN ( d ) ) { cc . addNumber ( d , n ) ; } else { addJsString ( n ) ; }
assertThat ( result.sourceMap ) . isEmpty () ;
catch ( IOException e ) { compiler . report ( JSError . make ( REPORT_PATH_IO_ERROR , reportPath , e . getMessage () ) ) ; }
catch ( IOException e ) { compiler . report ( JSError . make ( REPORT_PATH_IO_ERROR , reportPath , e . getMessage () ) ) ; }
Preconditions . checkState ( current . isGetProp () , STRING_CONSTANT , current ) ;
static boolean isEnhancedFor ( Node n ) { return n . isForOf () || n . isForIn () ; }
return newNode ( Token.FOR_IN , initializer , transform ( loopNode.collection ) , transformBlock ( loopNode.body ) ) ;
return new Node ( Token.FOR_IN , target , cond , body ) ;
validateNodeType ( Token.ROOT , n ) ;
validateNodeType ( Token.ROOT , n ) ;
Path path
Path path
TranspileResult transpile ( Path path , String code ) ;
TranspileResult result = transpiler . transpile ( Paths . get ( path ) , s ) ;
Path path
BaseTranspiler.CompileResult result = compiler . compile ( SOURCE_JS , STRING_CONSTANT ) ;
BaseTranspiler.CompileResult result = compiler . compile ( SOURCE_JS , STRING_CONSTANT ) ;
Path path
Path path
if ( parent . isForIn () ) { return n != parent . getFirstChild () ; } else { return NodeUtil . getConditionExpression ( parent ) != n ; }
source . isForIn ()
( parent . isForIn () )
if ( n . isForOf () || n . isForIn () ) { return n . getSecondChild () ; }
if ( parent . isForIn () ) { return parent ; } else { return parent . getSecondChild () . getNext () ; }
if ( cur . isVanillaFor () ) { iter = cur . getChildAtIndex ( NUMBER_CONSTANT ) ; }
forNode . isForIn () || forNode . isForOf ()
c . isForIn ()
parent . isForIn ()
! n . isForIn ()
parent . isFor () && ! parent . isForIn ()
if ( ! parent . isForIn () && child == parent . getFirstChild () ) { return parent ; }
boolean lhsOfForInLoop = gp . isForIn () && gp . getFirstFirstChild () == declNode ;
loopNode . isVanillaFor ()
srcDeclaration . isConst () && ! ( srcParent . isForIn () && srcDeclaration == srcParent . getFirstChild () )
! n . isForIn ()
nextSibling . isForIn ()
! n . isForIn ()
if ( enclosingFunc == null || ! enclosingFunc . isGeneratorFunction () || n . isForIn () ) { return; }
if ( currentStatement . isForIn () ) { visitForIn () ; return false ; }
if ( parent . isForIn () && parent . getFirstChild () == n ) { return false ; }
n . isForIn ()
Preconditions . checkState ( expr . isForIn () ) ;
Preconditions . checkState ( expr . getParent () . isForIn () ) ;
Preconditions . checkState ( lvalue . getParent () . isForIn () ) ;
n . isForIn ()
Node expr = n . isForIn () ? n . getFirstChild () : NodeUtil . getConditionExpression ( n ) ;
if ( parent . isForIn () ) { return; }
if ( n . isForIn () ) { return n ; }
if ( ! node . isForIn () ) { tryJoinForCondition ( node ) ; tryMinimizeCondition ( NodeUtil . getConditionExpression ( node ) ) ; }
parent . isForIn ()
if ( ! parent . isForIn () ) { return ( parent . getSecondChild () == expr ) ; }
( parent . isForIn () && parent . getFirstChild () == n )
return n . isForIn () ? null : n . getSecondChild () ;
( parent . isForIn () && parent . getFirstChild () == n )
! n . isForIn ()
control . isForIn ()
n . isForIn ()
parent . isFor () && ! parent . isForIn () && NodeUtil . getConditionExpression ( parent ) != n
if ( ! n . isForIn () ) { tryRemoveAssignment ( t , NodeUtil . getConditionExpression ( n ) , state ) ; }
var . getParentNode () . isVar () && ! var . getParentNode () . getParent () . isForIn ()
Preconditions . checkState ( ! NodeUtil . isLoopStructure ( parent ) ) ;
currentStatement . isVanillaFor ()
n . isAssign () && ! ( parent . isVanillaFor () || parent . isForIn () )
n . isAssign () && ( parent . isExprResult () || parent . isVanillaFor () || parent . isReturn () )
( declaration . getParent () . isVar () && ! NodeUtil . isLoopStructure ( declaration . getGrandparent () ) )
nextSibling . isVanillaFor () && nextSibling . getFirstChild () . isEmpty ()
Node initializer = NodeUtil . isAnyFor ( n ) ? n . getFirstChild () : IR . empty () ;
if ( ! parent . isVanillaFor () ) { assign = NodeUtil . newExpr ( assign ) ; }
grandparent . isForIn ()
{ appendFieldStart ( out , name , false ) ; }
Preconditions . checkNotNull ( scope , STRING_CONSTANT , t . getScopeRoot () ) ;
boolean preserveBlock = n . isNormalBlock () && ! n . isSyntheticBlock () ;
parent . isNormalBlock () || NodeUtil . isAnyFor ( parent ) || parent . isScript () || parent . isModuleBody () || parent . isLabel ()
boolean scanInnerBlocks = n . isRoot () || NodeUtil . isFunctionBlock ( n ) || n . isModuleBody () ;
TypedScope s = new TypedScopeCreator ( compiler , CodingConventions . getDefault () ) . createInitialScope ( new Node ( Token.ROOT ) ) ;
testMissingRequireStrict ( js , STRING_CONSTANT ) ;
testMissingRequireStrict ( js , STRING_CONSTANT ) ;
testMissingRequireStrict ( js , STRING_CONSTANT ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckRequiresForConstructors ( compiler , mode ) ; }
if ( this . optimizePropertyIndex && isObjectLiteralThatCanBeSkipped ( type ) ) { type = getSentinelObjectLiteral () ; }
new PeepholeMinimizeConditions ( late , useTypesForOptimization , options.assumeAccurateNullUndefinedTypes )
new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false , false ) , new PeepholeFoldConstants ( true , false ) )
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeMinimizeConditions ( late , useTypes , assumeAccurateNullUndefinedTypes ) ) ;
new PeepholeMinimizeConditions ( late , false , false )
new PeepholeMinimizeConditions ( late , false , false )
getInvalidationsErrors () . get ( t )
throw new RuntimeException ( cause ) ;
if ( exception [ NUMBER_CONSTANT ] != null ) { throw new RuntimeException ( exception [ NUMBER_CONSTANT ] ) ; }
try { TextFormat . merge ( textProto , builder ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; }
{ try { initialize ( metadata . getCompiler () ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableUnusedLocalAssignmentCheck = false ; }
{ CompilerOptions options = super . getOptions () ; if ( enableUnusedLocalAssignmentCheck ) { options . setWarningLevel ( DiagnosticGroups.UNUSED_LOCAL_VARIABLE , CheckLevel.WARNING ) ; } return options ; }
invalidationMap . get ( t )
private String getNewName () { return paramPrefix + uniqueId ++ ; }
{ this . compiler = Preconditions . checkNotNull ( compiler ) ; this . paramPrefix = Preconditions . checkNotNull ( paramPrefix ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeMinimizeConditions ( late , useTypes ) ) ;
new PeepholeMinimizeConditions ( late , false )
new PeepholeMinimizeConditions ( late , false )
new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false ) , new PeepholeFoldConstants ( true , false ) )
new PeepholeMinimizeConditions ( late , useTypesForOptimization )
( new NodeTraversal ( compiler , this , scopeCreator ) ) . traverseAtScope ( scope ) ;
{ addLibrary ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; setLanguage ( ES6 , ES5 ) ; testDoesNotInject ( STRING_CONSTANT ) ; }
{ addLibrary ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; setLanguage ( ES6 , ES5 ) ; testDoesNotInject ( STRING_CONSTANT ) ; }
validateBlock ( n . getLastChild () ) ;
{ validateNodeType ( Token.DEFAULT_CASE , n ) ; validateChildCount ( n ) ; validateBlock ( n . getLastChild () ) ; }
{ Preconditions . checkState ( body . isBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
body . setIsAddedBlock ( true ) ;
block . setIsAddedBlock ( true ) ;
block . setIsAddedBlock ( true ) ;
public void testEmpty () { this . instrumentationPb = STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
public void testSwitchCase () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveDo () { testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
testSame ( src ) ;
public void testForIn () { inFunction ( STRING_CONSTANT ) ; inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ foldSame ( STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; foldSame ( STRING_CONSTANT ) ; }
public void testDivision () { foldSame ( STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
testSame ( js ) ;
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
{ testSame ( STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
public void testNgInjectToArrowFunctions () { testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; }
public void testReturnType () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testRestParameter () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ testLocal ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testSameLocal ( STRING_CONSTANT ) ; }
testSameLocal ( STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
testSameWithInversion ( STRING_CONSTANT ) ;
testSame ( fullJsCode ) ;
testSame ( STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ if ( ! isClinitMethod ( node ) ) { return; } trySubstituteEmptyFunction ( node ) ; }
{ tryRemovingClinit ( node , parent ) ; if ( isNewControlBranch ( parent ) ) { clinitsCalledAtBranch = clinitsCalledAtBranch.parent ; } }
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode , definitionProvider , representativeNodesByName ) ;
this . functionSideEffectMap = new LinkedHashMap <> () ;
PropertyType pt = getPropTypeHelper ( jsdoc , getProp , rawType ) ;
{ lint ( Paths . get ( filename ) , new Compiler ( System.out ) ) ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , EARLY_REFERENCE ) ; }
testSame ( STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
options . setProtectHiddenSideEffects ( true ) ;
NodeTraversal outOfBandTraversal = new NodeTraversal ( compiler , this , scopeCreator ) ;
{ Preconditions . checkState ( mayBeExpression ( expr ) , expr ) ; return new Node ( Token.EXPR_RESULT , expr ) ; }
{ Node root = compiler . parseTestCode ( js ) ; assertThat ( compiler . getErrors () ) . isEmpty () ; return root ; }
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler , new DuplicateDeclarationHandler () ) ;
if ( isConstructor ( n ) ) { markConstructorToProcess ( n ) ; return false ; }
new RemoveCode ( compiler ) . process ( externs , root ) ;
handleStubDefinition ( t , n ) ;
Node memberType = parseTypeExpressionList ( typeName , next () ) ;
Node memberType = parseTypeExpressionList ( next () ) ;
lastIndex = replacement . getEndPosition () ;
{ return compilerExecutor . runInCompilerThread ( callable , options != null && options . getTracerMode () == TracerMode.ALL ) ; }
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode ) ;
this . functionSideEffectMap = ArrayListMultimap . create () ;
@ Nullable Object object
{ checkState ( token == Token.BLOCK ) ; putBooleanProp ( SYNTHETIC_BLOCK_PROP , val ) ; }
public void setTypeI ( @ Nullable TypeI type ) { this . typei = type ; }
@ Nullable public TypeI getTypeI () { return typei ; }
public void setJSType ( @ Nullable JSType jsType ) { this . typei = jsType ; }
checkNotNull ( target , STRING_CONSTANT ) ;
{ checkNotNull ( parent ) ; parent . removeChild ( this ) ; return this ; }
public AncestorIterable getAncestors () { return new AncestorIterable ( checkNotNull ( this . getParent () ) ) ; }
@ Nullable public Node getParent () { return parent ; }
void setPropListHead ( @ Nullable PropListItem propListHead ) { this . propListHead = propListHead ; }
@ Nullable PropListItem getPropListHeadForTesting () { return propListHead ; }
public void setStaticSourceFile ( @ Nullable StaticSourceFile file ) { this . putProp ( STATIC_SOURCE_FILE , file ) ; }
@ Nullable PropListItem next
@ Nullable PropListItem next
@ Nullable Object value
{ checkState ( this . propListHead == null , STRING_CONSTANT ) ; this . propListHead = other.propListHead ; return this ; }
checkNotNull ( target , STRING_CONSTANT ) ;
{ checkNotNull ( prevChild.next , STRING_CONSTANT ) ; replaceChild ( prevChild.next , newChild ) ; }
{ checkArgument ( child.parent == null ) ; child.parent = this ; }
@ Nullable public Node getSecondChild () { return first.next ; }
@ Nullable public Node getFirstChild () { return first ; }
@ Nullable PropListItem next
@ Nullable PropListItem next
@ Nullable PropListItem next
@ Nullable PropListItem next
@ Override public abstract PropListItem chain ( @ Nullable PropListItem next ) ;
@ Nullable PropListItem next
PropListItem chain ( @ Nullable PropListItem next ) ;
@ Nullable PropListItem getNext ( ) ;
Node memberType = parseTypeExpressionList ( typeName , next () ) ;
condition . isCall () && condition . hasTwoChildren ()
Preconditions . checkState ( node . hasTwoChildren () ) ;
callName . matchesQualifiedName ( STRING_CONSTANT ) && n . hasTwoChildren ()
boolean isDeprecatedCall = callNode . hasTwoChildren () && callName . isGetProp () ;
checkState ( n . hasTwoChildren () , n ) ;
Preconditions . checkState ( left . hasTwoChildren () ) ;
Preconditions . checkState ( n . hasTwoChildren () , n ) ;
Preconditions . checkState ( node . hasTwoChildren () , node ) ;
if ( createSourceMap ) { mcp . generateSourceMap ( code , sourceMap ) ; }
setReferencedType ( new NoResolvedType ( registry , getReferenceName () ) ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope , true ) ; }
assertThat ( templateTypes ) . isEmpty () ;
String shortName = getShortNameForRequire ( namespace ) ;
String shortName = getShortNameForRequire ( namespace ) ;
String shortName = getShortNameForRequire ( namespaceToRequire ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope ) ; }
setReferencedType ( registry . getNativeObjectType ( JSTypeNative.NO_RESOLVED_TYPE ) ) ;
Ascii . toUpperCase ( rightmostName )
{ checkState ( isAnalyzableObjectDefinePropertiesDefinition ( n ) ) ; return ImmutableList . of ( n . getLastChild () ) ; }
checkArgument ( parent . isVanillaFor () , STRING_CONSTANT , parent ) ;
checkNotNull ( reportPath ) ;
@ Nullable NameInformation referring
@ Nullable NameInformation referring
checkNotNull ( ns , STRING_CONSTANT , n ) ;
{ checkNotNull ( name ) ; scopes . put ( node , name ) ; }
checkState ( node . isCall () ) ;
{ super ( name , node ) ; checkState ( node . isCall () ) ; }
{ super ( name , parent . getFirstChild () ) ; checkState ( parent . isAssign () ) ; }
{ checkLocalityOfMarkedCalls ( source , expected , LanguageMode.ECMASCRIPT_2015 ) ; checkLocalityOfMarkedCalls ( source , expected , LanguageMode.ECMASCRIPT5 ) ; }
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
assertNoPureCalls ( source ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
assertNoPureCalls ( source ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
assertNoPureCalls ( templateSrc . replace ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
JSType recvType = simpleInferExprTypeRecur ( recv ) ;
JSType t = simpleInferExprTypeRecur ( argNode ) ;
{ String name = NodeUtil . getName ( n ) ; noSideEffectExterns . add ( name ) ; }
qname != null && noSideEffectExterns . contains ( qname ) && ! isDefinedInSrc
Map < ParamGroup , CompilationParam [] > compilationParamsByGroup = new EnumMap <> ( ParamGroup . class ) ;
assertTrue ( functionA . getBodyNode () . isNormalBlock () ) ;
assertTrue ( mainFunction . getAstNode () . isRoot () ) ;
assertTrue ( mainFunction . getBodyNode () . isRoot () ) ;
{ return n . isNormalBlock () && n . hasChildren () && isReturnTypeNullable ( n . getParent () ) && ! hasSingleThrow ( n ) ; }
statement . isNormalBlock ()
Preconditions . checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
currentFile . markNameProcessed ( nameNode . getQualifiedName () ) ;
Preconditions . checkState ( root . isRoot () ) ;
if ( ! originalBody . isNormalBlock () ) { originalBody = IR . block ( IR . returnNode ( originalBody ) ) . useSourceInfoFromForTree ( originalBody ) ; }
! body . isNormalBlock ()
Preconditions . checkState ( block . isNormalBlock () ) ;
Preconditions . checkState ( body . getNext () == null && body . isNormalBlock () , body ) ;
checkState ( body . isNormalBlock () , body ) ;
if ( n . isExprResult () || n . isNormalBlock () ) { return; }
Preconditions . checkArgument ( block . isNormalBlock () , STRING_CONSTANT ) ;
node . isFunction () && ! NodeUtil . getFunctionBody ( node ) . isNormalBlock ()
if ( body . isNormalBlock () ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
if ( ! n . isNormalBlock () || ! n . hasChildren () ) { return; }
if ( newChild . isNormalBlock () ) { NodeUtil . tryMergeBlock ( newChild ) ; }
if ( ! n . isScript () && ! n . isNormalBlock () ) { return; }
parent . isScript () || ( parent . isNormalBlock () && parent . getParent () . isFunction () )
c . isNormalBlock ()
c . isNormalBlock ()
Preconditions . checkState ( caseBody . isNormalBlock () ) ;
! labeledStatement . isNormalBlock ()
last . isNormalBlock ()
currentStatement . isNormalBlock ()
if ( ! favorsCommaOverSemiColon && ! block . isNormalBlock () ) { return false ; }
Preconditions . checkArgument ( node . isNormalBlock () ) ;
parent != null && ( parent . isNormalBlock () || parent . isScript () )
s . isFunctionScope () && s . getRootNode () . getLastChild () . isNormalBlock ()
for ( Node child : node . children () ) { if ( child . isNormalBlock () ) { blocks . add ( child ) ; } }
! target . getParent () . isScript () && ! target . getParent () . isNormalBlock ()
! n . getParent () . isScript () && ! n . getParent () . isNormalBlock ()
boolean isVar = NodeUtil . isNameDeclaration ( parent ) && parent . getParent () . isNormalBlock () ;
isGoogScopeFunctionBody ( enclosingFunctionBody ) && scopeRoot . isNormalBlock () && ! scopeRoot . getParent () . isFunction ()
NodeUtil . isControlStructureCodeBlock ( n , c ) && ! c . isNormalBlock ()
! setFunction . hasChildren () || ! setFunction . getLastChild () . isNormalBlock () || ! setFunction . getSecondChild () . isParamList ()
if ( ! getFunction . hasChildren () || ! getFunction . getLastChild () . isNormalBlock () ) { return false ; }
if ( ! n . isFunction () || ! n . getLastChild () . isNormalBlock () ) { return; }
umdPattern.activeBranch . isNormalBlock () && umdPattern.activeBranch . getChildCount () == NUMBER_CONSTANT
n . isNormalBlock ()
n . isNormalBlock ()
n . isNormalBlock ()
n . isNormalBlock ()
if ( n . isEmpty () || ( n . isNormalBlock () && ! n . hasChildren () ) ) { return; }
next != null && next . isNormalBlock ()
if ( ! body . isNormalBlock () || ! body . hasOneChild () || ! body . getFirstChild () . isReturn () ) { return; }
{ Preconditions . checkArgument ( blockNode . isNormalBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
if ( n . isNormalBlock () ) { visitBlock ( n ) ; }
{ Preconditions . checkArgument ( n . isNormalBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
Preconditions . checkState ( addingRoot . isNormalBlock () || addingRoot . isModuleBody () || addingRoot . isScript () ) ;
{ return n . isNormalBlock () && n . getParent () != null && n . getParent () . isFunction () ; }
Preconditions . checkState ( block . isNormalBlock () ) ;
node . isNormalBlock ()
for ( ; ! currentParent . isScript () && ! currentParent . isNormalBlock () ; current = currentParent , currentParent = currentParent . getParent () ) {}
if ( ! ( parent . isScript () || grandparent != null && grandparent . isFunction () && parent . isNormalBlock () ) ) { return; }
body . isNormalBlock () && ! body . hasChildren ()
{ return ( n . isNormalBlock () && n . isSyntheticBlock () ) || n . isScript () ; }
Preconditions . checkState ( block . isNormalBlock () ) ;
return expectedBlock . isNormalBlock () ? expectedBlock : null ;
if ( ! subtree . isScript () && ! subtree . isNormalBlock () ) { return subtree ; }
Preconditions . checkState ( n . isNormalBlock () , n ) ;
if ( maybeAssign . isNormalBlock () || maybeAssign . isScript () || NodeUtil . isStatement ( maybeAssign ) ) { return; }
n . isNormalBlock () && ! loneBlocks . isEmpty () && loneBlocks . peek () == n
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( finallyBody . isNormalBlock () ) ;
Preconditions . checkState ( tryBody . isNormalBlock () ) ;
{ Preconditions . checkState ( body . isNormalBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( then . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
! isArrow && ! isSignature && ! bodyNode . isNormalBlock ()
! irNode . isNormalBlock ()
n . hasChildren () && n . getFirstChild () . isNormalBlock ()
Preconditions . checkState ( collectionRoot . isScript () || collectionRoot . isRoot () ) ;
Preconditions . checkState ( externs . isRoot () ) ;
{ assertTrue ( mainRoot . isRoot () && ! mainRoot . hasChildren () ) ; }
assertNode ( functionA . getBodyNode () ) . hasType ( Token.BLOCK ) ;
assertNode ( mainFunction . getAstNode () ) . hasType ( Token.ROOT ) ;
assertNode ( mainFunction . getBodyNode () ) . hasType ( Token.ROOT ) ;
return ImmutableList . of ( qmark , bang ) ;
return scopeRoot . isNormalBlock () && scopeRoot . getParent () != null && scopeRoot . getParent () . isFunction () ;
n . isNormalBlock ()
( parent . isScript () || ( parent . isNormalBlock () && ! parent . isSyntheticBlock () && ! parent . isAddedBlock () ) )
block . isNormalBlock () && block . getParent () . isTry () && block . getParent () . getFirstChild () == block
node . isNormalBlock () && parent != null && parent . isTry () && NodeUtil . getCatchBlock ( parent ) == node
if ( ! n . isNormalBlock () || ! n . hasChildren () || ! isGoogModuleCall ( n . getFirstChild () ) ) { return false ; }
if ( ! block . isNormalBlock () ) { return false ; }
if ( node . isNormalBlock () ) { node . setToken ( Token.SCRIPT ) ; }
boolean needsSemicolon = parent != null && ( parent . isExprResult () || parent . isNormalBlock () || parent . isScript () ) ;
deleteWhitespaceBefore && parent != null && ( parent . isScript () || parent . isNormalBlock () )
Preconditions . checkState ( parentNode . isNormalBlock () , STRING_CONSTANT ) ;
endPass ( STRING_CONSTANT ) ;
endPass ( STRING_CONSTANT ) ;
endPass ( STRING_CONSTANT ) ;
endPass ( STRING_CONSTANT ) ;
! currentScope . hasThis () && NodeUtil . containsType ( fn . getLastChild () , Token.SUPER , NodeUtil.MATCH_NOT_FUNCTION )
Renamer createForChildScope ( boolean hoisted ) ;
{ renamer = nameStack . peek () . createForChildScope ( ! NodeUtil . createsBlockScope ( declarationRoot ) ) ; }
if ( isInferrableConst ( jsdoc , name , false ) ) { jsdoc = pullJsdocTypeFromAst ( compiler , jsdoc , name ) ; }
if ( ! isInferrableConst ( jsdoc , nameNode , false ) ) { return; }
testWarning ( STRING_CONSTANT , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
warnings . add ( JSError . make ( propAccessNode , ABSTRACT_SUPER_METHOD_NOT_CALLABLE , funName ) ) ;
{ Preconditions . checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
Node argList = NodeUtil . getFunctionParameters ( function ) ;
Node argList = NodeUtil . getFunctionParameters ( function ) ;
throw new MalformedException ( STRING_CONSTANT + node , fnChild ) ;
findDeclaredNames ( functionBody , renamer , false ) ;
if ( ! declarationRoot . isFunction () ) { findDeclaredNames ( declarationRoot , renamer , false ) ; }
if ( isCallInLoop ) { fixUninitializedVarDeclarations ( newBlock , newBlock ) ; }
Preconditions . checkArgument ( declaration . isName () || declaration . isStringKey () ) ;
void clear () { providedNamespaces . clear () ; seenNames . clear () ; constructorsToProcess . clear () ; }
for ( String prefix : Iterables . concat ( seenNames , providedNamespaces ) ) { if ( fullyQualifiedName . startsWith ( prefix ) ) { return true ; } }
if ( instrumentationData . get ( fileName ) != null ) { node . addChildrenToFront ( newHeaderNode ( traversal , node ) . removeChildren () ) ; }
{ node . addChildrenToFront ( newHeaderNode ( traversal , node ) . removeChildren () ) ; instrumentBranchCoverage ( traversal , instrumentationData . get ( fileName ) ) ; }
{ return isUnionType () ? this . toMaybeUnionType () . getAlternatesWithoutStructuralTyping () : null ; }
TypeI type
TypeI type = getType ( typeObj ) ;
TypeI type = getType ( n ) ;
this . BOTTOM_OBJECT = this . registry . getNativeType ( JSTypeNative.NO_OBJECT_TYPE ) . toMaybeObjectType () ;
TypeI type
TypeI type
{ objectType = objectType . getTopDefiningInterface ( propName ) ; }
if ( isInterface () ) { return getInstanceType () . getTopDefiningInterface ( propertyName ) ; }
if ( lvalueType . isEnumElement () ) { lvalueType = lvalueType . getEnumeratedTypeOfEnumElement () ; }
JSType enumeratedType = requiredType . getProp ( new QualifiedName ( pname ) ) . getEnumeratedTypeOfEnumElement () ;
JSType enumeratedType = requiredType . getProp ( new QualifiedName ( pname ) ) . getEnumeratedTypeOfEnumElement () ;
{ NominalType tmp = NominalType . join ( n1 , n2 ) ; if ( tmp != null ) { return tmp . getInstanceAsJSType () ; } }
NominalType nominal = NominalType . join ( nt1 , nt2 ) ;
@ Override public CompilerPass getProcessor ( final Compiler compiler ) { return new ClosureOptimizePrimitives ( compiler , propertyRenamingEnabled ) ; }
{ Preconditions . checkState ( n . isName () , n ) ; n . removeFirstChild () ; }
parent . removeFirstChild () ;
! currentScript.declareLegacyNamespace && currentScript.defaultExportRhs == null && namedExport . hasInlinableName ( currentScript.exportsToInline . keySet () )
Preconditions . checkArgument ( o instanceof JSType , STRING_CONSTANT , o ) ;
this . registry = compiler . getTypeIRegistry () ;
test ( DEFAULT_EXTERNS + externs , js , expected , null , warning , description ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = STRING_CONSTANT ;
testSets ( js , output , STRING_CONSTANT ) ;
{ super . setUp () ; super . enableNormalize () ; this . mode = TypeInferenceMode.OTI_ONLY ; }
public DisambiguatePropertiesTest () { super ( DEFAULT_EXTERNS ) ; parseTypeInfo = true ; }
if ( ! ( t . inGlobalHoistScope () || t . inModuleScope () ) ) { return false ; }
{ assertError ( e ) . hasType ( type ) ; assertEquals ( e.lineNumber , lineNumber ) ; }
assertError ( result.errors [ NUMBER_CONSTANT ] ) . hasType ( errorType ) ;
assertThat ( result.success ) . isTrue () ;
assertThat ( compiler . getResult () . success ) . isTrue () ;
currentModule.importsByLongRequiredName . put ( extractFirstArgumentName ( callNode ) , parent ) ;
options . setPolymerVersion ( NUMBER_CONSTANT ) ;
polymerVersion = null ;
if ( options.deadAssignmentElimination ) { passes . add ( deadAssignmentsElimination ) ; if ( options.polymerVersion == null ) { passes . add ( deadPropertyAssignmentElimination ) ; } }
if ( options.polymerVersion != null ) { checks . add ( polymerPass ) ; }
options . setPolymerVersion ( NUMBER_CONSTANT ) ;
if ( other . isGeneric () ) { other = other . instantiateGenericsWithUnknown () ; }
{ if ( this . equals ( other ) ) { return true ; } return instantiateGenericsWithUnknown () . isSubtypeOfHelper ( other , checkThisType , subSuperMap , boxedInfo ) ; }
if ( isGeneric () ) { return instantiateGenericsWithUnknown () . transformByApplyProperty () ; }
Preconditions . checkArgument ( rootNode != parent.rootNode , STRING_CONSTANT , rootNode ) ;
public void testDontCrashCtorAliasWithEnum () { test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testGlobalObjectDeclaredToPreserveItsPreviousValue2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testObjLitAssignmentDepth2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; }
public boolean isConstDeclaration () { return getParent () . isConst () ; }
public boolean isVarDeclaration () { return getParent () . isVar () ; }
{ traverseClass ( n ) ; }
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
options . setPrettyPrint ( true ) ;
this . prettyPrint = options . isPrettyPrint () ;
String zipEntryPath = JAR_URL_PREFIX + absoluteZipPath + BANG_SLASH + entryPath ;
options.prettyPrint = true ;
this . prettyPrint = options.prettyPrint ;
public void testJqueryExpandedEachExpansionEs6ComputedProp () { testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ExpandJqueryAliases.JQUERY_UNABLE_TO_EXPAND_INVALID_NAME ) ; }
options . setPrettyPrint ( true ) ;
this . prettyPrint = options . isPrettyPrint () ;
{ options . setPolymerVersion ( value ? NUMBER_CONSTANT : null ) ; }
fix . getReplacements () . keySet ()
nameDefinitionMultimap . keySet ()
nameDefinitionMultimap . keys ()
nameDefinitionMultimap . keySet ()
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
{ checkState ( scope . isGlobal () , scope ) ; scanVars ( n , true , true ) ; }
{ CompilerOptions options = createCompilerOptions () ; options . setCheckTypes ( true ) ; test ( options , STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ; }
public void testTypeParsingOnWithVerbose () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ; test ( STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ; }
testSame ( DEFAULT_EXTERNS , STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
markConstAndCopyJsDoc ( assignNode , jsdocNode ) ;
markConstAndCopyJsDoc ( target , target ) ;
markConstAndCopyJsDoc ( jsdocNode , jsdocNode ) ;
{ return Iterables . getLast ( list ) ; }
super . setCode ( cachedCode , Objects . equals ( this . getCharset () , StandardCharsets.UTF_8 ) ) ;
super . setCode ( cachedCode , Objects . equals ( this . getCharset () , StandardCharsets.UTF_8 ) ) ;
if ( this . ns != null ) { builder . append ( this . ns ) ; }
{ if ( inheritedPropDef.methodType != null ) { propMethodTypesToProcess . put ( pname , inheritedPropDef.methodType ) ; } }
{ Preconditions . checkState ( this . rawType . isFinalized () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
this . functionContextStack . addLast ( initialGeneratorContext ? FunctionFlavor.GENERATOR : FunctionFlavor.NORMAL ) ;
Node namespaceArg = crDefineCallNode . getSecondChild () ;
Node pathArg = crExportPathNode . getSecondChild () ;
String target = call . getSecondChild () . getQualifiedName () ;
{ int result = BASE64_DECODE_MAP [ c ] ; assert ( result != - NUMBER_CONSTANT ) : STRING_CONSTANT ; return result ; }
ParseTree arrowFunctionBody = parseArrowFunctionBody ( expressionIn , FunctionFlavor.ASYNCHRONOUS ) ;
ParseTree arrowFunctionBody = parseArrowFunctionBody ( expressionIn , FunctionFlavor.NORMAL ) ;
parseFunctionTail ( builder , FunctionFlavor.GENERATOR ) ;
parseFunctionTail ( builder , FunctionFlavor.NORMAL ) ;
parseFunctionTail ( builder , FunctionFlavor.ASYNCHRONOUS ) ;
parseFunctionTail ( builder , FunctionFlavor.ASYNCHRONOUS ) ;
parseFunctionTail ( builder , isGenerator ? FunctionFlavor.GENERATOR : FunctionFlavor.NORMAL ) ;
parseFunctionTail ( builder , isGenerator ? FunctionFlavor.GENERATOR : FunctionFlavor.NORMAL ) ;
parseFunctionTail ( builder , isGenerator ? FunctionFlavor.GENERATOR : FunctionFlavor.NORMAL ) ;
recvType = recvType . removeType ( commonTypes.NULL_OR_UNDEFINED ) ;
if ( isCallTo ( destructuringLhsNode . getLastChild () , GOOG_REQUIRE ) ) { return; }
if ( aliasVarNodeRhs == null || ! isCallTo ( aliasVarNodeRhs , GOOG_FORWARDDECLARE ) ) { t . report ( call , INVALID_GET_ALIAS ) ; return; }
return call != null && isCallTo ( call , GOOG_LOADMODULE ) && call . getLastChild () . isFunction () ;
nameGenerator . reset ( reservedNames , STRING_CONSTANT , reservedFirstCharacters , reservedNonFirstCharacters ) ;
{ this ( compiler , generatePseudoNames , prevUsedPropertyMap , null , null , nameGenerator ) ; }
{ this ( compiler , generatePseudoNames , null , null , null , nameGenerator ) ; }
NameGenerator nameGen = new DefaultNameGenerator ( reservedNames . build () , STRING_CONSTANT , reservedFirstCharacters , reservedNonFirstCharacters ) ;
reset ( reservedNames , prefix , reservedCharacters , reservedCharacters ) ;
{ return new AmbiguateProperties ( compiler , options . getPropertyReservedNamingFirstChars () , options . getPropertyReservedNamingNonFirstChars () ) ; }
if ( isBottom () || isUnknown () || isTheTruthyType () ) { return this . commonTypes . UNKNOWN ; }
private boolean isTheFalsyType () { return FALSY_MASK == getMask () ; }
private boolean isTheTruthyType () { return TRUTHY_MASK == getMask () ; }
Preconditions . checkState ( this . isFinalized , STRING_CONSTANT , this ) ;
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; recordImplicitUseOfNativeObject ( n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; recordImplicitUseOfNativeObject ( n , caseType , switchType ) ; }
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ; return options ; }
for ( Var v : globalExternsScope . getVarIterable () ) { considerVar ( v , null ) ; }
scope . getVarIterable ()
for ( TypedScope s : scopes . values () ) { Iterables . addAll ( vars , s . getVarIterable () ) ; }
parse ( STRING_CONSTANT ) ;
for ( Var v : globalExternsScope . getAllSymbols () ) { considerVar ( v , null ) ; }
scope . getAllSymbols ()
for ( TypedScope s : scopes . values () ) { Iterables . addAll ( vars , s . getAllSymbols () ) ; }
{ return NodeUtil . isLoopStructure ( target ) && matchLabel ( target . getParent () , label ) ; }
{ if ( leftOfArrow.type == ParseTreeType.CALL_EXPRESSION ) { return completeAssignmentExpressionParseAtArrow ( leftOfArrow . asCallExpression () ) ; } else { return completeArrowFunctionParseAtArrow ( leftOfArrow , expressionIn ) ; } }
if ( ! sourceType . isSubtypeWithoutStructuralTyping ( targetType ) ) { TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , sourceType , targetType ) ; }
TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , argType , paramType ) ;
TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , rightType , leftType ) ;
TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , rightType , leftType ) ;
TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , caseType , switchType ) ;
if ( topInterface != null && topInterface . getConstructor () != null ) { foundType = topInterface . getPrototypeObject () ; }
if ( isPrototypeObject () ) { return builder . append ( getOwnerFunction () . getThisType () ) . append ( STRING_CONSTANT ) ; }
{ ObjectType obj = getObjTypeIfSingletonObj () ; return obj != null && obj . hasOwnProperty ( new QualifiedName ( propertyName ) ) ; }
if ( this . equals ( proto ) ) { Preconditions . checkState ( isBuiltinObjectPrototype () , STRING_CONSTANT , this ) ; return null ; }
test ( DEFAULT_EXTERNS + externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
testSets ( js , output , STRING_CONSTANT ) ;
NodeUtil . isNameDeclaration ( n ) && n . getFirstFirstChild () != null && n . getFirstFirstChild () . isFunction ()
return builder () . withCharset ( inputCharset ) . withOriginalPath ( originalZipPath + BANG_SLASH + entryPath ) . buildFromUrl ( zipEntryUrl ) ;
assertPasses ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
isNameDeclaration ( parent ) || parent . isExprResult ()
println ( STRING_CONSTANT , funType ) ;
reportCodeChange () ;
reportCodeChange () ;
testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendStringPart ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected void setUp () { style = RELAX ; }
@ Override public void setUp () { enableNormalize () ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
{ if ( options == null ) { initOptions ( new CompilerOptions () ) ; } return errorManager ; }
inputsById . clear () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
{ if ( options == null ) { initOptions ( newCompilerOptions () ) ; } return errorManager ; }
inputsById = new HashMap <> () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = errorManager ; }
Preconditions . checkState ( ! areSubtypes , STRING_CONSTANT , obj1 , obj2 ) ;
{ switch ( ch ) { case CHAR_CONS : case CHAR_CONS : return true ; default: return ch == NUMBER_CONSTANT || Character . isLetter ( ch ) ; } }
{ if ( options == null ) { initOptions ( new CompilerOptions () ) ; } return errorManager ; }
inputsById . clear () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
Preconditions . checkArgument ( callNode . isCall () , STRING_CONSTANT , callNode ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ; return options ; }
Node root = compiler . getJsRoot () ;
{ assertThat ( aggregateWarnings ) . named ( STRING_CONSTANT ) . isEmpty () ; }
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
public void testCodeMotionDoesntBreakFunctionHoisting ( ) throws Exception { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
private void testSameEs6Strict ( String js ) { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; test ( js , js , null , null ) ; }
public void testConst () { testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testLet () { testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testRewriteWarning ( code , expected , warning , LanguageMode.ECMASCRIPT3 ) ; testRewriteWarning ( code , expected , warning , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testRewriteError ( js , error , LanguageMode.ECMASCRIPT3 ) ; testRewriteError ( js , error , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testRewrite ( code , expected , LanguageMode.ECMASCRIPT3 ) ; testRewrite ( code , expected , LanguageMode.ECMASCRIPT_2015 ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; allowExternsChanges ( true ) ; }
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_NEXT ;
languageMode = LanguageMode.ECMASCRIPT_NEXT ;
public void testAsyncArrowFunction () { languageMode = LanguageMode.ECMASCRIPT_NEXT ; assertPrintSame ( STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_NEXT ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testMemberGeneratorYield1 () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testNewTarget () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDefaultParametersWithRestParameters () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testRestParameters () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDefaultParameters () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testOctalNumericKey () { allowWarnings = true ; languageMode = LanguageMode.ECMASCRIPT5 ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testComputedPropertiesClassMethods () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
{ assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrettyPrinter_defaultValue ( ) throws Exception { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testPrettyPrinter_arrow ( ) throws Exception { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testForOf () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDestructuringForOfLoops2 () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrintDestructuringInRestParam () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrintMixedDestructuring () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testPrettyPrintObjectPattern () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrintNestedObjectPattern () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testPrettyPrintArrayPattern () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrintBlockScopedFunctions () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExponentiationAssignmentOperator () { languageMode = LanguageMode.ECMASCRIPT_2016 ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2016 ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; compiler = createCompiler () ; }
public void testWhileLoopBranch ( ) throws Exception { compareWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareWhileLoopBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDoWhileLoopMultiLineBranch ( ) throws Exception { compareDoWhileLoopMultiLineBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopMultiLineBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDoWhileLoopBranch ( ) throws Exception { compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testForLoopBranch ( ) throws Exception { compareForLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareForLoopBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testIfElseBranch ( ) throws Exception { compareIfElseBranch ( LanguageMode.ECMASCRIPT5 ) ; compareIfElseBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testIfBranch ( ) throws Exception { compareIfBranch ( LanguageMode.ECMASCRIPT5 ) ; compareIfBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testFunction ( ) throws Exception { compareFunctionOneMode ( LanguageMode.ECMASCRIPT5 ) ; compareFunctionOneMode ( LanguageMode.ECMASCRIPT_2015 ) ; }
return languageOutIsAtLeast ( LanguageMode.ECMASCRIPT_2015 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
{ setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; }
{ testExternChanges ( extern , input , expectedExtern , LanguageMode.ECMASCRIPT_2015 ) ; testExternChanges ( extern , input , expectedExtern , LanguageMode.ECMASCRIPT5 ) ; }
{ testWarning ( js , expected , warning , LanguageMode.ECMASCRIPT_2015 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testWarning ( js , warning , warningMessage ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testWarning ( js , warning ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testWarning ( js , warning ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT_2015 ) ; testError ( js , error , LanguageMode.ECMASCRIPT5 ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT_2015 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testError ( js , es6Error ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testError ( js , es5Error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testError ( js , error ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testError ( js , error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( externs , js , diag , error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testSame ( externs , js , warning ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . test ( js , js ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . test ( js , js ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . test ( js , js ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
{ test ( js , expected , LanguageMode.ECMASCRIPT_2015 ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ test ( js , expected , LanguageMode.ECMASCRIPT_2015 ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; super . test ( js , expected ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . test ( js , expected ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; anchorUnusedVars = false ; canRemoveExterns = false ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; allowExternsChanges ( false ) ; }
{ CompilerOptions options = super . getOptions () ; options . setLanguageIn ( LanguageMode.ECMASCRIPT6_TYPED ) ; options . setLanguageOut ( LanguageMode.ECMASCRIPT_2015 ) ; return options ; }
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
{ super . setUp () ; compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ; compilerOptions . setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , VarCheck.VIOLATED_MODULE_DEP_ERROR ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , VarCheck.VIOLATED_MODULE_DEP_ERROR ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , VarCheck.MISSING_MODULE_DEP_ERROR ) ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , VarCheck.MISSING_MODULE_DEP_ERROR ) ; }
public void testLegalConstReferenceBetweenModules () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testLegalLetReferenceBetweenModules () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testObjLit () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; assertUnreachable ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testForLoopsEs6 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; assertUnreachable ( STRING_CONSTANT ) ; assertUnreachable ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public CheckUnusedPrivatePropertiesTest () { super ( EXTERNS ) ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; }
{ setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
{ compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
public void testFunctionNonMovement1 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; testSame ( createModuleStar ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
public void testInvalidVariableInScope () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_INVALID_VARIABLE ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_INVALID_VARIABLE ) ; }
public void testNonAliasLocal () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testJSDocCopiedForClasses () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectLiteralMethods () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectLiteralShorthand () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDefaultParameter () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition3 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition2 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition1 () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testArrowFunction () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testNonTopLevelDestructuring () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectDescructuringError2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testObjectDescructuringError1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testDestructuringError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testYieldExpression () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testScopedNoChanges ( aliases , code , LanguageMode.ECMASCRIPT3 ) ; testScopedNoChanges ( aliases , code , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testScoped ( code , expected , LanguageMode.ECMASCRIPT3 ) ; testScoped ( code , expected , LanguageMode.ECMASCRIPT_2015 ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testAsyncFunction () { setLanguage ( LanguageMode.ECMASCRIPT_NEXT , LanguageMode.ECMASCRIPT5 ) ; testError ( STRING_CONSTANT , CANNOT_CONVERT_YET ) ; testError ( STRING_CONSTANT , CANNOT_CONVERT_YET ) ; }
public void testExponentiationAssignmentOperator () { setLanguage ( LanguageMode.ECMASCRIPT_2016 , LanguageMode.ECMASCRIPT5 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExponentiationOperator () { setLanguage ( LanguageMode.ECMASCRIPT_2016 , LanguageMode.ECMASCRIPT5 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; runTypeCheckAfterProcessing = true ; }
setLanguage ( LanguageMode.ECMASCRIPT_NEXT , LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( LanguageMode.ECMASCRIPT_NEXT , LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( LanguageMode.ECMASCRIPT_NEXT , LanguageMode.ECMASCRIPT5 ) ;
public void testValidRestParameter () { setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; valid ( STRING_CONSTANT ) ; valid ( STRING_CONSTANT ) ; }
options . setLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
return CompilerOptions.LanguageMode.ECMASCRIPT_2015 ;
this . languageIn = CompilerOptions.LanguageMode.ECMASCRIPT_2015 ;
options . setLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageOut ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5_STRICT ) ;
compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
{ testError ( createFunction ( body ) ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testError ( createShorthandFunctionInObjLit ( body ) ) ; }
{ testOk ( createFunction ( body ) ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testOk ( createShorthandFunctionInObjLit ( body ) ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testEs6EnhancedObjLiteralsPropertyShorthand () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testEs6EnhancedObjLiteralsComputedValuesNotRemoved () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testES6ClassComputedProperty () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; }
public void testEs6GettersWithoutTranspilation () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; languageOut = LanguageMode.ECMASCRIPT3 ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( createShorthandFunctionInObjLit ( returnType , body ) ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; String js = createShorthandFunctionInObjLit ( returnType , body ) ; testWarning ( js , CheckMissingReturn.MISSING_RETURN_STATEMENT ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; compareJsDoc = true ; }
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
public void testNoMoveDeepFunctionDeclarations () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testInlineEmptyFunction6 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrowFunction4 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testFailure ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrowFunction3 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testFailure ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrowFunction2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testFailure ( STRING_CONSTANT ) ; }
public void testArrowFunction1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testFailure ( STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; runTypeCheckAfterProcessing = true ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
public void testTaggedTemplateError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; }
public void testInlineIntoNestedNonHoistedNamedFunctions () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNoRewriteIfNotInGlobalScope1 ( ) throws Exception { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT + NoRewriteIfNotInGlobalScopeTestInput.INPUT + STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; compareJsDoc = true ; }
replaceSymbol ( t , n , name , t . getInput () ) ;
com.google.javascript.jscomp.newtypes.FunctionType ctorType = functionType == null ? null : functionType . getFunTypeIfSingletonObj () ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
{ checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
checkState ( child.parent == this , STRING_CONSTANT , child , parent ) ;
testSame ( STRING_CONSTANT ) ;
replaceSymbol ( n , name , t . getInput () ) ;
findDeclaredNames ( t , functionBody , renamer , false ) ;
if ( ! declarationRoot . isFunction () ) { findDeclaredNames ( t , declarationRoot , renamer , false ) ; }
testSameEs6 ( STRING_CONSTANT ) ;
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; enableTypeCheck () ; }
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
checkState ( child.parent == this ) ;
{ Preconditions . checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
checkState ( child.parent == this , STRING_CONSTANT , child , parent ) ;
{ checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
Preconditions . checkState ( this . isFrozen , STRING_CONSTANT , this ) ;
{ Preconditions . checkState ( ! this . isFrozen ) ; super . addUndeclaredProperty ( pname , defSite , this . commonTypes . UNKNOWN , false ) ; }
{ Preconditions . checkState ( ! this . isFrozen ) ; super . addProperty ( pname , defSite , type , isConstant ) ; }
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( this . isFrozen ) ;
if ( ! this . isFrozen ) { return null ; }
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
public boolean isStruct () { Preconditions . checkState ( isFrozen () || isClass () ) ; return this . objectKind . isStruct () ; }
{ if ( isFrozen && externs . containsKey ( name ) ) { type = externs . get ( name ) ; } }
Preconditions . checkState ( isFrozen ) ;
Preconditions . checkState ( this . rawType . isFrozen () ) ;
{ Preconditions . checkState ( this . rawType . isFrozen () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
Preconditions . checkState ( this . rawType . isFrozen () ) ;
public RawNominalType getRawNominalType () { Preconditions . checkState ( ! this . rawType . isFrozen () ) ; return this . rawType ; }
Preconditions . checkArgument ( nominalType . isFrozen () ) ;
Preconditions . checkArgument ( nominalType . isFrozen () ) ;
if ( ! thisNode . isEquivalentWithSideEffectsToShallow ( thatNode ) ) { return false ; }
ScopedChangeHandler () { this . lastCodeChangeQuery = compiler . getChangeStamp () ; }
maybeSanityCheck ( name , externs , root ) ;
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override protected void setUp () { super . enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override protected void setUp () { nameGenerator = null ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { super . enableLineNumberCheck ( false ) ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
public InlineVariablesConstantsTest () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; validateAstChangeMarking ( false ) ; }
@ Override protected void setUp () { super . enableLineNumberCheck ( false ) ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
globalScope = TypedScope . createGlobalScope ( rootNode ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope , true ) ; }
setReferencedType ( new NoResolvedType ( registry , getReferenceName () , getTemplateTypes () ) ) ;
@ Override public void setUp () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
{ Node grandparent = parent . getParent () ; replaceWithEmpty ( parent , grandparent ) ; compiler . reportChangeToEnclosingScope ( grandparent ) ; }
@ Override public final boolean isUnresolved () { return false ; }
final JSTypes getCommonTypes () { return this . commonTypes ; }
compiler . reportChangeToEnclosingScope ( block ) ;
compiler . reportChangeToEnclosingScope ( assign ) ;
compiler . reportChangeToEnclosingScope ( newBody ) ;
{ newBlockNode . useSourceInfoIfMissingFromForTree ( oldBlockNode ) ; functionNode . replaceChild ( oldBlockNode , newBlockNode ) ; compiler . reportChangeToEnclosingScope ( newBlockNode ) ; }
if ( ! origValueNode . getString () . equals ( newString ) ) { origValueNode . setString ( newString ) ; compiler . reportChangeToEnclosingScope ( origValueNode ) ; }
if ( newValue != msgNode ) { newValue . useSourceInfoIfMissingFromForTree ( msgNode ) ; msgNode . replaceWith ( newValue ) ; compiler . reportChangeToEnclosingScope ( newValue ) ; }
this . mode = TypeInferenceMode.BOTH ;
public void testCoercionSubstitution_boxedNumberVsZero () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
compiler . reportChangeToEnclosingScope ( parent ) ;
{ Node retValue = returnedValue . cloneTree () ; parent . replaceChild ( call , retValue ) ; compiler . reportChangeToEnclosingScope ( retValue ) ; }
compiler . reportChangeToEnclosingScope ( getProp ) ;
if ( ! p.newName . equals ( oldName ) ) { n . setString ( p.newName ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; }
compiler . reportChangeToEnclosingScope ( newQualifiedNameNode ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( binaryNamespaceExportNode ) ;
compiler . reportChangeToEnclosingScope ( jsdocNode ) ;
compiler . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( var ) ;
if ( ! collapses . isEmpty () ) { applyCollapses () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ callTarget . getLastChild () . setString ( STRING_CONSTANT ) ; firstArg . getNext () . detach () ; compiler . reportCodeChange () ; return n ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; compiler . reportCodeChange () ; return newNode ; }
if ( rhs . isChanged () ) { compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . replaceChild ( placeholder , mNode . getNode () . removeFirstChild () ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detach () ; compiler . reportCodeChange () ; return null ; }
this . compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; compiler . reportCodeChange () ; return newLiteralNode ; }
if ( canFoldStandardConstructors ( n ) ) { n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ parent . removeChild ( n ) ; compiler . reportChangeToEnclosingScope ( parent ) ; functions . put ( t . getModule () , n ) ; }
if ( codeChanged ) { compiler . reportCodeChange () ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( stringNode ) ;
compiler . reportChangeToEnclosingScope ( objNode ) ;
compiler . reportChangeToEnclosingScope ( objNode ) ;
t . getCompiler () . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( and ) ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; compiler . reportCodeChange () ; return result ; }
compiler . reportCodeChange () ;
{ n . detachChildren () ; parent . replaceChild ( n , result ) ; compiler . reportCodeChange () ; return result ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; compiler . reportCodeChange () ; return replacementNode ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; compiler . reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; compiler . reportCodeChange () ; return null ; }
for ( Node childToRemove : nodesToRemove ) { node . removeChild ( childToRemove ) ; compiler . reportCodeChange () ; }
compiler . reportChangeToEnclosingScope ( rhs ) ;
@ Override protected void setUp () { allowExternsChanges ( true ) ; }
compiler . reportChangeToEnclosingScope ( var ) ;
void apply () { parent . replaceChild ( oldChild , newChild ) ; compiler . reportChangeToEnclosingScope ( newChild ) ; }
compiler . reportChangeToEnclosingScope ( addingRoot ) ;
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; }
compiler . reportChangeToEnclosingScope ( classDeclaration ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( outerBlock ) ;
{ n . setString ( newName ) ; t . getCompiler () . reportChangeToEnclosingScope ( n ) ; return; }
public InlineVariablesConstantsTest () { enableNormalize () ; }
{ n . setString ( prop + fileid ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
compiler . reportChangeToEnclosingScope ( getKey . getParent () ) ;
@ Override protected void setUp () { super . enableLineNumberCheck ( false ) ; }
compiler . reportChangeToEnclosingScope ( parent ) ;
if ( node != null ) { n . setDeclaredTypeExpression ( node ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
{ attachTypeExpr = IR . rest ( n . getString () ) ; n . replaceWith ( attachTypeExpr ) ; compiler . reportChangeToEnclosingScope ( attachTypeExpr ) ; }
compiler . reportChangeToEnclosingScope ( node ) ;
compiler . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( propstmt ) ;
{ if ( NodeUtil . getPureBooleanValue ( forCondition ) == TernaryValue.TRUE ) { forCondition . replaceWith ( IR . empty () ) ; compiler . reportCodeChange () ; } }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; compiler . reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ maybeBreak . detach () ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; compiler . reportCodeChange () ; return right ; }
compiler . reportChangeToEnclosingScope ( callSite.parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.ADDING_PROPERTY_TO_NON_OBJECT ) ;
@ Override protected void setUp () { super . enableNormalize () ; }
compiler . reportChangeToEnclosingScope ( ref ) ;
compiler . reportChangeToEnclosingScope ( varNode ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
for ( Node closureRequire : requiresToBeRemoved ) { compiler . reportChangeToEnclosingScope ( closureRequire ) ; closureRequire . detach () ; }
notifyOfRemoval ( node , parent ) ;
{ parent . removeChild ( node ) ; notifyOfRemoval ( node , parent ) ; }
@ Override public void setUp () { enableNormalize () ; }
{ functionBody . removeChild ( current ) ; insertAfter = addToFront ( functionBody , current , insertAfter ) ; reportCodeChange ( functionBody , STRING_CONSTANT ) ; }
reportCodeChange ( n , STRING_CONSTANT ) ;
reportCodeChange ( n , STRING_CONSTANT ) ;
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
scope . isFunctionScope ()
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( global.root ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( varNode ) ;
@ Override public void setUp () { enableNormalize () ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( genBlock ) ;
if ( maybeNormalizeFunctionDeclaration ( n , compiler ) ) { reportCodeChange ( n , STRING_CONSTANT ) ; }
compiler . reportChangeToEnclosingScope ( var ) ;
compiler . reportChangeToEnclosingScope ( result ) ;
compiler . reportChangeToEnclosingScope ( newBlock ) ;
compiler . reportChangeToEnclosingScope ( newFor ) ;
compiler . reportChangeToEnclosingScope ( name ) ;
compiler . reportChangeToEnclosingScope ( stringKey ) ;
compiler . reportChangeToEnclosingScope ( init ) ;
compiler . reportChangeToEnclosingScope ( assign ) ;
compiler . reportChangeToEnclosingScope ( mathDotPowCall ) ;
compiler . reportChangeToEnclosingScope ( initSymbol ) ;
{ return new DevirtualizePrototypeMethods ( compiler ) ; }
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
n . isName () && NodeUtil . isNameDeclaration ( n . getParent () )
Iterable < JSModule > getAllModules () { return modules ; }
compiler . setChangeScope ( null ) ;
initTraversal ( root ) ;
initTraversal ( scopeRoot ) ;
initTraversal ( root ) ;
compiler . reportChangeToEnclosingScope ( exportCall ) ;
compiler . reportChangeToEnclosingScope ( expression ) ;
compiler . reportChangeToEnclosingScope ( objLit ) ;
compiler . reportChangeToEnclosingScope ( expression ) ;
{ c . setQuotedString () ; compiler . reportChangeToEnclosingScope ( c ) ; }
@ Override public void setUp () { super . enableLineNumberCheck ( false ) ; }
{ Node dollarChildProp = n . getGrandparent () ; dollarChildProp . setToken ( Token.GETELEM ) ; compiler . reportChangeToEnclosingScope ( dollarChildProp ) ; }
compiler . reportChangeToEnclosingScope ( stmt ) ;
@ Override public void setUp () { enableNormalize () ; }
@ Override public void setUp () { enableNormalize () ; }
compiler . reportChangeToEnclosingScope ( assign ) ;
compiler . reportChangeToEnclosingScope ( stmts ) ;
compiler . reportChangeToEnclosingScope ( stmts ) ;
compiler . reportChangeToEnclosingScope ( fnNameNode ) ;
{ parent . replaceChild ( n , declaringNode . getFirstFirstChild () . cloneTree () ) ; t . reportCodeChange () ; }
{ if ( isUtilGetDefineCall ( n ) ) { substituteUtilGetDefine ( t , n ) ; } }
t . reportCodeChange () ;
t . reportCodeChange () ;
t . reportCodeChange () ;
if ( isGoogLoadModuleStatement ( n ) ) { updateGoogLoadModuleLate ( t , n ) ; }
{ n . putBooleanProp ( Node.GOOG_MODULE , true ) ; inlineModuleIntoGlobal ( n ) ; t . reportCodeChange () ; checkAndSetStrictModeDirective ( t , n ) ; }
if ( newJsdoc != null ) { jsdocNode . setJSDocInfo ( newJsdoc ) ; t . reportCodeChange () ; }
t . reportCodeChange () ;
{ if ( NodeUtil . isDestructuringDeclaration ( n ) ) { splitDeclaration ( t , n , parent ) ; } }
reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( lastAncestor ) ;
reportCodeChange () ;
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; reportCodeChange () ; return null ; }
for ( Node childToRemove : nodesToRemove ) { node . removeChild ( childToRemove ) ; reportCodeChange () ; }
t . reportCodeChange () ;
t . reportCodeChange () ;
{ visitArrowFunction ( t , n , checkNotNull ( thisContext ) ) ; }
if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; reportCodeChange () ; return newNode ; }
if ( rhs . isChanged () ) { reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( placeholder , mNode . getNode () . removeFirstChild () ) ; reportCodeChange () ; }
reportCodeChange () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detach () ; reportCodeChange () ; return null ; }
this . reportCodeChange () ;
reportCodeChange () ;
t . reportCodeChange () ;
if ( tryReplaceArguments ( traversal . getScope () ) ) { traversal . reportCodeChange () ; }
reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( injectionPointParent ) ;
compiler . reportChangeToEnclosingScope ( expressionRoot ) ;
t . reportCodeChange () ;
t . reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
if ( canFoldStandardConstructors ( n ) ) { n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
t . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( newValue ) ;
compiler . reportChangeToEnclosingScope ( newNode ) ;
t . reportCodeChange () ;
t . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( parent ) ;
visitClass ( t , n , parent ) ;
visitRestParam ( t , n , parent ) ;
reportCodeChange () ;
{ if ( NodeUtil . getPureBooleanValue ( forCondition ) == TernaryValue.TRUE ) { forCondition . replaceWith ( IR . empty () ) ; reportCodeChange () ; } }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
{ maybeBreak . detach () ; reportCodeChange () ; }
reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; reportCodeChange () ; return right ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ callTarget . getLastChild () . setString ( STRING_CONSTANT ) ; firstArg . getNext () . detach () ; reportCodeChange () ; return n ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
t . reportCodeChange () ;
JSTypeExpression typeExpr = getTypeFromGetterOrSetter ( member ) . copy () ;
{ if ( expr != null ) { return cloneTypeNodes ? expr . copy () : expr ; } return null ; }
if ( foundObj . isGenericObjectType () ) { foundType = foundObj . getRawType () ; }
ImmutableMap < String , TypeI > typeVars
if ( obj != null && obj . isGenericObjectType () ) { return obj . instantiateGenericsWithUnknown () ; }
if ( foundType != null && foundType . isGenericObjectType () ) { foundType = foundType . getRawType () ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new PropagateConstJsdoc () ) ; new RemoveCode ( compiler ) . process ( externs , root ) ; }
@ Override public void setUp () { enableNormalize () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
TypeI type = n . getTypeI () ;
TypeI type = n . getTypeI () ;
if ( extractionInfo . shouldExtract () ) { doExtraction ( extractionInfo ) ; }
compiler . reportChangeToEnclosingScope ( objectLit ) ;
{ if ( logger . isLoggable ( Level.FINE ) ) { logger . fine ( STRING_CONSTANT + callName ) ; } inlineEmptyMethod ( t , parent , callNode ) ; }
compiler . reportChangeToEnclosingScope ( addingRoot ) ;
compiler . reportChangeToEnclosingScope ( body ) ;
compiler . reportChangeToEnclosingScope ( inheritsExpressionResult ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
for ( Definition def : definitionsGatherer.definitions ) { def . remove ( compiler ) ; }
if ( codeChanged ) { reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; reportCodeChange () ; return result ; }
reportCodeChange () ;
{ n . detachChildren () ; parent . replaceChild ( n , result ) ; reportCodeChange () ; return result ; }
reportCodeChange () ;
reportCodeChange () ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; reportCodeChange () ; return replacementNode ; }
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; reportCodeChange () ; }
if ( options . getInstrumentForCoverageOnly () ) { instrumentForCoverage ( options.instrumentBranchCoverage ) ; return; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
if ( Keywords . isKeyword ( idToken.value ) && ! Keywords . isTypeScriptSpecificKeyword ( idToken.value ) ) { reportError ( STRING_CONSTANT , name ) ; }
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null ) ;
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null ) ;
optimizer = new PhaseOptimizer ( compiler , tracker ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null ) ;
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null ) ;
if ( typeWithBannedProp . isSubtypeWithoutStructuralTyping ( foundType ) ) { if ( matchesPrototype ( typeWithBannedProp , foundType ) ) { return ConformanceResult.VIOLATION ; } else if ( reportLooseTypeViolations ) { return ConformanceResult.POSSIBLE_VIOLATION_DUE_TO_LOOSE_TYPES ; } }
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
t . reportCodeChange () ;
t . reportCodeChange () ;
{ clazz . replaceChild ( clazz . getFirstChild () , IR . empty () . useSourceInfoFrom ( clazz . getFirstChild () ) ) ; t . reportCodeChange () ; }
t . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( root ) ;
t . reportCodeChange () ;
if ( n . getLineno () == NUMBER_CONSTANT ) { n . setCharno ( n . getCharno () - NUMBER_CONSTANT ) ; t . reportCodeChange () ; }
AbstractCompiler compiler
reportChangeToEnclosingScope ( parent ) ;
t . reportCodeChange () ;
t . reportCodeChange () ;
t . reportCodeChange () ;
t . reportCodeChange () ;
{ if ( isMethodOrCtorCallThatTriggersRemoval ( t , n , parent ) ) { replaceHighestNestedCallWithNull ( t , n , parent ) ; } }
if ( parent . getFirstChild () == n && isReferenceToRemovedVar ( t , n ) ) { replaceHighestNestedCallWithNull ( t , parent , parent . getParent () ) ; }
{ n . setString ( newName ) ; t . reportCodeChange () ; return; }
maybeRewriteClassDefinition ( t , n ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , InliningMode.DIRECT ) ;
this . mode = TypeInferenceMode.OTI_ONLY ;
public PeepholeFoldConstantsTest () { super ( DEFAULT_EXTERNS ) ; }
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
@ Override public void setUp () { setLanguage ( ECMASCRIPT_NEXT , ECMASCRIPT_NEXT ) ; behavior = null ; }
Iterable < JSModule > getAllModules () { return modules ; }
tightenNameTypeAndDontWarn ( varName , expr , declType , inferredType , requiredType )
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT , STRING_CONSTANT ) , InliningMode.DIRECT ) ;
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
{ currentLocationAbstractionIdentifier = locationAbstractionIdentifier ; testSame ( SHARED_EXTERNS , js , null ) ; currentJsRoot = getLastCompiler () . jsRoot ; return currentAnalysis ; }
List < TypeMismatch > actual = ImmutableList . copyOf ( getLastCompiler () . getTypeMismatches () ) ;
JSTypeRegistry registry = getLastCompiler () . getTypeRegistry () ;
JSTypeRegistry registry = getLastCompiler () . getTypeRegistry () ;
JSTypeRegistry registry = getLastCompiler () . getTypeRegistry () ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , findFunction ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , findParameter ) ;
NodeUtil . isCompoundAssignmentOp ( n ) || n . isInc () || n . isDec ()
if ( NodeUtil . isCompoundAssignmentOp ( n ) ) { normalizeAssignShorthand ( n ) ; }
bundler . appendTo ( out , input , input . getSourceFile () . getCode () ) ;
sourceMapOriginalSources . putIfAbsent ( path , originalSourcesLoader . loadSource ( path ) ) ;
ExternalSourceLoader originalSourcesLoader
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
readInputs () ;
{ ensureRequirementIsMutable () ; com.google.protobuf.AbstractMessageLite.Builder . addAll ( values , requirement_ ) ; onChanged () ; }
catch ( com.google.protobuf.InvalidProtocolBufferException e ) { parsedMessage = ( com.google.javascript.jscomp.ConformanceConfig ) e . getUnfinishedMessage () ; throw e . unwrapIOException () ; }
private void maybeForceBuilderInitialization () { if ( com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ) { getRequirementFieldBuilder () ; } }
private Builder ( com.google.protobuf.GeneratedMessageV3.BuilderParent parent ) { super ( parent ) ; maybeForceBuilderInitialization () ; }
com.google.protobuf.GeneratedMessageV3.BuilderParent parent
{ return com.google.protobuf.GeneratedMessageV3 . parseWithIOException ( PARSER , input , extensionRegistry ) ; }
{ return com.google.protobuf.GeneratedMessageV3 . parseDelimitedWithIOException ( PARSER , input , extensionRegistry ) ; }
{ return com.google.protobuf.GeneratedMessageV3 . parseWithIOException ( PARSER , input , extensionRegistry ) ; }
public void testInlineInFunction1 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( n . isAsyncFunction () ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT ) , InliningMode.DIRECT ) ;
NodeUtil . isNameDeclaration ( declaration ) && declaredVarOrProp . isName ()
assertGetNameResult ( parent . getLastChild () , STRING_CONSTANT ) ;
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; assertGetNameResult ( parent . getFirstChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; assertGetNameResult ( parent . getLastChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; assertGetNameResult ( parent . getFirstChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) ; assertGetNameResult ( parent . getFirstChild () , STRING_CONSTANT ) ; }
if ( sanityCheck != null ) { changeVerifier = new ChangeVerifier ( compiler ) . snapshot ( jsRoot ) ; }
{ sanityCheck . create ( compiler ) . process ( externs , root ) ; changeVerifier . checkRecordedChanges ( passName , jsRoot ) ; }
if ( n . getFirstChild () . matchesQualifiedName ( Es6RewriteClass.INHERITS ) ) { inheritsCalls . add ( n ) ; }
parent . replaceChild ( node , NodeUtil . newUndefinedNode ( node ) ) ;
compiler . performOptimizations () ;
n . isName () && NodeUtil . isNameDeclaration ( searchIt . currentParent () ) && n . getString () . equals ( STRING_CONSTANT )
( NodeUtil . isNameDeclaration ( declaration . getParent () ) && ! NodeUtil . isLoopStructure ( declaration . getGrandparent () ) )
public HierarchicalSet ( HierarchicalSet < T > parent ) { this . parent = parent ; }
clinitsCalledAtBranch = new HierarchicalSet <> ( clinitsCalledAtBranch ) ;
JSType declType = this . currentScope . getDeclaredTypeOf ( name ) ;
NTIScope innerScope = this . currentScope . getScope ( fnName ) ;
lhs . isName () && this . currentScope . isConstVar ( lhs . getString () )
if ( ! this . currentScope . hasThis () ) { return new EnvTypePair ( inEnv , UNKNOWN ) ; }
return expr . isNew () || ( expr . isCall () && this . currentScope . isConstructor () && expr . getFirstChild () . isSuper () ) ;
JSType declType = this . currentScope . getDeclaredTypeOf ( name ) ;
JSType declRetType = this . currentScope . getDeclaredFunctionType () . getReturnType () ;
guardA . addGuard ( visibilityOff ) ;
checkState ( val . isObjectLit () , val ) ;
checkState ( object . isObjectLit () , object ) ;
checkState ( parent . getFirstChild () == name ) ;
Preconditions . checkState ( val . isObjectLit () ) ;
Preconditions . checkState ( object . isObjectLit () ) ;
Preconditions . checkState ( parent . getFirstChild () == name ) ;
checkState ( val . isObjectLit () , val ) ;
checkState ( object . isObjectLit () , object ) ;
checkState ( parent . getFirstChild () == name ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( ! t . getScope () . isHoistScope () ) { return; }
public InlineVariablesTest () { enableNormalize () ; setAcceptedLanguage ( ECMASCRIPT_NEXT ) ; }
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
@ Override void reportChangeToEnclosingScope ( Node n ) { recordChange ( getChangeScopeForNode ( n ) ) ; notifyChangeHandlers () ; }
{ return precedence ( n ) < minPrecedence ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
{ return NodeUtil . precedence ( n . getToken () ) < minPrecedence ; }
{ invalidatingPropRef = ! isValidCandidateDefinition ( t , n , parent ) ; }
TypeI type
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
checkArgument ( child.parent == null , STRING_CONSTANT , child , parent , this ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
checkState ( ! maybeDecl . isInitializingDeclaration () ) ;
checkState ( references . get ( NUMBER_CONSTANT ) . isDeclaration () ) ;
{ deepestModule = graph . getSmallestCoveringDependency ( ImmutableList . of ( m , deepestModule ) ) ; }
{ return precedence ( n ) < minPrecedence ; }
checkNotNull ( js ) ;
checkState ( collectionRoot . isScript () || collectionRoot . isRoot () ) ;
{ checkNotNull ( options ) ; return warningsGuard . level ( error ) ; }
{ checkState ( changeScopeRoot . isScript () || changeScopeRoot . isFunction () ) ; recordChange ( changeScopeRoot ) ; notifyChangeHandlers () ; }
if ( currentChangeScope != null ) { checkState ( currentChangeScope . isScript () || currentChangeScope . isFunction () ) ; recordChange ( currentChangeScope ) ; }
checkState ( passes instanceof DefaultPassConfig , STRING_CONSTANT ) ;
checkState ( input . isExtern () , STRING_CONSTANT , input . getName () ) ;
checkState ( currentTracer != null , STRING_CONSTANT ) ;
checkState ( currentTracer == null ) ;
{ checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
if ( ! compiler . hasErrors () ) { compiler . stage1AndStage2Passes () ; compiler . completeCompilation () ; }
if ( ! compiler . hasErrors () ) { compiler . stage1AndStage2Passes () ; compiler . completeCompilation () ; }
blockStack . get ( i ) . getRoot () == containingScope . getRootNode ()
if ( clone == null ) { verifyNewNode ( passNameMsg , n ) ; } else { verifyNodeChange ( passNameMsg , n , clone ) ; }
grandparent == null || ( ! isPrototypePropertyDeclaration ( grandparent ) && ! isPropertyDeclarationOnThis ( parent . getFirstChild () , currentScope ) )
Reference aliasRef = aliasRefs.references . get ( i ) ;
Reference ref
maybeTemporarilyLiveNodes . add ( expr ) ;
node . matchesQualifiedName ( name )
@ Nullable String newName
public InlineObjectLiteralsTest () { enableNormalize () ; setAcceptedLanguage ( ECMASCRIPT_NEXT ) ; }
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
{ return fromFile ( file , UTF_8 ) ; }
{ parent . detach () ; }
qNameRoot != null && qNameRoot . matchesQualifiedName ( EXPORTS ) && NodeUtil . isLValue ( qNameRoot )
callbackBlock . detach () ;
onlyExport . detach () ;
@ Override public boolean isPropertyTestFunction ( Node call ) { return call . getFirstChild () . matchesQualifiedName ( STRING_CONSTANT ) ; }
boolean isInClass = n . getParent () . isClassMembers () ;
{ parent . detach () ; }
{ n . detach () ; }
{ if ( alreadyRemoved ( n ) ) { continue; } compiler . reportChangeToEnclosingScope ( n ) ; n . detach () ; }
if ( defined ) { compiler . reportChangeToEnclosingScope ( vnode . getParent () ) ; vnode . detach () ; }
assignmentParent . detach () ;
return parent != null && parent . isAssign () && parent . getFirstChild () == n ;
{ parent . removeChild ( n ) ; if ( ! parent . hasChildren () ) { parent . detach () ; } }
return enclosingNode != null && ! enclosingNode . isFunction () ;
if ( ! anc . getFirstChild () . matchesQualifiedName ( name ) ) { return Ref.Type.ALIASING_GET ; }
Node block = t . getScopeRoot () ;
isASTNormalized () && constructorNameNode . isName ()
parent . detach () ;
{ if ( isNamespacePlaceholder ( parent ) ) { compiler . reportChangeToEnclosingScope ( parent ) ; parent . detach () ; } }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
checkState ( ! name . equals ( ARGUMENTS ) ) ;
checkArgument ( ! idPrefix . isEmpty () ) ;
{ checkState ( n . isName () , n ) ; n . setString ( newName ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
if ( currentScript.isModule ) { rewriteShortObjectKey ( t , n ) ; }
{ testWarning ( js , warning , LanguageMode.ECMASCRIPT_2015 ) ; }
shouldRemove ( t , nameNode )
if ( isConstToBeInferred ( jsdoc , name , false ) ) { jsdoc = pullJsdocTypeFromAst ( compiler , jsdoc , name ) ; }
CrossModuleReferenceCollector collector
CrossModuleReferenceCollector collector
CrossModuleReferenceCollector collector
public void testNgInjectAddsInjectToClassConstructor ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
{ if ( null == str ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . str = str . intern () ; }
this . quoteKeywordProperties = options . shouldQuoteKeywordProperties () ;
options . assumeStrictThis () || options . getLanguageIn () == ECMASCRIPT5_STRICT
if ( options . shouldAmbiguateProperties () && options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED ) { passes . add ( ambiguateProperties ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
CrossModuleReferenceCollector collector = new CrossModuleReferenceCollector ( compiler , new Es6SyntacticScopeCreator ( compiler ) ) ;
@ Override public void setUp () { setLanguage ( ECMASCRIPT_NEXT , ECMASCRIPT_NEXT ) ; }
public CompilerOptions setEmitUseStrict ( boolean emitUseStrict ) { this . emitUseStrict = Optional . of ( emitUseStrict ) ; return this ; }
builder . setTagAsStrict ( firstOutput && options . shouldEmitUseStrict () ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT , error.description ) ;
assertEquals ( STRING_CONSTANT , error.description ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal t = new NodeTraversal ( compiler , finder , SyntacticScopeCreator . makeUntyped ( compiler ) ) ;
NodeTraversal t = new NodeTraversal ( compiler , null , new Es6SyntacticScopeCreator ( compiler ) ) ;
checkState ( reference . isName () ) ;
if ( checkUnusedLocals && unusedAssignment != null && ! isRead && ! hasErrors ) { checkForUnusedLocalVar ( v , unusedAssignment ) ; }
options . assumeStrictThis () || options . isStrictModeInput ()
ObjectsBuilder newObjs = new ObjectsBuilder () ;
public RemoveSuperMethodsPassTest () { super ( DEFAULT_EXTERNS ) ; }
while ( s.parent != null ) { if ( s . isDefinedLocally ( varName , false ) ) { return false ; } s = s.parent ; }
catch ( MaxIterationsExceededException e ) { assertEquals ( STRING_CONSTANT + MAX_STEP + STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalStateException e ) { assertEquals ( FixedPointGraphTraversal.NON_HALTING_ERROR_MSG , e . getMessage () ) ; }
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , builder ) ; }
options . assumeStrictThis () || options . getLanguageIn () == ECMASCRIPT5_STRICT
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , registry , builder ) ; }
catch ( IOException e ) { compiler . report ( JSError . make ( COULD_NOT_DESERIALIZE_AST , filename ) ) ; }
options . assumeStrictThis () || options . isStrictModeInput ()
! NodeUtil . isValidQualifiedName ( compiler . getOptions () . getLanguageOut () , name )
key . isStringKey () && ! key . isQuotedString () && NodeUtil . isValidPropertyName ( compiler . getOptions () . getLanguageOut () , key . getString () )
public CompilerOptions setStrictModeInput ( boolean isStrictModeInput ) { this . isStrictModeInput = Optional . of ( isStrictModeInput ) ; return this ; }
Config.StrictMode strictMode = options . expectStrictModeInput () ? Config.StrictMode.STRICT : Config.StrictMode.SLOPPY ;
if ( options . expectStrictModeInput () ) { options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.ERROR ) ; }
return new InlineFunctions ( compiler , compiler . getUniqueNameIdSupplier () , options.inlineFunctions , options.inlineLocalFunctions , true , options . assumeStrictThis () || options . expectStrictModeInput () , options.assumeClosuresOnlyCaptureReferences , options.maxFunctionSizeAfterInlining ) ;
! NodeUtil . isValidQualifiedName ( compiler . getLanguageMode () , name )
Pattern . compile ( STRING_CONSTANT )
! NodeUtil . isValidQualifiedName ( compiler . getOptions () . getLanguageIn () , name )
key . isStringKey () && ! key . isQuotedString () && NodeUtil . isValidPropertyName ( compiler . getOptions () . getLanguageIn () , key . getString () )
String finalMessage = STRING_CONSTANT + message ;
STRING_CONSTANT + number + ( ! supported ? STRING_CONSTANT : STRING_CONSTANT ) + ( es6Modules ? STRING_CONSTANT : STRING_CONSTANT ) + ( typeScript ? STRING_CONSTANT : STRING_CONSTANT ) + STRING_CONSTANT
( ( FeatureSet ) other ) . supported == supported
this . number >= other.number && ( ! this . supported || other.supported )
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
{ if ( mockToString ) { return STRING_CONSTANT ; } return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
{ parent . replaceChild ( assignNode , IR . number ( NUMBER_CONSTANT ) . srcref ( assignNode ) ) ; }
builder . append ( STRING_CONSTANT ) ;
MemoizedTypedScopeCreator scopeCreator
MemoizedTypedScopeCreator getTypedScopeCreator () { return typedScopeCreator ; }
typedScopeCreator = new MemoizedTypedScopeCreator ( internalScopeCreator ) ;
scopeCreator = new MemoizedTypedScopeCreator ( new TypedScopeCreator ( compiler ) ) ;
MemoizedTypedScopeCreator scopeCreator
MemoizedTypedScopeCreator typedScopeCreator = getTypedScopeCreator () ;
{ foundNodes . add ( name ) ; }
{ this . names = names ; foundNodes = new HashSet <> () ; }
checkState ( inputs.length > NUMBER_CONSTANT ) ;
List < SourceFile > externsInputs = maybeCreateSources ( STRING_CONSTANT , externs ) ;
test ( compiler , null , createSources ( STRING_CONSTANT , expected ) , error , warning ) ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; disableMultistageCompilation () ; }
validateFeature ( Feature.NAMESPACE_DECLARATION , n ) ;
{ validateFeature ( Feature.AMBIENT_DECLARATION , n ) ; validateNodeType ( Token.DECLARE , n ) ; validateAmbientDeclarationHelper ( n . getFirstChild () ) ; }
{ validateFeature ( Feature.TYPE_ALIAS , n ) ; validateNodeType ( Token.TYPE_ALIAS , n ) ; validateChildCount ( n ) ; }
validateFeature ( Feature.ARROW_FUNCTIONS , n ) ;
validateFeature ( Feature.CLASSES , n ) ;
validateFeature ( Feature.INTERFACE , n ) ;
validateFeature ( Feature.TEMPLATE_LITERALS , n ) ;
validateFeature ( Feature.TEMPLATE_LITERALS , n ) ;
validateFeature ( Feature.MODULES , n ) ;
{ validateFeature ( Feature.ASYNC_FUNCTIONS , n ) ; validateNodeType ( Token.AWAIT , n ) ; validateWithinAsyncFunction ( n ) ; }
validateFeature ( Feature.GENERATORS , n ) ;
setFeatureSet ( options . getLanguageIn () . toFeatureSet () ) ;
this . setFeatureSet ( options . getLanguageIn () . toFeatureSet () ) ;
{ Compiler compiler = new Compiler () ; compiler . setFeatureSet ( acceptedLanguage . toFeatureSet () ) ; return compiler ; }
{ if ( options.skipNonTranspilationPasses ) { whitespaceOnlyPasses () ; if ( options . needsTranspilationFrom ( FeatureSet.ES6 ) ) { transpileAndDontCheck () ; } } else { check () ; } }
compiler . getOptions () . needsTranspilationFrom ( FeatureSet.ES6 )
compiler . getOptions () . needsTranspilationFrom ( FeatureSet.ES6 )
Node root2 = compiler . parseSyntheticCode ( STRING_CONSTANT , source ) ;
if ( options.dartPass && ! options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
options.rewritePolyfills = flags.rewritePolyfills && options . getLanguageIn () . toFeatureSet () . contains ( FeatureSet.ES6 ) ;
return replaceNode ( n , minCond . getMinimized ( MinimizationStyle.PREFER_UNNEGATED ) ) ;
int precedence
expectFeatures ( Feature.DESTRUCTURING , Feature.ARRAY_PATTERN_REST ) ;
{ Preconditions . checkState ( script . isScript () ) ; if ( TranspilationPasses . isScriptEs6OrHigher ( script ) ) { return true ; } }
isScriptEs6OrHigher ( scriptRoot )
isScriptEs6OrHigher ( singleRoot )
{ if ( isScriptEs6OrHigher ( scriptRoot ) ) { for ( Callback callback : callbacks ) { NodeTraversal . traverseEs6 ( compiler , scriptRoot , callback ) ; } } }
{ if ( isScriptEs6OrHigher ( singleRoot ) ) { for ( Callback callback : callbacks ) { NodeTraversal . traverseEs6 ( compiler , singleRoot , callback ) ; } } }
! forTranspileOnly || ( compiler . getOptions () . getLanguageIn () . toFeatureSet () . contains ( FeatureSet.ES6 ) && TranspilationPasses . isScriptEs6OrHigher ( scriptRoot ) )
{ for ( Node singleRoot : root . children () ) { if ( TranspilationPasses . isScriptEs6OrHigher ( singleRoot ) ) { return true ; } } }
return isConst && ! JsdocUtil . hasAnnotatedType ( jsdoc ) && ! NodeUtil . isNamespaceDecl ( nameNode ) ;
rhs . replaceWith ( IR . cast ( IR . number ( NUMBER_CONSTANT ) , JsdocUtil . getQmarkTypeJSDoc () ) . srcrefTree ( rhs ) ) ;
new Es6RewriteModules ( this ) . processFile ( root , forceRewrite ) ;
{ compiler . stage1Passes () ; if ( ! compiler . hasErrors () ) { compiler . stage2Passes () ; } compiler . performPostCompilationTasks () ; }
{ compiler . restoreState ( serializedInputStream ) ; if ( ! compiler . hasErrors () ) { compiler . stage2Passes () ; } compiler . performPostCompilationTasks () ; }
performPostCompilationTasks () ;
performPostCompilationTasks () ;
{ if ( ! compiler . getFeatureSet () . has ( feature ) ) { violation ( STRING_CONSTANT + feature , n ) ; } }
features = features . union ( factory . getFeatures () ) ;
for ( LanguageMode mode : LanguageMode . values () ) { if ( mode.featureSet . has ( feature ) ) { return mode ; } }
{ features = features . union ( FeatureSet.TYPESCRIPT ) ; return nextToken () . type ; }
features = features . with ( Feature.DESTRUCTURING ) ;
features = features . with ( Feature.DESTRUCTURING ) ;
features = features . with ( Feature.ARRAY_PATTERN_REST ) ;
features = features . with ( Feature.DESTRUCTURING ) ;
features = features . with ( Feature.NEW_TARGET ) ;
features = features . with ( Feature.EXPONENT_OP ) ;
features = features . with ( Feature.ARROW_FUNCTIONS , Feature.ASYNC_FUNCTIONS ) ;
features = features . with ( Feature.ARROW_FUNCTIONS ) ;
if ( TokenType.STAR_STAR_EQUAL . equals ( operator.type ) ) { features = features . with ( Feature.EXPONENT_OP ) ; }
{ features = features . with ( Feature.TRAILING_COMMA ) ; if ( config.warnTrailingCommas ) { errorReporter . reportWarning ( commaToken.location.start , STRING_CONSTANT ) ; } }
features = features . with ( Feature.REST_PARAMETERS ) ;
features = features . with ( Feature.DEFAULT_PARAMETERS ) ;
features = features . with ( Feature.ASYNC_FUNCTIONS ) ;
features = features . with ( Feature.ASYNC_FUNCTIONS ) ;
features = features . with ( Feature.ASYNC_FUNCTIONS ) ;
if ( Keywords . isKeyword ( name.value ) ) { features = features . with ( Feature.KEYWORDS_AS_PROPERTIES ) ; }
if ( expectedFeatures != null ) { assertFS ( result.features ) . contains ( expectedFeatures ) ; }
if ( expectedFeatures != null ) { assertFS ( result.features ) . contains ( expectedFeatures ) ; }
expectFeatures ( Feature.DESTRUCTURING ) ;
expectFeatures ( Feature.CLASSES , Feature.MEMBER_DECLARATIONS , Feature.CONST_DECLARATIONS , Feature.LET_DECLARATIONS ) ;
m.featureSet . has ( Feature.ASYNC_FUNCTIONS )
expectFeatures ( Feature.DESTRUCTURING , Feature.DEFAULT_PARAMETERS ) ;
expectFeatures ( Feature.MEMBER_DECLARATIONS ) ;
STRING_CONSTANT + featureSet . version ()
features = features . with ( Feature.STRING_CONTINUATION ) ;
features = features . with ( feature ) ;
features = features . with ( feature ) ;
features = features . with ( Feature.SETTER ) ;
features = features . with ( Feature.GETTER ) ;
features = features . with ( Feature.KEYWORDS_AS_PROPERTIES ) ;
{ if ( isValidSimpleName ( name ) ) { return true ; } else { return mode . has ( Feature.KEYWORDS_AS_PROPERTIES ) && TokenStream . isKeyword ( name ) ; } }
features . has ( Feature.MODULES )
setFeatureSet ( featureSet . without ( Feature.MODULES ) ) ;
BitSet modules
{ if ( hasConditionalAncestor ( parent . getParent () ) ) { info . disallowMovement () ; } }
Node parse ( String js ) { return parse ( js , TypeInferenceMode.NEITHER ) ; }
Preconditions . checkArgument ( root . isRoot () , STRING_CONSTANT , root . getToken () ) ;
assertPrettyPrintSame ( STRING_CONSTANT + String . format ( STRING_CONSTANT , NUMBER_CONSTANT ) + STRING_CONSTANT ) ;
String [] parts = path . split ( MODULE_SLASH ) ;
public void testConstTarget () { disableTypeCheck () ; testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , POLYMER_INVALID_DECLARATION ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ test ( wrapInFunction ( original ) , wrapInFunction ( expected ) ) ; }
{ fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGoogScopeClassOutput () { test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportEs6ArrowFunction () { test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportConst () { test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportLet () { test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
public void testExtractableExport4 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testExtractableExport3 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testEs6Class_testMethod () { test ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
private void assertNoWarningEs6 ( String js ) { testSame ( js ) ; }
private void assertAmbiguousEs6 ( String js ) { testSame ( js ) ; }
public void testAliasInModule () { enableUnusedLocalAssignmentCheck = true ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSame ( STRING_CONSTANT ) ;
@ Override public void setUp () { injectNamespace = false ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDuplicate_destructuring () { testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , DUPLICATE_REQUIRE ) ; }
public void testDuplicate_shorthand () { testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , DUPLICATE_REQUIRE ) ; }
testWarning ( STRING_CONSTANT , UNUSED_LABEL ) ;
testSame ( STRING_CONSTANT ) ;
testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ReplaceIdGenerators.CONDITIONAL_ID_GENERATOR_CALL ) ;
public void testClass () { testSame ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ReplaceIdGenerators.INVALID_GENERATOR_PARAMETER ) ; }
public void testPassModule () { testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; mode = CheckRequiresForConstructors.Mode.FULL_COMPILE ; }
public void testGoogModuleWithEmptyDestructuringRequire () { testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , EXTRA_REQUIRE_WARNING ) ; }
public void testRemovalMultipleAssignment3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemovalMultipleAssignment2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveRepeatedProperties () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveUnnecessaryBodies () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testConstPropagationPrivateProperties2 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testConstructorAlias4 () { testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorAlias3 () { testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testPathologicalCaseThatsOkAnyway () { testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , NAME_DEFINED_LATE_WARNING ) ; }
public void testNullUndefined () { testWarning ( STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ; assertMismatches ( Collections . < TypeMismatch > emptyList () ) ; }
testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ;
testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ;
{ testWarning ( STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ; assertMismatches ( ImmutableList . of ( fromNatives ( STRING_TYPE , NUMBER_TYPE ) ) ) ; }
{ testWarning ( STRING_CONSTANT + params + STRING_CONSTANT + arguments + STRING_CONSTANT , type ) ; }
testWarning ( fooDfn + STRING_CONSTANT , WRONG_ARGUMENT_COUNT ) ;
testWarning ( declarations + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
{ testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
{ testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
public void testBadObjectLiteralCast1 () { testWarning ( STRING_CONSTANT + STRING_CONSTANT , ClosureCodingConvention.OBJECTLIT_EXPECTED ) ; }
testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
{ return ! found && ! n . isFunction () ; }
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testNoWarning ( typedefExterns , code ) ;
testNoWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT , value ( STRING_CONSTANT ) ) ; testNoWarning ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testCustomBanUnknownThisProp2 () { configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testNoWarning ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testCustomRestrictThrow2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
{ allowSourcelessWarnings () ; configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
testNoWarning ( EXTERNS + STRING_CONSTANT , code + STRING_CONSTANT ) ;
testNoWarning ( code + STRING_CONSTANT ) ;
{ configuration = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
testNoWarning ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ) ) ;
testWarning ( input , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
testNoWarning ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ) ) ;
public void testViolationWhitelisted2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
public void testViolationWhitelisted1 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
testNoWarning ( STRING_CONSTANT ) ;
public void testNotViolation2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT , null , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , null , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
{ testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
NodeTraversal unusedT
Node export = n . getFirstFirstChild () ;
public void testObjLit () { assertUnreachable ( STRING_CONSTANT ) ; }
if ( options . needsTranspilationFrom ( ES6 ) && ! options.skipTranspilationAndCrash ) { checks . add ( convertStaticInheritance ) ; }
catch ( IOException e ) { report ( JSError . make ( AbstractCompiler.READ_ERROR , input . getName () , e . getMessage () ) ) ; }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2017 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2017 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
defUse = new MustBeReachingVariableDef ( cfg , scope , compiler , scopeCreator ) ;
useDef = new MaybeReachingVariableUse ( cfg , scope , compiler , scopeCreator ) ;
liveness = new LiveVariablesAnalysis ( cfg , functionScope , compiler , SyntacticScopeCreator . makeUntyped ( compiler ) ) ;
LiveVariablesAnalysis liveness = new LiveVariablesAnalysis ( cfg , scope , compiler , t . getScopeCreator () ) ;
public void testObjectDestructuringDefaultVals () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringAssignNewVarNames () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringAssignWithoutDeclaration () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringBasicAssign () { testSame ( STRING_CONSTANT ) ; }
public void testArrayDestructuringVarAssign () { testSame ( STRING_CONSTANT ) ; }
public void testArrayDestructuringSwap () { testSame ( STRING_CONSTANT ) ; }
{ new GraphReachability <> ( controlFlowGraph , REACHABLE ) . compute ( controlFlowGraph . getEntry () . getValue () ) ; }
inheritsCall . useSourceInfoIfMissingFromForTree ( metadata.superClassNameNode ) ;
Node lp = scope . getParentScope () . getRootNode () . getSecondChild () ;
assertThat ( cssNames ) . isEqualTo ( expected ) ;
assertThat ( cssNames ) . isEqualTo ( expected ) ;
assertThat ( cssNames ) . isEqualTo ( expected ) ;
catch ( IOException | ClassNotFoundException e ) { compiler . report ( JSError . make ( COULD_NOT_DESERIALIZE_AST , filename ) ) ; }
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; }
public void testVarArguments () { testConsts ( STRING_CONSTANT , STRING_CONSTANT ) ; }
peepholePass . setRetraverseOnChange ( retraverseOnChange ) ;
public void testIssue () { allowExternsChanges () ; test ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public RemoveUnusedClassPropertiesTest () { super ( EXTERNS ) ; }
allowExternsChanges () ;
public void testProvideInExterns () { allowExternsChanges () ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
allowExternsChanges () ;
{ allowExternsChanges () ; test ( STRING_CONSTANT , STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , null , null ) ; }
allowExternsChanges () ;
allowExternsChanges () ;
allowExternsChanges () ;
if ( transpileEnabled && ! compiler . hasErrors () ) { transpileToEs5 ( compiler , externsRoot , mainRoot ) ; }
public final String getFilename () { return filename ; }
public J2clCheckPassTest () { super ( DEFAULT_EXTERNS ) ; }
enableCheckAccessControls () ;
enableCheckAccessControls () ;
public GatherRawExportsTest () { super ( EXTERNS ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; enableRunTypeCheckAfterProcessing () ; }
disableCompareJsDoc () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; useGoogleCodingConvention = true ; }
public RemoveUnusedVarsTest () { super ( STRING_CONSTANT ) ; }
public void testEs6ONoEs6 () { allowExternsChanges () ; testSame ( STRING_CONSTANT ) ; }
public Es6ExternsCheckTest () { super ( EXTERNS_BASE ) ; }
{ enableTypeCheck () ; allowExternsChanges () ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT , POSSIBLE_INEXISTENT_PROPERTY ) ; }
{ declarationCheck = ! sanityCheck ; disableCompareAsTree () ; testExternChanges ( extern , input , expectedExtern ) ; }
allowExternsChanges () ;
public ProcessDefinesTest () { super ( DEFAULT_EXTERNS + STRING_CONSTANT ) ; }
this . runSmartNameRemoval = true ;
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
allowExternsChanges () ;
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ disableCompareAsTree () ; super . testExternChanges ( input , expectedExtern ) ; }
disableValidateAstChangeMarking () ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; }
{ value = key . removeFirstChild () ; }
Node assign = IR . assign ( windowPropAccess , nameNode . removeFirstChild () ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
binaryNamespaceName . setOriginalName ( currentScript.legacyNamespace ) ;
binaryNamespaceName . setOriginalName ( currentScript.legacyNamespace ) ;
exportedNamespaceName . setOriginalName ( legacyNamespace ) ;
binaryNamespaceName . setOriginalName ( legacyNamespace ) ;
Node initializer = n . removeFirstChild () ;
Node extern = externs . removeFirstChild () ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
{ ModulesTestUtils . testModules ( this , input , STRING_CONSTANT + expected ) ; }
if ( caught . isArrayPattern () ) { validateArrayPattern ( Token.CATCH , caught ) ; } else { validateObjectPattern ( Token.CATCH , caught ) ; }
test ( options , source , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ;
public void testNotStringLiteralConstantArgument3 () { testError ( CLOSURE_DEFS + STRING_CONSTANT , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ; }
public void testNotStringLiteralConstantArgument2 () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ; }
public void testNotStringLiteralConstantArgument1 () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ; }
public void testNotConstantArgument () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ; }
shadowedVar != null && ! shadowedVar . getScope () . isModuleScope ()
shadowedVar != null && shadowedVar . isLocal ()
this . redeclarationHandler = DEFAULT_REDECLARATION_HANDLER ;
ScopeScanner ( AbstractCompiler compiler , Scope scope ) { this ( compiler , DEFAULT_REDECLARATION_HANDLER , scope ) ; }
public Es6SyntacticScopeCreator ( AbstractCompiler compiler , ScopeFactory scopeFactory ) { this ( compiler , DEFAULT_REDECLARATION_HANDLER , scopeFactory ) ; }
int count = RandomNameGenerator.FIRST_CHAR . size () * ( RandomNameGenerator.NONFIRST_CHAR . size () + NUMBER_CONSTANT ) ;
int count = RandomNameGenerator.FIRST_CHAR . size () * ( RandomNameGenerator.NONFIRST_CHAR . size () + NUMBER_CONSTANT ) ;
{ this . random = random ; reset ( ImmutableSet . < String > of () , STRING_CONSTANT , null ) ; }
NodeUtil . isNameDeclaration ( var . getParentNode () ) && ! var . getParentNode () . getParent () . isForIn ()
Scope scope = scopeCreator . createScope ( root , null ) ;
NodeTraversal . traverseEs6 ( compiler , root , new RemoveNonDeclarations ( compiler ) ) ;
for ( Assign assign : assignsByVar . get ( var ) ) { compiler . reportChangeToEnclosingScope ( assign.assignNode ) ; assign . remove ( compiler ) ; }
this . changeProxy = new AstChangeProxy ( compiler ) ;
clonesByCurrent . clear () ;
if ( hasExternsRoot () && n == externsRoot ) { externsScope = t . getScope () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
options . setChromePass ( flags.chromePass ) ;
if ( options . isChromePassEnabled () ) { checks . add ( chromePass ) ; }
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
{ if ( n . isFunction () ) { NormalizeStatements . visitFunction ( n , compiler ) ; } }
if ( visitFunction ( n , compiler ) ) { reportCodeChange ( n , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT , warning ( Es6TypedToEs6Converter.CANNOT_CONVERT_BOUNDED_GENERICS ) ) ;
test ( modules , expected ( expected ) , warning ( warning ) ) ;
{ test ( srcs ( js ) , expected ( js ) ) ; }
{ test ( modules , expected ( expected ) , null ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( js ) , warning ( warning , description ) ) ; }
{ test ( srcs ( js ) , expected ( expected ) ) ; }
testWarning ( externs , js , ConstCheck.CONST_REASSIGNED_VALUE_ERROR ) ;
testSame ( externs , js ) ;
{ testSame ( kExterns + extraExterns , source ) ; assertEquals ( expected , noSideEffectCalls ) ; noSideEffectCalls . clear () ; }
public void testIssue2508576_1 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testExternFunction () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testObjectLitExtern () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testJSDocDescInExterns () { testWarning ( STRING_CONSTANT , MISPLACED_MSG_ANNOTATION ) ; testSame ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testEnum () { testSame ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testErrorExterns ( jsdoc + STRING_CONSTANT ) ;
public void testProvideInExterns () { allowExternsChanges () ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; }
{ test ( createModuleStar ( moduleInputs ) , expected ( expected ) , null ) ; }
{ testNoWarning ( js ) ; assertEquals ( fieldTypes , mapToString ( lastPass . getRenamedTypesForTesting () ) ) ; }
test ( DEFAULT_EXTERNS + externs , STRING_CONSTANT , STRING_CONSTANT ) ;
public void testSkipNativeFunctionMethod () { String js = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( js ) ; }
testSame ( externs , js ) ;
{ test ( code , addLibraries ( code , libraries ) , warning ( warning ) ) ; }
public void testGlobalAliasWithProperties5 () { testSame ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
test . testError ( inputs , error ) ;
{ currentLocationAbstractionIdentifier = locationAbstractionIdentifier ; testSame ( SHARED_EXTERNS , js ) ; currentJsRoot = getLastCompiler () . jsRoot ; return currentAnalysis ; }
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR , message ) ) ;
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR , message ) ) ;
{ String externs = STRING_CONSTANT ; String code = STRING_CONSTANT ; testSame ( externs , code ) ; }
{ String externs = STRING_CONSTANT ; String code = STRING_CONSTANT ; testSame ( externs , code ) ; }
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ testSame ( externs , STRING_CONSTANT ) ; assertEquals ( ImmutableSet . copyOf ( properties ) , getLastCompiler () . getExternProperties () ) ; }
testSame ( STRING_CONSTANT , STRING_CONSTANT ) ;
tester . testSame ( STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( externs , STRING_CONSTANT ) ;
testSame ( externs , js ) ;
testSame ( externs , js ) ;
testSame ( externs , js ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( ALL_NATIVE_EXTERN_TYPES , STRING_CONSTANT ) ;
testSame ( METHOD_DEFS , STRING_CONSTANT ) ;
testSame ( OBJECT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( OBJECT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , warning ( ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , warning ( ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ) ;
{ testSame ( externs , source ) ; assertEquals ( expected , found ) ; found . clear () ; }
{ setAcceptedLanguage ( lang ) ; test ( code , expected , warning ( warning ) ) ; }
testError ( googModule , MISSING_MODULE_OR_PROVIDE , warning ) ;
public void testRenameWithExterns1 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ; }
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
test ( externs , input , expected ) ;
test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ;
public void testRenameWithExterns2 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRenameWithExterns1 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ; }
{ overrides . put ( STRING_CONSTANT , new Node ( Token.TRUE ) ) ; test ( STRING_CONSTANT , STRING_CONSTANT , warning ( ProcessDefines.UNKNOWN_DEFINE_WARNING ) ) ; }
{ overrides . put ( STRING_CONSTANT , new Node ( Token.TRUE ) ) ; test ( STRING_CONSTANT , STRING_CONSTANT , warning ( ProcessDefines.UNKNOWN_DEFINE_WARNING ) ) ; }
public void testNamespaceResetInLocalScope2 () { test ( STRING_CONSTANT , STRING_CONSTANT , warning ( NAMESPACE_REDEFINED_WARNING ) ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
public void testNamespaceResetInLocalScope1 () { test ( STRING_CONSTANT , STRING_CONSTANT , warning ( NAMESPACE_REDEFINED_WARNING ) ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
public void testNamespaceResetInGlobalScope1 () { test ( STRING_CONSTANT , STRING_CONSTANT , warning ( NAMESPACE_REDEFINED_WARNING ) ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
{ testSame ( CompilerTestCase.ACTIVE_X_OBJECT_DEF , STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
testSame ( CompilerTypeTestCase.DEFAULT_EXTERNS , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( externs , code ) ;
if ( Es6RewriteModules . isEs6ModuleRoot ( root ) ) { moduleRewriter . processFile ( root ) ; }
Preconditions . checkState ( exportsNameNode . getString () . equals ( STRING_CONSTANT ) , exportsNameNode ) ;
Preconditions . checkArgument ( importNode . getFirstChild () . isDestructuringLhs () , importNode ) ;
Preconditions . checkState ( currentScript.defaultExportRhs == null , currentScript.defaultExportRhs ) ;
Preconditions . checkArgument ( n . isStringKey () , n ) ;
Preconditions . checkState ( scriptRoot . isScript () , scriptRoot ) ;
Preconditions . checkState ( c . isScript () , c ) ;
public void testES6VarAliasClassDeclarationWithoutNew () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testES6VarAliasClassDeclarationWithNew () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
if ( NodeUtil . isEnhancedFor ( parent ) ) { return; }
public void testSimpleConstAliasInCode () { testSame ( STRING_CONSTANT ) ; }
{ checkState ( error.node . getParent () . isStringKey () , error.node . getParent () ) ; fix . delete ( error.node . getParent () ) ; }
checkState ( regexMatcher . matches () , STRING_CONSTANT , error.description ) ;
checkState ( regexMatcher . matches () , STRING_CONSTANT , error.description ) ;
checkState ( fullNameMatcher . matches () , error.description ) ;
checkState ( name . isName () , name ) ;
mayWarnAboutGlobalThis ( expr ) ;
mayWarnAboutGlobalThis ( expr ) ;
T o
public HierarchicalSet ( @ Nullable HierarchicalSet < T > parent ) { this . parent = parent ; }
if ( isObjectLitOrCastOfObjectLit ( n ) && n . getParent () . isArrowFunction () ) { return true ; } else { return precedence ( n ) < minPrecedence ; }
{ for ( Var var : computeLiveness ( src ) . getEscapedLocals () ) { assertThat ( var.name ) . isNotEqualTo ( name ) ; } }
public void visitCallSite ( NodeTraversal t , Node callNode , FunctionState functionState ) ;
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
throw new IllegalStateException ( STRING_CONSTANT ) ;
Map < String , Node > map = new HashMap <> ( stringLiteralMatches ) ;
ScopeCreator creator = new MemoizedScopeCreator ( new Es6SyntacticScopeCreator ( compiler ) ) ;
ScopeCreator creator = new MemoizedScopeCreator ( new Es6SyntacticScopeCreator ( compiler ) ) ;
{ test ( createModuleStar ( moduleInputs ) , expected ) ; }
{ Preconditions . checkState ( expected == null ) ; expected = fromSources ( ( Sources ) part ) ; }
protected Sources srcs ( List < SourceFile > files ) { return new FlatSources ( files ) ; }
protected Sources srcs ( String [] srcTexts ) { return new FlatSources ( createSources ( STRING_CONSTANT , srcTexts ) ) ; }
protected Sources srcs ( String srcText ) { return new FlatSources ( maybeCreateSources ( filename , srcText ) ) ; }
{ test ( srcs ( modules ) , expected ( modules ) ) ; }
{ test ( srcs ( modules ) , expected ( expected ) ) ; }
builder . setTypeRegistry ( getTypeIRegistry () ) ;
validateChildCount ( n ) ;
public Es6RewriteModules ( AbstractCompiler compiler ) { this . compiler = compiler ; }
ModulesTestUtils . testModulesError ( this , STRING_CONSTANT , Es6RewriteModules.NAMESPACE_IMPORT_CANNOT_USE_STAR ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.ERROR ) ;
@ Override protected FeatureSet featureSet () { return ES7_MODULES ; }
@ Override protected FeatureSet featureSet () { return ES6_MODULES ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
if ( forAnnotations ) { return sb . append ( getReferenceName () ) ; }
{ return STRING_CONSTANT + type . toMaybeObjectType () . getEnumeratedTypeOfEnumObject () . toNonNullAnnotationString () + STRING_CONSTANT ; }
TypeI getEnumeratedTypeOfEnumObject ( ) ;
@ Override public TypeI getEnumeratedTypeOfEnumObject () { return null ; }
checkState ( sum > NUMBER_CONSTANT ) ;
checkState ( s instanceof TypedScope , STRING_CONSTANT ) ;
checkState ( curNode != null ) ;
checkNotNull ( parent ) ;
checkState ( s . isGlobal () || s . isModuleScope () ) ;
type = Name.Type.OTHER ;
{ super . setUp () ; compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6_TYPED ) ; this . mode = InputLanguageMode.TRANSPILATION ; }
if ( ! functionScope . isDeclaredSloppy ( name , false ) ) { return; }
if ( current . isDeclaredSloppy ( oldName , false ) ) { return; } else { current = current . getParent () ; }
{ return n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ! jsScope . isDeclaredSloppy ( ARGUMENT_ARRAY_ALIAS , false ) ; }
if ( ! jsScope . isDeclaredSloppy ( name , false ) ) { return; }
{ this . warningsGuard = new ComposeWarningsGuard ( new SuppressDocWarningsGuard ( this , getDiagnosticGroups () . getRegisteredGroups () ) , warningsGuard ) ; }
Es6SyntacticScopeCreator createInternalScopeCreator ( AbstractCompiler compiler ) { return new Es6SyntacticScopeCreator ( compiler , factory , factory ) ; }
ScopeScanner ( AbstractCompiler compiler , Scope scope ) { this ( compiler , DEFAULT_REDECLARATION_HANDLER , scope , null ) ; }
new ScopeScanner ( compiler , redeclarationHandler , scope , null ) . populate () ;
undeclareInteral ( var ) ;
NodeUtil . isAnyFor ( n )
{ logger . fine ( STRING_CONSTANT + scopeRoot ) ; }
{ return new J2clClinitPrunerPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopeNodes , this , false ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler , true ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () , true ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true , true ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
checkArgument ( nameNode . isQualifiedName () ) ;
checkArgument ( functionNode . isFunction () ) ;
checkArgument ( nameNode . isQualifiedName () ) ;
checkState ( NodeUtil . isStatement ( statement ) , statement ) ;
checkState ( functionBody . isNormalBlock () ) ;
checkArgument ( paramList . isParamList () ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) { processRequire ( expr ) ; } else { checkState ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) ; }
void markConstructorToProcess ( Node ctorNode ) { checkArgument ( ctorNode . isFunction () , ctorNode ) ; constructorsToProcess . add ( ctorNode ) ; }
int getMaxArity ( ) ;
int getMinArity ( ) ;
index < funType . getMaxArity ()
{ if ( currentType . getMaxArity () <= expectedType . getMaxArity () ) { return expectedType ; } }
{ this ( res , new NumberValue ( op1 ) , o , op2 ) ; }
{ this ( res , op1 , o , new NumberValue ( op2 ) ) ; }
checkArgument ( ! members . isEmpty () , STRING_CONSTANT ) ;
checkArgument ( nt . isGeneric () , nt ) ;
checkArgument ( nameNode . getParent () . isVar () ) ;
checkArgument ( funNode . isFunction () ) ;
checkState ( n . isOr () || n . isAnd () ) ;
checkState ( n . isGetElem () ) ;
return checkNotNull ( funType ) . toFunctionType () ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkState ( declNode . isGetProp () ) ;
checkArgument ( fn . isFunction () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkNotNull ( lendsName ) ;
checkState ( qnameNode . isName () || qnameNode . isGetProp () ) ;
checkState ( qnameNode . isName () || qnameNode . isGetProp () ) ;
checkArgument ( fn . isFunction () ) ;
checkState ( ! fnName . contains ( STRING_CONSTANT ) ) ;
checkState ( qnameNode . isQualifiedName () ) ;
checkState ( qnameNode . isQualifiedName () ) ;
{ if ( maybeAssign . isAssign () ) { maybeAssign . putBooleanProp ( Node.ANALYZED_DURING_GTI , true ) ; } else { checkState ( maybeAssign . isExprResult () ) ; } }
checkState ( ! currentScope . isNamespace ( qname ) ) ;
{ PropertyDef propdef = checkNotNull ( getPropDefFromClass ( superType , pname ) ) ; inheritedPropDefs = ImmutableSet . of ( propdef ) ; }
{ JSType t = castTypes . get ( n ) ; checkNotNull ( t ) ; return t ; }
{ checkNotNull ( part , STRING_CONSTANT ) ; parts . add ( part ) ; return this ; }
checkNotNull ( name , STRING_CONSTANT ) ;
checkState ( n . isScript () ) ;
checkState ( passName . equals ( logStats.pass ) ) ;
checkArgument ( mode != TracerMode.OFF , STRING_CONSTANT ) ;
checkNotNull ( qualifiedName ) ;
checkArgument ( lastLink.nextLink == null ) ;
checkState ( token == JsDocToken.PIPE ) ;
checkArgument ( token == JsDocToken.LEFT_CURLY ) ;
checkArgument ( token == JsDocToken.LEFT_CURLY ) ;
checkState ( annotation == Annotation.IMPLEMENTS ) ;
checkState ( other instanceof NominalType ) ;
{ checkArgument ( pname . isIdentifier () ) ; return this . rawType . getSubtypesWithProperty ( pname . getLeftmostName () ) ; }
{ checkArgument ( pname . isIdentifier () ) ; return this . rawType . isPropDefinedOnSubtype ( pname . getLeftmostName () ) ; }
checkState ( nt1.rawType . equals ( nt2.rawType ) ) ;
checkState ( this . rawType . equals ( other.rawType ) ) ;
checkState ( this . inheritsFromIObjectReflexive () && other . inheritsFromIObjectReflexive () ) ;
checkArgument ( other . isStructuralInterface () ) ;
checkState ( typeMap . size () == NUMBER_CONSTANT ) ;
checkState ( this . rawType . isFrozen () ) ;
{ checkState ( this . rawType . isFrozen () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
checkState ( this . rawType . isFrozen () ) ;
checkState ( isUninstantiatedGenericType () ) ;
checkState ( types . size () == typeParams . size () ) ;
public RawNominalType getRawNominalType () { checkState ( ! this . rawType . isFrozen () ) ; return this . rawType ; }
{ checkArgument ( value . isInterface () ) ; return new SubtypeCache ( this . m . with ( key , value ) ) ; }
checkState ( node . isSuper () ) ;
{ checkArgument ( ! ( scope instanceof TypedScope ) ) ; return new Arguments ( scope ) ; }
{ checkState ( root . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ super ( registry , null , null , isNativeType , constructor . getTemplateTypeMap () ) ; checkNotNull ( constructor ) ; this . constructor = constructor ; }
{ checkState ( m == null ) ; }
checkState ( line < nextLine || col <= nextCol ) ;
checkArgument ( n . isFunction () ) ;
checkState ( variableNode != null ) ;
checkArgument ( n . getChildCount () > NUMBER_CONSTANT ) ;
{ checkNotNull ( isDisposalStack ) ; if ( ! isDisposalStack . isEmpty () ) { return isDisposalStack . peek () ; } return null ; }
{ checkNotNull ( isConstructorStack ) ; if ( ! isDisposalStack . isEmpty () ) { return isConstructorStack . peek () ; } return null ; }
checkArgument ( checkingPolicy != DisposalCheckingPolicy.OFF ) ;
checkNotNull ( name ) ;
checkState ( NodeUtil . isStatementBlock ( parent ) ) ;
checkArgument ( ret . isReturn () ) ;
checkArgument ( node . isNormalBlock () ) ;
{ checkArgument ( classByAlias . containsKey ( original ) ) ; classByAlias . put ( alias , classByAlias . get ( original ) ) ; }
checkState ( subclassMember . isAssign () , subclassMember ) ;
checkState ( staticGetProp . isGetProp () ) ;
{ checkState ( n . isName () , n ) ; n . removeFirstChild () ; }
{ checkState ( root . isRoot () ) ; if ( root . getChangeTime () != NUMBER_CONSTANT ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
checkArgument ( n . isCast () ) ;
checkState ( first . getParent () == last . getParent () ) ;
{ checkState ( n . getParent () . isGetProp () , n ) ; nodeToRename = n ; }
checkState ( parentNode . isNormalBlock () , STRING_CONSTANT ) ;
checkState ( node . isName () ) ;
public boolean isLive ( Var v ) { checkNotNull ( v ) ; return liveSet . get ( v.index ) ; }
checkNotNull ( other ) ;
{ checkNotNull ( other ) ; this . liveSet = ( BitSet ) other.liveSet . clone () ; }
checkArgument ( mode != TypeInferenceMode.BOTH ) ;
checkState ( subns.namespaceType != null ) ;
checkState ( this . namespaceType == null ) ;
checkState ( this . namespaceType == null ) ;
checkState ( ! prop . isOptional () ) ;
this . defSite = checkNotNull ( defSite ) ;
checkNotNull ( clinitName ) ;
checkNotNull ( name ) ;
checkState ( hasProcessBeenRun , STRING_CONSTANT ) ;
{ super ( symbolName , value ) ; this . exportPath = checkNotNull ( exportPath ) ; }
checkArgument ( fn . isFunction () ) ;
{ checkState ( pathDefinition . isVar () ) ; pathDefinition . setJSDocInfo ( jsdoc ) ; }
{ checkState ( valueToExport . isObjectLit () ) ; initializer = createExternObjectLit ( valueToExport ) ; }
checkArgument ( before . isExprResult () , STRING_CONSTANT ) ;
checkArgument ( keyValPairs.length % NUMBER_CONSTANT == NUMBER_CONSTANT ) ;
checkState ( isNamespacePlaceholder ( decl ) ) ;
checkState ( isNamespacePlaceholder ( decl ) ) ;
{ checkState ( newModule == minimumModule , STRING_CONSTANT ) ; }
checkArgument ( explicitNode != node ) ;
checkState ( n . isCall () ) ;
checkNotNull ( providedModule , n ) ;
checkState ( parent . isExprResult () ) ;
checkState ( isRegistered () ) ;
boolean isCorrectRegisterFunction ( TweakFunction registerFunction ) { checkNotNull ( registerFunction ) ; return this . registerFunction == registerFunction ; }
checkArgument ( scriptNodeCount == NUMBER_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ;
checkState ( moduleNode . isModuleBody () ) ;
checkArgument ( parent . isModuleBody () , parent ) ;
checkArgument ( parent . isModuleBody () , parent ) ;
{ checkArgument ( isEs6ModuleRoot ( root ) , root ) ; clearState () ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
checkArgument ( scriptNode . isScript () ) ;
checkArgument ( n . isCall () ) ;
checkArgument ( subtree . isCall () ) ;
checkArgument ( subtree . isCall () ) ;
{ checkState ( script . isScript () ) ; visit ( script ) ; }
checkState ( ! member . isStaticMember () ) ;
checkNotNull ( constructor ) ;
checkArgument ( object != null , STRING_CONSTANT ) ;
checkState ( ! frozen ) ;
checkState ( fnNode . isFunction () || type . isFunctionType () ) ;
checkNotNull ( registry ) ;
checkState ( NodeUtil . isNameDeclaration ( n ) ) ;
checkArgument ( ! envs . isEmpty () ) ;
{ checkArgument ( ! n . contains ( STRING_CONSTANT ) ) ; return typeMap . get ( n ) ; }
checkState ( typeMap . size () >= SIZE_THRESHOLD ) ;
checkState ( meaning != null ) ;
checkArgument ( n . isCall () || n . isNew () ) ;
checkState ( n . isNew () ) ;
checkState ( n . isCall () ) ;
checkState ( n . isCall () , n ) ;
checkArgument ( NodeUtil . isAssociative ( n . getToken () ) ) ;
checkArgument ( node . isGetProp () ) ;
checkNotNull ( compiler ) ;
{ checkArgument ( groupIndex >= NUMBER_CONSTANT && groupIndex <= NUMBER_CONSTANT ) ; this . groupIndex = groupIndex ; }
checkState ( n . isGetProp () , n ) ;
checkNotNull ( typei ) ;
checkArgument ( callSite . isCall () || callSite . isNew () ) ;
checkArgument ( callType == Token.CALL || callType == Token.NEW ) ;
checkArgument ( NodeUtil . isNameDeclaration ( node . getParent () ) ) ;
{ checkNotNull ( sideEffectInfo ) ; updateSideEffectsForNode ( sideEffectInfo , traversal , node , enclosingFunction ) ; }
checkNotNull ( functionInfo ) ;
checkNotNull ( cacheCall ) ;
this . compiler = checkNotNull ( compiler ) ;
checkState ( initialization . getGrandparent () . isExprResult () ) ;
checkState ( value != null ) ;
checkState ( NodeUtil . isNameDeclaration ( varNode ) , varNode ) ;
checkState ( scriptRoot . isScript () ) ;
Time ( String name ) { checkNotNull ( name ) ; this . name = name ; }
Event ( T value ) { checkNotNull ( value ) ; this . value = value ; }
checkState ( exportDefinition . hasInlinableName ( currentScript.exportsToInline . keySet () ) ) ;
checkState ( n . isScript () , n ) ;
checkState ( currentScript.willCreateExportsObject || currentScript.hasCreatedExportObject ) ;
checkArgument ( importNode . getFirstChild () . isDestructuringLhs () , importNode ) ;
checkState ( currentScript.defaultExportRhs == null , currentScript.defaultExportRhs ) ;
checkArgument ( n . isStringKey () , n ) ;
checkState ( scriptRoot . isScript () , scriptRoot ) ;
checkState ( c . isScript () , c ) ;
checkState ( returnNode . isReturn () , returnNode ) ;
{ checkArgument ( containsModule ( legacyNamespace ) ) ; return scriptDescriptionsByGoogModuleNamespace . get ( legacyNamespace ) . declareLegacyNamespace ; }
{ checkState ( isInterface () ) ; isStructuralInterface = flag ; }
checkArgument ( isConstructor () || isInterface () ) ;
checkNotNull ( that ) ;
checkArgument ( interfaceType . isInterface () ) ;
checkState ( msgBuilder != null ) ;
checkState ( ! STRING_CONSTANT . equals ( projectId ) ) ;
{ checkArgument ( classNode . isClass () ) ; return classNode . getFirstChild () . isName () && parent . isName () ; }
checkNotNull ( name ) ;
checkArgument ( n . isFunction () ) ;
checkState ( rootNode . isFunction () ) ;
checkState ( ! typeMap . isEmpty () ) ;
public JSType getRestFormalsType () { checkState ( restFormals != null ) ; return restFormals ; }
checkArgument ( propertyName . isString () ) ;
checkArgument ( superSet . isAssign () ) ;
checkArgument ( objectLit . isObjectLit () ) ;
checkState ( parent . isCall () ) ;
checkState ( parent . isObjectLit () ) ;
checkNotNull ( t ) ;
public JSTypeExpression getTypeExprForErrorReporting () { checkState ( state == State.DURING_RESOLUTION ) ; return typeExpr ; }
checkState ( state != State.RESOLVED ) ;
public JSType getType () { checkState ( state == State.RESOLVED ) ; return type ; }
checkNotNull ( typeExpr ) ;
{ checkState ( renameStrategy == RenameStrategy.MAPPED ) ; return new MappedNameSupplier ( mappings ) ; }
{ checkState ( grandparent . isLabel () ) ; throw new IllegalStateException ( STRING_CONSTANT ) ; }
checkState ( functionBody . getParent () . isFunction () ) ;
checkArgument ( n . isLabel () ) ;
checkState ( n . isFunction () , n ) ;
checkArgument ( ! Iterables . isEmpty ( options ) , STRING_CONSTANT ) ;
checkState ( oldName . equals ( p.oldName ) ) ;
Map < String , String > getRenamingMap () { checkNotNull ( renamingMap ) ; return renamingMap ; }
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
checkNotNull ( refNode ) ;
checkNotNull ( value ) ;
if ( invalidatingPropRef ) { checkNotNull ( propName ) ; invalidateProperty ( propName ) ; }
checkState ( n . isName () , n ) ;
checkNotNull ( inputId ) ;
{ checkState ( mayBeExpression ( expr ) ) ; return new Node ( token , expr ) ; }
checkState ( function . isFunction () ) ;
{ checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.SPREAD , expr ) ; }
checkState ( mayBeExpression ( value ) ) ;
{ checkState ( expr . isString () ) ; return new Node ( Token.REGEXP , expr ) ; }
for ( Node expr : exprs ) { checkState ( mayBeExpressionOrEmpty ( expr ) ) ; arraylit . addChildToBack ( expr ) ; }
checkState ( mayBeExpression ( target ) ) ;
for ( Node arg : args ) { checkState ( mayBeExpression ( arg ) ) ; newcall . addChildToBack ( arg ) ; }
for ( Node arg : args ) { checkState ( mayBeExpression ( arg ) , arg ) ; call . addChildToBack ( arg ) ; }
{ checkState ( name . isLabelName () ) ; return new Node ( Token.CONTINUE , name ) ; }
{ checkState ( name . isLabelName () ) ; return new Node ( Token.BREAK , name ) ; }
checkState ( finallyBody . isNormalBlock () ) ;
{ checkState ( ! name . isEmpty () ) ; return Node . newString ( Token.LABEL_NAME , name ) ; }
{ checkState ( body . isNormalBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
{ checkState ( mayBeExpression ( expr ) , expr ) ; return new Node ( Token.EXPR_RESULT , expr ) ; }
{ checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.RETURN , expr ) ; }
for ( Node stmt : stmts ) { checkState ( mayBeStatementNoReturn ( stmt ) ) ; paramList . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { checkState ( mayBeStatementNoReturn ( stmt ) ) ; block . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { checkState ( mayBeStatement ( stmt ) ) ; paramList . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { checkState ( mayBeStatement ( stmt ) ) ; block . addChildToBack ( stmt ) ; }
{ checkState ( mayBeStatement ( stmt ) ) ; Node block = new Node ( Token.BLOCK , stmt ) ; return block ; }
{ checkState ( param . isName () || param . isRest () ) ; paramList . addChildToBack ( param ) ; }
{ checkState ( param . isName () || param . isRest () ) ; return new Node ( Token.PARAM_LIST , param ) ; }
checkArgument ( node . isGetProp () ) ;
checkArgument ( NodeUtil . isVarDeclaration ( node ) ) ;
{ super ( IR . getprop ( IR . objectlit () , name . cloneNode () ) , true ) ; checkArgument ( name . isString () ) ; }
{ super ( inExterns ) ; checkArgument ( node . isAssign () ) ; assignment = node ; }
{ super ( node , inExterns ) ; checkArgument ( NodeUtil . isFunctionExpression ( node ) ) ; }
{ super ( inExterns ) ; checkArgument ( node . isFunction () ) ; function = node ; }
checkNotNull ( lValue ) ;
{ checkState ( fileName . equals ( file . getName () ) ) ; sourceFile = file ; }
checkArgument ( parent . isExprResult () ) ;
checkState ( ! NodeUtil . isObjectLitKey ( n ) ) ;
checkState ( expressionRoot != null ) ;
checkState ( notAlreadyOutstanding ) ;
checkState ( Thread . currentThread () == startThread ) ;
checkState ( noCycles ) ;
{ checkState ( parentClass . isInterface () ) ; warnings . add ( JSError . make ( funNode , CONFLICTING_EXTENDED_TYPE , STRING_CONSTANT , functionName ) ) ; }
checkState ( thisRoot . getToken () == Token.BANG ) ;
checkArgument ( params != null || jsdoc != null ) ;
checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
checkState ( e != null , STRING_CONSTANT + STRING_CONSTANT ) ;
checkState ( td != null , STRING_CONSTANT + STRING_CONSTANT ) ;
checkNotNull ( n ) ;
checkNotNull ( commonTypes ) ;
checkState ( options.sourceMapDetailLevel != null ) ;
checkState ( n . isNormalBlock () , n ) ;
checkState ( line >= NUMBER_CONSTANT ) ;
checkState ( sourceMapDetailLevel != null ) ;
checkArgument ( getCfg () . hasNode ( useNode ) ) ;
{ checkState ( ownerFunction == null || type == null ) ; ownerFunction = type ; }
checkNotNull ( templateType , STRING_CONSTANT ) ;
checkState ( index >= NUMBER_CONSTANT ) ;
checkNotNull ( type ) ;
checkArgument ( ! values . isEmpty () ) ;
checkState ( scope . isFunctionScope () , scope ) ;
checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ;
checkArgument ( o instanceof ObjectType ) ;
checkArgument ( pname . isIdentifier () ) ;
checkArgument ( qname . isIdentifier () ) ;
checkArgument ( qname . isIdentifier () ) ;
{ checkArgument ( qname . isIdentifier () ) ; Property p = getLeftmostProp ( qname ) ; return p != null ; }
{ checkState ( p != null ) ; return p . getType () . getProp ( qname . getAllButLeftmost () ) ; }
checkNotNull ( this . ns ) ;
checkState ( isLoose || other.isLoose ) ;
checkNotNull ( pname ) ;
checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ;
checkNotNull ( resultNominalType ) ;
checkNotNull ( nominalType ) ;
{ return new ObjectType ( commonTypes , commonTypes . getObjectType () , checkNotNull ( commonTypes.BOTTOM_PROPERTY_MAP ) , null , null , false , ObjectKind.UNRESTRICTED ) ; }
checkNotNull ( reference ) ;
checkState ( node . isName () , node ) ;
public boolean isLive ( Var v ) { checkNotNull ( v ) ; return liveSet . get ( v.index ) ; }
checkNotNull ( other ) ;
{ checkNotNull ( other ) ; this . liveSet = ( BitSet ) other.liveSet . clone () ; }
checkState ( first . isString () ) ;
checkArgument ( ctorType . isConstructor () ) ;
{ checkState ( parent . isFunction () ) ; parent . setJSType ( varType ) ; }
checkState ( n . isGetElem () , n ) ;
checkNotNull ( data ) ;
checkNotNull ( preservedNamespaces , STRING_CONSTANT ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkState ( ! isDefined ( qnameNode ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkState ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkState ( s != null ) ;
{ checkArgument ( ! fnName . contains ( STRING_CONSTANT ) ) ; return getScopeHelper ( new QualifiedName ( fnName ) ) != null ; }
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( qnameNode . isQualifiedName () ) ;
{ checkState ( this . isTopLevel () ) ; this . unknownTypeNames = ImmutableSet . copyOf ( names ) ; }
boolean isPrototypeMethod () { checkArgument ( root != null ) ; return NodeUtil . isPrototypeMethod ( root ) ; }
checkNotNull ( declaredType ) ;
Node getBody () { checkArgument ( root . isFunction () ) ; return NodeUtil . getFunctionBody ( root ) ; }
checkNotNull ( commonTypes ) ;
checkArgument ( NodeUtil . isGet ( n ) ) ;
checkState ( left . isString () ) ;
checkArgument ( n . isGetElem () ) ;
checkArgument ( n . isNew () ) ;
checkArgument ( n . isCall () ) ;
{ checkArgument ( n . isNew () ) ; if ( inForcedStringContext ( n ) ) { return tryFoldInForcedStringContext ( n ) ; } return n ; }
checkArgument ( node . isAdd () ) ;
checkArgument ( n . isAssign () ) ;
checkArgument ( n . isInstanceOf () ) ;
checkState ( n . hasOneChild () , n ) ;
checkArgument ( originalTypeofNode . isTypeOf () ) ;
checkNotNull ( n ) ;
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
public ConstParamCheck ( AbstractCompiler compiler ) { this . compiler = checkNotNull ( compiler ) ; }
checkState ( options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED ) ;
{ checkArgument ( ! callbacks . isEmpty () ) ; return new CombinedCompilerPass ( compiler , callbacks ) ; }
if ( checks . contains ( closureGoogScopeAliases ) ) { checkState ( checks . contains ( checkVariableReferences ) , STRING_CONSTANT ) ; }
if ( pass1Index != - NUMBER_CONSTANT && pass2Index != - NUMBER_CONSTANT ) { checkState ( pass1Index < pass2Index , msg ) ; }
{ for ( PassFactory pass : passes ) { checkState ( ! pass . isOneTimePass () ) ; } }
{ for ( PassFactory pass : passes ) { checkState ( pass . isOneTimePass () ) ; } }
checkState ( this . namespaceType == null ) ;
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
checkState ( ! compiler . hasErrors () ) ;
checkState ( parametersList . isParamList () ) ;
checkNotNull ( traversal ) ;
checkNotNull ( traversal ) ;
{ checkArgument ( usingNameNode . isName () ) ; return referencesByNameNode . get ( usingNameNode ) ; }
checkArgument ( otherLocation instanceof VisibilityBasedEffectLocation ) ;
checkArgument ( otherLocation instanceof VisibilityBasedEffectLocation ) ;
{ checkArgument ( isStorageNode ( node ) ) ; return NodeUtil . isLValue ( node ) ; }
checkArgument ( isStorageNode ( node ) ) ;
checkArgument ( variableReference . isName () ) ;
checkState ( n . isGetProp () , n ) ;
checkState ( caseBody . isNormalBlock () ) ;
checkState ( first . getString () . isEmpty () ) ;
checkArgument ( token.type == TokenType.STRING ) ;
{ checkState ( config.keepGoing == Config.RunMode.KEEP_GOING ) ; bodyNode = IR . block () ; }
checkArgument ( scriptNode . isScript () ) ;
checkState ( ret . isString () ) ;
checkState ( work . isEmpty () ) ;
checkArgument ( isZipEntry ( zipURL ) ) ;
checkArgument ( arrowFunction . isArrowFunction () ) ;
{ checkState ( templateJs == null , STRING_CONSTANT ) ; this . templateJs = refasterJsTemplate ; }
checkState ( templateJs == null , STRING_CONSTANT ) ;
checkState ( objLit . isObjectLit () ) ;
checkState ( objLit . isObjectLit () ) ;
{ JSModule module = input . getModule () ; checkNotNull ( module ) ; entryPointInputsPerModule . put ( module , input ) ; }
checkState ( n . isCall () , n ) ;
{ checkState ( child . getParent () == n ) ; normalizeNodeTypes ( child ) ; }
checkNotNull ( thisType ) ;
checkState ( moduleSpecifier . isString () ) ;
checkNotNull ( ref . getTwin () ) ;
checkState ( isObjKey || isQName ) ;
checkState ( ref.node . getParent () . isExprResult () ) ;
checkState ( child . hasOneChild () ) ;
checkState ( cycleCount != maxIterations , NON_HALTING_ERROR_MSG ) ;
public int getArgIndex () { checkState ( this . argIndex >= NUMBER_CONSTANT ) ; return this . argIndex ; }
public JSType getExpectedType () { return checkNotNull ( this . expected ) ; }
public JSType getFoundType () { return checkNotNull ( this . found ) ; }
public String getPropName () { return checkNotNull ( this . propName ) ; }
checkState ( firstScript . isScript () ) ;
checkState ( namespace . hasExternsRoot () ) ;
{ checkArgument ( namespace . hasExternsRoot () ) ; this . namespace = namespace ; return this ; }
checkNotNull ( prevUsedRenameMap . getNewNameToOriginalNameMap () ) ;
{ checkState ( this . newName == null ) ; this . newName = newName ; }
checkState ( nameNode . isName () ) ;
checkArgument ( n . isAnd () || n . isOr () ) ;
checkNotNull ( replacementFnType ) ;
checkNotNull ( type ) ;
checkNotNull ( resultType ) ;
checkNotNull ( var ) ;
checkArgument ( objectType . isUnknownType () ) ;
checkNotNull ( errorRoot ) ;
{ checkState ( this . knownConstants . isEmpty () ) ; this . knownConstants = knownConstants ; }
{ checkState ( ! NodeUtil . isFunctionObjectApply ( callNode ) ) ; }
checkArgument ( callSiteType != CallSiteType.UNSUPPORTED ) ;
if ( type == DecompositionType.DECOMPOSABLE ) { return CallSiteType.DECOMPOSABLE_EXPRESSION ; } else { checkState ( type == DecompositionType.UNDECOMPOSABLE ) ; }
checkState ( this != callSiteType ) ;
checkState ( this != callSiteType ) ;
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
checkState ( fnRecursionName != null ) ;
checkArgument ( n . isDo () ) ;
checkArgument ( n . isVanillaFor () ) ;
checkArgument ( n . isWhile () ) ;
{ checkState ( isExprConditional ( n ) ) ; return n . getFirstFirstChild () ; }
{ checkState ( isSimpleAssignment ( n ) ) ; return n . getFirstChild () . getLastChild () ; }
checkState ( isSimpleAssignment ( n ) ) ;
checkState ( n . isSwitch () , n ) ;
checkState ( subtree . isAssign () ) ;
checkState ( n . isTry () , n ) ;
checkState ( this . namespaceType == null ) ;
{ NominalType builtinObj = checkNotNull ( this . commonTypes . getObjectType () , STRING_CONSTANT ) ; protoNT = builtinObj ; }
checkState ( ! this . isFrozen ) ;
{ checkState ( ! this . isFrozen ) ; super . addProperty ( pname , defSite , type , isConstant ) ; }
checkState ( ! this . isFrozen ) ;
checkState ( ! this . isFrozen ) ;
checkState ( ! this . isFrozen ) ;
checkState ( ! this . isFrozen ) ;
checkState ( ! this . isFrozen ) ;
if ( isClass () ) { checkState ( this . name . equals ( STRING_CONSTANT ) ) ; return getAllPropsOfClass () ; }
checkState ( isInterface () ) ;
checkState ( isClass () ) ;
checkState ( ancestor . isInterface () ) ;
checkState ( ! this . isFrozen ) ;
checkState ( ancestor . isClass () ) ;
{ checkState ( ! this . isFrozen ) ; this . ctorFn = ctorFn ; }
public boolean isStruct () { checkState ( isFrozen () || isClass () ) ; return this . objectKind . isStruct () ; }
JSType getPrototypeObject () { checkState ( this . isFrozen ) ; return this . protoObject ; }
checkNotNull ( objectKind ) ;
{ super ( commonTypes ) ; this . objs = checkNotNull ( objs ) ; }
{ super ( commonTypes ) ; this . objs = checkNotNull ( objs ) ; }
@ Override protected ImmutableSet < EnumType > getEnums () { return checkNotNull ( enums ) ; }
@ Override protected ImmutableSet < ObjectType > getObjs () { return checkNotNull ( objs ) ; }
@ Override public final Iterable < TypeI > getParameterTypes () { return checkNotNull ( getFunType () ) . getParameterTypes () ; }
{ checkState ( this . isSingletonObj () ) ; return this . getNominalTypeIfSingletonObj () . isClassy () ; }
checkState ( this . isSingletonObj () ) ;
{ checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getPropertyDefSite ( propertyName ) ; }
{ checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getOwnPropertyDefSite ( propertyName ) ; }
checkState ( this . isSingletonObj () ) ;
checkState ( this . isSingletonObj () ) ;
{ checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getReturnType () ; }
{ checkState ( this . isFunctionType () ) ; return this . getFunTypeIfSingletonObj () . getMinArity () ; }
checkState ( this . isFunctionType () ) ;
{ checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getThisType () ; }
checkState ( this . isFunctionType () ) ;
{ checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getInstanceTypeOfCtor () != null ; }
checkState ( this . isFunctionType () ) ;
checkArgument ( pname . isIdentifier () ) ;
checkArgument ( pname . isIdentifier () ) ;
checkState ( ! getObjs () . isEmpty () ) ;
checkArgument ( type != null ) ;
checkNotNull ( arrayType ) ;
checkArgument ( pname . isIdentifier () ) ;
if ( getObjs () . isEmpty () ) { checkState ( ! getEnums () . isEmpty () ) ; return this ; }
checkState ( ! areSubtypes ) ;
checkNotNull ( type ) ;
checkState ( this . isSingletonObj () ) ;
checkState ( ! getObjs () . isEmpty () ) ;
private JSType ( JSTypes commonTypes ) { checkNotNull ( commonTypes ) ; this . commonTypes = commonTypes ; }
checkState ( newExpr . isNew () ) ;
checkState ( newExpr . isNew () ) ;
checkArgument ( NodeUtil . isCallOrNew ( call ) , STRING_CONSTANT ) ;
checkArgument ( function . isFunction () , STRING_CONSTANT ) ;
checkState ( value . getParent () == null ) ;
checkState ( DefinitionUseSiteFinder . isCallOrNewSite ( site ) ) ;
checkState ( compiler . getLifeCycleStage () == LifeCycleStage.NORMALIZED ) ;
checkArgument ( ! isIdentifier () ) ;
{ checkArgument ( ! isIdentifier () ) ; return new QualifiedName ( parts . subList ( NUMBER_CONSTANT , parts . size () ) ) ; }
checkArgument ( fnNode . isFunction () ) ;
checkArgument ( unsafe != null ) ;
{ checkState ( ! NodeUtil . isFunctionObjectApply ( callNode ) ) ; argMap . put ( THIS_MARKER , NodeUtil . newUndefinedNode ( callNode ) ) ; }
checkArgument ( n . isScript () ) ;
checkNotNull ( lValue ) ;
void setIn ( L in ) { checkNotNull ( in ) ; this . in = in ; }
checkState ( outBefore . size () == state.out . size () ) ;
void setOut ( L out ) { checkNotNull ( out ) ; this . out = out ; }
void setIn ( L in ) { checkNotNull ( in ) ; this . in = in ; }
{ checkNotNull ( dep ) ; Preconditions . checkState ( dep != this , STRING_CONSTANT , this ) ; deps . add ( dep ) ; }
checkState ( inputs . contains ( other ) ) ;
checkState ( n . isSwitch () ) ;
checkState ( allCatchNodes . hasOneChild () ) ;
checkArgument ( type instanceof TypeDeclarationNode ) ;
checkNotNull ( reader ) ;
{ checkNotNull ( whitelist ) ; this . whitelist = normalizeWhitelist ( whitelist ) ; }
public JSTypeExpression getTypeExprForErrorReporting () { checkState ( this . state == State.DURING_RESOLUTION ) ; return typeExpr ; }
checkState ( this . state != State.RESOLVED ) ;
public JSType getPropType () { checkState ( this . state == State.RESOLVED ) ; return enumPropType ; }
public JSType getEnumeratedType () { checkState ( this . state == State.RESOLVED ) ; return declaredType ; }
checkNotNull ( typeExpr ) ;
{ checkState ( isVarBlock ( n ) ) ; return n . getFirstChild () ; }
{ checkState ( isReturnExpressBlock ( n ) ) ; return n . getFirstFirstChild () ; }
{ checkState ( isFoldableExpressBlock ( n ) ) ; return n . getFirstChild () ; }
checkArgument ( n . isNot () ) ;
checkState ( objLit . isObjectLit () ) ;
checkState ( objLit . isObjectLit () ) ;
checkState ( script . isScript () ) ;
checkArgument ( declaration . isName () || declaration . isStringKey () ) ;
{ checkState ( isCallOrNew ( call ) ) ; return getNthSibling ( call . getSecondChild () , index ) ; }
{ checkState ( function . isFunction () ) ; return getNthSibling ( function . getSecondChild () . getFirstChild () , index ) ; }
{ checkArgument ( fnNode . isFunction () ) ; return fnNode . getSecondChild () ; }
{ checkArgument ( n . isNormalBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
{ checkArgument ( n . isTry () ) ; return n . getSecondChild () ; }
{ checkArgument ( n . isTry () ) ; return n . getChildCount () == NUMBER_CONSTANT ; }
checkArgument ( NodeUtil . isObjectDefinePropertiesDefinition ( definePropertiesCall ) ) ;
{ checkState ( isLValue ( n ) ) ; lhsNodes . add ( n ) ; }
{ checkArgument ( function . isFunction () ) ; return isNameReferenced ( function . getLastChild () , STRING_CONSTANT , MATCH_NOT_THIS_BINDING ) ; }
{ checkArgument ( fn . isFunction () , fn ) ; return fn . getLastChild () ; }
checkState ( block . isNormalBlock () ) ;
checkState ( tryNode . isTry () ) ;
checkState ( n . isName () , n ) ;
checkState ( objlit . isObjectLit () ) ;
checkState ( n . isObjectLit () || n . isClassMembers () ) ;
{ checkState ( n . isNew () , n ) ; return n . isOnlyModifiesThisCall () ; }
{ checkState ( n . isCall () , n ) ; return ( n . getSideEffectFlags () & Node.FLAG_LOCAL_RESULTS ) > NUMBER_CONSTANT ; }
checkState ( node . hasTwoChildren () , node ) ;
{ checkArgument ( n . isClass () ) ; return n . getLastChild () ; }
checkState ( n . isFunction () || n . isClass () ) ;
checkState ( n . isFunction () || n . isClass () ) ;
checkState ( descriptor . isObjectLit () ) ;
checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
checkNotNull ( var ) ;
checkState ( function . isFunction () ) ;
checkState ( function . isFunction () ) ;
if ( modifyCallSites ) { checkNotNull ( defFinder ) ; callSiteOptimizer = new CallSiteOptimizer ( compiler , defFinder ) ; }
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
{ checkState ( this . fn == null ) ; this . fn = fn ; }
checkArgument ( changed != null ) ;
checkState ( functionState . hasExistingFunctionDefinition () ) ;
checkState ( n . isName () , n ) ;
checkState ( name . isName () ) ;
checkState ( NodeUtil . isGet ( child ) ) ;
checkArgument ( fn . isFunction () ) ;
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
checkNotNull ( data ) ;
{ checkState ( hasProcessBeenRun , STRING_CONSTANT ) ; return definitionNodeByDefinitionSite . values () ; }
checkNotNull ( site ) ;
checkState ( ! hasProcessBeenRun , STRING_CONSTANT ) ;
checkNotNull ( colorToNodeMap , STRING_CONSTANT ) ;
int exitCodeValue = checkNotNull ( exitCode ) ;
{ checkNotNull ( entryPoints ) ; this . entryPoints = entryPoints ; return this ; }
{ checkState ( NUMBER_CONSTANT == Iterables . size ( inputs ) ) ; return; }
checkState ( compiler . getOptions () . outputJs == OutputJs.NORMAL ) ;
checkState ( specs != null ) ;
checkState ( zipEntryName . contains ( filename ) ) ;
checkNotNull ( input ) ;
{ this . exitCodeReceiver = checkNotNull ( newExitCodeReceiver ) ; }
checkArgument ( inputsSupplier == null ^ modulesSupplier == null ) ;
checkState ( currentInfo != null ) ;
{ this . compilerOptions = checkNotNull ( compilerOptions ) ; return this ; }
{ checkState ( c . isScript () ) ; hotSwapScript ( c , null ) ; }
checkNotNull ( sourceString ) ;
checkArgument ( js.length == NUMBER_CONSTANT , STRING_CONSTANT ) ;
checkState ( block . isNormalBlock () ) ;
{ checkState ( nameNode . isQualifiedName () ) ; return nameNode . getLastChild () . getString () . startsWith ( STRING_CONSTANT ) ; }
checkState ( TokenStream . isJSIdentifier ( tempVarName ) ) ;
checkArgument ( newSourceInd < sources . size () ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( result != null ) ;
checkState ( n . isNew () || n . isCall () ) ;
checkState ( compiler . getLifeCycleStage () == LifeCycleStage.NORMALIZED ) ;
checkState ( null == m . put ( type , top ) ) ;
{ Integer priority = priorities . get ( n ) ; checkNotNull ( priority ) ; return priority ; }
checkState ( handler . isTry () ) ;
checkState ( cur . getParent () != null , STRING_CONSTANT ) ;
{ checkState ( next . isCase () ) ; createEdge ( node , Branch.ON_FALSE , next ) ; }
{ checkState ( exceptionHandler . peek () == parent ) ; exceptionHandler . pop () ; }
String aliasExpanded = checkNotNull ( aliasDefinition . getQualifiedName () ) ;
{ checkState ( ! aliasReference . hasChildren () ) ; aliasReference . addChildToFront ( replacement ) ; }
checkState ( matches . size () == NUMBER_CONSTANT , matches ) ;
checkState ( currentStatement . isDo () ) ;
checkNotNull ( compiler ) ;
{ checkState ( parent == scope . getParent () ) ; }
checkArgument ( nameNode . isName () ) ;
checkArgument ( ancestors.length > NUMBER_CONSTANT ) ;
private int getMaskForBitIndex ( int bitIndex ) { checkArgument ( bitIndex >= NUMBER_CONSTANT , STRING_CONSTANT ) ; return NUMBER_CONSTANT < < bitIndex ; }
checkState ( t . getScope () . isFunctionBlockScope () ) ;
{ checkNotNull ( edgeAnnotationStack , STRING_CONSTANT ) ; popAnnotations ( edgeAnnotationStack ) ; }
{ checkNotNull ( nodeAnnotationStack , STRING_CONSTANT ) ; popAnnotations ( nodeAnnotationStack ) ; }
{ checkState ( call . isCall () ) ; call . putBooleanProp ( Node.FREE_CALL , true ) ; return call ; }
{ checkState ( parent . isCall () ) ; compiler . report ( JSError . make ( parent , GOOG_CLASS_DESCRIPTOR_NOT_VALID ) ) ; }
checkArgument ( call . isCall () ) ;
{ checkState ( parent . isVar () ) ; parent . removeChild ( nameNode ) ; }
{ checkState ( NodeUtil . createsBlockScope ( root ) , scope ) ; symbolStack . push ( new NameContext ( anonymousNode , scope ) ) ; }
checkState ( isGeneric () ) ;
{ checkState ( isGeneric () ) ; return substituteParametricGenerics ( typeMap ) ; }
{ for ( String typeParam : this . typeParameters ) { checkState ( ! typeMap . containsKey ( typeParam ) ) ; } }
checkState ( this . isLoose () || f2 . isLoose () ) ;
{ checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ; f1 . isSubtypeOfHelper ( f2 , true , subSuperMap , boxedInfo ) ; }
checkArgument ( f1 . isLoose () || f2 . isLoose () ) ;
checkArgument ( ! isTopFunction () ) ;
{ checkState ( ! isTopFunction () ) ; return requiredFormals . size () ; }
{ checkState ( ! isTopFunction () ) ; return outerVarPreconditions . get ( name ) ; }
checkState ( ! isTopFunction () ) ;
public JSType getRestFormalsType () { checkNotNull ( restFormals ) ; return restFormals ; }
checkState ( isUniqueConstructor () ) ;
checkNotNull ( commonTypes ) ;
checkArgument ( o instanceof DeferredCheck ) ;
checkArgument ( pname . isIdentifier () ) ;
checkState ( insideQualifiedName ) ;
checkNotNull ( type ) ;
checkArgument ( pname == null || pname . isIdentifier () ) ;
checkNotNull ( type ) ;
{ checkArgument ( ! varName . contains ( STRING_CONSTANT ) ) ; return env . putType ( varName , type ) ; }
{ checkArgument ( ! pname . contains ( STRING_CONSTANT ) ) ; return env . getType ( pname ) ; }
checkArgument ( expr . isNew () || expr . isCall () ) ;
checkArgument ( callNode . isCall () || callNode . isNew () ) ;
checkNotNull ( type ) ;
checkArgument ( thisExpr . isThis () ) ;
checkState ( propAccessNode . isGetProp () || propAccessNode . isGetElem () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( propAccessNode . isGetProp () || propAccessNode . isGetElem () ) ;
checkNotNull ( funType ) ;
checkState ( receiver == null || isFwd ) ;
checkState ( ! formalType . isBottom () ) ;
checkArgument ( call . isCall () ) ;
checkState ( logicalOp == Token.AND ) ;
checkState ( n != null , STRING_CONSTANT ) ;
TypeEnv outEnv = checkNotNull ( getOutEnv ( dn ) ) ;
if ( fnType . getFunType () == null ) { checkState ( fnType . isUnknown () ) ; return this . commonTypes . qmarkFunction () ; }
checkState ( qnameRoot . isName () ) ;
{ checkNotNull ( original ) ; return original != this . node || this . isChanged () ; }
{ checkState ( this . isNot () ) ; return ( normalizeChildren ( node , children ) [ NUMBER_CONSTANT ] ) . change () ; }
checkNotNull ( n . getParent () ) ;
checkState ( n . getParent () != null ) ;
checkNotNull ( dNode ) ;
checkNotNull ( dNode ) ;
if ( doSanityChecks && sourceFile != null ) { checkState ( sourceFile . equals ( n . getSourceFileName () ) ) ; }
{ checkState ( this . declaration == null ) ; this . declaration = ref ; }
if ( otherScopeParent == null ) { checkState ( globalScope == null , STRING_CONSTANT ) ; }
checkNotNull ( declNode ) ;
checkState ( fn . isConstructor () || fn . isInterface () ) ;
checkState ( fn . isConstructor () || fn . isInterface () ) ;
checkArgument ( destructuringLhs . isDestructuringLhs () ) ;
{ checkState ( lhs . isName () ) ; checkShortName ( t , lhs , callNode . getLastChild () . getString () ) ; }
checkState ( callNode . isCall () ) ;
checkState ( currentModule == null ) ;
{ checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ; this . compiler = compiler ; }
{ checkState ( languageIn != LanguageMode.NO_TRANSPILE ) ; this . languageIn = languageIn ; }
{ checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
checkNotNull ( entryPoints ) ;
{ checkArgument ( funAstSize > NUMBER_CONSTANT ) ; this . maxFunctionSizeAfterInlining = funAstSize ; }
checkState ( value instanceof String ) ;
checkState ( script . isScript () ) ;
checkState ( script . isScript () ) ;
checkState ( script . isScript () ) ;
checkState ( script . isScript () ) ;
{ checkState ( hasReferenceName () ) ; return getReferenceName () . hashCode () ; }
{ checkState ( n . getParent () . getFirstChild () == n ) ; return n . getParent () . cloneTree () . getFirstChild () ; }
if ( n . isScript () ) { checkState ( this . script == null ) ; this . script = n ; }
checkState ( root . isScript () ) ;
checkState ( root . isScript () ) ;
checkState ( newReachable . getAnnotation () != REACHABLE ) ;
checkNotNull ( compiler ) ;
{ super ( source ) ; checkNotNull ( source ) ; this . excerpt = excerpt ; }
checkNotNull ( paramType , STRING_CONSTANT ) ;
checkState ( n . isAssign () ) ;
protected boolean isASTNormalized () { checkNotNull ( compiler ) ; return compiler . getLifeCycleStage () . isNormalized () ; }
{ checkNotNull ( compiler ) ; return compiler . areNodesEqualForInlining ( n1 , n2 ) ; }
checkNotNull ( typeParameters ) ;
{ checkState ( this . nominalType == null ) ; this . nominalType = t ; return this ; }
{ checkState ( returnType == null ) ; returnType = t ; return this ; }
{ checkState ( restFormals == null ) ; restFormals = t ; return this ; }
checkArgument ( ! t . isBottom () ) ;
public FunctionTypeBuilder ( JSTypes commonTypes ) { this . commonTypes = checkNotNull ( commonTypes ) ; }
checkArgument ( qName != null && ownerName != null ) ;
checkArgument ( ! variableName . isEmpty () ) ;
{ checkNotNull ( inputId ) ; sourceName = NodeUtil . getSourceName ( n ) ; }
checkArgument ( o instanceof Property ) ;
checkArgument ( inferredType != null ) ;
checkNotNull ( inputId ) ;
checkNotNull ( inputId ) ;
{ super ( registry , templateTypeMap ) ; setReferencedType ( checkNotNull ( referencedType ) ) ; }
checkState ( DEFAULT_EXTERNS . length () != externs . length () ) ;
checkState ( behaviorObjLit . isObjectLit () ) ;
checkState ( behaviorObjLit . isObjectLit () ) ;
checkNotNull ( keys ) ;
checkNotNull ( namedType ) ;
{ checkNotNull ( name ) ; nonNullableTypeNames . add ( name ) ; }
checkArgument ( source == null || source . isFunction () ) ;
checkState ( source . isFunction () , source ) ;
{ checkState ( namesToTypes . containsKey ( name ) ) ; register ( t , name ) ; }
{ checkArgument ( ! name . contains ( STRING_CONSTANT ) , STRING_CONSTANT ) ; namesToTypes . put ( name , type ) ; }
public TemplateType getObjectIndexKey () { checkNotNull ( iObjectIndexTemplateKey ) ; return this . iObjectIndexTemplateKey ; }
checkNotNull ( inputId ) ;
checkState ( n . hasOneChild () , n ) ;
{ checkArgument ( compiler . getLifeCycleStage () . isNormalized () ) ; this . compiler = compiler ; }
{ checkNotNull ( realSource ) ; this . realSource = realSource ; this . reportParseErrors = reportParseErrors ; }
checkNotNull ( declaration ) ;
checkState ( parent . isClassMembers () ) ;
checkState ( parent . isObjectLit () ) ;
checkState ( obj instanceof AstChange ) ;
checkArgument ( functionName != null ) ;
checkArgument ( parameterName != null ) ;
checkState ( labeledVariable . isVar () ) ;
Property nameProp = checkNotNull ( getOrCreateProperty ( n ) ) ;
{ checkArgument ( blockNode . isNormalBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
checkArgument ( assignedAt . isQualifiedName () ) ;
{ checkArgument ( lhs . isQualifiedName () ) ; writes . addLast ( new PropertyWrite ( lhs ) ) ; }
checkArgument ( obj . isObjectLit () ) ;
{ checkNotNull ( internalScopeCreator ) ; internalScopeCreator . patchGlobalScope ( topScope , scriptRoot ) ; }
checkState ( defParent . isExprResult () ) ;
checkArgument ( use . isName () ) ;
checkState ( t . getScopeRoot () . isFunction () ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( callOrNew . isCall () || callOrNew . isNew () ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkArgument ( userOrderedInputs . containsAll ( rootInputs ) ) ;
checkState ( nameNode != null ) ;
checkState ( ! name . isEmpty () ) ;
checkState ( ! current.renameMap . containsKey ( name ) ) ;
checkState ( fnNode . isFunction () ) ;
checkState ( callNode . isCall () ) ;
checkState ( ORDER_CODE_REPLACEMENTS . isOrdered ( replacements ) ) ;
checkState ( ORDER_CODE_REPLACEMENTS . isOrdered ( replacements ) ) ;
{ checkState ( n . isFunction () , n ) ; return true ; }
checkState ( this . namespaceType == null ) ;
checkNotNull ( interfaceType ) ;
checkNotNull ( node ) ;
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels () ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true ) ; }
{ return new J2clClinitPrunerPass ( compiler ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () ) ; }
EnvTypePair pair = analyzeExprFwd ( prop , recvLvalue.env , firstNonBottom ( indexType , UNKNOWN ) ) ;
builder . put ( typeParam , firstNonBottom ( t , UNKNOWN ) ) ;
pair = analyzeExprFwd ( index , pair.env , firstNonBottom ( indexType , UNKNOWN ) ) ;
{ builder . addRetType ( firstNonBottom ( actualRetType , TOP ) ) ; }
moduleResolutionMode = ModuleLoader.ResolutionMode.BROWSER ;
public void testEs6ThisWithImportModule () { testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , Es6CheckModule.ES6_MODULE_REFERENCES_THIS ) ; }
String result = STRING_CONSTANT ;
String result = STRING_CONSTANT + STRING_CONSTANT ;
if ( forAnnotations ) { return sb . append ( this . primitiveType ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new UnreachableCodeElimination ( compiler ) ; }
{ @ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler ) ; } }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopeNodes , this , false ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler , true ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () , true ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ return new J2clClinitPrunerPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true , true ) ; }
{ this ( config , errorReporter , source , offset , false ) ; }
return new ParseResult ( root , comments , features , p . getSourceMapURL () ) ;
Node objectLit = n . getFirstChild () . getFirstFirstChild () ;
@ Override MustDef createEntryLattice () { return new MustDef ( returnAllVars () ) ; }
return JSType . fromObjectType ( ObjectType . fromNominalType ( tmp . substituteGenerics ( typeMap ) ) ) ;
return nominal == null ? null : nominal . substituteGenerics ( this . commonTypes . MAP_TO_UNKNOWN ) . getInstanceAsJSType () ;
{ if ( interf . inheritsFromIObjectReflexive () ) { result . add ( interf . substituteGenerics ( typeMap ) ) ; } }
for ( NominalType interf : this . rawType . getInterfaces () ) { result . add ( interf . substituteGenerics ( typeMap ) ) ; }
return this . rawType . getSuperClass () . substituteGenerics ( typeMap ) ;
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , builder ) ; }
! invalidatingTypes . isInvalidating ( dest )
! props . containsKey ( propName ) && ! invalidatingTypes . isInvalidating ( type ) && NodeUtil . isImmutableValue ( value ) && NodeUtil . isExecutedExactlyOnce ( value )
{ fn = fn == null ? null : fn . withLoose () ; props = joinPropsLoosely ( obj1.props , obj2.props ) ; }
{ props = joinPropsLoosely ( obj1.props , obj2.props ) ; }
if ( doSlicing ) { pair.env = envPutType ( pair.env , name , firstNonNull ( declType , UNKNOWN ) ) ; }
preciseType = firstNonNull ( declType , requiredType ) ;
{ JSType result = ft . getSuperPrototype () ; pair.type = firstNonNull ( result , UNDEFINED ) ; return pair ; }
{ JSType tmp = t . getIndexedType () ; return firstNonNull ( tmp , UNKNOWN ) ; }
declRetType = firstNonNull ( declRetType , UNKNOWN ) ;
throw new IllegalStateException ( STRING_CONSTANT + name . getToken () ) ;
{ return new InstrumentFunctions ( compiler , compiler . getFunctionNames () , options.instrumentationTemplate , options.appNameStr ) ; }
{ compiler . setVariableMap ( runVariableRenaming ( compiler , prevVariableMap , externs , root ) ) ; }
compiler . setPropertyMap ( rprop . getPropertyMap () ) ;
compiler . setAnonymousFunctionNameMap ( naf . getFunctionMap () ) ;
{ return new CrossModuleMethodMotion ( compiler , compiler . getCrossModuleIdGenerator () , options.removeUnusedPrototypePropertiesInExterns , options.crossModuleCodeMotionNoStubMethods ) ; }
compiler . setStringMap ( pass . getStringMap () ) ;
compiler . setIdGeneratorMap ( pass . getSerializedIdMappings () ) ;
compiler . setFunctionNames ( pass . getFunctionNames () ) ;
compiler . setCssNames ( newCssNames ) ;
{ return new CrossModuleMethodMotion ( compiler , new IdGenerator () , canMoveExterns , noStubs ) ; }
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives || this . shouldGenerateTypedExterns () ; }
preserveClosurePrimitives = false ;
public static Matcher googModuleOrProvide () { return anyOf ( googModule () , functionCall ( STRING_CONSTANT ) ) ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
parseWarning ( STRING_CONSTANT , STRING_CONSTANT ) ;
skipStringLiteralEscapeSequence ( true ) ;
private boolean skipStringLiteralChar () { if ( peek ( CHAR_CONS ) ) { return skipStringLiteralEscapeSequence ( false ) ; } nextChar () ; return true ; }
return isUnknown () || ( isAmbiguousObject () && isLoose () ) || ( ft != null && ft . isTopFunction () ) ;
objType == null || types . contains ( objType ) || objType . isAmbiguousObject () || objType . isUnknownType () || objType . isBottom ()
return objType . isAmbiguousObject () || ( ft != null && ft . isConstructor () && isInvalidatingType ( ft . getInstanceType () ) ) ;
TypeI type
TypeI type
TypeI type
boolean mustReplaceThisAndArguments () { return isAsyncContext () || thisAndArgumentsContext . isAsyncContext () ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
parent . getParent () . isCall () && NodeUtil . isInvocationTarget ( parent )
checkArgument ( expr . isCall () || expr . isTaggedTemplateLit () ) ;
checkArgument ( n . isFunction () || ( n . isName () && NodeUtil . isInvocationTarget ( n ) ) ) ;
return analyzeInvocationArgsFwdWhenError ( call , inEnv ) ;
{ checkArgument ( ! pname . contains ( STRING_CONSTANT ) , pname ) ; return env . getType ( pname ) ; }
for ( FunctionTypeI impl : constructor . getDirectSubTypes () ) { list . add ( impl . getInstanceType () ) ; }
if ( constructor != null ) { for ( FunctionTypeI subType : constructor . getDirectSubTypes () ) { addRelatedInstance ( subType , related ) ; } }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveGoogProvidesAndRequires || this . shouldGenerateTypedExterns () ; }
preserveGoogProvidesAndRequires = false ;
options . setWarningLevel ( DiagnosticGroups.UNNECESSARY_ESCAPE , CheckLevel.WARNING ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.TEMPLATE_ARGUMENT_MISSING ) ;
testSame ( TEST_EXTERNS + externs , STRING_CONSTANT , GlobalTypeInfoCollector.REDECLARED_PROPERTY ) ;
testSame ( TEST_EXTERNS + externs , STRING_CONSTANT , GlobalTypeInfoCollector.REDECLARED_PROPERTY ) ;
typeCheck ( js , GlobalTypeInfoCollector.CTOR_IN_DIFFERENT_SCOPE , NewTypeInference.MISTYPED_ASSIGN_RHS ) ;
typeCheck ( js , GlobalTypeInfoCollector.ANONYMOUS_NOMINAL_TYPE , GlobalTypeInfoCollector.ANONYMOUS_NOMINAL_TYPE , NewTypeInference.MISTYPED_ASSIGN_RHS ) ;
typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.INEXISTENT_PARAM ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfoCollector.WRONG_PARAMETER_COUNT ) ;
public void testUnknownTypeReferenceDoesntCrash () { typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ; }
typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.INEXISTENT_PARAM ) ;
public void testVarDecls () { typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.ONE_TYPE_FOR_MANY_VARS ) ; typeCheck ( STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; typeCheck ( STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; }
typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ;
typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ;
testSame ( DEFAULT_EXTERNS , STRING_CONSTANT , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ;
this . symbolTable = ( GlobalTypeInfo ) compiler . getGlobalTypeInfo () ;
passes . add ( makePassFactory ( STRING_CONSTANT , new GlobalTypeInfoCollector ( compiler ) ) ) ;
test ( options , STRING_CONSTANT , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ;
@ Override protected CompilerPass create ( final AbstractCompiler compiler ) { return new GlobalTypeInfoCollector ( compiler ) ; }
globalTypeInfo = compilerState.globalTypeInfo ;
this . globalTypeInfo = compiler.globalTypeInfo ;
return getGlobalTypeInfo () . getImplicitInterfaceUses () ;
return getGlobalTypeInfo () . getMismatches () ;
globalTypeInfo = null ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfoCollector.INVALID_PROP_OVERRIDE ) ;
ignoreWarnings ( GlobalTypeInfoCollector.INTERFACE_METHOD_NOT_IMPLEMENTED , TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) , getRequiresEs6Message ( Feature.ARRAY_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) , getRequiresEs6Message ( Feature.ARRAY_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.TRAILING_COMMA ) ) ;
parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.TRAILING_COMMA ) ) ;
parseWarning ( js , warning ) ;
@ Nullable Node ast
features = factory . getFeatures () ;
ImmutableMap . < Pattern , DiagnosticType > builder () . put ( Pattern . compile ( STRING_CONSTANT + STRING_CONSTANT ) , TRAILING_COMMA )
{ features = features . with ( Feature.ACCESSIBILITY_MODIFIER ) ; return nextToken () . type ; }
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) ) ;
parseWarning ( STRING_CONSTANT , TRAILING_COMMA_MESSAGE ) ;
parseWarning ( STRING_CONSTANT , TRAILING_COMMA_MESSAGE ) ;
parseWarning ( js , warning , warning ) ;
Node ast
features = features . union ( factory . getFeatures () ) ;
ImmutableMap . < Pattern , DiagnosticType > builder () . put ( Pattern . compile ( STRING_CONSTANT ) , TRAILING_COMMA )
{ features = features . union ( FeatureSet.TYPESCRIPT ) ; return nextToken () . type ; }
new CheckMissingAndExtraRequires ( compiler , CheckMissingAndExtraRequires.Mode.SINGLE_FILE )
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckMissingAndExtraRequires ( compiler , CheckMissingAndExtraRequires.Mode.FULL_COMPILE ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new CheckMissingAndExtraRequires ( compiler , CheckMissingAndExtraRequires.Mode.SINGLE_FILE ) ; }
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new CheckMissingAndExtraRequires ( compiler , CheckMissingAndExtraRequires.Mode.FULL_COMPILE ) ; }
public void testFailGoogArray () { mode = CheckMissingAndExtraRequires.Mode.SINGLE_FILE ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testFailConstant () { mode = CheckMissingAndExtraRequires.Mode.SINGLE_FILE ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckMissingAndExtraRequires ( compiler , mode ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; mode = CheckMissingAndExtraRequires.Mode.FULL_COMPILE ; }
n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ( ! jsScope . isDeclared ( ARGUMENT_ARRAY_ALIAS , false ) || ! childDeclared )
{ return n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ! jsScope . isDeclared ( ARGUMENT_ARRAY_ALIAS , false ) ; }
if ( ! jsScope . isDeclared ( name , false ) ) { return; }
assertTrue ( fBlockScope . isDeclaredInFunctionBlockOrParameter ( STRING_CONSTANT ) ) ;
assertTrue ( fBlockScope . isDeclaredInFunctionBlockOrParameter ( STRING_CONSTANT ) ) ;
assertTrue ( fBlockScope . isDeclaredInFunctionBlockOrParameter ( STRING_CONSTANT ) ) ;
if ( ! functionBlockScope . isDeclaredInFunctionBlockOrParameter ( name ) ) { return; }
if ( current . isDeclared ( oldName , false ) ) { return; } else { current = current . getParent () ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives || this . shouldGenerateTypedExterns () ; }
preserveClosurePrimitives = false ;
public static Matcher googModuleOrProvide () { return anyOf ( googModule () , functionCall ( STRING_CONSTANT ) ) ; }
maybeProcessAccessibilityModifier ( tree , member , tree.access ) ;
maybeProcessAccessibilityModifier ( tree , n , tree.access ) ;
maybeProcessAccessibilityModifier ( functionTree , member , functionTree.access ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; enableTranspile () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; enableTranspile () ; }
{ env = analyzeExprBwd ( prop , env , enumeratedType ) . env ; }
EnvTypePair pair = analyzeExprBwd ( prop , env , reqPtype ) ;
EnvTypePair pair = analyzeExprFwd ( prop , env , enumeratedType ) ;
EnvTypePair pair = analyzeExprFwd ( prop , env , reqPtype , specPtype ) ;
PropertyDef propdef = checkNotNull ( getPropDefFromClass ( superType , pname ) , STRING_CONSTANT , superType , pname ) ;
return state . getIn () . reachingDef . get ( allVarsInFn . get ( name ) ) ;
Var dep = allVarsInFn . get ( n . getString () ) ;
@ Override MustDef createEntryLattice () { return new MustDef ( allVarsInFn . values () ) ; }
Collection < Var > vars
return state . getOut () . mayUseMap . get ( allVarsInFn . get ( name ) ) ;
{ Pattern pattern = new Pattern () ; pattern.regExp = new RegExp ( string ) ; return pattern ; }
node = new Node < E > ( e ) ;
Map < Node < E > , ImmutableSet.Builder < E > > groupsTmp = Maps . newLinkedHashMap () ;
@ Nullable E e
@ Override public void add ( @ Nullable E e ) { union ( e , e ) ; }
{ for ( E elem : other . elements () ) { union ( other . find ( elem ) , elem ) ; } }
public void testUnusedLocalConst_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; }
public void testUnusedLocalConst () { enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; }
public void testUnusedLocalLet_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; }
{ enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; assertUnused ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
assertUnused ( STRING_CONSTANT ) ;
public void testDefaultParam_withES6Modules () { assertEarlyReferenceError ( STRING_CONSTANT ) ; assertNoWarning ( STRING_CONSTANT ) ; }
public void testES6Module_destructuring () { enableUnusedLocalAssignmentCheck = true ; assertNoWarning ( STRING_CONSTANT ) ; }
public void testUnusedCompoundAssign_withES6Modules () { assertNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testUsedInShorthandObjLit_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUndeclared ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
assertUndeclared ( STRING_CONSTANT ) ;
public void testForOf () { assertEarlyReferenceError ( STRING_CONSTANT ) ; assertNoWarning ( STRING_CONSTANT ) ; }
public void testRedeclare_withES6Modules () { assertRedeclare ( STRING_CONSTANT ) ; assertNoWarning ( STRING_CONSTANT ) ; }
assertNoWarning ( STRING_CONSTANT ) ;
NodeUtil . isNameDeclaration ( parent )
@ Nullable Pattern includeFilePattern
new ProcessDefines ( compiler , ImmutableMap . copyOf ( replacements ) , options.checksOnly ) . injectNamespace ( namespaceForChecks ) . process ( externs , jsRoot ) ;
Set < String > defines = new ProcessDefines ( compiler , null , false ) . collectDefines ( externs , root ) . keySet () ;
{ overrideDefines ( collectDefines ( externs , root ) ) ; }
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
ImmutableSet . of ( TokenType.IDENTIFIER , TokenType.TYPE , TokenType.DECLARE , TokenType.MODULE , TokenType.NAMESPACE ) . contains ( type )
! peekId () && ! ImmutableSet . of ( TokenType.VOID , TokenType.OPEN_PAREN , TokenType.OPEN_CURLY , TokenType.TYPEOF ) . contains ( peekType () )
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.ES3 ; }
recordPropertyName ( getProp . getLastChild () ) ;
recordPropertyName ( prop ) ;
Function < Node , Void > recordPropertyName
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
new ProcessDefines ( compiler , overrides , doReplacements ) . injectNamespace ( namespace ) . process ( externs , js ) ;
new ProcessDefines ( compiler , ImmutableMap . copyOf ( replacements ) , ! options.checksOnly ) . injectNamespace ( namespaceForChecks ) . process ( externs , jsRoot ) ;
Set < String > defines = new ProcessDefines ( compiler , null , true ) . collectDefines ( externs , root ) . keySet () ;
n . isName () && isDeclaration ( n )
public boolean isAsyncFunction () { return isFunction () && getBooleanProp ( ASYNC_FN ) ; }
public boolean isArrowFunction () { return isFunction () && getBooleanProp ( ARROW_FN ) ; }
if ( key . isEmpty () || key . isComputedProp () ) { continue; }
invalidatingTypes . isInvalidating ( recvType ) || isStructuralInterfacePrototype ( recv )
{ if ( invalidatingTypes . isInvalidating ( type ) ) { invalidate () ; return false ; } rootTypesByNode . put ( node , type ) ; }
if ( invalidatingTypes . isInvalidating ( top ) ) { invalidate () ; return; }
PolymerPassStaticUtils . extractProperties ( behaviorValue , PolymerClassDefinition.DefinitionType.ObjectLiteral , compiler )
List < MemberDefinition > properties = PolymerPassStaticUtils . extractProperties ( behaviorValue , PolymerClassDefinition.DefinitionType.ObjectLiteral , compiler ) ;
new PolymerPass ( compiler , NUMBER_CONSTANT , true ) . process ( externs , root ) ;
new PolymerPass ( compiler , NUMBER_CONSTANT , false ) . process ( externsRoot , mainRoot ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
Property p = getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
Property p = getPropFromClass ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
rhs . matchesQualifiedName ( ABSTRACT_METHOD_NAME ) || ( GlobalTypeInfoCollector . isCtorDefinedByCall ( lhs ) && ! isFunctionBind ( rhs . getFirstChild () , inEnv , true ) )
( GlobalTypeInfoCollector . isCtorDefinedByCall ( nameNode ) && ! isFunctionBind ( rhs . getFirstChild () , inEnv , true ) )
if ( maybeWin != null ) { return maybeWin . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ; }
return this . nominalType . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
if ( nom != null ) { return nom . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ; }
Property p = this . rawType . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
Property p = this . rawType . getOwnProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
( ns . hasStaticProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , propDeclType , previousPropType ) )
isCtorDefinedByCall ( getProp )
classType . hasStaticProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , propDeclType , previousPropType )
isCtorDefinedByCall ( nameNode )
final CompilerPass simplifier = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeSimplifyRegExp () ) ;
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeRemoveDeadCode () ) ;
{ return new PeepholeOptimizationsPass ( compiler , getName () , new ExploitAssigns () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , getName () , new ReorderConstantExpression () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeCollectPropertyAssignments () ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeSubstituteAlternateSyntax ( late ) ) ;
{ PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new StatementFusion ( favorsCommas ) ) ; return peepholePass ; }
{ return new PeepholeOptimizationsPass ( compiler , getName () , new ExploitAssigns () ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return createPeepholeOptimizationsPass ( compiler , getName () ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return createPeepholeOptimizationsPass ( compiler , getName () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeRemoveDeadCode () ) ; }
computeEscapedEs6 ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
computeEscapedEs6 ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
computeEscapedEs6 ( jsScope , escaped , compiler , scopeCreator ) ;
if ( isObjLit ) { declareVariablesForObjLitValues ( n , alias , rvalue , varNode , varNode . getPrevious () , varParent ) ; }
super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( node ) ) ;
super ( isExtern , NameBasedDefinitionProvider . getSimplifiedName ( getLValue ( name ) ) ) ;
{ super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( node . getFirstChild () ) ) ; checkArgument ( node . isAssign () ) ; assignment = node ; }
{ super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( node . getFirstChild () ) ) ; Preconditions . checkArgument ( node . isClass () ) ; c = node ; }
{ super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( node . getFirstChild () ) ) ; checkArgument ( node . isFunction () ) ; function = node ; }
super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( lValue ) ) ;
Property p = this . rawType . getProp ( pname , PropAccess.EXCLUDE_STRAY_PROPS ) ;
superType . isInterface () && current . isClass () && ! isCtorDefinedByCall ( current ) && ! current . mayHaveNonStrayProp ( pname )
superClass . isAbstractClass () && superClass . hasAbstractMethod ( pname ) && ! rawType . isAbstractClass () && ! rawType . mayHaveOwnNonStrayProp ( pname )
if ( maybeWin != null ) { return maybeWin . getProp ( pname , PropAccess.EXCLUDE_STRAY_PROPS ) ; }
@ Override public boolean apply ( Node n ) { return isFunctionDeclaration ( n ) || NodeUtil . isNameDeclaration ( n ) ; }
NodeUtil . isNameDeclaration ( parent )
NodeUtil . isNameDeclaration ( n . getParent () )
! NodeUtil . isNameDeclOrSimpleAssignLhs ( callNode , parent )
! NodeUtil . isNameDeclOrSimpleAssignLhs ( name , name . getParent () )
{ if ( NodeUtil . isNameDeclOrSimpleAssignLhs ( parent , grandparent ) ) { validProperties . add ( propName ) ; } else { return false ; } }
NodeUtil . isNameDeclOrSimpleAssignLhs ( n , parent )
if ( NodeUtil . isNameDeclOrSimpleAssignLhs ( n , parent ) ) { if ( referring != null ) { recordReference ( referringName , name , RefType.REGULAR ) ; } return; }
if ( NodeUtil . isNameDeclOrSimpleAssignLhs ( n , parent ) ) { return; }
{ if ( nextParent == null || ! NodeUtil . isNameDeclOrSimpleAssignLhs ( nextNode , nextParent ) ) { readsState = true ; } }
NodeUtil . isNameDeclOrSimpleAssignLhs ( n , n . getParent () )
dest . isString () && NodeUtil . isExprAssign ( grandParent ) && NodeUtil . isNameDeclOrSimpleAssignLhs ( n , parent )
public void testEs6EnhancedObjLiteralsPropertyShorthand () { testSame ( STRING_CONSTANT ) ; }
public void testES6ClassComputedProperty () { testSame ( STRING_CONSTANT ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; }
final byte prop
byte propType
byte propType
byte propType
public void putBooleanProp ( byte propType , boolean value ) { putIntProp ( propType , value ? NUMBER_CONSTANT : NUMBER_CONSTANT ) ; }
byte propType
byte propType
byte propType
public boolean getBooleanProp ( byte propType ) { return getIntProp ( propType ) != NUMBER_CONSTANT ; }
byte propType
byte propType
byte propType
byte propType
byte propType
byte propType
@ Override public byte getType () { return propType ; }
byte propType
byte propType
Set < ? extends Var > escaped
Set < N > entrySet = new LinkedHashSet <> () ;
Set < N > nodes = new LinkedHashSet <> () ;
String lValueName = NodeUtil . getBestLValueName ( lValue ) ;
isStatementBlock ( parent ) || isSwitchCase ( node ) || node . isMemberFunctionDef ()
assertThat ( computeEscapedLocals ( STRING_CONSTANT ) ) . hasSize ( NUMBER_CONSTANT ) ;
validateChildCount ( n , NUMBER_CONSTANT ) ;
{ validateChildCount ( n , NUMBER_CONSTANT ) ; validateExpression ( n . getFirstChild () ) ; validateExpression ( n . getLastChild () ) ; }
private void validateUnaryOp ( Node n ) { validateChildCount ( n , NUMBER_CONSTANT ) ; validateExpression ( n . getFirstChild () ) ; }
new PeepholeReorderConstantExpression ()
{ if ( parent . isParamList () ) { return true ; } else if ( NodeUtil . isNameDeclaration ( parent ) ) { return n . hasChildren () ; } }
List < Scope > allScopes = liveness . getAllScopesInFunction () ;
assertThat ( statements . get ( NUMBER_CONSTANT ) . isMovableDeclaration () ) . isFalse () ;
{ if ( parent . isParamList () ) { return true ; } else if ( parent . isVar () ) { return n . hasChildren () ; } }
thisProps = ! thisNt . isBuiltinObject () && thisNt . isStructuralInterface () ? thisNt . getPropertyNames () : this . props . keySet ()
{ otherPropNames = otherNt . getPropertyNames () ; if ( otherPropNames == null ) { return false ; } }
QualifiedName setterPname = new QualifiedName ( commonTypes . createSetterPropName ( pname . getLeftmostName () ) ) ;
QualifiedName getterPname = new QualifiedName ( commonTypes . createGetterPropName ( pname ) ) ;
scopeRoots . add ( node ) ;
{ validateChildCount ( n ) ; validateLHS ( n . getToken () , n . getFirstChild () ) ; validateExpression ( n . getLastChild () ) ; }
{ validateLHS ( n . getParent () . getToken () , n ) ; }
public void testInvalidAnnotation5 ( ) throws Exception { testError ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
public void testInvalidAnnotation4 ( ) throws Exception { testError ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
if ( ! t . isHoistScope () ) { return; }
{ if ( t . isHoistScope () ) { pop ( blockStack ) ; } }
if ( t . isHoistScope () ) { blockStack . add ( new BasicBlock ( parent , n ) ) ; }
if ( t . isHoistScope () ) { pop ( blockStack ) ; }
if ( t . isHoistScope () ) { blockStack . add ( new BasicBlock ( parent , n ) ) ; }
Node hoistRoot = t . getClosestHoistScopeRoot () ;
{ if ( n . isVar () && t . getScopeRoot () != t . getClosestHoistScopeRoot () ) { hoistVarIfNeeded ( t , n , parent ) ; } }
if ( scopeType == ScopeType.EXEC_CONTEXT ) { return t . getClosestHoistScopeRoot () == currentScript.rootNode ; } else { return n . getParent () == currentScript.rootNode ; }
Node scopeRoot = t . getClosestHoistScopeRoot () ;
if ( ! n . hasChildren () ) { rewriteEs6ObjectLiteralShorthandPropertySyntax ( n ) ; reportCodeChange ( n , STRING_CONSTANT ) ; }
yield . setYieldAll ( tree.isYieldAll ) ;
if ( n . isYieldAll () ) { checkNotNull ( first ) ; add ( STRING_CONSTANT ) ; }
if ( isGlobal () || isModuleScope () ) { return null ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new ClosureOptimizePrimitives ( compiler , propertyRenamingEnabled , canUseEs6Syntax ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
Diagnostic warning
{ super . setUp () ; this . mode = TypeInferenceMode.NEITHER ; enableRunTypeCheckAfterProcessing () ; }
test ( srcs ( STRING_CONSTANT ) , warningOtiNti ( TOO_MANY_TEMPLATE_PARAMS , INVALID_GENERICS_INSTANTIATION ) ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( srcs ( STRING_CONSTANT ) , warningOtiNti ( TOO_MANY_TEMPLATE_PARAMS , INVALID_GENERICS_INSTANTIATION ) ) ; }
{ if ( parent . isParamList () ) { return true ; } else if ( NodeUtil . isNameDeclaration ( parent ) ) { return n . hasChildren () ; } }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
if ( hasParamWithInvalidPropertyNameIdentifier ( fnNode ) ) { functionState . setInline ( false ) ; }
NodeUtil . tryMergeBlock ( moduleBody , true ) ;
if ( newChild . isNormalBlock () ) { NodeUtil . tryMergeBlock ( newChild , false ) ; }
NodeUtil . tryMergeBlock ( scopeClosureBlock , false ) ;
NodeUtil . tryMergeBlock ( callbackBlock , false ) ;
if ( NodeUtil . tryMergeBlock ( n , false ) ) { reportCodeChange () ; return null ; }
NodeUtil . tryMergeBlock ( moduleBody , true ) ;
Throwable cause
catch ( Error | Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Error | Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Error | Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Error | Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
Throwable unexpectedException
abstract void throwInternalError ( String msg , Throwable cause ) ;
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isGeneric () ? nt . getRawNominalType () . getInstanceAsJSType () : null ; }
if ( ! init . isEmpty () && ! NodeUtil . isNameDeclaration ( init ) ) { init = trySimplifyUnusedResult ( init , false ) ; }
if ( NodeUtil . isNameDeclaration ( n ) && n . hasOneChild () && n . getFirstFirstChild () != null ) { return true ; }
return this . globalScope . getInstanceType ( typeName ) ;
JSType declRetType = this . currentScope . getDeclaredTypeForOwnBody () . getReturnType () ;
JSType declRetType = this . currentScope . getDeclaredTypeForOwnBody () . getReturnType () ;
DeclaredFunctionType dft = this . currentScope . getDeclaredTypeForOwnBody () ;
return this . registry . evaluateTypeExpression ( expr , this . typeEnv ) ;
TypeI type = typeEnv . getNamespaceType ( name ) ;
Node mapFunctionBody = NodeUtil . getFunctionBody ( mapFunction ) ;
this . registry = compiler . getTypeIRegistry () ;
List < String > names
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isGeneric () ? nt . getRawNominalType () . getInstanceAsJSType () : this ; }
{ TemplatizedType t = toMaybeTemplatizedType () ; return t == null ? this : t . getReferencedType () ; }
if ( STRING_CONSTANT . equals ( name ) ) { if ( ! hasThis () ) { return null ; } return getDeclaredTypeForOwnBody () . getThisType () ; }
EnumSet . of ( TokenType.IDENTIFIER , TokenType.TYPE , TokenType.DECLARE , TokenType.MODULE , TokenType.NAMESPACE ) . contains ( type )
! peekId () && ! EnumSet . of ( TokenType.VOID , TokenType.OPEN_PAREN , TokenType.OPEN_CURLY , TokenType.TYPEOF ) . contains ( peekType () )
compiler = CompilerTestCaseUtils . multistageSerializeAndDeserialize ( this , compiler , inputs , recentChange ) ;
{ functionBody . removeChild ( current ) ; insertAfter = addToFront ( functionBody , current , insertAfter ) ; reportCodeChange ( STRING_CONSTANT , functionBody ) ; }
reportCodeChange ( STRING_CONSTANT , n ) ;
reportCodeChange ( STRING_CONSTANT , n ) ;
boolean isFull () { return numUnfilledTemplateKeys () == NUMBER_CONSTANT ; }
compiler . getOptions () . setStrictModeInput ( true ) ;
public abstract Object getObjectValue ( ) ;
compiler . addToDebugLog ( STRING_CONSTANT , defineName ) ;
compiler . addToDebugLog ( STRING_CONSTANT , var.name ) ;
compiler . addToDebugLog ( STRING_CONSTANT , name , STRING_CONSTANT , newName ) ;
catch ( RuntimeException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
t . getCompiler () . addToDebugLog ( STRING_CONSTANT , fn . getName () ) ;
{ return new IntPropListItem ( propType , intValue , next ) ; }
{ return new ObjectPropListItem ( propType , objectValue , next ) ; }
public void testRestParamWithoutContext () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
var . setStaticSourceFileFrom ( name ) ;
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
assertPassOrder ( checks , chromePass , checkJsDocAndEs6Modules , STRING_CONSTANT ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
TypeParameters typeParameters
public List < String > getTypeParameters () { return this . typeParameters . asList () ; }
builder . addTypeParameters ( TypeParameters . make ( nt . getTypeParameters () ) ) ;
this . typeParameters = TypeParameters.EMPTY ;
TypeParameters typeParameters
TypeParameters typeParameters
public final boolean isDeleted () { return getBooleanProp ( DELETED ) ; }
@ Nullable final PropListItem getPropListHeadForTesting () { return propListHead ; }
public final int getSourcePosition () { return sourcePosition ; }
public final int getCharno () { return extractCharno ( sourcePosition ) ; }
public final int getLineno () { return extractLineno ( sourcePosition ) ; }
public final int getLength () { return this . length ; }
public final boolean hasProps () { return propListHead != null ; }
public final boolean hasChildren () { return first != null ; }
{ validateLHS ( n . getLastChild () . getToken () , n . getLastChild () ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; enableNormalize () ; }
NodeUtil . isNameDeclaration ( parent )
public void toStringIsEqualTo ( String typeString ) { assertEquals ( typeString , actual () . toString () ) ; }
if ( n . isParamList () ) { return; }
checks . add ( createEmptyPass ( PassNames.AFTER_STANDARD_CHECKS ) ) ;
passName . equals ( PassNames.PARSE_INPUTS )
checks . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
passName . equals ( Compiler.PARSING_PASS_NAME )
n . isName () && parent . isVar ()
checkState ( e != null , STRING_CONSTANT ) ;
Typedef td = Typedef . make ( qnameNode , jsdoc . getTypedefType () ) ;
TypeI type = typeEnv . getNamespaceOrTypedefType ( name ) ;
options . setPackageJsonEntryNames ( ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
packageJsonEntryNames = ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
checks . add ( createEmptyPass ( PassNames.AFTER_STANDARD_CHECKS ) ) ;
passName . equals ( PassNames.PARSE_INPUTS )
{ Node nameNode = n . getFirstChild () ; renamer . addDeclaredName ( nameNode . getString () , false ) ; }
if ( this . instanceProps . containsKey ( pname ) || this . protoProps . containsKey ( pname ) ) { return; }
this . allProps = builder . addAll ( instanceProps . keySet () ) . addAll ( protoProps . keySet () ) . build () ;
Property p = getNonInheritedProp ( pname , propAccess ) ;
Property p = getNonInheritedProp ( pname , propAccess ) ;
{ ObjectType obj = getObjTypeIfSingletonObj () ; return obj != null && obj . hasNonInheritedProperty ( new QualifiedName ( propertyName ) ) ; }
{ checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getNonInheritedPropertyDefSite ( propertyName ) ; }
classType . mayHaveNonInheritedProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , typeInJsdoc , previousPropType )
this . externs = makeExternInputs ( externs ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
{ for ( Var var : scriptToVarMap . removeAll ( script ) ) { super . undeclareInteral ( var ) ; } }
visitForOf ( t , n , parent ) ;
preloadEs6RuntimeFunction ( compiler , function ) ;
CompilerInput newInput = ( CompilerInput ) deserialize ( compiler , serialize ( input ) ) ;
@ Override public FeatureSet featureSet () { return ES8_MODULES ; }
newEmptyClinitMethod = true ;
compiler . ensureLibraryInjected ( STRING_CONSTANT + function . toLowerCase ( Locale.US ) , false ) ;
visitForOf ( n , parent ) ;
@ Override public FeatureSet featureSet () { return ES8 ; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
return this . globalScope . getType ( typeName ) ;
JSType t = getType ( typeName ) ;
public void testTypeTransformationNoneType () { inFunction ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; verify ( STRING_CONSTANT , JSTypeNative.UNKNOWN_TYPE ) ; }
{ tmpEnv = collectTypesForEscapedVarsFwd ( callee , tmpEnv ) ; }
TypeEnv outEnv = collectTypesForEscapedVarsFwd ( expr , inEnv ) ;
TypeEnv exitEnv = getExitTypeEnv () ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
handleGet ( module , scope , n , parent , prefix , Ref.Type.PROTOTYPE_GET , true ) ;
handleGet ( module , scope , n , parent , name , type , true ) ;
{ if ( n . isEmpty () && parent . isClassMembers () ) { reportCodeChange ( STRING_CONSTANT , n ) ; n . detach () ; } }
NodeTraversal . traverseEs6 ( compiler , root , new RemoveEmptyClassMembers () ) ;
preloadEs6RuntimeFunction ( compiler , function ) ;
visitForOf ( t , n , parent ) ;
{ builder . addRetType ( firstNonBottom ( actualRetType , UNKNOWN ) ) ; }
for ( ObjectTypeI interfaceType : funType . getAncestorInterfaces () ) { interfaces . add ( interfaceType . toAnnotationString ( Nullability.IMPLICIT ) ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT , record . toAnnotationString ( Nullability.EXPLICIT ) ) ;
assertEquals ( STRING_CONSTANT , record . toAnnotationString ( Nullability.EXPLICIT ) ) ;
if ( ! runOptimizeCalls ) { passes . add ( getRemoveUnusedVars ( PassNames.REMOVE_UNUSED_VARS , false ) ) ; }
checks . add ( createEmptyPass ( PassNames.BEFORE_TYPE_CHECKING ) ) ;
NodeUtil . markFunctionsDeleted ( nameNode , compiler ) ;
if ( ! n . hasOneChild () ) { return false ; }
Node statementNode = rhsNode . getGrandparent () ;
if ( ! call . hasTwoChildren () || ! legacyNamespaceNode . isString () ) { t . report ( legacyNamespaceNode , INVALID_GET_NAMESPACE ) ; return; }
if ( ! call . hasTwoChildren () || ! namespaceNode . isString () ) { t . report ( namespaceNode , INVALID_FORWARD_DECLARE_NAMESPACE ) ; return; }
grandparent . isStringKey () && NodeUtil . isObjectDefinePropertiesDefinition ( grandparent . getGrandparent () )
NodeTraversal . traverseEs6 ( compiler , fnName . getGrandparent () , uniquifier ) ;
if ( entry . isObjectLit () ) { checkState ( entryName . equals ( STRING_CONSTANT ) , entryName ) ; processBrowserFieldAdvancedUsage ( dirName , entry ) ; }
{ checkState ( this . setUpRan , STRING_CONSTANT ) ; Collections . addAll ( ignoredWarnings , warnings ) ; }
{ @ Override public boolean apply ( Node n ) { return n . matchesQualifiedName ( name ) ; } }
catch ( IllegalArgumentException expected ) { assertThat ( expected ) . hasMessageThat () . contains ( STRING_CONSTANT + STRING_CONSTANT ) ; }
Node classNode = root . getFirstChild () . getFirstFirstChild () ;
Node fNode = root . getFirstChild () . getFirstFirstChild () ;
js = RENAME_FUNCTION_DEFINITION + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
js = RENAME_FUNCTION_DEFINITION + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
js = RENAME_FUNCTION_DEFINITION + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . isEqualTo ( FixedPointGraphTraversal.NON_HALTING_ERROR_MSG ) ; }
{ testSame ( EXTERNS + extraExterns , source ) ; assertEquals ( expected , noSideEffectCalls ) ; noSideEffectCalls . clear () ; }
Node fNode = root . getFirstFirstChild () ;
assertNull ( noInline ) ;
if ( parent . isVar () ) { parent . detach () ; reportCodeChange () ; return null ; }
{ node . detach () ; reportCodeChange () ; return null ; }
if ( line . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT ) { return line . indexOf ( CHAR_CONS ) ; }
public void testImportedNameCollision () { testSame ( STRING_CONSTANT ) ; }
checkState ( n . isName () || n . isStringKey () || n . isImportStar () , STRING_CONSTANT , n ) ;
@ Override public FeatureSet featureSet () { return ES5 ; }
{ checkArgument ( n . isTry () ) ; return n . hasXChildren ( NUMBER_CONSTANT ) ; }
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ iterableType = iterable . getTypeI () . autobox () . toMaybeObjectType () ; typeParam = iterableType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; allowExternsChanges () ; this . mode = TypeInferenceMode.BOTH ; enableRunTypeCheckAfterProcessing () ; }
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node , parent ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node ) ;
emptiedClinitMethods . add ( fnQualifiedName ) ;
if ( options . getNewTypeInference () && options . getRunOTIafterNTI () && ! options.checksOnly ) { addOldTypeCheckerPasses ( checks , options ) ; }
Renamer renamer = renamerStack . peek () ;
{ if ( NodeUtil . isFunctionBlock ( t . getScopeRoot () ) ) { return; } if ( ! t . inGlobalScope () ) { renamerStack . pop () ; } }
new PureFunctionIdentifier.DriverInJ2cl ( compiler , null ) . process ( externs , root ) ;
new PureFunctionIdentifier.Driver ( compiler , null ) . process ( externs , root ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( returnType != null ) { builder . append ( STRING_CONSTANT ) ; returnType . appendTo ( builder , ctx ) ; }
if ( options . getNewTypeInference () && options . getRunOTIafterNTI () ) { addOldTypeCheckerPasses ( checks , options ) ; }
lit . setTypeI ( exportedObjectLit . getTypeI () ) ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
{ super . setUp () ; enableNormalize () ; this . mode = TypeInferenceMode.BOTH ; }
{ super . setUp () ; allowExternsChanges () ; this . mode = TypeInferenceMode.BOTH ; enableRunTypeCheckAfterProcessing () ; enableParseTypeInfo () ; }
this . mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; assertExternProperties ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.NEITHER ;
public void tagAsStrict () { add ( STRING_CONSTANT ) ; cc . endLine () ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { this . mode = TypeInferenceMode.BOTH ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties4 () { this . mode = TypeInferenceMode.BOTH ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty2 () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testConstructorProperty1 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
v != null || ! isShadowingAllowed ( name , s )
if ( options.j2clPassMode . shouldAddJ2clPasses () ) { passes . add ( j2clConstantHoisterPass ) ; passes . add ( j2clClinitPass ) ; }
boolean shouldPrintExterns () { return this . printExterns || incrementalCheckMode == IncrementalCheckMode.GENERATE_IJS ; }
return check () . about ( types () ) . that ( actualPropType ) ;
t . inGlobalScope () && NodeUtil . isDeclaration ( n ) && ! n . getBooleanProp ( Node.IS_NAMESPACE ) && ! isWhitelisted ( n )
assertTrue ( NodeUtil . isFunctionDeclaration ( getFunctionNode ( STRING_CONSTANT ) ) ) ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
warningOtiNti ( TYPE_MISMATCH_WARNING , MISTYPED_ASSIGN_RHS )
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.BOTH ;
checkNotNull ( curNode ) ;
boolean isFunctionExpression = parent != null && NodeUtil . isFunctionExpression ( n ) ;
checkState ( s . isGlobal () || s . isModuleScope () , s ) ;
checkArgument ( child.parent == null , STRING_CONSTANT , child , child.parent , this ) ;
passes . add ( createEmptyPass ( PassNames.BEFORE_MAIN_OPTIMIZATIONS ) ) ;
public void testJSDocCopiedForClasses () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testObjectLiteralMethods () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testObjectLiteralShorthand () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testDefaultParameter () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testClassDefinition3 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testClassDefinition2 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testClassDefinition1 () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testArrowFunction () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testNonTopLevelDestructuring () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testObjectDescructuringError2 () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testObjectDescructuringError1 () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testDestructuringError () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testYieldExpression () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testInlineEmptyFunction6 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
NodeTraversal . traverseEs6ScopeRoots ( compiler , null , ImmutableList . of ( fooFunction , barFunction , bazFunction ) , callback , callback , false ) ;
testSame ( STRING_CONSTANT ) ;
public void testMakeLocalNamesUniqueWithContext10 () { this . useDefaultRenamer = true ; testSame ( STRING_CONSTANT ) ; }
public void testMakeLocalNamesUniqueWithContext9 () { this . useDefaultRenamer = true ; testSame ( STRING_CONSTANT ) ; }
if ( NodeUtil . isBleedingFunctionName ( n ) ) { renameBleedingFunctionName ( t , n ) ; }
{ newNode = IR . assign ( getprop , rhs . cloneTree () ) ; }
{ FunctionType getterType = typeRegistry . createFunctionType ( objectType ) ; codingConvention . applySingletonGetter ( PROPERTY_DECLARER , functionType , getterType , objectType ) ; }
if ( superCtor != null && subCtor != null ) { codingConvention . applySubclassRelationship ( PROPERTY_DECLARER , superCtor , subCtor , relationship.type ) ; }
when ( mockCompiler . compile ( FOO_JS , STRING_CONSTANT ) ) . thenReturn ( new BaseTranspiler.CompileResult ( STRING_CONSTANT , false , STRING_CONSTANT ) ) ;
when ( mockCompiler . compile ( FOO_JS , STRING_CONSTANT ) ) . thenReturn ( new BaseTranspiler.CompileResult ( STRING_CONSTANT , true , STRING_CONSTANT ) ) ;
inFunction ( STRING_CONSTANT ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( firstArg ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( newNode ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
{ replacement = replacement . useSourceInfoIfMissingFrom ( node ) ; node . replaceWith ( replacement ) ; compiler . reportChangeToEnclosingScope ( replacement ) ; }
{ Node replacement = measuredNodeReplacement . applyTo ( original ) ; compiler . reportChangeToEnclosingScope ( replacement ) ; return replacement ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( whileNode ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( replacementConditionNode ) ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; compiler . reportChangeToEnclosingScope ( parent ) ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; compiler . reportChangeToEnclosingScope ( switchNode ) ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( caseBlock ) ;
{ compiler . reportChangeToEnclosingScope ( maybeBreak ) ; maybeBreak . detach () ; }
compiler . reportChangeToEnclosingScope ( parent ) ;
{ subtree . replaceWith ( right . detach () ) ; compiler . reportChangeToEnclosingScope ( right ) ; return right ; }
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( elem ) ;
compiler . reportChangeToEnclosingScope ( elem ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( newStringNode ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( newNode ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
compiler . reportChangeToEnclosingScope ( subtree ) ;
if ( codeChanged ) { compiler . reportChangeToEnclosingScope ( subtree ) ; }
compiler . reportChangeToEnclosingScope ( stringNode ) ;
compiler . reportChangeToEnclosingScope ( call ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; compiler . reportChangeToEnclosingScope ( newLiteralNode ) ; return newLiteralNode ; }
{ n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( parentNode ) ;
compileFiles ( STRING_CONSTANT , zipFile1 , zipFile2 ) ;
if ( options.j2clPassMode . shouldAddJ2clPasses () ) { checks . add ( j2clSourceFileChecker ) ; }
j2clPassMode = J2clPassMode.AUTO ;
checkState ( child.parent == this , STRING_CONSTANT , this , child ) ;
checkState ( child.parent == this , STRING_CONSTANT , this , child ) ;
assertThat ( result.transformed ) . isFalse () ;
assertThat ( result.transformed ) . isTrue () ;
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new Transpiler ( mockCompiler , STRING_CONSTANT ) ; compiler = Transpiler . compilerSupplier () ; }
Files . asCharSink ( jsFile , UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , UTF_8 ) . write ( code ) ;
{ this . def = checkNotNull ( def ) ; this . use = use ; }
if ( ! rewriteState . containsModule ( legacyNamespace ) ) { unrecognizedRequires . add ( new UnrecognizedRequire ( call , legacyNamespace , false , false ) ) ; }
inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ;
AnalyzePrototypeProperties analyzer = new AnalyzePrototypeProperties ( compiler , null , canModifyExterns , anchorUnusedVars , false ) ;
this . analyzer = new AnalyzePrototypeProperties ( compiler , moduleGraph , canModifyExterns , false , noStubFunctions ) ;
compilationLevelParsed = CompilationLevel . fromString ( Ascii . toUpperCase ( compilationLevel ) ) ;
if ( cacheEntry.input == null ) { cacheEntry.input = CompilerInput . makePersistentInput ( source ) ; }
boolean transformed = transformed ( result ) ;
@ Override public FeatureSet featureSet () { return FeatureSet . latest () ; }
public void testInlineIntoNestedNonHoistedNamedFunctions () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
jsDoc != null && jsDoc . hasConstAnnotation () && jsDoc . getType () == null
newNode . useSourceInfoIfMissingFromForTree ( sourceInfoNode ) ;
expr . useSourceInfoIfMissingFromForTree ( parent ) ;
checkState ( n . isFunction () || n . isClass () , n ) ;
public boolean shouldAmbiguateProperties () { return this . ambiguateProperties ; }
public boolean shouldDisambiguateProperties () { return this . disambiguateProperties ; }
public boolean shouldInlineProperties () { return inlineProperties ; }
{ return new Es6RewriteClass ( compiler , ! compiler . getOptions () . inIncrementalCheckMode () ) ; }
decl . simplify ( compiler ) ;
public void testForIn () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
NodeUtil . isEnhancedFor ( n )
typeCheck ( LINE_JOINER . join ( CLOSURE_BASE , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.NULLABLE_DEREFERENCE ) ;
typeCheck ( LINE_JOINER . join ( CLOSURE_DEFS , STRING_CONSTANT ) ) ;
typeCheck ( LINE_JOINER . join ( CLOSURE_BASE , STRING_CONSTANT ) ) ;
Iterable < Node > replacements
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
if ( hasReferenceName () ) { return sb . append ( forAnnotations ? getNormalizedReferenceName () : getReferenceName () ) ; }
if ( ! isPrettyPrint () || this == registry . getNativeType ( JSTypeNative.FUNCTION_INSTANCE_TYPE ) ) { return sb . append ( forAnnotations ? STRING_CONSTANT : STRING_CONSTANT ) ; }
{ checkArgument ( qnameNode . isQualifiedName () , qnameNode ) ; declarations . add ( PotentialDeclaration . from ( qnameNode , scope ) ) ; }
boolean isImport = isImportRhs ( rhs ) ;
ignoreWarnings ( NewTypeInference.INEXISTENT_PROPERTY ) ;
public void testInherits4 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testInherits3 () { testSame ( STRING_CONSTANT ) ; }
public void testInherits2 () { testSame ( STRING_CONSTANT ) ; }
public void testInherits1 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLoggerOnObject3b () { ignoreWarnings ( NewTypeInference.GLOBAL_THIS ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
! callClassType . isBottom () && ! callClassType . isSomeUnknownType ()
if ( checkAnnotated && sourceFile != null ) { checkState ( sourceFile . equals ( n . getSourceFileName () ) ) ; }
if ( devMode ) { runValidityCheck () ; if ( hasErrors () ) { return null ; } }
maybeRunValidityCheck () ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new ValidityCheck ( compiler ) ; }
if ( options.devMode == DevMode.EVERY_PASS ) { phaseOptimizer . setValidityCheck ( validityCheck ) ; }
if ( options.devMode == DevMode.START_AND_END ) { runValidityCheck () ; }
! validityCheck
{ declarationCheck = ! validityCheck ; disableCompareAsTree () ; testExternChanges ( extern , input , expectedExtern ) ; }
validityCheck = true ;
public void testViolatedModuleDependencyNonStrictNotPromoted () { validityCheck = true ; strictModuleDepErrorLevel = CheckLevel.ERROR ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testMissingModuleDependencySkipNonStrictNotPromoted () { validityCheck = true ; strictModuleDepErrorLevel = CheckLevel.ERROR ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public void testViolatedModuleDependencySkipNonStrict () { validityCheck = true ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testMissingModuleDependencySkipNonStrict () { validityCheck = true ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
validityCheck = false ;
@ Override public ObjectType prototypeOrInstance () { return prototype ; }
@ Override public ObjectType instance () { return instance ; }
@ Override public FunctionType constructor () { return constructor ; }
convention . applySingletonGetter ( new NominalTypeBuilderNti ( rawType . getAsNominalType () ) , getInstanceType ) ;
new FunctionTypeBuilder ( getCommonTypes () ) . addReqFormal ( getCommonTypes () . qmarkFunction () )
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ reportBadBaseMethodUse ( t , n , clazz . getFirstChild () . getString () , STRING_CONSTANT ) ; }
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
if ( initializer != null ) { inferredType = simpleInferExpr ( initializer , this . currentScope ) ; }
return bindComponents.thisValue == null ? null : simpleInferExpr ( bindComponents.thisValue , this . currentScope ) ;
this . currentScope . isConstructor ()
JSType rhsType = simpleInferExpr ( rhs , this . currentScope ) ;
JSType newPropType = rhs == null ? null : simpleInferExpr ( rhs , this . currentScope ) ;
JSType recvType = simpleInferExpr ( recv , this . currentScope ) ;
JSType t = initializer == null ? null : simpleInferExpr ( initializer , this . currentScope ) ;
if ( initializer != null ) { inferredType = simpleInferExpr ( initializer , this . currentScope ) ; }
JSType t = simpleInferExpr ( prop . getFirstChild () , this . currentScope ) ;
checkState ( n . isName () || n . isImportStar () , n ) ;
String requireName = ProcessCommonJSModules . getCommonJsImportPath ( require ) ;
{ this . compiler = compiler ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this ) ; cjs . process ( null , root ) ; }
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this , true ) ; cjs . process ( null , root ) ; }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT , } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
String requireName = require . getSecondChild () . getString () ;
{ this ( compiler , true ) ; }
if ( type . isEquivalentTo ( domHelperType ) ) { return true ; }
case SIMPLIFY_RHS :
void markProvided ( String providedName ) { checkNotNull ( providedName ) ; providedNamespaces . add ( providedName ) ; }
void markNameProcessed ( String fullyQualifiedName ) { checkNotNull ( fullyQualifiedName ) ; seenNames . add ( fullyQualifiedName ) ; }
{ return new ObjectLiteralPropertyDefinition ( n , n . getFirstChild () , isExtern ) ; }
List < Var > orderedVars = new ArrayList <> () ;
List < Var > orderedVars = new ArrayList <> () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this ) ; cjs . process ( null , root ) ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
String requireName = ProcessCommonJSModules . getCommonJsImportPath ( require ) ;
{ this . compiler = compiler ; }
public void testDontPreserveUnknownTypeDeclarations () { testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
typeCheck ( LINE_JOINER . join ( CLOSURE_BASE , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( isUnknown () || isUnresolved () ) { return this ; }
checkArgument ( nameNode . isQualifiedName () || nameNode . isStringKey () , nameNode ) ;
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) || options.transformAMDToCJSModules || options.processCommonJSModules
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
testSame ( STRING_CONSTANT ) ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeMinimizeConditions ( late ) ) ;
TernaryValue result = evaluateComparison ( n . getToken () , left , right ) ;
Double rightValObj = NodeUtil . getNumberValue ( right ) ;
Double result = NodeUtil . getNumberValue ( n ) ;
new PeepholeMinimizeConditions ( late )
new PeepholeMinimizeConditions ( late )
caseMatches = PeepholeFoldConstants . evaluateComparison ( Token.SHEQ , cond , caseLabel ) ;
new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true ) , new PeepholeFoldConstants ( true , false ) )
new PeepholeMinimizeConditions ( late )
optimizations . add ( new PeepholeMinimizeConditions ( late ) ) ;
Node n = parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.STRING_CONTINUATION ) , STRING_CONSTANT + STRING_CONSTANT ) ;
replacement . setTypeI ( call . getTypeI () ) ;
{ checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ; f1 . isSubtypeOfHelper ( f2 , false , subSuperMap , boxedInfo ) ; }
{ return isSubtypeOfHelper ( other , false , subSuperMap , null ) ; }
{ return isSubtypeOfHelper ( other , true , SubtypeCache . create () , null ) ; }
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testCallOrApply ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false ) ; }
void process ( Node externs , Node root , ReferenceMap references ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false , false ) ; }
void process ( Node externs , Node root , DefinitionUseSiteFinder definitions ) ;
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCallOrApply ( ) throws Exception { testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = newlineJoin ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
options . setEmitUseStrict ( false ) ;
passes = new ArrayList <> () ;
passes = new ArrayList <> () ;
{ passes = new ArrayList <> () ; addInlineVariables () ; addPeephole () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
passes = new ArrayList <> () ;
passes = new ArrayList <> () ;
passes = new ArrayList <> () ;
{ passes = new ArrayList <> () ; addDeadCodeElimination () ; addInlineVariables () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
passes = new ArrayList <> () ;
{ passes = new ArrayList <> () ; addInlineVariables () ; addPeephole () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ messages = new ArrayList <> () ; mode = JsMessage.Style.LEGACY ; compilerOptions = null ; renameMessages = false ; }
return getTopObject () . getNominalTypeIfSingletonObj () . getPrototypeObject () ;
return superClass == null ? null : superClass . getPrototypeObject () ;
JSType proto = getNominalTypeIfSingletonObj () . getPrototypeObject () ;
checkState ( n . isCall () || n . isTaggedTemplateLit () , n ) ;
catch ( RuntimeException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalArgumentException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
ref.scope . getClosestHoistScope () . isGlobal ()
ref.scope . isGlobal ()
try { compiler . compile ( EXTVAR_EXTERNS , inputs , options ) ; } catch ( RuntimeException e ) { fail ( STRING_CONSTANT ) ; }
Result result = compiler . compile ( EXTVAR_EXTERNS , inputs , options ) ;
Result result = compiler . compile ( EXTVAR_EXTERNS , inputs , options ) ;
Result result = compiler . compile ( testExterns , inputs , options ) ;
if ( type . contains ( STRING_CONSTANT ) ) { type = type . substring ( NUMBER_CONSTANT , type . lastIndexOf ( CHAR_CONS ) ) ; } else { return; }
String shortName = parent . getQualifiedName () . substring ( parent . getQualifiedName () . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
suffixes . add ( polyfillName . substring ( polyfillName . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ) ;
{ return STRING_CONSTANT + cls.target . getQualifiedName () . replace ( STRING_CONSTANT , STRING_CONSTANT ) + STRING_CONSTANT ; }
Map < Node < E > , ImmutableSet.Builder < E > > groupsTmp = new LinkedHashMap <> () ;
Map < String , Integer > map = new HashMap <> () ;
NodeUtil . findLhsNodesInNode ( n )
NodeUtil . findLhsNodesInNode ( n )
NodeUtil . findLhsNodesInNode ( decl )
Iterable < Node > allVars = NodeUtil . findLhsNodesInNode ( n ) ;
names = NodeUtil . findLhsNodesInNode ( c ) ;
NodeUtil . findLhsNodesInNode ( paramList )
checkNotNull ( sideEffectInfo , STRING_CONSTANT , function ) ;
NodeUtil . findLhsNodesInNode ( varNode )
{ for ( Node lhs : NodeUtil . findLhsNodesInNode ( n ) ) { declareVar ( s , lhs ) ; } }
NodeUtil . findLhsNodesInNode ( declaration )
if ( NodeUtil . findLhsNodesInNode ( nameDecl ) . size () > NUMBER_CONSTANT ) { continue; }
ref.scope . getClosestHoistScope () . isGlobal ()
public void testLocalAliasWithLet3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalAliasWithLet2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageIn = LanguageMode.ECMASCRIPT_2017 ;
List < Var > orderedVars = new ArrayList <> () ;
List < Node > arrayFoldedChildren = new ArrayList <> () ;
Deque < ScriptDescription > scriptDescriptions = new ArrayDeque <> () ;
List < Node > newVars = new ArrayList <> () ;
this . orderedVars = new ArrayList <> () ;
this . orderedVars = new ArrayList <> () ;
List < Var > orderedVars = new ArrayList <> () ;
this . orderedVars = new ArrayList <> () ;
languageIn = LanguageMode.ECMASCRIPT3 ;
public void testCallOrApply ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false ) ; }
void process ( Node externs , Node root , ReferenceMap references ) ;
languageIn = LanguageMode.ECMASCRIPT_2017 ;
public void testConst1 () { inFunction ( STRING_CONSTANT ) ; }
languageIn = LanguageMode.ECMASCRIPT3 ;
rewriteDeclsToVars () ;
rewriteDeclsToVars () ;
@ Nullable Node varName
checkLocalityOfMarkedCalls ( source , ImmutableList . < String > of ( STRING_CONSTANT ) ) ;
checkLocalityOfMarkedCalls ( source , ImmutableList . < String > of ( STRING_CONSTANT ) ) ;
assertTrue ( NodeUtil . evaluatesToLocalValue ( n ) ) ;
languageIn = LanguageMode.ECMASCRIPT_2017 ;
languageIn = LanguageMode.ECMASCRIPT3 ;
return STRING_CONSTANT + fnName + STRING_CONSTANT + sourceName ;
String fullExportedName = currentScript . getBinaryNamespace () . get () + exportDefinition . getExportPostfix () ;
Node binaryNamespaceName = IR . name ( currentScript . getBinaryNamespace () . get () ) ;
if ( ! currentScript . isModule () ) { return; }
if ( ! currentScript . isModule () ) { return; }
if ( ! currentScript . isModule () ) { return; }
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) . get () ;
checkState ( currentScript . isModule () , currentScript ) ;
if ( ! currentScript . isModule () || ! n . getString () . equals ( STRING_CONSTANT ) || ! isAssignTarget ( n ) ) { return; }
languageIn = LanguageMode.ECMASCRIPT_2017 ;
if ( et != null && et . enumLiteralHasKey ( pname ) ) { return et . getPropType () ; }
{ type = locals . get ( name ) . getDeclaredType () ; }
{ locals . put ( name , TaggedType . makeDeclared ( newDeclType ) ) ; }
String fullExportedName = currentScript . getBinaryNamespace () + exportDefinition . getExportPostfix () ;
Node binaryNamespaceName = IR . name ( currentScript . getBinaryNamespace () ) ;
if ( ! currentScript.isModule ) { return; }
if ( ! currentScript.isModule ) { return; }
if ( ! currentScript.isModule ) { return; }
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) ;
checkState ( currentScript.isModule , currentScript ) ;
if ( ! currentScript.isModule || ! n . getString () . equals ( STRING_CONSTANT ) || ! isAssignTarget ( n ) ) { return; }
checkState ( n . isName () || n . isGetProp () , n ) ;
finder . visitTree ( root ) ;
{ return STRING_CONSTANT + cls.target . getQualifiedName () . replace ( CHAR_CONS , CHAR_CONS ) + STRING_CONSTANT ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; }
NodeUtil . isNameDeclaration ( statementNode )
checkState ( declNode . isGetProp () , declNode ) ;
{ getGlobalScope () . addNamespaceLit ( new QualifiedName ( WINDOW_INSTANCE ) , qnameNode ) ; return true ; }
compilerOptions . setPreserveClosurePrimitives ( true ) ;
compilerOptions . setPreserveClosurePrimitives ( true ) ;
keyNode . isStringKey () || keyNode . isGetProp ()
Node externsRoot = parse ( compiler , STRING_CONSTANT ) ;
Node externsRoot = parse ( compiler , STRING_CONSTANT ) ;
{ helperExposeExpression ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; helperExposeExpression ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
JSType jsdocType = ( JSType ) prop . getTypeI () ;
pair.type = ( JSType ) expr . getTypeI () ;
JSType jsdocType = ( JSType ) prop . getTypeI () ;
JSType toType = ( JSType ) expr . getTypeI () ;
visitNamespacePropertyDeclaration ( getProp , QualifiedName . fromNode ( recv ) , pname ) ;
JSType propDeclType = ( JSType ) prop . getTypeI () ;
return ( JSType ) n . getTypeI () ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.TOO_MANY_TYPE_PARAMS , CheckLevel.WARNING ) ; return options ; }
js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , js ) ;
String fileoverview = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ testFunctionNamesAndIds ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } ) ; }
{ testFunctionNamesAndIds ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } ) ; }
{ testFunctionNamesAndIds ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , } ) ; }
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSets ( STRING_CONSTANT , js , output , STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEarlyReferenceError ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEarlyReferenceError ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; assertThat ( getLastCompiler () . injected ) . isEmpty () ; }
Node script = compiler . parseSyntheticCode ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( modules , new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT , STRING_CONSTANT , } ) ;
test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
{ test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
test ( createModuleChain ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT } )
test ( createModuleStar ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( modules , new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) } ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testError ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , VarCheck.UNDEFINED_VAR_ERROR ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ; }
{ String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ; }
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = lines ( DEFAULT_EXTERNS , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { STRING_CONSTANT , STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) }
typeCheck ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
testWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
testWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
testWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
String localVar = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
foldSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String body = lines ( STRING_CONSTANT , STRING_CONSTANT ) ;
String body = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testReference ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , false ) ;
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
String legacyScript = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
t . inGlobalHoistScope () && NodeUtil . isFunctionDeclaration ( n )
Preconditions . checkState ( ! isFunctionDeclaration ( n ) ) ;
return checkForNewObjects || isFunctionDeclaration ( n ) ;
if ( Es6RewriteModules . isEs6ModuleRoot ( root ) ) { return true ; }
if ( Es6RewriteModules . isEs6ModuleRoot ( root ) ) { moduleType = ModuleType.ES6 ; }
testModules ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new ProcessCommonJSModules ( compiler ) ; }
if ( NodeUtil . isFunctionExpression ( parent ) ) { return; }
{ FindStaticMembers findStaticMembers = new FindStaticMembers () ; TranspilationPasses . processTranspile ( compiler , scriptRoot , findStaticMembers ) ; processInherits ( findStaticMembers ) ; }
processInherits ( findStaticMembers ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertChangesRecorded ( code , new NameChangingCallback () ) ; }
{ String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertChangesRecorded ( code , new NameChangingCallback () ) ; }
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String src = CompilerTestCase . lines ( lines ) ;
String src = CompilerTestCase . lines ( lines ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
if ( ! fn . isFromExterns () ) { GlobalTypeInfoCollector . this . scopes . add ( fnScope ) ; }
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
useSourceInfoForNewQName ( node , basisNode ) ;
{ return assertAbout ( JSErrorSubject : : new ) . that ( error ) ; }
{ return assertAbout ( NodeSubject : : new ) . that ( node ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
TranspilationPasses . processTranspile ( compiler , scriptRoot , transpiledFeatures , findStaticMembers ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , this ) ; }
TranspilationPasses . processTranspile ( compiler , externs , transpiledFeatures , this ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , checkedFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , features , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , features , this , new SelfReferenceRewriter () ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , features , this , new SelfReferenceRewriter () ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , checkedFeatures , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , checkedFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ if ( allowMethodCallDecomposing ) { return DecompositionType.DECOMPOSABLE ; } else { return DecompositionType.UNDECOMPOSABLE ; } }
checkState ( allowMethodCallDecomposing , STRING_CONSTANT ) ;
Node name = NodeUtil . newQName ( compiler , PROTOTYPE_ALIAS + STRING_CONSTANT + declar.memberName , declar.node , declar.memberName ) ;
Node var = NodeUtil . newVarNode ( PROTOTYPE_ALIAS , null ) . useSourceInfoIfMissingFromForTree ( injectionPoint ) ;
isAssignmentOp ( declNode )
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isLiteralObject () || nt . isBuiltinObject () || nt . isIObject () ; }
boolean isPropertyRemovable ( String propertyName ) { return isEntirelyRemovable || ( unreferencedPropertiesMayBeRemoved && ! referencedPropertyNames . contains ( propertyName ) ) ; }
resultPair = analyzeCastFwd ( expr , inEnv ) ;
Name superclassNameObj = getOrCreateName ( superclassName , true ) ;
void verify ( Compiler compiler ) ;
currentArgumentsAccess = new ArrayList <> () ;
List < MemberDefinition > allProperties = new ArrayList <> () ;
List < SourceFile > files = new ArrayList <> () ;
List < SourceFile > files = new ArrayList <> () ;
List < SourceFile > files = new ArrayList <> () ;
List < String > entryPoints = new ArrayList <> () ;
cur = instance.declarations . get ( instance.declarations . size () - NUMBER_CONSTANT ) . node ;
PrototypeMemberDeclaration first = instance.declarations . get ( NUMBER_CONSTANT ) ;
if ( lValue . isRest () ) { lValue = lValue . getOnlyChild () ; }
VarInfo varInfo = traverseVar ( classScope . getVar ( classNameNode . getString () ) ) ;
{ VarInfo varInfo = traverseVar ( var ) ; varInfo . addRemovable ( new RemovableBuilder () . buildDestructuringAssign ( c , c ) ) ; }
VarInfo varInfo = traverseVar ( var ) ;
VarInfo varInfo = traverseVar ( var ) ;
VarInfo varInfo = traverseVar ( checkNotNull ( scope . getVar ( nameNode . getString () ) ) ) ;
VarInfo varInfo = traverseVar ( scope . getVar ( nameNode . getString () ) ) ;
VarInfo exceptionVarInfo = traverseVar ( scope . getVar ( exceptionNameNode . getString () ) ) ;
{ VarInfo varInfo = traverseVar ( var ) ; varInfo . addRemovable ( new RemovableBuilder () . buildDestructuringAssign ( restNode , target ) ) ; }
VarInfo classVarInfo = traverseVar ( classVar ) ;
checkState ( isCallOrNew ( invocation ) , invocation ) ;
@ Nullable Scope scope
checkState ( current . isGetProp () , STRING_CONSTANT , current ) ;
checkState ( current . isLabel () , current ) ;
checkState ( isControlStructure ( parent ) , parent ) ;
checkState ( n . isClassMembers () || n . isObjectLit () , n ) ;
checkState ( n . isClassMembers () || n . isObjectLit () , n ) ;
checkArgument ( callNode . isNew () , STRING_CONSTANT , callNode . getToken () ) ;
{ throw new IllegalStateException ( STRING_CONSTANT + ref ) ; }
throw new IllegalStateException ( STRING_CONSTANT + expr ) ;
checkState ( ! NodeUtil . isObjectLitKey ( n ) , n ) ;
boolean isMarkedConst = n . getParent () . isConst () || ( jsdoc != null && jsdoc . isConstant () ) ;
Queue < Property > propertyQueue = new ArrayDeque <> ( propertiesSet ) ;
{ if ( n . isFunction () ) { break; } this . ancestors . addFirst ( n ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; }
assertNoPureCalls ( source ) ;
@ Nullable Var v
@ Nullable Node definitionRValue
isStaticCtorProp ( getProp )
@ Nullable JSModule module
@ Nullable JSModule module
NameBasedDefinitionProvider definitionProvider
if ( defs . isEmpty () ) { return; }
@ VisibleForTesting Multimap < String , UseSite > getUseSitesByName () { return ImmutableMultimap . copyOf ( useSitesByName ) ; }
{ if ( inExterns ) { visitExterns ( traversal , node ) ; } else { visitCode ( traversal , node ) ; } }
public void testAnnotationInExterns_new5 ( ) throws Exception { assertPureCallsMarked ( STRING_CONSTANT , ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false , false ) ; }
new RemoveUnusedVars ( compiler , true , false , false ) . process ( externs , root ) ;
{ new RemoveUnusedVars ( compiler , removeGlobal , preserveFunctionExpressionNames , false ) . process ( externs , root ) ; }
return new RemoveUnusedVars ( compiler , ! removeOnlyLocals , preserveAnonymousFunctionNames , false ) ;
{ visitScript ( t , n ) ; }
assertThat ( packageJsonMainEntries ) . containsEntry ( STRING_CONSTANT , ModuleLoader.JSC_BROWSER_BLACKLISTED_MARKER ) ;
checkArgument ( fnNode . isFunction () , fnNode ) ;
LinkedHashMap < String , Node > actualMap = getFunctionCallParameterMap ( fn , call , getNameSupplier () ) ;
public void testFindModifiedParameters12 () { assertThat ( findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters2 () { assertThat ( findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters1 () { assertThat ( findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters0 () { assertThat ( findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
boolean replaceParent = true ;
tracer = new Tracer ( STRING_CONSTANT , name ) ;
{ if ( edgeAnnotationStack == null ) { edgeAnnotationStack = new ArrayDeque <> () ; } pushAnnotations ( edgeAnnotationStack , getEdges () ) ; }
{ if ( nodeAnnotationStack == null ) { nodeAnnotationStack = new ArrayDeque <> () ; } pushAnnotations ( nodeAnnotationStack , getNodes () ) ; }
if ( LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE < blockScope . getVarCount () + functionScope . getVarCount () ) { return; }
if ( LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE < t . getScope () . getVarCount () ) { return; }
i < LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE + NUMBER_CONSTANT
if ( var . getParentNode () . isParamList () ) { varInfo.propertyAssignmentsWillPreventRemoval = true ; }
exceptionVarInfo . setIsExplicitlyNotRemovable () ;
canonicalTotallyUnremovableVarInfo . setIsExplicitlyNotRemovable () ;
ImmutableSet < String > namesToAlias
ImmutableSet < String > needAliases
ImmutableMap < String , Node > argMap
return LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE > orderedVars . size () ;
if ( LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t . getScope () . getVarCount () ) { return; }
i < LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE + NUMBER_CONSTANT
if ( ! NodeUtil . isNameDeclaration ( n ) ) { return; }
NodeUtil . isNameDeclaration ( parent ) && nameNode . hasOneChild ()
NodeUtil . isNameDeclaration ( parent )
removeUnusedProperties && r . isPrototypeObjectNamedPropertyAssignment () && ! referencedPropertyNames . contains ( r . getPropertyName () )
removeUnusedProperties && removable . isPrototypeObjectNamedPropertyAssignment () && ! referencedPropertyNames . contains ( removable . getPropertyName () )
! n . isString () && ! isConstantNameNode ( n )
if ( rValue == null || ! rValue . isFunction () || NodeUtil . doesFunctionReferenceOwnArgumentsObject ( rValue ) ) { return false ; }
if ( NodeUtil . doesFunctionReferenceOwnArgumentsObject ( fnc ) ) { return false ; }
computeEscaped ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
computeEscaped ( jsScope , escaped , compiler , scopeCreator ) ;
computeEscaped ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
funType . isSomeConstructorOrInterface ()
private Scope newScope () { return Scope . createGlobalScope ( new Node ( Token.ROOT ) ) ; }
@ Override public void setUp () { allowMethodCallDecomposing = false ; knownConstants . clear () ; }
{ test ( createCompilerOptions () , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
testModules ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) )
public void testES6Modules () { testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testB3473189 () { testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
options . setErrorHandler ( new BlackHoleErrorManager () ) ;
String classAndItsMethodAliasedAsExtern = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String getPropertyName () { return checkNotNull ( propertyName ) ; }
if ( toRemove . isParamList () ) {} else { throw new IllegalStateException ( STRING_CONSTANT + toRemove . toStringTree () ) ; }
assertTrue ( options . shouldCollapseProperties () ) ;
assertTrue ( options . shouldCollapseProperties () ) ;
assertTrue ( options . shouldCollapseProperties () ) ;
assertTrue ( options . shouldCollapseProperties () ) ;
@ Override public boolean isApplied ( CompilerOptions options ) { return options . shouldCollapseProperties () ; }
@ Override public FeatureSet featureSet () { return ES8_MODULES ; }
return ! NodeUtil . isNameDeclaration ( n . getFirstChild () ) ;
public void testNoGlobalScopeChanges () { testSame ( STRING_CONSTANT ) ; }
return new RemoveUnusedVars ( compiler , ! removeOnlyLocals , preserveAnonymousFunctionNames , options.removeUnusedPrototypeProperties ) ;
( getTypeDeprecationInfo ( getTypeOfThis ( scopeRoot ) ) != null )
Var var
Var var
@ Override boolean isClassOrPrototypeNamedProperty () { return true ; }
boolean isIndependentlyRemovableNamedProperty () { return isPrototypeObjectNamedPropertyAssignment () || isClassOrPrototypeNamedProperty () ; }
boolean isClassOrPrototypeNamedProperty () { return false ; }
isGlobal && ! removeGlobals && ! removeUnusedPrototypeProperties
removeUnusedPrototypeProperties && removable . isNamedProperty ()
if ( removeUnusedPrototypeProperties ) { removeUnreferencedProperties () ; }
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedCode () ) ; }
{ passes . add ( flowSensitiveInlineVariables ) ; if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedCodeOnce () ) ; } }
new RemoveUnusedCode.Builder ( compiler ) . removeGlobals ( true ) . build () . process ( externs , root ) ;
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( removeUnusedCode ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new RewriteGlobalClassFunctionDeclarationsToVarAssignmentsCallback () ) ;
SimpleDependencyInfo . builder ( closureRelativePath , filePath ) . setProvides ( provides ) . setRequires ( requires ) . setWeakRequires ( weakRequires ) . setLoadFlags ( loadFlags ) . build ()
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedCode () ) ; }
atLeast8 = mode == Mode.ES8_OR_GREATER || mode == Mode.ES_NEXT ;
ImmutableList < String > getWeakRequires ( ) ;
ImmutableList < String > getRequires ( ) ;
ImmutableList < String > getProvides ( ) ;
public void testDefaultParam_argIsUnknown () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testDefaultParam_argIsUndefined () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrayPatternParam () { testSame ( STRING_CONSTANT ) ; }
visitParamList ( n , parent ) ;
Annotation annotation = annotations . get ( annotationName ) ;
config . languageMode () != LanguageMode.TYPESCRIPT
if ( config . languageMode () == LanguageMode.ECMASCRIPT3 ) { errorReporter . error ( SETTER_ERROR_MESSAGE , sourceName , lineno ( node ) , NUMBER_CONSTANT ) ; return true ; }
if ( config . languageMode () == LanguageMode.ECMASCRIPT3 ) { errorReporter . error ( GETTER_ERROR_MESSAGE , sourceName , lineno ( node ) , NUMBER_CONSTANT ) ; return true ; }
if ( config . languageMode () == LanguageMode.ECMASCRIPT3 ) { errorReporter . warning ( INVALID_ES3_PROP_NAME , sourceName , node . getLineno () , node . getCharno () ) ; }
{ checkState ( config . runMode () == Config.RunMode.KEEP_GOING ) ; bodyNode = IR . block () ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . removeLocalVars ( true ) . build () ; }
if ( shouldRunRemoveUnusedCode () ) { passes . add ( removeUnusedCode ) ; }
CollapseProperties collapseProperties = new CollapseProperties ( compiler , PropertyCollapseLevel.ALL ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new CollapseProperties ( compiler , options . getPropertyCollapseLevel () ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CollapseProperties ( compiler , PropertyCollapseLevel.ALL ) ; }
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
@ Override public void apply ( CompilerOptions options , boolean value ) { options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ; }
if ( p != null && ! canCollapse ( p ) ) { continue; }
if ( ! canCollapseChildNames || ! canCollapse ( n ) ) { return; }
if ( ! canCollapseChildNames || ! canCollapse ( n ) ) { return; }
isObjLit && canEliminate ( n )
isObjLit && canEliminate ( n )
if ( canCollapse ( n ) ) { updateGlobalNameDeclaration ( n , alias , canCollapseChildNames ) ; }
new CollapseProperties ( compiler , PropertyCollapseLevel.ALL ) . process ( externs , js ) ;
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new CollapseProperties ( compiler , propertyCollapseLevel ) ; }
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
collapsePropertiesLevel = PropertyCollapseLevel.NONE ;
if ( options.removeUnusedPrototypeProperties ) { passes . add ( removeUnusedPrototypeProperties ) ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . build () ; }
if ( NodeUtil . isNameDeclaration ( parent ) || parent . isFunction () ) { return true ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . removeLocalVars ( true ) . build () ; }
if ( shouldRunRemoveUnusedCode () ) { passes . add ( removeUnusedCode ) ; }
{ options . setCollapsePropertiesLevel ( value ? PropertyCollapseLevel.ALL : PropertyCollapseLevel.NONE ) ; }
for ( String filename : files ) { if ( fix ) { fixRepeatedly ( filename ) ; } else { lint ( filename ) ; } }
passes . add ( removeUnusedCodeOnce ) ;
String qualifiedName = getAliasedNamespace ( aliasVar . getInitialValue () ) ;
String aliasExpanded = checkNotNull ( getAliasedNamespace ( aliasDefinition ) ) ;
this . inliningReach = Reach.LOCAL_ONLY ;
public void testLocalFunctionInliningOnly4 () { this . inliningReach = Reach.LOCAL_ONLY ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalFunctionInliningOnly3 () { this . inliningReach = Reach.LOCAL_ONLY ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalFunctionInliningOnly2 () { this . inliningReach = Reach.LOCAL_ONLY ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
inliningReach = Reach.ALL ;
{ options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2017 ) ; options . setLanguageOut ( value ? CompilerOptions.LanguageMode.ECMASCRIPT5 : CompilerOptions.LanguageMode.NO_TRANSPILE ) ; }
public boolean includesGlobals () { return this == ALL ; }
logger . finest ( STRING_CONSTANT + file . getName () ) ;
checkArgument ( NodeUtil . isAssignmentOp ( assignNode ) , assignNode ) ;
Node superClassNameNode = metadata.superClassNameNode . cloneTree () ;
VarInfo varInfo = traverseNameNode ( classNameNode , classScope ) ;
VarInfo varInfo = traverseNameNode ( classNameNode , scope ) ;
VarInfo varInfo = traverseNameNode ( nameNode , scope ) ;
VarInfo varInfo = traverseNameNode ( nameNode , scope ) ;
VarInfo exceptionVarInfo = traverseNameNode ( exceptionNameNode , scope ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
public void testIssue618_2 () { this . removeGlobal = false ; testSame ( STRING_CONSTANT ) ; }
rhs == null || PotentialDeclaration . isTypedRhs ( rhs ) || NodeUtil . isCallTo ( rhs , STRING_CONSTANT ) || isImportRhs ( rhs )
getAllSymbols ()
public Iterable < Symbol > getAllSymbols () { return ImmutableList . copyOf ( symbols . values () ) ; }
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
getAllSymbols ()
getAllSymbols ()
if ( key . isShorthandProperty () ) { maybeWarn = true ; }
if ( node . isStringKey () && node . isShorthandProperty () ) { t . report ( node , SHORTHAND_ASSIGNMENT_IN_ENUM ) ; }
if ( parent . isObjectPattern () ) { return ! n . isStringKey () ; }
{ validateEnumStringKey ( c ) ; }
passes . add ( extraSmartNamePass ) ;
options . setInlineFunctions ( Reach.NONE ) ;
options . setInlineFunctions ( Reach.ALL ) ;
options . setInlineFunctions ( Reach.ALL ) ;
options . setInlineFunctions ( Reach.ALL ) ;
{ this . setInlineFunctions ( inlineFunctions ? Reach.ALL : Reach.NONE ) ; }
allSymbols . addAll ( table . getAllSymbols () ) ;
boolean isPrototypeProperty () { return isPrototypeObjectNamedPropertyAssignment () || isClassOrPrototypeNamedProperty () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; }
if ( isClassMethod ( functionNode ) ) { return STRING_CONSTANT . equals ( functionNode . getParent () . getString () ) ; }
isClassMethod ( functionNode )
{ if ( isImport ) { currentFile . recordImport ( name . getString () ) ; } else { currentFile . recordNameDeclaration ( name , t . getScope () ) ; } }
String name = ClassUtil . getPrototypeNameOfMethod ( functionNode ) ;
if ( ClassUtil . isConstructor ( n ) && n . getLastChild () . hasChildren () ) { currentFile . markConstructorToProcess ( n ) ; }
newJsdoc == null && ClassUtil . isThisProp ( nameNode )
if ( ClassUtil . isClassMethod ( n ) ) { currentFile . recordMethod ( n , t . getScope () ) ; }
! ClassUtil . isConstructor ( n )
{ if ( isTypeCompatible ( receiverType , method . type () ) ) { unusedMethodPolyfills . remove ( method ) ; } }
checkArgument ( ClassUtil . isClassMethod ( functionNode ) ) ;
private boolean isAssignmentToPrototype ( Node n ) { return n . isAssign () && isDotPrototype ( n . getFirstChild () ) ; }
long nodeCount = graph . getNodeCount () ;
checkState ( n . isName () || n . isImportStar () , STRING_CONSTANT , n ) ;
if ( NodeUtil . isLValue ( n ) ) { return n ; }
if ( NodeUtil . isLValue ( n ) ) { return n ; }
if ( NodeUtil . isLValue ( n ) ) { return n ; }
boolean isPrototypeProperty () { return isPrototypeDotPropertyReference () || isClassOrPrototypeNamedProperty () ; }
removeUnusedThisProperties && removable . isThisDotPropertyReference ()
RemovableBuilder builder = new RemovableBuilder () . setIsThisDotPropertyReference ( true ) ;
{ fsCalled . setRemove ( false ) ; if ( ! minimizeCost ( fsCalled ) ) { fsCalled . disallowInlining () ; } }
{ Node rootNode = scopeRoots . get ( i - NUMBER_CONSTANT ) ; if ( isHoistScopeRootNode ( rootNode ) ) { return rootNode ; } }
public boolean isHoistScope () { return isHoistScopeRootNode ( getScopeRoot () ) ; }
checkState ( ( NodeUtil . isNameDeclaration ( parent ) && var . isGlobal () ) || NodeUtil . isFunctionDeclaration ( parent ) ) ;
if ( aliasVar != null ) { return aliasVar . isGlobal () ; }
Node name = importSpec . getSecondChild () ;
validateChildCount ( n , NUMBER_CONSTANT ) ;
validateChildCount ( n , NUMBER_CONSTANT ) ;
Builder removeUnusedConstructorProperties ( boolean value ) { this . removeUnusedStaticProperties = value ; return this ; }
this . removeUnusedStaticProperties = builder.removeUnusedStaticProperties ;
test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
Scope s = getAbstractScope () ;
refinedScope != null && getAbstractScope () != refinedScope
checkArgument ( ! name . isEmpty () ) ;
String name = ClassUtil . getFullyQualifiedNameOfMethod ( functionNode ) ;
NodeUtil . deleteNode ( getRemovableNode () , compiler ) ;
Node oldStatement = getRemovableNode () ;
Node getRemovableNode () { return NodeUtil . getEnclosingStatement ( lhs ) ; }
@ Override public boolean hasReferenceName () { checkNotNull ( referencedObjType ) ; return referencedObjType . hasReferenceName () ; }
passes . add ( removeUnusedCodeOnce ) ;
testModules ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( NodeUtil . mayHaveSideEffects ( objExpression ) ) { replaceNodeWith ( incOrDecNode , objExpression . detach () ) ; } else { removeExpressionCompletely ( incOrDecNode ) ; }
if ( NodeUtil . mayHaveSideEffects ( objExpression ) ) { replaceNodeWith ( referenceNode , objExpression . detach () ) ; } else { removeExpressionCompletely ( referenceNode ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
Arguments ( Scope scope ) { super ( ARGUMENTS , null , scope , - NUMBER_CONSTANT , null ) ; }
@ Override public TypedScope getScope ( TypedVar var ) { return ( TypedScope ) var.scope ; }
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
{ ( ( Scope ) scope ) . declare ( name , n , input ) ; }
Es6SyntacticScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
AbstractScope < , > s
private void pushScope ( AbstractScope < , > s ) { pushScope ( s , false ) ; }
AbstractScope < , > refinedScope
AbstractScope < , > scope
AbstractScope < , > s
Scope hoistedScope = t . getClosestHoistScope () . untyped () ;
Es6SyntacticScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Var var = new Var ( name , nameNode , this , getVarCount () , input ) ;
AbstractScope < , > parent
Es6SyntacticScopeCreator scopeCreator = createScopeCreator () ;
AbstractScope < , > parent
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ return new FeatureSet ( union ( features , other.features ) ) ; }
public FeatureSet withoutTypes () { return new FeatureSet ( difference ( features , LangVersion.TYPESCRIPT . features () ) ) ; }
private FeatureSet ( EnumSet < Feature > features ) { this . features = ImmutableSet . copyOf ( features ) ; }
{ test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
! scope . isDeclared ( name , false ) && ! ( scope . isLocal () && name . equals ( Var.ARGUMENTS ) )
if ( Var.ARGUMENTS . equals ( name ) && NodeUtil . isVanillaFunction ( scope . getRootNode () ) ) { return scope . getArgumentsVar () ; }
public final S getScope () { return scope ; }
if ( ! isFunctionScope () || rootNode . isArrowFunction () ) { return getParent () . getArgumentsVar () ; }
@ Override public TypedScope getScope ( TypedVar var ) { return var.scope ; }
optimizations . add ( new MinimizeExitPoints () ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , ( String ) null ) ;
assertChanges ( externs , originalCode , template , ( String ) null ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( STRING_CONSTANT , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( STRING_CONSTANT , originalCode , template , expectedCode ) ;
public void clearTemplates () { templates = null ; matchedTemplates = null ; }
checkNotNull ( funType , STRING_CONSTANT , recvType , setterPname ) ;
if ( isCommonJsImport ( n ) ) { visitRequireCall ( t , n , parent ) ; }
this . moduleLoader = new ModuleLoader ( null , options.moduleRoots , inputs , ModuleLoader.PathResolver.RELATIVE , options.moduleResolutionMode , inputPathByWebpackId ) ;
options . setModuleResolutionMode ( resolutionMode ) ;
public JsonFileSpec ( String src , String path ) { this ( src , path , null , null ) ; }
if ( var . getParentNode () . isParamList () ) { varInfo.hasNonLocalOrNonLiteralValue = true ; }
catch ( RuntimeException e ) { throw new AssertionError ( STRING_CONSTANT , e ) ; }
@ Override public boolean preventsRemovalOfVariableWithNonLocalValueOrPrototype () { return true ; }
foldSame ( STRING_CONSTANT ) ;
public void testNewOperator3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNewOperator2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNewOperator1 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
return JSType . getLeastSupertype ( this , that ) ;
checkState ( n . hasOneChild () , n ) ;
Node newDeclaration = NodeUtil . newDeclaration ( lhsToSplit . detach () , rhs , n . getToken () ) . srcref ( n ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
Map < String , TypeI > props = new LinkedHashMap <> () ;
checkState ( mayBeStatement ( stmt ) , STRING_CONSTANT , stmt . getToken () ) ;
NameDeclarationStatement removable = builder . buildNameDeclarationStatement ( declarationStatement ) ;
( NodeUtil . isEnhancedFor ( parent ) )
if ( grandparent != null && NodeUtil . isNameDeclaration ( grandparent ) ) { return false ; }
public void testLoggerMethodCallByVariableType_var () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
ParseTree right = parseExponentiationExpression () ;
return findModifiedParameters ( fnNode . getLastChild () , names , unsafeNames , false ) ;
public void testDirectPrototypeAssignment2 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRICT_INEXISTENT_PROPERTY ) ; }
public void testPropertyInference6 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRICT_INEXISTENT_PROPERTY ) ; }
{ compiler . getErrorManager () . report ( CheckLevel.ERROR , JSError . make ( AbstractCompiler.READ_ERROR , getName () , e . getMessage () ) ) ; return SimpleDependencyInfo.EMPTY ; }
catch ( IOException e ) { compiler . report ( JSError . make ( AbstractCompiler.READ_ERROR , sourceFile . getName () , e . getMessage () ) ) ; }
boolean allowDupe = VarCheck . hasDuplicateDeclarationSuppression ( compiler , referenceNode , v . getNameNode () ) ;
{ testClosureTypesMultipleWarnings ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , ImmutableList . of ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ) ; }
public void testMissingProperty30 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
TemplateAstMatcher astMatcher = new TemplateAstMatcher ( compiler . getTypeIRegistry () , templateRoot , typeMatchingStrategy ) ;
return fnThisType == null ? null : fnThisType . toObjectType () ;
IR . string ( t . getInput () . getName () )
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new CheckSuper ( compiler ) ; }
checks . add ( checkSuper ) ;
passes . add ( checkSuper ) ;
{ visitInterfaceGetprop ( t , assign , object , rvalue ) ; }
visitGetProp ( t , n ) ;
checkArgument ( scriptNode . isScript () , scriptNode ) ;
{ Node enclosingNode = NodeUtil . getEnclosingNode ( n , isLoopOrFunction ) ; return enclosingNode != null && ! enclosingNode . isFunction () ; }
{ return new Es6RewriteClass ( compiler , true ) ; }
assertTypeEquals ( typeRegistry . getNativeType ( BOOLEAN_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
suppressors . put ( STRING_CONSTANT , new DiagnosticGroupWarningsGuard ( new DiagnosticGroup ( DiagnosticGroups.CHECK_TYPES , DiagnosticGroups.STRICT_CHECK_TYPES ) , CheckLevel.OFF ) ) ;
if ( ! rewriteState . containsModule ( legacyNamespace ) ) { unrecognizedRequires . add ( new UnrecognizedRequire ( call , legacyNamespace , false ) ) ; }
@ Deprecated boolean inIncrementalCheckMode () { return incrementalCheckMode != IncrementalCheckMode.OFF ; }
Node originalFunction = checkNotNull ( functionContext.function ) ;
{ for ( PotentialDeclaration decl : currentFile . getDeclarations () . get ( name ) ) { processDeclaration ( name , decl ) ; } }
if ( getRhs () == null || shouldPreserve () ) { return; }
if ( ! PotentialDeclaration . isConstToBeInferred ( originalJsdoc , nameNode ) ) { return; }
boolean isImport = PotentialDeclaration . isImportRhs ( rhs ) ;
lhsToSplit . isDestructuringLhs () && ! PotentialDeclaration . isImportRhs ( lhsToSplit . getLastChild () )
PotentialDeclaration . isConstToBeInferred ( jsdoc , nameNode ) && ! nameNode . isFromExterns () && ! JsdocUtil . isPrivate ( jsdoc )
jsdoc == null || ! jsdoc . containsDeclaration () || isConstToBeInferred ( jsdoc , jsdocNode )
checkState ( caseBody . isNormalBlock () , caseBody ) ;
checkState ( first . getString () . isEmpty () , first ) ;
public void testIssue2508576_1 () { String externs = STRING_CONSTANT ; testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ; }
public void testClassExtern () { String externs = STRING_CONSTANT ; testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ; }
public void testObjectLitExtern2 () { String externs = STRING_CONSTANT ; testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ; }
public void testObjectLitExtern1 () { String externs = STRING_CONSTANT ; testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ; }
testSame ( externs ( CompilerTypeTestCase.DEFAULT_EXTERNS ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( SHARED_EXTERNS ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( METHOD_DEFS ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( externs ) , srcs ( code ) ) ;
testSame ( externs ( externs ) , srcs ( code ) ) ;
{ testSame ( externs ( externs ) , srcs ( source ) ) ; assertEquals ( expected , found ) ; found . clear () ; }
tester . testSame ( externs ( STRING_CONSTANT ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( ALL_NATIVE_EXTERN_TYPES ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( code ) ) ;
testSame ( externs ( EXTERNS ) , srcs ( STRING_CONSTANT ) ) ;
private void testSameEs6Strict ( String js ) { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( js ) ; }
testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String externs = DEFAULT_EXTERNS . replace ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Map < String , StaticTypedSlot < JSType > > slots = new HashMap <> () ;
NodeUtil . isNameDeclaration ( parent )
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil : : isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil : : isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil : : isNameDeclaration ) ;
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil.isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil.isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil.isNameDeclaration ) ;
addExpr ( first . getNext () , NUMBER_CONSTANT , Context.OTHER ) ;
public void testFindExpressionRoot5 () { assertNode ( findExpressionRoot ( STRING_CONSTANT , STRING_CONSTANT ) ) . hasType ( Token.FOR ) ; }
{ return parent . getParent () ; }
{ return ! isReasonableObjectPropertyKey ( templatizedType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ) ; }
if ( that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL ) ) ) { return UNKNOWN ; } else { return FALSE ; }
{ registerMismatchAndReport ( n , INVALID_OPERAND_TYPE , msg , type , getNativeType ( NUMBER_STRING ) , null , null ) ; }
this . allBitwisableValueTypes = typeRegistry . createUnionType ( STRING_TYPE , NUMBER_TYPE , BOOLEAN_TYPE , NULL_TYPE , VOID_TYPE ) ;
allDeps . addAll ( input . getRequiredSymbols () ) ;
input . getKnownRequiredSymbols ()
writeJsArray ( out , Require . asSymbolList ( info . getRequires () ) ) ;
ImmutableList < Require > getRequires ( ) ;
{ input . addOrderedRequire ( Require . compilerModule ( require ) ) ; }
public abstract Builder setRequires ( Collection < Require > requires ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) ) )
ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) , googRequireSymbol ( STRING_CONSTANT ) )
public void addRequire ( Require require ) { extraRequires . add ( require ) ; }
Require require
rootInput . getRequiredSymbols ()
userOrderedInput . getRequiredSymbols ()
input . getRequiredSymbols ()
requires . addAll ( deps . getRequiredSymbols () ) ;
for ( String require : dependency . getRequiredSymbols () ) { addDependency ( require , seen , list ) ; }
public void testGithubIssue2818 () { noInline ( STRING_CONSTANT ) ; noInline ( STRING_CONSTANT ) ; noInline ( STRING_CONSTANT ) ; }
testError ( srcs ( js ) , error ( BAD_PRIVATE_PROPERTY_ACCESS ) . withMessage ( STRING_CONSTANT ) ) ;
error ( BAD_PRIVATE_PROPERTY_ACCESS ) . withMessage ( STRING_CONSTANT )
error ( BAD_PRIVATE_PROPERTY_ACCESS ) . withMessage ( STRING_CONSTANT )
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_FOR_GOOG_SCOPE ) . withMessage ( warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_WARNING ) . withMessage ( warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_WARNING ) . withMessage ( warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_STRICT_WARNING ) . withMessage ( warningText ) ) ; }
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR ) . withMessage ( message ) ) ;
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR ) . withMessage ( message ) ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , expected ( expected ) , warning ( warning ) . withMessage ( description ) ) ;
test ( externs ( externs ) , srcs ( STRING_CONSTANT ) , expected ( STRING_CONSTANT ) , warning ( e ) . withMessage ( STRING_CONSTANT + STRING_CONSTANT ) ) ;
{ assertNotNull ( warning ) ; test ( externs ( externs ) , srcs ( js ) , warning ( warning ) . withMessage ( description ) ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( inputs ) , warning ( warning ) . withMessage ( description ) ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( js ) , warning ( warning ) . withMessage ( description ) ) ; }
{ assertNotNull ( error ) ; test ( srcs ( inputs ) , error ( error ) . withMessage ( description ) ) ; }
{ assertNotNull ( error ) ; test ( srcs ( js ) , error ( error ) . withMessage ( description ) ) ; }
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING ) . withMessage ( warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING ) . withMessage ( warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING ) . withMessage ( warning ) ) ;
public abstract Builder setRequires ( Collection < String > requires ) ;
public void addRequire ( String require ) { extraRequires . add ( require ) ; }
String require
allDeps . addAll ( input . getRequires () ) ;
input . getKnownRequires ()
rootInput . getRequires ()
requires . addAll ( deps . getRequires () ) ;
for ( String require : dependency . getRequires () ) { addDependency ( require , seen , list ) ; }
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( STRING_CONSTANT ) )
ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT )
writeJsArray ( out , info . getRequires () ) ;
ImmutableList < String > getRequires ( ) ;
userOrderedInput . getRequires ()
input . getRequires ()
{ input . addOrderedRequire ( require ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks , preprocessorSymbolTableFactory ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes , preprocessorSymbolTableFactory ) ; }
n . putBooleanProp ( Node.MODULE_ALIAS , true ) ;
TranspilationPasses . addEs6ModulePass ( factories , new PreprocessorSymbolTable.CachedInstanceFactory () ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null ) ; }
noInline ( STRING_CONSTANT ) ;
noInline ( STRING_CONSTANT ) ;
for ( TemplateType unused : obj . getTemplateTypeMap () . getTemplateKeys () ) { unknowns . add ( getNativeType ( UNKNOWN_TYPE ) ) ; }
public void testIssue70b () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.LANGUAGE_FEATURE ) ; }
public void testIssue70a () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.LANGUAGE_FEATURE ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
rewriteGeneratorBody ( STRING_CONSTANT , lines ( STRING_CONSTANT ) ) ;
if ( node . hasTwoChildren () && node . getLastChild () . isString () ) { info.importedModules . add ( node . getLastChild () . getString () ) ; }
TypedScopeCreator typedScopeCreator = getTypedScopeCreator () ;
scopeCreator = new TypedScopeCreator ( compiler ) ;
TypedScopeCreator scopeCreator
TypedScopeCreator getTypedScopeCreator () { return typedScopeCreator ; }
TypedScopeCreator scopeCreator
public abstract Builder setRequires ( Collection < Require > requires ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) ) )
ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) , googRequireSymbol ( STRING_CONSTANT ) )
userOrderedInput . getRequiredSymbols ()
input . getRequiredSymbols ()
rootInput . getRequiredSymbols ()
requires . addAll ( deps . getRequiredSymbols () ) ;
for ( String require : dependency . getRequiredSymbols () ) { addDependency ( require , seen , list ) ; }
writeJsArray ( out , Require . asSymbolList ( info . getRequires () ) ) ;
ImmutableList < Require > getRequires ( ) ;
public void addRequire ( Require require ) { extraRequires . add ( require ) ; }
Require require
{ input . addOrderedRequire ( Require . compilerModule ( require ) ) ; }
allDeps . addAll ( input . getRequiredSymbols () ) ;
input . getKnownRequiredSymbols ()
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives ; }
noInline ( STRING_CONSTANT ) ;
public void testNoInlineGetElem () { noInline ( STRING_CONSTANT ) ; }
public void testNoInlineGetProp1 () { noInline ( STRING_CONSTANT ) ; }
@ Override public StaticTypedScope < JSType > getParentScope () { throw new UnsupportedOperationException () ; }
final Scope usageScope
List < String > provides = new ArrayList <> ( depInfo . getProvides () ) ;
this . nullOrUndefined = typeRegistry . getNativeType ( JSTypeNative.NULL_VOID ) ;
{ return testForEquality ( that ) . equals ( TernaryValue.UNKNOWN ) ; }
disableStrictMissingPropertyChecks () ;
disableStrictMissingPropertyChecks () ;
disableStrictMissingPropertyChecks () ;
{ disableStrictMissingPropertyChecks () ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
disableStrictMissingPropertyChecks () ;
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
disableStrictMissingPropertyChecks () ;
disableStrictMissingPropertyChecks () ;
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
disableStrictMissingPropertyChecks () ;
rewriteGeneratorBodyWithVars ( STRING_CONSTANT , STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
context . writeGeneratedNode ( IR . ifNode ( condition , context . createJumpToBlock ( startCase , false , n ) ) . useSourceInfoFrom ( n ) ) ;
IR . ifNode ( IR . not ( condition ) . useSourceInfoFrom ( condition ) , context . createJumpToBlock ( endCase , true , n ) ) . useSourceInfoFrom ( n )
IR . ifNode ( IR . not ( condition ) . useSourceInfoFrom ( condition ) , context . createJumpToBlock ( endCase , true , n ) ) . useSourceInfoFrom ( n )
if ( options . needsTranspilationFrom ( ES2018 ) ) { TranspilationPasses . addEs2018Passes ( passes ) ; passes . add ( setFeatureSet ( ES8 ) ) ; }
parseWarning ( STRING_CONSTANT , getRequiresEs2018Message ( Feature.OBJECT_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs2018Message ( Feature.OBJECT_PATTERN_REST ) ) ;
if ( options . needsTranspilationFrom ( ES2018 ) ) { TranspilationPasses . addEs2018Passes ( checks ) ; checks . add ( setFeatureSet ( ES8 ) ) ; }
return isValidAliasRhs ( rhs ) ;
if ( this . isNoOp () ) { return STRING_CONSTANT ; }
allJsDocParams = ( info == null ) ? new HashSet <> () : new HashSet <> ( info . getParameterNames () )
JSType type = typeRegistry . getGlobalType ( dottedName ) ;
JSType type = compiler . getTypeRegistry () . getType ( STRING_CONSTANT ) ;
{ return metadata . getCompiler () . getTypeRegistry () . getGlobalType ( type ) ; }
TypeI mathType = compiler . getTypeIRegistry () . getGlobalType ( STRING_CONSTANT ) ;
{ return registry . getGlobalType ( typeName ) ; }
domHelperType = compiler . getTypeIRegistry () . getGlobalType ( STRING_CONSTANT ) ;
{ super ( compiler , requirement ) ; errorObjType = compiler . getTypeIRegistry () . getGlobalType ( STRING_CONSTANT ) ; }
TypeI methodClassType = registry . getGlobalType ( r.type ) ;
TypeI typeWithBannedProp = registry . getGlobalType ( prop.type ) ;
{ TypeI type = registry . getGlobalType ( typeName ) ; if ( type != null ) { types . add ( type ) ; } }
TypeI methodClassType = registry . getGlobalType ( className ) ;
final Scope scope = t . getScope () ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
Predicates . alwaysTrue ()
ImmutableList.Builder < Callback > callbacks = ImmutableList . builder () ;
parent . isAssign () && parent . getFirstChild () == getProp && getProp . getLastChild () . getString () . equals ( STRING_CONSTANT )
parent . isAssign () && parent . getFirstChild () == getProp && parent . getFirstChild () . getLastChild () . getString () . equals ( STRING_CONSTANT )
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil : : isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil : : isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil : : isNameDeclaration ) ;
Streams . stream ( fixChoices ) . map ( choices - > choices . getAlternatives () . get ( choiceIndex ) )
Streams . stream ( fixChoices ) . map ( f - > f . getAlternatives () . size () )
newVar = declare ( scopeToDeclareIn , variableName , n , type , input , inferred ) ;
if ( isKeyword ( importedName.value ) ) { reportError ( importedName , STRING_CONSTANT , importedName.value ) ; }
if ( isKeyword ( importedName.value ) ) { reportExpectedError ( null , PredefinedName.AS ) ; }
this . scanner = new Scanner ( config.parseTypeSyntax , errorReporter , commentRecorder , source , offset ) ;
testNotEs6TypedFullError ( STRING_CONSTANT , STRING_CONSTANT ) ;
testNotEs6TypedFullError ( STRING_CONSTANT , STRING_CONSTANT ) ;
testNotEs6TypedFullError ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ parse ( STRING_CONSTANT ) ; expectErrors ( STRING_CONSTANT ) ; parse ( STRING_CONSTANT ) ; testNotEs6TypedFullError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
checkState ( nameNode . isName () , nameNode ) ;
for ( Case currentCase : allCases ) { switchNode . addChildToBack ( currentCase . createCaseNode () ) ; }
{ currentCase.embedInto . replaceWith ( currentCase.caseBlock ) ; it . remove () ; continue; }
this . context = new TranspilationContext () ;
ImmutableSortedSet . copyOf ( comparingByKey () , map . entrySet () )
this . modulePaths = resolvePaths ( Iterables . transform ( Iterables . transform ( inputs , DependencyInfo : : getName ) , pathResolver ) , moduleRootPaths ) ;
{ this . cache = builder . build ( CacheLoader . from ( delegate : : transform ) ) ; }
{ return this : : transform ; }
{ return function : : apply ; }
Predicates . alwaysTrue ()
return NodeUtil . has ( node , pred , Predicates . alwaysTrue () ) ;
{ this ( compiler , behavior , creator , Predicates . alwaysTrue () ) ; }
return NodeUtil . has ( callNode , hasSpreadCallArgumentPredicate , Predicates . alwaysTrue () ) ;
return ! referencesArguments && ! NodeUtil . has ( block , p , Predicates . alwaysTrue () ) ;
return result == null ? ImmutableList . of () : ImmutableList . of ( result ) ;
if ( customPasses == null ) { customPasses = LinkedHashMultimap . create () ; }
for ( Node typeNode : info . getTypeNodes () ) { NodeUtil . visitPreOrder ( typeNode , fixJsdocTypeNodes , Predicates . alwaysTrue () ) ; }
{ maybeAddUsage ( t , n , typeNode , false , Predicates . alwaysTrue () ) ; }
Predicates . alwaysTrue ()
{ return eval ( ttlAst , typeVars , ImmutableMap . of () ) ; }
List < Ref > getRefs () { return refs == null ? ImmutableList . of () : refs ; }
{ return chars == null ? ImmutableSet . of () : ImmutableSet . copyOf ( Chars . asList ( chars ) ) ; }
reserved = previousMap != null ? previousMap . getNewNameToOriginalNameMap () . keySet () : Collections . emptySet ()
return invocation . hasOneChild () ? ImmutableList . of () : invocation . getSecondChild () . siblings () ;
{ return getCount ( node , new MatchNameNode ( name ) , Predicates . alwaysTrue () ) ; }
Predicates . alwaysTrue ()
Arrays . sort ( arr , Ordering . natural () ) ;
for ( Node typeNode : info . getTypeNodes () ) { NodeUtil . visitPreOrder ( typeNode , replaceJsDocRefs ) ; }
ImmutableSet . of ()
invalidations = FluentIterable . from ( invalidationMap . get ( t ) ) . transform ( Suppliers . supplierFunction () ) . limit ( MAX_INVALIDATION_WARNINGS_PER_PROPERTY )
this . invalidationMap = propertiesToErrorFor . isEmpty () ? null : LinkedHashMultimap . create () ;
return new JSTypeExpression ( typeNode , VIRTUAL_FILE ) ;
JSType type = compiler . getTypeRegistry () . getGlobalType ( STRING_CONSTANT ) ;
TypeI type = registry . getGlobalType ( target . getFirstFirstChild () . getQualifiedName () ) ;
{ final JSType voidType = compiler . getTypeRegistry () . getNativeType ( JSTypeNative.VOID_TYPE ) ; return voidType . isSubtype ( returnType ) ; }
{ return isTheObjectType () || isStringObjectType () || isDateType () || isRegexpType () || isArrayType () || isNumberObjectType () || isBooleanObjectType () || hasOverriddenNativeProperty ( STRING_CONSTANT ) ; }
@ Override public boolean matchesNumberContext () { return isNumberObjectType () || isDateType () || isBooleanObjectType () || isStringObjectType () || hasOverriddenNativeProperty ( STRING_CONSTANT ) ; }
TypeI type = compiler . getTypeIRegistry () . getGlobalType ( typeName ) ;
public void testMissingProperty33 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty22 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty21 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty18 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty15 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty12 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty11 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty10 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty9 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
JSTypeExpression expr = new JSTypeExpression ( getCallArgument ( ttlAst , NUMBER_CONSTANT ) , VIRTUAL_FILE ) ;
compiler . getOptions () . getLanguageOut () . toFeatureSet () . contains ( ES6 )
if ( options . getLanguageOut () . toFeatureSet () . contains ( ES6 ) ) { passes . add ( optimizeToEs6 ) ; }
if ( options.dartPass && ! options . getLanguageOut () . toFeatureSet () . contains ( ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
{ CompilerOptions options = super . getDefaultOptions () ; options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ; options . setLanguageOut ( LanguageMode.ECMASCRIPT5 ) ; return options ; }
return ( nameNode . hasChildren () || isLhsOfEnhancedForExpression ( nameNode ) ) ;
{ if ( pos >= js . length () ) { return null ; } else { return js . substring ( pos ) ; } }
if ( node . isQuotedString () || ! node . hasChildren () ) { return; }
declList . sort ( DECLARATIONS_FIRST ) ;
{ JSType newType = objType . getTemplateTypeMap () . getResolvedTemplateType ( registry . getIterableTemplate () ) ; redeclareSimpleVar ( informed , item , newType ) ; }
@ Override JSType resolveInternal ( ErrorReporter reporter , StaticTypedScope < JSType > scope ) { return this ; }
@ Override JSType resolveInternal ( ErrorReporter reporter , StaticTypedScope < JSType > scope ) { return this ; }
abstract JSType resolveInternal ( ErrorReporter reporter , StaticTypedScope < JSType > scope ) ;
ErrorReporter reporter
@ Override JSType resolveInternal ( ErrorReporter reporter , StaticTypedScope < JSType > scope ) { return this ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModulesToCommonJsModules ( compiler , STRING_CONSTANT ) ; }
private String transpileEs6Module ( String s ) { return transpile ( s , es6ModuleTranspiler ) ; }
if ( that . isUnknownType () || that . isSubtypeOf ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; }
if ( t . isUnknownType () || t . isNoResolvedType () || ! t . isSubtypeOf ( type ) ) { restricted . addAlternate ( t ) ; }
if ( ! alternate . isUnknownType () && that . isSubtypeOf ( alternate ) ) { return this ; }
if ( isStructural && ! thisUnresolved && ! thatUnresolved ) { return rightType . isSubtypeOf ( leftType ) ; } else { return rightType . isSubtypeWithoutStructuralTyping ( leftType ) ; }
{ return type . isSubtypeOf ( getNativeType ( ARRAY_TYPE ) ) ? null : type ; }
{ JSType arrayType = getNativeType ( ARRAY_TYPE ) ; return arrayType . isSubtypeOf ( type ) ? arrayType : null ; }
if ( resultEqualsValue ) { return ctorType . getGreatestSubtype ( type ) ; } else { return type . isSubtypeOf ( ctorType ) ? null : type ; }
assertTrue ( x . isSubtypeOf ( windowCtor . getInstanceType () ) ) ;
assertTrue ( x . isSubtypeOf ( windowCtor . getInstanceType () ) ) ;
assertTrue ( y . isSubtypeOf ( getNativeType ( STRING_TYPE ) ) ) ;
{ if ( this . isSubtype ( rawThat ) ) { return this ; } else if ( rawThat . isSubtypeOf ( this ) ) { return filterNoResolvedType ( rawThat ) ; } }
assertTrue ( unknown . isSubtypeOf ( STRING_TYPE ) ) ;
assertTrue ( NULL_TYPE . isSubtypeOf ( nullOrUnknown ) ) ;
! argType . isSubtypeOf ( paramType )
! rightType . isSubtypeOf ( leftType )
! leftType . isNoType () && ! rightType . isSubtypeOf ( leftType )
! switchType . canTestForShallowEqualityWith ( caseType ) && ( caseType . autoboxesTo () == null || ! caseType . autoboxesTo () . isSubtypeOf ( switchType ) )
! type . isNoType () && ! type . isUnknownType () && type . isSubtypeOf ( nullOrUndefined ) && ! containsForwardDeclaredUnresolvedName ( type )
! type . isSubtypeOf ( getNativeType ( NUMBER_STRING_SYMBOL ) )
! type . isSubtypeOf ( getNativeType ( NUMBER_STRING ) )
! type . matchesNumberContext () && ! type . isSubtypeOf ( allBitwisableValueTypes )
! type . isSubtypeOf ( getNativeType ( NUMBER_TYPE ) )
if ( ! anyObjectType . isSubtypeOf ( type ) && ! type . isEmptyType () ) { mismatch ( t , n , msg , type , anyObjectType ) ; }
if ( funcTarget . hasInstanceType () ) { if ( type . isSubtypeOf ( funcTarget . getInstanceType () ) ) { return null ; } return type ; }
if ( ! objType . isNoType () && ! objType . isUnknownType () && objType . isSubtypeOf ( getNativeType ( NULL_VOID ) ) ) { return; }
if ( castType . restrictByNotNullOrUndefined () . isSubtypeOf ( exprType ) || expr . isObjectLit () ) { expr . setJSType ( castType ) ; }
if ( isEmptyType () || that . isEmptyType () ) { return isSubtypeOf ( that ) || that . isSubtypeOf ( this ) ; }
{ JSType alternate = alternatesList . get ( i ) ; if ( alternate . isSubtypeOf ( arrayType ) ) { return true ; } }
public final boolean isSymbol () { return isSubtypeOf ( getNativeType ( JSTypeNative.SYMBOL_VALUE_OR_OBJECT_TYPE ) ) ; }
public final boolean isNumber () { return isSubtypeOf ( getNativeType ( JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE ) ) ; }
public final boolean isString () { return isSubtypeOf ( getNativeType ( JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE ) ) ; }
if ( that . isSubtypeOf ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL ) ) ) { return UNKNOWN ; }
! type . isSubtypeOf ( typeRegistry . getNativeType ( OBJECT_TYPE ) )
assertTrue ( STRING_CONSTANT + varType + STRING_CONSTANT + name + STRING_CONSTANT + type + STRING_CONSTANT , varType . isSubtypeOf ( type ) ) ;
return new BooleanOutcomePair ( jsType . getPossibleToBooleanOutcomes () , registry . getNativeType ( BOOLEAN_TYPE ) . isSubtypeOf ( jsType ) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY , flowScope , flowScope ) ;
outcome.booleanValues == BooleanLiteralSet.EMPTY && getNativeType ( BOOLEAN_TYPE ) . isSubtypeOf ( type )
argObjectType . isSubtypeOf ( referencedParamType )
! jsType . isUnknownType () && ! jsType . isAllType () && jsType . isSubtypeOf ( providedJsType )
if ( that . isUnknownType () || that . isSubtypeOf ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; }
{ final JSType voidType = compiler . getTypeRegistry () . getNativeType ( JSTypeNative.VOID_TYPE ) ; return voidType . isSubtypeOf ( returnType ) ; }
if ( that . isUnknownType () || that . isSubtypeOf ( getNativeType ( JSTypeNative.NUMBER_STRING_BOOLEAN ) ) || that . isObject () ) { return UNKNOWN ; }
assertFalse ( arrayOfString . isSubtypeOf ( createUnionType ( arrayOfNumber , NULL_VOID ) ) ) ;
@ Override public boolean isSubtype ( JSType that ) { return this . isSubtype ( that , ImplCache . create () , SubtypingMode.NORMAL ) ; }
return thisType . isSubtypeOf ( thatType ) || thatType . isSubtypeOf ( thisType ) ;
{ if ( thisType . isFunctionType () ) { return true ; } else { return thisType . isSubtypeOf ( functionType ) || functionType . isSubtype ( thisType ) ; } }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_NEXT ) ;
boolean isConstToBeInferred () { return isConstToBeInferred ( getLhs () ) ; }
maybeWarnForConstWithoutExplicitType ( compiler , decl ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clPass ( compiler ) ; }
if ( astValidationEnabled ) { new AstValidator ( compiler ) . setTypeValidationEnabled ( typeInfoValidationEnabled ) . validateRoot ( root ) ; }
new PureFunctionIdentifier.Driver ( compiler , null ) . process ( externs , root ) ;
exportedNameToLocalQName . put ( name , new LocalQName ( name , export ) ) ;
exportedNameToLocalQName . put ( name , new LocalQName ( name , lhs ) ) ;
exportedNameToLocalQName . put ( STRING_CONSTANT , new LocalQName ( name , export ) ) ;
Map.Entry < String , LocalQName > entry
functionNames = compilerState.functionNames ;
this . functionNames = compiler.functionNames ;
assertScope ( moduleScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( moduleScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( blockScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( fooScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( forOfScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( functionBlockScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( functionScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( functionBlockScope ) . declares ( STRING_CONSTANT ) . directly () ;
catch ( FlagUsageException e ) { assertThat ( e ) . hasMessageThat () . isEqualTo ( STRING_CONSTANT ) ; }
return s != null ? s : createScope ( n , createScope ( NodeUtil . getEnclosingNode ( n . getParent () , NodeUtil : : isValidCfgRoot ) ) ) ;
TypeInference dfa = new TypeInference ( compiler , cfg , rai , assumedScope , scopeCreator , ASSERTION_FUNCTION_MAP ) ;
return v != null && v . isLocal () && v . isMarkedEscaped () && v . getScope () . getClosestNonBlockScope () == cfgRootScope ;
if ( isUnflowable ( currentScope . getVar ( varName ) ) ) { return; }
isLocallyInferred = ( var != currentScope . getSlot ( qualifiedName ) ) ;
ttlObj = new TypeTransformation ( compiler , currentScope ) ;
TypedVar var = currentScope . getVar ( qKeyName ) ;
TypedVar var = currentScope . getVar ( qName ) ;
TypedVar var = currentScope . getVar ( varName ) ;
{ type = info . getType () . evaluate ( currentScope , registry ) ; }
if ( info != null && info . hasType () ) { n . setJSType ( info . getType () . evaluate ( currentScope , registry ) ) ; }
if ( rename ) { NodeTraversal . traverseEs6 ( compiler , js , new Renamer () ) ; }
registry . createNullableType ( registry . getGlobalType ( STRING_CONSTANT ) )
{ super ( null , registry , reference , sourceName , lineno , charno ) ; }
unresolvedNamedTypes . removeAll ( scope ) ;
public void clearNamedTypes () { unresolvedNamedTypes . clear () ; }
{ checkTypeName ( name ) ; namesToTypes . put ( name , type ) ; }
assertTrue ( findNameType ( STRING_CONSTANT , lastLocalScope ) . isEquivalentTo ( registry . getType ( null , STRING_CONSTANT ) ) ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , jsdoc . getImplementedInterfaces () . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , types . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , interfaces . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , NUMBER_CONSTANT , NUMBER_CONSTANT ) , jsdoc . getBaseType () ) ;
{ assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , parse ( STRING_CONSTANT ) . getBaseType () ) ; }
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , interfaces . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( createNullableType ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
! newType . isEquivalentTo ( varType , true )
{ assertTypeEquals ( expected , resolve ( actual ) ) ; }
{ return ! checkEquivalenceHelper ( that , EquivalenceMethod.DATA_FLOW , EqCache . create () ) ; }
{ if ( constructorI . isEquivalentTo ( constructorJ ) ) { shouldCheck = false ; } }
{ this ( Functions . identity () , errorManager ) ; }
Node ast = parseSyntheticCode ( SYNTHETIC_CODE_PREFIX + resourceName + STRING_CONSTANT , originalCode ) ;
if ( ! scope . hasSlot ( NodeUtil.JSC_PROPERTY_NAME_FN ) ) { scope . declare ( NodeUtil.JSC_PROPERTY_NAME_FN , null , null ) ; }
if ( scope . hasOwnSlot ( qName ) ) { continue; }
! scope . hasOwnSlot ( qName ) && n . isUnscopedQualifiedName ()
if ( ! name . isEmpty () && ! usageScope . hasSlot ( name ) ) { return true ; }
if ( t . getScope () . hasSlot ( alias ) ) { compiler . report ( JSError . make ( n , TYPE_ALIAS_ALREADY_DECLARED , alias ) ) ; }
n . isName () && ! t . getScope () . hasSlot ( n . getString () )
if ( current . hasOwnSlot ( oldName ) ) { return; } else { current = current . getParent () ; }
assertScope ( fooScope ) . declares ( STRING_CONSTANT ) . directly () ;
if ( ! getRootNode () . isFunction () ) { return getClosestContainerScope () . getTypeOfThis () ; }
return v != null && v . isLocal () && v . isMarkedEscaped () && v . getScope () . getClosestContainerScope () == containerScope ;
this . containerScope = syntacticScope ;
while ( t . getScope () . hasSlot ( pseudoName ) ) { pseudoName += STRING_CONSTANT ; }
varsInFunctionBody . contains ( refName ) && ! scope . hasSlot ( refName )
curScope . hasSlot ( assignment.oldName )
AbstractVar < , > var = getVar ( name ) ;
AbstractVar < , > var = getVar ( name ) ;
if ( isUnflowable ( getDeclaredVar ( scope , varName ) ) ) { return; }
isLocallyInferred = ( var != getDeclaredVar ( scope , qualifiedName ) ) ;
backwardsInferenceFromCallSite ( n , ct , scope ) ;
backwardsInferenceFromCallSite ( n , fnType , scope ) ;
TypedVar var = getDeclaredVar ( scope , qKeyName ) ;
boolean unflowable = isInferred && isUnflowable ( getDeclaredVar ( scope , varName ) ) ;
{ type = info . getType () . evaluate ( scope . getDeclarationScope () , registry ) ; }
return getBinaryModuleNamespace ( legacyNamespace ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , MODULE_USES_GOOG_MODULE_GET ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null , false , ResolutionMode.BROWSER ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null ) ; }
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , GOOG_MODULE_USES_GOOG_MODULE_GET ) ; }
return MODULE_EXPORTS_PREFIX + this . legacyNamespace . replace ( CHAR_CONS , CHAR_CONS ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , error ( INVALIDATION_ON_TYPE ) . withMessageContaining ( STRING_CONSTANT ) ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , error ( INVALIDATION_ON_TYPE ) . withMessageContaining ( STRING_CONSTANT ) ) ;
{ test ( srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , error ( INVALIDATION ) . withMessageContaining ( STRING_CONSTANT ) ) ; }
{ test ( srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , error ( INVALIDATION ) . withMessageContaining ( STRING_CONSTANT ) ) ; }
TypedVar fnVar = currentScope . getVar ( fnName ) ;
Node rootNode = currentHoistScope . getClosestContainerScope () . getRootNode () ;
GlobalScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
if ( currentScope . hasOwnSlot ( qName ) ) { continue; }
TypedVar ownerVar = currentScope . getVar ( slotName ) ;
TypedVar slot = currentScope . getVar ( name ) ;
{ return rValueInfo . getType () . evaluate ( currentScope , typeRegistry ) ; }
{ return createEnumTypeFromNodes ( rValue , lValue . getQualifiedName () , info , isLValueRootedInGlobalScope ( lValue ) ) ; }
return isLValueRootedInGlobalScope ( lValue ) || ! type . isReturnTypeInferred () ;
parent == null || ! parent . isFunction () || n == parent . getFirstChild () || parent == currentScope . getRootNode ()
if ( this . cache . functionScope != that.cache.functionScope ) { return false ; }
return slot != null ? slot : syntacticScope . getSlot ( var . getName () ) ;
{ return getSlot ( getVarFromSyntacticScope ( name ) ) ; }
ScopedName var = getVarFromSyntacticScope ( symbol ) ;
{ return new LinkedFlowScope ( new FlatFlowScopeCache ( scope ) , scope ) ; }
{ if ( type != null ) { this . type = type . resolve ( errorReporter , scope ) ; } }
public TemplateType getObjectIndexKey () { checkNotNull ( iObjectIndexTemplateKey ) ; return iObjectIndexTemplateKey ; }
public TemplateType getObjectElementKey () { return iObjectElementTemplateKey ; }
new InvalidatingTypes.Builder ( registry ) . writeInvalidationsInto ( this . invalidationMap ) . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () )
Node root = NodeUtil . getEnclosingScopeRoot ( n ) ;
AbstractScope ( Node rootNode ) { this . rootNode = checkNotNull ( rootNode ) ; }
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , MODULE_USES_GOOG_MODULE_GET ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null , false , ResolutionMode.BROWSER ) ; }
return getBinaryModuleNamespace ( legacyNamespace ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ if ( moduleType == ModuleType.GOOG_MODULE ) { moduleType = ModuleType.LEGACY_GOOG_MODULE ; } else { compiler . report ( JSError . make ( declaresLegacyNamespace , DECLARE_LEGACY_NAMESPACE_OUTSIDE_GOOG_MODULE ) ) ; } }
if ( Keywords . isKeyword ( name.value , false ) ) { features = features . with ( Feature.KEYWORDS_AS_PROPERTIES ) ; }
{ if ( moduleType == ModuleType.GOOG_MODULE ) { moduleType = ModuleType.LEGACY_GOOG_MODULE ; } else { compiler . report ( JSError . make ( declaresLegacyNamespace , DECLARE_LEGACY_NAMESPACE_IN_NON_MODULE ) ) ; } }
NodeUtil . isNameDeclaration ( n )
if ( NodeUtil . isNameDeclaration ( n ) ) { return n . getFirstChild () ; } else if ( NodeUtil . isExprAssign ( n ) ) { return n . getFirstFirstChild () ; }
if ( ! NodeUtil . isNameDeclaration ( child ) && ! NodeUtil . isExprAssign ( child ) ) { continue; }
parent != null && NodeUtil . isNameDeclaration ( parent )
Node node = withType ( IR . number ( id ) , numberType ) . useSourceInfoFrom ( sourceNode ) ;
sourceNode . replaceWith ( createBreakNodeFor ( sourceNode ) ) ;
IR . block ( callContextMethodResult ( sourceNode , STRING_CONSTANT , section . getNumber ( sourceNode ) ) , createBreakNodeFor ( sourceNode ) ) . useSourceInfoFrom ( sourceNode )
{ writeGeneratedNode ( n ) ; writeGeneratedNode ( createBreakNodeFor ( n ) ) ; currentCase.mayFallThrough = false ; }
var != null && var . getScope () == actual ()
{ checkState ( scope != actual () , STRING_CONSTANT ) ; expectScope ( STRING_CONSTANT , scope , scope ) ; }
private DeclarationSubject ( AbstractVar < , > var ) { this . var = checkNotNull ( var ) ; }
ImmutableList < AbstractVar < , > > declared = ImmutableList . copyOf ( actual () . getAllAccessibleVariables () ) ;
if ( NodeUtil . isNameDeclaration ( replace ) ) { replace . replaceWith ( NodeUtil . newExpr ( replacement ) ) ; } else { replace . replaceWith ( replacement ) ; }
NodeUtil . isNameDeclaration ( ref . getParent () )
NodeUtil . isNameDeclaration ( parent )
if ( parent . isFunction () || NodeUtil . isNameDeclaration ( parent ) || parent . isNew () ) { return; }
{ return ( NodeUtil . isNameDeclaration ( n ) || n . isFunction () ) && isWhitelistedName ( n . getFirstChild () . getString () ) ; }
checkArgument ( returnNode . isReturn () , returnNode ) ;
{ return ! isValidIndex ( index + offset ) ? CHAR_CONS : contents . charAt ( index + offset ) ; }
private char nextChar () { if ( isAtEnd () ) { return CHAR_CONS ; } return contents . charAt ( index ++ ) ; }
String value = this . contents . substring ( startOffset , index ) ;
{ NodeTraversal . traverse ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , collector ) ;
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , extractionInfo ) ;
NodeTraversal . traverse ( compiler , scriptRoot , this ) ;
{ NodeTraversal . traverse ( compiler , root , new Callback () ) ; }
{ NodeTraversal . traverse ( compiler , externs , this ) ; addWindowProperties () ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , body , updater ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , root , this ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ symbolMap = getCssRenamingMap () ; NodeTraversal . traverse ( compiler , root , new Traversal () ) ; }
NodeTraversal . traverse ( compiler , scriptRoot , traverser ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverseRoots ( compiler , renamer , externs , root ) ;
{ NodeTraversal . traverse ( compiler , checkNotNull ( root ) , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
for ( Callback callback : callbacks ) { scriptRoot . putBooleanProp ( Node.TRANSPILED , true ) ; NodeTraversal . traverse ( compiler , scriptRoot , callback ) ; }
for ( Callback callback : callbacks ) { singleRoot . putBooleanProp ( Node.TRANSPILED , true ) ; NodeTraversal . traverse ( compiler , singleRoot , callback ) ; }
do { codeChanged = false ; NodeTraversal . traverse ( compiler , root , new EliminationPass ( cfg ) ) ; } while ( codeChanged ) ;
{ checkNotNull ( root ) ; checkState ( root . isScript () ) ; NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , this ) ;
{ if ( Es6RewriteModules . isEs6ModuleRoot ( script ) ) { NodeTraversal . traverse ( compiler , script , new Rewriter ( compiler , script ) ) ; } }
NodeTraversal . traverse ( compiler , root , finder ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverse ( compiler , scriptRoot , finder ) ;
NodeTraversal . traverse ( compiler , block , new UnmarkedNodeTranspiler () ) ;
{ YieldFinder yieldFinder = new YieldFinder () ; NodeTraversal . traverse ( compiler , n , yieldFinder ) ; return yieldFinder . getYieldNode () ; }
NodeTraversal . traverse ( compiler , wrapper , context . new UnmarkedNodeTranspiler () ) ;
NodeTraversal . traverse ( compiler , originalGeneratorBody , new YieldNodeMarker () ) ;
NodeTraversal . traverse ( compiler , root , new LabelFinder () ) ;
NodeTraversal . traverse ( compiler , root , namingCallback ) ;
NodeTraversal . traverseRoots ( compiler , pass , externs , root ) ;
NodeTraversal . traverseRoots ( compiler , this , externs , root ) ;
{ NodeTraversal . traverse ( compiler , originalRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , externs , this ) ;
{ NodeTraversal . traverse ( compiler , externs , findExternsCallback ) ; }
{ NodeTraversal . traverse ( compiler , js , this ) ; }
if ( renameMessages ) { RenameMessagesVisitor renameMessagesVisitor = new RenameMessagesVisitor () ; NodeTraversal . traverse ( compiler , root , renameMessagesVisitor ) ; }
NodeTraversal . traverse ( compiler , root , namingCallback ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , originalRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , function . getLastChild () , finder ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , NodeUtil . getLoopCodeBlock ( loopNode ) , continueStatementUpdater ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , superSet . getLastChild () , this ) ;
{ NodeTraversal . traverse ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
{ CheckProvidesCallback callback = new CheckProvidesCallback ( codingConvention ) ; NodeTraversal . traverse ( compiler , scriptRoot , callback ) ; }
NodeTraversal . traverse ( compiler , cfgNode , gatherCb ) ;
NodeTraversal . traverse ( compiler , n , gatherCb ) ;
NodeTraversal . traverse ( compiler , cfgNode , gatherCb ) ;
NodeTraversal . traverse ( compiler , t . getScopeRoot () , new GatherCandidates () ) ;
NodeTraversal . traverse ( compiler , scriptRoot , this ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
{ new InferConsts ( compiler ) . process ( externs , root ) ; NodeTraversal . traverse ( compiler , root , constFinder ) ; }
NodeTraversal . traverse ( this , n , sia ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , NodeUtil . getFunctionBody ( constructor ) , finder ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , externs , this ) ; compiler . setExternProperties ( ImmutableSet . copyOf ( externProperties ) ) ; }
NodeTraversal . traverse ( compiler , tree , test ) ;
NodeTraversal . traverse ( compiler , tree , test ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverse ( compiler , root , new Callback () ) ;
NodeTraversal . traverse ( compiler , root , traversal ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , externs , externsCallback ) ;
NodeTraversal . traverse ( compiler , originalRoot , cb ) ;
NodeTraversal . traverse ( compiler , root , new ProcessProperties () ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , new GatherCollapses () ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverseScopeRoots ( compiler , root , changedScopes , new EmptyClinitPruner () , false ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverse ( compiler , script , test ) ;
{ checkArgument ( isEs6ModuleRoot ( root ) , root ) ; clearState () ; NodeTraversal . traverse ( compiler , root , this ) ; }
if ( isEs6ModuleRoot ( scriptNode ) ) { processFile ( scriptNode ) ; } else { NodeTraversal . traverse ( compiler , scriptNode , new RewriteRequiresForEs6Modules () ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , callbacks . get ( NUMBER_CONSTANT ) ) ; }
NodeTraversal . traverse ( compiler , root , new Strip () ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
NodeTraversal . traverse ( getLastCompiler () , getLastCompiler () . jsRoot , findFunction ) ;
NodeTraversal . traverse ( getLastCompiler () , getLastCompiler () . jsRoot , findParameter ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , this ) ;
{ NodeTraversal . traverse ( compiler , root , new ExportTestFunctionsNodes () ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , externs , findExternsCallback ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , callback , new RenameCallback ( aliasName , renamed ) ) ; aliasName = renamed ; break; }
NodeTraversal . traverse ( compiler , callbackBlock , new DefineCallbackReturnCallback () ) ;
{ NodeTraversal . traverse ( compiler , root , new TransformAMDModulesCallback () ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , script , this ) ;
NodeTraversal . traverse ( compiler , googRoot , this ) ;
{ checkArgument ( scriptNode . isScript () ) ; NodeTraversal . traverse ( compiler , scriptNode , this ) ; }
{ if ( ! rules . isEmpty () ) { NodeTraversal . traverseRoots ( compiler , this , externs , root ) ; } }
NodeTraversal . traverse ( compiler , tree , cb ) ;
{ checkState ( root . isScript () ) ; NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverseRoots ( compiler , this , externs , root ) ;
NodeTraversal . traverse ( compiler , js , new Normalize.NormalizeStatements ( compiler , false ) ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , new ProcessVars () ) ;
NodeTraversal . traverseScopeRoots ( compiler , null , changedScopeRoots , new UseSiteGatheringCallback () , false ) ;
{ super . process ( externs , source ) ; NodeTraversal . traverse ( compiler , source , new UseSiteGatheringCallback () ) ; }
NodeTraversal . traverse ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
{ requiresLineNumbers = false ; NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , constructorBody , replaceThisWithSuperThis ) ;
NodeTraversal . traverse ( compiler , functionBody , checkForDefinedReturnValue ) ;
NodeTraversal . traverse ( compiler , enclosingFunction , checkAssigns ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , root , findExportableNodes ) ;
NodeTraversal . traverse ( compiler , parsed.ast , new Traverser ( info ) ) ;
{ FindPrimitives pass = new FindPrimitives () ; NodeTraversal . traverse ( compiler , root , pass ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , pass ) ;
NodeTraversal . traverse ( compiler , body , traversal ) ;
NodeTraversal . traverse ( compiler , root , getterSetterCollector ) ;
NodeTraversal . traverse ( compiler , body , this ) ;
NodeTraversal . traverseScopeRoots ( compiler , null , changedScopeRoots , cb , cb , false ) ;
{ requiresTypes = false ; NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , this ) ;
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ mode = Mode.SINGLE_FILE ; reset () ; NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ reset () ; NodeTraversal . traverseRoots ( compiler , this , externs , root ) ; }
NodeTraversal . traverse ( compiler , root , definitionsGatherer ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverseScopeRoots ( compiler , root , changedScopeNodes , new PeepCallback () , false ) ; if ( ! retraverseOnChange ) { break; } }
NodeTraversal . traverse ( compiler , root , new ReductionGatherer ( reducers , reductionMap ) ) ;
{ NodeTraversal . traverse ( compiler , js , new DeadAssignmentsElimination ( compiler ) ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , root , new ProcessProperties () ) ;
{ NodeTraversal . traverse ( compiler , root , new SourceInformationAnnotator ( STRING_CONSTANT , false ) ) ; }
{ PolymerPassSuppressBehaviors suppressBehaviorsCallback = new PolymerPassSuppressBehaviors ( compiler ) ; NodeTraversal . traverse ( compiler , root , suppressBehaviorsCallback ) ; }
return new IdentifierToken ( getTokenRange ( beginToken ) , value ) ;
NodeTraversal . traverse ( compiler , script , cb ) ;
NodeTraversal . traverse ( compiler , rootNode , callback ) ;
NodeTraversal . traverse ( metadata . getCompiler () , script , callback ) ;
assertType ( x . getType () ) . toStringIsEqualTo ( STRING_CONSTANT ) ;
assertType ( bar . getType () ) . toStringIsEqualTo ( STRING_CONSTANT ) ;
assertType ( f . getPropertyType ( STRING_CONSTANT ) ) . toStringIsEqualTo ( STRING_CONSTANT ) ;
if ( NodeUtil . isNameDeclaration ( item ) ) { item = item . getFirstChild () ; }
{ checkArgument ( parent . isFunction () || NodeUtil . isNameDeclaration ( parent ) || parent . isParamList () || parent . isCatch () ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new IdentifyGlobalEnumsAndTypedefsAsNonNullable ( typeRegistry ) ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
NodeTraversal . traverse ( compiler , root , new IdentifyGlobalEnumsAndTypedefsAsNonNullable ( typeRegistry ) ) ;
ReferenceCollectingCallback refCollector = new ReferenceCollectingCallback ( this , ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR , new Es6SyntacticScopeCreator ( this ) ) ;
private TypeCheckResult parseAndTypeCheckWithScope ( String js ) { return parseAndTypeCheckWithScope ( STRING_CONSTANT , js ) ; }
private Node parseAndTypeCheck ( String js ) { return parseAndTypeCheck ( STRING_CONSTANT , js ) ; }
{ testTypesWithExterns ( DEFAULT_EXTERNS + STRING_CONSTANT + externs , js , diag , false ) ; }
{ testTypesWithExterns ( externs , js , ( String ) null , false ) ; }
{ testTypesWithExterns ( STRING_CONSTANT , js , description , isError ) ; }
public void testCovariantIThenable3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testSymbol2 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testSymbol1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch6 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch5 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch4 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch2 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeCovariant2 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeCovariant1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
Node js1Node = parseAndTypeCheck ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
Node js1Node = parseAndTypeCheck ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT ) ;
{ TypeCheckResult p = parseAndTypeCheckWithScope ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testAddingMethodsUsingPrototypeIdiomComplexNamespace ( p ) ; }
{ TypeCheckResult p = parseAndTypeCheckWithScope ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testAddingMethodsUsingPrototypeIdiomComplexNamespace ( p ) ; }
Node js1Node = parseAndTypeCheck ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT ) ;
public void testFunctionBind5 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind4 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind3 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind2 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind1 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall8 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall7 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall6 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall5 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall3 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall2 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall1 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testAbstractMethodCall13 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall12 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall10 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall8 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall7 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall5 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testIssue1201b () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testThis14 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess9 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess8 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess7 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess6 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess4 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess3 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess2 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess1 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testGetelemStruct_noErrorForGettingWellKnownSymbol () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testGetelemStruct_noErrorForSettingWellKnownSymbol () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testForOf8 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf6 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf5 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf4 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ Node number = createUntypedNumber ( n ) ; number . setJSType ( getNativeNumberType () ) ; return number ; }
{ Node n = new Node ( Token.NULL ) ; n . setJSType ( getNativeNullType () ) ; return n ; }
child . inferSlotType ( STRING_CONSTANT , getNativeNumberType () ) ;
public void testTransformationWithUnionInMaprecord () { testTTL ( getNativeUnknownType () , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithInvalidMaprecord () { testTTL ( getNativeUnknownType () , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithInvalidNestedMapunion () { testTTL ( getNativeUnknownType () , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testTransformationWithNestedMapunionInMapFunctionBody () { testTTL ( getNativeStringType () , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithNestedExpressionInBooleanSecondParam () { testTTL ( getNativeStringType () , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithNestedExpressionInBooleanFirstParam () { testTTL ( getNativeStringType () , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
assertTypeEquals ( type , getNativeObjectType () ) ;
{ Node n = parseAndTypeCheck ( STRING_CONSTANT ) ; assertTypeEquals ( getNativeErrorType () , n . getFirstFirstChild () . getJSType () ) ; }
assertTypeEquals ( getNativeNumberType () , type ) ;
assertTypeEquals ( getNativeNumberType () , type ) ;
assertTypeEquals ( STRING_CONSTANT , getNativeNumberType () , googFooGetprop2ObjectType . getPropertyType ( STRING_CONSTANT ) ) ;
public void testName5 () { assertTypeEquals ( getNativeRegexpConstructorType () , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName4 () { assertTypeEquals ( getNativeDateConstructorType () , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName3 () { assertTypeEquals ( getNativeArrayConstructorType () , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName2 () { assertTypeEquals ( getNativeObjectConstructorType () , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName1 () { assertTypeEquals ( getNativeVoidType () , testNameNode ( STRING_CONSTANT ) ) ; }
assertTypeEquals ( getNativeArrayType () , a . getType () ) ;
assertTypeEquals ( getNativeVoidType () , n . getJSType () ) ;
{ Node falseNode = typeCheck ( new Node ( Token.FALSE ) ) ; assertTypeEquals ( getNativeBooleanType () , falseNode . getJSType () ) ; }
{ Node trueNode = typeCheck ( new Node ( Token.TRUE ) ) ; assertTypeEquals ( getNativeBooleanType () , trueNode . getJSType () ) ; }
{ Node n = typeCheck ( Node . newString ( STRING_CONSTANT ) ) ; assertTypeEquals ( getNativeStringType () , n . getJSType () ) ; }
{ Node n = typeCheck ( Node . newNumber ( NUMBER_CONSTANT ) ) ; assertTypeEquals ( getNativeNumberType () , n . getJSType () ) ; }
{ TypeCheckResult p = parseAndTypeCheckWithScope ( STRING_CONSTANT ) ; assertTypeEquals ( getNativeNumberType () , p.scope . getVar ( STRING_CONSTANT ) . getType () ) ; }
JSDocInfo jsDoc = NodeUtil . isNameDeclaration ( node . getParent () ) ? node . getParent () . getJSDocInfo () : node . getJSDocInfo () ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks , options ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes , options ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories , compiler . getOptions () ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes , compiler . getOptions () ) ;
shouldAddTypes ? contextType . getPropertyType ( fieldName ) : null
String embedded = transpiled + STRING_CONSTANT + ESCAPER . escape ( sourceMap ) + STRING_CONSTANT ;
var . getParentNode () != null && var . getType () == null && NodeUtil . isNameDeclaration ( var . getParentNode () )
options . setPreserveClosurePrimitives ( true ) ;
ObjectType regType = ObjectType . cast ( registry . getType ( scope . getDeclarationScope () , qualifiedName ) ) ;
JSType windowType = getTypeInternal ( null , STRING_CONSTANT ) ;
private void registerGlobalType ( JSType type ) { register ( null , type , type . toString () ) ; }
{ typesIndexedByProperty . clear () ; eachRefTypeIndexedByProperty . clear () ; initializeBuiltInTypes () ; scopedNameTable . clear () ; initializeRegistry () ; }
assertTypeEquals ( typeRegistry . getNativeType ( GENERATOR_TYPE ) , typeRegistry . getGlobalType ( STRING_CONSTANT ) ) ;
assertTypeEquals ( typeRegistry . getNativeType ( ITERATOR_TYPE ) , typeRegistry . getGlobalType ( STRING_CONSTANT ) ) ;
assertTypeEquals ( typeRegistry . getNativeType ( ITERABLE_TYPE ) , typeRegistry . getGlobalType ( STRING_CONSTANT ) ) ;
{ warnImplicitlyNullable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; warnImplicitlyNullable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
JSType type = registry . getType ( resolutionScope , reference ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
NodeUtil . isLoopStructure ( scopeRoot )
actualYieldType = actualYieldType . autobox () . getTemplateTypeMap () . getResolvedTemplateType ( typeRegistry . getIterableTemplate () ) ;
var . getParentNode () != null && var . getType () == null && var . getParentNode () . isVar ()
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.OTI_ONLY ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; late = false ; useTypes = true ; numRepetitions = NUMBER_CONSTANT ; mode = TypeInferenceMode.DISABLED ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
warning ( TYPE_MISMATCH_WARNING )
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
Node parse ( String js ) { return parse ( js , TypeInferenceMode.DISABLED ) ; }
new CodePrinter.Builder ( parse ( js , TypeInferenceMode.CHECKED ) )
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = STRING_CONSTANT ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
public void disable_testClassMethodUnused2 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassPropUnused1 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; }
public void testClassWithEmptyMembers () { this . mode = TypeInferenceMode.DISABLED ; testError ( STRING_CONSTANT , StrictModeCheck.DUPLICATE_CLASS_METHODS ) ; }
public void testStaticAndNonstaticSetterWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticGetterWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticMethodWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testComputedPropInClass () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
public void testArguments6 () { this . mode = TypeInferenceMode.DISABLED ; testSame ( STRING_CONSTANT ) ; }
public void testUnknownVariable4 () { this . mode = TypeInferenceMode.DISABLED ; testSameEs6Strict ( STRING_CONSTANT ) ; testSameEs6Strict ( STRING_CONSTANT ) ; }
{ super . setUp () ; late = true ; useTypes = true ; this . mode = TypeInferenceMode.DISABLED ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefinePropertiesQuotesPreventRemoval () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty1 () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.DISABLED ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_boxedNumberVsZero () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_while () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; late = true ; this . mode = TypeInferenceMode.DISABLED ; ignoreWarnings ( DiagnosticGroups.NEW_CHECK_TYPES_EXTRA_CHECKS ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
this . mode = TypeInferenceMode.CHECKED ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.CHECKED ; }
testSame ( externs ( lines ( MINIMAL_EXTERNS , STRING_CONSTANT , STRING_CONSTANT ) ) , srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , warning ( TypeValidator.TYPE_MISMATCH_WARNING ) )
{ this . mode = TypeInferenceMode.DISABLED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.DISABLED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
test ( srcs ( STRING_CONSTANT ) , warning ( TOO_MANY_TEMPLATE_PARAMS ) ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( srcs ( STRING_CONSTANT ) , warning ( TOO_MANY_TEMPLATE_PARAMS ) ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
for ( NamedType type : unresolvedNamedTypes . get ( scope ) ) { type . resolve ( reporter ) ; }
activeXObject . resolve ( null ) ;
namedA . resolve ( null ) ;
{ if ( type != null ) { this . type = type . resolve ( errorReporter ) ; } }
a . resolve ( null ) ;
for ( DeferredSetType deferred : deferredSetTypes ) { deferred . resolve () ; }
TranspilationPasses . addEs6PreTypecheckPasses ( factories , compiler . getOptions () ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes , compiler . getOptions () ) ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks , options ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes , options ) ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
public void testAbstractClass () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT , warning ( INSTANTIATE_ABSTRACT_CLASS ) ) ; }
disableTypeCheck () ;
{ disableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ disableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
Node parse ( String js ) { return parse ( js , false ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefinePropertiesQuotesPreventRemoval () { enableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { enableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
enableTypeCheck () ;
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties1 () { enableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testES6StaticProperty2 () { disableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
public void testES6StaticProperty () { disableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testConstructorProperty2 () { enableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty1 () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; disableTypeCheck () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; enableTranspile () ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ super . setUp () ; disableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
public void testClassWithEmptyMembers () { disableTypeCheck () ; testError ( STRING_CONSTANT , StrictModeCheck.DUPLICATE_CLASS_METHODS ) ; }
public void testStaticAndNonstaticSetterWithSameName () { disableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticGetterWithSameName () { disableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticMethodWithSameName () { disableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testComputedPropInClass () { disableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
public void testArguments6 () { disableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
public void testUnknownVariable4 () { disableTypeCheck () ; testSameEs6Strict ( STRING_CONSTANT ) ; testSameEs6Strict ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; late = true ; useTypes = true ; disableTypeCheck () ; }
public void disable_testClassMethodUnused2 () { disableTypeCheck () ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { disableTypeCheck () ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassPropUnused1 () { disableTypeCheck () ; unused ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; disableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
disableTypeCheck () ;
disableTypeCheck () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; enableTypeCheck () ; }
disableTypeCheck () ;
disableTypeCheck () ;
{ disableTypeCheck () ; String source = STRING_CONSTANT ; assertNoPureCalls ( source ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
{ disableTypeCheck () ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
disableTypeCheck () ;
{ disableTypeCheck () ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
{ disableTypeCheck () ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ super . setUp () ; disableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
new CodePrinter.Builder ( parse ( js , true ) )
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_boxedNumberVsZero () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_while () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
enableTypeCheck () ;
public void testCoercionSubstitution_expression () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
public void testCoercionSubstitution_booleanResult0 () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTranspile () ; enableTypeCheck () ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ; }
public boolean isTypecheckingEnabled () { return this . checkTypes ; }
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ; }
this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ;
return getTypeRegistry () ;
this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ;
ignoreWarnings ( TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED ) ;
public void testTypeMismatch () { ignoreWarnings ( TypeValidator.TYPE_MISMATCH_WARNING ) ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
DiagnosticGroup ignored = new DiagnosticGroup ( TypeCheck.INEXISTENT_PROPERTY , TypeValidator.TYPE_MISMATCH_WARNING ) ;
validator . expectCanAssignTo ( t , loopVarNode , actualType , declaredType , STRING_CONSTANT ) ;
checkArgument ( setKey == null || setKey . isSetterDef () , setKey ) ;
hoistNode ( varStatement ) ;
hoistNode ( n ) ;
if ( NodeUtil . isSomeCompileTimeConstStringValue ( ast ) ) { paramNodeMatches . set ( paramIndex , ast ) ; return true ; }
{ return NodeUtil . isSomeCompileTimeConstStringValue ( ast ) ; }
{ if ( ! isSafeValue ( traversal . getScope () , argument ) ) { compiler . report ( traversal . makeError ( argument , CONST_NOT_STRING_LITERAL_ERROR ) ) ; } }
if ( prop != null ) { if ( NodeUtil . isSomeCompileTimeConstStringValue ( prop ) ) { continue; } return violation ; }
NodeUtil . isLhsOfAssign ( propAccess ) && ( NodeUtil . isLiteralValue ( propAccess . getNext () , false ) || NodeUtil . isSomeCompileTimeConstStringValue ( propAccess . getNext () ) )
String lastPart = typeString . substring ( typeString . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
int index = name . indexOf ( CHAR_CONS ) ;
checkArgument ( setKey . isSetterDef () , setKey ) ;
URI path
URI path
URI path
URI path
URI path
public void setSourceMapLocationMappings ( List < ? extends SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
{ locationMappings . add ( new SourceMap.PrefixLocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
List < ? extends LocationMapping > sourceMapLocationMappings
URI path
URI path
{ switch ( n . getToken () ) { case FOR_OF : visitForOf ( n , parent ) ; break; default: break; } }
this . registry = compiler . getTypeRegistry () ;
actual = new CodePrinter.Builder ( script ) . setCompilerOptions ( options ) . setTypeRegistry ( compiler . getTypeRegistry () ) . build () . trim ()
JSType type = fnNode . getJSType () ;
JSType type = n . getJSType () ;
public boolean isPrototypeObject () { return isFunctionPrototypeType () ; }
JSType type = srcObj . getJSType () ;
JSType attrsType = attrs . getJSType () ;
JSType type = srcObj . getJSType () ;
ObjectType targetType = target . getJSType () . toMaybeObjectType () ;
String typeName = n . getFirstChild () . getJSType () . toString () ;
JSType type = n . getJSType () ;
JSType type = n . getJSType () ;
{ return n . getJSType () != null && isKnown ( n ) && invalidDeref ( n ) && ! isWhitelistedType ( n ) ; }
JSType thrown = n . getFirstChild () . getJSType () ;
{ super ( compiler , requirement ) ; errorObjType = compiler . getTypeRegistry () . getGlobalType ( STRING_CONSTANT ) ; }
TemplateAstMatcher astMatcher = new TemplateAstMatcher ( compiler . getTypeRegistry () , templateRoot , typeMatchingStrategy ) ;
FunctionType restrictedCallType
FunctionType restrictedCallType
FunctionType functionType
JSType type = n . getJSType () ;
{ return isAssertionCall ( n . getParent () ) || n . getJSTypeBeforeCast () != null ; }
{ JSType type = n . getJSType () ; return ( type == null || type . isSomeUnknownType () ) ; }
{ JSType type = n . getJSType () ; return ( type == null || type . isUnknownType () ) ; }
{ JSType type = n . getJSType () ; return type != null && type . isTop () ; }
nativeObjectType = compiler . getTypeRegistry () . getNativeType ( JSTypeNative.OBJECT_TYPE ) ;
n . setJSType ( type ) ;
FunctionType getterType
JSTypeRegistry typeRegistry
public TypeSubject ( FailureMetadata failureMetadata , JSType type ) { super ( failureMetadata , type ) ; }
JSType type
FunctionType getterType
builder . setTypeRegistry ( getTypeRegistry () ) ;
StaticTypedScope < ? extends JSType > scope
private String formatTypeVar ( JSType var ) { return var . toAnnotationString ( Nullability.IMPLICIT ) ; }
JSTypeRegistry registry
JSType typeI = getPropLhs . getJSType () ;
if ( n . getJSType () == null ) { throw new IllegalStateException ( STRING_CONSTANT + n + STRING_CONSTANT + STRING_CONSTANT ) ; }
Builder ( JSTypeRegistry registry ) { this . registry = registry ; }
ObjectType objectType
@ Nullable ObjectType referenceType
JSType type = name . getJSType () ;
JSTypeRegistry typeRegistry
JSType type
public JSType getReturnType () { return call.returnType ; }
JSType type
JSType type
JSType type
JSType type
new InvalidatingTypes.Builder ( compiler . getTypeRegistry () ) . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () ) . addAllTypeMismatches ( compiler . getImplicitInterfaceUses () ) . build ()
JSTypeRegistry registry
public void applySingletonGetter ( NominalTypeBuilder classType , FunctionType getterType ) ;
Node assign = withType ( IR . assign ( copiedVarName , varName . removeFirstChild () ) , varName . getJSType () ) . useSourceInfoFrom ( varName ) ;
Node newThis = withType ( context . getScopedName ( GENERATOR_THIS ) , n . getJSType () ) ;
IR . returnNode ( withType ( IR . call ( createGenerator , withType ( genFuncName . cloneNode () , generatorFunction . getJSType () ) , program ) , originalGenReturnType ) )
JSTypeRegistry typeRegistry
JSType type = n . getJSType () ;
JSTypeRegistry registry
JSTypeRegistry registry
FunctionType getterType
Node stringKey = withType ( IR . stringKey ( name , n . getFirstChild () . detach () ) , n . getJSType () ) ;
this . registry = compiler . getTypeRegistry () ;
ImmutableMap < String , JSType > typeVars
JSTypeRegistry registry
{ JSType type = n . getJSType () ; return ( type != null && type . isFunctionType () ) ; }
JSType jsType
JSType jsType
CodePrinter.Builder builder = new CodePrinter.Builder ( externsRoot ) . setPrettyPrint ( true ) . setOutputTypes ( true ) . setTypeRegistry ( compiler . getTypeRegistry () ) ;
lit . setJSType ( exportedObjectLit . getJSType () ) ;
TemplateAstMatcher matcher = new TemplateAstMatcher ( lastCompiler . getTypeRegistry () , templateRoot . getFirstChild () , typeMatchingStrategy ) ;
replacement . setJSType ( call . getJSType () ) ;
JSType type = expr . getJSType () ;
mathDotPowCall = withType ( IR . call ( mathPow . get () . cloneTree () , left , right ) , n . getJSType () ) . useSourceInfoIfMissingFromForTree ( n )
JSType type = n . getJSType () ;
lastCompiler . getTypeRegistry ()
lastCompiler . getTypeRegistry ()
JSType type
new InvalidatingTypes.Builder ( compiler . getTypeRegistry () ) . disallowGlobalThis () . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () ) . build ()
JSType type
JSType receiverType = determineReceiverType ( n ) ;
this . registry = compiler . getTypeRegistry () ;
JSType type = n . getJSType () ;
replacement . setJSType ( getNativeStringType () ) ;
newName . setJSType ( child . getJSType () ) ;
@ Override public JSType getType () { return null ; }
public Builder setTypeRegistry ( JSTypeRegistry registry ) { this . registry = registry ; return this ; }
ObjectType prototypeOrInstance ( ) ;
void declarePrototypeProperty ( String name , JSType type , Node defSite ) ;
void declareInstanceProperty ( String name , JSType type , Node defSite ) ;
void declareConstructorProperty ( String name , JSType type , Node defSite ) ;
JSType type
JSType type = getType ( typeObj ) ;
JSType type = getType ( obj ) ;
JSType objlitType = getType ( n ) ;
JSType type = getType ( n . getFirstChild () ) ;
return n . isGetProp () && n . getLastChild () . getString () . equals ( STRING_CONSTANT ) && n . getFirstChild () . getJSType () . isStructuralInterface () ;
JSType recvType = getType ( recv ) ;
JSType type
JSType type
ObjectType objectType
ObjectType objectType
JSType type = n . getJSType () ;
this . typeRegistry = compiler . getTypeRegistry () ;
for ( Node n : nodeList ) { n.jstype = ( JSType ) in . readObject () ; }
for ( Node n : nodeList ) { out . writeObject ( n.jstype ) ; }
dst . setJSType ( this . jstype ) ;
@ Nullable public final JSType getJSTypeBeforeCast () { return ( JSType ) getProp ( TYPE_BEFORE_CAST ) ; }
public FunctionType getOwnerFunction () { return null ; }
JSType type = firstArg . getJSType () ;
@ Nullable JSType typeI
n . getJSType () == null
Path path
Path path
Path path
Path path
Path path
List < LocationMapping > sourceMapLocationMappings
{ locationMappings . add ( new SourceMap.LocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
Path path
Path path
public void setSourceMapLocationMappings ( List < SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
if ( c . getString () . equals ( WINDOW_NAME ) ) { windowInExterns = true ; continue; }
abstract boolean hasTypeCheckingRun ( ) ;
this . compiler . setTypeCheckingHasRun ( true ) ;
this . addTypes = compiler . hasTypeCheckingRun () ;
compiler . setTypeCheckingHasRun ( true ) ;
{ this . compiler = compiler ; this . addTypes = compiler . hasTypeCheckingRun () ; }
typeCheckingHasRun = compilerState.typeCheckingHasRun ;
this . typeCheckingHasRun = compiler.typeCheckingHasRun ;
compiler . setTypeCheckingHasRun ( true ) ;
{ this . compiler = compiler ; this . addTypes = compiler . hasTypeCheckingRun () ; }
this . addTypes = compiler . hasTypeCheckingRun () ;
if ( c . getString () . equals ( STRING_CONSTANT ) ) { windowInExterns = true ; continue; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
{ super . setUp () ; compiler . getOptions () . setWarningLevel ( DiagnosticGroups.MISSING_OVERRIDE , CheckLevel.WARNING ) ; compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_CHECK_TYPES , CheckLevel.WARNING ) ; }
if ( prevUsedRenameMap != null ) { reusePreviouslyUsedVariableMap ( varsByFrequency ) ; }
if ( ! validator . expectAutoboxesToIterable ( t , n , actualYieldType , STRING_CONSTANT ) ) { return; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
if ( c . getString () . equals ( WINDOW_NAME ) ) { windowInExterns = true ; continue; }
public ResolutionMode getModuleResolutionMode () { return this . moduleResolutionMode ; }
JSType objectType
JSType objectType
if ( iterableType != null ) { typeParam = iterableType . getInstantiatedTypeArgument ( registry . getNativeType ( JSTypeNative.ITERABLE_TYPE ) ) ; }
JSType newType = objType . getInstantiatedTypeArgument ( getNativeType ( ITERABLE_TYPE ) ) ;
defineSlot ( astParameter , paramType , inferred ) ;
{ defineSlot ( fnNameNode , fnNode . getJSType () , false ) ; }
if ( candidate . isGetProp () ) { defineSlot ( candidate , getNativeType ( NO_TYPE ) , false ) ; }
defineSlot ( n , valueType , inferred ) ;
if ( NodeUtil . isFunctionDeclaration ( n ) ) { defineSlot ( n . getFirstChild () , functionType ) ; }
{ boolean inferred = keyType == null ; defineSlot ( keyNode , qualifiedName , keyType , inferred ) ; }
! type . matchesNumberContext () && ! type . matchesStringContext () && ! type . matchesSymbolContext ()
FunctionType makeIteratorType = registry . createFunctionType ( iteratorType , paramBuilder . build () ) ;
{ return isSubtype ( that , ImplCache . createWithoutStructuralTyping () , SubtypingMode.NORMAL ) ; }
URI path
URI path
List < ? extends LocationMapping > sourceMapLocationMappings
public void setSourceMapLocationMappings ( List < ? extends SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
URI path
URI path
URI path
{ locationMappings . add ( new SourceMap.PrefixLocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
URI path
URI path
visitImport ( t . getInput () . getPath () , n ) ;
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , es6ModuleTranspiler , newMode , sourceUrl , path , sourceMapCache ) ; }
return tightenTypeAfterDereference ( n . getFirstChild () , scope ) ;
return dereferencePointer ( n . getFirstChild () , scope ) ;
{ testTypes ( externs , js , description , false ) ; }
{ testTypes ( STRING_CONSTANT , js , diagnosticType , isError ) ; }
{ testTypes ( STRING_CONSTANT , js , description , isError ) ; }
public void testGenerator_yieldAll_string () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_yieldAll1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_return2 () { testTypesWithCommonExterns ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_noDeclaredReturnType3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_returnsIterator2 () { testTypesWithCommonExterns ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_returnsIterable2 () { testTypesWithCommonExterns ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator3 () { testTypesWithCommonExterns ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_StringObject2 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_StringObject1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_string1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_array3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType6a () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType5 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType4a () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrayLitSpread () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
JSType getTypeOfThis ( ) ;
StaticTypedScope scope
{ if ( sym instanceof StaticTypedSlot ) { return ( ( StaticTypedSlot ) sym ) . isTypeInferred () ; } return true ; }
{ if ( s instanceof StaticTypedScope ) { return ( ( StaticTypedScope ) s ) . getTypeOfThis () ; } return null ; }
{ if ( sym instanceof StaticTypedSlot ) { return ( ( StaticTypedSlot ) sym ) . getType () ; } return null ; }
StaticTypedScope scope
StaticTypedScope typeEnv
StaticTypedScope getDeclarationScope ( ) ;
FlowScope createChildFlowScope ( StaticTypedScope scope ) ;
@ Override public JSType getTypeOfThis () { return null ; }
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedSlot slot
StaticTypedScope scope
@ Override StaticTypedScope getScope ( ) ;
if ( n . isAssignAdd () ) { updateScopeForAssignment ( scope , left , leftType , type ) ; }
visitArgumentList ( t , n , functionType ) ;
visitArgumentList ( t , n , fnType ) ;
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
while ( current.parent != null && current.scopes == current.parent.scopes ) { current = current.parent ; }
NodeUtil . isInvocation ( n ) || n . isYield ()
return tightenTypeAfterDereference ( n . getFirstChild () , scope ) ;
updateTypeOfArguments ( n , fnType ) ;
updateTypeOfParameters ( n , fnType ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6InjectRuntimeLibraries ( compiler ) ; }
updateTypeOfArguments ( n , fnType ) ;
if ( ! options.checksOnly ) {}
if ( decl . isAliasDefinition () ) { return; }
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( n . isAssignAdd () ) { scope = updateScopeForAssignment ( scope , left , leftType , type ) ; }
flowScope = flowScope . inferSlotType ( STRING_CONSTANT , type ) ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
child = child . inferSlotType ( STRING_CONSTANT , getNativeNumberType () ) ;
if ( this == that ) { return true ; }
FlowScope output = input . withSyntacticScope ( scopeCreator . createScope ( root ) ) ;
FlowScope informed = blindScope ;
assign . useSourceInfoIfMissingFromForTree ( method ) ;
{ scope = traverseChildren ( name , scope ) ; }
parentChunkCanSeeSymbolsDeclaredInChildren = false ;
List < String > moduleNameRegexList = options.chunksToPrintAfterEachPassRegexList ;
{ return new CrossModuleMethodMotion ( compiler , compiler . getCrossModuleIdGenerator () , options.removeUnusedPrototypePropertiesInExterns , options.crossChunkCodeMotionNoStubMethods ) ; }
{ return new CrossModuleCodeMotion ( compiler , compiler . getModuleGraph () , options.parentChunkCanSeeSymbolsDeclaredInChildren ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RescopeGlobalSymbols ( compiler , options.renamePrefixNamespace , options.renamePrefixNamespaceAssumeCrossChunkNames ) ; }
assertFalse ( REGEXP_TYPE . canBeCalled () ) ;
obj != null && obj . isFunctionPrototypeType ()
return subtype . isEmptyType () ;
@ Override public final boolean isVoidable () { return true ; }
@ Override public final boolean isNullable () { return true ; }
@ Override public final boolean isNoObjectType () { return false ; }
type . isEnumElementType ()
type . isFunctionPrototypeType ()
! callClassType . isEmptyType () && ! callClassType . isSomeUnknownType ()
type == null || type . isUnknownType () || type . isUnresolved () || type . isAllType ()
return ! type . isAllType () && ( type . isNullable () || type . isVoidable () ) ;
targetType . isUnknownType () || targetType . isUnresolved () || targetType . isAllType () || targetType . isEquivalentTo ( registry . getNativeType ( JSTypeNative.OBJECT_TYPE ) )
{ JSType type = n . getJSType () . restrictByNotNullOrUndefined () ; return type . isEmptyType () ; }
{ JSType type = n . getJSType () ; return type != null && type . isAllType () ; }
if ( ft != null ) { functionNode . setJSType ( convertMethodToFunction ( ft ) ) ; }
if ( body . isEmptyType () || body . isEquivalentTo ( getObjectType () ) ) { continue; }
return result . isEmptyType () ? getUnknownType () : result ;
if ( type . isEnumElementType () ) { return type . getEnumeratedTypeOfEnumElement () ; }
return type != null && containsArray ( type ) ;
if ( objType . isFunctionPrototypeType () ) { constructor = objType . getOwnerFunction () ; } else { constructor = objType . getConstructor () ; }
type . isEnumElementType ()
{ return type . isEnumType () || type . isBoxableScalar () ; }
if ( type . isEnumElementType () ) { return getTypesToSkipForType ( type . getEnumeratedTypeOfEnumElement () ) ; }
if ( ! t . isObjectType () || t . isAllType () ) { return; }
type . isAllType () || type . isUnknownType ()
type . isAllType () || type . isUnknownType ()
public final boolean isAbstract () { return isAbstract ; }
return shouldTreatThisTypesAsCovariant ( other , implicitImplCache ) && this . call . isSubtype ( other.call , implicitImplCache , subtypingMode ) ;
public final ObjectType getPrototypeProperty () { return getPrototype () ; }
public final boolean isReturnTypeInferred () { return call.returnTypeInferred ; }
public final JSType getReturnType () { return call.returnType ; }
@ Override public final boolean canBeCalled () { return true ; }
public final void setDict () { propAccess = PropAccess.DICT ; }
public final void setStruct () { propAccess = PropAccess.STRUCT ; }
return restricted . isEmptyType () ? type : restricted ;
retType != null && ! retType . isEmptyType () && ! funType . isInterface ()
final ObjectType getReferencedObjTypeInternal () { return referencedObjType ; }
final JSType getReferencedTypeInternal () { return referencedType ; }
if ( ! receiverType . meetWith ( type ) . isEmptyType () ) { return true ; }
@ Override public final boolean matchesStringContext () { return true ; }
@ Override public final boolean matchesSymbolContext () { return true ; }
@ Override public final boolean matchesObjectContext () { return true ; }
@ Override public final boolean matchesNumberContext () { return true ; }
@ Override public final boolean isConstructor () { return false ; }
if ( type == null || type . isUnknownType () || type . isAllType () ) { return allowLooseMatches ? MatchResult.LOOSE_MATCH : MatchResult.NO_MATCH ; }
{ return type == null ? null : type . dereference () ; }
propdef . setJSType ( stringType ) ;
visitImport ( n ) ;
@ Override public boolean isApplied ( CompilerOptions options ) { return options . shouldRunCrossChunkMethodMotion () ; }
@ Override public boolean isApplied ( CompilerOptions options ) { return options . shouldRunCrossChunkCodeMotion () ; }
ensureTyped ( n ) ;
{ ensureTyped ( name , valueType ) ; }
ensureTyped ( n ) ;
ensureTyped ( n ) ;
ensureTyped ( n , type ) ;
ensureTyped ( iterableNode ) ;
if ( ! options.checksOnly ) {}
if ( recordUnresolvedTypes ) { unresolvedNamedTypes . add ( namedType ) ; }
if ( topScope == null ) { regenerateGlobalTypedScope ( compiler , root . getParent () ) ; } else { compiler . getTypeRegistry () . resolveTypes () ; }
{ whitespaceOnlyPasses () ; if ( options . needsTranspilationFrom ( options . getLanguageIn () . toFeatureSet () ) ) { transpileAndDontCheck () ; } }
FeatureSet features = NodeUtil . getFeatureSetOfScript ( script ) ;
body . isBlock () && ! body . hasChildren ()
{ return ( n . isBlock () && n . isSyntheticBlock () ) || n . isScript () ; }
checkState ( block . isBlock () ) ;
if ( ! block . isBlock () ) { return null ; }
stmt . isEmpty () || ( stmt . isBlock () && ! stmt . hasChildren () )
{ checkState ( expr . isName () ) ; checkState ( body . isBlock () ) ; return new Node ( Token.CATCH , expr , body ) ; }
checkState ( finallyBody . isBlock () ) ;
checkState ( tryBody . isBlock () ) ;
{ checkState ( body . isBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
checkState ( body . isBlock () ) ;
checkState ( body . isBlock () ) ;
checkState ( body . isBlock () ) ;
{ checkState ( body . isBlock () ) ; checkState ( mayBeExpression ( cond ) ) ; return new Node ( Token.WHILE , cond , body ) ; }
{ checkState ( body . isBlock () ) ; checkState ( mayBeExpression ( cond ) ) ; return new Node ( Token.DO , body , cond ) ; }
{ checkState ( mayBeExpression ( cond ) ) ; checkState ( then . isBlock () ) ; return new Node ( Token.IF , cond , then ) ; }
checkState ( body . isBlock () || mayBeExpression ( body ) ) ;
checkState ( body . isBlock () ) ;
if ( n . isExprResult () || n . isBlock () ) { return; }
if ( ! favorsCommaOverSemiColon && ! block . isBlock () ) { return false ; }
! n . isBlock ()
{ checkArgument ( blockNode . isBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
if ( n . isBlock () ) { visitBlock ( n ) ; }
n . isBlock ()
! target . getParent () . isScript () && ! target . getParent () . isBlock () && ! target . getParent () . isModuleBody ()
boolean isVar = NodeUtil . isNameDeclaration ( parent ) && parent . getParent () . isBlock () ;
isGoogScopeFunctionBody ( enclosingFunctionBody ) && scopeRoot . isBlock () && ! scopeRoot . getParent () . isFunction ()
if ( ! n . isBlock () || ! n . hasChildren () || ! isGoogModuleCall ( n . getFirstChild () ) ) { return false ; }
{ checkArgument ( n . isBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
n . isBlock ()
checkState ( addingRoot . isBlock () || addingRoot . isModuleBody () || addingRoot . isScript () ) ;
{ return n . isBlock () && n . getParent () != null && n . getParent () . isFunction () ; }
checkState ( block . isBlock () ) ;
node . isBlock ()
{ return n . isRoot () || n . isScript () || n . isBlock () || n . isModuleBody () ; }
if ( ! block . isBlock () ) { return false ; }
NodeUtil . isControlStructureCodeBlock ( n , c ) && ! c . isBlock ()
checkState ( body . getNext () == null && body . isBlock () , body ) ;
if ( ! n . isFunction () || ! n . getLastChild () . isBlock () ) { return; }
if ( ! subtree . isScript () && ! subtree . isBlock () ) { return subtree ; }
checkState ( n . isBlock () , n ) ;
statement . isBlock ()
if ( ! n . isBlock () || ! n . hasChildren () ) { return; }
block . isBlock () && block . getParent () . isTry () && block . getParent () . getFirstChild () == block
if ( parent . getParent () != null && parent . getParent () . isArrowFunction () && ! parent . isBlock () ) { return false ; }
{ return getRootNode () . isBlock () && getRootNode () . hasOneChild () && getRootNode () . getFirstChild () . isCatch () ; }
checkState ( block . isBlock () ) ;
for ( Node child : node . children () ) { if ( child . isBlock () ) { blocks . add ( child ) ; } }
n . isBlock () && ! loneBlocks . isEmpty () && loneBlocks . peek () == n
( parent . isScript () || ( parent . isBlock () && ! parent . isSyntheticBlock () && ! parent . isAddedBlock () ) )
scopeRoot . isBlock () && scopeRoot . getParent () . isFunction ()
! setFunction . hasChildren () || ! setFunction . getLastChild () . isBlock () || ! setFunction . getSecondChild () . isParamList ()
if ( ! getFunction . hasChildren () || ! getFunction . getLastChild () . isBlock () ) { return false ; }
for ( ; ! currentParent . isScript () && ! currentParent . isBlock () ; current = currentParent , currentParent = currentParent . getParent () ) {}
n . isFunction () && parent != null && parent . isBlock () && ! parent . getParent () . isFunction ()
! n . getParent () . isScript () && ! n . getParent () . isBlock ()
if ( body . isBlock () ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
{ return n . isBlock () && n . hasChildren () && isReturnTypeNullable ( n . getParent () ) && ! hasSingleThrow ( n ) ; }
if ( n . isEmpty () || ( n . isBlock () && ! n . hasChildren () ) ) { return; }
next != null && next . isBlock ()
checkArgument ( node . isBlock () ) ;
node . isFunction () && ! NodeUtil . getFunctionBody ( node ) . isBlock ()
! originalBody . isBlock ()
block . isBlock ()
checkState ( body . isBlock () , body ) ;
checkState ( block . isBlock () ) ;
checkState ( jumpBlock . isBlock () ) ;
checkState ( block . isBlock () ) ;
checkState ( catchBody . isBlock () ) ;
context . transpileUnmarkedBlock ( n . isBlock () || n . isAddedBlock () ? n : IR . block ( n ) ) ;
checkState ( newGeneratorHoistBlock . isBlock () , newGeneratorHoistBlock ) ;
{ return node . getParent () . isExprResult () && node . getGrandparent () . isBlock () && isClinitMethod ( node . getGrandparent () . getParent () ) ; }
! ( parent . isScript () || ( grandparent != null && grandparent . isFunction () && parent . isBlock () ) )
! body . isBlock () || body . hasChildren ()
if ( ! body . isBlock () || ! body . hasOneChild () || ! body . getFirstChild () . isReturn () ) { return; }
! isArrow && ! isSignature && ! bodyNode . isBlock ()
! irNode . isBlock ()
n . isFunction () && n . getParent () . isBlock () && ! n . getGrandparent () . isFunction ()
checkState ( ifBlock . isBlock () , ifBlock ) ;
checkState ( block . isBlock () , block ) ;
checkState ( block . isBlock () , block ) ;
checkState ( block . isBlock () , block ) ;
checkState ( innerBlock . isBlock () , innerBlock ) ;
checkState ( block . isBlock () , block ) ;
checkState ( block . isBlock () , block ) ;
checkState ( block . isBlock () , block ) ;
{ Node functionBody = NodeUtil . getFunctionBody ( n ) ; if ( ! functionBody . isBlock () ) { return; } }
if ( node . isBlock () ) { node . setToken ( Token.SCRIPT ) ; }
deleteWhitespaceBefore && parent != null && ( parent . isScript () || parent . isBlock () )
checkState ( parentNode . isBlock () , STRING_CONSTANT ) ;
parent != null && ( parent . isBlock () || parent . isScript () )
if ( ! n . isScript () && ! n . isBlock () ) { return; }
! body . isBlock ()
! body . isBlock ()
s . isFunctionScope () && s . getRootNode () . getLastChild () . isBlock ()
n . isFunction () && ! NodeUtil . getFunctionBody ( n ) . isBlock ()
c . isBlock ()
c . isBlock ()
checkState ( caseBody . isBlock () , caseBody ) ;
! labeledStatement . isBlock ()
last . isBlock ()
n . isBlock ()
n . isBlock ()
n . isBlock ()
n . isBlock ()
if ( newChild . isBlock () ) { NodeUtil . tryMergeBlock ( newChild , false ) ; }
JSType calleeTypeI = checkNotNull ( callee . getJSType () , STRING_CONSTANT , callNode . toStringTree () ) ;
assertFalse ( numbers . isSubtype ( sub1 ) ) ;
if ( ! languageOutIsAtLeast ( polyfill.polyfillVersion ) ) { traversal . report ( node , INSUFFICIENT_OUTPUT_VERSION_ERROR , name , compiler . getOptions () . getOutputFeatureSet () . version () ) ; }
if ( options . getOutputFeatureSet () . contains ( ES6 ) ) { passes . add ( optimizeToEs6 ) ; }
if ( options.dartPass && ! options . getOutputFeatureSet () . contains ( ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
checkState ( options . getOutputFeatureSet () . contains ( FeatureSet.ES5 ) , STRING_CONSTANT ) ;
FeatureSet languageOutFeatures = compiler . getOptions () . getOutputFeatureSet () ;
FeatureSet languageOutFeatures = compiler . getOptions () . getOutputFeatureSet () ;
if ( ! options . getOutputFeatureSet () . contains ( FeatureSet.ES5 ) ) { throw new InvalidOptionsException ( STRING_CONSTANT ) ; }
{ if ( incrementalCheckMode == IncrementalCheckMode.GENERATE_IJS ) { return false ; } return this . quoteKeywordProperties || FeatureSet.ES3 . contains ( getOutputFeatureSet () ) ; }
{ return getLanguageIn () . toFeatureSet () . has ( feature ) && ! getOutputFeatureSet () . has ( feature ) ; }
{ return getLanguageIn () . toFeatureSet () . contains ( languageLevel ) && ! getOutputFeatureSet () . contains ( languageLevel ) ; }
{ checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . setLanguageOut ( language ) ; }
{ if ( outputTypes ) { return Format.TYPED ; } if ( prettyPrint || options . getOutputFeatureSet () . contains ( FeatureSet.TYPESCRIPT ) ) { return Format.PRETTY ; } return Format.COMPACT ; }
public void testNestingArrow () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testAssigningArrowToObjectLiteralField_ExpressionBody () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . compiler = compiler ; this . contextStack = new ArrayDeque <> () ; }
private LocalScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
assertThat ( compiler . getErrors () ) . isEmpty () ;
{ if ( inTypeSummary ( error ) ) { return CheckLevel.OFF ; } return null ; }
{ this . outputFeatureSet = Optional . of ( featureSet ) ; }
@ JsOverlay public final List < T > asList () { return new JsArrayList ( this ) ; }
{ asPropertyMap () . set ( key , value ) ; return this ; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es7RewriteExponentialOperator ( compiler ) ; }
FunctionScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
NormalScopeBuilder scopeBuilder = new NormalScopeBuilder ( globalScope ) ;
{ return new ModulePath ( normalize ( pathEscaper . escape ( pathResolver . apply ( path ) ) , moduleRootPaths ) ) ; }
visitImport ( t . getInput () . getPath () , n ) ;
String path = pathEscaper . escape ( moduleAddress ) ;
String path = pathEscaper . escape ( moduleAddress ) ;
private void skipOctalDigits () { while ( peekOctalDigit () ) { nextChar () ; } }
if ( ! currentInfo . hasConstAnnotation () ) { currentInfo . setConstant ( true ) ; populated = true ; return true ; } else { return false ; }
assertThat ( jsdoc . isConstant () ) . isTrue () ;
isConst = nameNode . getParent () . isConst () || isExportLhs ( nameNode ) || ( jsdoc != null && jsdoc . isConstant () )
Token type
String name
String name
return shouldDescend ( n , parent ) ;
@ Nullable JSType ownerType
{ currentModule . moduleType ( ModuleType.COMMON_JS , t , n ) ; return; }
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . googNamespaces () ) . isEmpty () ;
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
JSType ownerType
return parent == null || ! NodeUtil . createsScope ( n ) ;
final Token type
final String name
final String name
assertTypeEquals ( STRING_TYPE , info . getParameterType ( STRING_CONSTANT ) ) ;
{ JSDocInfo info = parse ( STRING_CONSTANT ) ; assertTypeEquals ( NUMBER_TYPE , info . getParameterType ( STRING_CONSTANT ) ) ; }
{ if ( expandObjectLitAssignment ( t , root , export.scope ) ) { return; } }
@ JsMethod ( namespace = STRING_CONSTANT )
{ validator . expectStringOrNumber ( t , n , rightType , STRING_CONSTANT ) ; }
return shouldDescend ( n , parent ) ;
Token type
String name
String name
@ Nullable JSType ownerType
@ JsMethod ( name = STRING_CONSTANT , namespace = STRING_CONSTANT )
@ JsMethod ( namespace = STRING_CONSTANT )
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , newMode , sourceUrl , path , sourceMapCache ) ; }
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , es6ModuleTranspiler , newMode , sourceUrl , path , sourceMapCache ) ; }
Node restRhs = newName ( this . restDeletionVarName ) ;
{ int baseHash = super . hashCode () ; if ( isSpecializedOnlyWithUnknown ) { return baseHash ; } return Objects . hash ( templateTypes , baseHash ) ; }
{ NodeTraversal . traverse ( compiler , rootNode , new CoverageInstrumentationCallback ( instrumentationData , reach ) ) ; }
abstract ImmutableMultiset.Builder < String > es6ImportSpecifiersBuilder ( ) ;
abstract ImmutableMultiset.Builder < String > requiredGoogNamespacesBuilder ( ) ;
abstract ImmutableMultiset.Builder < String > requiredTypesBuilder ( ) ;
public void testSettersForbidden2 () { mode = LanguageMode.ECMASCRIPT3 ; parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden4 () { mode = LanguageMode.ECMASCRIPT3 ; parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden3 () { mode = LanguageMode.ECMASCRIPT3 ; parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden2 () { mode = LanguageMode.ECMASCRIPT3 ; parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; mode = LanguageMode.ES_NEXT ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
testSame ( STRING_CONSTANT ) ;
validateDefaultValue ( n ) ;
options . setEs6ModuleTranspilation ( Es6ModuleTranspilation.TO_COMMON_JS_LIKE_MODULES ) ;
@ Override public boolean isVarArgsParameter ( Node parameter ) { return parameter . isRest () || parameter . isVarArgs () ; }
{ if ( ! isParsed () ) { parse ( compiler ) ; root . setInputId ( inputId ) ; } return checkNotNull ( root ) ; }
this . root = checkNotNull ( root ) ;
Node originalRoot = checkNotNull ( input . getAstRoot ( this ) ) ;
return checkNotNull ( input . getAstRoot ( this ) ) ;
findDeps . process ( checkNotNull ( input . getAstRoot ( this ) ) ) ;
Node root = checkNotNull ( input . getAstRoot ( this ) ) ;
return checkNotNull ( root ) ;
if ( ! options.checksOnly ) {}
{ matchedNodeInfo = MatchedNodeInfo . create ( node , RefactoringUtils . isInClosurizedFile ( node , new NodeMetadata ( compiler ) ) ) ; return this ; }
validateObjectPatternRest ( type , c ) ;
validateArrayPatternRest ( type , c ) ;
{ validateRestParameters ( Token.PARAM_LIST , c ) ; }
public void testForOf4 () { testTypes ( STRING_CONSTANT ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) AbstractCommandLineRunner () { this ( System.in , System.out , System.err ) ; }
boolean shouldDeclareOnGlobalThis = isGlobalVar && ( parent . isVar () || parent . isFunction () ) ;
JSType maybeThisType = info . getThisType () . evaluate ( templateScope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( templateScope , typeRegistry ) ; returnTypeInferred = false ; }
JSType maybeThisType = info . getThisType () . evaluate ( scope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( scope , typeRegistry ) ; returnTypeInferred = false ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , new GeneratorFunctionsTranspiler () ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , new GeneratorFunctionsTranspiler () ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
if ( ! compiler . hasHaltingErrors () ) { TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , features ) ; }
checkState ( source . isFunction () || source . isClass () , source ) ;
JSType returnType = getExplicitReturnTypeIfExpected ( n ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new Es6RelativizeImportPaths ( compiler ) ; }
case RELATIVIZE_IMPORT_PATHS :
SourceFile expectedEs6 = SourceFile . fromCode ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new Es6RewriteClass ( compiler ) ; }
public void testSpreadLibInjection () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; assertThat ( getLastCompiler () . injected ) . containsExactly ( STRING_CONSTANT ) ; }
{ JSType referencedType = getReferencedType () ; if ( areIdentical ( referencedType , this ) ) { handleTypeCycle ( reporter ) ; } }
if ( areIdentical ( this , that ) ) { return true ; }
public final boolean isGlobalThisType () { return areIdentical ( this , registry . getNativeType ( JSTypeNative.GLOBAL_THIS ) ) ; }
public final boolean isUnresolvedOrResolvedUnknown () { return isNoResolvedType () || ( isNamedType () && isUnknownType () ) ; }
assertSame ( objectType . getImplicitPrototype () , OBJECT_TYPE ) ;
defineVars ( n ) ;
defineVar ( n ) ;
if ( context . isAsyncContext () ) { convertAsyncFunction ( t , context ) ; }
JSType maybeThisType = info . getThisType () . evaluate ( templateScope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( templateScope , typeRegistry ) ; returnTypeInferred = false ; }
markNameProcessed ( nameNode . getQualifiedName () ) ;
{ if ( isNameProcessed ( nameNode . getQualifiedName () ) ) { return RemovalType.REMOVE_ALL ; } jsdocNode . setJSDocInfo ( getAllTypeJSDoc () ) ; return RemovalType.REMOVE_RHS ; }
NodeTraversal . traverseRootsEs6 ( compiler , new RemoveCode ( compiler ) , externs , root ) ;
