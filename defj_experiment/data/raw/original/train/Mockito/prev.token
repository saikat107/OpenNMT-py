VerifyingRecorderTest . class
stub ( mock . simpleMethod () ) . andThrows ( new RuntimeException () ) ;
state . verifyingStarted ( VerifyingMode . atLeastOnce () ) ;
VerifyingMode mode
{ return verify ( mock , VerifyingMode . times ( wantedNumberOfInvocations ) ) ; }
{ stub ( mock . simpleMethod () ) . andThrows ( null ) ; }
{ stub ( mock . simpleMethod () ) . andThrows ( new Exception () ) ; }
VerifyingModeTest . class
stub ( mock . size () ) . andThrows ( new RuntimeException () ) ;
stub ( mock . size () ) . andThrows ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . andThrows ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . andThrows ( error ) ;
stub ( reader . read () ) . andThrows ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . andThrows ( expected ) ;
assertNull ( Mockito.mockitoState . pullControlToBeStubbed () ) ;
< T > T verify ( T mock , VerifyingMode verifyingMode ) ;
assertNull ( Mockito.mockitoState . pullStubable () ) ;
MockitoStateImpl state = new MockitoStateImpl () ;
MockitoStateImplTest . class
{ mockitoState . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable ) ) ; }
public void addReturnValue ( Object value ) { mockitoState . stubbingCompleted () ; addResult ( Result . createReturnResult ( value ) ) ; }
state = new MockitoStateImpl () ;
{ MockControl < T > control = MockUtil . getControl ( mock ) ; mockitoState . stubbingStarted () ; return control ; }
mockitoState . validateState () ;
mockitoState . validateState () ;
{ MockUtil . validateMock ( mock ) ; mockitoState . verifyingStarted ( mode ) ; return mock ; }
MockControl < T > mockControl = new MockControl < T > ( mockitoState , new MatchersBinder () ) ;
verifyingRecorder . recordInvocation ( invocationMatcher ) ;
verifyingRecorder = new VerifyingRecorder < T > ( new AllInvocationsFinder () ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder ( STRING_CONSTANT ) ) ;
{ setStackTrace ( STRING_CONSTANT ) ; setCauseStackTrace ( STRING_CONSTANT ) ; remove () ; assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder () ) ; }
assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
void verify ( RegisteredInvocations registeredInvocations , InvocationMatcher wanted , OngoingVerifyingMode mode ) ;
@ Test ( expected = VerificationError . class )
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . oneArg ( true ) ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
@ Test ( expected = NumberOfInvocationsError . class )
@ Test ( expected = NumberOfInvocationsError . class )
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk () ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk () ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk () ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk () ;
verifyingRecorder = new VerifyingRecorder < T > () ;
InvocationsCalculator calculator = new InvocationsCalculatorImpl ( invocations ) ;
Invocation differentMethod = new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ;
Invocation differentMethod = new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ;
simpleMethod = new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ;
OngoingVerifyingModeTest . class
< T > T verify ( T mock , OngoingVerifyingMode ongoingVerifyingMode ) ;
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ) ;
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ) ;
OngoingVerifyingMode mode
OngoingVerifyingMode mode
OngoingVerifyingMode mode
OngoingVerifyingMode mode
OngoingVerifyingMode mode = OngoingVerifyingMode . atLeastOnce () ;
OngoingVerifyingMode mode = OngoingVerifyingMode . atLeastOnce () ;
OngoingVerifyingMode mode
OngoingVerifyingMode mode
public void reset () { stubbingInProgress = false ; ongoingVerifyingMode = null ; invocationSequenceNumber = NUMBER_CONSTANT ; }
void verify ( InvocationsCalculator calculator , InvocationMatcher wanted , OngoingVerifyingMode mode ) ;
OngoingVerifyingMode mode
{ return verify ( mock , OngoingVerifyingMode . times ( wantedNumberOfInvocations ) ) ; }
OngoingVerifyingMode mode
{ calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ; }
{ calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ; }
HasStackTrace firstUndesired = calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ;
{ if ( mode . orderOfInvocationsMatters () ) { return chunker . getFirstUnverifiedInvocationChunk ( mode . getAllMocksToBeVerifiedInSequence () ) ; } else { return registeredInvocations ; } }
public boolean orderOfInvocationsMatters () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
if ( i . isVerifiedInOrder () ) { continue; }
for ( Object mock : mocks ) { MockUtil . validateMock ( mock ) ; strictOrderVerifier . addMockToBeVerifiedInOrder ( mock ) ; }
List < Verifier > verifiers = Arrays . asList ( new MissingInvocationVerifier () , new NumberOfInvocationsVerifier () ) ;
if ( unverified != null ) { Exceptions . zeroInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
if ( unverified != null ) { Exceptions . noMoreInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
if ( ! mocksToBeVerifiedSrictly . contains ( mock ) ) { Exceptions . strictlyRequiresFamiliarMock () ; }
if ( mocks.length == NUMBER_CONSTANT ) { Exceptions . mocksHaveToBePassedWhenCreatingStrictly () ; }
if ( stubable == null ) { Exceptions . missingMethodInvocation () ; }
for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( wanted ) ) { return s . getResult () . answer () ; } }
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable ) ) ; }
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( VerificationMode . times ( NUMBER_CONSTANT ) ) ) ;
Result result
assertThat ( chunk , collectionHasExactlyInOrder ( simpleMethodInvocation , simpleMethodInvocationTwo ) ) ;
VerificationMode mode = VerificationMode . strict ( NUMBER_CONSTANT , Arrays . < Object > asList ( STRING_CONSTANT ) ) ;
strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ;
{ strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; }
{ strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
{ strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ;
strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ;
{ strictly . verify ( two , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
strictly . verify ( two , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ;
strictly . verify ( mockOne , NUMBER_CONSTANT ) . varargsObject ( NUMBER_CONSTANT , textOne , textOne ) ;
strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( textOne ) ;
verify ( mockOne , NUMBER_CONSTANT ) . varargsObject ( NUMBER_CONSTANT , textOne , textOne ) ;
verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( textOne ) ;
Mockito . verify ( mock , NUMBER_CONSTANT ) . add ( STRING_CONSTANT ) ;
{ Mockito . verify ( mock , NUMBER_CONSTANT ) . clear () ; fail () ; }
verify ( list , NUMBER_CONSTANT ) . add ( STRING_CONSTANT ) ;
verify ( mock , NUMBER_CONSTANT ) . add ( STRING_CONSTANT ) ;
verify ( map , NUMBER_CONSTANT ) . put ( anyObject () , anyObject () ) ;
verify ( mock , NUMBER_CONSTANT ) . oneArg ( two ) ;
{ return new VerificationMode ( wantedNumberOfInvocations , mocksToBeVerifiedStrictly ) ; }
assertNotNull ( STRING_CONSTANT , verifier.calculator ) ;
assertNotNull ( STRING_CONSTANT , verifierStub.calculator ) ;
assertThat ( verifierStub.calculator . getInvocations () , collectionHasExactlyInOrder ( differentMethod . getInvocation () ) ) ;
assertThat ( verifierStub.calculator . getInvocations () , collectionHasExactlyInOrder ( simpleMethod ) ) ;
verifier . verify ( calculatorStub , wanted , mode ) ;
verifier . verify ( calculatorStub , wanted , mode ) ;
void verify ( InvocationsCalculator calculator , InvocationMatcher wanted , VerificationMode mode ) ;
verifiers = Arrays . asList ( new MissingInvocationVerifier () , new NumberOfInvocationsVerifier ( new Reporter () ) , new NoMoreInvocationsVerifier () )
{ this . invocations = invocations ; return returnedByCalculator ; }
{ returnedByCalculator = null ; verifier . verify ( null , null , VerificationMode . noMoreInteractions () ) ; }
{ VerificationMode . times ( - NUMBER_CONSTANT ) ; fail () ; }
if ( mode . numberOfInvocationsMode () ) { return; }
if ( mode . isStrict () ) { markVerifiedStrictly ( invocations ) ; } else { markVerified ( wanted , invocations ) ; }
{ if ( mode . isStrict () ) { return chunker . getFirstUnverifiedInvocationChunk ( mode . getAllMocksToBeVerifiedInSequence () ) ; } else { return registeredInvocations ; } }
if ( mode . isExplicit () ) { marker . markInvocationsAsVerified ( invocations , wanted , mode ) ; }
if ( mode . isExplicit () ) { return; }
public boolean exactNumberOfInvocationsMode () { return ! atLeastOnceMode () && isExplicit () ; }
public boolean missingMethodMode () { return isExplicit () && ( atLeastOnceMode () || wantedInvocationCount == NUMBER_CONSTANT ) ; }
public boolean isExplicit () { return verification == Verification.EXPLICIT ; }
public boolean isStrict () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
public boolean atLeastOnceMode () { return wantedInvocationCount == null ; }
assertNull ( Mockito.mockingProgress . pullStubable () ) ;
if ( mocks.length == NUMBER_CONSTANT ) { reporter . mocksHaveToBePassedWhenCreatingStrictly () ; }
{ MockControl < T > control = MockUtil . getControl ( mock ) ; mockingProgress . stubbingStarted () ; return control ; }
{ MockUtil . validateMock ( mock ) ; mockingProgress . verificationStarted ( mode ) ; return mock ; }
MockControl < T > mockControl = new MockControl < T > ( mockingProgress , new MatchersBinder () ) ;
public void say ( String message ) ;
public void say ( Object message ) ;
public boolean withBooleanVarargs ( int value , boolean . . . b ) ;
public String throwsError ( int count ) throws Error ;
public String throwsIOException ( int count ) throws IOException ;
public String throwsNothing ( boolean value ) ;
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
MockControlTest . class
@ Test ( expected = MockitoException . class ) public void shouldScreamWhenNullPassed () { getControl ( null ) ; }
@ Test ( expected = NotAMockException . class ) public void shouldScreamWhenNotAMockPassed () { getControl ( STRING_CONSTANT ) ; }
try { getControl ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List < Invocation > invocationsOfSingleMock = MockUtil . getControl ( mock ) . getRegisteredInvocations () ; allInvocations . addAll ( invocationsOfSingleMock ) ; }
for ( Object mock : mocks ) { MockUtil . getControl ( mock ) . verifyNoMoreInteractions () ; }
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( VerificationError e ) {}
{ mock . clear () ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {} }
{ mock . clear () ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {} }
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
VerificationError e
VerificationError e
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
{ UndesiredInvocation cause = buildUndesiredInvocationCause ( actualInvocationStackTrace , STRING_CONSTANT , undesired ) ; throw new VerificationError ( join ( STRING_CONSTANT ) , cause ) ; }
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError expected ) {}
Invocation actual = calculator . findActualInvocation ( invocations , wanted ) ;
int actualCount = calculator . countActual ( invocations , wanted ) ;
public MissingInvocationVerifier () { this ( new InvocationsCalculator () , new Reporter () ) ; }
Invocation unverified = calculator . getFirstUnverified ( invocations ) ;
public NoMoreInvocationsVerifier () { this ( new InvocationsCalculator () , new Reporter () ) ; }
{ verifier . verify ( invocations , wanted , times ( NUMBER_CONSTANT ) ) ; assertSame ( wanted , calculatorStub.wanted ) ; }
@ Test public void shouldPassBecauseActualInvocationFound () { calculatorStub.actualCountToReturn = NUMBER_CONSTANT ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
{ calculator.invocationToReturn = null ; verifier . verify ( null , null , VerificationMode . noMoreInteractions () ) ; }
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsCalculator () ) ; }
return actualbyName != null ? actualbyName : getFirstUnverified ( invocations ) ;
Invocation unverified = analyzer . getFirstUnverified ( invocations ) ;
{ verify ( sub ) . say ( CrazyMatchers . contains ( STRING_CONSTANT ) ) ; fail () ; }
mockingProgress . reportStubable ( this ) ;
OngoingStubbing pullStubable ( ) ;
void reportStubable ( OngoingStubbing ongoingStubbing ) ;
VerificationModeTest . class
VerificationMode mode
state . verificationStarted ( VerificationMode . atLeastOnce () ) ;
VerificationMode verificationMode = mockingProgress . pullVerificationMode () ;
VerificationMode mode
VerificationMode mode = new VerificationModeBuilder () . strict () ;
VerificationMode mode = new VerificationModeBuilder () . strict () ;
VerificationMode mode
public void verify ( VerificationMode mode ) { verify ( null , mode ) ; }
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationMode mode ) ;
verifier . verify ( invocations , wanted , VerificationMode . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationMode . atLeastOnce () ) ;
verifier . verify ( invocations , null , VerificationMode . noMoreInteractions () ) ;
{ return VerificationMode . times ( wantedNumberOfInvocations ) ; }
{ return VerificationMode . atLeastOnce () ; }
VerificationMode mode = VerificationMode . times ( NUMBER_CONSTANT ) ;
VerificationMode mode
{ analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ; }
{ analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ; }
HasStackTrace firstUndesired = analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ;
VerificationMode mode
VerificationMode mode
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode
VerificationMode mode
{ VerificationMode mode = VerificationMode . noMoreInteractions () ; recorder . verify ( mode ) ; assertNull ( markerStub.mode ) ; }
VerificationMode mode = new VerificationModeBuilder () . strict () ;
VerificationMode mode = VerificationMode . atLeastOnce () ;
VerificationMode mode = VerificationMode . atLeastOnce () ;
VerificationMode mode
public MissingInvocationVerifier () { this ( new InvocationsAnalyzer () , new Reporter () ) ; }
{ setStackTrace ( STRING_CONSTANT ) ; setCauseStackTrace ( STRING_CONSTANT ) ; remove () ; assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder () ) ; }
three . simpleMethod () ;
public VerificationModeImpl strict () { return VerificationModeImpl . strict ( null , Arrays . asList ( new Object () ) ) ; }
assertEquals ( verifierStub.mode , mode ) ;
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsAnalyzer () ) ; }
{ analyzerStub.actualCountToReturn = NUMBER_CONSTANT ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
catch ( TooLittleActualInvocationsError e ) {}
StackTrackeFilteringTest . class
{ Mockito . verify ( mock , times ( NUMBER_CONSTANT ) ) . clear () ; fail () ; }
@ Before public void setup () { mock = Mockito . mock ( LinkedList . class ) ; }
catch ( TooLittleActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
VerificationError e
TooManyActualInvocationsError e
TooLittleActualInvocationsError e
try { verify ( mock ) . oneArg ( same ( three ) ) ; fail () ; } catch ( VerificationError e ) {}
@ Test ( expected = TooLittleActualInvocationsError . class )
VerificationError e
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockTwo ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
catch ( TooManyActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocationsError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerificationError e ) {}
catch ( NoInteractionsWantedError e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWantedError e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
try { verifyNoMoreInteractions ( mockTwo ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
catch ( TooManyActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
@ Test ( expected = VerificationError . class )
catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
@ Test ( expected = VerificationError . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = VerificationError . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
catch ( TooLittleActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
@ Test ( expected = TooLittleActualInvocationsError . class )
@ Test ( expected = TooManyActualInvocationsError . class )
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
VerificationError error
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
{ mock . clear () ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {} }
{ mock . clear () ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {} }
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
catch ( TooManyActualInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooManyActualInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooLittleActualInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
throw new NoInteractionsWantedError ( join ( STRING_CONSTANT ) , cause ) ;
public void wantedButNotInvoked ( String wanted ) { throw new VerificationError ( join ( STRING_CONSTANT , wanted ) ) ; }
throw new VerificationError ( join ( STRING_CONSTANT , STRING_CONSTANT , wanted ) , cause ) ;
wantedInvocation . matchesMockArgsAndMethodNameButMethodNotEqual ( actualInvocation )
try { verify ( mock ) . clear () ; fail () ; } catch ( TooManyActualInvocationsError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationError expected ) {}
@ Test ( expected = VerificationError . class ) public void shouldFailVerification ( ) throws Exception { verify ( mock ) . clear () ; }
catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
try { strictly . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
@ Test ( expected = VerificationError . class )
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
TooLittleActualInvocationsError e
TooManyActualInvocationsError e
TooManyActualInvocationsError e
VerificationError e
VerificationError e
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
NoInteractionsWantedError e
NoInteractionsWantedError e
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
VerificationError e
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooManyActualInvocations e ) {}
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocations e ) {}
try { strictly . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
chunked = chunker . chunk ( Collections . < Integer > emptyList () , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
List < ObjectsChunk < Integer > > chunked = chunker . chunk ( asList ( NUMBER_CONSTANT ) , new EqualitySeer () ) ;
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
@ Test ( expected = InvocationDiffersFromActual . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = InvocationDiffersFromActual . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooLittleActualInvocations e ) {}
@ Test ( expected = TooLittleActualInvocations . class )
@ Test ( expected = TooManyActualInvocations . class )
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
strictly . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ;
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsAnalyzer () , new ActualInvocationsFinder () ) ; }
public boolean strictMode () { return ! mocksToBeVerifiedStrictly . isEmpty () ; }
Invocation unverified = analyzer . findFirstUnverified ( invocations ) ;
public NoMoreInvocationsVerifier () { this ( new InvocationsAnalyzer () , new Reporter () ) ; }
{ Invocation similar = analyzer . findSimilarInvocation ( invocations , wanted , mode ) ; reportMissingInvocationError ( wanted , similar ) ; }
public MissingInvocationVerifier () { this ( new InvocationsAnalyzer () , new ActualInvocationsFinder () , new Reporter () ) ; }
List < Invocation > chunk = finder . findFirstStrictlyUnverified ( invocations , wanted ) ;
List < Invocation > chunk = finder . findFirstStrictlyUnverified ( invocations , wanted ) ;
{ analyzer.invocationToReturn = null ; verifier . verify ( null , null , VerificationModeImpl . noMoreInteractions () ) ; }
analyzerStub.similarToReturn = actualInvocation ;
analyzerStub.similarToReturn = null ;
{ verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ; assertSame ( invocations , analyzerStub.invocations ) ; }
finderStub = new ActualInvocationsFinderStub () ;
ActualInvocationsFinder finder
public MissingInvocationVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
ActualInvocationsFinder finder
public StrictlyNumberOfInvocationsVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
ActualInvocationsFinder finder
public StrictlyMissingInvocationVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
if ( mode . strictMode () ) { invocations = invocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedStrictly () ) ; } else { invocations = registeredInvocations ; }
ActualInvocationsFinder finder
public NoMoreInvocationsVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
ActualInvocationsFinder finder
public NumberOfInvocationsVerifier () { this ( new Reporter () , new ActualInvocationsFinder () ) ; }
finderStub = new ActualInvocationsFinderStub () ;
finder = new ActualInvocationsFinderStub () ;
List < Object > mocksToBeVerifiedStrictly
List < Object > mocksToBeVerifiedStrictly
HasStackTrace lastInvocation = getLastSafely ( chunk ) ;
HasStackTrace lastInvocation = getLastSafely ( actualInvocations ) ;
stub ( mock . oneArg ( anyString () ) ) . andReturn ( STRING_CONSTANT ) ;
mockingProgress . reportStubbable ( this ) ;
{ stub ( mock . simpleMethod () ) . andThrow ( null ) ; }
{ stub ( mock . simpleMethod () ) . andThrow ( new Exception () ) ; }
stub ( mock . booleanReturningMethod ( NUMBER_CONSTANT ) ) . andReturn ( true ) ;
OngoingStubbing pullStubbable ( ) ;
void reportStubbable ( OngoingStubbing ongoingStubbing ) ;
return handler ;
stub ( mock . simpleMethod () ) . andThrow ( new RuntimeException () ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . andReturn ( Boolean.FALSE ) ;
stub ( mock . size () ) . andThrow ( new RuntimeException () ) ;
stub ( mock . size () ) . andThrow ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( error ) ;
stub ( reader . read () ) . andThrow ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( expected ) ;
{ Strictly strictly = createStrictOrderVerifier ( mock ) ; strictly . verify ( null ) ; fail () ; }
{ createStrictOrderVerifier () ; fail () ; }
Strictly strictly = createStrictOrderVerifier ( mock ) ;
{ Strictly strictly = createStrictOrderVerifier ( mock ) ; strictly . verify ( mockTwo ) . simpleMethod () ; }
@ Test ( expected = MockitoException . class ) public void shouldNotCreateStrictlyWithoutMocks () { createStrictOrderVerifier () ; }
strictly = createStrictOrderVerifier ( mock , mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockDatabase ) ;
strictly = createStrictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
strictly = createStrictOrderVerifier ( mockOne ) ;
strictly = createStrictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
strictly = createStrictOrderVerifier ( mock , mockTwo ) ;
strictly = createStrictOrderVerifier ( one , two , three ) ;
strictly = createStrictOrderVerifier ( mockOne ) ;
strictly = createStrictOrderVerifier ( mockOne ) ;
strictly = createStrictOrderVerifier ( mockOne , mockThree ) ;
strictly = createStrictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mock ) ;
Object argument
Object actual
{ for ( IArgumentMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < IArgumentMatcher > matchers ) { this . matchers = matchers ; }
public Not ( IArgumentMatcher first ) { this . first = first ; }
{ for ( IArgumentMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < IArgumentMatcher > matchers ) { this . matchers = matchers ; }
List < IArgumentMatcher > matchers
public void reportMatcher ( IArgumentMatcher matcher ) { matcherStack . push ( matcher ) ; }
List < IArgumentMatcher > matchers
List < IArgumentMatcher > matchers
return findFirstUnverified ( invocations , wanted . getInvocation () . getMock () ) ;
{ return LastArguments . instance () . reportMatcher ( matcher ) . < T > nullValue () ; }
{ return LastArguments . instance () . reportMatcher ( new StartsWith ( prefix ) ) . < String > nullValue () ; }
public static String anyString () { isA ( String . class ) ; return null ; }
{ return reportMatcher ( matcher ) . < T > nullValue () ; }
public static double doubleThat ( CustomMatcher < Double > matcher ) { return reportMatcher ( matcher ) . doubleValue () ; }
public static float floatThat ( CustomMatcher < Float > matcher ) { return reportMatcher ( matcher ) . floatValue () ; }
public static long longThat ( CustomMatcher < Long > matcher ) { return reportMatcher ( matcher ) . longValue () ; }
public static int intThat ( CustomMatcher < Integer > matcher ) { return reportMatcher ( matcher ) . intValue () ; }
public static short shortThat ( CustomMatcher < Short > matcher ) { return reportMatcher ( matcher ) . shortValue () ; }
public static byte byteThat ( CustomMatcher < Byte > matcher ) { return reportMatcher ( matcher ) . byteValue () ; }
public static boolean booleanThat ( CustomMatcher < Boolean > matcher ) { return reportMatcher ( matcher ) . booleanValue () ; }
public static char charThat ( CustomMatcher < Character > matcher ) { return reportMatcher ( matcher ) . charValue () ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . < String > nullValue () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . < String > nullValue () ; }
{ return reportMatcher ( new Matches ( regex ) ) . < String > nullValue () ; }
{ return reportMatcher ( new Contains ( substring ) ) . < String > nullValue () ; }
public static Object notNull () { return reportMatcher ( NotNull.NOT_NULL ) . nullValue () ; }
public static Object isNull () { return reportMatcher ( Null.NULL ) . nullValue () ; }
{ return reportMatcher ( new Same ( value ) ) . nullValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . nullValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . shortValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . longValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . intValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . floatValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . doubleValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . charValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . byteValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . booleanValue () ; }
{ return reportMatcher ( new InstanceOf ( clazz ) ) . nullValue () ; }
public static Object anyObject () { return reportMatcher ( Any.ANY ) . nullValue () ; }
public static short anyShort () { return reportMatcher ( Any.ANY ) . shortValue () ; }
public static double anyDouble () { return reportMatcher ( Any.ANY ) . doubleValue () ; }
public static float anyFloat () { return reportMatcher ( Any.ANY ) . floatValue () ; }
public static long anyLong () { return reportMatcher ( Any.ANY ) . longValue () ; }
public static int anyInt () { return reportMatcher ( Any.ANY ) . intValue () ; }
public static char anyChar () { return reportMatcher ( Any.ANY ) . charValue () ; }
public static byte anyByte () { return reportMatcher ( Any.ANY ) . byteValue () ; }
public static boolean anyBoolean () { return reportMatcher ( Any.ANY ) . booleanValue () ; }
public boolean booleanValue () { return false ; }
public < T > T nullValue () { return null ; }
public short shortValue () { return NUMBER_CONSTANT ; }
public byte byteValue () { return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return false ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return first ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return null ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return first ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return null ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return false ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return null ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return false ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnChar () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnNull () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnFalse () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnNull () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnChar () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnFalse () ; }
{ return reportMatcher ( new Same ( value ) ) . returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new InstanceOf ( clazz ) ) . returnNull () ; }
{ return LastArguments . instance () . reportNot () . returnNull () ; }
{ return LastArguments . instance () . reportOr () . returnNull () ; }
{ return LastArguments . instance () . reportAnd () . returnNull () ; }
{ return reportMatcher ( new Find ( regex ) ) . returnNull () ; }
detects ( new OnStrictVerify () , UnfinishedVerificationException . class ) ;
detects ( new OnStrictVerify () , UnfinishedStubbingException . class ) ;
detects ( new OnStrictVerify () , UnfinishedStubbingException . class ) ;
assertFalse ( strict ( NUMBER_CONSTANT , asList ( new Object () ) ) . exactNumberOfInvocationsMode () ) ;
strictly = strictly ( mock , mockTwo ) ;
List < Invocation > unverified = ListUtil . filter ( invocations , new RemoveVerifiedStrictly () ) ;
strictly = strictly ( mock , mockTwo ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ;
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
@ Test ( expected = InvocationDiffersFromActual . class )
@ Override public void wantedButNotInvoked ( String wanted ) { this . wanted = wanted ; }
finderStub.firstUnverifiedChunkToReturn . add ( invocation ) ;
finderStub.firstUnverifiedChunkToReturn . addAll ( asList ( first , second ) ) ;
finderStub.firstUnverifiedChunkToReturn . addAll ( asList ( first , second ) ) ;
finderStub.firstUnverifiedChunkToReturn . add ( differentMethod ) ;
assertTrue ( finderStub.firstUnverifiedChunkToReturn . isEmpty () ) ;
catch ( VerifcationInOrderFailed e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
@ Test ( expected = VerifcationInOrderFailed . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { inOrder . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = VerifcationInOrderFailed . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
@ Test ( expected = VerifcationInOrderFailed . class )
@ Override public void wantedButNotInvoked ( Object wanted ) { this . wanted = wanted ; }
assertEquals ( wanted . toString () , reporterStub.wanted ) ;
{ reporter . wantedButNotInvoked ( wanted . toString () ) ; }
@ Override public void wantedButNotInvoked ( Object wanted ) { this . wanted = wanted ; }
Object wanted
List < Invocation > chunk = finder . findValidMatchingChunk ( invocations , wanted , mode ) ;
Object wanted
public void wantedButNotInvoked ( Object wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted . toString () ) ) ; }
Object previous
String undesired
assertEquals ( firstUnverified . toString () , reporterStub.undesired ) ;
if ( unverified != null ) { reporter . noMoreInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
String wanted
String wanted
assertEquals ( wanted . toString () , reporterStub.wanted ) ;
assertEquals ( wanted . toString () , reporterStub.wanted ) ;
Object previous
Invocation previousInOrder = finder . findPreviousInOrder ( invocations , wanted ) ;
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
@ Test ( expected = VerifcationInOrderFailed . class )
@ Test ( expected = VerifcationInOrderFailed . class )
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
@ Test ( expected = VerifcationInOrderFailed . class )
catch ( VerifcationInOrderFailed e ) {}
@ Test ( expected = VerifcationInOrderFailed . class )
try { inOrder . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
public String printActual () { return actual ; }
public String printWanted () { return wanted ; }
stub ( mockCalculator . countArticlesInPolish ( STRING_CONSTANT ) ) . toReturn ( NUMBER_CONSTANT ) ;
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { REPORTER . mocksHaveToBePassedAsArguments () ; } }
CustomMatcher < T > matcher
List < ArgumentMatcher > matchers
public Not ( ArgumentMatcher first ) { this . first = first ; }
List < ArgumentMatcher > matchers
{ for ( ArgumentMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
T actual
List < ArgumentMatcher > matchers
{ for ( ArgumentMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
private static ReturnValues reportMatcher ( ArgumentMatcher < > matcher ) { return LastArguments . instance () . reportMatcher ( matcher ) ; }
CustomMatcher < Double > matcher
CustomMatcher < Float > matcher
CustomMatcher < Long > matcher
CustomMatcher < Integer > matcher
CustomMatcher < Short > matcher
CustomMatcher < Byte > matcher
CustomMatcher < Boolean > matcher
CustomMatcher < Character > matcher
public ReturnValues reportMatcher ( ArgumentMatcher matcher ) { matcherStack . push ( matcher ) ; return new ReturnValues () ; }
catch ( TooManyActualInvocations e ) {}
catch ( TooManyActualInvocations e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
if ( mode . wantedCountIsZero () && noMatchFound ) { return; }
InvocationDiffersFromActual e
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual expected ) {}
@ Test ( expected = InvocationDiffersFromActual . class )
@ Test ( expected = InvocationDiffersFromActual . class )
@ Test ( expected = InvocationDiffersFromActual . class )
@ Test ( expected = InvocationDiffersFromActual . class )
catch ( InvocationDiffersFromActual e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
IncorectBindingPuzzleFixedTest . class
Printable undesired
@ Override public void wantedButNotInvoked ( Printable wanted ) { this . wanted = wanted ; }
Printable wanted
Printable wanted
Printable wanted
@ Override public void wantedButNotInvoked ( Printable wanted ) { this . wanted = wanted ; }
Printable undesired
Printable wanted
Printable wanted
Printable wanted
Printable wanted
Printable wanted
public void wantedButNotInvoked ( Printable wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted . toString () ) ) ; }
if ( matchers == null ) { this . matchers = buildMatchers ( invocation ) ; } else { this . matchers = matchers ; }
mock . simpleMethod ( null , null ) ;
argumentsMatch ( actual . getArguments () )
ArgumentsAreDifferentException e
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( ArgumentsAreDifferentException expected ) {}
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
catch ( ArgumentsAreDifferentException e ) {}
catch ( ArgumentsAreDifferentException e ) {}
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferentException e
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferentException e
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferentException e
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferentException e
assertTrue ( invocation . isSimilarTo ( overloadedInvocation ) ) ;
assertFalse ( invocation . isSimilarTo ( overloadedInvocation ) ) ;
assertFalse ( simpleMethod . isSimilarTo ( onDifferentMock ) ) ;
assertFalse ( simpleMethod . isSimilarTo ( verified ) ) ;
assertTrue ( STRING_CONSTANT + value . getMessage () + STRING_CONSTANT + text , cause . getMessage () . contains ( text ) ) ;
invocation . getMock () . equals ( actual . getMock () ) && invocation . getMethod () . equals ( actual . getMethod () ) && argumentsMatch ( actual )
assertTrue ( STRING_CONSTANT + value . getMessage () + STRING_CONSTANT + text , ( ( Throwable ) value ) . getMessage () . contains ( text ) ) ;
assertThat ( mock . toString () , equalTo ( STRING_CONSTANT ) ) ;
assertThat ( mock . toString () , equalTo ( STRING_CONSTANT ) ) ;
if ( verificationMode != null ) { verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return EmptyReturnValues . emptyValueFor ( method . getReturnType () ) ; }
if ( mode . inOrderMode () ) { invocations = globalInvocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedInOrder () ) ; } else { invocations = registeredInvocations ; }
EmptyReturnValuesTest . class
if ( verificationMode != null ) { verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . emptyValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
return MockitoConfiguration . emptyValues () . valueFor ( invocation ) ;
MockitoSampleTest . class
@ After public void resetDefaultReturnValues () { MockitoConfiguration . resetCustomReturnValues () ; myDefaultReturnValues . clearSmartStubs () ; }
return MockitoConfiguration . defaultReturnValues () . valueFor ( invocation ) ;
@ Before public void configureDefaultReturnValues () { MockitoConfiguration . setCustomReturnValues ( new MyDefaultReturnValues () ) ; }
{ verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . defaultReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
@ Before public void configureDefaultReturnValues () { myDefaultReturnValues = new MyDefaultReturnValues () ; MockitoConfiguration . setCustomReturnValues ( myDefaultReturnValues ) ; }
invocation . isToString ()
Invocation invocation
Invocation invocation
Invocation invocation
Invocation invocation
return emptyValueFor ( returnType ) ;
assertEquals ( CHAR_CONS , mock . charReturningMethod ( NUMBER_CONSTANT ) ) ;
{ FakeReturnValues fakeReturnValues = getFakeReturnValues () ; fakeReturnValues . configure ( mocks ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
String mockDescription = STRING_CONSTANT + MockNamer . nameForMock ( mock ) + STRING_CONSTANT + mock . hashCode () ;
{ return MockUtil . createMock ( classToMock , MOCKING_PROGRESS ) ; }
assertThat ( m . getMatchers () , collectionHasExactlyInOrder ( new Equals ( STRING_CONSTANT ) ) ) ;
assertThat ( STRING_CONSTANT , e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ;
assertThat ( verifierStub.invocations , collectionHasExactlyInOrder ( simpleMethod , differentMethod . getInvocation () ) ) ;
assertThat ( verifierStub.invocations , collectionHasExactlyInOrder ( simpleMethod ) ) ;
MockHandler handler = new MockHandler ( state , new ExceptionThrowingBinder () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
{ f . set ( testClass , Mockito . mock ( f . getType () ) ) ; }
assertThat ( filtered , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
stub ( mock . oneArg ( not ( contains ( STRING_CONSTANT ) ) ) ) . toReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( and ( contains ( STRING_CONSTANT ) , contains ( STRING_CONSTANT ) ) ) ) . toReturn ( STRING_CONSTANT ) ;
try { getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List mock = Mockito . mock ( List . class ) ; assertNotNull ( getMockHandler ( mock ) ) ; }
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( mode . inOrderMode () ) { invocations = globalInvocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedInOrder () ) ; } else { invocations = getRegisteredInvocations () ; }
{ return Modifier . isFinal ( clazz . getModifiers () ) ; }
{ if ( mocksReturningFakes . contains ( invocation . getMock () ) ) { return returnFake ( invocation ) ; } else { return defaultValueFor ( invocation ) ; } }
{ super . run ( notifier ) ; MockitoConfiguration . instance () . resetReturnValues () ; }
{ Object test = super . createTest () ; MockitoConfiguration . instance () . setReturnValues ( new FriendlyReturnValues () ) ; return test ; }
{ verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . instance () . getReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
return MockitoConfiguration . instance () . getReturnValues () . valueFor ( invocation ) ;
MockitoConfiguration config = MockitoConfiguration . instance () ;
{ super ( invocation . getInvocation () , invocation . getMatchers () ) ; this . result = result ; }
private Result ( IAnswer value ) { this . value = value ; }
public void addConsecutiveReturnValue ( Object value ) { stubbed . getFirst () . addResult ( Result . createReturnResult ( value ) ) ; }
ResultTest . class
{ validateThrowable ( throwable ) ; stubbed . getFirst () . addAnswer ( Result . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
Result result
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
Answer result = AnswerFactory . createThrowResult ( new RuntimeException () , filterStub ) ;
{ AnswerFactory . createThrowResult ( new RuntimeException () , new StackTraceFilter () ) . answer () ; }
{ Answer result = AnswerFactory . createReturnResult ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
{ validateThrowable ( throwable ) ; stubbed . getFirst () . addAnswer ( AnswerFactory . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( AnswerFactory . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
assertEquals ( null , mock . oneArg ( null ) ) ;
assertEquals ( null , mock . oneArg ( null ) ) ;
public String toString () { return toString ( argumentsToMatchers () ) ; }
{ Answer result = AnswerFactory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
{ return isA ( String . class ) ; }
Answer answer = AnswerFactory . createReturningAnswer ( value ) ;
for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) { return s . answer () ; } }
{ result . answer () ; fail () ; }
{ factory . createThrowingAnswer ( new RuntimeException () , null ) . answer () ; }
{ Answer result = factory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , not ( notNull () ) , eq ( STRING_CONSTANT ) ) ) . toReturn ( STRING_CONSTANT ) ;
Answer < T > answer
Answer < T > answer
Answer < T > answer
{ stubber . addConsecutiveThrowable ( throwable ) ; return this ; }
{ stubber . addConsecutiveReturnValue ( value ) ; return this ; }
Answer < T > answer
{ verifyingRecorder . eraseLastInvocation () ; stubber . addThrowable ( throwable ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addReturnValue ( value ) ; return new ConsecutiveStubbing () ; }
{ stubber . addThrowableForVoidMethod ( throwable ) ; return this ; }
{ try { stubber . addThrowable ( null ) ; fail () ; } catch ( MockitoException e ) {} }
stubber . addReturnValue ( STRING_CONSTANT ) ;
{ state . stubbingStarted () ; stubber . addReturnValue ( STRING_CONSTANT ) ; state . validateState () ; }
{ stubber . addThrowable ( new Exception () ) ; fail () ; }
public void setMock ( Object mock ) {}
ClassWithDodgyConstructor mock = factory . createMock ( ClassWithDodgyConstructor . class , new MockAwareStub () ) ;
ClassWithoutConstructor proxy = factory . createMock ( ClassWithoutConstructor . class , new MockAwareStub () ) ;
SomeInterface proxy = factory . createMock ( SomeInterface . class , new MockAwareStub () ) ;
{ return MockUtil . createMock ( classToMock , null , MOCKING_PROGRESS ) ; }
return delegate . intercept ( proxy , method , args , null ) ;
try { stubber . resultFor ( simpleMethod ) ; fail () ; } catch ( MyException e ) {}
stubber = new Stubber ( mockingProgress ) ;
void setMock ( T mock ) ;
@ Before public void setUp () { StateResetter . reset () ; mock = Mockito . mock ( IMethods . class ) ; }
{ StateResetter . reset () ; mock = mock ( IMethods . class ) ; }
{ MOCKING_PROGRESS . stubbingStarted () ; return new MethodSelectorImpl ( null ) ; }
{ MOCKING_PROGRESS . stubbingStarted () ; return new MethodSelectorImpl ( toBeReturned ) ; }
{ doReturn ( STRING_CONSTANT ) . when ( null ) . toString () ; fail () ; }
{ stubber . addConsecutiveAnswer ( answer ) ; return this ; }
{ stubber . addConsecutiveAnswer ( new ThrowsException ( throwable ) ) ; return this ; }
{ stubber . addConsecutiveAnswer ( new Returns ( value ) ) ; return this ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( new ThrowsException ( throwable ) ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( new Returns ( value ) ) ; return new ConsecutiveStubbing () ; }
{ stubber . addAnswerForVoidMethod ( answer ) ; return this ; }
public VoidMethodStubbable < T > toReturn () { stubber . addAnswerForVoidMethod ( new Returns () ) ; return this ; }
{ stubber . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
this . stubber = new Stubber ( mockingProgress ) ;
return handler . voidMethodStubbable () ;
@ SuppressWarnings ( STRING_CONSTANT ) public void setAnswersForStubbing ( List < Answer > answers ) { mockitoStubber . addAnswersForVoidMethod ( answers ) ; }
try { mockitoStubber . addVoidMethodForStubbing ( new InvocationMatcher ( simpleMethod ) ) ; fail () ; } catch ( MockitoException e ) {}
mockitoStubber . addVoidMethodForStubbing ( new InvocationMatcher ( simpleMethod ) ) ;
{ return MockUtil . createMock ( classToMock , name , MOCKING_PROGRESS , null ) ; }
{ validator . validate ( new ReturnsVoid () , new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ; }
{ validator . validate ( new ReturnsVoid () , new InvocationBuilder () . simpleMethod () . toInvocation () ) ; }
ReturnsVoid answer
doReturn () . doReturn () . doThrow ( new RuntimeException () ) . when ( mock ) . voidMethod () ;
Stubber doReturn ( ) ;
if ( answer instanceof DoesNothing ) { validateVoidReturn ( ( DoesNothing ) answer , invocation ) ; }
detects ( new OnDoReturn () , UnfinishedVerificationException . class ) ;
detects ( new OnDoReturn () , UnfinishedStubbingException . class ) ;
detects ( new OnDoReturn () , UnfinishedStubbingException . class ) ;
enhancer . setClassLoader ( MockFactory . class . getClassLoader () ) ;
AtLeastOnceVerificationTest . class
try { mockitoStubber . getResultFor ( simpleMethod ) ; fail () ; } catch ( MyException e ) {}
Invocation invocation
mockingProgress . reportOngoingStubbing ( new OngoingStubbingImpl () ) ;
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
mode . atLeastOnceMode () || ! mode . matchesActualCount ( firstChunk . size () )
public boolean neverWanted () { return ! atLeastOnceMode () && wantedInvocationCount == NUMBER_CONSTANT ; }
public boolean tooManyActualInvocations ( int actualCount ) { return ! atLeastOnceMode () && wantedInvocationCount < actualCount ; }
public boolean tooLittleActualInvocations ( int actualCount ) { return ! atLeastOnceMode () && wantedInvocationCount > actualCount ; }
public boolean missingMethodMode () { return explicitMode () && ( atLeastOnceMode () || wantedInvocationCount > NUMBER_CONSTANT ) ; }
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new VerificationModeImpl ( wantedNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.EXPLICIT ) ; }
stub ( mock . size () ) . toThrow ( new RuntimeException () ) ;
stub ( mock . size () ) . toThrow ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( error ) ;
stub ( reader . read () ) . toThrow ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( expected ) ;
stub ( mockTwo . toString () ) . toReturn ( STRING_CONSTANT ) ;
stub ( mock . booleanReturningMethod () ) . toReturn ( true ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . toReturn ( Boolean.FALSE ) ;
{ stub ( mock . simpleMethod () ) . toThrow ( null ) ; }
{ stub ( mock . simpleMethod () ) . toThrow ( new Exception () ) ; }
Mockito . stub ( mock . add ( STRING_CONSTANT ) ) . toReturn ( true ) ;
stub ( mock . simpleMethod () ) . toThrow ( new RuntimeException () ) ;
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new DeprecatedConsecutiveStubbing () ; }
mockingProgress . reportOngoingStubbing ( new DeprecatedOngoingStubbingImpl () ) ;
stub ( mock . oneArg ( anyString () ) ) . toReturn ( STRING_CONSTANT ) ;
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( ArgumentsAreDifferent expected ) {}
{ HasStackTrace lastInvocation = finder . getLastStackTrace ( actualInvocations ) ; reporter . tooLittleActualInvocationsInAtLeastMode ( mode . minimumCount () , actualCount , wanted , lastInvocation ) ; }
if ( mode . explicitMode () ) { return; }
boolean atLeast = atLeastMode () && actualCount >= minInvocationCount ;
public boolean exactNumberOfInvocationsMode () { return ! inOrderMode () && explicitMode () ; }
public static VerificationModeImpl noMoreInteractions () { return new VerificationModeImpl ( null , null , Collections . emptyList () , Verification.NO_MORE_WANTED ) ; }
MockFactoryTest . class
@ Test public void shouldNeverVerifyWhenVerificationIsInAtLeastMode ( ) throws Exception { verifier . verify ( null , null , VerificationModeImpl . atLeastOnce () ) ; }
@ Test public void shouldNeverVerifyWhenVerificationIsExplicit ( ) throws Exception { verifier . verify ( null , null , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ; }
mode . atLeastMode ()
mode . inOrderMode ()
VerificationModeImpl mode
public void verify ( VerificationModeImpl mode ) { verify ( null , mode ) ; }
VerificationModeImpl verificationMode = mockingProgress . pullVerificationMode () ;
VerificationModeImpl atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = atLeastOnce () ;
public VerificationModeDecoder ( VerificationModeImpl mode ) { this . mode = mode ; }
VerificationModeImpl mode = VerificationModeImpl . times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode
VerificationModeImpl mode
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationModeImpl mode ) ;
VerificationModeImpl mode
public boolean appliesTo ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) . missingMethodMode () ; }
VerificationModeImpl mode
public boolean appliesTo ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) . missingMethodInOrderMode () ; }
VerificationModeImpl mode
VerificationModeImpl inOrderMode = new VerificationModeBuilder () . inOrder () ;
VerificationModeImpl mode = VerificationModeImpl . atLeastOnce () ;
VerificationModeImpl mode = atLeastOnce () ;
private VerificationModeDecoder decode ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) ; }
VerificationModeImpl mode
public boolean appliesTo ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) . inOrderMode () ; }
VerificationModeImpl mode
public boolean appliesTo ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) . exactNumberOfInvocationsMode () ; }
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new VerificationModeImpl ( minNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.AT_LEAST ) ; }
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new VerificationModeImpl ( wantedNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.EXPLICIT ) ; }
verifyingRecorder = createRecorder () ;
state . verificationStarted ( VerificationModeImpl . atLeastOnce () ) ;
VerificationMode atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedDifferentMethod ) , atLeastOnce () ) ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedSimpleMethod ) , atLeastOnce () ) ;
VerificationMode mode
VerificationMode mode
verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
VerificationMode mode = atLeastOnce () ;
VerificationMode mode = VerificationModeImpl . times ( NUMBER_CONSTANT ) ;
public VerificationModeDecoder ( VerificationMode mode ) { this . mode = mode ; }
verifier . verify ( invocations , wanted , atLeastOnce () ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode
VerificationMode mode
VerificationModeImplTest . class
{ return VerificationModeImpl . atLeast ( minNumberOfInvocations ) ; }
{ return VerificationModeImpl . atLeastOnce () ; }
{ return VerificationModeImpl . times ( wantedNumberOfInvocations ) ; }
private VerificationModeDecoder decode ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) ; }
{ mode . verify ( getRegisteredInvocations () , wanted ) ; }
@ Override public InvocationMatcher getWanted () { return wanted ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . < String > returnNull () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . < String > returnNull () ; }
{ return reportMatcher ( new Matches ( regex ) ) . < String > returnNull () ; }
{ return reportMatcher ( new Contains ( substring ) ) . < String > returnNull () ; }
{ return ( Collection ) anyObject () ; }
{ return ( Map ) anyObject () ; }
{ return ( List ) anyObject () ; }
{ return ( String ) anyObject () ; }
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ; }
{ missingInvocation . verify ( data . getAllInvocations () , data . getWanted () , this ) ; }
@ Override public String toString () { return STRING_CONSTANT + wantedCount () + STRING_CONSTANT + mocksToBeVerifiedInOrder ; }
AtLeastXVerificationTest . class
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
verifyingRecorder = new VerifyingRecorder () ;
{ VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getVerifiableInvocations () , null ) ; VerificationModeFactory . noMoreInteractions () . verify ( data ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getVerifiableInvocations () , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
VerifyingRecorderTest . class
if ( ! ( mode instanceof VerificationInOrderMode ) ) { throw new MockitoException ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) {}
catch ( MockitoAssertionError e ) {}
catch ( MockitoException e ) {}
public boolean neverWanted () { return ! atLeastMode () && mode . wantedCount () == NUMBER_CONSTANT ; }
public boolean tooManyActualInvocations ( int actualCount ) { return ! atLeastMode () && mode . wantedCount () < actualCount ; }
public boolean tooLittleActualInvocations ( int actualCount ) { return ! atLeastMode () && mode . wantedCount () > actualCount ; }
public static MockitoVerificationMode times ( int wantedNumberOfInvocations ) { return new MockitoVerificationMode ( wantedNumberOfInvocations , Verification.EXPLICIT ) ; }
MockitoVerificationMode mode
MockitoVerificationMode mode
public VerificationModeDecoder ( MockitoVerificationMode mode ) { this . mode = mode ; }
MockitoVerificationModeTest . class
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode
private VerificationModeDecoder decode ( MockitoVerificationMode mode ) { return new VerificationModeDecoder ( mode ) ; }
MockitoVerificationMode atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
MockitoVerificationMode mode
return Mockito . verify ( mock , new InOrderVerificationModeWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ;
Times mode
List < Invocation > chunk = finder . findMatchingChunk ( invocations , wanted , mode ) ;
{ if ( wantedNumberOfInvocations < NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedInvocationCount = wantedNumberOfInvocations ; }
{ if ( wantedNumberOfInvocations <= NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedInvocationCount = wantedNumberOfInvocations ; }
numberOfCalls . verify ( allInvocations , wanted , this ) ;
wantedCount () > NUMBER_CONSTANT
verifier . verify ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . verify ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . verify ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . verify ( invocations , wanted ) ;
verifier . verify ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted ) ; }
verifier . verify ( invocations , wanted ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
{ verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; }
if ( wantedCount == NUMBER_CONSTANT ) { missingInvocation . verify ( allInvocations , wanted , this ) ; }
if ( wantedCount == NUMBER_CONSTANT ) { missingInvocation . verify ( data . getAllInvocations () , data . getWanted () ) ; }
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
verifier = new NumberOfInvocationsInOrderChecker ( finderStub , reporter ) ;
verifier . check ( invocations , wanted ) ;
verifier . check ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . check ( invocations , wanted ) ; }
verifier . check ( invocations , wanted ) ;
verifier = new MissingInvocationChecker ( finderStub , reporterStub ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier = new MissingInvocationInOrderChecker ( finderStub , reporterStub ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier = new NumberOfInvocationsChecker ( reporterStub , finderStub ) ;
numberOfCalls . verify ( allInvocations , wanted , wantedCount ) ;
numberOfInvocations . verify ( data . getAllInvocations () , data . getWanted () , wantedCount ) ;
if ( stubbing == null ) { REPORTER . missingMethodInvocation () ; }
T value
public DeprecatedOngoingStubbing < T > toReturn ( Object value ) { return toAnswer ( new Returns ( value ) ) ; }
public NewOngoingStubbing < T > thenReturn ( Object value ) { return thenAnswer ( new Returns ( value ) ) ; }
Object value
MockHandler handler = new MockHandler ( null , state , new ExceptionThrowingBinder () ) ;
{ return Configuration . instance () . getReturnValues () . valueFor ( invocation ) ; }
{ return MockUtil . createMock ( classToMock , MOCKING_PROGRESS , name , null ) ; }
{ return mock ( classToMock , null ) ; }
if ( mockedType . getSigners () != null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MOCKITO_NAMING_POLICY ) ; }
MockingProgressImpl state = new MockingProgressImpl () ;
public void reset () { stubbingInProgress = false ; verificationMode = null ; LastArguments . instance () . reset () ; }
LastArguments . instance () . validateState () ;
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnFalse () ; }
{ return LastArguments . instance () . reportNot () . returnChar () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . < T > returnNull () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnChar () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . < T > returnNull () ; }
{ return LastArguments . instance () . reportOr () . returnFalse () ; }
{ return LastArguments . instance () . reportAnd () . < T > returnNull () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnChar () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnFalse () ; }
LastArguments lastArguments
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnFalse () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnFalse () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnFalse () ; }
public void reset () { stubbingInProgress = false ; verificationMode = null ; getLastArguments () . reset () ; }
getLastArguments () . validateState () ;
public void stubbingCompleted ( Invocation invocation ) { stubbedInvocations . add ( invocation ) ; stubbingInProgress = false ; }
public ExperimentalMockitoJUnitRunner ( Class < > klass ) throws InitializationError { super ( klass ) ; }
private boolean shouldPrint () { return ! unusedStubs . isEmpty () ; }
public byte [] naughtyMethodUnderTestWhichDoesNotFailBecauseItReturnsAValue ( String filename ) { return this . reader . readFromFile ( STRING_CONSTANT ) ; }
public void addUnstubbedInvocation ( Invocation invocation ) { unstubbedInvocations . add ( invocation ) ; }
if ( ! invocation . isVoid () && answer == null ) { mockingProgress . getDebuggingHelper () . addUnstubbedInvocation ( invocation ) ; }
if ( ! invocation . isVoid () && answer == null ) { mockingProgress . getDebuggingHelper () . addPotentiallyUnstubbed ( invocationMatcher ) ; }
void print ( Object what ) ;
public void stubbingCompleted ( Invocation invocation ) { debuggingHelper . addStubbedInvocation ( invocation ) ; stubbingInProgress = false ; }
public void print () { System.out . println () ; }
public ExperimentalMockitoJUnitRunner ( Class < > klass ) throws InitializationError { super ( klass ) ; logger = new MockitoLoggerImpl () ; }
void println ( Object what ) ;
{ if ( hasData () ) { WarningsPrinter warningsPrinter = new WarningsPrinter ( stubbedInvocations , potentiallyUnstubbedInvocations ) ; warningsPrinter . print ( logger ) ; } }
public void addPotentiallyUnstubbed ( InvocationMatcher invocationMatcher ) { if ( ! collectingData ) { return; } potentiallyUnstubbedInvocations . add ( invocationMatcher ) ; }
public ExperimentalMockitoJUnitRunnerPMStub ( ) throws InitializationError { super ( ExperimentalMockitoJUnitRunnerPMTest . class ) ; }
String loggedInfo = logger . getLoggedInfo () ;
String loggedInfo = logger . getLoggedInfo () ;
String loggedInfo = logger . getLoggedInfo () ;
String loggedInfo = logger . getLoggedInfo () ;
public void log ( Object what ) { loggedInfo . append ( what ) ; }
{ return MockitoProperties.DEFAULT_RETURN_VALUES . valueFor ( invocation ) ; }
{ unusedStubbingThatQualifiesForWarning () ; notifier . fireTestFailure ( null ) ; assertTrue ( debuggingInfo . hasData () ) ; }
DefaultReturnValuesTest . class
EmptyReturnValues reportMatcher ( Matcher matcher ) ;
Foo mock = mock ( Foo . class , SMART_NULLS ) ;
Foo mock = mock ( Foo . class , SMART_NULLS ) ;
@ Before public void setup () { mock = mock ( IMethods . class , Mockito.SMART_NULLS ) ; }
{ return mock ( classToMock , name , null , USING_GLOBAL_CONFIG ) ; }
{ return mock ( classToMock , null , null , USING_GLOBAL_CONFIG ) ; }
String mockName
catch ( NoSuchMethodException e ) { throw new RuntimeException ( STRING_CONSTANT ) ; }
verify ( mock ) ;
{ validateState () ; resetOngoingStubbing () ; verificationMode = ( VerificationMode ) verify ; }
unfinishedVerificationHere () ;
{ unfinishedVerificationHere () ; fail () ; }
this . stackTrace = filter . filterStackTrace ( stackTrace ) ;
if ( callback instanceof MethodInterceptorFilter ) { return ( MethodInterceptorFilter ) callback ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
StackTrackeChangingTest . class
STRING_CONSTANT + actualCount + STRING_CONSTANT
{ matcherStack . push ( matcher ) ; return new HandyReturnValues () ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
assertEquals ( expectedMessage , actualMessage ) ;
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NeverWantedButInvoked e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
reporter . tooLittleActualInvocations ( wantedCount , actualCount , wanted , lastInvocation ) ;
reporter . tooLittleActualInvocationsInAtLeastMode ( wantedCount , actualCount , wanted , lastInvocation ) ;
reporter . tooLittleActualInvocationsInOrder ( wantedCount , actualCount , wanted , lastInvocation ) ;
STRING_CONSTANT + pluralize ( wantedCount ) + STRING_CONSTANT
reporter . tooLittleActualInvocationsInOrderInAtLeastMode ( wantedCount , actualCount , wanted , lastInvocation ) ;
catch ( SmartNullPointerException e ) { assertThat ( e . getCause () , hasMethodInStackTraceAt ( NUMBER_CONSTANT , STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
@ Test ( expected = VerifcationInOrderFailure . class )
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( spy ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure f ) {}
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
try { inOrder . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
VerifcationInOrderFailure e
VerifcationInOrderFailure e
VerifcationInOrderFailure e
VerifcationInOrderFailure e
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
{ String message = createTooLittleInvocationsMessage ( discrepancy , wanted , lastActualStackTrace ) ; throw new VerifcationInOrderFailure ( join ( STRING_CONSTANT + message ) ) ; }
throw new VerifcationInOrderFailure ( join ( STRING_CONSTANT + message ) ) ;
if ( stubbingInProgress ) { stubbingInProgress = false ; reporter . unfinishedStubbing () ; }
assertEquals ( expectedMessage , actualMessage ) ;
private void misplacedArgumentMatcher () { anyString () ; }
mockitoStubber . setInvocationForPotentialStubbing ( new InvocationBuilder () . toInvocationMatcher () ) ;
{ return new VoidMethodStubbableImpl ( mock ) ; }
{ return new VoidMethodStubbableImpl < T > ( mock , mockitoStubber ) ; }
if ( stubbingInProgress ) { stubbingInProgress = false ; reporter . unfinishedStubbing ( debuggingInfo . getLastInvocationLocation () ) ; }
mockitoStubber . setInvocationForPotentialStubbing ( new InvocationBuilder () . toInvocationMatcher () , null ) ;
public void reset () { stubbingInProgress = false ; verificationMode = null ; getArgumentMatcherStorage () . reset () ; }
public void stubbingCompleted ( Invocation invocation ) { debuggingInfo . addStubbedInvocation ( invocation ) ; stubbingInProgress = false ; }
{ Throwable filtered = throwable . fillInStackTrace () ; filter . filterStackTrace ( new HasStackTraceThrowableWrapper ( filtered ) ) ; throw filtered ; }
assertEquals ( invocation . getStackTrace () , reporterStub.stackTrace ) ;
assertSame ( third . getStackTrace () , reporterStub.stackTrace ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
assertSame ( second . getStackTrace () , reporterStub.stackTrace ) ;
if ( previousInOrder == null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder , previousInOrder . getStackTrace () ) ; }
HasStackTrace firstUndesired
HasStackTrace firstUndesired
HasStackTrace hasStackTrace
reporter . argumentsAreDifferent ( syncingPrinter . getWanted () , syncingPrinter . getActual () , similar . getStackTrace () ) ;
if ( unverified != null ) { new Reporter () . noMoreInteractionsWanted ( unverified , unverified . getStackTrace () ) ; }
assertSame ( previous . getStackTrace () , reporterStub.previousStackTrace ) ;
assertSame ( actualInvocation . getStackTrace () , reporterStub.actualInvocationStackTrace ) ;
assertNull ( reporterStub.actualInvocationStackTrace ) ;
final boolean overloadedButSameArgs = ! methodEquals && argumentsMatch ( candidate ) ;
int expectedMatchersSize = invocation . getArguments () . length ;
Location lastLocation = finder . getLastStackTrace ( chunk ) ;
Location lastLocation = finder . getLastStackTrace ( actualInvocations ) ;
Location lastInvocation = finder . getLastStackTrace ( actualInvocations ) ;
Location lastInvocation = finder . getLastStackTrace ( chunk ) ;
if ( previousInOrder == null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder , previousInOrder . getLocation () ) ; }
if ( unverified != null ) { new Reporter () . noMoreInteractionsWanted ( unverified , unverified . getLocation () ) ; }
@ Override public String toString () { return this . firstTraceElement . toString () ; }
if ( matcherStack . isEmpty () ) { return null ; }
assertNull ( Mockito.MOCKING_PROGRESS . pullOngoingStubbing () ) ;
ret . getClass () . isArray () ;
{ return doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return doAnswer ( new DoesNothing () ) ; }
{ return doAnswer ( new ThrowsException ( toBeThrown ) ) ; }
{ verifyNoMoreInteractions ( mocks ) ; }
{ return verify ( mock , times ( NUMBER_CONSTANT ) ) ; }
{ return mock ( classToMock , null , ( T ) null , returnValues ) ; }
{ return mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
return MockitoCore . mock ( ( Class ) class1 , null , null , this ) ;
{ return MockitoCore . inOrder ( mocks ) ; }
{ return MockitoCore . doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return MockitoCore . doAnswer ( new DoesNothing () ) ; }
{ return MockitoCore . doAnswer ( answer ) ; }
{ return MockitoCore . doAnswer ( new ThrowsException ( toBeThrown ) ) ; }
{ return MockitoCore . stubVoid ( mock ) ; }
{ MockitoCore . verifyNoMoreInteractions ( mocks ) ; }
{ MockitoCore . verifyNoMoreInteractions ( mocks ) ; }
{ return MockitoCore . verify ( mock , mode ) ; }
{ MockitoCore . reset ( mock ) ; }
{ return MockitoCore . verify ( mock , times ( NUMBER_CONSTANT ) ) ; }
{ return MockitoCore . when ( methodCall ) ; }
{ return MockitoCore . stub ( methodCall ) ; }
{ return MockitoCore . mock ( classToMock , null , ( T ) null , returnValues ) ; }
{ return MockitoCore . mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return MockitoCore . mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
for ( T m : mocks ) { MockUtil . resetMock ( m , MOCKING_PROGRESS , Mockito.RETURNS_DEFAULTS ) ; }
MOCKING_PROGRESS . stubbingStarted () ;
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { REPORTER . mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
{ MOCKING_PROGRESS . stubbingStarted () ; return ( NewOngoingStubbing ) stub () ; }
{ MOCKING_PROGRESS . stubbingStarted () ; return ( DeprecatedOngoingStubbing ) stub () ; }
ConfigurationAccess . getConfig () . overrideCleansStackTrace ( true ) ;
ConfigurationAccess . getConfig () . overrideCleansStackTrace ( true ) ;
{ mock = mock ( IMethods . class , Mockito.RETURNS_SMART_NULLS ) ; ConfigurationAccess . getConfig () . overrideCleansStackTrace ( true ) ; }
{ ConfigurationAccess . getConfig () . overrideCleansStackTrace ( true ) ; first () ; second () ; third () ; fourth () ; }
@ Before public void init () { StateMaster . validate () ; MockitoAnnotations . initMocks ( this ) ; }
StateMaster . validate () ;
{ return isA ( clazz ) ; }
filter . filterStackTrace ( t ) ;
{ unfilteredStackTrace = getStackTrace () ; StackTraceFilter filter = new StackTraceFilter () ; filter . filterStackTrace ( this ) ; }
filter . filterStackTrace ( this ) ;
filter . filterStackTrace ( this ) ;
this . firstTraceElement = filter . filterStackTrace ( stackTrace ) [ NUMBER_CONSTANT ] ;
@ Before public void cleanStackTraces () { super . makeStackTracesClean () ; }
filter . filterConditionally ( t ) ;
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e , messageContains ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ) ; }
catch ( InvalidUseOfMatchersException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( MockitoException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( MockitoException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( NeverWantedButInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( mockTwo . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
catch ( MockitoException e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
catch ( MockitoException e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
final boolean overloadedButSameArgs = ! methodEquals && argumentsMatch ( candidate . getArguments () ) ;
{ return anyObject () ; }
Invocation i = new Invocation ( mock , method , args , sequenceNumber ) ;
UnderTest mock = mock ( UnderTest . class ) ;
public Person ( int age ) { this . age = age ; }
if ( arguments . isEmpty () ) { new Reporter () . argumentValueNotYetCaptured () ; } else { return ( T ) arguments . getLast () ; }
{ anyObject () ; try { MockitoTroubleshooter . validateFrameworkState () ; fail () ; } catch ( InvalidUseOfMatchersException e ) {} }
try { MockitoTroubleshooter . validateFrameworkState () ; fail () ; } catch ( UnfinishedStubbingException e ) {}
{ verify ( mock ) ; try { MockitoTroubleshooter . validateFrameworkState () ; fail () ; } catch ( UnfinishedVerificationException e ) {} }
{ return ( List ) arguments ; }
{ Mockito . argThat ( this ) ; return null ; }
{ notifier . addListener ( new FrameworkUsageValidator ( notifier ) ) ; super . run ( notifier ) ; }
{ if ( classProvider . hasJUnit45OrHigher () ) { return classProvider . newInstance ( STRING_CONSTANT , klass ) ; } else { return classProvider . newInstance ( STRING_CONSTANT , klass ) ; } }
RunnerFactory ( ClassProvider classProvider ) { this . classProvider = classProvider ; }
{ super ( klass ) ; }
catch ( Throwable t ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , t ) ; }
this . runTest ( notifier ) ;
if ( MockUtil . isMock ( instance ) ) { return returnValues . valueFor ( invocation ) ; } else { return methodProxy . invoke ( instance , args ) ; }
{ try { new ShallowCopyTool () . copy ( optionalInstance , mock ) ; } catch ( UnableToCopyFieldValue e ) {} }
@ Test public void shouldCallRealMethdsEvenDelegatedToOtherSelfMethod () { String name = mock . getName () ; assertEquals ( STRING_CONSTANT , name ) ; }
protected String guessName () { return defaultName ; }
public String getName () { return guessName () ; }
{ return new VoidMethodStubbableImpl ( mock ) ; }
{ return MOCKITO_CORE . mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , null , null , RETURNS_DEFAULTS ) ; }
assertTrue ( MockUtil . isMock ( classMock ) ) ;
assertTrue ( MockUtil . isMock ( interfaceMock ) ) ;
if ( MockUtil . isMock ( throwable ) ) { throw throwable ; }
MockUtil . isMock ( instance )
MockUtil . getMockHandler ( withFinal ) ;
MockName name = MockUtil . getMockName ( mock ) ;
try { MockUtil . getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List mock = Mockito . mock ( List . class ) ; assertNotNull ( MockUtil . getMockHandler ( mock ) ) ; }
List < Invocation > fromSingleMock = MockUtil . getMockHandler ( mock ) . getRegisteredInvocations () ;
MockHandler < T > handler = MockUtil . getMockHandler ( mock ) ;
if ( mock == null ) { reporter . nullPassedWhenCreatingInOrder () ; } else if ( ! MockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder () ; }
{ if ( mock == null ) { reporter . nullPassedToVerifyNoMoreInteractions () ; } MockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions () ; }
for ( T m : mocks ) { MockUtil . resetMock ( m , mockingProgress ) ; }
if ( mock == null ) { reporter . nullPassedToVerify () ; } else if ( ! MockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify () ; }
{ mockingProgress . validateState () ; mockingProgress . resetOngoingStubbing () ; return MockUtil . createMock ( classToMock , mockingProgress , ( MockSettingsImpl ) mockSettings ) ; }
{ mock ( IMethods . class , configureWith () . extraInterfaces ( IMethods . class ) ) ; fail () ; }
{ mock ( Foo . class , configureWith () . extraInterfaces ( Foo . class ) ) ; fail () ; }
{ mock ( Foo . class , configureWith () . extraInterfaces ( ( Class [] ) null ) ) ; fail () ; }
{ mock ( Foo . class , configureWith () . extraInterfaces () ) ; fail () ; }
{ mock ( Foo . class , configureWith () . extraInterfaces ( IFoo . class , null ) ) ; fail () ; }
Foo mock = mock ( Foo . class , configureWith () . extraInterfaces ( IFoo . class , IBar . class ) ) ;
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , configureWith () . spiedInstance ( object ) . defaultBehavior ( RETURNS_DEFAULTS ) )
{ return MOCKITO_CORE . mock ( classToMock , configureWith () . defaultBehavior ( returnValues ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , configureWith () . name ( name ) . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , configureWith () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ mock ( IMethods . class , configureWith () . extraInterfaces ( ( Class [] ) null ) ) ; }
@ Test public void shouldScreamWhenExtraIsTheSame () { mock ( IMethods . class , configureWith () . extraInterfaces ( IMethods . class ) ) ; }
@ Test public void shouldScreamWhenNonInterfacePassed () { mock ( IMethods . class , configureWith () . extraInterfaces ( LinkedList . class ) ) ; }
{ mock ( IMethods . class , configureWith () . extraInterfaces ( List . class , null ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . defaultBehavior ( returnValues ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ MockSettingsImpl settings = ( MockSettingsImpl ) Mockito . withSettings () ; assertEquals ( Mockito.RETURNS_DEFAULTS , settings . getReturnValues () ) ; }
IMethods mock = mock ( IMethods . class , withSettings () . defaultBehavior ( RETURNS_SMART_NULLS ) . name ( STRING_CONSTANT ) ) ;
{ return mockSettings . getReturnValues () . valueFor ( invocation ) ; }
{ assertEquals ( STRING_CONSTANT , values . valueFor ( invocationOf ( StringMethods . class , STRING_CONSTANT ) ) ) ; }
ret = ( String [] ) values . valueFor ( invocationOf ( StringMethods . class , STRING_CONSTANT ) )
public static MockSettings withSettings () { return new MockSettingsImpl () . defaultBehavior ( RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . doAnswer ( new CallsRealMethod () ) ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultBehavior ( RETURNS_DEFAULTS ) )
{ return mock ( classToMock , withSettings () . name ( name ) . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ return mock ( classToMock , withSettings () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
EmptyReturnValuesTest . class
{ ConfigurationAccess . getConfig () . overrideCleansStackTrace ( false ) ; ConfigurationAccess . getConfig () . overrideReturnValues ( null ) ; }
runner = new VerboseMockitoJUnitRunner ( DummyTest . class ) ;
public Object answer ( InvocationOnMock invocation ) throws Throwable { return invocation . invokeSuper () ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultAnswer ( RETURNS_DEFAULTS ) )
catch ( Throwable t ) { new ConditionalStackTraceFilter () . filter ( t ) ; throw t ; }
this . firstTraceElement = filter . filter ( stackTrace ) [ NUMBER_CONSTANT ] ;
this . firstTraceElement = filter . filter ( stackTrace , NUMBER_CONSTANT ) [ NUMBER_CONSTANT ] ;
StackTraceElement [] filtered = filter . filter ( throwable . getStackTrace () , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( new StackTraceElement [ NUMBER_CONSTANT ] , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
line = printer . getArgumentsLine ( ( List ) Arrays . asList ( new Equals ( NUMBER_CONSTANT ) , NotNull.NOT_NULL ) , PrintSettings . verboseArgs () )
printer . getArgumentsBlock ( ( List ) Arrays . asList ( new Equals ( NUMBER_CONSTANT ) , new Equals ( NUMBER_CONSTANT ) ) , PrintSettings . verboseArgs () )
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseVariant () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseVariant () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
public void setMatchersToBePrintedVerbosely ( Matcher [] toBePrintedVerbosely ) { this . verboseMatchers = Arrays . asList ( toBePrintedVerbosely ) ; }
Matcher . . . verboselyPrinted
Matcher . . . toBePrintedVerbosely
{ withPrintSettings . add ( ( ( CanPrintArgumentVerbosely ) matcher ) . getVerboseSelfDescribing () ) ; }
SelfDescribing getVerboseSelfDescribing ( ) ;
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseSelfDescribing () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseSelfDescribing () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
CanDescribeVerbosely equals = new Equals ( NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , StringDescription . toString ( m . withExtraTypeInfo () ) ) ;
try { verify ( withFinal ) . finalMethod ( anyObject () ) ; fail () ; } catch ( UnfinishedVerificationException e ) {}
public BDDOngoingStubbingImpl ( NewOngoingStubbing < T > ongoingStubbing ) { this . mockitoOngoingStubbing = ongoingStubbing ; }
Field createInfoField = methodProxy . getClass () . getDeclaredField ( STRING_CONSTANT ) ;
{ return getInterceptor ( mock ) . getDelegate () ; }
{ Mockito . argThat ( capturingMatcher ) ; return null ; }
ArgumentCaptor < String > captor = new ArgumentCaptor < String > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
ArgumentCaptor < String > argument = new ArgumentCaptor < String > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
ArgumentCaptor < Person > person = new ArgumentCaptor < Person > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
{ Mockito . argThat ( capturingMatcher ) ; return new HandyReturnValues () . returnFor ( clazz ) ; }
ArgumentCaptor < String > argument = new ArgumentCaptor < String > () ;
newMessage += STRING_CONSTANT + debuggingInfo . getWarnings () ;
newMessage += STRING_CONSTANT + debuggingInfo . getWarnings () + STRING_CONSTANT ;
private String thisStubWasNotUsed ( Invocation i ) { return join ( STRING_CONSTANT , i , i . getLocation () , STRING_CONSTANT ) ; }
{ this ( unusedStubs , unstubbedInvocations , true ) ; }
invocationMarker . markVerified ( invocations , wanted ) ;
{ if ( wantedNumberOfInvocations <= NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedCount = wantedNumberOfInvocations ; }
private int hashCodeForMock ( Object mock ) { return new Integer ( System . identityHashCode ( mock ) ) ; }
{ return getInterceptor ( mock ) . getMockHandler () ; }
for ( T m : mocks ) { mockUtil . resetMock ( m , mockingProgress ) ; }
public static boolean isToString ( InvocationOnMock invocation ) { return isToString ( invocation . getMethod () ) ; }
if ( Invocation . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
equalsMethod . equals ( method )
MethodInterceptorFilter newFilter = new MethodInterceptorFilter ( Object . class , newMockHandler ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( classToMock , mockHandler ) ;
if ( hashCodeMethod . equals ( method ) ) { return hashCodeForMock ( proxy ) ; }
if ( ObjectMethodsGuru . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
public static boolean isToString ( InvocationOnMock invocation ) { return ObjectMethodsGuru . isToString ( invocation . getMethod () ) ; }
markFirstOccurence ( chunk , wantedMatcher ) ;
{ try { return argumentsMatch ( actualArgs ) ; } catch ( Throwable t ) { return false ; } }
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) Arrays . asList ( new Equals ( STRING_CONSTANT ) , capturingMatcher ) ) ;
proxy . setCallbacks ( new Callback [] { interceptor , NoOp.INSTANCE } ) ;
{ return methodProxy . invokeSuper ( target , arguments ) ; }
public CGLIBProxyRealMethod ( MethodProxy methodProxy ) { this . methodProxy = methodProxy ; }
public FilteredCGLIBProxyRealMethod ( MethodProxy methodProxy ) { this ( new CGLIBProxyRealMethod ( methodProxy ) ) ; }
Any mock = mock ( Any . class ) ;
{ return methodProxy . getMethodProxy () . invokeSuper ( target , arguments ) ; }
public Method getMethod () { return invocation . getMethod () ; }
Method method
Method getMethod ( ) ;
Invocation i = new Invocation ( mock , new DelegatingMockitoMethod ( method ) , args , sequenceNumber , null ) ;
{ new ObjectOutputStream ( new ByteArrayOutputStream () ) . writeObject ( new MethodInterceptorFilter ( null ) ) ; }
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHandler ) ;
assertFalse ( new SerializableMockitoMethod ( testBaseToStringMethod ) . equals ( mockMethod ) ) ;
mockMethod = new SerializableMockitoMethod ( toStringMethod ) ;
Class < > getReturnType ( ) ;
MockitoMethod mockitoMethod = new SerializableMockitoMethod ( method ) ;
Invocation i = new Invocation ( mock , new SerializableMockitoMethod ( method ) , args , sequenceNumber , null ) ;
assertFalse ( new MockitoMethod ( testBaseToStringMethod ) . equals ( mockMethod ) ) ;
mockMethod = new MockitoMethod ( toStringMethod ) ;
public MockitoMethod getMethod () { return invocation . getMethod () ; }
MockitoMethod getMethod ( ) ;
MockitoMethod method
Invocation i = new Invocation ( mock , new MockitoMethod ( method ) , args , sequenceNumber , null ) ;
SerializableMethod getMethod ( ) ;
public SerializableMethod getMethod () { return invocation . getMethod () ; }
{ if ( this . getMethod () . isDeclaredOnInterface () ) { new Reporter () . cannotCallRealMethodOnInterface () ; } return realMethod . invoke ( mock , rawArguments ) ; }
{ if ( invocation . getMethod () . isDeclaredOnInterface () ) { reporter . cannotCallRealMethodOnInterface () ; } }
SerializableMethod method
{ if ( isPrimitiveWrapper ( clazz ) ) { return primitiveWrapperOf ( clazz ) ; } return primitiveValueFor ( clazz ) ; }
@ Override protected MethodProxy getMethodProxy () { return methodProxy ; }
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
List < Invocation > allInvocations = ongoingStubbing . getRegisteredInvocations () . getAll () ;
{ registeredInvocations . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing < T > ( mockitoStubber ) ; }
{ registeredInvocations . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing < T > ( mockitoStubber ) ; }
OngoingStubbingImpl < T > ongoingStubbing = new OngoingStubbingImpl < T > ( mockitoStubber , mockitoStubber . getRegisteredInvocations () ) ;
public void addAnswer ( Answer answer ) { addAnswer ( answer , false ) ; }
public MockHandler ( MockHandler < T > oldMockHandler ) { this ( oldMockHandler.mockName , oldMockHandler.mockingProgress , oldMockHandler.matchersBinder , oldMockHandler.mockSettings ) ; }
return mockHandler . handle ( invocation ) ;
{ return ( MockHandler ) getInterceptor ( mock ) . getMockHandler () ; }
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHanlder , ( MockSettingsImpl ) withSettings () ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHanlder , ( MockSettingsImpl ) withSettings () ) ;
Mockito . verify ( mockHanlder , never () ) . handle ( any ( Invocation . class ) ) ;
Mockito . verify ( mockHanlder , never () ) . handle ( any ( Invocation . class ) ) ;
{ mockingProgress . validateState () ; mockingProgress . resetOngoingStubbing () ; return mockUtil . createMock ( classToMock , mockingProgress , ( MockSettingsImpl ) mockSettings ) ; }
public MockName getMockName ( Object mock ) { return getMockHandler ( mock ) . getMockName () ; }
MockHandler () { this ( new ThreadSafeMockingProgress () , new MatchersBinder () , new MockSettingsImpl () ) ; }
{ mockitoStubber . addAnswerForVoidMethod ( answer ) ; return this ; }
public VoidMethodStubbable < T > toReturn () { mockitoStubber . addAnswerForVoidMethod ( new DoesNothing () ) ; return this ; }
{ mockitoStubber . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
{ try { mockitoStubber . addAnswer ( new ThrowsException ( null ) ) ; fail () ; } catch ( MockitoException e ) {} }
{ state . stubbingStarted () ; mockitoStubber . addAnswer ( new Returns ( STRING_CONSTANT ) ) ; state . validateState () ; }
{ mockitoStubber . addAnswer ( new ThrowsException ( new Exception () ) ) ; fail () ; }
{ mockitoStubber . addConsecutiveAnswer ( answer ) ; return this ; }
{ mockitoStubber . addConsecutiveAnswer ( answer ) ; return this ; }
@ SuppressWarnings ( STRING_CONSTANT ) public void setAnswersForStubbing ( List < Answer > answers ) { mockitoStubber . setAnswersForStubbing ( answers ) ; }
{ return new VoidMethodStubbableImpl < T > ( mock , mockitoStubber ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( mockitoStubber . getInvocations () , null ) ; VerificationModeFactory . noMoreInteractions () . verify ( data ) ; }
this . mockitoStubber = new MockitoStubber ( mockingProgress ) ;
if ( i . stubInfo () != null ) { System.out . println ( STRING_CONSTANT + i . stubInfo () . stubbingLocation () ) ; }
void printInvocations ( Object . . . mocks ) ;
{ return MOCKITO_CORE . mock ( classToMock , mockSettings ) ; }
{ return MOCKITO_CORE . mock ( classToMock , mockSettings , true ) ; }
void varargs ( String . . . string ) ;
void varargs ( Object . . . object ) ;
List < Invocation > allInvocations = new AllInvocationsFinder () . getAllInvocations ( mocksToBeVerifiedInOrder ) ;
List < Invocation > invocations = finder . getAllInvocations ( asList ( mockOne , mockOne , mockOne ) ) ;
List < Invocation > invocations = finder . getAllInvocations ( asList ( mockOne , mockTwo ) ) ;
public void log ( Object what ) { System.out . println ( what . toString () ) ; }
public void stubbingCompleted ( Invocation invocation ) { debuggingInfo . addStubbedInvocation ( invocation ) ; stubbingInProgress = null ; }
for ( InvocationMatcher i : allInvocations ) { findingsListener . foundUstubbed ( i ) ; }
verify ( listener , only () ) . foundUstubbed ( unstubbedInvocation ) ;
void foundUstubbed ( InvocationMatcher unstubbed ) ;
{ this ( new MockitoLoggerImpl () , new RunnerFactory () . create ( klass ) ) ; }
public void cleanStackTraces () { super . makeStackTracesClean () ; }
public MockUtil ( CreationValidator creationValidator ) { this . creationValidator = creationValidator ; }
private boolean isEmpty ( String warnings ) { return warnings == null || warnings . isEmpty () ; }
SimpleTest test = new SimpleTest () ;
SimpleTest test = new SimpleTest () ;
@ Test ( expected = WantedButNotInvoked . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
if ( instance == null ) { throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
String log = Mockito . debug () . printInvocations ( mock , mockTwo ) ;
String log = Mockito . debug () . printInvocations ( mock , mockTwo ) ;
String log = Mockito . debug () . printInvocations ( mock , mockTwo ) ;
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMock Object iAmNull = null ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMock @ Captor ArgumentCaptor captor ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMock @ Mock List mock ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMock @ Spy List mock ; } ) ; }
null != field . getAnnotation ( InjectMock . class )
if ( field . isAnnotationPresent ( annotation ) ) { new Reporter () . unsupportedCombinationOfAnnotations ( annotation . getSimpleName () , InjectMock . class . getSimpleName () ) ; }
field . isAnnotationPresent ( InjectMock . class )
{ checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT ) ;
return mockitoCore . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ;
if ( invocation . isVoid () ) { reporter . cannotStubVoidMethodWithAReturnValue () ; }
mockingProgress . verificationStarted ( mode ) ;
{ VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl . getInvocations () , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
{ try { Thread . sleep ( sleep ) ; } catch ( InterruptedException ie ) { throw new MockitoException ( STRING_CONSTANT ) ; } }
try { t . verify ( data ) ; } catch ( MockitoAssertionError e ) {}
@ Override public InvocationMatcher getWanted () { return wanted ; }
@ Override public InOrderContext getOrderingContext () { return inOrder ; }
{ throw new MockitoException ( join ( STRING_CONSTANT + methodName + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ return ( T ) anyObject () ; }
Object instance = field . get ( testClass ) ;
{ throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + field . getType () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + field . getType () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + field . getType () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + field . getType () + STRING_CONSTANT ) ; }
NestedClassWithNoArgConstructor ( String _1arg ) {}
if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify () ; }
validateState () ;
Invocation . isToString ( invocation )
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
new Reporter () . smartNullPointerException ( location ) ;
new Reporter () . smartNullPointerException ( obj , location ) ;
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + formatMethodCall () + STRING_CONSTANT ; }
null != field . getAnnotation ( Mock . class )
Object testClass
int index = filter . accept ( actualMethod ) ;
notifyInvocationListener ( invocation ) ;
MockHandler handler
{ given ( handler . getMockSettings () . getDefaultAnswer () ) . willReturn ( SOME_ANSWER ) ; stubOrdinaryInvocationWithReturnValue ( handler , null ) ; }
doThrow ( new RuntimeException () ) . when ( throwingListener )
public OngoingMockInjection tryPropertyOrFieldInjection () { appendStrategy ( new PropertyAndSetterInjection () ) ; return this ; }
public OngoingMockInjection tryConstructorInjection () { appendStrategy ( new ConstructorInjection () ) ; return this ; }
{ return nextStrategy != null && nextStrategy . processInjection ( field , fieldOwner , mockCandidates ) ; }
{ assert wasAccessible != null ; try { accessibleObject . setAccessible ( wasAccessible ) ; } catch ( Throwable t ) {} }
AllInvocationsFinder finder = new AllInvocationsFinder () ;
{ for ( InvocationListener listener : mockSettings . getInvocationListener () ) { notifyListenerOfInvocationWithException ( invocation , exception , listener ) ; } }
{ for ( InvocationListener listener : mockSettings . getInvocationListener () ) { notifyListenerOfInvocationWithReturnValue ( invocation , returnValue , listener ) ; } }
given ( handler . getMockSettings () . getInvocationListener () ) . willReturn ( Arrays . asList ( listener ) ) ;
@ Test ( expected = MockitoException . class ) public void shouldThrowCorrectExceptionForNullInvocationListener ( ) throws Exception { new Reporter () . nullInvocationListenerAdded () ; }
Foo foo = mock ( Foo . class , withSettings () . callback ( listener1 ) . callback ( listener2 ) ) ;
Foo foo = mock ( Foo . class , withSettings () . callback ( listener ) ) ;
Foo foo = mock ( Foo . class , withSettings () . callback ( listener1 ) . callback ( listener2 ) ) ;
Foo foo = mock ( Foo . class , withSettings () . callback ( listener ) ) ;
{ assertFalse ( mockSettingsImpl . hasInvocationListeners () ) ; mockSettingsImpl . verboseLogging () ; assertContainsType ( mockSettingsImpl . getInvocationListeners () , LogInvocationsToStdOutListener . class ) ; }
MethodCallReport mcr
public void invocationListenersRequiresAtLeastOneListener () { throw new MockitoException ( join ( STRING_CONSTANT ) ) ; }
public void invocationListenerDoesNotAcceptNullParameters () { throw new MockitoException ( join ( STRING_CONSTANT ) ) ; }
{ notifier . handle ( invocation ) ; }
{ notifier . handle ( invocation ) ; }
{ mockSettingsImpl . invocationListeners ( invocationListener , null ) ; }
{ mockSettingsImpl . invocationListeners () ; }
{ mapOngoingStubbing . thenReturn ( STRING_CONSTANT ) ; }
{ super ( new URL [] { obtainClassPath ( SimplePerRealmReloadingClassLoader . class ) } , parentClassLoader ) ; this . reloadClassPredicate = reloadClassPredicate ; }
{ super ( new URL [] { obtainClassPath ( SimplePerRealmReloadingClassLoader . class ) } ) ; this . reloadClassPredicate = reloadClassPredicate ; }
return report . fieldWasInitialized () ;
mocks . addAll ( scanMocks ( testClassInstance , clazz ) ) ;
@ Test public void inject_mocks_even_in_declared_spy ( ) throws Exception { assertNotNull ( spiedReceiver.antena ) ; assertNotNull ( spiedReceiver.tuner ) ; }
new InjectMocksScanner ( testClassInstance , clazz ) . addTo ( mockDependentFields ) ;
{ return ( MockHandlerInterface ) getInterceptor ( mock ) . getHandler () ; }
String canThrowException ( ) throws ChangedCharSetException , CharacterCodingException ;
MockSettingsImpl mockSettings
MockSettingsImpl settings
MockSettingsImpl settings
MockSettingsImpl settings
public void setTheField ( final File theField ) { setTheFieldWasUsed = true ; this . theField = theField ; }
Class configClass = null ;
private void misplacedBooleanArgumentMatcher () { anyBoolean () ; }
private void misplacedIntArgumentMatcher () { anyInt () ; }
private void misplacedArgumentMatcher () { anyObject () ; }
List < Matcher > pullMatchers ( ) ;
Set < Object > mocks = new HashSet < Object > () ;
Set < Object > mocks = new HashSet < Object > () ;
{ this . delegatedInstance = delegatedInstance ; return defaultAnswer ( new ReturnsDelegate ( this . delegatedInstance ) ) ; }
public Integer getSequenceNumber () { return sequenceNumber ; }
int expectedMatchersSize = invocation . getArgumentsCount () ;
if ( isDeclaredOnInterface () ) { new Reporter () . cannotCallRealMethodOnInterface () ; }
List matchers = i . argumentsToMatchers () ;
public String toString () { return invocation . toString ( matchers , new PrintSettings () ) ; }
{ this . matchers = invocation . argumentsToMatchers () ; }
{ this . matchers = Invocation . argumentsToMatchers ( invocation . getArguments () ) ; }
public String print ( Invocation invocation ) { return print ( Invocation . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
public String toString () { return new PrintSettings () . print ( argumentsToMatchers ( getArguments () ) , this ) ; }
this . arguments = expandVarArgs ( mockitoMethod . isVarArgs () , args ) ;
List matchers = Invocation . argumentsToMatchers ( i . getArguments () ) ;
throw new NoInteractionsWanted ( join ( STRING_CONSTANT , new Location () , STRING_CONSTANT , undesired . getLocation () , scenario ) ) ;
Location lastActualLocation
Location lastActualLocation
Location firstUndesired
Location firstUndesired
join ( STRING_CONSTANT , STRING_CONSTANT , wanted . toString () , new Location () , STRING_CONSTANT , previous . toString () , previous . getLocation () , STRING_CONSTANT )
new Location ()
Location location
Location location
public Localized ( T object ) { this . object = object ; location = new Location () ; }
Location lastLocation = finder . getLastLocation ( chunk ) ;
Location actualLocation
public Location getLocation () { return invocation . getLocation () ; }
Location last = finder . getLastLocation ( invocations ) ;
this . location = new Location () ;
String loc = new Location ( filterReturningEmptyArray ) . toString () ;
Location lastLocation = null ;
{ this . actualMatcher = actualMatcher ; this . location = new Location () ; }
Location lastLocation = finder . getLastLocation ( actualInvocations ) ;
Location actualLocation
Location firstUndesired
Location firstUndesired
Location lastActualLocation
{ Location location = verificationMode . getLocation () ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; }
if ( stubbingInProgress != null ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; }
invocation . markStubbed ( new StubInfo ( stubbedInvocation ) ) ;
{ out += line ( STRING_CONSTANT + i . stubInfo () . stubbedAt () ) ; }
{ s . markStubUsed ( invocation ) ; invocation . markStubbed ( new StubInfo ( s ) ) ; return s ; }
isMultiline () || ( ! matchers . isEmpty () && invocationString . length () > Invocation.MAX_LINE_LENGTH )
public void stubbingCompleted ( Invocation invocation ) { threadSafely () . stubbingCompleted ( invocation ) ; }
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation undesired
Invocation undesired
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation
Mockito . verify ( handler , never () ) . handle ( any ( Invocation . class ) ) ;
Mockito . verify ( handler , never () ) . handle ( any ( Invocation . class ) ) ;
public void foundUnusedStub ( Invocation unused ) { logger . log ( STRING_CONSTANT + unused . getLocation () + STRING_CONSTANT ) ; }
Invocation unused
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
public void markVerified ( Invocation i ) { verified . add ( i ) ; }
public boolean isVerified ( Invocation invocation ) { return verified . contains ( invocation ) ; }
List < Invocation > getAllInvocations ( ) ;
Invocation invocationOnInterface = new InvocationBuilder () . toInvocation () ;
List < Invocation > unusedStubs
Invocation actual
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation previous = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
assertNull ( finder . getLastLocation ( Collections . < Invocation > emptyList () ) ) ;
Invocation invocationOnClass = getLastInvocation () ;
Invocation i
Invocation candidate
Invocation candidate
Invocation actual
public Invocation getInvocation () { return this . invocation ; }
public InvocationMatcher ( Invocation invocation ) { this ( invocation , Collections . < Matcher > emptyList () ) ; }
Invocation invocation
WarningsFinder finder = new WarningsFinder ( Arrays . < Invocation > asList () , Arrays . < InvocationMatcher > asList ( unstubbedInvocation ) ) ;
public boolean isOut ( Invocation invocation ) { return ! orderingContext . isVerified ( invocation ) ; }
public boolean isOut ( Invocation invocation ) { return ! wanted . matches ( invocation ) ; }
public boolean isOut ( Invocation invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
public void add ( Invocation invocation ) { invocations . add ( invocation ) ; }
Invocation invocation = new InvocationBuilder () . toInvocation () ;
public ExposedInvocation ( Invocation toBeExposed ) { methodProxy = ( ( HasCGLIBMethodProxy ) toBeExposed.realMethod ) . getMethodProxy () ; }
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation
List < Invocation > getAllInvocations ( ) ;
Invocation invocation
Invocation invocation
Invocation invocation
public void markVerified ( Invocation i ) { inOrderContext . markVerified ( i ) ; }
public boolean isVerified ( Invocation i ) { return inOrderContext . isVerified ( i ) ; }
List < Invocation > getInvocations ( ) ;
Invocation invocation
Invocation invocation
Invocation invocation
List < Invocation > allInvocations
Invocation invocation
given ( handler.invocationContainerImpl . findAnswerFor ( any ( Invocation . class ) ) ) . willReturn ( value ) ;
Invocation previous = new InvocationBuilder () . toInvocation () ;
Invocation actual = new InvocationBuilder () . toInvocation () ;
public String print ( Invocation invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
Invocation invocation
Invocation invocation
Object answerTo ( Invocation invocation ) throws Throwable { return findAnswerFor ( invocation ) . answer ( invocation ) ; }
Invocation invocation = invocationForStubbing . getInvocation () ;
Invocation actualInvocation = new InvocationBuilder () . toInvocation () ;
Invocation actual
Invocation actual
Invocation invocation
Invocation invocation
Invocation invocation
List < Invocation > unusedStubs
List < Invocation > unusedStubs
Invocation nullDereference
Invocation compareTo = this . getLastInvocation () ;
public MethodInfo ( PublicInvocation theInvocation ) { this . method = theInvocation . getMethod () ; }
PublicInvocation theInvocation
InvocationImpl compareTo = this . getLastInvocation () ;
List < InvocationImpl > allInvocations
InvocationImpl previous = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
InvocationImpl actual = new InvocationBuilder () . toInvocation () ;
List < InvocationImpl > getAllInvocations ( ) ;
List < InvocationImpl > getAllInvocations ( ) ;
public String print ( InvocationImpl invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
InvocationImpl invocation
InvocationImpl i
InvocationImpl candidate
InvocationImpl candidate
InvocationImpl actual
public InvocationImpl getInvocation () { return this . invocation ; }
public InvocationMatcher ( InvocationImpl invocation ) { this ( invocation , Collections . < Matcher > emptyList () ) ; }
InvocationImpl invocation
List < InvocationImpl > invocations
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
public void stubbingCompleted ( InvocationImpl invocation ) { threadSafely () . stubbingCompleted ( invocation ) ; }
public void markVerified ( InvocationImpl i ) { inOrderContext . markVerified ( i ) ; }
public boolean isVerified ( InvocationImpl i ) { return inOrderContext . isVerified ( i ) ; }
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
public void foundUnusedStub ( InvocationImpl unused ) { logger . log ( STRING_CONSTANT + unused . getLocation () + STRING_CONSTANT ) ; }
InvocationImpl unused
List < InvocationImpl > getInvocations ( ) ;
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocationOnInterface = new InvocationBuilder () . toInvocation () ;
InvocationImpl actual
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
List < InvocationImpl > unusedStubs
{ public InvocationMatcher bindMatchers ( ArgumentMatcherStorage argumentMatcherStorage , InvocationImpl invocation ) { throw new InvalidUseOfMatchersException () ; } }
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
public boolean isOut ( InvocationImpl invocation ) { return ! orderingContext . isVerified ( invocation ) ; }
public boolean isOut ( InvocationImpl invocation ) { return ! wanted . matches ( invocation ) ; }
InvocationImpl undesired
InvocationImpl undesired
List < InvocationImpl > chunk
InvocationImpl invocation
List < InvocationImpl > unusedStubs
List < InvocationImpl > unusedStubs
InvocationImpl invocationOnClass = getLastInvocation () ;
public boolean isOut ( InvocationImpl invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
public void add ( InvocationImpl invocation ) { invocations . add ( invocation ) ; }
public void markVerified ( InvocationImpl i ) { verified . add ( i ) ; }
public boolean isVerified ( InvocationImpl invocation ) { return verified . contains ( invocation ) ; }
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation
InvocationImpl actualInvocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = invocationForStubbing . getInvocation () ;
InvocationImpl actual
InvocationImpl actual
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
public LocationImpl getLocation () { return invocation . getLocation () ; }
LocationImpl lastLocation = finder . getLastLocation ( chunk ) ;
LocationImpl lastLocation = null ;
LocationImpl actualLocation
{ LocationImpl location = verificationMode . getLocation () ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; }
if ( stubbingInProgress != null ) { LocationImpl temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; }
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl lastActualLocation
LocationImpl lastLocation = finder . getLastLocation ( actualInvocations ) ;
LocationImpl location
LocationImpl lastActualLocation
LocationImpl lastActualLocation
LocationImpl lastActualInvocation
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl actualLocation
LocationImpl location
LocationImpl location
LocationImpl last = finder . getLastLocation ( invocations ) ;
LocationImpl actualLocation
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation
InvocationImpl invocation
for ( InvocationImpl i : unusedStubs ) { findingsListener . foundUnusedStub ( i ) ; }
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl previousInOrder = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
InvocationImpl invocation
Object answerTo ( InvocationImpl invocation ) throws Throwable { return findAnswerFor ( invocation ) . answer ( invocation ) ; }
InvocationImpl nullDereference
InvocationImpl invocation
InvocationImpl previous = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation
{ markVerified ( chunk , wanted ) ; for ( InvocationImpl i : chunk ) { context . markVerified ( i ) ; } }
InvocationImpl invocation
return new LinkedList < InvocationImpl > ( invocationsInOrder ) ;
assertNull ( finder . getLastLocation ( Collections . < InvocationImpl > emptyList () ) ) ;
synchronized ( invocations ) { copiedList = new LinkedList < InvocationImpl > ( invocations ) ; }
WarningsFinder finder = new WarningsFinder ( Arrays . < InvocationImpl > asList ( stub ) , Arrays . < InvocationMatcher > asList ( wrongArg ) ) ;
WarningsFinder finder = new WarningsFinder ( Arrays . < InvocationImpl > asList () , Arrays . < InvocationMatcher > asList ( unstubbedInvocation ) ) ;
{ new Reporter () . tooLittleActualInvocations ( new Discrepancy ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new InvocationBuilder () . toInvocation () , null ) ; }
Discrepancy discrepancy
Discrepancy discrepancy
Discrepancy discrepancy
Discrepancy discrepancy
STRING_CONSTANT + Pluralizer . pluralize ( wantedCount ) + STRING_CONSTANT
@ Override public void wantedButNotInvoked ( PrintableInvocation wanted ) { this . wanted = wanted ; }
PrintableInvocation invocation
public StubInfoImpl ( PrintableInvocation stubbedAt ) { this . stubbedAt = stubbedAt ; }
public void markStubUsed ( PrintableInvocation usedAt ) { this . usedAt = usedAt ; }
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
public void wantedButNotInvoked ( PrintableInvocation wanted ) { throw new WantedButNotInvoked ( createWantedButNotInvokedMessage ( wanted ) ) ; }
{ return new MockingDetails ( toInspect , new MockUtil () ) ; }
Invocation invocationOnClass = getLastInvocation () ;
InvocationTest . class
MockitoAnnotations.Mock annotation
{ return ( Answer < T > ) new ReturnsIdentity ( position ) ; }
new ReturnsIdentity ( NUMBER_CONSTANT )
{ validator . validate ( new ReturnsIdentity ( ReturnsIdentity.LAST_ARGUMENT ) , new InvocationBuilder () . simpleMethod () . toInvocation () ) ; fail () ; }
validator . validate ( new ReturnsIdentity ( NUMBER_CONSTANT ) , new InvocationBuilder () . method ( STRING_CONSTANT ) . arg ( STRING_CONSTANT ) . toInvocation () ) ;
{ ( ( Factory ) mock ) . setCallback ( NUMBER_CONSTANT , new MethodInterceptorFilter ( newHandler , settings ) ) ; }
MockitoInvocationHandler handler
InvocationNotifierHandler oldHandler = ( InvocationNotifierHandler ) mockMaker . getHandler ( mock ) ;
Class < > [] extraInterfaces
public MockSettingsImpl getMockSettings () { return mockHandler . getMockSettings () ; }
MockSettingsImpl settings
Class < > [] extraInterfaces
if ( isMockOrSpy ( instance ) ) { mockUtil . redefineMockNameIfSurrogate ( instance , field . getName () ) ; return instance ; }
MockSettingsImpl settings = oldHandler . getMockSettings () ;
mockUtil . redefineMockNameIfSurrogate ( mock , STRING_CONSTANT ) ;
mockUtil . redefineMockNameIfSurrogate ( mock , STRING_CONSTANT ) ;
public void validateExtraInterfaces ( Class classToMock , Class . . . interfaces ) { extraInterfacesValidated = true ; }
MockSettingsImpl mockSettings
@ SuppressWarnings ( STRING_CONSTANT ) MockHandler < > handler = new MockHandler () ;
T mock = mockUtil . createMock ( classToMock , ( MockSettingsImpl ) mockSettings ) ;
Class . . . extraInterfaces
name . isSurrogate ()
{ this . mockName = toInstanceName ( classToMock ) ; this . surrogate = true ; }
{ if ( getMockName ( mock ) . isSurrogate () ) { getMockHandler ( mock ) . getMockSettings () . redefineMockName ( newName ) ; } }
IMethods methods = mock ( IMethods . class , withSettings () . forwardTo ( new MethodsImpl () ) ) ;
List < String > mockedList = mock ( List . class , withSettings () . forwardTo ( delegatedList ) ) ;
List < String > mock = mock ( List . class , withSettings () . forwardTo ( delegatedList ) ) ;
List < String > mock = mock ( List . class , withSettings () . forwardTo ( delegatedList ) ) ;
MockSettingsInfo settings = oldHandler . getMockSettings () ;
MockSettingsInfo mockSettings
public MockSettingsInfo getMockSettings () { return mockHandler . getMockSettings () ; }
MockSettingsInfo settings
MockSettingsInfo settings
MockSettingsInfo settings
MockSettingsInfo mockSettings
{ mockingProgress . setListener ( null ) ; mockingProgress . mockingStarted ( null , null , null ) ; }
mockingProgress . mockingStarted ( mock , typeToMock , settings ) ;
MockHandler < T > mockHandler
MockHandlerTest . class
newHandler = new InvocationNotifierHandler < T > ( new MockHandler < T > ( settings ) , settings )
MockHandlerInterface mockitoHandler = cast ( handler ) ;
MockHandlerInterface handler
MockitoInvocationHandler newHandler
MockitoInvocationHandler handler
MockitoInvocationHandler newHandler
given ( iMethods . varargsObject ( eq ( NUMBER_CONSTANT ) , anyVararg () ) ) . will ( returnsArgAtPosition ( NUMBER_CONSTANT ) ) ;
MockHandlerImpl < T > mockHandler
{ return primitiveOf ( type ) ; }
result = NUMBER_CONSTANT * result + ( onClass != null ? onClass . hashCode () : NUMBER_CONSTANT ) ;
registerTypeVariablesOn ( clazz ) ;
return typeVariable . equals ( ( ( BoundedType ) o ) . typeVariable ) ;
< O extends K > O typeVarWithTypeParams ( ) ;
< S , T extends S > T twoTypeParams ( ) ;
List < ? super Integer > returningWildcard ( ) ;
public void setMockitoGenericMetadata ( MockitoGenericMetadata mockitoGenericMetadata ) { this . mockitoGenericMetadata = mockitoGenericMetadata ; }
public MockSettings parameterizedInfo ( MockitoGenericMetadata mockitoGenericMetadata ) { this . mockitoGenericMetadata = mockitoGenericMetadata ; return this ; }
MockitoGenericMetadata returnTypeGenericMetadata
{ VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
this . invocationContainerImpl = new InvocationContainerImpl ( mockingProgress ) ;
RegisteredInvocationsTest . class
RegisteredInvocationsAllTest . class
{ return mockSettings . isStubOnly () ? new RegisteredInvocationsStubOnly () : new RegisteredInvocationsAll () ; }
{ return mockSettings . isStubOnly () ? new RegisteredInvocationsStubOnly () : new DefaultRegisteredInvocations () ; }
catch ( NotAMockException e ) {}
@ After public void yesIKnowSomeMatchersAreMisplaced () { resetState () ; }
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingBecauseWrongStubbingSyntaxInConfigurationMethod . class ) ;
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingBecauseIncorrectStubbingSyntax . class ) ;
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingBecauseIncorrectAnnotationUsage . class ) ;
{ if ( mockitoGenericMetadata == null ) { this . mockitoGenericMetadata = GenericMetadataSupport . from ( typeToMock ) ; } return mockitoGenericMetadata ; }
GenericMetadataSupport genericMetadata = from ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = from ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = from ( StringBuilder . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , StringBuilder . class ) ) ;
GenericMetadataSupport genericMetadata = from ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = from ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
return recordDeepStubMock ( returnTypeGenericMetadata . toMock ( this ) , container ) ;
static MockMaker findPlatformMockMaker () { return findPluginImplementation ( MockMaker . class , new CglibMockMaker () ) ; }
if ( ! ClassImposterizer.INSTANCE . canImposterise ( clazz ) ) { return null ; }
{ if ( ! isTypeMockable ( classToMock ) ) { new Reporter () . cannotMockFinalClass ( classToMock ) ; } }
{ return mock ( returnTypeGenericMetadata . rawType () , withSettingsUsing ( returnTypeGenericMetadata ) ) ; }
if ( ! new MockCreationValidator () . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; }
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + pluginType , e ) ; }
NotSerializableToBeMocked ( Observable o ) { super ( o ) ; }
MockCreationSettings mockSettings = new MockUtil () . getMockHandler ( mockitoMock ) . getMockSettings () ;
public boolean isSpy ( Object mock ) { return mock instanceof MockitoSpy && isMock ( mock ) ; }
{ if ( Factory . class . isAssignableFrom ( cl ) ) { return STRING_CONSTANT ; } else { return STRING_CONSTANT ; } }
{ return ! STRING_CONSTANT . equals ( marker ) ; }
public boolean isMock ( Object mock ) { return mock instanceof MockitoMock ; }
public boolean isSpy ( Object mock ) { return mock instanceof MockitoSpy && isMock ( mock ) ; }
public boolean isMock ( Object mock ) { return mock != null && isMockitoMock ( mock ) ; }
catch ( ObjectStreamException e ) { Assertions . assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
{ SimpleSerializationUtil . serializeAndBack ( mockWithPrivateConstructor ) ; }
AClassToBeMockedInThisTestOnlyAndInCallablesOnly mock = Mockito . mock ( AClassToBeMockedInThisTestOnlyAndInCallablesOnly . class , Mockito . withSettings () . serializable () ) ;
this . serializable = copy.serializable ;
{ if ( mockUtil . isMock ( cl ) ) { return MOCKITO_PROXY_MARKER ; } else { return NOTHING ; } }
public boolean isMock ( Object mock ) { return mock instanceof MockitoMock && isMockitoMock ( mock ) ; }
verify ( mock , timeout ( NUMBER_CONSTANT ) . never () ) . clear () ;
public VerificationMode never () { new Reporter () . atMostShouldNotBeUsedWithTimeout () ; return null ; }
{ new Reporter () . atMostShouldNotBeUsedWithTimeout () ; return null ; }
verify ( target , timeout ( TEST_MILLIS ) . times ( TIMES * nThreads ) ) . targetMethod ( STRING_CONSTANT ) ;
public int getTreshhold () { return pollingPeriod ; }
{ return new After ( wrappedVerification . getDelay () , verificationMode ) ; }
{ return new Timeout ( wrappedVerification . getPollingPeriod () , wrappedVerification . getTimeout () , newVerificationMode ) ; }
{ super ( new VerificationWithTimeoutImpl ( pollingPeriod , millis , delegate ) ) ; }
{ return new After ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDelay () , verificationMode ) ; }
{ super ( new VerificationAfterDelayImpl ( pollingPeriod , delayMillis , verificationMode ) ) ; }
assertEquals ( expectedTimeout , ( ( Timeout ) t ) . wrappedVerification . getTimeout () ) ;
{ if ( canRecoverFromFailure ( delegate ) ) { error = e ; sleep ( pollingPeriod ) ; } else { throw e ; } }
ClassLoader cl = isolatedClassLoader () . withCurrentCodeSourceUrls () . withPrivateCopyOf ( STRING_CONSTANT ) . withPrivateCopyOf ( STRING_CONSTANT ) . build () ;
{ cl . loadClass ( STRING_CONSTANT ) ; }
{ cl . loadClass ( CLASS_NAME_USING_INTERFACE ) ; }
{ cl . loadClass ( CLASS_NAME_USING_INTERFACE ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
return mockSettings . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ;
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = typeVariable ; }
{ Type actualType = getActualTypeArgumentFor ( typeParameter ) ; actualTypeArguments . put ( typeParameter , actualType ) ; }
return wildCardBoundedType ;
return new TypeVarBoundedType ( typeParameter ) ;
{ for ( TypeVariable typeParameter : typeParameters ) { contextualActualTypeParameters . put ( typeParameter , boundsOf ( typeParameter ) ) ; } }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = new SerializableTypeVariable ( typeVariable ) ; }
{ Type actualType = getActualTypeArgumentFor ( typeParameter ) ; actualTypeArguments . put ( new SerializableTypeVariable ( typeParameter ) , actualType ) ; }
return new SerializableBoundedType ( wildCardBoundedType ) ;
return new SerializableBoundedType ( new TypeVarBoundedType ( typeParameter ) ) ;
{ return mockitoCore . mock ( returnTypeGenericMetadata . rawType () , withSettingsUsing ( returnTypeGenericMetadata ) ) ; }
private ReturnsDeepStubs returnsDeepStubsAnswerUsing ( final GenericMetadataSupport returnTypeGenericMetadata ) { return new NotSerializableGenericsAwareReturnsDeepStubs ( returnTypeGenericMetadata ) ; }
return makeDeepMock ( invocation , returnTypeGenericMetadata ) ;
{ return verify ( mock , mode ) ; }
public T should () { return verify ( mock ) ; }
{ return Mockito . verify ( mock , mode ) ; }
public T should () { return Mockito . verify ( mock ) ; }
{ if ( isEquals == false ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }
{ if ( isEquals == false ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }
if ( isEquals == false ) { return this ; }
{ return ( T ) primitiveOrWrapperDefaultValues . get ( primitiveOrWrapperType ) ; }
{ return primitiveOrWrapperDefaultValues . containsKey ( type ) ; }
{ if ( clazz . isPrimitive () ) { return clazz ; } return ( Class < T > ) primitiveTypes . get ( clazz ) ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnFalse () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnFalse () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnFalse () ; }
if ( ! cleaner . isOut ( unfilteredStackTrace . get ( i ) ) ) { continue; }
T extends Object
int delayMillis
int millis
int millis
public int getDuration () { return durationMillis ; }
public int getPollingPeriod () { return pollingPeriodMillis ; }
int sleep
{ verifyNoMoreInteractions ( null ) ; }
{ verifyNoMoreInteractions ( null ) ; }
{ inOrder ( null ) ; }
String expectedCause = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
String expectedCause = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
@ Override public int hashCode () { return method != null ? method . hashCode () : NUMBER_CONSTANT ; }
durationChecker . isVerificationStillInProgress ( startTime )
this . durationChecker = new DurationCheckerImpl ( durationMillis ) ;
when ( timer . isUp ( anyLong () ) ) . thenReturn ( true , true , true , true , true , false ) ;
public void reset () { mockingProgress . reset () ; }
Mockito . when ( clazzMock . isValid () ) . thenReturn ( true ) ;
catch ( MockitoException e ) { Assertions . assertThat ( e . getMessage () ) . contains ( MockitoLimitations.NON_PUBLIC_PARENT ) ; }
return recordDeepStubAnswer ( newDeepStubMock ( returnTypeGenericMetadata ) , container ) ;
{ return type == null ? STRING_CONSTANT : type . getCanonicalName () + STRING_CONSTANT + type . getClassLoader () + STRING_CONSTANT ; }
ClassImposterizer imposterizer = new ClassImposterizer ( new CachingObjenesisInstanceFactory () ) ;
return new ClassImposterizer ( new CachingObjenesisInstanceFactory () ) . imposterise ( new MethodInterceptorFilter ( mockitoHandler , settings ) , settings . getTypeToMock () , settings . getExtraInterfaces () ) ;
imposterizer = new ClassImposterizer ( new ConstructorInstanceFactory () ) ;
Factory proxy = instanceFactory . newInstance ( proxyClass ) ;
STRING_CONSTANT + instanceFactory . getClass () . getSimpleName ()
new ClassImposterizer ( new CachingObjenesisInstantiator () )
ClassImposterizer imposterizer = new ClassImposterizer ( new CachingObjenesisInstantiator () ) ;
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
ClassImposterizerTest . class
DefaultClassImposterizerTest . class
new DefaultClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
CglibClassImposterizerTest . class
new CglibClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
cglibHacker . setMockitoNamingPolicy ( mockitoMethodProxy ) ;
{ return methodProxy . invokeSuper ( target , arguments ) ; }
FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod ( mockitoMethodProxy ) ;
{ sourceJarComparator . addPair ( left , right ) ; }
boolean jars = sourceJarComparator . areEqual () ;
mock = mock ( List . class , delegatesTo ( new FakeListWithWrongMethods <> () ) )
mock = mock ( List . class , delegatesTo ( new FakeListWithWrongMethods <> () ) )
mock = mock ( List . class , delegatesTo ( new FakeList <> () ) )
mock = mock ( List . class , delegatesTo ( new FakeList <> () ) )
mock = mock ( List . class , delegatesTo ( new FakeList <> () ) )
{ return new ArrayList <> () ; }
{ return new ArrayList <> () ; }
BinaryComparator.Result result = binaryComparator . compareFiles () ;
{ binaryComparator . setPair ( left , right ) ; }
ClassImposterizer imposterizer = new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () ) ;
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
{ if ( settings . isUsingConstructor () ) { return new ConstructorInstantiator () ; } else { return INSTANCE ; } }
imposterizer = new ClassImposterizer ( new ConstructorInstantiator () ) ;
catch ( InstantationException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
{ if ( outerClassInstance == null ) { return noArgConstructor ( cls ) ; } return withOuterClass ( cls ) ; }
public String toString () { return author + STRING_CONSTANT + commits . size () ; }
{ email = commit . getEmail () ; author = commit . getAuthor () ; commits . add ( commit ) ; }
public String getEmail () { return email ; }
GitCommit commit
GitCommit commit
{ return new GitContributionsProvider ( runner ) ; }
{ return new GitContributionsProvider ( new GitLogProvider ( runner ) ) ; }
DefaultContributionSet contributions = new DefaultContributionSet () ;
if ( commit . getMessage () . contains ( STRING_CONSTANT ) ) { return; }
Map.Entry < String , DefaultContribution > entry
if ( ! m . matches () ) { throw new ReleaseNotesException ( STRING_CONSTANT + releaseNotesContent ) ; }
if ( out == null ) { throw new ReleaseNotesException ( STRING_CONSTANT + envVariableName + STRING_CONSTANT ) ; }
int id
public GitHubImprovementsProvider ( GitHubAuthToken authToken ) { this . authToken = authToken ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return new GloballyConfiguredAnswer () . answer ( invocation ) ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return Answers.CALLS_REAL_METHODS . get () . answer ( invocation ) ; }
String content = IOUtil . readStream ( response ) ;
catch ( NoSuchMethodException noDefaultConstructor ) { throw new MockitoException ( STRING_CONSTANT + type ) ; }
{ return new Then < T > ( mock ) ; }
try { closeable . close () ; } catch ( IOException e ) { throw new MockitoException ( STRING_CONSTANT + closeable ) ; }
catch ( IOException e ) { throw new MockitoException ( STRING_CONSTANT + reader ) ; }
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + output ) ; }
assertEquals ( asList ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , IOUtil . readLines ( new FileReader ( file ) ) ) ;
if ( ! pluginSwitcher . isEnabled ( pluginClassName ) ) { continue; }
String foundPluginClass = new PluginFinder ( pluginSwitcher ) . findPluginClass ( Iterables . toIterable ( resources ) ) ;
LinkedList < ReleaseStep > targets = new LinkedList < ReleaseStep > () ;
{ jUnitRule . apply ( new ExceptionStatement () , Description.EMPTY ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
{ injectTestCase = new InjectTestCase () ; jUnitRule = new JUnitRule ( injectTestCase ) ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return Answers.RETURNS_DEFAULTS . get () . answer ( invocation ) ; }
mockSettings . defaultAnswer ( annotation . answer () . get () ) ;
Operation getStep ( int stepNumber ) ;
return new DefaultGitAuthor ( currentLocalUser , currentLocalEmail ) ;
{ return ( Collection ) reportMatcher ( Any.ANY ) . returnList () ; }
{ return reportMatcher ( Any.ANY ) . returnList () ; }
{ return reportMatcher ( Any.ANY ) . returnMap () ; }
{ return reportMatcher ( Any.ANY ) . returnMap () ; }
{ return ( Set ) reportMatcher ( Any.ANY ) . returnSet () ; }
{ return reportMatcher ( Any.ANY ) . returnSet () ; }
{ return ( List ) reportMatcher ( Any.ANY ) . returnList () ; }
{ return reportMatcher ( Any.ANY ) . returnList () ; }
{ return reportMatcher ( Any.ANY ) . returnString () ; }
{ return ( T ) anyObject () ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnFor ( clazz ) ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnNull () ; }
{ return reportMatcher ( Any.ANY ) . returnZero () ; }
{ return reportMatcher ( Any.ANY ) . returnZero () ; }
{ return reportMatcher ( Any.ANY ) . returnZero () ; }
{ return reportMatcher ( Any.ANY ) . returnZero () ; }
{ return reportMatcher ( Any.ANY ) . returnZero () ; }
{ return reportMatcher ( Any.ANY ) . returnChar () ; }
{ return reportMatcher ( Any.ANY ) . returnZero () ; }
{ return reportMatcher ( Any.ANY ) . returnFalse () ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnNull () ; }
{ return ( T ) reportMatcher ( new InstanceOf ( clazz ) ) . returnFor ( clazz ) ; }
{ return ( T ) reportMatcher ( new InstanceOf ( Object . class ) ) . returnNull () ; }
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public static VersionTool getVersionTool () { return new DefaultVersionTool () ; }
int millis
public ClassLoader build () { return new InMemoryClassLoader ( inMemoryClassObjects ) ; }
catch ( ArgumentsAreDifferent e ) { error = handleVerifyException ( e ) ; }
if ( paramsMatch ( types , params ) ) { return ( T ) constructor . newInstance ( params ) ; }
catch ( InstantationException e ) { throw new MockitoException ( STRING_CONSTANT + proxyClass . getSuperclass () . getSimpleName () + STRING_CONSTANT , e ) ; }
int result = mockType . hashCode () ;
if ( ! mockType . equals ( mockKey.mockType ) ) return false ;
Class < > mockedType
{ return ( Class < ? extends T > ) previousClasses . get ( mockKey ) ; }
@ Origin Method method
@ Origin Method method
@ Origin Method method
Class < > proxyClass = new ByteBuddyMockMaker () . getOrMakeMock ( typeToMock , extraInterfaces , true ) ;
{ return ( Class < ? extends T > ) PREVIOUS_CLASSES . get ( mockKey ) ; }
PREVIOUS_CLASSES . put ( mockKey , mockType ) ;
T mock = silentConstructor . instantiate ( mockedType ) ;
if ( ! ( handler instanceof InternalMockHandler ) ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
Class < > proxyClass = new ByteBuddyMockMaker () . getOrMakeMock ( typeToMock , extraInterfaces ) ;
Class < > proxyClass = new CachingBytecodeGenerator () . get ( typeToMock , extraInterfaces ) ;
assumeTrue ( cache . size () == NUMBER_CONSTANT ) ;
assumeTrue ( cachingMockBytecodeGenerator.avoidingClassLeakageCache . size () == NUMBER_CONSTANT ) ;
byteBuddy . subclass ( mockedType , ConstructorStrategy.Default.NO_CONSTRUCTORS ) . name ( nameFor ( mockedType ) )
{ return thiz . getMockitoInterceptor () . getAcrossJVMSerializationFeature () . writeReplace ( thiz ) ; }
{ this . handler = handler ; this . mockCreationSettings = mockCreationSettings ; acrossJVMSerializationFeature = new AcrossJVMSerializationFeature () ; }
ClassImposterizerTest . class
Collections . sort ( unsortedFields , new PropertyAndSetterInjection.FieldTypeAndNameComparator () ) ;
Collections . sort ( unsortedFields , new PropertyAndSetterInjection.FieldTypeAndNameComparator () ) ;
Collections . sort ( unsortedFields , cmp ) ;
Collections . sort ( declaredFields , superTypesLast ) ;
ArrayList < Improvement > pagedImprovements = new ArrayList <> () ;
STRING_CONSTANT + mockMethod + STRING_CONSTANT + new MockUtil () . getMockName ( mock )
STRING_CONSTANT + mockMethod + STRING_CONSTANT + new MockUtil () . getMockName ( mock )
STRING_CONSTANT + new MockUtil () . getMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT
STRING_CONSTANT + new MockUtil () . getMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT
new VerificationInOrderFailure ( join ( STRING_CONSTANT , new LocationImpl () , STRING_CONSTANT + undesired . getMock () + STRING_CONSTANT , undesired . getLocation () ) )
join ( STRING_CONSTANT , new LocationImpl () , STRING_CONSTANT + undesired . getMock () + STRING_CONSTANT , undesired . getLocation () , scenario )
@ Before public void setup () { mock = Mockito . mock ( IMethods . class ) ; }
try { validator . validate ( new CallsRealMethods () , invocationOnInterface ) ; fail () ; } catch ( MockitoException e ) {}
catch ( MockitoException e ) {}
{ try { Thread . sleep ( sleep ) ; } catch ( InterruptedException ie ) {} }
{ this ( pollingPeriodMillis , durationMillis , delegate , returnOnSuccess , new Timer ( durationMillis ) ) ; }
{ return new After ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDuration () , verificationMode ) ; }
{ return new Timeout ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDuration () , newVerificationMode ) ; }
{ super ( new VerificationOverTimeImpl ( pollingPeriodMillis , millis , delegate , true ) ) ; }
@ Origin ( cacheMethod = true ) Method invokedMethod
@ Origin ( cacheMethod = true ) Method invokedMethod
@ Origin ( cacheMethod = true ) Method invokedMethod
ArrayList < Improvement > pagedImprovements = new ArrayList <> () ;
Object injected = mockCandidateFilter . filterCandidate ( mocks , field , instance ) . thenInject () ;
try { argument . getValue () ; fail () ; } catch ( MockitoException e ) {}
CapturesArgumensFromInvocation wanted
CapturesArgumensFromInvocation wanted
CapturesArgumensFromInvocation wanted
Mockito . verify ( c.invocationMarker ) . markVerified ( eq ( asList ( invocation ) ) , any ( CapturesArgumensFromInvocation . class ) ) ;
{ injectionOccurred |= injectMockCandidates ( fieldClass , newMockSafeHashSet ( mockCandidates ) , fieldInstanceNeedingInjection ) ; fieldClass = fieldClass . getSuperclass () ; }
{ ( ( MockMethodInterceptor.MockAccess ) mock ) . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( newHandler ) , settings ) ) ; }
MockMethodInterceptor.MockAccess mockAccess = ( MockMethodInterceptor.MockAccess ) mockInstance ;
if ( interceptor == null ) { return null ; }
{ return StringDescription . toString ( m ) . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
{ ContainsExtraTypeInformation equals = new Equals ( NUMBER_CONSTANT ) ; assertFalse ( equals . typeMatches ( null ) ) ; }
{ ContainsExtraTypeInformation equals = new Equals ( null ) ; assertFalse ( equals . typeMatches ( NUMBER_CONSTANT ) ) ; }
ContainsExtraTypeInformation equals = new Equals ( NUMBER_CONSTANT ) ;
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . withExtraTypeInfo () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . withExtraTypeInfo () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertSame ( m , m . withExtraTypeInfo () ) ; }
ContainsExtraTypeInformation equals10 = new Equals ( NUMBER_CONSTANT ) ;
{ return new MatchersPrinter () . print ( m ) . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
Class classToMock
Class classToMock
Class classToMock
Class classToMock
the_mock_type = cachingMockBytecodeGenerator . get ( withMockFeatures ( classloader_with_life_shorter_than_cache . loadClass ( STRING_CONSTANT ) , Collections . < Class > emptySet () , false ) )
Set < Class > extraInterfaces
Set < Class > interfaces
Set < Class > interfaces
Set < Class > interfaces
Set < Class > interfaces
Set < Class > extraInterfaces
{ byteBuddy = new ByteBuddy ( ClassFileVersion.JAVA_V5 ) . withDefaultMethodAttributeAppender ( MethodAttributeAppender.ForInstrumentedMethod.INSTANCE ) . withAttribute ( TypeAttributeAppender.ForSuperType.INSTANCE ) ; random = new Random () ; }
Matcher m
Matcher m = matchers . get ( position ) ;
List < Matcher > matchers
Matcher m
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( describe ( m ) , m . getTypedDescription () ) ; }
if ( actualMatcher instanceof ContainsTypedDescription ) { return ( ( ContainsTypedDescription ) actualMatcher ) . getTypedDescription () ; } else { return HamcrestPrinter . print ( actualMatcher ) ; }
Matcher actualMatcher
List < Matcher > matchers
{ for ( Matcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < Matcher > matchers ) { this . matchers = matchers ; }
InvocationMatcher invocationWithMatchers = new InvocationMatcher ( invocation , ( List < Matcher > ) ( List ) lastMatchers ) ;
Matcher matcher
{ for ( Matcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < Matcher > matchers ) { this . matchers = matchers ; }
private static HandyReturnValues reportMatcher ( ArgumentMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
private static HandyReturnValues reportMatcher ( Matcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
Matcher < Double > matcher
Matcher < Float > matcher
Matcher < Long > matcher
Matcher < Integer > matcher
Matcher < Short > matcher
Matcher < Byte > matcher
Matcher < Boolean > matcher
Matcher < Character > matcher
assertEquals ( name + STRING_CONSTANT , describe ( compareTo ) ) ;
public Not ( Matcher first ) { this . first = first ; }
{ String descStr = describe ( new Equals ( null ) ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( CHAR_CONS ) ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( STRING_CONSTANT ) ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
@ Test public void matchesToString () { assertEquals ( STRING_CONSTANT , describe ( new Matches ( STRING_CONSTANT ) ) ) ; }
@ Test public void findToString () { assertEquals ( STRING_CONSTANT , describe ( new Find ( STRING_CONSTANT ) ) ) ; }
@ Test public void containsToString () { assertEquals ( STRING_CONSTANT , describe ( new Contains ( STRING_CONSTANT ) ) ) ; }
@ Test public void endsWithToString () { assertEquals ( STRING_CONSTANT , describe ( new EndsWith ( STRING_CONSTANT ) ) ) ; }
@ Test public void startsWithToString () { assertEquals ( STRING_CONSTANT , describe ( new StartsWith ( STRING_CONSTANT ) ) ) ; }
@ Test public void notToString () { assertEquals ( STRING_CONSTANT , describe ( new Not ( new Equals ( NUMBER_CONSTANT ) ) ) ) ; }
assertEquals ( STRING_CONSTANT , describe ( new Equals ( o ) ) ) ;
@ Test public void equalsToStringWithChar () { assertEquals ( STRING_CONSTANT , describe ( new Equals ( CHAR_CONS ) ) ) ; }
@ Test public void equalsToStringWithString () { assertEquals ( STRING_CONSTANT , describe ( new Equals ( STRING_CONSTANT ) ) ) ; }
assertEquals ( STRING_CONSTANT , describe ( new Same ( o ) ) ) ;
@ Test public void sameToStringWithChar () { assertEquals ( STRING_CONSTANT , describe ( new Same ( CHAR_CONS ) ) ) ; }
@ Test public void sameToStringWithString () { assertEquals ( STRING_CONSTANT , describe ( new Same ( STRING_CONSTANT ) ) ) ; }
public String describe () { return STRING_CONSTANT ; }
public String describe () { return STRING_CONSTANT ; }
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( m . describe () , m . getTypedDescription () ) ; }
ContainsTypedDescription equals10 = new Equals ( NUMBER_CONSTANT ) ;
{ ContainsTypedDescription equals = new Equals ( NUMBER_CONSTANT ) ; assertFalse ( equals . typeMatches ( null ) ) ; }
{ ContainsTypedDescription equals = new Equals ( null ) ; assertFalse ( equals . typeMatches ( NUMBER_CONSTANT ) ) ; }
ContainsTypedDescription equals = new Equals ( NUMBER_CONSTANT ) ;
{ String descStr = new Equals ( null ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( CHAR_CONS ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
Equals matcherWithBadDescription = new Equals ( NUMBER_CONSTANT ) { public String describe () { return STRING_CONSTANT ; } } ;
{ return reportMatcher ( new Find ( regex ) ) . < String > returnNull () ; }
public String describe () { return describe ( wanted ) ; }
assertEquals ( name + STRING_CONSTANT , compareTo . describe () ) ;
@ Test public void matchesToString () { assertEquals ( STRING_CONSTANT , new Matches ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void findToString () { assertEquals ( STRING_CONSTANT , new Find ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void containsToString () { assertEquals ( STRING_CONSTANT , new Contains ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void endsWithToString () { assertEquals ( STRING_CONSTANT , new EndsWith ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void startsWithToString () { assertEquals ( STRING_CONSTANT , new StartsWith ( STRING_CONSTANT ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new And ( matchers ) . describe () ) ;
@ Test public void notToString () { assertEquals ( STRING_CONSTANT , new Not ( new Equals ( NUMBER_CONSTANT ) ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new Or ( matchers ) . describe () ) ;
assertEquals ( STRING_CONSTANT , new Equals ( o ) . describe () ) ;
@ Test public void equalsToStringWithChar () { assertEquals ( STRING_CONSTANT , new Equals ( CHAR_CONS ) . describe () ) ; }
@ Test public void equalsToStringWithString () { assertEquals ( STRING_CONSTANT , new Equals ( STRING_CONSTANT ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new Same ( o ) . describe () ) ;
@ Test public void sameToStringWithChar () { assertEquals ( STRING_CONSTANT , new Same ( CHAR_CONS ) . describe () ) ; }
@ Test public void sameToStringWithString () { assertEquals ( STRING_CONSTANT , new Same ( STRING_CONSTANT ) . describe () ) ; }
{ return m . describe () . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
public String describe () { return STRING_CONSTANT ; }
public String describe () { return STRING_CONSTANT ; }
out . append ( new Equals ( array [ i ] ) . describe () ) ;
public String describe () { return STRING_CONSTANT ; }
public String describe () { return STRING_CONSTANT ; }
{ out . add ( new FormattedText ( matcher . toString () ) ) ; }
{ for ( MockitoMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < MockitoMatcher > matchers ) { this . matchers = matchers ; }
List < MockitoMatcher > matchers
List < MockitoMatcher > matchers
MockitoMatcher m
MockitoMatcher m
private static HandyReturnValues reportMatcher ( MockitoMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
MockitoMatcher < Double > matcher
MockitoMatcher < Float > matcher
MockitoMatcher < Long > matcher
MockitoMatcher < Integer > matcher
MockitoMatcher < Short > matcher
MockitoMatcher < Byte > matcher
MockitoMatcher < Boolean > matcher
MockitoMatcher < Character > matcher
MockitoMatcher matcher
MockitoMatcher m
MockitoMatcher m = matchers . get ( position ) ;
List < MockitoMatcher > matchers
private static HandyReturnValues reportMatcher ( MockitoMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
MockitoMatcher matcher
MockitoMatcher matcher
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , Arrays . < MockitoMatcher > asList ( new Equals ( NUMBER_CONSTANT ) , m ) ) ;
{ for ( MockitoMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < MockitoMatcher > matchers ) { this . matchers = matchers ; }
List < MockitoMatcher > matchers
public Not ( MockitoMatcher first ) { this . first = first ; }
@ After public void resetState () { super . resetState () ; }
{ return MOCKITO_CORE . doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return MOCKITO_CORE . doAnswer ( new DoesNothing () ) ; }
{ return MOCKITO_CORE . doAnswer ( answer ) ; }
{ return MOCKITO_CORE . doAnswer ( new CallsRealMethods () ) ; }
if ( throwables == null ) { thenThrow ( ( Throwable ) null ) ; }
assertEquals ( expectedMock , returnedMock ) ;
assertEquals ( STRING_CONSTANT , dog . bark () ) ;
assertEquals ( STRING_CONSTANT , dog . bark () ) ;
public ThrowsExceptionClass ( Class < ? extends Throwable > throwableClass ) { this . throwableClass = throwableClass ; }
verify ( mock ) . simpleMethod ( anyObject () ) ;
when ( mock . oneArg ( anyObject () ) ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . oneArg ( anyObject () ) ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . oneArg ( any () ) ) . thenReturn ( STRING_CONSTANT ) ;
Instantiator instantiator = new InstantiatorProvider () . getInstantiator ( settings ) ;
byteBuddy = new ByteBuddy () . withDefaultMethodAttributeAppender ( new MethodAttributeAppender.ForInstrumentedMethod ( AnnotationAppender.ValueFilter.AppendDefaults.INSTANCE ) ) . withAttribute ( new TypeAttributeAppender.ForSuperType ( AnnotationAppender.ValueFilter.AppendDefaults.INSTANCE ) ) ;
for ( AllTestsRunner t : threads ) { t . join () ; failed = failed ? true : t . isFailed () ; }
{ pomComparator . setPair ( left , right ) ; }
ContributionsProvider contributionsProvider = Vcs . getGitProvider ( Exec . getProcessRunner ( workDir ) ) ;
ContributionsProvider contributionsProvider = Vcs . getGitProvider ( Exec.INSTANCE . getProcessRunner ( workDir ) ) ;
public MockBytecodeGenerator () { byteBuddy = new ByteBuddy () ; random = new Random () ; }
runner . addListener ( new TextListener ( System.out ) ) ;
{ return invocation . getMock () == invocation . getArguments () [ NUMBER_CONSTANT ] ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
String arg = ( String ) invocation . getArguments () [ NUMBER_CONSTANT ] ;
{ ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; }
int secondArgument = invocationOnInterface . getArgumentAt ( NUMBER_CONSTANT , int . class ) ;
{ validateIndexWithinInvocationRange ( invocation ) ; return invocation . getArguments () [ actualArgumentPosition ( invocation ) ] ; }
ImportLogBean bean = ( ImportLogBean ) invocation . getArguments () [ NUMBER_CONSTANT ] ;
{ return ( String ) invocation . getArguments () [ NUMBER_CONSTANT ] ; }
{ return ( String ) invocation . getArguments () [ NUMBER_CONSTANT ] ; }
{ return ( String ) invocation . getArguments () [ NUMBER_CONSTANT ] ; }
runner = new MockitoJUnit44Runner ( DummyTest . class ) ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
{ try { new ReturnsElementsOf ( null ) ; fail () ; } catch ( MockitoException e ) {} }
{ this . jUnitRule = new JUnitRule () ; }
{ assertEquals ( STRING_CONSTANT , e . getMessage () ) ; assertTrue ( logger . getLoggedInfo () . startsWith ( STRING_CONSTANT ) ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , listener . getStubbingInfo () ) ;
{ ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; }
assertThat ( mock , is ( List . class ) ) ;
{ return CoreMatchers . is ( type ) ; }
assertThat ( runner , is ( JUnit45AndHigherRunnerImpl . class ) ) ;
assertThat ( runner , is ( JUnit44RunnerImpl . class ) ) ;
assertTrue ( result . wasSuccessful () ) ;
{ return runnerProvider . newInstance ( STRING_CONSTANT , klass ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { runner . filter ( filter ) ; }
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
public void reportOngoingStubbing ( IOngoingStubbing iOngoingStubbing ) { threadSafely () . reportOngoingStubbing ( iOngoingStubbing ) ; }
stubVoid ( mock ) . toAnswer ( recordCall ) . on () . voidMethod () ;
stubVoid ( mock ) . toThrow ( new RuntimeException () ) . on () . clone () ;
stubVoid ( mock ) . toThrow ( new RuntimeException () ) . on () . clone () ;
stubVoid ( mock ) . toThrow ( expected ) . on () . clear () ;
{ return CoreMatchers . isA ( ( Class ) type ) ; }
{ jUnitRule . apply ( new UnfinishedStubbingStatement () , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
{ jUnitRule . apply ( new ExceptionStatement () , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
jUnitRule . apply ( new DummyStatement () , injectTestCase ) . evaluate () ;
{ return new MockitoJUnitRule () ; }
public VerificationCollectorImpl () { this . resetBuilder () ; }
collector . verify ( methods ) . simpleMethod () ;
{ IMethods methods = mock ( IMethods . class ) ; collector . verify ( methods ) . simpleMethod () ; }
MockHandler newHandler = new MockHandlerFactory () . create ( settings ) ;
MockHandler mockHandler = new MockHandlerFactory () . create ( settings ) ;
{ new FieldSetter ( testClass , field ) . set ( mock ) ; }
new FieldSetter ( descInstance , classNameField ) . set ( proxyClass . getCanonicalName () ) ;
{ new FieldSetter ( instance , field ) . set ( value ) ; }
{ new FieldSetter ( testInstance , field ) . set ( mock ) ; }
new FieldSetter ( testClass , field ) . set ( newFieldInstance ) ;
new FieldSetter ( testClass , field ) . set ( newFieldInstance ) ;
if ( ! new BeanPropertySetter ( injectee , candidateFieldToBeInjected ) . set ( matchingMock ) ) { new FieldSetter ( injectee , candidateFieldToBeInjected ) . set ( matchingMock ) ; }
InternalMockHandler handler = new MockHandlerFactory () . create ( settings ) ;
InternalMockHandler handler = new MockHandlerFactory () . create ( settings ) ;
catch ( Throwable listenerThrowable ) { new Reporter () . invocationListenerThrewException ( listener , listenerThrowable ) ; }
catch ( Throwable listenerThrowable ) { new Reporter () . invocationListenerThrewException ( listener , listenerThrowable ) ; }
public NumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () , new Reporter () ) ; }
if ( expectedMatchersSize != recordedMatchersSize ) { new Reporter () . invalidUseOfMatchers ( expectedMatchersSize , lastMatchers ) ; }
{ if ( ! superMethod . isInvokable () ) { new Reporter () . cannotCallAbstractRealMethod () ; } return superMethod . invoke () ; }
{ if ( argumentPosition != LAST_ARGUMENT && argumentPosition < NUMBER_CONSTANT ) { new Reporter () . invalidArgumentRangeAtIdentityAnswerCreationTime () ; } return argumentPosition ; }
if ( unverified != null ) { new Reporter () . noMoreInteractionsWantedInOrder ( unverified ) ; }
public NonGreedyNumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () , new Reporter () , new InvocationMarker () ) ; }
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { reporter . mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
if ( stubbing == null ) { mockingProgress . reset () ; reporter . missingMethodInvocation () ; }
{ this . defaultAnswer = defaultAnswer ; if ( defaultAnswer == null ) { new Reporter () . defaultAnswerDoesNotAcceptNullParameter () ; } return this ; }
{ if ( alreadyAssigned ) { new Reporter () . moreThanOneAnnotationNotAllowed ( field . getName () ) ; } }
if ( o . isToString ( wanted . getMethod () ) ) { new Reporter () . cannotVerifyToString () ; }
catch ( RuntimeException e ) { new Reporter () . cannotInjectDependency ( candidateFieldToBeInjected , matchingMock , e ) ; }
{ if ( alreadyAssigned ) { new Reporter () . moreThanOneAnnotationNotAllowed ( field . getName () ) ; } }
{ if ( usingConstructor && mode == SerializableMode.ACROSS_CLASSLOADERS ) { new Reporter () . usingConstructorWithFancySerializable ( mode ) ; } }
if ( delegatedInstance . getClass () . isAssignableFrom ( classToMock ) ) { new Reporter () . mockedTypeIsInconsistentWithDelegatedInstanceType ( classToMock , delegatedInstance ) ; }
if ( ! classToMock . equals ( spiedInstance . getClass () ) ) { new Reporter () . mockedTypeIsInconsistentWithSpiedInstanceType ( classToMock , spiedInstance ) ; }
for ( Class i : extraInterfaces ) { if ( classToMock == i ) { new Reporter () . extraInterfacesCannotContainMockedType ( classToMock ) ; } }
{ if ( mockSettings . isStubOnly () ) { new Reporter () . stubPassedToVerify () ; } return new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; }
if ( ! invocationContainerImpl . hasInvocationForPotentialStubbing () ) { new Reporter () . incorrectUseOfApi () ; }
{ if ( ! methodInfo . isVoid () ) { reporter . onlyVoidMethodsCanBeSetToDoNothing () ; } }
{ if ( methodInfo . isAbstract () ) { reporter . cannotCallAbstractRealMethod () ; } }
if ( foundSize > maxNumberOfInvocations ) { new Reporter () . wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; }
{ if ( method . isAbstract () ) { new Reporter () . cannotCallAbstractRealMethod () ; } return realMethod . invoke ( mock , rawArguments ) ; }
public MissingInvocationChecker () { this ( new InvocationsFinder () , new Reporter () ) ; }
if ( throwableClass == null || ! Throwable . class . isAssignableFrom ( throwableClass ) ) { new Reporter () . notAnException () ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { new Reporter () . invocationListenerDoesNotAcceptNullParameters () ; }
for ( StackTraceElement element : target ) { if ( CLEANER . apply ( element ) ) { filtered . add ( element ) ; } }
{ assertThat ( cleaner . apply ( type ( className ) ) ) . describedAs ( STRING_CONSTANT , className ) . isFalse () ; }
{ assertThat ( cleaner . apply ( type ( className ) ) ) . describedAs ( STRING_CONSTANT , className ) . isTrue () ; }
invocationMarker . markVerified ( actualInvocations , wanted ) ;
marker . markVerified ( next , wanted ) ;
public NonGreedyNumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () , new InvocationMarker () ) ; }
marker . markVerified ( chunk . get ( NUMBER_CONSTANT ) , wantedMatcher ) ;
invocationMarker . markVerifiedInOrder ( chunk , wanted , context ) ;
invocationMarker . markVerifiedInOrder ( chunk , wanted , orderingContext ) ;
invocationMarker . markVerified ( actualInvocations , wanted ) ;
invocationMarker . markVerified ( found , wanted ) ;
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnFalse () ; }
{ return reportMatcher ( matcher ) . returnChar () ; }
HandyReturnValues reportMatcher ( ArgumentMatcher matcher ) ;
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnFalse () ; }
{ return reportMatcher ( matcher ) . returnChar () ; }
{ return reportMatcher ( matcher ) . < T > returnNull () ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . returnString () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . returnString () ; }
{ return reportMatcher ( new Matches ( regex ) ) . returnString () ; }
{ return reportMatcher ( new Contains ( substring ) ) . returnString () ; }
{ return ( T ) reportMatcher ( NotNull.NOT_NULL ) . returnNull () ; }
{ return reportMatcher ( NotNull.NOT_NULL ) . returnNull () ; }
{ return ( T ) reportMatcher ( Null.NULL ) . returnNull () ; }
{ return reportMatcher ( Null.NULL ) . returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnChar () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnFalse () ; }
{ return ( T ) reportMatcher ( AnyVararg.ANY_VARARG ) . returnNull () ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnNull () ; }
{ Mockito . argThat ( capturingMatcher ) ; return handyReturnValues . returnFor ( clazz ) ; }
{ return Primitives . defaultValueForPrimitiveOrWrapper ( type ) ; }
assertNull ( new ThreadSafeMockingProgress () . pullOngoingStubbing () ) ;
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnFalse () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnFalse () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnFalse () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new Find ( regex ) ) . returnNull () ; }
{ if ( ENABLED && candidate . getMethodName () . contains ( STRING_CONSTANT ) ) { return false ; } return defaultCleaner . isOut ( candidate ) ; }
Object argument
Object argument
new ArgumentMatcher < String > () { public boolean matches ( Object argument ) { return true ; } }
public void setAnswersForStubbing ( List < Answer > answers ) { answersForStubbing . addAll ( answers ) ; }
Class clazz
public InOrderImpl ( List < Object > mocksToBeVerifiedInOrder ) { this . mocksToBeVerifiedInOrder . addAll ( mocksToBeVerifiedInOrder ) ; }
Map map () { return null ; }
LinkedList linkedList () { return null ; }
List list () { return null ; }
List < Answer > answers
public void setAnswersForStubbing ( List < Answer > answers ) { mockHandler . setAnswersForStubbing ( answers ) ; }
MockCreationSettings settings
assertEquals ( ( Double ) NUMBER_CONSTANT , captor . getValue () ) ;
Long longPretendingAnInt = new Long ( NUMBER_CONSTANT ) ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( new HamcrestArgumentMatcher ( matcher ) ) ; }
assertFalse ( mockUtil . isSpy ( ( Class ) null ) ) ;
void setAnswersForStubbing ( List < Answer > answers ) ;
public int compareTo ( HasCompare redHerring ) ;
public int foo ( HasCompare other ) ;
public int compareTo ( HasCompareToButDoesNotImplementComparable other ) ;
Assert . assertNotNull ( readObject ) ;
public NullResultGuardian ( InternalMockHandler delegate ) { this . delegate = delegate ; }
verify ( mock ) . simpleMethod ( ( Object ) anyObject () ) ;
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + pluginType , e ) ; }
Class classToMock
int secondArgument = invocationOnInterface . getArgument ( NUMBER_CONSTANT ) ;
void reportMatcher ( ArgumentMatcher matcher ) ;
void mockingStarted ( Object mock , Class classToMock ) ;
void mockingStarted ( Object mock , Class classToMock ) ;
OngoingStubbing pullOngoingStubbing ( ) ;
void reportOngoingStubbing ( OngoingStubbing ongoingStubbing ) ;
Class classToMock
public void reportOngoingStubbing ( OngoingStubbing iOngoingStubbing ) { threadSafely () . reportOngoingStubbing ( iOngoingStubbing ) ; }
public ArgumentMatcher getMatcher () { return matcher ; }
ArgumentMatcher matcher
createdMocks = new LinkedList () ;
public void mockingStarted ( Object mock , Class classToMock ) { toBeFilled . add ( mock ) ; }
public CollectCreatedMocks ( List toBeFilled ) { this . toBeFilled = toBeFilled ; }
Class expected
{ copy ( from , to , from . getClass () , to . getClass () ) ; }
Class actualType
Class lhsClass = lhs . getClass () ;
Class reflectUpToClass
Class typeToMock
Iterable < String > lines
new SerializableMethod ( type . getMethod ( methodName , new Class [ NUMBER_CONSTANT ] ) )
Class classToMock
Class mockedType
Class type
Class [] argTypes
{ mock ( IMethods . class , withSettings () . extraInterfaces ( ( Class [] ) null ) ) ; }
for ( Class anInterface : interfaces ) { types . add ( anInterface . getName () ) ; }
for ( Class i : extraInterfaces ) { if ( classToMock == i ) { throw extraInterfacesCannotContainMockedType ( classToMock ) ; } }
Class currentExploredClass = clazz
Class type
{ mock . add ( String . valueOf ( i ) ) ; }
Answer answer
Answer answer
public BDDStubber will ( Answer answer ) { return new BDDStubberImpl ( mockitoStubber . doAnswer ( answer ) ) ; }
public BDDStubber willAnswer ( Answer answer ) { return new BDDStubberImpl ( mockitoStubber . doAnswer ( answer ) ) ; }
Answer answer
Answer answer
return ( List ) matchers ;
HoldingAReference ( WeakReference < Class > a ) { this . a = a ; }
Class . . . extraInterfaces
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedDifferentMethod ) ) ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedSimpleMethod ) ) ;
Invocation unverified = new InvocationsFinder () . findFirstUnverifiedInOrder ( data . getOrderingContext () , invocations ) ;
Invocation unverified = new InvocationsFinder () . findFirstUnverified ( data . getAllInvocations () ) ;
Invocation next = finder . findFirstMatchingUnverifiedInvocation ( invocations , wanted , context ) ;
public int size ( Collection collection ) { return collection . size () ; }
public int size ( Map map ) { return map . size () ; }
verify ( ( Iterable ) iterable ) . iterator () ;
Assert . assertNotNull ( ( ( Iterable ) iterable ) . iterator () ) ;
notifier . setAnswersForStubbing ( new ArrayList < Answer > () ) ;
FailingConstructor ( Set set ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
public Set getHistogram2 () { return histogram2 ; }
public Set getHistogram1 () { return histogram1 ; }
public TreeSet getSearchTree () { return searchTree ; }
public List getAList () { return aList ; }
ConstructorInjection.SimpleArgumentResolver resolver = new ConstructorInjection.SimpleArgumentResolver ( newSetOf ( new HashSet () , new ByteArrayOutputStream () ) ) ;
public some_class_with_parametered_constructor ( List collaborator ) { constructor_instantiation ++ ; }
public ByteBuddyMockMaker () { cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator () ; }
public LessThan ( Comparable < T > value ) { super ( value ) ; }
public LessOrEqual ( Comparable < T > value ) { super ( value ) ; }
public GreaterOrEqual ( Comparable < T > value ) { super ( value ) ; }
Comparable < T > value
Comparable < T > value
Comparable < T > value
Comparable < T > value
Comparable < T > value
public CompareTo ( Comparable < T > value ) { this . wanted = value ; }
public GreaterThan ( Comparable < T > value ) { super ( value ) ; }
public CompareEqual ( Comparable < T > value ) { super ( value ) ; }
UnmockableHashCodeAndEquals mock = mock ( UnmockableHashCodeAndEquals . class ) ;
MethodTransformer.Simple . withModifiers ( SynchronizationState.PLAIN )
public VerificationMode only ( ) ;
public VerificationMode atLeastOnce ( ) ;
public VerificationMode never ( ) ;
@ Before public void initialize_dependencies () { underTest = new ConstructorInjection ( resolver ) ; }
public Method getJavaMethod ( ) ;
public Class < > [] getExceptionTypes ( ) ;
public Class < > [] getParameterTypes ( ) ;
public Class < > getReturnType ( ) ;
public String getName ( ) ;
{ return o1 == null && o2 == null ; }
Object writeReplace ( ) throws ObjectStreamException ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( new HamcrestArgumentMatcher < T > ( matcher ) ) ; }
mockingProgress . validateState () ;
mockingProgress . validateState () ;
mockingProgress . mockingStarted ( mock , typeToMock ) ;
ThreadSafeMockingProgress p = new ThreadSafeMockingProgress () ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return false ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return null ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return null ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return false ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return null ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return false ; }
assertThat ( new ThreadSafeMockingProgress () . pullOngoingStubbing () ) . isNull () ;
mockingProgress . stubbingCompleted ( invocation ) ;
InvocationContainerImpl invocations = new InvocationContainerImpl ( new ThreadSafeMockingProgress () , new MockSettingsImpl () ) ;
mockingProgress . setVerificationStrategy ( MockingProgressImpl . getDefaultVerificationStrategy () ) ;
{ mockingProgress . setVerificationStrategy ( MockingProgressImpl . getDefaultVerificationStrategy () ) ; }
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( AnyVararg.ANY_VARARG ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( null ) , AnyVararg.ANY_VARARG ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( NUMBER_CONSTANT ) , AnyVararg.ANY_VARARG ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( NUMBER_CONSTANT ) , AnyVararg.ANY_VARARG ) ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
public void filter ( Filter filter ) throws NoTestsRemainException { filterRequested = true ; runner . filter ( filter ) ; }
MockitoJUnitListener listener = new MockitoJUnitListener ( notifier ) ;
assertTrue ( result . wasSuccessful () ) ;
{ return runnerProvider . newInstance ( STRING_CONSTANT , klass ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { runner . filter ( filter ) ; }
notifier . fireTestFailure ( new Failure ( unnecessaryStubbings , new Reporter () . formatUnncessaryStubbingException ( testClass , stubbings . values () ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
public void filter ( Filter filter ) throws NoTestsRemainException { filterRequested = true ; runner . filter ( filter ) ; }
MockitoJUnitListener listener = new MockitoJUnitListener ( notifier ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
{ try { return new ArgumentsComparator () . argumentsMatch ( this , actualArgs ) ; } catch ( Throwable t ) { return false ; } }
return invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && new ArgumentsComparator () . argumentsMatch ( this , actual ) ;
! new TestMethodsFinder () . hasTestMethods ( klass )
MockCreationSettings < > settings
MockCreationSettings mockSettings
{ reportMatcher ( new InstanceOf ( Collection . class ) ) ; return new LinkedList () ; }
{ reportMatcher ( new InstanceOf ( Map . class ) ) ; return new HashMap () ; }
{ reportMatcher ( new InstanceOf ( Set . class ) ) ; return new HashSet () ; }
{ reportMatcher ( new InstanceOf ( List . class ) ) ; return new LinkedList () ; }
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( chunk , hasExactlyInOrder ( simpleMethodInvocation , simpleMethodInvocationTwo , simpleMethodInvocationThree ) ) ;
assertThat ( chunk , hasExactlyInOrder ( simpleMethodInvocation , simpleMethodInvocationTwo , simpleMethodInvocationThree ) ) ;
assertThat ( chunk , hasExactlyInOrder ( simpleMethodInvocation , simpleMethodInvocationTwo ) ) ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , MyAssertionError . class ) ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , UnnecessaryStubbingException . class ) ;
assertThat ( result ) . isSuccessful () ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT ) ) ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT ) ) ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT ) ) ;
assertThat ( result ) . isSuccessful () ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , UnfinishedStubbingException . class ) ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , TooLittleActualInvocations . class ) ;
{ Result result = runner . run ( SomeFeature . class ) ; assertThat ( result ) . isSuccessful () ; }
catch ( RuntimeException e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
assertThat ( t , hasOnlyThoseClassesInStackTrace ( STRING_CONSTANT ) ) ;
assertThat ( t , hasOnlyThoseClassesInStackTrace ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( filtered , hasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( timer . isCounting () , is ( false ) ) ;
assertThat ( timer . isCounting () , is ( true ) ) ;
{ reportMatcher ( new InstanceOf ( Iterable . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Collection . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Map . class ) ) ; return new HashMap ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Set . class ) ) ; return new HashSet ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( List . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( String . class ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Short . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Double . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Float . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Long . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Integer . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Character . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Byte . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Boolean . class ) ) ; return false ; }
public void save ( Person capture ) ;
public String targetMethod ( String arg ) ;
public Integer getValue ( Integer param ) ;
public Object otherMethod ( Object param ) ;
public Object someMethod ( Object param ) ;
public MyIterator < T > iterator ( ) ;
public void setSpy ( List spy ) { this . spy = spy ; }
public List getList () { return list ; }
assertContainsIgnoringCase ( STRING_CONSTANT , log ) ;
catch ( NeverWantedButInvoked e ) { assertNotContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NoInteractionsWanted e ) { assertNotContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( AssertionError e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NoInteractionsWanted e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
{ String expected = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; assertContains ( expected , e . getMessage () ) ; }
catch ( NoInteractionsWanted e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
{ assertContains ( STRING_CONSTANT , e . getMessage () ) ; e . getCause () . getMessage () . equals ( STRING_CONSTANT ) ; }
assertContains ( STRING_CONSTANT , out ) ;
catch ( NeverWantedButInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , name ) ;
assertContains ( STRING_CONSTANT , name ) ;
assertContains ( STRING_CONSTANT , name ) ;
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NeverWantedButInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( InvalidUseOfMatchersException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( SmartNullPointerException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( UnfinishedVerificationException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , STRING_CONSTANT + mockTwo ) ;
catch ( InstantiationException e ) { assertContains ( STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , failure . getException () . getMessage () ) ;
assertContains ( STRING_CONSTANT , STRING_CONSTANT + mockTwo ) ;
assertContains ( STRING_CONSTANT , mockTwo . toString () ) ;
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertNotNull ( mockUtil . getMockSettings ( mock ) ) ;
assertNotNull ( mockUtil . getMockHandler ( mock ) ) ;
if ( new MockUtil () . isMock ( throwable ) ) { throw throwable ; }
{ assertNotNull ( notInitializedSpy ) ; assertNotNull ( notInitializedSpy . getAList () ) ; assertTrue ( mockUtil . isMock ( notInitializedSpy ) ) ; }
@ Test public void should_inject_mocks_in_spy () { assertNotNull ( initializedSpy . getAList () ) ; assertTrue ( mockUtil . isMock ( initializedSpy ) ) ; }
Class < > mockType = mockUtil . getMockHandler ( mock ) . getMockSettings () . getTypeToMock () ;
new MockUtil () . isMock ( instance )
new MockUtil () . isMock ( instance )
if ( isMockOrSpy ( instance ) ) { mockUtil . maybeRedefineMockName ( instance , field . getName () ) ; return instance ; }
MockCreationSettings < > mockSettings = new MockUtil () . getMockSettings ( mockitoMock ) ;
MockCreationSettings parentMockSettings = new MockUtil () . getMockSettings ( parentMock ) ;
InternalMockHandler < Object > handler = new MockUtil () . getMockHandler ( invocation . getMock () ) ;
assertTrue ( isMock ( subClass.list ) ) ;
assertTrue ( new MockUtil () . isMock ( classMock ) ) ;
assertTrue ( new MockUtil () . isMock ( interfaceMock ) ) ;
InternalMockHandler < Object > handler = new MockUtil () . getMockHandler ( mock ) ;
public MockingDetails mockingDetails ( Object toInspect ) { return new DefaultMockingDetails ( toInspect , new MockUtil () ) ; }
InvocationContainer invocationContainer = new MockUtil () . getMockHandler ( m ) . getInvocationContainer () ;
{ if ( mock == null ) { throw nullPassedWhenCreatingInOrder () ; } if ( ! mockUtil . isMock ( mock ) ) { throw notAMockPassedWhenCreatingInOrder () ; } }
InvocationContainer invocations = mockUtil . getMockHandler ( mock ) . getInvocationContainer () ;
for ( T m : mocks ) { mockUtil . getMockHandler ( m ) . getInvocationContainer () . clearInvocations () ; }
for ( T m : mocks ) { mockUtil . resetMock ( m ) ; }
if ( ! mockUtil . isMock ( mock ) ) { throw notAMockPassedToVerify ( mock . getClass () ) ; }
T mock = mockUtil . createMock ( creationSettings ) ;
InternalMockHandler < Object > handler = new MockUtil () . getMockHandler ( mock ) ;
TypeMockability typeMockability = mockUtil . typeMockabilityOf ( classToMock ) ;
{ if ( mockUtil . typeMockabilityOf ( aClass ) . mockable () ) { constructorMockableParamsSize ++ ; } }
String mockName = mockUtil . getMockName ( mocks . iterator () . next () ) . toString () ;
{ if ( candidateFieldToBeInjected . getName () . equals ( mockUtil . getMockName ( mock ) . toString () ) ) { mockNameMatches . add ( mock ) ; } }
String qualifiedName = new MockUtil () . getMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () ;
List < Invocation > invocations = finder . find ( asList ( mockOne , mockOne , mockOne ) ) ;
List < Invocation > invocations = finder . find ( asList ( mockOne , mockTwo ) ) ;
List < Invocation > all = new AllInvocationsFinder () . find ( createdMocks ) ;
List < Invocation > invocations = new VerifiableInvocationsFinder () . find ( inOrder . getMocksToBeVerifiedInOrder () ) ;
List < Invocation > invocations = allInvocationsFinder . find ( asList ( mocks ) ) ;
assumeTrue ( ClassFileVersion . forCurrentJavaVersion () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
assumeTrue ( ClassFileVersion . forCurrentJavaVersion () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
verify ( mockHandler ) . setAnswersForStubbing ( anyList () ) ;
when ( sorter . sort ( anyList () ) ) . thenReturn ( null ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
{ results . add ( new SuperTypesLastSorter () . sort ( Arrays . asList ( o ) ) ) ; }
List < Field > sortedFields = new SuperTypesLastSorter () . sort ( unsortedFields ) ;
List < Field > l = new SuperTypesLastSorter () . sort ( Arrays . asList ( o1 , o2 ) ) ;
return new SuperTypesLastSorter () . sort ( declaredFields ) ;
new ArrayUtils () . isEmpty ( args )
public InvocationMatcher getWanted () { return wanted ; }
public boolean isOut ( Invocation invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
if ( new ObjectMethodsGuru () . isToString ( currentInvocation . getMethod () ) ) { return STRING_CONSTANT + unstubbedInvocation . toString () ; }
if ( ! filterRequested && listener . isSussessful () ) { reporter . report ( testClass , notifier ) ; }
mockingProgress () . mockingStarted ( mock , typeToMock ) ;
@ Test public void shouldNotifyListenerSafely ( ) throws Exception { mockingProgress . setListener ( null ) ; mockingProgress . mockingStarted ( null , null ) ; }
List < > mocks
throw cannotInitializeForInjectMocksAnnotation ( field . getName () , e ) ;
@ Test ( expected = NullPointerException . class )
@ Test ( expected = NullPointerException . class )
@ Test ( expected = NullPointerException . class )
@ Test ( expected = NullPointerException . class )
{ if ( value == null ) { throw new NullPointerException ( checkedValue + STRING_CONSTANT ) ; } return value ; }
public TypeVariable typeVariable () { return typeVariable ; }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = typeVariable ; }
TypeVariable [] typeParameters
if ( type instanceof TypeVariable ) { return new TypeVariableReturnType ( this , method . getTypeParameters () , ( TypeVariable ) type ) ; }
if ( wildCardBoundedType . firstBound () instanceof TypeVariable ) { return boundsOf ( ( TypeVariable ) wildCardBoundedType . firstBound () ) ; }
TypeVariable typeVariable
assertNotEquals ( NUMBER_CONSTANT , to.privateTransientField ) ;
assertNotEquals ( NUMBER_CONSTANT , to.finalField ) ;
Class classToMock
int size () { return unused . size () ; }
assumeTrue ( ClassFileVersion . forThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
assumeTrue ( ClassFileVersion . forThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
String getAuthor ( ) ;
String getAuthorId ( ) ;
public String toText () { return commits . size () + STRING_CONSTANT + author ; }
public String getAuthor () { return author ; }
public String getAuthorId () { return email ; }
UnusedStubbings ( Collection < Stubbing > unused ) { this . unused = unused ; }
if ( type instanceof Class ) { return new NotGenericReturnTypeSupport ( type ) ; }
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT ) ;
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT ) ;
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT ) ;
generatedMockClass = generate ( features ) ;
@ Test public void shouldRunInMultipleThreads ( ) throws Exception { assertFalse ( STRING_CONSTANT , runInMultipleThreads ( NUMBER_CONSTANT ) ) ; }
Class < ? extends T > mockedProxyType = createProxyClass ( mockWithFeaturesFrom ( settings ) ) ;
Class < ? extends T > type = bytecodeGenerator . mockClass ( mockWithFeaturesFrom ( settings ) ) ;
dispatcher == null || ! dispatcher . isMocked ( mock )
public AbstractByteBuddyMockMakerTest ( MockMaker mockMaker ) { this . mockMaker = mockMaker ; }
generatedMockClass = generate ( features ) ;
{ return invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && argumentsMatch ( this , actual ) ; }
given ( mock ( ConstructorArgumentResolver . class ) . resolveTypeInstances ( any ( Class [] . class ) ) )
withModifiers ( SynchronizationState.PLAIN )
{ addStep ( task , config . get ( STRING_CONSTANT ) ) ; return this ; }
InvocationMatcher wanted
InvocationMatcher wantedMatcher = data . getWanted () ;
InvocationMatcher wanted = data . getWanted () ;
public String print ( InvocationMatcher invocationMatcher ) { return print ( invocationMatcher . getMatchers () , invocationMatcher . getInvocation () ) ; }
InvocationMatcher wanted = data . getWanted () ;
InvocationMatcher wanted = data . getWanted () ;
InvocationMatcher wanted = data . getWanted () ;
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher getWanted ( ) ;
private RemoveNotMatching ( InvocationMatcher wanted ) { this . wanted = wanted ; }
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
CapturesArgumentsFromInvocation wanted
CapturesArgumentsFromInvocation wanted
CapturesArgumentsFromInvocation wanted
VerificationDataInOrderImpl dataInOrder = new VerificationDataInOrderImpl ( inOrder , invocations , data . getWanted () ) ;
MatchableInvocation wanted = data . getWanted () ;
{ assertNotNull ( listener ) ; mockingProgress () . removeListener ( listener ) ; return this ; }
{ assertNotNull ( listener ) ; mockingProgress () . addListener ( listener ) ; return this ; }
@ Before public void setUp () { executor = newSingleThreadScheduledExecutor () ; stopWatch = createNotStarted () ; }
@ Advice.BoxedReturn ( readOnly = false ) Object returned
@ Advice.BoxedArguments Object [] arguments
private ExcludeHandler ( RootDoc root ) { this . root = root ; }
public Invocation getInvocation () { return invocation ; }
{ return isMockitoMock ( mock ) && getMockSettings ( mock ) . getDefaultAnswer () == Mockito.CALLS_REAL_METHODS ; }
isMockitoMock ( mock )
mockingProgress () . stubbingCompleted ( invocation ) ;
AnnotationEngine customizedEngine = new DefaultAnnotationEngine () {} ;
AnnotationEngine annotationEngine = new GlobalConfiguration () . getAnnotationEngine () ;
ClassLoader cl = isolatedClassLoader () . withCurrentCodeSourceUrls () . withPrivateCopyOf ( CLASS_NAME_USING_INTERFACE ) . withPrivateCopyOf ( INTERFACE_NAME ) . build () ;
{ throw new IllegalArgumentException ( String . format ( STRING_CONSTANT , classLoader ) ) ; }
public ExcludingURLClassLoaderBuilder without ( String . . . privatePrefixes ) { privateCopyPrefixes . addAll ( asList ( privatePrefixes ) ) ; return this ; }
Statement statement
mock . simpleMethod ( NUMBER_CONSTANT ) ;
public void doAssert ( Throwable throwable ) { Assertions . assertThat ( throwable ) . isInstanceOf ( expected ) . hasMessage ( expectedMessage ) ; }
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
public void beforeTest ( Object testClassInstance , String testMethodName ) { MockitoAnnotations . initMocks ( testClassInstance ) ; }
public JUnitRule silent () { return new JUnitRule ( logger , true ) ; }
{ return new JUnitRule ( new ConsoleMockitoLogger () , false ) ; }
void doAssert ( Throwable throwable ) ;
@ Test public void rule_validates_mockito_usage ( ) throws Throwable { rule . expectThrowable ( UnfinishedVerificationException . class ) ; verify ( mock ) ; }
rule . expectThrowable ( PotentialStubbingProblem . class ) ;
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectThrowable ( UnnecessaryStubbingException . class ) ;
rule . expectThrowable ( RuntimeException . class , STRING_CONSTANT ) ;
{ rule . expectThrowable ( UnfinishedStubbingException . class ) ; when ( mock . simpleMethod () ) ; }
{ rule . expectThrowable ( RuntimeException . class , STRING_CONSTANT ) ; throw new RuntimeException ( STRING_CONSTANT ) ; }
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
notifyStubbedAnswerLookUp ( invocation , stubbedInvocation ) ;
List < StubbingLookUpListener > getStubbingLookUpListeners ( ) ;
{ return new JUnitRule ( new ConsoleMockitoLogger () , JUnitRule.Strictness.WARN ) ; }
public MockitoRule silent () { return new JUnitRule ( logger , Strictness.SILENT ) ; }
case SILENT :
settings . getStubbingLookupListeners ()
mockingProgress . verificationStarted ( new MockAwareVerificationMode ( mock , actualMode ) ) ;
public int wantedArgumentPosition () { return wantedArgumentPosition ; }
new AnswersValidator () . validateDefaultAnswerReturnedValue ( invocation , ret ) ;
public boolean returnsNull () { return value == null ; }
public void reportMatcher ( ArgumentMatcher matcher ) { matcherStack . push ( new LocalizedMatcher ( matcher ) ) ; }
{ this ( new StrictRunner ( new RunnerFactory () . create ( klass ) , klass ) ) ; }
{ super ( new StrictRunner ( new RunnerFactory () . create ( klass ) , klass ) ) ; }
RunnerImpl runner = provider . newInstance ( STRING_CONSTANT , this . getClass () ) ;
MockitoJUnitRunner ( RunnerImpl runner ) throws InvocationTargetException { this . runner = runner ; }
RunnerImpl runner
ClassLoadingStrategy.Default.INJECTION . with ( features.mockedType . getProtectionDomain () )
assertThat ( MockMethodAdvice . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ) . isSameAs ( throwable ) ;
throwable = MockMethodAdvice . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ;
@ Override public boolean mockable () { return instrumentation . isModifiableClass ( type ) && ! EXCLUDES . contains ( type ) ; }
if ( i != successCount ) { throw new AssertionError ( STRING_CONSTANT + successCount + STRING_CONSTANT + i + STRING_CONSTANT ) ; }
Result result = runner . run ( StubbingArgMismatchTest . class ) ;
Result result = runner . run ( UnnecessaryStubbingTest . class ) ;
{ return mock ( classToMock , withSettings () . defaultAnswer ( RETURNS_DEFAULTS ) ) ; }
return new AndroidClassLoadingStrategy ( target ) ;
MockSettings settings = withSettings () . defaultAnswer ( Mockito.CALLS_REAL_METHODS ) . name ( field . getName () ) ;
Mockito . mock ( instance . getClass () , withSettings () . spiedInstance ( instance ) . defaultAnswer ( Mockito.CALLS_REAL_METHODS ) . name ( field . getName () ) )
NestedClassWithNoArgConstructor ( String f ) {}
catch ( MockitoException e ) { Assertions . assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { Assertions . assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
throw paramsException ( cls , null ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
if ( ! argMismatchStubbings . isEmpty () ) { mismatchesReported = true ; Reporter . potentialStubbingProblemByJUnitRule ( invocation , argMismatchStubbings ) ; }
try { Mockito . framework () . addListener ( listener ) ; } catch ( RedundantListenerException e ) { throw new UnfinishedMockingException ( STRING_CONSTANT ) ; }
Failure f = result . getFailures () . iterator () . next () ;
mocking . finishMocking () ;
mocking . finishMocking () ;
mocking . finishMocking () ;
mocking . finishMocking () ;
{ mock . simpleMethod ( NUMBER_CONSTANT ) ; mock . otherMethod () ; mocking . finishMocking () ; logger . assertEmpty () ; }
assertThat ( new Runnable () { public void run () { mocking . finishMocking () ; } } ) . throwsException ( UnnecessaryStubbingException . class )
{ this . currentStrictness = strictness ; this . stubbingLookupListener . currentStrictness = strictness ; }
event . getFailure () == null && ! stubbingLookupListener.mismatchesReported
try { Mockito . framework () . addListener ( listener ) ; } catch ( RedundantListenerException e ) { Reporter . unfinishedMocking () ; }
JUnitResultAssert . assertThat ( result ) . fails ( UnfinishedMockingSessionException . class , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
JUnitResultAssert . assertThat ( result ) . succeeds ( NUMBER_CONSTANT ) ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , PotentialStubbingProblem . class ) ;
return Decamelizer . decamelizeMatcher ( matcher . getClass () . getSimpleName () ) ;
return JUnitTool . createArgumentsAreDifferentException ( message , wanted , actual ) ;
withModifiers ( SynchronizationState.PLAIN , Visibility.PUBLIC )
assertThat ( InlineByteBuddyMockMaker . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ) . isSameAs ( throwable ) ;
throwable = InlineByteBuddyMockMaker . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ;
if ( paramsMatch ( types , params ) ) { matchingConstructors . add ( constructor ) ; }
assertEquals ( STRING_CONSTANT , mock . forObject ( ( Object ) null ) ) ;
catch ( Throwable throwable ) { return null ; }
if ( unused . size () == NUMBER_CONSTANT ) { return; }
return method . getName () . equals ( STRING_CONSTANT ) ;
method . getName () . equals ( STRING_CONSTANT )
m . getName () . equals ( STRING_CONSTANT )
Type genericInterface = findGenericInteface ( match , targetBaseInterface ) ;
public Class < > [] getParameterTypes () { return method . getParameterTypes () ; }
this . arguments = ArgumentsProcessor . expandVarArgs ( mockitoMethod . isVarArgs () , args ) ;
this . arguments = ArgumentsProcessor . expandVarArgs ( mockitoMethod . isVarArgs () , arguments ) ;
parameterTypes = method . getParameterTypes () ;
{ if ( ! wantedArgumentPositionIsValidForInvocation ( invocation , argumentPosition ) ) { throw Reporter . invalidArgumentPositionRangeAtInvocationTime ( invocation , wantedArgumentPosition == LAST_ARGUMENT , wantedArgumentPosition ) ; } }
validateArgumentTypeCompatibility ( invocation , argumentPosition ) ;
public InOrderImpl ( List < ? extends Object > mocksToBeVerifiedInOrder ) { this . mocksToBeVerifiedInOrder . addAll ( mocksToBeVerifiedInOrder ) ; }
Assertions . assertThat ( m . getAllValues () ) . containsSequence ( STRING_CONSTANT , STRING_CONSTANT ) ;
Iterable < Object > mocks
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
given ( iMethods . varargsObject ( eq ( NUMBER_CONSTANT ) , anyVararg () ) ) . will ( returnsArgAt ( NUMBER_CONSTANT ) ) ;
public String foo () { return STRING_CONSTANT ; }
UnusedStubbings stubbings = new UnusedStubbings ( ( List ) asList () ) ;
List < StubbedInvocationMatcher > getStubbedInvocations ( ) ;
InternalMockHandler handler
public NullResultGuardian ( InternalMockHandler < T > delegate ) { this . delegate = delegate ; }
{ ( ( MockAccess ) mock ) . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( newHandler ) , settings ) ) ; }
mockAccess . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( handler ) , settings ) ) ;
InternalMockHandler < > handler = createMockHandler ( settings ) ;
InternalMockHandler < > handler = createMockHandler ( settings ) ;
InternalMockHandler < T > mockHandler
InvocationMatcher invocation
public void setAnswersForStubbing ( List < Answer < > > answers ) { invocationContainerImpl . setAnswersForStubbing ( answers ) ; }
this . invocationContainerImpl = new InvocationContainerImpl ( mockSettings ) ;
@ SuppressWarnings ( STRING_CONSTANT ) public < M > M getMock () { return ( M ) invocationContainerImpl . invokedMock () ; }
MockUtil . getMockHandler ( mock ) . setAnswersForStubbing ( answers ) ;
List < ? extends Stubbing > stubbings = mockHandler () . getInvocationContainer () . getStubbedInvocations () ;
InvocationContainer invocations
InvocationContainer invocations = getMockHandler ( mock ) . getInvocationContainer () ;
for ( T m : mocks ) { getMockHandler ( m ) . getInvocationContainer () . clearInvocations () ; }
MockUtil . getMockHandler ( mock ) . getInvocationContainer () . setAnswersForStubbing ( answers ) ;
InvocationContainer invocationContainer
MockCreationSettings < T > creationSettings = impl . confirm ( typeToMock ) ;
private MockHandler < Object > mockHandler () { assertGoodMock () ; return getMockHandler ( toInspect ) ; }
given ( handler.invocationContainer . findAnswerFor ( any ( InvocationImpl . class ) ) ) . willReturn ( value ) ;
{ if ( interceptor == null ) { return stubValue ; } return interceptor . doIntercept ( mock , invokedMethod , arguments , InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE ) ; }
return interceptor . doIntercept ( mock , invokedMethod , arguments , new InterceptedInvocation.SuperMethod.FromCallable ( superCall ) ) ;
Mockito . verify ( mock ) ;
{ InterceptedInvocation.RealMethod.FromCallable superMethod = new InterceptedInvocation.RealMethod.FromCallable ( realMethod ) ; return MockMethodInterceptor . createInvocation ( target , method , args , superMethod , settings ) ; }
{ if ( interceptor == null ) { return stubValue ; } return interceptor . doIntercept ( mock , invokedMethod , arguments , InterceptedInvocation.RealMethod.IsIllegal.INSTANCE ) ; }
return interceptor . doIntercept ( mock , invokedMethod , arguments , new InterceptedInvocation.RealMethod.FromCallable ( superCall ) ) ;
InterceptedInvocation.RealMethod realMethod
InterceptedInvocation.RealMethod realMethod
InterceptedInvocation.RealMethod realMethod
InterceptedInvocation.RealMethod realMethod
InterceptedInvocation.RealMethod realMethod ;
return ! node . getSort () . isResolved () || ! node . getRepresentative () . represents ( origin ) ;
if ( ! MockUtil . isMock ( mock ) ) { throw notAMockPassedToWhenMethod () ; }
UnusedStubbings stubbings = new UnusedStubbings ( Arrays . < Stubbing > asList () ) ;
{ this . verificationStartedListeners . addAll ( Arrays . asList ( listeners ) ) ; return this ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . invocationListenerDoesNotAcceptNullParameters () ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . methodDoesNotAcceptNullParameters ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ if ( mock == null ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT ) ; } this . mock = mock ; }
VerificationStartedEvent event = new DefaultVerificationStartedEvent () ;
mock = ( T ) VerificationStartedNotifier . notifyVerificationStarted ( handler . getMockSettings () . getVerificationStartedListeners () , mock ) ;
public static MockitoMock getMockitoMock ( Object mock ) { return new MockitoMock ( mockMaker . getHandler ( mock ) ) ; }
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event () ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event () ;
@ Test public void does_not_do_anything_when_list_is_empty ( ) throws Exception { VerificationStartedNotifier . notifyVerificationStarted ( ( List ) emptyList () , null ) ; }
catch ( Exception e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
@ Test public void does_not_do_anything_when_list_is_empty ( ) throws Exception { VerificationStartedNotifier . notifyVerificationStarted ( ( List ) emptyList () , mockitoMock ) ; }
assertEquals ( NUMBER_CONSTANT , captor . getValue () ) ;
catch ( NotAMockException e ) { TestCase . assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { TestCase . assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { TestCase . assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { TestCase . assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
public Object getOuterClassInstance () { return outerClassInstance ; }
public Object getSpiedInstance () { return spiedInstance ; }
public MockName getMockName () { return mockName ; }
public Object getOuterClassInstance () { return outerClassInstance ; }
public SerializableMode getSerializableMode () { return serializableMode ; }
public MockName getMockName () { return mockName ; }
public Object getSpiedInstance () { return spiedInstance ; }
SerializableClass proxy = mockMaker . createMock ( serializableSettingsFor ( SerializableClass . class , SerializableMode.BASIC ) , dummyH () ) ;
OtherClass mock = mockMaker . createMock ( settingsWithConstructorFor ( OtherClass . class ) , dummyH () ) ;
SomeClass mock = mockMaker . createMock ( settingsFor ( SomeClass . class , SomeInterface . class ) , dummyH () ) ;
ClassWithDodgyConstructor mock = mockMaker . createMock ( settingsFor ( ClassWithDodgyConstructor . class ) , dummyH () ) ;
ClassWithoutConstructor proxy = mockMaker . createMock ( settingsFor ( ClassWithoutConstructor . class ) , dummyH () ) ;
SomeInterface proxy = mockMaker . createMock ( settingsFor ( SomeInterface . class ) , dummyH () ) ;
new SerializationFeatureKey ( params.mockedType , params.interfaces , params.serializableMode )
{ this . bytecodeGenerator = bytecodeGenerator ; typeCache = new TypeCache.WithInlineExpunction < SerializationFeatureKey > ( weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT ) ; }
{ return selfCallInfo . checkSuperCall ( instance ) && isMock ( instance ) ; }
Assert . assertEquals ( STRING_CONSTANT , mock . getFoo () ) ;
{ verify ( mock , after ( NUMBER_CONSTANT ) . atLeast ( NUMBER_CONSTANT ) ) . oneArg ( CHAR_CONS ) ; Assert . fail ( STRING_CONSTANT ) ; }
if ( ! threads . awaitTermination ( NUMBER_CONSTANT , TimeUnit.MILLISECONDS ) ) { Assert . fail () ; }
if ( ! threads . awaitTermination ( NUMBER_CONSTANT , TimeUnit.MILLISECONDS ) ) { Assert . fail () ; }
Assert . assertEquals ( STRING_CONSTANT , mock . getValue () ) ;
{ TestedObject mock = mock ( TestedObject . class , CALLS_REAL_METHODS ) ; Assert . assertEquals ( STRING_CONSTANT , mock . getValue () ) ; }
Assert . assertEquals ( STRING_CONSTANT , mock.value ) ;
{ when ( mock . getValue () ) . thenCallRealMethod () ; Assert . assertEquals ( STRING_CONSTANT , mock . getValue () ) ; }
sb . append ( STRING_CONSTANT + mock ) . append ( STRING_CONSTANT ) ;
classLoader == null ? BOOTSTRAP_LOCK : classLoader
{ return ! selfCallInfo . isSelfInvocation ( instance ) && isMock ( instance ) ; }
@ Override public boolean isMock ( Object instance ) { return interceptors . containsKey ( instance ) ; }
public Throwable getFailure () { return testFailure ; }
assertEquals ( filterLineNo ( STRING_CONSTANT + STRING_CONSTANT ) , filterLineNo ( logger . getLoggedInfo () ) ) ;
assertEquals ( filterLineNo ( STRING_CONSTANT + STRING_CONSTANT ) , filterLineNo ( logger . getLoggedInfo () ) ) ;
String getTestMethodName ( ) ;
catch ( org.mockito.internal.creation.instance.InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + type . getSimpleName () + STRING_CONSTANT , e ) ; }
catch ( InstantiationException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Test ( expected = InstantiationException . class )
catch ( org.mockito.internal.creation.instance.InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + mockedProxyType . getSuperclass () . getSimpleName () + STRING_CONSTANT , e ) ; }
if ( explosive . get () != null ) { throw new RuntimeException ( STRING_CONSTANT ) ; }
return pluginType . cast ( new InstantiatorProvider2Wrapper ( create ( InstantiatorProvider2 . class , className ) ) ) ;
{ instantiatorProvider = new InstantiatorProviderWrapper ( ( InstantiatorProvider ) impl ) ; }
{ return MockMethodInterceptor . createInvocation ( target , method , args , superMethod , settings ) ; }
this . mock . equals ( other.mock )
public String returnA () { return STRING_CONSTANT ; }
if ( ref == null ) { throw new IllegalStateException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . instanceRef = new SerializeableWeakReference < Object > ( instance ) ;
T ref = super . get () ;
this . instanceRef = new WeakReference < Object > ( instance ) ;
{ if ( throwableType == null ) { mockingProgress () . reset () ; throw notAnException () ; } return thenThrow ( newInstance ( throwableType ) ) ; }
{ new ThrowsException ( new IOException () ) . validateFor ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ; }
{ new ThrowsException ( new CharacterCodingException () ) . validateFor ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ; }
new ThrowsException ( throwableToRaise ) . answer ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ;
new ThrowsException ( mock ( Exception . class ) ) . answer ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ;
new ThrowsException ( new IllegalStateException ( STRING_CONSTANT ) ) . answer ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ;
{ if ( throwableType == null ) { return abortNullExceptionType () ; } return thenThrow ( newInstance ( throwableType ) ) ; }
List < Object > testInstances
{ if ( field . isAnnotationPresent ( u ) ) { throw unsupportedCombinationOfAnnotations ( annotation . getSimpleName () , annotation . getClass () . getSimpleName () ) ; } }
if ( isPrimitiveOrWrapper ( valueClass ) && isPrimitiveOrWrapper ( referenceType ) ) { return Primitives . primitiveTypeOf ( valueClass ) . isAssignableFrom ( referenceType ) ; }
for ( Annotation firstParamAnnotation : firstParamAnnotations ) { if ( annotationClass . isAssignableFrom ( firstParamAnnotation . getClass () ) ) { return ( T ) firstParamAnnotation ; } }
assertThat ( subList . isEmpty () ) ;
@ SuppressWarnings ( STRING_CONSTANT )
assumeFalse ( System . getProperty ( STRING_CONSTANT ) . startsWith ( STRING_CONSTANT ) ) ;
if ( isComingFromJDK ( type ) || isComingFromSignedJar ( type ) || isComingFromSealedPackage ( type ) ) { typeName = STRING_CONSTANT + typeName ; }
{ super ( Opcodes.ASM5 , cv ) ; this . typeDescription = typeDescription ; }
@ SuppressWarnings ( STRING_CONSTANT ) private MockitoExtension () { this ( Strictness.STRICT_STUBS ) ; }
if ( rawArguments == matcherCount && isLastMatcherVargargMatcher ( matchers ) ) { return MATCH_EACH_VARARGS_WITH_LAST_MATCHER ; }
