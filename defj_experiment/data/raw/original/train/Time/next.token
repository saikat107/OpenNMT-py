{ super . setZoneRetainFields ( zone ) ; }
if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING_CONSTANT ) ) ; }
{ return getAsText ( null ) ; }
public abstract DurationField getLeapDurationField ( ) ;
public abstract boolean isSupported ( ) ;
DateTime result = new DateTime ( test . resolve ( dt . getMillis () , DateTimeZone.UTC ) ) ;
{ super ( instant ) ; }
{ super ( chronology ) ; }
public TimeOfDay () { super(); }
iInstantConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , PartialInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
return ( getMillis () < readableInstant . getMillis () ) ;
iInstantConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
ReadablePartial instant
public abstract int getMaximumValue ( ReadablePartial instant ) ;
ReadablePartial instant
public abstract int getMinimumValue ( ReadablePartial instant ) ;
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial partial
ReadablePartial partial
ReadablePartial partial
ReadablePartial partial
public DateTimeField getField () { return iYearMonthDay . getField ( iFieldIndex ) ; }
{ return getField () . getMaximumValue ( getReadablePartial () ) ; }
{ return getField () . getMinimumValue ( getReadablePartial () ) ; }
{ return getField () . getAsShortText ( getReadablePartial () , get () , locale ) ; }
{ return getField () . getAsText ( getReadablePartial () , get () , locale ) ; }
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial partial
ReadablePartial partial
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
public int getMaximumValue ( ReadablePartial instant ) { throw unsupported () ; }
ReadablePartial instant
public int getMinimumValue ( ReadablePartial instant ) { throw unsupported () ; }
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial partial
ReadablePartial partial
{ test1 . millisOfSecond () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . millisOfSecond () . getReadablePartial () ) ;
{ test1 . secondOfMinute () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . secondOfMinute () . getReadablePartial () ) ;
{ test1 . minuteOfHour () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . minuteOfHour () . getReadablePartial () ) ;
{ test1 . hourOfDay () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . hourOfDay () . getReadablePartial () ) ;
assertEquals ( false , test1 . equals ( MockPartial.EMPTY_INSTANCE ) ) ;
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
public int getMinimumValue ( ReadablePartial instant ) { return NUMBER_CONSTANT ; }
ReadablePartial instant
void validate ( ReadablePartial instant ) ;
public DateTimeField getField () { return iTimeOfDay . getField ( iFieldIndex ) ; }
ReadablePartial instant
ReadablePartial instant
{ test1 . dayOfMonth () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . dayOfMonth () . getReadablePartial () ) ;
{ test1 . monthOfYear () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . monthOfYear () . getReadablePartial () ) ;
{ test1 . year () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . year () . getReadablePartial () ) ;
assertEquals ( false , test1 . equals ( MockPartial.EMPTY_INSTANCE ) ) ;
public int getMaximumValue ( ReadablePartial instant , int [] values ) { return iField . getMaximumValue ( instant , values ) ; }
public int getMaximumValue ( ReadablePartial instant ) { return iField . getMaximumValue ( instant ) ; }
public int getMinimumValue ( ReadablePartial instant , int [] values ) { return iField . getMinimumValue ( instant , values ) ; }
public int getMinimumValue ( ReadablePartial instant ) { return iField . getMinimumValue ( instant ) ; }
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
public String getAsShortText ( ReadablePartial partial , Locale locale ) { return iField . getAsShortText ( partial , locale ) ; }
ReadablePartial partial
public String getAsText ( ReadablePartial partial , Locale locale ) { return iField . getAsText ( partial , locale ) ; }
ReadablePartial partial
ReadablePartial instant
{ t = new DateTimeFormatterBuilder ( iChrono ) . append ( hourMinuteSecondMillis () ) . append ( offsetElement () ) . toFormatter () ; }
iChronology = selectChronology ( converter . getChronology ( instant , chronology ) ) ;
iChronology = selectChronology ( converter . getChronology ( instant , zone ) ) ;
iChronology = selectChronology ( converter . getChronology ( instant ) ) ;
{ return DurationType . getMillisType () ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField millis () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField seconds () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField minutes () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField hours () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField days () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField weeks () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField months () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField years () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public abstract boolean isSupported ( ) ;
assertSame ( test , test . dayOfMonth () . getReadableInstant () ) ;
assertSame ( test , test . monthOfYear () . getReadableInstant () ) ;
assertSame ( test , test . year () . getReadableInstant () ) ;
assertSame ( test , test . yearOfCentury () . getReadableInstant () ) ;
assertSame ( test , test . centuryOfEra () . getReadableInstant () ) ;
assertSame ( test , test . yearOfEra () . getReadableInstant () ) ;
assertSame ( test , test . era () . getReadableInstant () ) ;
{ return getField () . remainder ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMaximumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMinimumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getLeapAmount ( getReadableInstant () . getMillis () ) ; }
{ return getField () . isLeap ( getReadableInstant () . getMillis () ) ; }
return getField () . getDifferenceAsLong ( getReadableInstant () . getMillis () , instant . getMillis () ) ;
return getField () . getDifference ( getReadableInstant () . getMillis () , instant . getMillis () ) ;
{ return getField () . getAsShortText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . getAsText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . get ( getReadableInstant () . getMillis () ) ; }
try { iChrono . era () . addWrapField ( SMALL_MILLIS , NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
iMillis = round ( converter . getInstantMillis ( instant , chronology ) , iChronology ) ;
iMillis = round ( converter . getInstantMillis ( instant , zone ) , iChronology ) ;
iMillis = round ( converter . getInstantMillis ( instant ) , iChronology ) ;
{ super(); iChronology = selectChronology ( chronology ) ; iMillis = round ( instant , iChronology ) ; }
{ setMillis ( instant ) ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
NullConverter.INSTANCE . setInto ( m , null ) ;
{ long instant = getChronology () . getDateTimeMillis ( getMillis () , hour , minuteOfHour , secondOfMinute , millisOfSecond ) ; setMillis ( instant ) ; }
withUTC () . dayOfYear () . remainder ( iCutoverMillis ) == NUMBER_CONSTANT
return getDateMidnightMillis ( year , monthOfYear , dayOfMonth ) + millisOfDay ;
assertEquals ( false , zone5 . equals ( zone4 ) ) ;
private DateTimeUtils () { super(); }
protected DateTimeUtils () { super(); }
int size () { return iConverters.length ; }
assertTrue ( set != result ) ;
catch ( IllegalStateException ex ) {}
assertEquals ( ( NUMBER_CONSTANT - NUMBER_CONSTANT ) * DateTimeConstants.MILLIS_PER_DAY , test . monthOfYear () . remainder () ) ;
MutableDuration duration = new MutableDuration ( NUMBER_CONSTANT , type ) ;
public String toString () { return STRING_CONSTANT ; }
{ if ( chrono == getChronology () ) { return this ; } return MaskedType . mask ( iType . withChronology ( chrono ) , iMask ) ; }
{ if ( chrono == iChronology ) { return this ; } return DurationType . getYearWeekType ( chrono ) ; }
{ if ( chrono == iChronology ) { return this ; } return DurationType . getYearMonthType ( chrono ) ; }
{ if ( chrono == iChronology ) { return this ; } return DurationType . getAllType ( chrono ) ; }
{ if ( chrono == iChronology ) { return this ; } return DurationType . getAverageYearMonthType ( chrono ) ; }
if ( isPrecise () ) { return FieldUtils . safeAdd ( instant , getTotalMillis () * scalar ) ; }
{ MutableDuration test = new MutableDuration () ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( duration , type , false ) ; }
{ super ( duration , null , false ) ; }
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
{ duration = duration . withDurationTypeUsingTotalMillis ( type ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( duration , type , false ) ; }
{ super ( duration , null , false ) ; }
{ assertEquals ( NUMBER_CONSTANT , Duration.ZERO . getTotalMillis () ) ; assertEquals ( DurationType . getAllType () , Duration.ZERO . getDurationType () ) ; }
YearMonthType ( Chronology chrono ) { super ( chrono ) ; }
YearWeekType ( Chronology chrono ) { super ( chrono ) ; }
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
MutableDuration test = new MutableDuration ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
public void testGetDurationType_Object ( ) throws Exception { assertEquals ( null , NullConverter.INSTANCE . getDurationType ( null ) ) ; }
{ convId = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return fixedOffsetZone ( convId , offset ) ; }
{ id = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return fixedOffsetZone ( id , offset ) ; }
assertEquals ( false , test1 . equals ( new Duration ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getYearWeekType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getYearMonthType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getAllType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getDayHourType () ; }
type = ( type == null ? converter . getDurationType ( duration , totalMillisMaster ) : type ) ;
assertEquals ( false , test1 . equals ( new Duration ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
assertEquals ( type , type . withChronology ( ISOChronology . getInstance () ) ) ;
assertEquals ( ISOChronology . getInstanceUTC () , type . getChronology () ) ;
ReadWritableTimePeriod duration
{ return ( ( ReadableDuration ) object ) . getMillis () ; }
{ return true ; }
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( STRING_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( length , null ) ;
MutableTimePeriod test = new MutableTimePeriod ( length ) ;
{ try { new MutableTimePeriod ( DurationType . getAllType () , true ) ; fail () ; } catch ( IllegalArgumentException ex ) {} }
MutableTimePeriod test = new MutableTimePeriod ( null , false ) ;
MutableTimePeriod test = new MutableTimePeriod ( null , true ) ;
MutableTimePeriod test = new MutableTimePeriod () ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ;
{ TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod () ;
{ MutableTimePeriod test = new MutableTimePeriod () ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
public void setInto ( ReadWritableTimePeriod duration , Object object ) {}
public void setInto ( ReadWritableTimePeriod duration , Object object ) {}
public void setInto ( ReadWritableTimePeriod duration , Object object ) {}
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( DurationType . getMillisType () ) ) ;
TimePeriod test = new TimePeriod ( STRING_CONSTANT ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( length , null ) ;
TimePeriod test = new TimePeriod ( length ) ;
TimePeriod test = TimePeriod.ZERO ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
{ DurationConverter [] array = ConverterManager . getInstance () . getDurationConverters () ; assertEquals ( DURATION_SIZE , array.length ) ; }
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , m . toDurationMillis () ) ;
assertEquals ( NUMBER_CONSTANT , m . toDurationMillis () ) ;
{ add ( new TimePeriod ( duration , getDurationType () ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () , getDurationType () ) ) ; } }
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getYearMonthType () ) ;
PeriodType type
PeriodType type
{ return new TimePeriod ( toDurationMillis () , getPeriodType () ) ; }
PeriodType type
PeriodType type
PeriodType type
PeriodType type
suite . addTest ( TestPeriodType . suite () ) ;
{ add ( new TimePeriod ( duration , getPeriodType () ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () , getPeriodType () ) ) ; } }
{ if ( interval != null ) { add ( interval . toTimePeriod ( getPeriodType () ) ) ; } }
final PeriodType type = iType ;
PeriodType type
PeriodType type
PeriodType type
PeriodType type
int hash = getPeriodType () . hashCode () ;
PeriodType type = iType ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
public TestPeriodType ( String name ) { super ( name ) ; }
PeriodType type
PeriodType type
PeriodType type
PeriodType type
PeriodType type = period . getPeriodType () ;
PeriodType type
if ( ! mustParse && ! isSupported ( period . getPeriodType () ) ) { return position ; }
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getMillisType () ) ;
TimePeriodConverter c = ConverterManager . getInstance () . getTimePeriodConverter ( new TimePeriod ( PeriodType . getMillisType () ) ) ;
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( PeriodType . getMillisType () ) ) ;
MillisDuration base = new MillisDuration ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getDayHourType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
PeriodType type
PeriodType type
if ( pos < NUMBER_CONSTANT ) { parser . parseMutableTimePeriod ( period . getPeriodType () , str ) ; }
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getMillisType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
test . add ( new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseAllType () ) ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearWeekType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearWeekType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
assertEquals ( test . getPeriodType () , copy . getPeriodType () ) ;
assertEquals ( test . getPeriodType () , copy . getPeriodType () ) ;
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getMillisType () ) ;
ReadablePeriod period
ReadablePeriod period
c = ConverterManager . getInstance () . getDurationConverter ( new Period ( PeriodType . getMillisType () ) ) ;
MutablePeriod result = test . toMutableTimePeriod () ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod () ;
{ MutablePeriod test = new MutablePeriod () ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
Period test = new Period ( STRING_CONSTANT ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( length , null ) ;
Period test = new Period ( length ) ;
Period test = new Period ( length ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
ReadablePeriod period
ReadablePeriod period
public void testSetDuration_RD () { setPeriod ( ( ReadableDuration ) null ) ; }
Period test = new Period ( NUMBER_CONSTANT ) ;
Period test = new Period ( NUMBER_CONSTANT ) ;
{ Period test = new Period ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
MutablePeriod test = new MutablePeriod ( STRING_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( length , null ) ;
MutablePeriod test = new MutablePeriod ( length ) ;
MutablePeriod test = new MutablePeriod ( length ) ;
MutablePeriod test = new MutablePeriod () ;
{ return STRING_CONSTANT + iInstantConverters . size () + STRING_CONSTANT + iDurationConverters . size () + STRING_CONSTANT + iPeriodConverters . size () + STRING_CONSTANT + iIntervalConverters . size () + STRING_CONSTANT ; }
ReadablePeriod period
ReadablePeriod period
Period duration ;
Class cls = ReadablePeriodConverter . class ;
public void testSetPeriod_2 () { setPeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testSetPeriod_1 () { setPeriod ( NUMBER_CONSTANT ) ; }
public void testSetDuration_RD_1 () { setDuration ( null ) ; }
{ if ( chrono == iChronology ) { return this ; } return PeriodType . getYearDayType ( chrono ) ; }
{ return PRECISE_ALL ; }
{ return PRECISE_YEAR_WEEK ; }
{ return PRECISE_YEAR_MONTH ; }
public static PeriodType getPreciseYearDayType () { return PRECISE_YEAR_DAY ; }
public static PeriodType getPreciseDayHourType () { return PRECISE_DAY_HOUR ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearWeekTypeUTC () ; }
{ return YEAR_WEEK ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearMonthTypeUTC () ; }
{ return YEAR_MONTH ; }
public static PeriodType getYearDayType () { return YEAR_DAY ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getAllTypeUTC () ; }
{ return ALL ; }
public static PeriodType getMillisType () { return MILLIS ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
public Duration ( long duration ) { super(); iMillis = duration ; }
protected AbstractDuration () { super(); }
{ long durationMillis = DateTimeUtils . getDurationMillis ( duration ) ; setStartMillis ( FieldUtils . safeAdd ( getEndMillis () , - durationMillis ) ) ; }
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
Object duration
public Duration ( long duration ) { super ( duration ) ; }
{ long endMillis = DateTimeUtils . getInstantMillis ( end ) ; setEndMillis ( endMillis ) ; }
{ long startMillis = DateTimeUtils . getInstantMillis ( start ) ; setStartMillis ( startMillis ) ; }
{ super . setStartMillis ( startInstant ) ; }
public void normalize () { setPeriod ( toDurationMillis () ) ; }
{ return new MutableDateTime ( getMillis () , chronology ) ; }
public MutableDateTime toMutableDateTime () { return new MutableDateTime ( getMillis () ) ; }
{ long instant = getChronology () . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; setMillis ( instant ) ; }
{ super ( partial , values ) ; }
{ super ( partial , values ) ; }
{ Chronology chrono = getChronology () . withZone ( zone ) ; return resolve ( baseInstant , chrono ) ; }
BaseGJChronology chronology
BaseGJChronology chronology
GJYearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
GJMonthOfYearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
BaseGJChronology chrono = iChronology ;
CopticYearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
BaseGJChronology chronology
GJWeekyearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
BaseGJChronology chronology
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
NoWeekyearZeroField ( BaseGJChronology chronology , DateTimeField field ) { super ( chronology , field ) ; }
BaseGJChronology chronology
public static TestSuite suite () { return new TestSuite ( TestParseISO . class ) ; }
public static TestSuite suite () { return new TestSuite ( TestDateTimeConstants . class ) ; }
{ millis = getField ( i , chrono ) . set ( millis , getValue ( i ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendSuffix ( new SimpleAffix ( text ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendPrefix ( new SimpleAffix ( text ) ) ; }
PeriodFieldAffix affix ;
PeriodFieldAffix affix ;
PeriodFieldAffix affix ;
PeriodFieldAffix suffix
int scan ( String periodStr , int position ) ;
int parse ( String periodStr , int position ) ;
PeriodFieldAffix suffix
PeriodFieldAffix prefix
{ if ( iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue ( period ) != Long.MAX_VALUE ) { return NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
public PeriodFormatterBuilder appendMillis () { appendField ( MILLIS ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithOptionalMillis () { appendField ( SECONDS_OPTIONAL_MILLIS ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithMillis () { appendField ( SECONDS_MILLIS ) ; return this ; }
public PeriodFormatterBuilder appendSeconds () { appendField ( SECONDS ) ; return this ; }
public PeriodFormatterBuilder appendMinutes () { appendField ( MINUTES ) ; return this ; }
public PeriodFormatterBuilder appendHours () { appendField ( HOURS ) ; return this ; }
public PeriodFormatterBuilder appendDays () { appendField ( DAYS ) ; return this ; }
public PeriodFormatterBuilder appendWeeks () { appendField ( WEEKS ) ; return this ; }
public PeriodFormatterBuilder appendMonths () { appendField ( MONTHS ) ; return this ; }
public PeriodFormatterBuilder appendYears () { appendField ( YEARS ) ; return this ; }
DateTimeComparator c = DateTimeComparator . getInstance ( DateTimeFieldType . hourOfDay () , DateTimeFieldType . dayOfYear () ) ;
DateTimeFieldType lowerLimit
public static DateTimeComparator getInstance () { return ALL_INSTANCE ; }
{ super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
if ( iParseField == null ) { iParseField = new PreciseDateTimeField ( DateTimeFieldType . millisOfSecond () , MillisDurationField.INSTANCE , iField . getDurationField () ) ; }
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . dayOfMonth () , days ) ; iChronology = chronology ; }
super ( gregorianField . getType () ) ;
public TestGJYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . year () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . weekOfWeekyear () , weeks ) ; iChronology = chronology ; }
private ISOYearOfEraDateTimeField () { super ( GregorianChronology . getInstanceUTC () . year () , DateTimeFieldType . yearOfEra () ) ; }
{ super ( DateTimeFieldType . dayOfWeek () , days ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chrono . millisPerMonth () , chrono ) ; }
{ super ( field , field . getType () ) ; iDurationField = durationField ; iRangeDurationField = rangeDurationField ; iLeapDurationField = leapDurationField ; }
super ( field . getType () ) ;
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . dayOfYear () , days ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . dayOfMonth () , days ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . monthOfYear () , months ) ; iChronology = chronology ; }
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( DateTimeFieldType . era () ) ; iChronology = chronology ; }
public DateTimeField era () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . era () , eras () ) ; }
public DateTimeField centuryOfEra () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . centuryOfEra () , centuries () ) ; }
public DateTimeField yearOfCentury () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . yearOfCentury () , years () ) ; }
public DateTimeField yearOfEra () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . yearOfEra () , years () ) ; }
public DateTimeField year () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . year () , years () ) ; }
public DateTimeField monthOfYear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . monthOfYear () , months () ) ; }
public DateTimeField weekyear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . weekyear () , weekyears () ) ; }
public DateTimeField weekOfWeekyear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . weekOfWeekyear () , weeks () ) ; }
public DateTimeField dayOfYear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . dayOfYear () , days () ) ; }
public DateTimeField dayOfMonth () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . dayOfMonth () , days () ) ; }
{ return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . dayOfWeek () , days () ) ; }
{ return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . halfdayOfDay () , UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ) ; }
public DateTimeField clockhourOfHalfday () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . clockhourOfHalfday () , hours () ) ; }
public DateTimeField hourOfHalfday () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . hourOfHalfday () , hours () ) ; }
public DateTimeField clockhourOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . clockhourOfDay () , hours () ) ; }
public DateTimeField hourOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . hourOfDay () , hours () ) ; }
public DateTimeField minuteOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . minuteOfDay () , minutes () ) ; }
public DateTimeField minuteOfHour () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . minuteOfHour () , minutes () ) ; }
public DateTimeField secondOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . secondOfDay () , seconds () ) ; }
public DateTimeField secondOfMinute () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . secondOfMinute () , seconds () ) ; }
public DateTimeField millisOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . millisOfDay () , millis () ) ; }
public DateTimeField millisOfSecond () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . millisOfSecond () , millis () ) ; }
{ super ( yearField , DateTimeFieldType . yearOfEra () ) ; iChronology = chronology ; }
LinkedDurationField ( DurationField durationField , ImpreciseCutoverField dateTimeField ) { super ( durationField , durationField . getType () ) ; iField = dateTimeField ; }
{ return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . halfdayOfDay () , halfdays () ) ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , chrono.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , chrono.MILLIS_PER_DAY , chrono ) ; }
public String toString () { return STRING_CONSTANT + getName () + CHAR_CONS ; }
{ super ( DateTimeFieldType . year () , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . year () , chrono . millisPerYear () , chrono ) ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , NUMBER_CONSTANT ) ;
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , chrono.MILLIS_PER_DAY , chrono ) ; }
super ( field . getType () ) ;
{ super ( DateTimeFieldType . year () , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . weekyear () , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . weekyear () , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , NUMBER_CONSTANT ) ;
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . millis () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . seconds () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . minutes () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . hours () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . days () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . weeks () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . months () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . years () ) ; }
{ super ( chrono ) ; iMonths = new ScaledDurationField ( chrono . days () , DurationFieldType . months () , NUMBER_CONSTANT ) ; }
{ super ( chrono ) ; iYears = new ScaledDurationField ( chrono . days () , DurationFieldType . years () , NUMBER_CONSTANT ) ; }
fields.centuryOfEra = new DividedDateTimeField ( ISOYearOfEraDateTimeField.INSTANCE , DateTimeFieldType . centuryOfEra () , NUMBER_CONSTANT ) ;
{ super ( DateTimeFieldType . monthOfYear () , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . monthOfYear () , chrono . millisPerMonth () , chrono ) ; }
public int size () { return NUMBER_CONSTANT ; }
int [] values = new int [ size () ] ;
int i = NUMBER_CONSTANT , isize = size ()
{ return getAsShortText ( partial , partial . get ( getType () ) , locale ) ; }
{ return getAsText ( partial , partial . get ( getType () ) , locale ) ; }
public int size () { return NUMBER_CONSTANT ; }
int size ( ) ;
partial . isSupported ( iField . getType () )
partial . isSupported ( iField . getType () )
partial . isSupported ( iField . getType () )
public int size () { return getFields () . length ; }
public static DateTimeFieldType era () { return ERA_TYPE ; }
public static DateTimeFieldType centuryOfEra () { return CENTURY_OF_ERA_TYPE ; }
public static DateTimeFieldType yearOfCentury () { return YEAR_OF_CENTURY_TYPE ; }
public static DateTimeFieldType yearOfEra () { return YEAR_OF_ERA_TYPE ; }
public static DateTimeFieldType year () { return YEAR_TYPE ; }
public static DateTimeFieldType monthOfYear () { return MONTH_OF_YEAR_TYPE ; }
public static DateTimeFieldType weekyearOfCentury () { return WEEKYEAR_OF_CENTURY_TYPE ; }
public static DateTimeFieldType weekyear () { return WEEKYEAR_TYPE ; }
public static DateTimeFieldType weekOfWeekyear () { return WEEK_OF_WEEKYEAR_TYPE ; }
public static DateTimeFieldType dayOfYear () { return DAY_OF_YEAR_TYPE ; }
public static DateTimeFieldType dayOfMonth () { return DAY_OF_MONTH_TYPE ; }
public static DateTimeFieldType dayOfWeek () { return DAY_OF_WEEK_TYPE ; }
public static DateTimeFieldType halfdayOfDay () { return HALFDAY_OF_DAY_TYPE ; }
public static DateTimeFieldType clockhourOfHalfday () { return CLOCKHOUR_OF_HALFDAY_TYPE ; }
public static DateTimeFieldType hourOfHalfday () { return HOUR_OF_HALFDAY_TYPE ; }
public static DateTimeFieldType clockhourOfDay () { return CLOCKHOUR_OF_DAY_TYPE ; }
public static DateTimeFieldType hourOfDay () { return HOUR_OF_DAY_TYPE ; }
public static DateTimeFieldType minuteOfDay () { return MINUTE_OF_DAY_TYPE ; }
public static DateTimeFieldType minuteOfHour () { return MINUTE_OF_HOUR_TYPE ; }
public static DateTimeFieldType secondOfDay () { return SECOND_OF_DAY_TYPE ; }
public static DateTimeFieldType secondOfMinute () { return SECOND_OF_MINUTE_TYPE ; }
public static DateTimeFieldType millisOfDay () { return MILLIS_OF_DAY_TYPE ; }
public static DateTimeFieldType millisOfSecond () { return MILLIS_OF_SECOND_TYPE ; }
int otherValue = getFieldType () . getField ( chrono ) . get ( instant . getMillis () ) ;
public static DurationFieldType eras () { return ERAS_TYPE ; }
public static DurationFieldType centuries () { return CENTURIES_TYPE ; }
public static DurationFieldType years () { return YEARS_TYPE ; }
public static DurationFieldType months () { return MONTHS_TYPE ; }
public static DurationFieldType weekyears () { return WEEKYEARS_TYPE ; }
public static DurationFieldType weeks () { return WEEKS_TYPE ; }
public static DurationFieldType days () { return DAYS_TYPE ; }
public static DurationFieldType halfdays () { return HALFDAYS_TYPE ; }
public static DurationFieldType hours () { return HOURS_TYPE ; }
public static DurationFieldType minutes () { return MINUTES_TYPE ; }
public static DurationFieldType seconds () { return SECONDS_TYPE ; }
public static DurationFieldType millis () { return MILLIS_TYPE ; }
assertEquals ( false , test . isAfter ( ( ReadableInstant ) null ) ) ;
assertEquals ( false , test . isBefore ( ( ReadableInstant ) null ) ) ;
assertEquals ( false , test . isAfter ( ( ReadableInstant ) null ) ) ;
assertEquals ( false , test . isBefore ( ( ReadableInstant ) null ) ) ;
{ if ( instant == null ) { return isAfterNow () ; } return isAfter ( instant . getMillis () ) ; }
{ if ( instant == null ) { return isBeforeNow () ; } return isBefore ( instant . getMillis () ) ; }
{ if ( instant == null ) { return containsNow () ; } return contains ( instant . getMillis () ) ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period result = test . withPeriodType ( PeriodType . standard () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . dayTime () ) ) ) ;
{ Period test = new Period ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . standard () , test . getPeriodType () ) ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
test = new MutablePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . millis () ) ;
{ super . setField ( DurationFieldType . millis () , millis ) ; }
{ super . setField ( DurationFieldType . seconds () , seconds ) ; }
{ super . setField ( DurationFieldType . minutes () , minutes ) ; }
{ super . setField ( DurationFieldType . hours () , hours ) ; }
{ super . setField ( DurationFieldType . days () , days ) ; }
{ super . setField ( DurationFieldType . weeks () , weeks ) ; }
{ super . setField ( DurationFieldType . months () , months ) ; }
{ super . setField ( DurationFieldType . years () , years ) ; }
{ setPeriod ( duration , null ) ; }
{ super ( period , type , null ) ; }
{ super ( period , null , null ) ; }
public MutablePeriod ( PeriodType type ) { super ( NUMBER_CONSTANT , type , null ) ; }
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . dayTime () ) ) ) ;
{ MutablePeriod test = new MutablePeriod () ; assertEquals ( PeriodType . standard () , test . getPeriodType () ) ; }
{ super ( period , type , null ) ; }
{ super ( period , null , null ) ; }
{ if ( period != null ) { setMillis ( period . addTo ( getMillis () , scalar , getChronology () ) ) ; } }
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
{ test1 . year () . compareTo ( ( ReadableInstant ) null ) ; fail () ; }
assertEquals ( PeriodType . standard () , test . getPeriodType () ) ;
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setStartMillis ( chrono . add ( getEndMillis () , period , - NUMBER_CONSTANT ) ) ; }
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setEndMillis ( chrono . add ( getStartMillis () , period , NUMBER_CONSTANT ) ) ; }
{ if ( period != null ) { setMillis ( getChronology () . add ( getMillis () , period , scalar ) ) ; } }
assertEquals ( PeriodType . standard () , test . getPeriodType () ) ;
try { test . setYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , millis } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , seconds , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , minutes , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , hours , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , days , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , weeks , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , months , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
new Period ( new int [] { years , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () )
{ duration . setPeriod ( ( Period ) null ) ; }
iIntervalConverters = new ConverterSet ( new Converter [] { ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
{ super . setInterval ( getStartMillis () , endInstant , getChronology () ) ; }
{ super . setInterval ( startInstant , getEndMillis () , getChronology () ) ; }
public long toDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
{ IntervalConverter [] array = ConverterManager . getInstance () . getIntervalConverters () ; assertEquals ( INTERVAL_SIZE , array.length ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
public long toDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
DateTime getEnd ( ) ;
DateTime getStart ( ) ;
{ MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . toDuration () ) ; }
Interval result = test . withEnd ( null ) ;
{ test . withEnd ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withEnd ( new Instant ( TEST_TIME2 - NUMBER_CONSTANT ) ) ;
Interval result = test . withStart ( null ) ;
{ test . withStart ( new Instant ( TEST_TIME2 + NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withStart ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ;
{ Interval test = new Interval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . toDuration () ) ; }
{ return ( ( ( ReadableInterval ) object ) ) . toDurationMillis () ; }
iValues = chronology . get ( this , millis ) ;
iValues = chronology . get ( this , millis ) ;
iValues = chronology . get ( this , instant ) ;
long resolved = chrono . set ( this , instantMillis ) ;
{ Chronology chrono = getChronology () . withZone ( zone ) ; return chrono . set ( this , baseInstant ) ; }
{ if ( period != null ) { setMillis ( getChronology () . add ( period , getMillis () , scalar ) ) ; } }
if ( period == null ) { iStartMillis = iEndMillis ; } else { iStartMillis = chrono . add ( period , iEndMillis , - NUMBER_CONSTANT ) ; }
if ( period == null ) { iEndMillis = iStartMillis ; } else { iEndMillis = chrono . add ( period , iStartMillis , NUMBER_CONSTANT ) ; }
long instant = getChronology () . add ( period , getMillis () , scalar ) ;
{ if ( period == null ) { setValues ( new int [ size () ] ) ; } else { setPeriodInternal ( period ) ; } }
long endMillis = chrono . add ( this , startMillis , NUMBER_CONSTANT ) ;
iValues = chrono . get ( this , startMillis , endMillis ) ;
{ setStartMillis ( getChronology () . add ( period , getEndMillis () , - NUMBER_CONSTANT ) ) ; }
{ setEndMillis ( getChronology () . add ( period , getStartMillis () , NUMBER_CONSTANT ) ) ; }
{ if ( period != null ) { super . addPeriod ( period ) ; } }
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
{ if ( partial == null ) { return this ; } return withMillis ( getChronology () . set ( partial , getMillis () ) ) ; }
DateTime result = test . toDateTimeUsing ( null ) ;
{ long millis = this . iChrono . withUTC () . set ( partial , NUMBER_CONSTANT ) ; printTo ( null , out , millis ) ; }
long millis = this . iChrono . withUTC () . set ( partial , NUMBER_CONSTANT ) ;
DateTime result = test . toDateTimeUsing ( null ) ;
{ return new Period ( getStartMillis () , getEndMillis () , type , getChronology () ) ; }
{ return new Period ( getStartMillis () , getEndMillis () , getChronology () ) ; }
{ return new MutableInterval ( getStartMillis () , getEndMillis () , getChronology () ) ; }
{ return new Interval ( getStartMillis () , getEndMillis () , getChronology () ) ; }
Interval test4 = new Interval ( TEST_TIME1 , TEST_TIME2 , Chronology . getGJ () ) ;
{ if ( endInstant == getEndMillis () ) { return this ; } return new Interval ( getStartMillis () , endInstant , getChronology () ) ; }
{ if ( startInstant == getStartMillis () ) { return this ; } return new Interval ( startInstant , getEndMillis () , getChronology () ) ; }
{ test . set ( DateTimeFieldType . monthOfYear () , NUMBER_CONSTANT ) ; fail () ; }
test . set ( DateTimeFieldType . year () , NUMBER_CONSTANT ) ;
Object f
Object f
Object f
public DateTimeFormatterBuilder appendEraText () { return appendText ( DateTimeFieldType . era () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearShortText () { return appendShortText ( DateTimeFieldType . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearText () { return appendText ( DateTimeFieldType . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekShortText () { return appendShortText ( DateTimeFieldType . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekText () { return appendText ( DateTimeFieldType . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendHalfdayOfDayText () { return appendText ( DateTimeFieldType . halfdayOfDay () ) ; }
String text
char c
Object element
DateTimeParser parser
DateTimeParser parser
DateTimePrinter printer
DateTimeFormatter formatter
Chronology chrono
DateTimeZone zone
public MutableDateTime parseMutableDateTime ( String text ) { return mParser . parseMutableDateTime ( text ) ; }
public DateTime parseDateTime ( String text ) { return mParser . parseDateTime ( text ) ; }
public long parseMillis ( String text ) { return mParser . parseMillis ( text ) ; }
public String print ( long instant ) { throw unsupported () ; }
public String print ( ReadableInstant instant ) { throw unsupported () ; }
FParser ( DateTimeParser parser ) { super(); mParser = parser ; }
public MutableDateTime parseMutableDateTime ( String text ) { throw unsupported () ; }
public DateTime parseDateTime ( String text ) { throw unsupported () ; }
public long parseMillis ( String text ) { throw unsupported () ; }
public String print ( long instant ) { return mPrinter . print ( instant ) ; }
public String print ( ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
FPrinter ( DateTimePrinter printer ) { super(); mPrinter = printer ; }
iMillis = converter . getInstantMillis ( instant , Chronology . getISOUTC () ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
{ PartialConverter [] array = ConverterManager . getInstance () . getPartialConverters () ; assertEquals ( PARTIAL_SIZE , array.length ) ; }
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
iPartialConverters = new ConverterSet ( new Converter [] { ReadablePartialConverter.INSTANCE , ReadableInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
throw new InternalError () ;
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , UnsupportedDurationField . getInstance ( getDurationType () ) ) ; }
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , UnsupportedDurationField . getInstance ( getDurationType () ) ) ; }
throw new InternalError () ;
try { MillisDurationField.INSTANCE . getDifferenceAsLong ( Long.MAX_VALUE , - NUMBER_CONSTANT ) ; fail () ; } catch ( ArithmeticException ex ) {}
{ return FieldUtils . safeMultiply ( value , getUnitMillis () ) ; }
{ return FieldUtils . safeMultiply ( value , iUnitMillis ) ; }
BaseDateTimeField field = new MockStandardBaseDateTimeField () ;
PreciseDateTimeField field = new MockPreciseDateTimeField () ;
DateTimeParser dateTimeParser = ISODateTimeFormat . getInstance ( chrono ) . dateTimeParser () ;
{ assertEquals ( PARIS , DateTimeUtils . getZone ( PARIS ) ) ; assertEquals ( DateTimeZone . getDefault () , DateTimeUtils . getZone ( null ) ) ; }
return printTimeZone ( getOffset ( instant ) ) ;
return printTimeZone ( getOffset ( instant ) ) ;
{ convId = printTimeZone ( offset ) ; return fixedOffsetZone ( convId , offset ) ; }
BasePeriodFormatter [] parsers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
Separator finish ( BasePeriodFormatter after ) { iAfter = after ; return this ; }
BasePeriodFormatter before
BasePeriodFormatter composite = createComposite ( formatters ) ;
DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder ( iLocale ) ;
DateTimeParser p = ISODateTimeFormat . getInstance () . hourMinuteSecondFraction () ;
return DateTimeFormat . getInstance ( locale ) . forPattern ( pattern ) . print ( this ) ;
return DateTimeFormat . getInstance () . forPattern ( pattern ) . print ( this ) ;
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket = new ParseBucket ( instantLocal , chrono ) ;
ParseBucket bucket = new ParseBucket ( NUMBER_CONSTANT , chrono ) ;
ParseBucket bucket = new ParseBucket ( instantLocal , chrono ) ;
{ if ( permission instanceof JodaTimePermission ) { return false ; } return true ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return true ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return true ; }
iFieldType >= SECONDS_MILLIS
{ return appendSeparator ( text , finalText , null , true , true ) ; }
{ return appendSeparator ( text , text , null , true , true ) ; }
int offset = - ( int ) offsetFormatter () . parseMillis ( convId , ISOChronology . getInstance ( UTC ) ) ;
int offset = - ( int ) offsetFormatter () . parseMillis ( id , ISOChronology . getInstance ( UTC ) ) ;
int itimeStyle = selectStyle ( timeStyle ) ;
DateTimeField field = iFieldType . getField ( chronoLocal ) ;
return printOffset ( getOffset ( instant ) ) ;
return printOffset ( getOffset ( instant ) ) ;
String id = printOffset ( offset ) ;
return new MutableDateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new MutableDateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , chrono ) , chrono ) ; }
return new DateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new DateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , chrono ) , chrono ) ; }
return ( ( DateTimePrinter ) this ) . print ( millis , chrono ) ;
( ( DateTimePrinter ) this ) . printTo ( out , millis , chrono ) ;
( ( DateTimePrinter ) this ) . printTo ( buf , millis , chrono ) ;
public MutableDateTime parseMutableDateTime ( String text , ReadableInstant instant ) { return iParser . parseMutableDateTime ( text , instant ) ; }
public MutableDateTime parseMutableDateTime ( String text , Chronology chrono ) { return iParser . parseMutableDateTime ( text , chrono ) ; }
public DateTime parseDateTime ( String text , ReadableInstant instant ) { return iParser . parseDateTime ( text , instant ) ; }
public DateTime parseDateTime ( String text , Chronology chrono ) { return iParser . parseDateTime ( text , chrono ) ; }
{ return iParser . parseMillis ( text , instant , chrono ) ; }
{ return iParser . parseInto ( instant , text , position ) ; }
public String print ( long instant , Chronology chrono ) { return iPrinter . print ( instant , chrono ) ; }
public String print ( long instant , DateTimeZone zone ) { return iPrinter . print ( instant , zone ) ; }
{ iPrinter . printTo ( out , instant , chrono ) ; }
{ iPrinter . printTo ( buf , instant , chrono ) ; }
{ iPrinter . printTo ( out , instant , zone ) ; }
{ iPrinter . printTo ( buf , instant , zone ) ; }
public void printTo ( Writer out , long instant ) throws IOException { iPrinter . printTo ( out , instant ) ; }
{ iPrinter . printTo ( out , instant ) ; }
public int estimateParsedLength () { return iParsedLengthEstimate ; }
public int estimateParsedLength () { return iParsedLengthEstimate ; }
DateTimePrinter [] elements = iPrinters ;
DateTimePrinter [] elements = iPrinters ;
public int estimatePrintedLength () { return iPrintedLengthEstimate ; }
DateTimeFormatter [] printers
public int estimatePrintedLength () { return iShortFormat ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
public int estimateParsedLength () { return estimatePrintedLength () ; }
public int estimateParsedLength () { return iMaxDigits ; }
public int estimatePrintedLength () { return iMaxDigits ; }
public int estimateParsedLength () { return estimatePrintedLength () ; }
public int estimatePrintedLength () { return iShort ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
public int estimatePrintedLength () { return NUMBER_CONSTANT ; }
public int estimateParsedLength () { return NUMBER_CONSTANT ; }
public int estimatePrintedLength () { return iMaxParsedDigits ; }
public int estimatePrintedLength () { return iMaxParsedDigits ; }
public int estimateParsedLength () { return iMaxParsedDigits ; }
DateTimeParserBucket bucket
public int estimateParsedLength () { return NUMBER_CONSTANT ; }
PeriodFormatter [] parsers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
Separator finish ( PeriodFormatter after ) { iAfter = after ; return this ; }
PeriodFormatter before
PeriodFormatter composite = createComposite ( formatters ) ;
{ return getField () . remainder ( getMillis () ) ; }
{ return getField () . getMaximumValue ( getMillis () ) ; }
{ return getField () . getMinimumValue ( getMillis () ) ; }
{ return getField () . getLeapAmount ( getMillis () ) ; }
{ return getField () . isLeap ( getMillis () ) ; }
{ return getField () . getAsShortText ( getMillis () , locale ) ; }
{ return getField () . getAsText ( getMillis () , locale ) ; }
{ return getField () . get ( getMillis () ) ; }
if ( value == getValue ( index ) ) { return this ; }
fields.era = ThaiBuddhistEraDateTimeField.INSTANCE ;
{ zone = DateTimeZone . forTimeZone ( cal . getTimeZone () ) ; }
DateTimeZone . setDefault ( DateTimeZone . forID ( STRING_CONSTANT ) ) ;
iChronology = ISOChronology . getInstance ( DateTimeZone . forID ( id ) ) ;
zones [ i ++ ] = new ZoneData ( id , DateTimeZone . forID ( id ) ) ;
z = DateTimeZone . forID ( str ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
{ DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , zone . getID () ) ; }
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , TestGJChronology.MILLIS_PER_DAY , chrono ) ; }
int dayOfWeek = ( int ) TestGJChronology . mod ( iChronology . fixedFromMillis ( millis ) , NUMBER_CONSTANT ) ;
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , TestGJChronology.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , TestGJChronology.MILLIS_PER_DAY , chrono ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . withLocale ( locale ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . print ( this ) ; }
return - ( int ) offsetFormatter () . withChronology ( chrono ) . parseMillis ( str ) ;
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . withLocale ( locale ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . print ( this ) ; }
return cOffsetFormatter . withZone ( iZone ) . print ( millis ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
parse ( ISODateTimeFormat . dateTimeParser () ) ;
DateTimeFormatter p
DateTimePrinter [] printers
{ return append0 ( new TimeZoneOffset ( zeroOffsetText , showSeparators , minFields , maxFields ) ) ; }
{ return append0 ( new TimeZonePrinter ( true ) , null ) ; }
{ return append0 ( new TimeZonePrinter ( false ) , null ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , true ) ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , false ) ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter () , formatter . getParser () ) ; }
DateTimeFormatter p = ISODateTimeFormat . hourMinuteSecondFraction () ;
try { g . parseMutableDateTime ( STRING_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { g . parseDateTime ( STRING_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
bucket . saveField ( iType , year ) ;
append0 ( field , field ) ;
append0 ( literal , literal ) ;
append0 ( formatter . getPrinter () , formatter . getParser () ) ;
PeriodFormatter formatter = toFormatter ( iElementPairs ) ;
public PeriodParser toParser () { return toFormatter () . getParser () ; }
public PeriodPrinter toPrinter () { return toFormatter () . getPrinter () ; }
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
f = ISOPeriodFormat . standard () ;
{ return ISOPeriodFormat . standard () . print ( this ) ; }
PeriodFormatter periodParser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
InputStream in = new ByteArrayInputStream ( data . getBytes ( STRING_CONSTANT ) ) ;
PeriodFormatter parser = PeriodFormat . getDefault () ;
Locale locale
Locale locale
Locale locale
Locale locale
fields.year = new BasicYearDateTimeField ( this ) ;
fields.year = new BasicYearDateTimeField ( this ) ;
fields.year = new GJYearDateTimeField ( this ) ;
fields.year = new CopticYearDateTimeField ( this ) ;
{ if ( iZone == zone ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , false , iChrono , zone , iPivotYear ) ; }
{ if ( iChrono == chrono ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , iOffsetParsed , chrono , iZone , iPivotYear ) ; }
{ if ( iOffsetParsed == true ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , true , iChrono , null , iPivotYear ) ; }
return new DateTimeFormatter ( iPrinter , iParser , locale , iOffsetParsed , iChrono , iZone , iPivotYear ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
{ return appendTwoDigitWeekyear ( pivot , false ) ; }
{ return appendTwoDigitYear ( pivot , false ) ; }
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalFieldValueException ( DateTimeFieldType . era () , text ) ; } return instant ; }
catch ( NumberFormatException ex ) { throw new IllegalFieldValueException ( getType () , text ) ; }
FieldUtils . verifyValueBounds ( DateTimeFieldType . millisOfDay () , millisOfDay , NUMBER_CONSTANT , DateTimeConstants.MILLIS_PER_DAY ) ;
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalFieldValueException ( DateTimeFieldType . era () , text ) ; } return instant ; }
throw new IllegalFieldValueException ( DateTimeFieldType . halfdayOfDay () , text ) ;
throw new IllegalFieldValueException ( DateTimeFieldType . dayOfWeek () , text ) ;
throw new IllegalFieldValueException ( DateTimeFieldType . monthOfYear () , text ) ;
throw new IllegalFieldValueException ( DateTimeFieldType . era () , text ) ;
suite . addTest ( TestIllegalFieldValueException . suite () ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
public int getMinimumDaysInFirstWeek () { return iMinDaysInFirstWeek ; }
DateTimeZone test = DateTimeZone . forID ( STRING_CONSTANT ) ;
protected DateTimeFormat () { super(); }
protected PeriodFormat () { super(); }
protected ISOPeriodFormat () { super(); }
cfg . setProperty ( STRING_CONSTANT , STRING_CONSTANT + getClass () . getName () ) ;
fields.era = ERA_FIELD ;
Period test = new Period ( length , PeriodType . standard () , ISOChronology . getInstanceUTC () ) ;
Period test = new Period ( length , PeriodType . time () . withMillisRemoved () , ISOChronology . getInstance () ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( ISOChronology . getInstance () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == ISOChronology . getInstance () . minutes () . hashCode () ) ;
assertEquals ( false , iField . equals ( ISOChronology . getInstance () . minutes () ) ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
Chronology chrono = GJChronology . getInstanceUTC () ;
assertEquals ( - NUMBER_CONSTANT , MillisDurationField.INSTANCE . compareTo ( ISOChronology . getInstance () . seconds () ) ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( ISOChronology . getInstance () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == ISOChronology . getInstance () . minutes () . hashCode () ) ;
assertEquals ( false , iField . equals ( ISOChronology . getInstance () . minutes () ) ) ;
{ FieldUtils . verifyValueBounds ( ISOChronology . getInstance () . monthOfYear () , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail () ; }
Chronology chrono = ISOChronology . getInstance ( ZONES [ i ] ) ;
Chronology chrono = ISOChronology . getInstance ( ZONES [ i ] ) ;
Chronology chrono = GregorianChronology . getInstance () ;
actual = ReadablePartialConverter.INSTANCE . getPartialValues ( tod , new TimeOfDay ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , ISOChronology . getInstance ( PARIS ) )
int [] actual = NullConverter.INSTANCE . getPartialValues ( tod , null , ISOChronology . getInstance () ) ;
assertEquals ( new Interval ( TEST_TIME1 , TEST_TIME2 , ISOChronology . getInstance () ) , test ) ;
test . add ( ms , ISOChronology . getInstanceUTC () ) ;
test . add ( ms , ISOChronology . getInstance () ) ;
test . add ( NUMBER_CONSTANT , ISOChronology . getInstance () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
try { type . getField ( CopticChronology . getInstanceUTC () ) ; fail () ; } catch ( InternalError ex ) {}
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
int [] actual = StringConverter.INSTANCE . getPartialValues ( tod , STRING_CONSTANT , ISOChronology . getInstance () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
try { type . getField ( CopticChronology . getInstanceUTC () ) ; fail () ; } catch ( InternalError ex ) {}
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , ISOChronology . getInstanceUTC () ) ;
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , ISOChronology . getInstance () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . standard () , ISOChronology . getInstanceUTC () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . time () . withMillisRemoved () , ISOChronology . getInstance () ) ;
ReadableIntervalConverter.INSTANCE . setInto ( m , i , CopticChronology . getInstance () ) ;
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
public Chronology getChronology () { return ChronologyType . iso () . getChronologyUTC () ; }
iMillis = converter . getInstantMillis ( instant , ChronologyType . iso () . getChronologyUTC () ) ;
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = ChronologyType . iso () . getChronology () ; }
{ return ChronologyType . iso () . getChronology ( zone ) ; }
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
iZone = zone ;
iZone = zone ;
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiply ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiply ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . addWrapPartial ( this , index , newValues , FieldUtils . safeMultiply ( period . getValue ( i ) , scalar ) ) ; }
if ( val < NUMBER_CONSTANT ) { System.out . println ( STRING_CONSTANT ) ; }
if ( val < NUMBER_CONSTANT ) { System.out . println ( STRING_CONSTANT ) ; }
cal . setTime ( convertToDate ( cal ) ) ;
cal . setTime ( convertToDate ( cal ) ) ;
{ out . write ( print ( instant - displayOffset , displayZone , locale ) ) ; }
{ buf . append ( print ( instant - displayOffset , displayZone , locale ) ) ; }
{ return ISOChronology . getInstance ( zone ) ; }
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = ISOChronology . getInstance () ; }
{ super ( ISOChronology . getInstance ( zone ) ) ; }
{ return ISOChronology . getInstance ( zone ) ; }
public Chronology getChronology () { return ISOChronology . getInstanceUTC () ; }
iMillis = converter . getInstantMillis ( instant , ISOChronology . getInstanceUTC () ) ;
{ super ( ISOChronology . getInstance ( zone ) ) ; }
return iChronology . getDaysInYearMax () ;
return iChronology . getDaysInYearMax () ;
FieldUtils . verifyValueBounds ( this , month , MIN , iMax ) ;
long difference = ( minuendYear - subtrahendYear ) * ( ( long ) iMax ) + minuendMonth - subtrahendMonth ;
{ return set ( instant , FieldUtils . getWrappedValue ( get ( instant ) , months , MIN , iMax ) ) ; }
assertEquals ( false , EthiopicChronology . getInstanceUTC () . months () . isPrecise () ) ;
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * MILLIS_PER_DAY ; return new TestSuite ( TestEthiopicChronology . class ) ; }
assertEquals ( false , CopticChronology . getInstanceUTC () . months () . isPrecise () ) ;
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * MILLIS_PER_DAY ; return new TestSuite ( TestCopticChronology . class ) ; }
fields.monthOfYear = new IslamicMonthOfYearDateTimeField ( this ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
fields.monthOfYear = new BasicMonthOfYearDateTimeField ( this , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
BasicChronology chronology
GJEraDateTimeField ( BasicChronology chronology ) { super ( DateTimeFieldType . era () ) ; iChronology = chronology ; }
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
GJMonthOfYearDateTimeField ( BasicChronology chronology ) { super ( chronology , NUMBER_CONSTANT ) ; }
BasicChronology chronology
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
{ int len = parser . estimateParsedLength () ; if ( len > est ) { est = len ; } }
long instant = chronology . getDateTimeMillis ( NUMBER_CONSTANT , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
LocalTime test = LocalTime . forInstant ( ( Object ) null , JULIAN_LONDON ) ;
LocalTime test = LocalTime . forInstant ( date , JULIAN_LONDON ) ;
LocalTime test = LocalTime . forInstant ( TEST_TIME2 , JULIAN_LONDON ) ;
LocalTime test = LocalTime . now ( JULIAN_LONDON ) ;
LocalTime test = LocalTime . fromMillisOfDay ( TEST_TIME1 , JULIAN_LONDON ) ;
assertEquals ( false , test . isSupported ( DurationFieldType . eras () ) ) ;
DateMidnight test = base . toDateMidnight () ;
DateTime test = base . toDateTimeAtCurrentTime () ;
DateTime test = base . toDateTimeAtMidnight () ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate () ;
LocalDate test = new LocalDate () ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
public void testSize () { LocalDate test = new LocalDate () ; assertEquals ( NUMBER_CONSTANT , test . size () ) ; }
LocalDate test = new LocalDate () ;
DateTime test = base . toDateTimeToday () ;
long getApproxMillisAtEpochDividedByTwo () { return ( - MILLIS_YEAR_1 ) / NUMBER_CONSTANT ; }
long millis = bucket . computeMillis ( true , text ) ;
long millis = bucket . computeMillis ( true , text ) ;
{ if ( newPos >= text . length () ) { return bucket . computeMillis ( true , text ) ; } }
instant . setMillis ( bucket . computeMillis ( false , text ) ) ;
public long computeMillis () { return computeMillis ( false , null ) ; }
test = new DateMidnight ( TEST_TIME1_UTC , GREGORIAN_PARIS ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( false , test1 . equals ( new DateMidnight ( TEST_TIME1_UTC , GREGORIAN_DEFAULT ) ) ) ;
assertEquals ( ISO_DEFAULT , test . getChronology () ) ;
test = new DateTime ( TEST_TIME1 , GREGORIAN_PARIS ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( ISO_DEFAULT , test . getChronology () ) ;
long millis = converter . getInstantMillis ( instant , chronology , ISODateTimeFormat . dateParser () ) ;
long millis = converter . getInstantMillis ( instant , chronology , ISODateTimeFormat . dateParser () ) ;
long millis = converter . getInstantMillis ( instant , chronology , ISODateTimeFormat . timeParser () ) ;
long millis = converter . getInstantMillis ( instant , chronology , ISODateTimeFormat . timeParser () ) ;
{ super ( instant , DateTimeUtils . getChronology ( chronology ) , ISODateTimeFormat . timeParser () ) ; }
{ super ( instant , null , ISODateTimeFormat . timeParser () ) ; }
int index = ( ( dateStyle < < NUMBER_CONSTANT ) + dateStyle ) + timeStyle ;
public LocalDateTime withMinimumValue () { return setCopy ( getMinimumValue () ) ; }
{ return setCopy ( getMaximumValue () ) ; }
public LocalDate withMinimumValue () { return setCopy ( getMinimumValue () ) ; }
{ return setCopy ( getMaximumValue () ) ; }
public LocalTime withMinimumValue () { return setCopy ( getMinimumValue () ) ; }
public LocalTime withMaximumValue () { return setCopy ( getMaximumValue () ) ; }
LocalDateTime copy = test . millisOfSecond () . setCopy ( STRING_CONSTANT ) ;
LocalDateTime copy = test . secondOfMinute () . setCopy ( STRING_CONSTANT ) ;
LocalDateTime copy = test . minuteOfHour () . setCopy ( STRING_CONSTANT ) ;
LocalDateTime copy = test . hourOfDay () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . millisOfSecond () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . secondOfMinute () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . minuteOfHour () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . hourOfDay () . setCopy ( STRING_CONSTANT ) ;
assertEquals ( false , interval33 . contains ( new Instant ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( false , interval33 . containsNow () ) ;
assertEquals ( false , interval33 . contains ( NUMBER_CONSTANT ) ) ;
return FieldUtils . equals ( getChronology () , other . getChronology () ) ;
public synchronized Set getAvailableIDs () { return new TreeSet ( iZoneInfoMap . keySet () ) ; }
if ( value >= min && value <= getMaximumValue ( instant ) ) { return super . set ( instant , value ) ; }
DateTimeZone tz = builder . toDateTimeZone ( STRING_CONSTANT , true ) ;
builder . writeTo ( STRING_CONSTANT , out ) ;
super ( createMessage ( fieldName , value , lowerBound , upperBound , null ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound , null ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound , null ) ) ;
try { test . minusYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
try { test . plusYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
try { test . withYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
{ printTo ( out , instant , null ) ; }
{ printTo ( buf , instant , null ) ; }
DateTime now = new DateTime ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
( offsetLocal - offsetAdjusted ) < NUMBER_CONSTANT
{ t = new DateTimeFormatterBuilder () . append ( hourMinuteSecondFraction () ) . append ( offsetElement () ) . toFormatter () ; }
DateTime start = base . toDateTimeAtStartOfDay ( LONDON ) ;
DateTime start = base . toDateTimeAtStartOfDay ( TOKYO ) ;
DateTime start = base . toDateTimeAtStartOfDay () ;
DateFormatSymbols dfs = DateTimeUtils . getDateFormatSymbols ( locale ) ;
String [] [] zoneStrings = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
throw new IllegalArgumentException ( STRING_CONSTANT + id + STRING_CONSTANT ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + id + STRING_CONSTANT ) ;
{ Hibernate.DATE . nullSafeSet ( preparedStatement , ( ( LocalDate ) value ) . toDateTimeAtStartOfDay () . toDate () , index ) ; }
ReadablePartial partial
ReadableInstant readableInstant
DurationField durationField
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
List < Object > list
List < Object > elementPairs
List < Object > elementPairs
List < Object > pairs = iElementPairs ;
if ( iElementPairs == null ) { iElementPairs = new ArrayList < Object > () ; } else { iElementPairs . clear () ; }
Map < String , RuleSet > ruleSets
{ iRules = new ArrayList < Rule > () ; iRules . add ( rule ) ; }
public int compareTo ( DurationField durationField ) { return iField . compareTo ( durationField ) ; }
Class < > type
Class < > type
iRules = new ArrayList < Rule > ( rs.iRules ) ;
RuleSet () { iRules = new ArrayList < Rule > ( NUMBER_CONSTANT ) ; iUpperYear = Integer.MAX_VALUE ; }
ReadablePartial partial
f = cCache . get ( key ) ;
formatter = cPatternedCache . get ( pattern ) ;
ReadablePartial partial
Map < String , Object > zimap
iZoneInfoMap . put ( id , new SoftReference < DateTimeZone > ( tz ) ) ;
public int compareTo ( DurationField durationField ) { return NUMBER_CONSTANT ; }
List < Object > list
public DateTimeFormatterBuilder () { super(); iElementPairs = new ArrayList < Object > () ; }
HashMap < Object , Object > converted
HashMap < Object , Object > converted
HashMap < Object , Object > converted
HashMap < Object , Object > converted
TreeMap < String , Integer > map
TreeMap < String , Integer > map
symbols = cCache . get ( locale ) ;
ReadableDuration obj
chrono = cCache . get ( zone ) ;
try { Single . between ( start , new LocalTime () , zero ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
assertEquals ( STRING_CONSTANT , f . withZoneUTC () . print ( dt ) ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.KOREAN ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withPivotYear ( NUMBER_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withPivotYear ( NUMBER_CONSTANT ) . withZoneUTC () ;
{ if ( ldp == null ) { ldp = dateElementParser () . withZoneUTC () ; } return ldp ; }
{ if ( value == null ) { return null ; } return new Instant ( value ) ; }
{ return org.joda.time.gwt.util.Arrays . copyOf ( iValues , iValues.length ) ; }
{ return Arrays . copyOf ( iValues , iValues.length ) ; }
TimeZone . setDefault ( DateTimeZone . forID ( STRING_CONSTANT ) . toTimeZone () ) ;
Locale . setDefault ( Locale.JAPAN ) ;
{ locale = Locale . getDefault () ; zone = DateTimeZone . getDefault () ; Locale . setDefault ( Locale.JAPAN ) ; }
Locale . setDefault ( Locale.JAPAN ) ;
Locale . setDefault ( Locale.JAPAN ) ;
Locale . setDefault ( Locale.JAPAN ) ;
TimeZone . setDefault ( DateTimeZone . forID ( STRING_CONSTANT ) . toTimeZone () ) ;
Locale . setDefault ( Locale.JAPAN ) ;
Locale . setDefault ( Locale.JAPAN ) ;
public YearMonth getYearMonth () { return iBase ; }
protected ReadablePartial getReadablePartial () { return iBase ; }
public DateTimeField getField () { return iBase . getField ( iFieldIndex ) ; }
{ super(); iBase = partial ; iFieldIndex = fieldIndex ; }
Map < String , Object > map = new ConcurrentHashMap < String , Object > () ;
DateTimeZone . setDefault ( PARIS ) ;
return iZone . convertLocalToUTC ( localInstant , false , instant ) ;
return iZone . convertLocalToUTC ( localInstant , false , instant ) ;
return iZone . convertLocalToUTC ( localInstant , false , instant ) ;
long result = iZone . convertLocalToUTC ( localInstant , false , instant ) ;
return iZone . convertLocalToUTC ( localInstant , false , instant ) ;
return iZone . convertLocalToUTC ( localInstant , false , instant ) ;
return iZone . convertLocalToUTC ( localInstant , false , instant ) ;
return iBase . getZone () . convertLocalToUTC ( localInstant , false , instant ) ;
{ super ( duration ) ; }
{ super ( duration ) ; }
Object timestamp = StandardBasicTypes.STRING . nullSafeGet ( resultSet , string ) ;
Object date = StandardBasicTypes.DATE . nullSafeGet ( resultSet , string ) ;
Object value = StandardBasicTypes.LONG . nullSafeGet ( resultSet , name ) ;
Object value = StandardBasicTypes.TIMESTAMP . nullSafeGet ( resultSet , name ) ;
Object timestamp = StandardBasicTypes.TIME . nullSafeGet ( resultSet , string ) ;
Object timestamp = StandardBasicTypes.INTEGER . nullSafeGet ( resultSet , string ) ;
Object timestamp = StandardBasicTypes.DATE . nullSafeGet ( resultSet , string ) ;
Object date = StandardBasicTypes.TIME . nullSafeGet ( resultSet , string ) ;
Object timestamp = StandardBasicTypes.TIMESTAMP . nullSafeGet ( resultSet , string ) ;
Object timestamp = StandardBasicTypes.TIMESTAMP . nullSafeGet ( resultSet , string ) ;
String s = ( String ) StandardBasicTypes.STRING . nullSafeGet ( resultSet , strings [ NUMBER_CONSTANT ] ) ;
{ if ( period != null ) { setValues ( addPeriodInto ( getValues () , period ) ) ; } }
{ if ( period != null ) { setValues ( mergePeriodInto ( getValues () , period ) ) ; } }
setValues ( newValues ) ;
array = new Object [] { validValues , Integer . valueOf ( maxLength ) } ;
{ integers [ i ] = Integer . valueOf ( i ) ; }
{ return withPivotYear ( Integer . valueOf ( pivotYear ) ) ; }
array = new Object [] { validValues , Integer . valueOf ( maxLength ) } ;
{ return withPivotYear ( Integer . valueOf ( pivotYear ) ) ; }
DateTimeFormatter printer = ISODateTimeFormat . dateTime () ;
protected void setUp ( ) throws Exception { originalLocale = Locale . getDefault () ; Locale . setDefault ( DE ) ; }
convId = zone . getID () ;
catch ( ArrayIndexOutOfBoundsException ex ) { throw new IOException ( STRING_CONSTANT ) ; }
try { readZoneInfoMap ( din , map ) ; } finally { try { din . close () ; } catch ( IOException ex ) {} }
StringBuilder msg = new StringBuilder () ;
StringBuilder sb = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder () ;
if ( tokenLen >= NUMBER_CONSTANT ) { builder . appendTimeZoneName () ; } else { builder . appendTimeZoneShortName ( null ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . startsWith ( STRING_CONSTANT ) ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . startsWith ( STRING_CONSTANT ) ) ; }
try { localDateTime . toDateTime ( this ) ; return false ; } catch ( IllegalInstantException ex ) { return true ; }
throw new IllegalInstantException ( message ) ;
{ if ( divisor == NUMBER_CONSTANT ) { return this ; } return new Duration ( FieldUtils . safeDivide ( getMillis () , divisor ) ) ; }
{ if ( multiplicand == NUMBER_CONSTANT ) { return this ; } return new Duration ( FieldUtils . safeMultiply ( getMillis () , multiplicand ) ) ; }
Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ;
{ printTo ( appendable , instant , null ) ; }
f2 = new DateTimeFormatter ( ( InternalPrinter ) null , f . getParser () ) ;
InternalPrinter [] elements = iPrinters ;
InternalPrinter [] elements = iPrinters ;
{ printTo ( appendable , instant , chrono ) ; }
f instanceof InternalPrinter
InternalPrinter printer
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , parser ) ; }
{ checkPrinter ( printer ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , null ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter0 () , formatter . getParser () ) ; }
{ InternalPrinter p = getFormatter ( locale ) . getPrinter0 () ; p . printTo ( appendable , partial , locale ) ; }
InternalPrinter p = getFormatter ( locale ) . getPrinter0 () ;
return ( ( StyleFormatter ) formatter . getPrinter0 () ) . getPattern ( locale ) ;
InternalPrinter printer = requirePrinter () ;
InternalPrinter printer = requirePrinter () ;
{ printTo ( ( Appendable ) out , instant ) ; }
InternalPrinter printer
catch ( IllegalArgumentException ex ) { assertMessageContains ( ex , STRING_CONSTANT ) ; }
{ return computeMillis ( resetFields , ( CharSequence ) null ) ; }
{ return computeMillis ( false , ( CharSequence ) null ) ; }
{ obtainSaveField () . init ( fieldType . getField ( iChrono ) , value ) ; }
{ obtainSaveField () . init ( field , value ) ; }
CharSequence text
f2 = new DateTimeFormatter ( ( DateTimePrinter ) null , f . getParser () ) ;
{ reset () ; return doParseMillis ( DateTimeParserInternalParser . of ( parser ) , text ) ; }
CharSequence text
CharSequence text
CharSequence text
f instanceof InternalParser
InternalParser parser
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , DateTimeParserInternalParser . of ( parser ) ) ; }
{ checkParser ( parser ) ; return append0 ( null , DateTimeParserInternalParser . of ( parser ) ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter0 () , formatter . getParser0 () ) ; }
InternalParser parser = requireParser () ;
InternalParser parser = requireParser () ;
InternalParser parser = requireParser () ;
InternalParser parser = requireParser () ;
InternalParser parser = requireParser () ;
public DateTimeParser getParser () { return InternalParserDateTimeParser . of ( iParser ) ; }
InternalParser parser
InternalParser parser
{ this ( DateTimePrinterInternalPrinter . of ( printer ) , DateTimeParserInternalParser . of ( parser ) ) ; }
iMillis = FieldUtils . safeSubtract ( endMillis , startMillis ) ;
{ super(); iMillis = FieldUtils . safeSubtract ( endInstant , startInstant ) ; }
try { builder . appendSuffix ( NULL_STRING , null ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { builder . appendPrefix ( NULL_STRING , null ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
iSuffixes = texts . clone () ;
builder . appendDays () . appendSuffix ( STRING_CONSTANT ) . appendSuffix ( STRING_CONSTANT , STRING_CONSTANT )
builder . appendPrefix ( STRING_CONSTANT ) . appendPrefix ( STRING_CONSTANT , STRING_CONSTANT )
if ( periodStr . regionMatches ( false , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
if ( periodStr . regionMatches ( true , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
synchronized ( cDefaultLock ) { cDefault = zone ; }
{ return iZoneInfoKeys ; }
public Set < String > getAvailableIDs () { return AVAILABLE_IDS ; }
public static Set < String > getAvailableIDs () { return getProvider () . getAvailableIDs () ; }
DateTimeZone zone = getProvider () . getZone ( id ) ;
assertEquals ( zone , result ) ;
int curMonth0 = values [ NUMBER_CONSTANT ] - NUMBER_CONSTANT ;
if ( ZoneInfoLogger . verbose () ) { System.out . println ( STRING_CONSTANT + tz . getID () ) ; }
ZoneInfoLogger . set ( verbose ) ;
Interval interval = new Interval ( start , end , getChronology () ) ;
int compare = csCompare ( text , position , value ) ;
{ return FieldUtils . safeSubtract ( getEndMillis () , getStartMillis () ) ; }
{ millis = iField . setExtended ( millis , iValue ) ; }
str = str . toLowerCase ( Locale.ENGLISH ) ;
assertEquals ( STRING_CONSTANT , str . toUpperCase ( Locale.ENGLISH ) ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.ENGLISH ) ;
DateTimeFormatter fmt = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.ENGLISH ) ;
{ Provider provider = new ZoneInfoProvider ( DEFAULT_TZ_DATA_PATH ) ; return validateProvider ( provider ) ; }
try { retDT = new DateTime ( s ) ; } catch ( IllegalArgumentException pe ) {}
IllegalArgumentException e
final Object f
final Object f
final Object f
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final DateTimeField field
final DateTimeField field
final char c
final Object element
final DateTimeParser parser
final DateTimeParser parser
final DateTimePrinter printer
final DateTimeFormatter formatter
final Chronology chrono
final DateTimeZone zone
int digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
int digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
Chronology chrono = new LenientChronology ( ISOChronology . getInstanceUTC () ) ;
public int getMinimumValue ( long instant ) { return NUMBER_CONSTANT ; }
long value
final long millis
GJWeekyearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getRoughMillisPerYear () ) ; iChronology = chronology ; }
DateTime instant
public int get ( long instant ) { return BuddhistChronology.BE ; }
public String getNameKey ( long instant ) { return iNameKey ; }
{ return add ( millis , ( long ) value - get ( millis ) ) ; }
public long add ( long millis , long value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
IllegalArgumentException pe
{ return add ( millis , ( long ) value - get ( millis ) ) ; }
public long add ( long millis , long value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
public long add ( long millis , long value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
return ( getMillis ( readableInstant ) < readableInstant . getMillis ( this ) ) ;
{ Chronology chrono = getChronology () ; return ( chrono != null ? chrono . getDateTimeZone () : null ) ; }
protected AbstractInstant () { super(); }
catch ( IllegalArgumentException pe ) { pe . printStackTrace () ; }
try { retDT = new DateTime ( s , DateTimeZone.UTC ) ; } catch ( IllegalArgumentException pe ) { pe . printStackTrace () ; }
if ( zone == null ) { zone = DateTimeZone . getDefault () ; }
long value
if ( zone == null ) { zone = DateTimeZone . getDefault () ; }
GJMonthOfYearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getRoughMillisPerMonth () ) ; iChronology = chronology ; }
long value
public abstract boolean equals ( Object object ) ;
public String print ( final long instant ) { throw unsupported () ; }
public String print ( final ReadableInstant instant ) { throw unsupported () ; }
public String print ( final ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
final char c
final char style
final char style
