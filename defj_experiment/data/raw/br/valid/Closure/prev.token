rhs . getType ()
n . getType ()
parent . getType ()
rootNameNode . getType ()
parent . getType ()
Node newVar = IR . declaration ( child , n . getType () ) . srcref ( n ) ;
n . getType ()
n . getType ()
notChild . getType ()
n . getType ()
node . getType ()
{ switch ( n . getType () ) { case CALL : annotateCalls ( n ) ; break; default: break; } }
assertThat ( enumTypeNode . getType () ) . isEqualTo ( Token.BANG ) ;
n . getType ()
{ switch ( n . getType () ) { case CALL : visitCall ( t , n ) ; break; default: break; } }
if ( typeExprNode . getType () == Token.QMARK && ! typeExprNode . hasChildren () ) { return true ; }
n . getType ()
n . getType ()
n . getType ()
n . getType ()
assertEquals ( Token.VAR , var . getType () ) ;
n . getType () == type
n . getType ()
n . getType ()
n . getType ()
n . getParent () . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
definitionParent . getType ()
throw new RuntimeException ( STRING_CONSTANT + defSite . getType () ) ;
n . getType ()
n . getType ()
Preconditions . checkState ( nameNode . isGetProp () , STRING_CONSTANT , nameNode . getType () ) ;
n . getType ()
Token exprKind = expr . getType () ;
expr . getType ()
insideQualifiedName || propAccessNode . getParent () . getType () != Token.ASSIGN
expr . getType ()
lvalue . getType ()
Token tokenType = expr . getType () ;
{ warnInvalidOperand ( expr , expr . getType () , STRING_CONSTANT , lhsType + STRING_CONSTANT + rhsType ) ; }
if ( ! commonTypes . isNumberScalarOrObj ( pair.type ) ) { warnInvalidOperand ( child , expr . getType () , JSType.NUMBER , pair.type ) ; }
Token exprKind = expr . getType () ;
{ warnings . add ( JSError . make ( expr , UNKNOWN_EXPR_TYPE , expr . getType () . toString () ) ) ; }
dn . getValue () . getType ()
assertThat ( cont . getType () ) . isSameAs ( Token.CONTINUE ) ;
assertThat ( breakStm . getType () ) . isSameAs ( Token.BREAK ) ;
value . getType ()
! registerFunc . isValidNodeType ( valueNode . getType () )
! registerFunc . isValidNodeType ( value . getType () )
n . getType ()
changed = changed || finalValue . getType () != info.initialValue . getType () || ! finalValue . isEquivalentTo ( info.initialValue ) ;
{ if ( blockNode . getChildCount () == NUMBER_CONSTANT && blockNode . getFirstChild () . getType () == Token.THROW ) { return true ; } return false ; }
n . getType ()
arg . getType () != desiredType
val . getType ()
n . getType ()
lhs . getType ()
Token parentType = parent . getType () ;
{ switch ( n . getType () ) { case HOOK : case AND : case OR : return true ; default: return false ; } }
expr . getType ()
n . getType ()
Token type = ancestor . getType () ;
node . getType ()
node . getType ()
n . getType ()
n . getType ()
n . getType ()
Token actualType = cfgNodes . get ( i ) . getValue () . getType () ;
if ( source . getType () == startToken ) { assertFalse ( STRING_CONSTANT + startToken + STRING_CONSTANT + STRING_CONSTANT , cfg . isImplicitReturn ( dest ) ) ; return; }
if ( source . getType () == startToken && cfg . isImplicitReturn ( dest ) ) { return; }
return enclosingNode != null && enclosingNode . getType () != Token.FUNCTION ;
n . getType ()
n . getType ()
expr . getRoot () . getType ()
n . getType ()
refParent . getType ()
anc . getType ()
parent . getType ()
n . getType ()
grandparent . getType ()
n . getType ()
n . getType ()
{ switch ( n . getType () ) { case AND : case OR : case HOOK : return true ; default: return false ; } }
assertEquals ( Token.STRING , n . getType () ) ;
{ assertEquals ( Token.STRING , n . getType () ) ; visited . append ( n . getString () ) ; }
n . getType ()
input . getType ()
parent . getType ()
n . getType ()
n . getType ()
n . getType ()
Token type = n . getType () ;
next . getType ()
value . getType ()
n . getType ()
return parent != null && parent . getType () == Token.EXPONENT && parent . getFirstChild () == n ;
{ return NodeUtil . precedence ( n . getType () ) < minPrecedence ; }
{ switch ( n . getType () ) { case LET : case CONST : case FUNCTION : case CLASS : case DO : return true ; default: return false ; } }
while ( firstNonOperator . getType () == op ) { firstNonOperator = firstNonOperator . getFirstChild () ; }
n . getType ()
n . getType ()
c . getType ()
last . getType ()
n . getType ()
n . getType ()
switch ( n . getType () ) { case FUNCTION : if ( n . isArrowFunction () ) { visitArrowFunction ( t , n ) ; } break; default: break; }
value . getType ()
{ Token type = n . getType () ; return ( type == Token.INC || type == Token.DEC ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT + node . getType () ) ; }
Token declarationType = declarationNode . getType () ;
{ newNode = IR . declaration ( newLHS , newRHS , parent . getType () ) ; }
{ newNode = IR . declaration ( newLHS , newRHS , parent . getType () ) ; }
n . getType ()
n . getType ()
int parentPrecedence = NodeUtil . precedence ( n . getType () ) ;
node . getType ()
n . getType ()
if ( isSimpleOp ) { msg = STRING_CONSTANT + n . getType () . toString () . toLowerCase () + STRING_CONSTANT ; }
assertEquals ( Token.SCRIPT , global . getDeclaration () . getNode () . getType () ) ;
assertEquals ( Token.GETPROP , refs . get ( NUMBER_CONSTANT ) . getNode () . getType () ) ;
assertEquals ( Token.GETPROP , refs . get ( NUMBER_CONSTANT ) . getNode () . getType () ) ;
assertEquals ( Token.NAME , refs . get ( NUMBER_CONSTANT ) . getNode () . getType () ) ;
if ( ! propName . isString () ) { throw new IllegalStateException ( STRING_CONSTANT + propName . getType () ) ; }
if ( ! propName . isString () ) { throw new IllegalStateException ( STRING_CONSTANT + propName . getType () ) ; }
Token parentType = parent . getType () ;
parent . getType ()
n . getType ()
Token type = n . getType () ;
parent . getType ()
Token nodeType = input . getType () ;
Token type = current . getType () ;
type != null && type . getType () != Token.ARRAY_TYPE
if ( invalidInitializers . contains ( initializer . getType () ) ) { errorReporter . error ( STRING_CONSTANT , sourceName , lineno ( loopNode.initializer ) , charno ( loopNode.initializer ) ) ; }
if ( invalidInitializers . contains ( initializer . getType () ) ) { errorReporter . error ( STRING_CONSTANT , sourceName , lineno ( loopNode.initializer ) , charno ( loopNode.initializer ) ) ; }
Token nType = n . getType () ;
{ switch ( n . getType () ) { case FOR : case FOR_OF : case WHILE : case DO : return true ; default: return false ; } }
{ switch ( n . getType () ) { case FOR : case FOR_OF : case WHILE : case DO : case SWITCH : return true ; default: return false ; } }
n . getType ()
n . getType ()
switch ( n . getType () ) { case GETPROP : return n . getLastChild () . getString () ; case MEMBER_FUNCTION_DEF : return n . getString () ; default: break; }
expr . getType ()
expr . getType ()
n . getType ()
getType ()
getType ()
getType ()
getType ()
Preconditions . checkArgument ( source == null || Token.FUNCTION == source . getType () ) ;
Preconditions . checkArgument ( source == null || Token.FUNCTION == source . getType () ) ;
int expectedArity = Token . arity ( n . getType () ) ;
switch ( n . getType () ) { case NAME : validateName ( n ) ; break; case GETPROP : validateGetProp ( n ) ; break; default: break; }
catch ( UnsupportedOperationException e ) { violation ( STRING_CONSTANT + n . getType () , n ) ; }
{ validateChildCount ( n , NUMBER_CONSTANT ) ; validateNameDeclarationHelper ( n . getType () , n ) ; }
{ if ( NodeUtil . isNameDeclaration ( n ) ) { validateNameDeclarationHelper ( n . getType () , n ) ; } else { validateOptionalExpression ( n ) ; } }
if ( body . getType () == Token.BLOCK ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
n . getFirstChild () . getType () == Token.EXPORT_SPECS
secondChild . getType ()
n . getType ()
control . getType ()
n . getType ()
switch ( n . getParent () . getType () ) { case VAR : case CATCH : names . add ( n . getString () ) ; break; default: break; }
Token type = n . getType () ;
switch ( c . getType () ) { case FUNCTION : case AND : case OR : case HOOK : return true ; default: break; }
cArg . getType ()
Token type = parent . getType () ;
{ @ Override public boolean apply ( Node n ) { return type == n . getType () ; } }
n . getType ()
FlowScope rightScope = reverseInterpreter . getPreciserScopeKnowingConditionOutcome ( left , leftOutcome . getOutcomeFlowScope ( left . getType () , nIsAnd ) , nIsAnd ) ;
left . getType ()
n . getType ()
newScope = reverseInterpreter . getPreciserScopeKnowingConditionOutcome ( condition , conditionOutcomes . getOutcomeFlowScope ( condition . getType () , branch == Branch.ON_TRUE ) , branch == Branch.ON_TRUE ) ;
n . getType ()
n . getType ()
n . getType ()
namedImports . getType () == Token.IMPORT_SPECS
n . getType ()
n . getType ()
{ assertEquals ( Token.FUNCTION , function . getType () ) ; assertEquals ( name , NodeUtil . getName ( function ) ) ; }
n . getParent () . getType ()
arg . getType ()
isASTNormalized () && Token.NAME == constructorNameNode . getType ()
result . getType ()
node . getType ()
Token parentType = parent . getType () ;
n . getType ()
export . getFirstChild () . getType () == Token.EXPORT_SPECS
Token type = nextNode . getType () ;
n . getType ()
{ if ( typeNode . getType () == Token.BANG ) { typeNode = typeNode . getFirstChild () ; } return typeNode ; }
n . getType ()
n . getType ()
Node decl = IR . declaration ( cls.name . cloneTree () , cls.constructor.value , exprRoot . getType () ) . srcref ( exprRoot ) ;
parent . getType ()
if ( fieldTypeNode . getType () == Token.COLON ) { fieldNameNode = fieldTypeNode . getFirstChild () ; hasType = true ; }
Token pType = parent . getType () ;
assertEquals ( Token.NEW , callsiteNode . getType () ) ;
assertEquals ( Token.CALL , callsiteNode . getType () ) ;
assertEquals ( Token.CALL , callsiteNode . getType () ) ;
Token type = n . getType () ;
parent . getType () == Token.PARAM_LIST
aliasReference . getType () == Token.STRING_KEY
n . getType ()
{ if ( n . getType () == Token.INSTANCEOF ) { reportIfNonObject ( t , n . getFirstChild () , SUSPICIOUS_INSTANCEOF_LEFT_OPERAND ) ; } }
{ if ( n . getType () == Token.IN ) { reportIfNonObject ( t , n . getLastChild () , SUSPICIOUS_IN_OPERATOR ) ; } }
n . getType ()
n . getType ()
n . getType ()
Token operatorToken = condition . getType () ;
builder . append ( n . getType () . toString () ) ;
decl.node . getParent () . getType ()
Preconditions . checkArgument ( n . isGetProp () , STRING_CONSTANT , n . getType () , n ) ;
Token nType = n . getType () ;
val . getType () == Token.OR
n . getType ()
n . getType ()
if ( typeNode . getType () != Token.EQUALS ) { report ( typeNode , DEFAULT_PARAM_MUST_BE_MARKED_OPTIONAL ) ; }
n . getType ()
n . getType ()
n . getType ()
typeNode != null && typeNode . getType () == Token.STRING
c . getType ()
left . getType ()
TernaryValue result = evaluateComparison ( n . getType () , left , right , shouldUseTypes ) ;
Node result = performArithmeticOp ( n . getType () , left , right ) ;
Token type = n . getType () ;
n . getType ()
argumentNode . getType ()
n . getType ()
n . getType ()
subtree . getType ()
subtree . getType ()
while ( moveIt . hasNext () ) { actualTokens . add ( moveIt . next () . getType () ) ; }
node . getType () == Token.CALL
Token parentType = useParent . getType () ;
Token nodeType = n . getType () ;
Token parentNodeType = parent . getType () ;
key . getType ()
n . getType ()
Token type = parent . getType () ;
n . getType ()
{ Preconditions . checkState ( sourceName != null ) ; Preconditions . checkState ( n . getType () == type , n ) ; }
n . getType ()
n . getType ()
node . getType ()
assertEquals ( Token.FUNCTION , fooNode . getType () ) ;
n . getType ()
Token type = n . getType () ;
{ switch ( n . getFirstChild () . getType () ) { case HOOK : case AND : case OR : return true ; default: break; } }
{ switch ( n . getType () ) { case BREAK : case CONTINUE : case RETURN : case THROW : return true ; default: return false ; } }
blockChild . getType ()
n . getType ()
subtree . getType ()
parent . getType ()
ancestor . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
if ( node . getType () == type ) { matchingNodes . add ( node ) ; }
n . getType ()
declType = variable . getType () ;
n . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getParent () . getType ()
Preconditions . checkArgument ( node . isNew () , STRING_CONSTANT , node . getType () ) ;
Preconditions . checkArgument ( node . isCall () , STRING_CONSTANT , node . getType () ) ;
Preconditions . checkArgument ( node . isHook () , STRING_CONSTANT , node . getType () ) ;
Preconditions . checkArgument ( ( node . isAnd () ) || ( node . isOr () ) , STRING_CONSTANT , node . getType () ) ;
Preconditions . checkArgument ( hook . isHook () , STRING_CONSTANT , hook . getType () ) ;
Preconditions . checkArgument ( ( original . isAnd () ) || ( original . isOr () ) , STRING_CONSTANT , original . getType () ) ;
parent . getType ()
n . getType ()
n . getType ()
n . getType ()
node . getType ()
Token secondArgumentType = secondArgument . getType () ;
n . getType ()
int offset = getSourceInfoOffset ( provideStringNode ) ;
{ return ! type . isNoResolvedType () ; }
return isKnown ( n ) && ! isAllType ( n ) && isClassType ( n ) && ! isNativeObjectType ( n ) && ! isWhitelistedType ( n ) ;
! isTemplateType ( n )
! isTemplateType ( n )
if ( type == null || type . isUnknownType () || type . isAllType () ) { return new MatchResult ( allowLooseMatches , allowLooseMatches ) ; }
options . setPreserveGoogRequires ( true ) ;
compilerOptions . setPreserveGoogRequires ( true ) ;
importNode . copyInformationFrom ( export ) ;
n . detachFromParent () ;
Node stringKey = IR . stringKey ( name , memberDef . getFirstChild () . detachFromParent () ) ;
if ( parent . isExprResult () ) { parent . detachFromParent () ; } else { parent . replaceChild ( n , elemValue ) ; }
{ parent . getParent () . detachFromParent () ; compiler . reportCodeChange () ; }
{ if ( n . getParent () != null ) { n . detachFromParent () ; compiler . reportCodeChange () ; } }
Node body = IR . block ( IR . returnNode ( returnValue . detachFromParent () ) ) ;
parent . replaceChild ( export , declaration . detachFromParent () ) ;
newBlock . detachFromParent () ;
typeString . detachFromParent () ;
if ( rep . isExprResult () ) { rep = rep . getFirstChild () ; rep . detachFromParent () ; }
{ changeProxy . replaceWith ( grandparent , parent , parent . getLastChild () . detachFromParent () ) ; }
Node replacement = firstArg . detachFromParent () ;
{ rhs . detachFromParent () ; ancestor . replaceChild ( last , rhs ) ; }
rhs . detachFromParent () ;
Node child = n . getLastChild () . detachFromParent () ;
argNode . detachFromParent () ;
assignmentValue . detachFromParent () ;
Node simplified = new Node ( type , condition . detachFromParent () , simplifyShortCircuitBranch ( body ) ) . useSourceInfoIfMissingFrom ( hook ) ;
{ if ( original . getParent () != null ) { original . detachFromParent () ; } replacements . add ( original ) ; }
Node newGetProp = IR . getprop ( target . detachFromParent () , prop . detachFromParent () ) ;
if ( i == NUMBER_CONSTANT && first . getString () . isEmpty () ) { add = add . getSecondChild () . detachFromParent () ; }
for ( PrototypeMemberDeclaration declar : instance.declarations ) { block . addChildToBack ( declar.node . detachFromParent () ) ; }
{ if ( preserveGoogProvidesAndRequires && explicitNode . hasChildren () ) { return; } explicitNode . detachFromParent () ; compiler . reportCodeChange () ; }
if ( typeDeclaration != null ) { compiler . forwardDeclareType ( typeDeclaration ) ; parent . detachFromParent () ; compiler . reportCodeChange () ; }
Node value = n . getChildAtIndex ( NUMBER_CONSTANT ) . detachFromParent () ;
for ( Node closureRequire : requiresToBeRemoved ) { closureRequire . detachFromParent () ; compiler . reportCodeChange () ; }
arg . detachFromParent () ;
Node method = member . getLastChild () . detachFromParent () ;
stringKey = IR . stringKey ( ( member . isGetterDef () || member . getBooleanProp ( Node.COMPUTED_PROP_GETTER ) ) ? STRING_CONSTANT : STRING_CONSTANT , function . detachFromParent () )
constructor = member . getFirstChild () . detachFromParent () ;
for ( Node child : functionBody . children () ) { newBlock . addChildToBack ( child . detachFromParent () ) ; }
Node stringKey = IR . stringKey ( name , n . getFirstChild () . detachFromParent () ) ;
if ( subtree . getChildCount () == NUMBER_CONSTANT ) { subtree . getLastChild () . detachFromParent () ; }
{ for ( Node c : externs . children () ) { if ( ! c . hasChildren () ) { c . detachFromParent () ; } } }
if ( expected != null ) { expectedRoot = parseExpectedJs ( expected ) ; expectedRoot . detachFromParent () ; }
{ Node ancParent = ancestor . getParent () ; ancParent . replaceChild ( ancestor , ancestor . getLastChild () . detachFromParent () ) ; break; }
node . detachFromParent () ;
{ if ( node != null && node . getParent () != null ) { node . detachFromParent () ; } return node ; }
{ compiler . report ( JSError . make ( requireNode , MISSING_MODULE_OR_PROVIDE.level , MISSING_MODULE_OR_PROVIDE , legacyNamespace ) ) ; NodeUtil . getEnclosingStatement ( requireNode ) . detachFromParent () ; continue; }
moduleBlockNode . detachFromParent () ;
returnStatementNode . detachFromParent () ;
{ NodeUtil . getEnclosingStatement ( call ) . detachFromParent () ; }
private void updateGoogDeclareLegacyNamespace ( Node call ) { NodeUtil . getEnclosingStatement ( call ) . detachFromParent () ; }
if ( ! currentScript.declareLegacyNamespace ) { NodeUtil . getEnclosingStatement ( call ) . detachFromParent () ; }
if ( secondExpr != firstExpr ) { secondExpr . detachFromParent () ; } else { secondExpr = IR . nullNode () ; }
bind.target . detachFromParent () ;
declParent . detachFromParent () ;
{ if ( value != null ) { value . detachFromParent () ; } varNode = parent ; }
callbackFunction . detachFromParent () ;
{ objlit . removeChild ( key ) ; value . detachFromParent () ; }
Node replacement = value . detachFromParent () ;
Node destObj = n . getSecondChild () . detachFromParent () ;
Node newNode = new Node ( newType , left . detachFromParent () , newRight . detachFromParent () ) ;
if ( NodeUtil . isNumericResult ( left ) ) { parent . replaceChild ( n , left . detachFromParent () ) ; reportCodeChange () ; return left ; }
if ( root != null ) { root . detachFromParent () ; }
callNode . getParent () . replaceChild ( callNode , replacementNode . detachFromParent () ) ;
clinitAssignedValue . detachFromParent () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detachFromParent () ; reportCodeChange () ; return null ; }
{ block . replaceChild ( maybeIf , maybeIf . getLastChild () . detachFromParent () ) ; }
colon . addChildToBack ( member . detachFromParent () ) ;
n . detachFromParent () ;
for ( Node child : stringKeys ) { child . detachFromParent () ; }
member . detachFromParent () ;
indexSignature . detachFromParent () ;
comma . addChildToBack ( leftMostChild . detachFromParent () ) ;
Node condStatement = IR . exprResult ( cond . detachFromParent () ) . srcref ( cond ) ;
Node statement = IR . exprResult ( cond . detachFromParent () ) . useSourceInfoIfMissingFrom ( cond ) ;
n . getParent () . replaceChild ( n , caseBlock . detachFromParent () ) ;
{ maybeBreak . detachFromParent () ; reportCodeChange () ; }
{ subtree . detachFromParent () ; subtree = null ; }
{ subtree . getParent () . replaceChild ( subtree , right . detachFromParent () ) ; reportCodeChange () ; return right ; }
{ n . detachFromParent () ; }
var . detachFromParent () ;
Node newDeclaration = IR . var ( name . detachFromParent () ) . useSourceInfoFrom ( declarationList ) ;
inlineValue ( v , ref , value . detachFromParent () ) ;
Node opDetached = op . detachFromParent () ;
potentialCallee . detachFromParent () ;
{ expectedRoot = parseExpectedJs ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , expected ) ) ) ; expectedRoot . detachFromParent () ; }
if ( ! t . inGlobalScope () && NodeUtil . isHoistedFunctionDeclaration ( value ) ) { parent . addChildToFront ( value . detachFromParent () ) ; }
body . detachFromParent () ;
Node decl = IR . declaration ( pattern . detachFromParent () , IR . name ( tempVarName ) , declarationType ) ;
List < Node > assignments = new ArrayList < Node > () ;
List < Node > nodes = new ArrayList < Node > () ;
public JSType getJSTypeBeforeCast () { return ( JSType ) getProp ( TYPE_BEFORE_CAST ) ; }
String externs = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
@ Override public TypeI evaluateTypeExpressionInGlobalScope ( JSTypeExpression expr ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
@ Override public boolean isInstanceType () { Preconditions . checkState ( this . isSingletonObj () ) ; return this . getNominalTypeIfSingletonObj () . isClass () ; }
@ Override public boolean isUnknownType () { return isUnknown () ; }
return fn . isLooseSubtypeOf ( other.fn , subSuperMap ) ;
UpdateThisAndArgumentsReferences updater = new UpdateThisAndArgumentsReferences () ;
{ this . passUnderTest = new NameBasedDefinitionProvider ( compiler ) ; this . compiler = compiler ; }
NameBasedDefinitionProvider defFinder = new NameBasedDefinitionProvider ( compiler ) ;
public void testHookOperators4 ( ) throws Exception { checkMarkedCalls ( STRING_CONSTANT + STRING_CONSTANT , ImmutableList . < String > of () ) ; }
public DefinitionUseSiteFinder ( AbstractCompiler compiler ) { super ( compiler ) ; this . nameUseSiteMultimap = LinkedHashMultimap . create () ; }
defFinder = new NameBasedDefinitionProvider ( compiler ) ;
NameBasedDefinitionProvider defFinder = new NameBasedDefinitionProvider ( compiler ) ;
NameBasedDefinitionProvider defFinder = new NameBasedDefinitionProvider ( compiler ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.INEXISTENT_PROPERTY ) ;
typeCheck ( STRING_CONSTANT , NewTypeInference.PROPERTY_ACCESS_ON_NONOBJECT ) ;
if ( testMode ) { return new StringWriter () ; }
if ( testMode ) { return new StringWriter () ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ process ( null , scriptRoot ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
phaseopt . process ( externsNode , n ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
passes . add ( checkVariableReferences ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
if ( J2clSourceFileChecker . shouldSkipExecution ( compiler ) ) { return; }
if ( J2clSourceFileChecker . shouldSkipExecution ( compiler ) ) { return; }
{ if ( J2clSourceFileChecker . shouldSkipExecution ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
if ( J2clSourceFileChecker . shouldSkipExecution ( compiler ) ) { return; }
{ testSame ( Lists . newArrayList ( NO_J2CL_SOURCE_FILE , NO_J2CL_SOURCE_FILE2 ) ) ; assertThat ( compiler . getAnnotation ( J2clSourceFileChecker.HAS_J2CL_ANNOTATION_KEY ) ) . isEqualTo ( Boolean.FALSE ) ; }
{ testSame ( Lists . newArrayList ( NO_J2CL_SOURCE_FILE , J2CL_SOURCE_FILE , NO_J2CL_SOURCE_FILE2 ) ) ; assertThat ( compiler . getAnnotation ( J2clSourceFileChecker.HAS_J2CL_ANNOTATION_KEY ) ) . isEqualTo ( Boolean.TRUE ) ; }
{ if ( J2clSourceFileChecker . shouldSkipExecution ( compiler ) ) { return; } new StaticFieldGetterSetterInliner ( root ) . run () ; }
{ recvType = recvType . withProperty ( pname , JSType.TOP_OBJECT . withLoose () ) ; inEnv = updateLvalueTypeInEnv ( inEnv , obj , recvLvalue.ptr , recvType ) ; }
String js = STRING_CONSTANT ;
testSame ( code + STRING_CONSTANT ) ;
RefactoringDriver driver = new RefactoringDriver.Builder ( scanner ) . addExternsFromCode ( externs ) . addInputsFromCode ( originalCode ) . build () ;
ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , externs ) )
n . getTypeI () . isSomeUnknownType ()
{ tracker = new PerformanceTracker ( jsRoot , options.tracer , this . outStream ) ; addChangeHandler ( tracker . getCodeChangeHandler () ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
phaseopt . process ( externsNode , externAndJsRoot ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
passes . add ( checkVariableReferencesForTranspileOnly ) ;
public static ResourceBundle getBundle ( String baseName , Locale locale ) { return new ResourceBundle () ; }
{ Preconditions . checkState ( ! this . isFinalized ) ; super . addUndeclaredProperty ( pname , defSite , JSType.UNKNOWN , false ) ; }
if ( type == null && isConstant ) { type = JSType.UNKNOWN ; }
this . randomProps . with ( pname , Property . make ( type == null ? JSType.UNKNOWN : type , type ) )
if ( ! t . isUnknown () && ! t . equals ( JSType . fromTypeVar ( typeVar ) ) ) { return false ; }
if ( typeMap . isEmpty () ) { return Property . make ( JSType.UNKNOWN , null ) ; }
{ NominalType thisWithoutTypemap = this . rawType . getAsNominalType () ; return thisWithoutTypemap . instantiateGenerics ( JSType.MAP_TO_UNKNOWN ) ; }
JSType result = JSType.TOP ;
JSType result = JSType.BOTTOM ;
if ( ! isGeneric () || JSType.MAP_TO_UNKNOWN . equals ( concreteTypes ) ) { return substituteNominalGenerics ( concreteTypes ) ; }
FunctionTypeBuilder builder = new FunctionTypeBuilder () ;
{ if ( ! f . isGeneric () ) { return f ; } return f . instantiateGenerics ( JSType.MAP_TO_UNKNOWN ) ; }
if ( ! FunctionType.allowMethodsAsFunctions && this . receiverType != null && other.receiverType == null ) { return false ; }
FunctionTypeBuilder builder = new FunctionTypeBuilder () ;
optionalFormals . add ( JSType . join ( t , JSType.UNDEFINED ) ) ;
this == other || other.ns != null || ! other . getNominalType () . equals ( builtinObject )
if ( other == TOP_OBJECT ) { return true ; }
if ( other == TOP_OBJECT ) { return true ; }
if ( newPropType . isBottom () ) { return BOTTOM_MAP ; }
JSType result = JSType.BOTTOM ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) { return JSType.STRING ; }
recvType = recvType . removeType ( JSType.NULL ) ;
if ( propInferredFunType != null ) { rawType . addUndeclaredClassProperty ( pname , propInferredFunType , getProp ) ; } else { rawType . addUndeclaredClassProperty ( pname , JSType.UNKNOWN , getProp ) ; }
if ( t == null ) { t = JSType.UNKNOWN ; }
FunctionType getInstanceFunType = ( new FunctionTypeBuilder () ) . addRetType ( instanceType ) . buildFunction () ;
if ( t == null ) { t = JSType.UNKNOWN ; }
{ this . currentScope . addLocal ( varName , JSType.UNKNOWN , false , false ) ; }
JSType resultType = JSType.TOP ;
for ( String typedefName : localTypedefs . keySet () ) { locals . put ( typedefName , JSType.UNDEFINED ) ; }
{ isTypeVar = true ; type = JSType . fromTypeVar ( declaredType . getTypeVariableDefinedLocally ( name ) ) ; }
{ addNamespace ( qnameNode , new NamespaceLit ( getCommonTypes () , qnameNode . getQualifiedName () , qnameNode ) ) ; }
{ this . root . setTypeI ( getCommonTypes () . fromFunctionType ( declaredType . toFunctionType () ) ) ; }
{ if ( anyNumOrStr == null ) { return t . isSubtypeOf ( JSType.NUM_OR_STR ) ; } return t . isSubtypeOf ( anyNumOrStr ) ; }
{ if ( numberOrNumber == null ) { return t . isSubtypeOf ( JSType.STRING ) ; } return t . isSubtypeOf ( stringOrString ) ; }
{ if ( numberOrNumber == null ) { return t . isSubtypeOf ( JSType.NUMBER ) ; } return t . isSubtypeOf ( numberOrNumber ) ; }
stringOrString = JSType . join ( JSType.STRING , stringInstance ) ;
numberOrNumber = JSType . join ( JSType.NUMBER , numberInstance ) ;
ObjectType getStringInstanceObjType () { return stringInstanceObjtype != null ? stringInstanceObjtype : ObjectType.TOP_OBJECT ; }
ObjectType getBooleanInstanceObjType () { return booleanInstanceObjtype != null ? booleanInstanceObjtype : ObjectType.TOP_OBJECT ; }
ObjectType getNumberInstanceObjType () { return numberInstanceObjtype != null ? numberInstanceObjtype : ObjectType.TOP_OBJECT ; }
public JSType getStringInstance () { return stringInstance != null ? stringInstance : JSType.STRING ; }
public JSType getBooleanInstance () { return booleanInstance != null ? booleanInstance : JSType.BOOLEAN ; }
public JSType getNumberInstance () { return numberInstance != null ? numberInstance : JSType.NUMBER ; }
public JSType getRegexpType () { return regexpInstance != null ? regexpInstance : JSType.UNKNOWN ; }
if ( this . arguments == null ) { return JSType.UNKNOWN ; }
if ( arrayType == null ) { return JSType.UNKNOWN ; }
return commonTypes . fromFunctionType ( ctorType ) ;
ObjectType arrayType = commonTypes . getArrayInstance () . getObjTypeIfSingletonObj () ;
if ( isTrueOrTruthy () ) { return FALSY ; } else if ( isFalseOrFalsy () ) { return TRUTHY ; }
return makeType ( newtype ) ;
{ JSType maybeScalar = ObjectType . mayTurnLooseObjectToScalar ( t , JSType.commonTypes ) ; if ( t != maybeScalar ) { return maybeScalar ; } }
JSType result = BOTTOM ;
JSType result = TOP ;
boolean noCycles = constructorType . addInterfaces ( extendedInterfaces . isEmpty () ? ImmutableSet . of ( registry . getCommonTypes () . getObjectType () ) : extendedInterfaces ) ;
NominalType builtinObject = registry . getCommonTypes () . getObjectType () ;
{ builder . addRetType ( JSType.UNDEFINED ) ; }
builder . addRestFormals ( t != null ? t : JSType.UNKNOWN ) ;
return t . isSingletonObjWithNull () ? t . removeType ( JSType.NULL ) : t ;
tdType = JSType.UNKNOWN ;
try { return getTypeFromCommentHelper ( n , registry , typeParameters ) ; } catch ( UnknownTypeException e ) { return JSType.UNKNOWN ; }
lvalue.type = lvalue.type . mayHaveProp ( pname ) ? lvalue.type . getProp ( pname ) : JSType.UNKNOWN ;
if ( doSlicing ) { pair.env = envPutType ( pair.env , name , declType != null ? declType : JSType.UNKNOWN ) ; }
! lvalueType . isSubtypeOf ( JSType.TOP_OBJECT )
if ( requiredType . mayHaveProp ( pname ) ) { reqPtype = requiredType . getProp ( pname ) ; } else { reqPtype = JSType.UNKNOWN ; }
return new EnvTypePair ( env , JSType.UNKNOWN ) ;
if ( formalType . isBottom () ) { formalType = JSType.UNKNOWN ; }
pair.type = JSType.BOOLEAN ;
JSType operandType = requiredType . isNumber () ? JSType.NUMBER : JSType.UNKNOWN ;
private EnvTypePair analyzeExprBwd ( Node expr , TypeEnv outEnv ) { return analyzeExprBwd ( expr , outEnv , JSType.UNKNOWN ) ; }
if ( outerType == null ) { outerType = JSType.UNKNOWN ; }
{ JSType tmp = t . getIndexedType () ; return tmp == null ? JSType.UNKNOWN : tmp ; }
{ reqPtype = specPtype = JSType.UNKNOWN ; }
if ( ! currentScope . hasThis () ) { mayWarnAboutGlobalThis ( expr , currentScope ) ; return new EnvTypePair ( inEnv , JSType.UNKNOWN ) ; }
return new EnvTypePair ( env , JSType.UNKNOWN ) ;
funType . isOptionalArg ( i ) && pair.type . equals ( JSType.UNDEFINED )
rhsPair.type = JSType.BOOLEAN ;
{ return analyzeExprFwd ( expr , inEnv , JSType.UNKNOWN , JSType.UNKNOWN ) ; }
if ( rootNs != null && rootNs . isSubtypeOf ( JSType.TOP_OBJECT ) ) { namespaceType = rootNs . getProp ( qname . getAllButLeftmost () ) ; }
return ImmutableList . copyOf ( out ) ;
EnvTypePair lhsPair = analyzeExprBwd ( lhs , rhsPair.env ) ;
{ process ( null , scriptRoot ) ; }
passes . add ( checkVariableReferences ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
phaseopt . process ( externsNode , n ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
this . rawType . name . equals ( STRING_CONSTANT ) && NUMERIC_PATTERN . matcher ( pname ) . matches ()
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
public ProcessDefinesTest () { super ( STRING_CONSTANT ) ; allowSourcelessWarnings () ; }
assertThat ( JSDocInfoPrinter . print ( info ) ) . isEqualTo ( output ) ;
assertEquals ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , JSDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , JSDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , JSDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , JSDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , JSDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , JSDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , JSDocInfoPrinter . print ( info ) ) ;
phaseopt . process ( externsNode , externAndJsRoot ) ;
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
passes . add ( checkVariableReferencesForTranspileOnly ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
long stop () { return System . currentTimeMillis () + start ; }
replacement . setTypeI ( nativeStringType ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
phaseopt . process ( externsNode , n ) ;
{ FindStaticMembers findStaticMembers = new FindStaticMembers () ; NodeTraversal . traverseEs6 ( compiler , scriptRoot , findStaticMembers ) ; processInherits ( findStaticMembers.inheritsCalls ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
passes . add ( checkVariableReferences ) ;
{ process ( null , scriptRoot ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new J2clEqualitySameRewriterPass ( compiler ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new J2clConstantHoisterPass ( compiler ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new J2clClinitPrunerPass ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new J2clConstantHoisterPass ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clClinitPrunerPass ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clEqualitySameRewriterPass ( compiler ) ; }
Node moduleNode = new Node ( Token.MODULE_BODY ) ;
Node lhs = node . getFirstChild () . getFirstChild () ;
Node clinitFunction = multiExpression . getFirstChild () . getFirstChild () ;
Node methodName = member . getFirstChild () . getFirstChild () ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ;
public void disable_testClassMethodUnused2 () { this . disableTypeCheck () ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { this . disableTypeCheck () ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
{ passes . add ( flowSensitiveInlineVariables ) ; if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedVars ( STRING_CONSTANT , false ) ) ; } }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler , true ) ; }
options . setRemoveDeadCode ( true ) ;
options . setRemoveDeadCode ( true ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler , false ) ; }
options . setFoldConstants ( true ) ;
options . setFoldConstants ( true ) ;
options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ;
public void testInvalidAnnotation5 ( ) throws Exception { testError ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
public void testInvalidAnnotation4 ( ) throws Exception { testError ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
public String toModuleName () { return ModuleNames . toModuleName ( uri ) ; }
public String toJSIdentifier () { return ModuleNames . toJSIdentifier ( uri ) ; }
{ requires . add ( fileUri . resolveEs6Module ( arg ) . toModuleName () ) ; }
String globalModuleName = t . getInput () . getUri () . resolveEs6Module ( moduleName ) . toModuleName () ;
String moduleName = t . getInput () . getUri () . toModuleName () ;
String moduleName = t . getInput () . getUri () . resolveEs6Module ( moduleIdentifier . getString () ) . toModuleName () ;
{ moduleName = t . getInput () . getUri () . resolveEs6Module ( importName ) . toModuleName () ; }
ModuleLoader.ModuleUri actual
String moduleName = t . getInput () . getUri () . toModuleName () ;
TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , this ) ;
{ errorReporter . warning ( STRING_CONSTANT + SimpleErrorReporter . getMessage0 ( messageId ) , getSourceName () , lineno , charno ) ; }
{ errorReporter . warning ( STRING_CONSTANT + SimpleErrorReporter . getMessage1 ( messageId , messageArg ) , getSourceName () , lineno , charno ) ; }
assertWarning ( STRING_CONSTANT , RhinoErrorReporter.JSDOC_MISSING_BRACES_WARNING , STRING_CONSTANT ) ;
{ SourceMapObject sourceMapObject = new SourceMapObject ( contents ) ; parse ( sourceMapObject , null ) ; }
SourceMapObject sourceMapObject = new SourceMapObject ( contents ) ;
{ for ( MemberDefinition prop : PolymerPassStaticUtils . extractProperties ( objLit ) ) { prop.name . removeProp ( Node.JSDOC_INFO_PROP ) ; } }
PolymerPassStaticUtils . extractProperties ( objLit )
overwriteMembersIfPresent ( allProperties , PolymerPassStaticUtils . extractProperties ( descriptor ) ) ;
{ GwtProperties p = GwtProperties . load ( STRING_CONSTANT ) ; assertTrue ( p . propertyNames () . isEmpty () ) ; }
return MODULE_JOINER . join ( Arrays . copyOfRange ( buffer , NUMBER_CONSTANT , position ) ) ;
if ( options.coalesceVariableNames ) { passes . add ( coalesceVariableNames ) ; if ( options.foldConstants ) { passes . add ( peepholeOptimizations ) ; } }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ Preconditions . checkState ( hasInstanceType () ) ; return typeOfThis . toObjectType () ; }
{ if ( sideEffectInfo . taintedLocals () . contains ( v ) ) { sideEffectInfo . setTaintsUnknown () ; sideEffectInfo . resetLocalVars () ; break; } }
if ( defs == null ) { functionInfo . setTaintsUnknown () ; break; }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String currentJsSource = toSource () ;
Config config = ParserRunner . createConfig ( mode , Config.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , Config.RunMode.KEEP_GOING , null ) ;
return new ParseResult ( root , comments , features ) ;
{ return createConfig ( languageMode , JsDocParsing.TYPES_ONLY , RunMode.STOP_AFTER_ERROR , extraAnnotationNames ) ; }
{ this ( config , errorReporter , source , offset , false ) ; }
{ this ( annotationWhitelist , JsDocParsing.TYPES_ONLY , RunMode.STOP_AFTER_ERROR , suppressionNames , languageMode ) ; }
Config config = new Config ( extraAnnotations , parseDocumentation , RunMode.STOP_AFTER_ERROR , extraSuppressions , LanguageMode.ECMASCRIPT3 ) ;
Config config = new Config ( extraAnnotations , JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , RunMode.KEEP_GOING , extraSuppressions , LanguageMode.ECMASCRIPT3 ) ;
n . getType () == Token.DIV && n . getFirstChild () . isNumber () && n . getFirstChild () . getDouble () == NUMBER_CONSTANT
parent . getType ()
parent . getType ()
parent . getType ()
value . getType ()
node . getType ()
parent . getType ()
n . getType ()
ancestor . getType ()
{ switch ( node . getType () ) { case GETTER_DEF : case SETTER_DEF : return true ; default: break; } return false ; }
switch ( key . getType () ) { case STRING_KEY : case GETTER_DEF : case SETTER_DEF : case MEMBER_FUNCTION_DEF : return key . getString () ; default: break; }
{ switch ( node . getType () ) { case STRING_KEY : case GETTER_DEF : case SETTER_DEF : case MEMBER_FUNCTION_DEF : return true ; default: break; } return false ; }
return parent != null && parent . getType () == Token.ASSIGN && parent . getFirstChild () == n ;
current . getType ()
{ switch ( parent . getType () ) { case DECLARE : case EXPORT : return true ; default: return isStatementParent ( parent ) ; } }
switch ( parent . getType () ) { case SCRIPT : case MODULE_BODY : case BLOCK : case LABEL : case NAMESPACE_ELEMENTS : return true ; default: return false ; }
n . getType ()
n . getType ()
n . getType ()
parent . getType ()
n . getType ()
n . getType ()
{ switch ( n . getType () ) { case FOR : case FOR_OF : case DO : case WHILE : return true ; default: return false ; } }
n . getParent () . getType ()
{ @ Override public boolean apply ( Node n ) { return n . getType () == type ; } }
n . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
switch ( n . getType () ) { case VOID : return true ; case NAME : return n . getString () . equals ( STRING_CONSTANT ) ; default: break; }
n . getType ()
n . getType ()
Preconditions . checkArgument ( callNode . isNew () , STRING_CONSTANT , callNode . getType () ) ;
n . getType ()
val . getType ()
n . getType ()
{ switch ( n . getType () ) { case GT : case GE : case LT : case LE : return true ; default: break; } return false ; }
switch ( n . getType () ) { case EQ : case NE : case SHEQ : case SHNE : case MUL : return true ; default: break; }
n . getType ()
parent . getType ()
parent . getType ()
n . getType ()
n . getType ()
n . getType ()
n . getType ()
valueNode . getType ()
node . getType ()
Token pType = root . getParent () . getType () ;
Token parentType = parent . getType () ;
return DECLARATION_PARENTS . contains ( parent . getType () ) ;
parent . getType ()
propdef . setType ( Token.STRING ) ;
op . setType ( assignOp ) ;
if ( canFoldStandardConstructors ( n ) ) { n . setType ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; reportCodeChange () ; }
Token type = n . getType () ;
{ return include == nodeTypes . contains ( n . getType () ) ; }
Token type = valueNode . getType () ;
n . getType ()
n . getType ()
parent . setType ( Token.ASSIGN ) ;
newOperator . setType ( complementOperator ) ;
shorthand . setType ( NodeUtil . getOpFromAssignmentOp ( shorthand ) ) ;
n . setType ( Token.FOR ) ;
node . getType ()
{ switch ( n . getType () ) { case FOR : case FOR_OF : case DO : case WHILE : return true ; default: return false ; } }
n . getType ()
n . getType ()
{ for ( Token type : types ) { if ( c . getType () == type ) { return c ; } } }
n . getType ()
parent . getType ()
parent . getType ()
n . getType ()
{ if ( n . isConst () ) { handleDeclarationList ( n , n . getParent () ) ; } n . setType ( Token.VAR ) ; }
declarationList . setType ( Token.VAR ) ;
{ currentProp . setType ( Token.STRING ) ; newProp = IR . getprop ( objectToExtend . cloneTree () , currentProp ) . srcref ( currentProp ) ; }
n . getType ()
member . setType ( Token.STRING_KEY ) ;
c . setType ( Token.VAR ) ;
{ Node dollarChildProp = n . getGrandparent () ; dollarChildProp . setType ( Token.GETELEM ) ; compiler . reportCodeChange () ; }
switch ( node . getType () ) { case NAME : case STRING : case STRING_KEY : return node . getString () ; default: return compiler . toSource ( node ) ; }
{ Token inverseOperator = NodeUtil . getInverseOperator ( subtree . getToken () ) ; subtree . setType ( inverseOperator ) ; }
jsdoc . getType ()
return jsdocNode != null && jsdocNode . getType () == Token.ELLIPSIS ;
Preconditions . checkState ( thisRoot . getType () == Token.BANG ) ;
boolean isPropDeclared = propNode . getType () == Token.COLON ;
importedName . setType ( Token.NAME ) ;
key . setType ( Token.STRING_KEY ) ;
key . setType ( Token.SETTER_DEF ) ;
key . setType ( Token.GETTER_DEF ) ;
{ irNode . setType ( Token.BLOCK ) ; }
name . getType ()
parent . getType ()
n . setType ( TEMPLATE_LOCAL_NAME ) ;
n . setType ( TEMPLATE_TYPE_PARAM ) ;
keyNode . setType ( Token.STRING_KEY ) ;
keyNode . setType ( Token.STRING_KEY ) ;
( n == jsRoot || n . isFunction () ) && comp . hasScopeChanged ( n )
private boolean taintsThis () { return getMask ( TAINTS_THIS_MASK ) ; }
private boolean taintsGlobalState () { return getMask ( TAINTS_GLOBAL_STATE_MASK ) ; }
private boolean pureFunction () { return getMask ( PURE_FUNCTION_MASK ) ; }
{ if ( node . isFunction () ) { visitFunction ( node , parent ) ; } return true ; }
Collection < Definition > defs = getCallableDefinitions ( definitionProvider , callSite . getFirstChild () ) ;
this . functionSideEffectMap = new HashMap <> () ;
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new MinimizeExitPoints ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clClinitPrunerPass ( compiler , null ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new J2clConstantHoisterPass ( compiler , null ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clEqualitySameRewriterPass ( compiler , null ) ; }
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , OPTIONAL_TYPE_NOT_USING_OPTIONAL_NAME ) ;
this . compiler = compiler ;
boolean useTypesForOptimization = compiler . getOptions () . useTypesForOptimization ;
boolean shouldAmbiguateProperties () { return this . useTypesForOptimization || this . ambiguateProperties ; }
boolean shouldDisambiguateProperties () { return this . useTypesForOptimization || this . disambiguateProperties ; }
@ Override protected CompilerOptions getOptions ( CompilerOptions options ) { options.useTypesForOptimization = true ; return super . getOptions ( options ) ; }
CompilerPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeFoldConstants ( late , compiler . getOptions () . useTypesForOptimization ) ) ;
compiler . getOptions () . useTypesForOptimization
final boolean useTypesForOptimization = compiler . getOptions () . useTypesForOptimization ;
if ( ! compiler . getOptions () . useTypesForOptimization ) { return; }
{ CompilerOptions options = super . getOptions () ; options.useTypesForOptimization = useTypesForOptimization ; options . setJ2clPass ( CompilerOptions.J2clPassMode.ON ) ; return options ; }
