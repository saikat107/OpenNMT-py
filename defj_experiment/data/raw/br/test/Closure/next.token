! name.inExterns && name.globalSets == NUMBER_CONSTANT && name.localSets == NUMBER_CONSTANT && name.aliasingGets > NUMBER_CONSTANT
Context rhsContext = getContextForNoInOperator ( context ) ;
{ return topType . isAllType () ? getNativeType ( ARRAY_TYPE ) : topType ; }
{ if ( assignLhsChild != null ) { return true ; } return parent != null && NodeUtil . isGet ( parent ) ; }
int indexOfDot = namespace . lastIndexOf ( CHAR_CONS ) ;
int indexOfDot = namespace . lastIndexOf ( CHAR_CONS ) ;
! type . restrictByNotNullOrUndefined () . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) )
return false ;
return TernaryValue.UNKNOWN ;
if ( c > NUMBER_CONSTANT && c < NUMBER_CONSTANT ) { sb . append ( c ) ; } else { appendHexJavaScriptRepresentation ( sb , c ) ; }
{ defineSlot ( astParameter , functionNode , jsDocParameter . getJSType () , false ) ; jsDocParameter = jsDocParameter . getNext () ; }
if ( token != JsDocToken.LP ) { restoreLookAhead ( token ) ; return reportTypeSyntaxWarning ( STRING_CONSTANT ) ; }
{ initCompilerOptionsIfTesting () ; return toSource ( n , null , true ) ; }
String code = toSource ( root , sourceMap , inputSeqNum == NUMBER_CONSTANT ) ;
this . maybeAliased = NodeUtil . isExpressionResultUsed ( assignNode ) ;
if ( ( x < NUMBER_CONSTANT || negativeZero ) && prev == CHAR_CONS ) { add ( STRING_CONSTANT ) ; }
cc . addOp ( opStr , true ) ;
options.dependencyOptions . needsManagement () && options.closurePass
{ ( new NodeTraversal ( compiler , this ) ) . traverseRoots ( externs , root ) ; }
Node catchBody = blockUnchecked ( catchNode ) . copyInformationFrom ( catchNode ) ;
{ for ( Node finallyNode : cfa.finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch.ON_EX , finallyNode ) ; } }
{ if ( recurse ) { return anyResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; } }
String moduleName = guessCJSModuleName ( script . getSourceFileName () ) ;
c . canInline ( t . getScope () )
