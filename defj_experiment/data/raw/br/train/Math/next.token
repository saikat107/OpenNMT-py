final SecondOrderDifferentialEquations equations
public DerivativeException ( final Throwable cause ) { super ( cause ) ; }
super ( METHOD_NAME , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( METHOD_NAME , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
ODEIntegrator integrator
{ maxValueError = NUMBER_CONSTANT ; maxTimeError = NUMBER_CONSTANT ; lastError = NUMBER_CONSTANT ; expectedStepStart = Double.NaN ; }
CompositeFormat cf = new ComplexFormat () ;
CompositeFormat cf = ComplexFormat . getInstance ( getLocale () ) ;
stepSize = forward ? step : - step ;
stepSize = forward ? step : - step ;
this . step = Math . abs ( step ) ;
{ if ( qrt == null ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ System . arraycopy ( b [ i ] , NUMBER_CONSTANT , root . getDataRef () [ index [ i ] ] , NUMBER_CONSTANT , rank ) ; }
{ new QRDecompositionImpl () . isNonSingular () ; fail ( STRING_CONSTANT ) ; }
if ( ! isNonSingular () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! isNonSingular () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
{ RealMatrix XTX = X . transpose () . multiply ( X ) ; return new LUDecompositionImpl ( XTX ) . getInverse () ; }
if ( ! isNonSingular () ) { throw new RankDeficientMatrixException () ; }
if ( ! isNonSingular () ) { throw new RankDeficientMatrixException () ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
MatrixIndexException ex = new MatrixIndexException ( msg , new Object [ NUMBER_CONSTANT ] ) ;
if ( singular ) { throw new SingularMatrixException () ; }
if ( singular ) { throw new SingularMatrixException () ; }
if ( singular ) { throw new SingularMatrixException () ; }
if ( ! matrix . isSquare () ) { throw new NonSquareMatrixException ( matrix . getRowDimension () , matrix . getColumnDimension () ) ; }
if ( ! matrix . isSquare () ) { throw new NonSquareMatrixException ( matrix . getRowDimension () , matrix . getColumnDimension () ) ; }
if ( ! isSquare () ) { throw new NonSquareMatrixException ( getRowDimension () , getColumnDimension () ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
throw new MathRuntimeException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ;
catch ( Exception e ) { throw new MathRuntimeException ( e ) ; }
MatrixIndexException ex = new MatrixIndexException ( msg , null ) ;
InvalidMatrixException ex = new InvalidMatrixException ( msg , null ) ;
assertEquals ( NUMBER_CONSTANT , ex . getMessage ( Locale.FRENCH ) . length () ) ;
assertEquals ( NUMBER_CONSTANT , ex . getMessage ( Locale.FRENCH ) . length () ) ;
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT , null ) ; }
throw new MathRuntimeException ( STRING_CONSTANT , null ) ;
public Double getZ () { throw new MathRuntimeException ( STRING_CONSTANT , null ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT , null ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
{ super(); this . pattern = null ; this . arguments = new Object [ NUMBER_CONSTANT ] ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( Exception e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( Exception e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( Exception e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( IOException ioe ) { assertEquals ( NUMBER_CONSTANT , ioe . getMessage () . length () ) ; }
catch ( IOException ioe ) { assertEquals ( NUMBER_CONSTANT , ioe . getMessage () . length () ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
{ if ( qrt == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ if ( resultComputed ) { return iterationCount ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; }
{ if ( lu == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ if ( resultComputed ) { return iterationCount ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
if ( ! loaded ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT + STRING_CONSTANT , null ) ; } }
assertEquals ( NUMBER_CONSTANT , vTv . subtract ( id ) . getNorm () , NUMBER_CONSTANT ) ;
{ assertEquals ( refValues [ i ] , eigenValues [ i ] , NUMBER_CONSTANT ) ; }
transformer = null ;
ds = null ;
ds = null ;
ds = null ;
public int [] getPivot ( ) throws IllegalStateException { return pivot ; }
{ return eigenvalues [ i ] ; }
public double [] getEigenvalues ( ) throws InvalidMatrixException { return eigenvalues . clone () ; }
EigenDecomposition ed = new DecompositionSolver ( distinct ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( repeated ) . eigenDecompose () ;
RealMatrix v = new DecompositionSolver ( matrix ) . eigenDecompose () . getV () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new EigenDecompositionImpl ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
public double getNorm ( ) throws InvalidMatrixException { return singularValues [ NUMBER_CONSTANT ] ; }
public double [] getSingularValues ( ) throws InvalidMatrixException { return singularValues . clone () ; }
lu = null ;
lu = null ;
{ copyIn ( d ) ; lu = null ; }
lu = null ;
EigenDecomposition ed = new EigenDecompositionImpl ( distinct , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( repeated , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( m , MathUtils.SAFE_MIN ) ;
RealMatrix v = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) . getV () ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
{ return stat . evaluate ( eDA . getInternalValues () , eDA . start () , eDA . getNumElements () ) ; }
final RealVectorImpl v
final RealMatrixImpl m
final RealMatrixImpl m
final RealMatrixImpl m
{ setup ( f ) ; return factory . newDefaultSolver () . solve ( f , x0 , x1 ) ; }
cachedV = transformer . getV () . multiply ( MatrixUtils . createRealMatrix ( iData ) ) ;
cachedU = transformer . getU () . multiply ( MatrixUtils . createRealMatrix ( iData ) ) ;
{ this . X = MatrixUtils . createRealMatrix ( x ) ; }
{ this . Y = new RealVectorImpl ( y ) ; }
{ this . Omega = MatrixUtils . createRealMatrix ( omega ) ; this . OmegaInverse = null ; }
{ this . X = new DenseRealMatrix ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
{ this . solver = decomposition . getSolver () ; }
{ this . X = new RealMatrixImpl ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
{ this . X = new RealMatrixImpl ( x ) ; }
{ this . Y = new RealMatrixImpl ( y ) ; }
{ this . solver = decomposition . getSolver () ; }
{ eigenvectors [ i ] = findEigenvector ( realEigenvalues [ i ] , d , l ) ; }
{ realEigenvalues [ index ] = main [ index ] ; }
{ if ( eigenvectors == null ) { findEigenVectors () ; } return new Solver ( realEigenvalues , eigenvectors ) ; }
{ double determinant = NUMBER_CONSTANT ; for ( double lambda : realEigenvalues ) { determinant *= lambda ; } return determinant ; }
{ if ( cachedD == null ) { cachedD = MatrixUtils . createRealDiagonalMatrix ( realEigenvalues ) ; } return cachedD ; }
singularValues = eigenDecomposition . getRealEigenvalues () ;
{ if ( eigenvectors == null ) { findEigenVectors () ; } return new Solver ( realEigenvalues , imagEigenvalues , eigenvectors ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
{ return FastFourierTransformer . scaleArray ( fht ( f ) , NUMBER_CONSTANT / f.length ) ; }
{ OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap () ; assertTrue ( Double . isNaN ( map . remove ( NUMBER_CONSTANT ) ) ) ; }
values [ index ] = missingEntries ;
return new LUDecompositionImpl ( XTX ) . getSolver () . getInverse () ;
assertEquals ( new DenseRealMatrix ( reference ) , new DenseRealMatrix ( sub ) ) ;
assertEquals ( new DenseRealMatrix ( reference ) , new DenseRealMatrix ( sub ) ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
rDiag = new double [ Math . min ( m , n ) ] ;
return new LUDecompositionImpl ( XTOIX ) . getSolver () . getInverse () ;
{ if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; } }
if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; }
if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; }
if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; }
if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; }
private double getDeterminant ( RealMatrix m ) { return new LUDecompositionImpl ( m ) . getDeterminant () ; }
{ vals [ i ] = values [ i ] . doubleValue () ; }
roots . computeOmega ( - f.length ) ;
roots . computeOmega ( - f.length ) ;
{ roots . computeOmega ( f.length ) ; return fft ( f ) ; }
{ for ( int i = NUMBER_CONSTANT ; i < virtualSize ; i ++ ) { setEntry ( i , value ) ; } }
{ setEntry ( i , NUMBER_CONSTANT / getEntry ( i ) ) ; }
{ setEntry ( i , getEntry ( i ) + d ) ; }
{ res . setEntry ( i + virtualSize , a [ i ] ) ; }
{ RealVector res = new SparseRealVector ( this , NUMBER_CONSTANT ) ; res . setEntry ( virtualSize , d ) ; return res ; }
MatrixIndexException ex = new MatrixIndexException ( msg ) ;
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( numElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( STRING_CONSTANT ) ; }
public Double getZ () { throw new MathRuntimeException ( STRING_CONSTANT ) ; }
final Object . . . parts
FunctionEvaluationException ex = new FunctionEvaluationException ( cause , NUMBER_CONSTANT ) ;
FunctionEvaluationException ex = new FunctionEvaluationException ( cause , NUMBER_CONSTANT , pattern , arguments ) ;
if ( isZero ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , rows , columns ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
catch ( ClassCastException cce ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
Object . . . arguments
catch ( DimensionMismatchException dme ) { throw new MathRuntimeException ( dme , STRING_CONSTANT ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT ) ; }
Object . . . parts
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
Object . . . arguments
Object . . . parts
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return isForward ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
final Object . . . arguments
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
Object . . . arguments
MathException ex = new MathException ( cause , pattern , arguments ) ;
{ super ( isCardan ? STRING_CONSTANT : STRING_CONSTANT ) ; }
MathConfigurationException ex = new MathConfigurationException ( cause , pattern , arguments ) ;
Object . . . arguments
ConvergenceException ex = new ConvergenceException ( cause , pattern , arguments ) ;
{ throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
final Object . . . parts
final Object . . . arguments
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
final Object . . . parts
if ( b.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( ! isSquare () ) { throw new NonSquareMatrixException ( getRowDimension () , getColumnDimension () ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { throw new MathRuntimeException ( de , STRING_CONSTANT ) ; }
while ( iter . hasNext () ) { iter . advance () ; if ( Double . isNaN ( iter . value () ) ) { return true ; } }
while ( iter . hasNext () ) { iter . advance () ; if ( Double . isInfinite ( iter . value () ) ) { return true ; } }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , data.length , n ) ; } }
if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
epsilon = v . getEpsilon () ;
final ScalarOptimizer optimizer
final Comparator < ScalarPointValuePair > comparator
final VectorialObjectiveFunction function
final VectorialObjectiveFunction function
final VectorialObjectiveFunction function
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , buildArray ( m , factor ) , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , buildChebyquadArray ( n , factor ) , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , buildArray ( n , x0 ) , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; if ( theoreticalStartCost > NUMBER_CONSTANT ) { setCostAccuracy ( NUMBER_CONSTANT ) ; setParamsAccuracy ( NUMBER_CONSTANT ) ; } }
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; if ( theoreticalStartCost > NUMBER_CONSTANT ) { setCostAccuracy ( NUMBER_CONSTANT ) ; setParamsAccuracy ( NUMBER_CONSTANT ) ; } }
{ super ( NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , x0 ) , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
{ super ( NUMBER_CONSTANT , startParams , NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
{ super ( m , buildArray ( n , x0 ) , theoreticalMinCost , null ) ; }
final double residual = residuals [ i ] ;
++ jacobianEvaluations ;
{ setConvergenceChecker ( new SimpleVectorialValueChecker () ) ; setMaxIterations ( DEFAULT_MAX_ITERATIONS ) ; }
{ super ( cause , pattern , arguments ) ; this . argument = new double [] { argument } ; }
{ super ( cause ) ; this . argument = new double [] { argument } ; }
{ super ( pattern , arguments ) ; this . argument = new double [] { argument } ; }
assertEquals ( NUMBER_CONSTANT , ex . getArgument () [ NUMBER_CONSTANT ] , NUMBER_CONSTANT ) ;
assertEquals ( Math.PI , ex . getArgument () [ NUMBER_CONSTANT ] , NUMBER_CONSTANT ) ;
final MultivariateVectorialFunction function
{ if ( numerator == NUMBER_CONSTANT ) { return ZERO ; } return new BigFraction ( numerator , denominator ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . wholeFormat = format ; }
final ArrayList < BigFraction > coefficients
assertEquals ( ci , l40 [ i ] , Math . abs ( ci ) * NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , new BigFraction ( Double . longBitsToDouble ( NUMBER_CONSTANT ) ) . getNumeratorAsLong () ) ;
@ Override protected Locale getLocale () { return Locale.US ; }
@ Override protected Locale getLocale () { return Locale.FRENCH ; }
@ Override protected String getResourceName () { return STRING_CONSTANT ; }
@ Override protected String getResourceName () { return STRING_CONSTANT ; }
@ Override protected Locale getLocale () { return Locale.US ; }
@ Override protected Locale getLocale () { return Locale.FRENCH ; }
@ Override protected Locale getLocale () { return Locale.FRENCH ; }
@ Override protected Locale getLocale () { return Locale.US ; }
{ setup ( f ) ; return LazyHolder.FACTORY . newDefaultSolver () . solve ( f , x0 , x1 ) ; }
{ logSum += Math . log ( i ) ; }
double degreesOfFreedom = ( n1 + n2 - NUMBER_CONSTANT ) ;
{ return ( sumY - slope * sumX ) / ( n ) ; }
Math . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / n ) + ( xbar * xbar ) / sumXX ) )
{ if ( n < NUMBER_CONSTANT ) { return Double.NaN ; } return getSumSquaredErrors () / ( n - NUMBER_CONSTANT ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
double n = length ;
{ dest.variance = source.variance . copy () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
{ dest.incMoment = source.incMoment ; dest.moment = source.moment . copy () ; }
double sampleSize = length ;
{ dest.moment = source.moment . copy () ; dest.incMoment = source.incMoment ; }
{ dest.sumOfLogs = source.sumOfLogs . copy () ; }
{ return Math . exp ( sumOfLogs . evaluate ( values , begin , length ) / length ) ; }
{ return Math . exp ( sumOfLogs . getResult () / sumOfLogs . getN () ) ; }
{ result [ i - NUMBER_CONSTANT ] = i * coefficients [ i ] ; }
double n0 = n ;
{ dest.moment = new ThirdMoment ( source.moment . copy () ) ; dest.incMoment = source.incMoment ; }
{ dest.moment = source.moment . copy () ; dest.isBiasCorrected = source.isBiasCorrected ; dest.incMoment = source.incMoment ; }
double len = length ;
{ super ( problem ) ; y = problem.y . clone () ; }
return Math . sqrt ( sum / v.length ) ;
{ super ( problem ) ; e = problem.e ; y = problem.y . clone () ; }
{ super ( problem ) ; y = problem.y . clone () ; }
{ dY [ i ] = y [ i ] ; }
{ dX [ i ] = x [ i ] ; }
{ super ( problem ) ; a = problem.a ; y = problem.y . clone () ; }
try { randomData . nextExponential ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) {}
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
SimplexTableau tableau = new SimplexTableau ( f , constraints , GoalType.MAXIMIZE , false , NUMBER_CONSTANT ) ;
SimplexTableau tableau = new SimplexTableau ( f , constraints , GoalType.MAXIMIZE , false , NUMBER_CONSTANT ) ;
final SimplexTableau tableau = new SimplexTableau ( f , constraints , goalType , restrictToNonNegative , epsilon ) ;
{ return ( sumY - slope * sumX ) / n ; }
Math . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / ( double ) n ) + ( xbar * xbar ) / sumXX ) )
Math . sqrt ( ( accum - ( Math . pow ( accum2 , NUMBER_CONSTANT ) / length ) ) / ( length - NUMBER_CONSTANT ) )
{ checkSufficientData ( matrix ) ; nObs = matrix . getRowDimension () ; correlationMatrix = computeCorrelationMatrix ( matrix ) ; }
{ checkSufficientData ( matrix ) ; n = matrix . getRowDimension () ; covarianceMatrix = computeCovarianceMatrix ( matrix , biasCorrected ) ; }
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) {}
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { testGenerator . nextInt ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { regression . getSlopeConfidenceInterval ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) {}
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
Iterator < > it = f . valuesIterator () ;
final T [] out = buildArray ( field , nCols ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nCols ) ;
final T [] [] data = buildArray ( field , getRowDimension () , getColumnDimension () ) ;
final T [] [] out = buildArray ( getField () , nRows , getColumnDimension () ) ;
final T [] out = buildArray ( getField () , nCols ) ;
final T [] out = buildArray ( getField () , nRows ) ;
data = buildArray ( getField () , subMatrix.length , nCols ) ;
final T [] [] outData = buildArray ( getField () , nRows , nCols ) ;
final T [] [] outData = buildArray ( getField () , rowCount , columnCount ) ;
final T [] [] outData = buildArray ( getField () , rowCount , columnCount ) ;
{ return ( FieldVectorImpl < T > ) subtract ( v.data ) ; }
{ return ( FieldVectorImpl < T > ) add ( v.data ) ; }
super ( extractField ( v ) ) ;
super ( extractField ( d ) ) ;
{ super ( extractField ( d ) ) ; copyIn ( d ) ; }
nextAction = handler . eventOccurred ( t , y , ! ( increasing ^ forward ) ) ;
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( Double . doubleToLongBits ( test ) != Double . doubleToLongBits ( getEntry ( iter . key () ) ) ) { return false ; }
double [] hatResiduals = I . subtract ( hat ) . operate ( model.Y ) . getData () ;
{ this . Y = new RealVectorImpl ( y ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
if ( n < NUMBER_CONSTANT || n != sample2.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n , sample2.length ) ; }
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , windowSize ) ; } }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; } this . mean = mean ; }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . alpha = alpha ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( size < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , size ) ; } sampleSize = size ; }
{ if ( size <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , size ) ; } populationSize = size ; }
{ if ( num < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , num ) ; } numberOfSuccesses = num ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . alpha = alpha ; }
if ( r < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , r ) ; }
catch ( ClassCastException ex ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getClass () . getName () ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getClass () . getName () ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( successes < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , successes ) ; } numberOfSuccesses = successes ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ;
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . degreesOfFreedom = degreesOfFreedom ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
if ( mean.length != standardDeviation.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean.length , standardDeviation.length ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( trials < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , trials ) ; } numberOfTrials = trials ; }
{ if ( realFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . realFormat = realFormat ; }
{ if ( imaginaryFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . imaginaryFormat = imaginaryFormat ; }
if ( imaginaryCharacter == null || imaginaryCharacter . length () == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ; }
if ( p <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ;
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( sd <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , sd ) ; } standardDeviation = sd ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , s ) ; } scale = s ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( mean < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; }
if ( sigma <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , sigma ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , len ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , len ) ; }
if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
Comparable < > obj1 = null ;
OpenMapRealVector v1 = new OpenMapRealVector ( vec1 ) ;
return new OpenMapRealVector ( out ) ;
{ assertEquals ( expected [ i ] , observed [ i ] , tolerance ) ; }
final int dimension = ( currentState == null ) ? - NUMBER_CONSTANT : currentState.length ;
final int dimension = ( currentState == null ) ? - NUMBER_CONSTANT : currentState.length ;
final StepInterpolator prototype
integrator = null ;
integrator = null ;
{ super(); yDotK = null ; integrator = null ; }
interpolator . reinitialize ( new DummyIntegrator ( interpolator ) , y , yDot , true ) ;
interpolator . reinitialize ( new DummyIntegrator ( interpolator ) , y , yDot , true ) ;
interpolator . reinitialize ( new DummyIntegrator ( interpolator ) , y , yDot , true ) ;
{ this . factors = new BlockRealMatrix ( factors ) ; this . target = target ; }
{ this . factors = new BlockRealMatrix ( factors ) ; this . target = target ; }
assertEquals ( MatrixUtils . createColumnRealMatrix ( col ) , new BlockRealMatrix ( colMatrix ) ) ;
assertEquals ( MatrixUtils . createRowRealMatrix ( row ) , new BlockRealMatrix ( rowMatrix ) ) ;
RealMatrix mA = new BlockRealMatrix ( a ) ;
RealMatrix result = new BlockRealMatrix ( dimension , dimension ) ;
return new BlockRealMatrix ( matrixData ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new BlockRealMatrix ( testDataInv ) ) , identity , entryTolerance ) ;
{ BlockRealMatrix m = new BlockRealMatrix ( testData ) ; assertEquals ( m , TestUtils . serializeAndRecover ( m ) ) ; }
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
assertEquals ( new BlockRealMatrix ( reference ) , new BlockRealMatrix ( sub ) ) ;
assertEquals ( new BlockRealMatrix ( reference ) , new BlockRealMatrix ( sub ) ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
assertEquals ( new BlockRealMatrix ( reference ) , sub ) ;
assertEquals ( new BlockRealMatrix ( reference ) , sub ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( testData ) ;
RealMatrix m = new BlockRealMatrix ( testData ) ;
RealMatrix m = new BlockRealMatrix ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ this . factors = new BlockRealMatrix ( factors ) ; this . target = target ; }
{ return computeCorrelationMatrix ( new BlockRealMatrix ( data ) ) ; }
RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ;
{ return computeCorrelationMatrix ( new BlockRealMatrix ( data ) ) ; }
RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ;
return new BlockRealMatrix ( out ) ;
return new BlockRealMatrix ( out ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
assertEquals ( new BlockFieldMatrix < Fraction > ( reference ) , sub ) ;
assertEquals ( new BlockFieldMatrix < Fraction > ( reference ) , sub ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
{ return computeCovarianceMatrix ( new BlockRealMatrix ( data ) , biasCorrected ) ; }
RealMatrix outMatrix = new BlockRealMatrix ( dimension , dimension ) ;
{ this ( new BlockRealMatrix ( data ) , biasCorrected ) ; }
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
{ setColumn ( column , ( ( ArrayRealVector ) vector ) . getDataRef () ) ; }
return new ArrayRealVector ( outData , false ) ;
{ setRow ( row , ( ( ArrayRealVector ) vector ) . getDataRef () ) ; }
return new ArrayRealVector ( outData , false ) ;
{ return new ArrayRealVector ( getColumn ( column ) , false ) ; }
{ return new ArrayRealVector ( getRow ( row ) , false ) ; }
eigenvectors = new ArrayRealVector [ m ] ;
final ArrayRealVector v = eigenvectors [ i ] ;
final ArrayRealVector v = eigenvectors [ i ] ;
{ this . X = new Array2DRowRealMatrix ( x ) ; }
{ this . Y = new ArrayRealVector ( y ) ; }
return new ArrayRealVector ( data , false ) ;
{ m . setColumnVector ( NUMBER_CONSTANT , new ArrayRealVector ( NUMBER_CONSTANT ) ) ; fail ( STRING_CONSTANT ) ; }
TestUtils . assertEquals ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
{ super ( STRING_CONSTANT , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
return new Array2DRowFieldMatrix < Fraction > ( out ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
return new ArrayFieldVector < Fraction > ( data , false ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
assertEquals ( new Array2DRowFieldMatrix < Fraction > ( reference ) , sub ) ;
assertEquals ( new Array2DRowFieldMatrix < Fraction > ( reference ) , sub ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
{ this ( new ArrayRealVector ( coefficients ) , constantTerm ) ; }
{ this ( new ArrayRealVector ( coefficients ) , relationship , value ) ; }
return new Array2DRowRealMatrix ( matrixData ) ;
RealMatrix repeatedColumns = new Array2DRowRealMatrix ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
this . tableau = new Array2DRowRealMatrix ( matrix ) ;
this . tableau = new Array2DRowRealMatrix ( createTableau ( goalType == GoalType.MAXIMIZE ) ) ;
nordsieck = new Array2DRowRealMatrix ( nData , false ) ;
{ setColumn ( column , ( ( ArrayFieldVector < T > ) vector ) . getDataRef () ) ; }
return new ArrayFieldVector < T > ( outData , false ) ;
{ setRow ( row , ( ( ArrayFieldVector < T > ) vector ) . getDataRef () ) ; }
return new ArrayFieldVector < T > ( outData , false ) ;
return new ArrayRealVector ( x ) ;
{ this . X = new Array2DRowRealMatrix ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
Array2DRowRealMatrix augI = new Array2DRowRealMatrix ( n , n ) ;
return new Array2DRowFieldMatrix < BigFraction > ( pData , false ) ;
FieldMatrix < BigFraction > bigMSupdate = bigMStoN . multiply ( new Array2DRowFieldMatrix < BigFraction > ( shiftedP , false ) ) ;
return coefficients.msToN . multiply ( new Array2DRowRealMatrix ( multistep , false ) ) ;
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
return new Array2DRowRealMatrix ( x , false ) ;
{ this . Omega = new Array2DRowRealMatrix ( omega ) ; this . OmegaInverse = null ; }
{ return new ArrayFieldVector < T > ( getColumn ( column ) , false ) ; }
{ return new ArrayFieldVector < T > ( getRow ( row ) , false ) ; }
return new ArrayRealVector ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
RealVector lhs = new ArrayRealVector ( numCoefficients ) ;
final RealMatrix matrix = new Array2DRowRealMatrix ( data , false ) ;
final RealVector vector = new ArrayRealVector ( data , false ) ;
RealMatrix getConvertedMatrix () { return new Array2DRowRealMatrix ( data , false ) ; }
RealMatrix getConvertedMatrix () { return new Array2DRowRealMatrix ( data , false ) ; }
{ return new ArrayFieldVector < T > ( data , true ) ; }
return new Array2DRowFieldMatrix < T > ( d , false ) ;
new Array2DRowFieldMatrix < T > ( data )
new Array2DRowFieldMatrix < T > ( field , rows , columns )
{ es . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
decompMatrix = new Array2DRowRealMatrix ( decomp ) ;
RealMatrix triangularMatrix = new Array2DRowRealMatrix ( lowerTriangularMatrix ) ;
RealMatrix triangularMatrix = new Array2DRowRealMatrix ( lowerTriangularMatrix ) ;
solver . solve ( new Array2DRowRealMatrix ( m3 ) , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } ) ;
solver . decompose ( new Array2DRowRealMatrix ( m7 ) ) ;
return new ArrayFieldVector < Fraction > ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayFieldVector < Fraction > ( testVector ) ) . getData () , entryTolerance ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix < Fraction > ( testDataInv ) ) , identity , entryTolerance ) ;
return new Array2DRowRealMatrix ( bp , false ) ;
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
return new Array2DRowFieldMatrix < BigFraction > ( pData , false ) ;
FieldMatrix < BigFraction > bigMSupdate = bigMStoN . multiply ( new Array2DRowFieldMatrix < BigFraction > ( shiftedP , false ) ) ;
return coefficients.msToN . multiply ( new Array2DRowRealMatrix ( multistep , false ) ) ;
FieldMatrix < T > identity = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
return new Array2DRowFieldMatrix < T > ( bp , false ) ;
cachedP = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
cachedU = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
cachedL = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n , startConfiguration.length ) ; }
f . set ( this , NordsieckTransformer . getInstance ( nSteps + NUMBER_CONSTANT ) ) ;
{ super ( STRING_CONSTANT , nSteps , nSteps , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
final Array2DRowRealMatrix nordsieck
if ( interpolator.nordsieck != null ) { nordsieck = new Array2DRowRealMatrix ( interpolator.nordsieck . getDataRef () , true ) ; }
nordsieck = initializeHighOrderDerivatives ( scaled , multistep ) ;
v instanceof SparseFieldVector < >
v instanceof SparseFieldVector < >
v instanceof SparseFieldVector < >
v instanceof SparseFieldVector < >
! ( original instanceof RandomKey < > )
if ( ! ( another instanceof RandomKey < > ) ) return false ;
{ measurements [ i ] = new MinpackMeasurement ( this , i ) ; }
StatisticalSummary observed
optimizer . setConvergenceChecker ( new SimpleRealPointChecker ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
optimizer . setConvergenceChecker ( new SimpleVectorialPointChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
this . constraints = normalizeConstraints ( constraints ) ;
return FACTORIALS [ n ] ;
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new ThreeEighthesStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new EulerStepInterpolator () , step ) ; }
public static DummyStepHandler getInstance () { return INSTANCE ; }
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new MidpointStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new ClassicalRungeKuttaStepInterpolator () , step ) ; }
@ Override public Object [] [] getContents () { return CONTENTS . clone () ; }
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new GillStepInterpolator () , step ) ; }
try { alg = MessageDigest . getInstance ( STRING_CONSTANT ) ; } catch ( NoSuchAlgorithmException ex ) { throw MathRuntimeException . createInternalError ( ex ) ; }
{ return row * columns + column ; }
@ Override public int getRowDimension () { return rows ; }
@ Override public int getColumnDimension () { return columns ; }
{ return row * columns + column ; }
@ Override public int getRowDimension () { return rows ; }
@ Override public int getColumnDimension () { return columns ; }
final SimplexTableau tableau = new SimplexTableau ( function , linearConstraints , goal , nonNegative , epsilon ) ;
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . scale = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . shape = alpha ; }
{ final double residual = residuals [ i ] ; chiSquare += residual * residual / residualsWeights [ i ] ; }
{ final double residual = residuals [ i ] ; criterion += residualsWeights [ i ] * residual * residual ; }
final double factor = - Math . sqrt ( residualsWeights [ i ] ) ;
catch ( NumberFormatException e ) { throw new MathException ( e , STRING_CONSTANT , e . getMessage () ) ; }
public static DummyStepHandler getInstance () { return LazyHolder.INSTANCE ; }
final RandomGenerator generator
return anovaPValue ( categoryData ) < alpha ;
{ return internalArray ; }
{ return internalArray ; }
synchronized int getInternalLength () { return internalArray.length ; }
return isForward ? omegaImaginaryForward [ k ] : omegaImaginaryInverse [ k ] ;
isForward = n > NUMBER_CONSTANT ;
{ checkSignificanceLevel ( alpha ) ; return tTest ( sampleStats1 , sampleStats2 ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return homoscedasticTTest ( sample1 , sample2 ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return tTest ( sample1 , sample2 ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return tTest ( mu , sampleStats ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return tTest ( mu , sample ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return pairedTTest ( sample1 , sample2 ) < alpha ; }
public boolean isSquare () { return getColumnDimension () == getRowDimension () ; }
{ g0Positive = g0 >= NUMBER_CONSTANT ; nextAction = EventHandler.CONTINUE ; }
increasing = gb >= ga ;
{ t0 = tStart ; g0 = handler . g ( tStart , yStart ) ; g0Positive = g0 >= NUMBER_CONSTANT ; }
final boolean forward = t > t0 ;
final boolean forward = t > t0 ;
final boolean forward = t > t0 ;
{ return o1 . compareTo ( ( T ) o2 ) ; }
return chiSquareTestDataSetsComparison ( observed1 , observed2 ) < alpha ;
unequalCounts = countSum1 != countSum2 ;
return chiSquareTest ( counts ) < alpha ;
return chiSquareTest ( expected , observed ) < alpha ;
{ correction += values [ i ] - xbar ; }
public boolean isSquare () { return getColumnDimension () == getRowDimension () ; }
return super . equals ( stat ) && aggregateStatistics . equals ( stat.aggregateStatistics ) ;
final boolean forward = t > t0 ;
forward = interpolator . getCurrentTime () >= lastTime ;
final boolean forward = t > t0 ;
Complex N1 = new Complex ( n - NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
while ( ! tableau . isOptimal () ) { doIteration ( tableau ) ; }
while ( ! tableau . isOptimal () ) { doIteration ( tableau ) ; }
double [] bounds = ( ( EmpiricalDistributionImpl ) empiricalDistribution2 ) . getGeneratorUpperBounds () ;
if ( xval.length == NUMBER_CONSTANT || xval [ NUMBER_CONSTANT ] == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( microsphereElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , microsphereElements ) ; } this . microsphereElements = microsphereElements ; }
{ if ( brightnessExponent < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , brightnessExponent ) ; } this . brightnessExponent = brightnessExponent ; }
super ( rootCause ) ;
super ( rootCause ) ;
catch ( IOException e ) { throw new MathRuntimeException ( e ) ; }
Math . sqrt ( MathUtils.TWO_PI * x )
double f = ( MathUtils.TWO_PI * x * ( n - x ) ) / n ;
double d = x - mu ;
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FRACTION ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FRACTION ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FRACTION ) ; }
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( OVERFLOW_MESSAGE , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
{ if ( BigInteger.ZERO . equals ( fraction.numerator ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; } return multiply ( fraction . reciprocal () ) ; }
if ( BigInteger.ZERO . equals ( bg ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; }
if ( BigInteger.ZERO . equals ( den ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; }
if ( ! restrictToNonNegative ) { columnLabels . add ( NEGATIVE_VAR_COLUMN_LABEL ) ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
{ super ( FAILED_EVALUATION_MESSAGE , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
{ super ( FAILED_EVALUATION_MESSAGE , argument ) ; this . argument = new double [] { argument } ; }
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( DIMENSION_MISMATCH_MESSAGE , n , startConfiguration.length ) ; }
if ( steps [ j ] == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EQUAL_VERTICES_MESSAGE , j , j + NUMBER_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREE_MESSAGE , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREE_MESSAGE , n ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POLYNOMIAL_FUNCTION_MESSAGE ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( NON_POLYNOMIAL_FUNCTION_MESSAGE ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTH_MISMATCH_MESSAGE , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTH_MISMATCH_MESSAGE , b.length , m ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( OUT_OF_RANGE_POINT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( WRONG_ORDER_ENDPOINTS_MESSAGE , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( WRONG_ORDER_ENDPOINTS_MESSAGE , x0 , x1 ) ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FUNCTION_MESSAGE ) ; } }
if ( function == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FUNCTION_MESSAGE ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( NON_FITTING_POSITION_AND_SIZE_MESSAGE , pos , size , d.length ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( NON_FITTING_POSITION_AND_SIZE_MESSAGE , pos , size , d.length ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( MISSING_ROOTS_OF_UNITY_MESSAGE ) ; } return isForward ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( NOT_POWER_OF_TWO_MESSAGE , o.length ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( NOT_POWER_OF_TWO_MESSAGE , d.length ) ; } }
int value = decoded . get ( i ) ;
return mapDivide ( norm ) ;
if ( isDefaultValue ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
public OpenMapRealVector ( int dimension ) { this ( dimension , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
public void setEntry ( int index , double value ) throws MatrixIndexException { data [ index ] = value ; }
{ try { return mapToSelf ( ComposableFunction.ULP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TANH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SQRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SINH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIGNUM ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.RINT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG10 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.FLOOR ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXPM1 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.COSH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.COS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CEIL ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CBRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ATAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ACOS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ABS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG1P ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
epsilon = DEFAULT_ZERO_TOLERANCE ;
{ this ( values , DEFAULT_ZERO_TOLERANCE ) ; }
public OpenMapRealVector ( int dimension ) { this ( dimension , DEFAULT_ZERO_TOLERANCE ) ; }
{ this ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE ) ; }
{ return new BigReal ( d . divide ( a.d , scale , roundingMode ) ) ; }
return new ArrayRealVector ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
if ( lcm == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , a , b ) ; }
{ return new Solver ( singularValues , getUT () , getV () , getRank () == Math . max ( m , n ) ) ; }
@ Override public double getNorm () { throw unsupported () ; }
@ Override public double getL1Norm () { throw unsupported () ; }
@ Override public double getLInfNorm () { throw unsupported () ; }
@ Override public double getNorm () { throw unsupported () ; }
@ Override public double getL1Norm () { throw unsupported () ; }
@ Override public double getLInfNorm () { throw unsupported () ; }
{ dest.n = source.n ; dest.m1 = source.m1 ; dest.dev = source.dev ; dest.nDev = source.nDev ; }
{ new LoessInterpolator ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ new LoessInterpolator ( - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; }
assertEquals ( NUMBER_CONSTANT , solution . subtract ( xRef ) . getNorm () , NUMBER_CONSTANT ) ;
{ interpolator = new DummyStepInterpolator ( yTmp , yDotK [ stages - NUMBER_CONSTANT ] , forward ) ; }
{ super ( interpolator ) ; currentDerivative = interpolator.currentDerivative . clone () ; }
{ super(); currentDerivative = null ; }
public BadStepInterpolator ( double [] y , boolean forward ) { super ( y , new double [ y.length ] , forward ) ; }
DummyStepInterpolator interpolator = new DummyStepInterpolator ( y , new double [ y.length ] , true ) ;
{ interpolator = new DummyStepInterpolator ( yTmp , yDotK [ stages - NUMBER_CONSTANT ] , forward ) ; }
final ODEWithJacobians ode
{ this ( mean , sd , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setTolerance ( defaultTolerance ) ; }
{ super ( f , DEFAULT_MAXIMUM_ITERATIONS , DEFAULT_ABSOLUTE_ACCURACY ) ; }
{ if ( p < NUMBER_CONSTANT ) { return mean ; } else { return Double.MAX_VALUE ; } }
{ ret = - mean * Math . log ( NUMBER_CONSTANT - p ) ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - x / mean ) ; }
public ExponentialDistributionImpl ( double mean ) { super(); setMeanInternal ( mean ) ; }
{ ret = Beta . regularizedBeta ( probabilityOfSuccess , numberOfSuccesses , x + NUMBER_CONSTANT ) ; }
if ( p < NUMBER_CONSTANT ) { ret = alpha * beta ; } else { ret = Double.MAX_VALUE ; }
{ ret = Gamma . regularizedGammaP ( alpha , x / beta ) ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - Math . pow ( x / scale , shape ) ) ; }
public TDistributionImpl ( double degreesOfFreedom ) { super(); setDegreesOfFreedomInternal ( degreesOfFreedom ) ; }
{ return gamma . cumulativeProbability ( x ) ; }
if ( x <= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else if ( x >= numberOfElements ) { return NUMBER_CONSTANT ; }
double d = denominatorDegreesOfFreedom ;
{ return numberOfTrials ; }
if ( p < NUMBER_CONSTANT ) { ret = mean ; } else { ret = Double.MAX_VALUE ; }
if ( p < NUMBER_CONSTANT ) { ret = - Double.MAX_VALUE ; } else { ret = mean ; }
if ( p < NUMBER_CONSTANT ) { ret = median ; } else { ret = Double.MAX_VALUE ; }
if ( p < NUMBER_CONSTANT ) { ret = - Double.MAX_VALUE ; } else { ret = median ; }
public LaguerreSolver () { super ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; p = null ; }
protected void setDistribution ( AbstractContinuousDistribution distribution ) { this . distribution = distribution ; }
public TDistributionImpl ( double degreesOfFreedom ) { this ( degreesOfFreedom , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ this ( numeratorDegreesOfFreedom , denominatorDegreesOfFreedom , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ this ( alpha , beta , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ this ( alpha , beta , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
public ExponentialDistributionImpl ( double mean ) { this ( mean , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ this ( median , s , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
final double [] row = AINV [ i ] ;
{ return solve ( f , min , max ) ; }
int length = TestUtils . eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = TestUtils . eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = TestUtils . eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = TestUtils . eliminateZeroMassPoints ( densityPoints , densityValues ) ;
assertFalse ( MathUtils . equals ( Double.NaN , Double.NaN , NUMBER_CONSTANT ) ) ;
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( observations.length != scale . getColumnDimension () ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , observations.length , scale . getColumnDimension () ) ; }
if ( observations.length != weights.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , observations.length , weights.length ) ; }
if ( dimension == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE , minSingularValue , singularValues [ NUMBER_CONSTANT ] ) ; }
catch ( DuplicateSampleAbscissaException e ) { throw new FunctionEvaluationException ( e , z , e . getLocalizablePattern () , e . getArguments () ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
{ super ( LocalizedFormats.FRACTION_CONVERSION_OVERFLOW , value , p , q ) ; }
{ super ( LocalizedFormats.FAILED_FRACTION_CONVERSION , value , maxIterations ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_WHOLE_FORMAT ) ; } this . wholeFormat = format ; }
final Localizable specifier
if ( sampleStats . getN () == NUMBER_CONSTANT ) { throw MathRuntimeException . createEOFException ( LocalizedFormats.URL_CONTAINS_NO_DATA , url ) ; }
if ( r < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_COMPLEX_MODULE , r ) ; }
if ( b.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v.length != getColumnDimension () ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || zval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optima . clone () ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , columns ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIFFERENT_ROWS_LENGTHS , columns , length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
{ this ( new DummyLocalizable ( pattern ) , arguments ) ; }
Localizable specifier
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
{ if ( newDegreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM , newDegreesOfFreedom ) ; } this . degreesOfFreedom = newDegreesOfFreedom ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
{ throw new MathRuntimeException ( new UnsupportedOperationException () , LocalizedFormats.NO_DENSITY_FOR_THIS_DISTRIBUTION ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( successes < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_NUMBER_OF_SUCCESSES , successes ) ; } numberOfSuccesses = successes ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SCALE , beta ) ; } this . scale = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SHAPE , alpha ) ; } this . shape = alpha ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public Double getZ () { throw new MathRuntimeException ( LocalizedFormats.SIMPLE_MESSAGE , STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_UPPER_BOUND , n ) ; }
if ( e . compareTo ( BigInteger.ZERO ) < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
{ if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; } return k . pow ( e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( lcm == Long.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.LCM_OVERFLOW_64_BITS , a , b ) ; }
if ( lcm == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.LCM_OVERFLOW_32_BITS , a , b ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NON_POSITIVE_POLYNOMIAL_DEGREE , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NON_POSITIVE_POLYNOMIAL_DEGREE , n ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FUNCTION_NOT_POLYNOMIAL ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FUNCTION_NOT_POLYNOMIAL ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS , nRows , nCols ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_COVARIANCE_MATRIX ) ; }
{ throw new DerivativeException ( LocalizedFormats.SIMPLE_MESSAGE , STRING_CONSTANT ) ; }
if ( ( c1 / c2 < NUMBER_CONSTANT ) || ( c2 / c3 < NUMBER_CONSTANT ) ) { throw new OptimizationException ( LocalizedFormats.UNABLE_TO_FIRST_GUESS_HARMONIC_COEFFICIENTS ) ; }
{ super ( LocalizedFormats.EVALUATION_FAILED , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
{ super ( LocalizedFormats.EVALUATION_FAILED , argument ) ; this . argument = new double [] { argument } ; }
{ this ( cause , new DummyLocalizable ( pattern ) , arguments ) ; }
{ this ( new DummyLocalizable ( pattern ) , arguments ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS ) ; } }
catch ( InvalidMatrixException ime ) { throw new OptimizationException ( LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , data.length , n ) ; } }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY , pos , size , d.length ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT ) ; }
{ super ( LocalizedFormats.DUPLICATED_ABSCISSA , abscissa , i1 , i2 ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optima . clone () ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS , nRows , nCols ) ; }
{ double d = getDimension () ; if ( d != n ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , d , n ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_RESULT_AVAILABLE ) ; } }
{ this ( new DummyLocalizable ( pattern ) , arguments ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
{ if ( ( minimalIterationCount <= NUMBER_CONSTANT ) || ( maximalIterationCount <= minimalIterationCount ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_ITERATIONS_LIMITS , minimalIterationCount , maximalIterationCount ) ; } }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_RESULT_AVAILABLE ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
{ throw new IntegratorException ( LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION , minStep , Math . abs ( h ) ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , n ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , n ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , data.length , n ) ; } }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY , pos , size , d.length ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY , pos , size , d.length ) ; }
if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_ITERATIONS_LIMITS , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.SAME_SIGN_AT_ENDPOINTS , min , max , yMin , yMax ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( newMean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_MEAN , newMean ) ; } this . mean = newMean ; }
if ( isDefaultValue ( norm ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
{ if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p ) ; } quantile = p ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p ) ; }
{ if ( getDimension () != n ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , getDimension () , n ) ; } }
if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET ) ; }
if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_COMPUTE_0TH_ROOT_OF_UNITY ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET ) ; } return isForward ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , o.length ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , d.length ) ; } }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES , n ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_ITERATIONS_LIMITS , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_EXPONENT , s ) ; } this . exponent = s ; }
{ if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_DIMENSION , n , NUMBER_CONSTANT ) ; } this . numberOfElements = n ; }
if ( i < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INDEX_NOT_POSITIVE , i ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INITIAL_CAPACITY_NOT_POSITIVE , initialCapacity ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.UNSUPPORTED_EXPANSION_MODE , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( LocalizedFormats.CANNOT_SET_AT_NEGATIVE_INDEX , index ) ; }
if ( expansion <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EXPANSION_FACTOR_SMALLER_THAN_ONE , expansion ) ; }
if ( numElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_NUMERATOR_FORMAT ) ; } this . numeratorFormat = format ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_DENOMINATOR_FORMAT ) ; } this . denominatorFormat = format ; }
if ( nSteps <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INTEGRATION_METHOD_NEEDS_AT_LEAST_ONE_PREVIOUS_POINT , name ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
if ( Double . isInfinite ( norm2 ) || Double . isNaN ( norm2 ) ) { throw new OptimizationException ( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN , rows , cols ) ; }
public CardanEulerSingularityException ( boolean isCardan ) { super ( isCardan ? LocalizedFormats.CARDAN_ANGLES_SINGULARITY : LocalizedFormats.EULER_ANGLES_SINGULARITY ) ; }
if ( arrayDimension != expected ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , arrayDimension , expected ) ; }
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , n , startConfiguration.length ) ; }
if ( steps [ j ] == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX , j , j + NUMBER_CONSTANT ) ; }
{ if ( microsphereElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NON_POSITIVE_MICROSPHERE_ELEMENTS , microsphereElements ) ; } this . microsphereElements = elements ; }
{ if ( brightnessExponent < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_BRIGHTNESS_EXPONENT , brightnessExponent ) ; } this . brightnessExponent = brightnessExponent ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
throw new OptimizationException ( LocalizedFormats.UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH ) ;
if ( nRows == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.AT_LEAST_ONE_ROW ) ; }
if ( nCols == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.AT_LEAST_ONE_COLUMN ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_MEAN , mean ) ; }
if ( sigma <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_STANDARD_DEVIATION , sigma ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_POISSON_MEAN , mean ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_LENGTH , len ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_LENGTH , len ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
if ( Double . isInfinite ( norm2 ) || Double . isNaN ( norm2 ) ) { throw new EstimationException ( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN , rows , cols ) ; }
{ if ( sd <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_STANDARD_DEVIATION , sd ) ; } standardDeviation = sd ; }
if ( ( str = filePointer . readLine () ) == null ) { throw MathRuntimeException . createEOFException ( LocalizedFormats.URL_CONTAINS_NO_DATA , valuesFileURL ) ; }
if ( ( empiricalDistribution == null ) || ( empiricalDistribution . getBinStats () . size () == NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.DIGEST_NOT_INITIALIZED ) ; }
{ if ( newBeta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_BETA , newBeta ) ; } this . beta = newBeta ; }
{ if ( newAlpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_ALPHA , newAlpha ) ; } this . alpha = newAlpha ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( getN () > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC , getN () ) ; } }
catch ( InvalidMatrixException e ) { throw new EstimationException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( vector . getDimension () != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , vector . getDimension () , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( vector . getDimension () != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nCols ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_ITERATIONS_LIMITS , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_PLUS_ONE , f.length ) ; }
{ if ( size < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE , size ) ; } sampleSize = size ; }
{ if ( size <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_POPULATION_SIZE , size ) ; } populationSize = size ; }
{ if ( num < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_NUMBER_OF_SUCCESSES , num ) ; } numberOfSuccesses = num ; }
final Localizable pattern
if ( xval.length != yval.length ) { throw new MathException ( LocalizedFormats.MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS , xval.length , yval.length ) ; }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SCALE , s ) ; } scale = s ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optima . clone () ; }
Localizable pattern
Localizable pattern
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 ) ; }
throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR , obj . getClass () . getName () ) ;
catch ( ClassCastException cce ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FUNCTION_NOT_DIFFERENTIABLE ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( vector . getDimension () != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , vector . getDimension () , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( vector . getDimension () != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nCols ) ; }
{ if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.AT_LEAST_ONE_ROW ) ; } return d [ NUMBER_CONSTANT ] . getField () ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
{ throw new InvalidMatrixException ( LocalizedFormats.ASSYMETRIC_EIGEN_NOT_SUPPORTED ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
if ( p <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_POISSON_MEAN , p ) ; }
throw new NotARotationMatrixException ( LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX , i - NUMBER_CONSTANT ) ;
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS ) ; }
{ if ( BigInteger.ZERO . equals ( fraction.numerator ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; } return multiply ( fraction . reciprocal () ) ; }
if ( BigInteger.ZERO . equals ( bg ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
{ if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
if ( y0 * y1 >= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.SAME_SIGN_AT_ENDPOINTS , min , max , y0 , y1 ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_FORMAT_OBJECT_TO_FRACTION ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_WHOLE_FORMAT ) ; } this . wholeFormat = format ; }
{ super ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , dimension1 , dimension2 ) ; this . dimension1 = dimension1 ; this . dimension2 = dimension2 ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; } }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( trials < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_NUMBER_OF_TRIALS , trials ) ; } numberOfTrials = trials ; }
{ if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS , lower , initial , upper ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_RESULT_AVAILABLE ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
if ( f [ NUMBER_CONSTANT ] != NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FIRST_ELEMENT_NOT_ZERO , f [ NUMBER_CONSTANT ] ) ; }
{ if ( realFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_REAL_FORMAT ) ; } this . realFormat = realFormat ; }
{ if ( imaginaryFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_IMAGINARY_FORMAT ) ; } this . imaginaryFormat = imaginaryFormat ; }
if ( imaginaryCharacter == null || imaginaryCharacter . length () == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EMPTY_STRING_FOR_IMAGINARY_CHARACTER ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_COMPLEX , obj . getClass () . getName () ) ; }
catch ( ClassCastException ex ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES , v . getClass () . getName () ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CLASS_DOESNT_IMPLEMENT_COMPARABLE , v . getClass () . getName () ) ; }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N , n ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FRACTION ) ; }
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.OVERFLOW_IN_FRACTION , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
{ super ( LocalizedFormats.NON_SQUARE_MATRIX , rows , columns ) ; }
final Localizable specifier
if ( m <= p ) { throw new EstimationException ( LocalizedFormats.NO_DEGREES_OF_FREEDOM , m , p ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM ) ; }
if ( ++ costEvaluations > maxCostEval ) { throw new EstimationException ( LocalizedFormats.MAX_EVALUATIONS_EXCEEDED , maxCostEval ) ; }
{ if ( in [ i ] < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX , i , in [ i ] ) ; } }
{ if ( in [ i ] <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_ELEMENT_AT_INDEX , i , in [ i ] ) ; } }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_REAL_VECTOR , obj . getClass () . getName () ) ;
if ( Double . isNaN ( optima [ NUMBER_CONSTANT ] ) ) { throw new OptimizationException ( LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT , starts ) ; }
{ if ( optimaValues == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optimaValues . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optima . clone () ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , columns ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIFFERENT_ROWS_LENGTHS , columns , length ) ; }
catch ( InvalidMatrixException e ) { throw new OptimizationException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
if ( xval.length == NUMBER_CONSTANT || xval [ NUMBER_CONSTANT ] == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 ) ; }
catch ( IllegalAccessException e2 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD , SET_QUANTILE_METHOD_NAME , percentileImpl . getClass () . getName () ) ; }
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_WINDOW_SIZE , windowSize ) ; } }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_UPPER_BOUND , n ) ; }
if ( mean.length != standardDeviation.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , mean.length , standardDeviation.length ) ; }
{ throw MathRuntimeException . createArithmeticException ( LocalizedFormats.IDENTICAL_ABSCISSAS_DIVISION_BY_ZERO , i , k , x [ i ] ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.RANDOMKEY_MUTATION_WRONG_CLASS , original . getClass () . getSimpleName () ) ; }
throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED , n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( sum == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ARRAY_SUMS_TO_ZERO ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL , lower , upper ) ; } }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX , k , NUMBER_CONSTANT , omegaCount - NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX , k , NUMBER_CONSTANT , omegaCount - NUMBER_CONSTANT ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL , lower , upper ) ; } }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_FRACTION_NUMBER , source ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_FRACTION_NUMBER , source ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_COMPLEX_NUMBER , source ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL , lower , upper ) ; } }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_REAL_VECTOR , source ) ; }
catch ( NoSuchMethodException e1 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD , percentileImpl . getClass () . getName () , SET_QUANTILE_METHOD_NAME ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_3D_VECTOR , source ) ; }
public NotStrictlyPositiveException ( Number value ) { super ( value , NUMBER_CONSTANT , false ) ; }
public NotPositiveException ( Number value ) { super ( value , NUMBER_CONSTANT , true ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw new NoDataException () ; }
if ( x.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NUMBER_OF_POINTS , x.length , NUMBER_CONSTANT , true ) ; }
if ( x.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NUMBER_OF_POINTS , x.length , NUMBER_CONSTANT , true ) ; }
if ( mean.length != standardDeviation.length ) { throw new DimensionMismatchException ( mean.length , standardDeviation.length ) ; }
if ( n < NUMBER_CONSTANT ) { throw new NotStrictlyPositiveException ( n ) ; }
final double [] scale = new double [ mainSetDimension ] ;
{ super ( specific , LocalizedFormats.NO_DATA , ( Object [] ) null ) ; }
a [ i ] [ j ] [ k ] = aV [ i + N * ( j + N * k ) ]
{ return ( value == null ) ? null : value . clone () ; }
{ return ( point == null ) ? null : point . clone () ; }
super ( specific , boundIsAllowed ? LocalizedFormats.NUMBER_TOO_SMALL : LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED , wrong , min ) ;
( startConfiguration == null ) || ( startConfiguration.length != startPoint.length )
{ return ( point == null ) ? null : point . clone () ; }
public GoalType getGoalType () { return optimizationGoal ; }
{ throw new MatrixIndexException ( LocalizedFormats.ROW_INDEX_OUT_OF_RANGE , row , NUMBER_CONSTANT , getRowDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( LocalizedFormats.INDEX_OUT_OF_RANGE , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( LocalizedFormats.INDEX_OUT_OF_RANGE , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( LocalizedFormats.INDEX_OUT_OF_RANGE , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
public void remove () { throw MathRuntimeException . createUnsupportedOperationException ( LocalizedFormats.UNSUPPORTED_OPERATION ) ; }
{ super ( METHOD_NAME , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( METHOD_NAME , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
{ super ( METHOD_NAME , nSteps , nSteps , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( METHOD_NAME , nSteps , nSteps , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
if ( populationLimit < NUMBER_CONSTANT ) { throw new NotPositiveException ( LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE , populationLimit ) ; }
{ ret = addAndCheck ( a , - b , LocalizedFormats.OVERFLOW_IN_ADDITION ) ; }
if ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.OVERFLOW_IN_SUBTRACTION , x , y ) ; }
{ return addAndCheck ( a , b , LocalizedFormats.OVERFLOW_IN_ADDITION ) ; }
if ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.OVERFLOW_IN_ADDITION , x , y ) ; }
catch ( ArithmeticException ex ) { assertTrue ( ex . getMessage () . length () > NUMBER_CONSTANT ) ; }
{ this ( wrong , previous , index , MathUtils.OrderDirection.INCREASING , true ) ; }
if ( t == NUMBER_CONSTANT && i >= j ) continue;
arguments = ArgUtils . flatten ( args ) ;
public void remove () { throw new MathUnsupportedOperationException () ; }
if ( idxStep == NUMBER_CONSTANT ) { throw new ZeroException () ; }
if ( idxStep == NUMBER_CONSTANT ) { throw new ZeroException () ; }
if ( observations == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; }
if ( f == null ) { throw new NullArgumentException ( LocalizedFormats.FUNCTION ) ; }
{ if ( values == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( d == NUMBER_CONSTANT ) { throw new ZeroException () ; }
if ( d == NUMBER_CONSTANT ) { throw new ZeroException () ; }
if ( fraction == null ) { throw new NullArgumentException ( LocalizedFormats.FRACTION ) ; }
if ( fraction == null ) { throw new NullArgumentException ( LocalizedFormats.FRACTION ) ; }
if ( fraction == null ) { throw new NullArgumentException ( LocalizedFormats.FRACTION ) ; }
if ( f == null ) { throw new NullArgumentException ( LocalizedFormats.FUNCTION ) ; }
{ throw new DimensionMismatchException ( xArray.length , yArray.length ) ; }
if ( covarianceMatrix == null ) { throw new NullArgumentException ( LocalizedFormats.COVARIANCE_MATRIX ) ; }
{ if ( f == null ) { throw new NullArgumentException ( LocalizedFormats.FUNCTION ) ; } }
if ( function == null ) { throw new NullArgumentException ( LocalizedFormats.FUNCTION ) ; }
{ if ( values == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
final double [] grad = weightedResidualJacobian [ i ] ;
{ this ( cause , argument , new DummyLocalizable ( pattern ) , arguments ) ; }
{ this ( cause , argument , new DummyLocalizable ( pattern ) , arguments ) ; }
{ this ( argument , new DummyLocalizable ( pattern ) , arguments ) ; }
{ this ( argument , new DummyLocalizable ( pattern ) , arguments ) ; }
step *= FastMath . max ( NUMBER_CONSTANT , yA / yB )
return FastMath . sqrt ( sum / v.length ) ;
{ return FastMath . sqrt ( getChiSquare () / rows ) ; }
{ this . h = FastMath . abs ( h ) ; this . handler = handler ; reset () ; }
double invR3 = NUMBER_CONSTANT / ( r2 * FastMath . sqrt ( r2 ) ) ;
double expected = FastMath . random () ;
double expected = FastMath . random () ;
return FastMath . sqrt ( sum2 ) ;
final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , rows ) ;
final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , rows ) ;
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double t = FastMath . abs ( rValues . getEntry ( i , j ) ) / stdErrors . getEntry ( i , j ) ;
assertEquals ( n + STRING_CONSTANT + degree + STRING_CONSTANT + i , reference , result , NUMBER_CONSTANT * ( NUMBER_CONSTANT + FastMath . abs ( reference ) ) ) ;
NUMBER_CONSTANT * ( NUMBER_CONSTANT + Erf . erf ( ( x - mean ) / ( standardDeviation * FastMath . sqrt ( NUMBER_CONSTANT ) ) ) )
return FastMath . sqrt ( dx * dx + dy * dy ) ;
assertTrue ( FastMath . sqrt ( m.length ) * estimator . getRMS ( problem ) > NUMBER_CONSTANT ) ;
{ assertTrue ( FastMath . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
{ assertTrue ( FastMath . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
assertTrue ( FastMath . sqrt ( problem.target.length ) * optimizer . getRMS () > NUMBER_CONSTANT ) ;
{ sumLog += FastMath . log ( values [ i ] ) ; }
{ value += FastMath . log ( d ) ; n ++ ; }
{ ret = - mean * FastMath . log ( NUMBER_CONSTANT - p ) ; }
{ ret = NUMBER_CONSTANT - FastMath . exp ( - x / mean ) ; }
{ if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } return FastMath . exp ( - x / mean ) / mean ; }
{ sum += FastMath . abs ( p1 [ i ] - p2 [ i ] ) ; }
{ return ( FastMath . exp ( x ) - FastMath . exp ( - x ) ) / NUMBER_CONSTANT ; }
float factor = ( float ) FastMath . pow ( NUMBER_CONSTANT , scale ) * sign ;
final boolean isEqual = FastMath . abs ( xInt - yInt ) <= maxUlps ;
{ return equalsIncludingNaN ( x , y ) || ( FastMath . abs ( y - x ) <= eps ) ; }
{ return equals ( x , y , NUMBER_CONSTANT ) || FastMath . abs ( y - x ) <= eps ; }
{ return ( FastMath . exp ( x ) + FastMath . exp ( - x ) ) / NUMBER_CONSTANT ; }
return FastMath . floor ( result + NUMBER_CONSTANT ) ;
double mu = FastMath . random () ;
double x = NUMBER_CONSTANT / FastMath . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / FastMath . sqrt ( NUMBER_CONSTANT ) ;
double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ;
double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( n ) ;
{ double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ; return scaleArray ( fft ( f , true ) , scaling_coefficient ) ; }
double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ;
double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( n ) ;
{ double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ; return scaleArray ( fft ( f , false ) , scaling_coefficient ) ; }
{ return FastMath . atan2 ( getImaginary () , getReal () ) ; }
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
Assert . assertEquals ( STRING_CONSTANT , expected , result , FastMath . ulp ( NUMBER_CONSTANT ) ) ;
Assert . assertEquals ( STRING_CONSTANT , expected , result , FastMath . ulp ( NUMBER_CONSTANT ) ) ;
{ singularValues [ i ] = FastMath . sqrt ( FastMath . abs ( singularValues [ i ] ) ) ; }
{ result [ i ] = FastMath . sqrt ( sigma * betaVariance [ i ] [ i ] ) ; }
double fpos = FastMath . floor ( pos ) ;
final double dist = FastMath . abs ( z - x [ i ] ) ;
setMaxGrowth ( FastMath . pow ( NUMBER_CONSTANT , - exp ) ) ;
setMaxGrowth ( FastMath . pow ( NUMBER_CONSTANT , - exp ) ) ;
FastFourierTransformer . scaleArray ( x , FastMath . sqrt ( x.length / NUMBER_CONSTANT ) ) ;
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double tolerance = FastMath . max ( relativeAccuracy * z . abs () , absoluteAccuracy ) ;
int k = FastMath . max ( N , seed.length )
{ values [ i ] = FastMath . pow ( values [ i ] , d ) ; }
{ return ( m - mu ) / FastMath . sqrt ( v / n ) ; }
{ stepStart = Double.NaN ; stepSize = FastMath . sqrt ( minStep * maxStep ) ; }
{ assertEquals ( msg , expected , actual , FastMath . abs ( tolerance * actual ) ) ; }
Gamma . digamma ( FastMath . pow ( NUMBER_CONSTANT , - n ) )
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double range = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double range = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
double absAi = FastMath . abs ( coefficients [ i ] ) ;
{ ret = median + scale * FastMath . tan ( FastMath.PI * ( p - NUMBER_CONSTANT ) ) ; }
return ( NUMBER_CONSTANT / FastMath.PI ) * ( scale / ( dev * dev + scale * scale ) ) ;
final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , rows ) ;
final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , rows ) ;
{ stdDev [ i ] = FastMath . sqrt ( matrix . getEntry ( i , i ) ) ; }
( int ) ( FastMath . abs ( NUMBER_CONSTANT * x + NUMBER_CONSTANT * y ) ) % NUMBER_CONSTANT == NUMBER_CONSTANT
( int ) ( FastMath . abs ( NUMBER_CONSTANT * x + NUMBER_CONSTANT * y ) ) % NUMBER_CONSTANT == NUMBER_CONSTANT
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * FastMath . sqrt ( NUMBER_CONSTANT ) ) , sample . getStandardDeviation () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * FastMath . sqrt ( NUMBER_CONSTANT ) ) , sample . getStandardDeviation () , NUMBER_CONSTANT ) ;
if ( value != i ) { res += FastMath . abs ( value - i ) ; }
widthSufficient = FastMath . min ( lowerBinMass , upperBinMass ) * sampleSize >= minExpectedCount ;
return FastMath . sqrt ( criterion / wm.length ) ;
double factor = - FastMath . sqrt ( wm . getWeight () ) ;
{ assertTrue ( FastMath . abs ( value - expected ) < NUMBER_CONSTANT ) ; }
{ return FastMath . atan2 ( x , y ) ; }
{ return FastMath . pow ( x , y ) ; }
accum3 /= variance * FastMath . sqrt ( variance ) ;
( n0 * moment.m3 ) / ( ( n0 - NUMBER_CONSTANT ) * ( n0 - NUMBER_CONSTANT ) * FastMath . sqrt ( variance ) * variance )
assertEquals ( FastMath . exp ( NUMBER_CONSTANT ) , u . getGeometricMean () , NUMBER_CONSTANT ) ;
{ return FastMath . asin ( z / getNorm () ) ; }
{ return FastMath . atan2 ( y , x ) ; }
double x = FastMath . random () ;
assertTrue ( FastMath . abs ( generated [ NUMBER_CONSTANT ] - NUMBER_CONSTANT ) > NUMBER_CONSTANT ) ;
{ return new HarmonicFunction ( a * omega , omega , phi + FastMath.PI / NUMBER_CONSTANT ) ; }
{ return a * FastMath . cos ( omega * x + phi ) ; }
{ assertTrue ( FastMath . abs ( value - reference ) < NUMBER_CONSTANT ) ; }
long index = FastMath . round ( ( FastMath . random () ) * testArray.length ) ;
{ length = list . size () - FastMath . max ( NUMBER_CONSTANT , list . size () - windowSize ) ; }
double c = t2 + NUMBER_CONSTANT * ( FastMath . exp ( - NUMBER_CONSTANT * t2 ) - NUMBER_CONSTANT ) ;
double t = NUMBER_CONSTANT * FastMath.PI ;
double t = NUMBER_CONSTANT * FastMath.PI ;
assertEquals ( FastMath . sqrt ( NUMBER_CONSTANT ) , e1 . distanceFrom ( e2 ) , NUMBER_CONSTANT ) ;
error = FastMath . sqrt ( error / scale.length ) * errfac [ currentDegree - NUMBER_CONSTANT ] ;
double expected = FastMath . random () ;
double expected = FastMath . random () ;
final double power = FastMath . pow ( normalizedAbscissa , order ) ;
assertEquals ( FastMath . sqrt ( NUMBER_CONSTANT ) , Vector3D . distance ( v1 , v2 ) , NUMBER_CONSTANT ) ;
assertEquals ( FastMath . sqrt ( NUMBER_CONSTANT ) , new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getNorm () , NUMBER_CONSTANT ) ;
{ return FastMath . exp ( sumOfLogs . getResult () / sumOfLogs . getN () ) ; }
this . convergence = FastMath . abs ( convergence ) ;
final int capacity = ( int ) FastMath . ceil ( expectedSize / LOAD_FACTOR ) ;
double fl = FastMath . floor ( x ) ;
{ return cumulativeProbability ( ( int ) FastMath . floor ( x ) ) ; }
{ assertTrue ( FastMath . abs ( value - reference ) < NUMBER_CONSTANT ) ; }
{ double absError = FastMath . abs ( expected ) * relativeError ; Assert . assertEquals ( msg , expected , actual , absError ) ; }
return - mean * FastMath . log ( unif ) ;
double sigma = FastMath . sqrt ( mean ) ;
if ( FastMath . abs ( x1 - x0 ) <= absoluteAccuracy ) { setResult ( x1 , i ) ; return x1 ; }
double delta = FastMath . abs ( getEntry ( i ) - v [ i ] ) ;
{ double delta = FastMath . abs ( getEntry ( i ) - v [ i ] ) ; max += delta ; }
return FastMath . sqrt ( res ) ;
return FastMath . sqrt ( res ) ;
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
{ assertTrue ( FastMath . abs ( value - expected ) < NUMBER_CONSTANT ) ; }
new Fraction ( FastMath.PI , NUMBER_CONSTANT )
{ new Fraction ( ( NUMBER_CONSTANT + FastMath . sqrt ( NUMBER_CONSTANT ) ) / NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
max = FastMath . max ( max , FastMath . abs ( delta ) ) ;
max = FastMath . max ( max , FastMath . abs ( delta ) ) ;
{ final double delta = data [ i ] - v [ i ] ; sum += FastMath . abs ( delta ) ; }
sum += FastMath . abs ( delta ) ;
return FastMath . sqrt ( sum ) ;
return FastMath . sqrt ( sum ) ;
for ( double a : data ) { max = FastMath . max ( max , FastMath . abs ( a ) ) ; }
for ( double a : data ) { sum += FastMath . abs ( a ) ; }
return FastMath . sqrt ( sum ) ;
{ data [ i ] = FastMath . ulp ( data [ i ] ) ; }
{ data [ i ] = FastMath . signum ( data [ i ] ) ; }
{ data [ i ] = FastMath . rint ( data [ i ] ) ; }
{ data [ i ] = FastMath . floor ( data [ i ] ) ; }
{ data [ i ] = FastMath . ceil ( data [ i ] ) ; }
{ data [ i ] = FastMath . cbrt ( data [ i ] ) ; }
{ data [ i ] = FastMath . sqrt ( data [ i ] ) ; }
{ data [ i ] = FastMath . abs ( data [ i ] ) ; }
{ data [ i ] = FastMath . atan ( data [ i ] ) ; }
{ data [ i ] = FastMath . asin ( data [ i ] ) ; }
{ data [ i ] = FastMath . acos ( data [ i ] ) ; }
{ data [ i ] = FastMath . tan ( data [ i ] ) ; }
{ data [ i ] = FastMath . sin ( data [ i ] ) ; }
{ data [ i ] = FastMath . cos ( data [ i ] ) ; }
{ data [ i ] = FastMath . tanh ( data [ i ] ) ; }
{ data [ i ] = FastMath . sinh ( data [ i ] ) ; }
{ data [ i ] = FastMath . cosh ( data [ i ] ) ; }
{ data [ i ] = FastMath . log1p ( data [ i ] ) ; }
{ data [ i ] = FastMath . log10 ( data [ i ] ) ; }
{ data [ i ] = FastMath . log ( data [ i ] ) ; }
{ data [ i ] = FastMath . expm1 ( data [ i ] ) ; }
{ data [ i ] = FastMath . exp ( data [ i ] ) ; }
{ data [ i ] = FastMath . pow ( data [ i ] , d ) ; }
final double inv = NUMBER_CONSTANT / FastMath . sqrt ( norm2 ) ;
{ if ( FastMath . abs ( value - searchArray [ i ] ) < tolerance ) { found = true ; } i ++ ; }
this . step = FastMath . abs ( step ) ;
final int p = FastMath . min ( m , n ) ;
double range = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double range = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
{ return ( int ) FastMath . min ( randomData . nextPoisson ( mean ) , Integer.MAX_VALUE ) ; }
normal . setStandardDeviation ( FastMath . sqrt ( p ) ) ;
if ( unequalCounts ) { weight = FastMath . sqrt ( ( double ) countSum1 / ( double ) countSum2 ) ; }
if ( FastMath . abs ( sumExpected - sumObserved ) > NUMBER_CONSTANT ) { ratio = sumObserved / sumExpected ; rescale = true ; }
final double s17 = FastMath . sqrt ( NUMBER_CONSTANT ) ;
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
{ norm = FastMath . max ( norm , FastMath . abs ( e . getValue () ) ) ; }
return FastMath . sqrt ( sum ) ;
return FastMath . sqrt ( d ) ;
return FastMath . sqrt ( dx * dx + dy * dy ) ;
return a * FastMath . cos ( omega * x + phi ) ;
final double f = NUMBER_CONSTANT / FastMath . sqrt ( normSq ) ;
{ if ( getN () > NUMBER_CONSTANT ) { stdDev = FastMath . sqrt ( getVariance () ) ; } else { stdDev = NUMBER_CONSTANT ; } }
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
assertTrue ( FastMath . abs ( h ) < minStep ) ;
double maxStep = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
{ if ( getN () > NUMBER_CONSTANT ) { stdDev = FastMath . sqrt ( getVariance () ) ; } else { stdDev = NUMBER_CONSTANT ; } }
double [] y0 = { FastMath . sin ( a ) , FastMath . cos ( a ) } ;
new double [] { - FastMath . sqrt ( NUMBER_CONSTANT ) , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT }
{ new BigReal ( NUMBER_CONSTANT ) , BigReal.ONE , BigReal.ZERO , new BigReal ( NUMBER_CONSTANT ) , new BigReal ( FastMath.PI ) , new BigReal ( - NUMBER_CONSTANT ) }
if ( deltaNorm > NUMBER_CONSTANT * FastMath . max ( NUMBER_CONSTANT , initialNorm ) ) { return false ; }
assertEquals ( FastMath.PI , MathUtils . scalb ( FastMath.PI , NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
MathUtils . hash ( new double [] { FastMath . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) } )
assertEquals ( i + STRING_CONSTANT , FastMath . log ( factorial ( i ) ) , MathUtils . factorialLog ( i ) , NUMBER_CONSTANT ) ;
new double [] { FastMath . nextAfter ( FastMath . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT ) }
MathUtils . equals ( new double [] { NUMBER_CONSTANT } , new double [] { FastMath . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) } )
ret = FastMath . exp ( p1 + p2 - p3 ) ;
{ return FastMath . min ( k , m ) ; }
{ return FastMath . max ( NUMBER_CONSTANT , m - ( n - k ) ) ; }
{ return NUMBER_CONSTANT * ( NUMBER_CONSTANT - distribution . cumulativeProbability ( FastMath . abs ( getSlope () ) / getSlopeStdErr () ) ) ; }
{ return FastMath . sqrt ( getMeanSquareError () / sumXX ) ; }
double result = FastMath . sqrt ( getRSquare () ) ;
if ( FastMath . abs ( sumXX ) < NUMBER_CONSTANT * Double.MIN_VALUE ) { return Double.NaN ; }
@ Override public double value ( double d ) { return FastMath . ulp ( d ) ; }
@ Override public double value ( double d ) { return FastMath . signum ( d ) ; }
@ Override public double value ( double d ) { return FastMath . rint ( d ) ; }
@ Override public double value ( double d ) { return FastMath . cosh ( d ) ; }
@ Override public double value ( double d ) { return FastMath . acos ( d ) ; }
@ Override public double value ( double d ) { return FastMath . cos ( d ) ; }
@ Override public double value ( double d ) { return FastMath . log10 ( d ) ; }
@ Override public double value ( double d ) { return FastMath . log ( d ) ; }
@ Override public double value ( double d ) { return FastMath . floor ( d ) ; }
@ Override public double value ( double d ) { return FastMath . ceil ( d ) ; }
@ Override public double value ( double d ) { return FastMath . cbrt ( d ) ; }
@ Override public double value ( double d ) { return FastMath . tanh ( d ) ; }
@ Override public double value ( double d ) { return FastMath . tan ( d ) ; }
@ Override public double value ( double d ) { return FastMath . atan ( d ) ; }
@ Override public double value ( double d ) { return FastMath . asin ( d ) ; }
@ Override public double value ( double d ) { return FastMath . expm1 ( d ) ; }
@ Override public double value ( double d ) { return FastMath . exp ( d ) ; }
@ Override public double value ( double d ) { return FastMath . sinh ( d ) ; }
@ Override public double value ( double d ) { return FastMath . sqrt ( d ) ; }
@ Override public double value ( double d ) { return FastMath . sin ( d ) ; }
@ Override public double value ( double d ) { return FastMath . abs ( d ) ; }
new BigFraction ( FastMath.PI , NUMBER_CONSTANT )
{ new BigFraction ( ( NUMBER_CONSTANT + FastMath . sqrt ( NUMBER_CONSTANT ) ) / NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
FastFourierTransformer . scaleArray ( x , FastMath . sqrt ( NUMBER_CONSTANT * ( x.length - NUMBER_CONSTANT ) ) ) ;
double c = FastMath . exp ( t0 - t ) ;
assertEquals ( NUMBER_CONSTANT , FastMath . sqrt ( circle . getN () ) * optimizer . getRMS () , NUMBER_CONSTANT ) ;
{ product *= FastMath . pow ( values [ i ] , weights [ i ] ) ; }
FastFourierTransformer . scaleArray ( x2 , NUMBER_CONSTANT / FastMath . sqrt ( x2.length ) ) ;
assertNotSame ( v , new ArrayRealVector ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT + FastMath . ulp ( NUMBER_CONSTANT ) } ) ) ;
double scaling_coefficient = FastMath . sqrt ( NUMBER_CONSTANT / ( n - NUMBER_CONSTANT ) ) ;
double scaling_coefficient = FastMath . sqrt ( NUMBER_CONSTANT / ( f.length - NUMBER_CONSTANT ) ) ;
if ( FastMath . abs ( fn1 - fn ) <= threshold ) return o ;
assertNotSame ( v , new OpenMapRealVector ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT + FastMath . ulp ( NUMBER_CONSTANT ) } ) ) ;
FastMath . sin ( i * FastMath.PI / n ) * ( f [ i ] + f [ n - i ] )
double scaling_coefficient = FastMath . sqrt ( NUMBER_CONSTANT / n ) ;
{ double scaling_coefficient = FastMath . sqrt ( NUMBER_CONSTANT / f.length ) ; return FastFourierTransformer . scaleArray ( fst ( f ) , scaling_coefficient ) ; }
double tmp2 = FastMath . exp ( tmp1 ) ;
double tmp2 = FastMath . sqrt ( tmpSquare ) ;
double absTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
FastMath . abs ( max - min ) <= absoluteAccuracy
assertEquals ( ci , l40 [ i ] , FastMath . abs ( ci ) * NUMBER_CONSTANT ) ;
FastMath . abs ( Tk . value ( x ) ) < ( NUMBER_CONSTANT + NUMBER_CONSTANT )
double tmp2 = FastMath . exp ( tmp1 ) ;
double tmp2 = FastMath . sqrt ( tmpSquare ) ;
assertEquals ( mi , vi , paramsAccuracy * ( NUMBER_CONSTANT + FastMath . abs ( mi ) ) ) ;
assertEquals ( theoreticalMinCost , FastMath . sqrt ( m ) * rms , threshold ) ;
{ assertTrue ( FastMath . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
final int capacity = ( int ) FastMath . ceil ( expectedSize / LOAD_FACTOR ) ;
@ Override public double getResult () { return FastMath . sqrt ( variance . getResult () ) ; }
j < FastMath . min ( i + NUMBER_CONSTANT , n )
int row = FastMath . min ( m , n ) - NUMBER_CONSTANT
catch ( ConvergenceException e ) { assertTrue ( ( ! solvable ) && ( degree > NUMBER_CONSTANT ) ) ; }
ConvergenceChecker < RealPointValuePair > convergenceChecker
public GoalType getGoalType () { return goal ; }
assertEquals ( NUMBER_CONSTANT , sum . getResult () , NUMBER_CONSTANT ) ;
@ Override public void clear () { value = NUMBER_CONSTANT ; n = NUMBER_CONSTANT ; }
assertEquals ( NUMBER_CONSTANT , sumSq . getResult () , NUMBER_CONSTANT ) ;
@ Override public void clear () { value = NUMBER_CONSTANT ; n = NUMBER_CONSTANT ; }
@ Override public void clear () { value = NUMBER_CONSTANT ; n = NUMBER_CONSTANT ; }
assertEquals ( NUMBER_CONSTANT , product . getResult () , NUMBER_CONSTANT ) ;
{ return NUMBER_CONSTANT + ( sign < < NUMBER_CONSTANT ) + ( nans < < NUMBER_CONSTANT ) + exp + Arrays . hashCode ( mant ) ; }
@ Override protected int getNumberOfRegressors () { return x [ NUMBER_CONSTANT ] . length + NUMBER_CONSTANT ; }
@ Override protected int getNumberOfRegressors () { return x [ NUMBER_CONSTANT ] . length + NUMBER_CONSTANT ; }
final boolean isMinim = getGoalType () == GoalType.MINIMIZE ;
public Well44497b ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497b ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497b () { super ( K , M1 , M2 , M3 ) ; }
public Well19937c ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937c ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937c () { super ( K , M1 , M2 , M3 ) ; }
v [ indexRm2 ] &= NUMBER_CONSTANT ;
v [ indexRm2 ] &= NUMBER_CONSTANT ;
v [ indexRm2 ] &= NUMBER_CONSTANT ;
v [ indexRm2 ] &= NUMBER_CONSTANT ;
if ( v.length != rows ) { throw new DimensionMismatchException ( v.length , rows ) ; }
if ( v.length != columns ) { throw new DimensionMismatchException ( v.length , columns ) ; }
if ( length != columns ) { throw new DimensionMismatchException ( columns , length ) ; }
{ super ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ; dimension = expected ; }
if ( v.length != rows ) { throw new DimensionMismatchException ( v.length , rows ) ; }
if ( v.length != columns ) { throw new DimensionMismatchException ( v.length , columns ) ; }
if ( length != columns ) { throw new DimensionMismatchException ( columns , length ) ; }
if ( v . getDimension () != nRows ) { throw new DimensionMismatchException ( v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw new DimensionMismatchException ( v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw new DimensionMismatchException ( v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw new DimensionMismatchException ( v.length , nCols ) ; }
dist = new PoissonDistributionImpl ( NUMBER_CONSTANT ) ;
{ this ( p , DEFAULT_EPSILON , DEFAULT_MAX_ITERATIONS ) ; }
distribution = new ChiSquaredDistributionImpl ( df ) ;
{ distribution = new ChiSquaredDistributionImpl ( expected.length - NUMBER_CONSTANT ) ; return NUMBER_CONSTANT - distribution . cumulativeProbability ( chiSquare ( expected , observed ) ) ; }
double density ( double x ) ;
( FastMath . max ( FastMath . abs ( mij ) , FastMath . abs ( mji ) ) * eps )
FDistributionImpl fd = new FDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( n > NUMBER_CONSTANT ) { distribution = new TDistributionImpl ( n - NUMBER_CONSTANT ) ; }
if ( n > NUMBER_CONSTANT ) { distribution = new TDistributionImpl ( n - NUMBER_CONSTANT ) ; }
@ SuppressWarnings ( STRING_CONSTANT ) private RandomAdaptor () { randomGenerator = null ; }
return a . dotrap ( DfpField.FLAG_INVALID , STRING_CONSTANT , a , a . newInstance ( ( byte ) NUMBER_CONSTANT , Dfp.QNAN ) ) ;
if ( ia > NUMBER_CONSTANT ) { return a . newInstance ( ( byte ) NUMBER_CONSTANT , Dfp.INFINITE ) ; }
public int [] getSizes () { return copyOf ( size , dimension ) ; }
this . size = copyOf ( size , dimension ) ;
public int [] getCounts () { return copyOf ( counter , dimension ) ; }
final double [] d = copyOf ( direc [ i ] , n ) ;
{ try { new ExponentialDistributionImpl ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( NotStrictlyPositiveException e ) {} }
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ UnivariateRealSolverUtils . solve ( sin , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
zb += za - temp2 ;
if ( v . getDimension () != nRows ) { throw new DimensionMismatchException ( v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw new DimensionMismatchException ( v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw new DimensionMismatchException ( v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw new DimensionMismatchException ( v.length , nCols ) ; }
{ setQuantile ( p ) ; cachedPivots = null ; }
{ this ( n , NUMBER_CONSTANT ) ; }
public MultiDirectionalSimplex ( final int n ) { this ( n , NUMBER_CONSTANT ) ; }
try { es . getInverse () ; fail ( STRING_CONSTANT ) ; } catch ( SingularMatrixException ime ) {}
{ this ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , wrong , expected ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
@ Test ( expected = NonSymmetricMatrixException . class )
catch ( NonSquareMatrixException ime ) {}
public LaguerreSolver () { super ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ return MessageFactory . buildMessage ( locale , specific , general , arguments ) ; }
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
try { finalizeStep () ; } catch ( MathUserException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { finalizeStep () ; } catch ( MathUserException e ) { throw MathRuntimeException . createIOException ( e ) ; }
{ try { return mapToSelf ( ComposableFunction.ULP ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TANH ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TAN ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SQRT ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SINH ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIN ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIGNUM ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.RINT ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
try { return mapToSelf ( BinaryFunction.POW . fix2ndArgument ( d ) ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; }
try { return mapToSelf ( BinaryFunction.MULTIPLY . fix1stArgument ( d ) ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; }
{ try { return mapToSelf ( ComposableFunction.LOG1P ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG10 ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.INVERT ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.FLOOR ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXPM1 ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXP ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
try { return mapToSelf ( BinaryFunction.DIVIDE . fix2ndArgument ( d ) ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; }
{ try { return mapToSelf ( ComposableFunction.COSH ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.COS ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CEIL ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CBRT ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ATAN ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ACOS ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ABS ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ return f . value ( x , y ) ; }
CircleVectorial circle = new CircleVectorial () ;
CircleVectorial circle = new CircleVectorial () ;
CircleVectorial circle = new CircleVectorial () ;
NumberIsTooLargeException ex
assertEquals ( NUMBER_CONSTANT , handler . getMaximalValueError () , NUMBER_CONSTANT ) ;
public RealVector mapPowToSelf ( double d ) { return mapToSelf ( new Power ( d ) ) ; }
{ if ( d != NUMBER_CONSTANT ) { return mapToSelf ( FunctionUtils . fix2ndArgument ( new Add () , d ) ) ; } return this ; }
{ if ( ++ iterations > maxIterations ) { throw new OptimizationException ( new MaxCountExceededException ( maxIterations ) ) ; } }
throw new MaxCountExceededException ( maximalIterationCount ) ;
{ throw new MaxCountExceededException ( maxIterations ) ; }
if ( n >= maxIterations ) { throw new MaxCountExceededException ( LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION , maxIterations , x ) ; }
if ( dimension == NUMBER_CONSTANT ) { throw new NumberIsTooLargeException ( LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE , minSingularValue , singularValues [ NUMBER_CONSTANT ] , true ) ; }
{ return solve ( DEFAULT_MAX_EVALUATIONS , f , startValue ) ; }
StringBuilder buffer
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder msgBuffer = new StringBuilder () ;
StringBuilder out = new StringBuilder ( msg ) ;
StringBuilder messageBuffer = new StringBuilder () ;
StringBuilder s = new StringBuilder () ;
final StringBuilder buff = new StringBuilder ( STRING_CONSTANT ) ;
StringBuilder msgBuffer = new StringBuilder () ;
StringBuilder sb = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
Assert . assertEquals ( FastMath.PI , solver . solve ( NUMBER_CONSTANT , f , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , solver . getAbsoluteAccuracy () ) ;
result = solver . solve ( NUMBER_CONSTANT , f , min , max ) ;
{ this ( new SimpleVectorialValueChecker () ) ; }
{ this ( new SimpleScalarValueChecker () ) ; }
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw new OutOfRangeException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x1 < x0 ) { throw new NumberIsTooSmallException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x1 , x0 , true ) ; }
if ( x1 < x0 ) { throw new NumberIsTooSmallException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x1 , x0 , true ) ; }
catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
catch ( NullArgumentException ex ) {}
catch ( NullArgumentException ex ) {}
catch ( NullArgumentException ex ) {}
try { m . preMultiply ( new BlockRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . multiply ( new BlockRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . subtract ( new BlockRealMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
{ if ( a < NUMBER_CONSTANT ) { ret = a - b ; } else { throw new MathArithmeticException ( msg ) ; } }
try { optimizer . getOptima () ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalStateException ise ) {}
{ if ( numerator == Integer.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW_IN_FRACTION , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
{ try { UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {} }
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
if ( begin + length > values.length ) { throw new NumberIsTooLargeException ( LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END , begin + length , values.length , true ) ; }
try { m . preMultiply ( new Array2DRowRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . multiply ( new Array2DRowRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . subtract ( new Array2DRowRealMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . min ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . max ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . mean ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
{ NumberFormat f = CompositeFormat . getDefaultNumberFormat ( locale ) ; return new ComplexFormat ( f ) ; }
public ComplexFormat ( String imaginaryCharacter ) { this ( imaginaryCharacter , CompositeFormat . getDefaultNumberFormat () ) ; }
{ return new Vector3DFormat ( CompositeFormat . getDefaultNumberFormat ( locale ) ) ; }
if ( ! found ) { Assert . fail ( msg + STRING_CONSTANT + ( new ComplexFormat () ) . format ( z ) ) ; }
CompositeFormat . formatDouble ( vector . getEntry ( i ) , format , toAppendTo , pos ) ;
{ return new RealVectorFormat ( CompositeFormat . getDefaultNumberFormat ( locale ) ) ; }
Class < > type
{ this ( imaginaryCharacter , format , format ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( s == NUMBER_CONSTANT ) { throw new MathArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
throw new MathInternalError () ;
throw new MathInternalError () ;
try { alg = MessageDigest . getInstance ( STRING_CONSTANT ) ; } catch ( NoSuchAlgorithmException ex ) { throw new MathInternalError ( ex ) ; }
denseOutput = requiresDenseOutput () || ( ! eventsStates . isEmpty () ) ;
{ super . addStepHandler ( handler ) ; denseOutput = requiresDenseOutput () || ( ! eventsStates . isEmpty () ) ; initializeArrays () ; }
denseOutput = requiresDenseOutput () || ( ! eventsStates . isEmpty () ) ;
denseOutput = requiresDenseOutput () || ( ! eventsStates . isEmpty () ) ;
stepStart = acceptStep ( interpolator , y , yDot , t ) ;
stepStart = acceptStep ( interpolator , y , yDot , t ) ;
final double temp = sinEpsA * HEX_40000000 ;
final double tmp = hiPrec [ NUMBER_CONSTANT ] * HEX_40000000 ;
if ( x >= TWO_POWER_52 || x <= - TWO_POWER_52 ) { return x ; }
final double epsilon = xa - EIGHTHS [ idx ] ;
final double epsilon = xa - EIGHTHS [ idx ] ;
final boolean fatal = true ;
final boolean fatal = false ;
if ( invx == NUMBER_CONSTANT ) { if ( x > NUMBER_CONSTANT ) { return y ; } else { return copySign ( Math.PI , y ) ; } }
if ( xa == NUMBER_CONSTANT ) { return leftPlane ? copySign ( Math.PI , xa ) : xa ; }
@ Ignore
{ return ( int ) floor ( x + NUMBER_CONSTANT ) ; }
final double [] d = MathUtils . copyOf ( direc [ i ] ) ;
public int [] getSizes () { return MathUtils . copyOf ( size ) ; }
this . size = MathUtils . copyOf ( size ) ;
public int [] getCounts () { return MathUtils . copyOf ( counter ) ; }
{ return ONE_WAY_ANANOVA . anovaTest ( categoryData , alpha ) ; }
{ return ONE_WAY_ANANOVA . anovaPValue ( categoryData ) ; }
{ return ONE_WAY_ANANOVA . anovaFValue ( categoryData ) ; }
{ return UNKNOWN_DISTRIBUTION_CHI_SQUARE_TEST . chiSquareTestDataSetsComparison ( observed1 , observed2 , alpha ) ; }
{ return UNKNOWN_DISTRIBUTION_CHI_SQUARE_TEST . chiSquareTestDataSetsComparison ( observed1 , observed2 ) ; }
{ return UNKNOWN_DISTRIBUTION_CHI_SQUARE_TEST . chiSquareDataSetsComparison ( observed1 , observed2 ) ; }
{ return CHI_SQUARE_TEST . chiSquareTest ( counts ) ; }
{ return CHI_SQUARE_TEST . chiSquareTest ( counts , alpha ) ; }
{ return CHI_SQUARE_TEST . chiSquareTest ( expected , observed ) ; }
{ return CHI_SQUARE_TEST . chiSquareTest ( expected , observed , alpha ) ; }
{ return CHI_SQUARE_TEST . chiSquare ( counts ) ; }
{ return CHI_SQUARE_TEST . chiSquare ( expected , observed ) ; }
{ return T_TEST . tTest ( sampleStats1 , sampleStats2 ) ; }
{ return T_TEST . tTest ( sampleStats1 , sampleStats2 , alpha ) ; }
{ return T_TEST . tTest ( sample1 , sample2 ) ; }
{ return T_TEST . tTest ( sample1 , sample2 , alpha ) ; }
{ return T_TEST . tTest ( mu , sampleStats ) ; }
{ return T_TEST . tTest ( mu , sampleStats , alpha ) ; }
{ return T_TEST . tTest ( mu , sample ) ; }
{ return T_TEST . tTest ( mu , sample , alpha ) ; }
{ return T_TEST . t ( sampleStats1 , sampleStats2 ) ; }
{ return T_TEST . t ( sample1 , sample2 ) ; }
{ return T_TEST . t ( mu , sampleStats ) ; }
{ return T_TEST . t ( mu , observed ) ; }
{ return T_TEST . pairedTTest ( sample1 , sample2 ) ; }
{ return T_TEST . pairedTTest ( sample1 , sample2 , alpha ) ; }
{ return T_TEST . pairedT ( sample1 , sample2 ) ; }
{ return T_TEST . homoscedasticTTest ( sampleStats1 , sampleStats2 ) ; }
{ return T_TEST . homoscedasticTTest ( sample1 , sample2 ) ; }
{ return T_TEST . homoscedasticTTest ( sample1 , sample2 , alpha ) ; }
{ return T_TEST . homoscedasticT ( sampleStats1 , sampleStats2 ) ; }
{ return T_TEST . homoscedasticT ( sample1 , sample2 ) ; }
RealMatrix arzneg = selectColumns ( arz , MathUtils . copyOf ( arReverseIndex , mu ) ) ;
double numer = bits & NUMBER_CONSTANT ;
ParametricUnivariateRealFunction sif = new SimpleInverseFunction () ;
ParametricUnivariateRealFunction sif = new SimpleInverseFunction () ;
final ParametricUnivariateRealFunction f
final ParametricUnivariateRealFunction f
final ParametricUnivariateRealFunction f
final double g = Gaussian . value ( diff , norm , i2s2 ) ;
{ super ( optimizer ) ; ; }
final boolean fatal = true ;
{ this ( specific , LocalizedFormats.ILLEGAL_STATE , args ) ; }
{ super ( null , specific , general , args ) ; }
{ super ( null , null , LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
Assert . assertEquals ( reference , p . multiply ( q ) . toString () ) ;
oneOverN = NUMBER_CONSTANT / n ;
return _isMinimize ? penalty : - penalty ;
if ( _boundaries == null ) return true ;
return isMinimize ? penalty : - penalty ;
if ( boundaries == null ) return true ;
final FitnessFunction fitfun = new FitnessFunction () ;
if ( result == - NUMBER_CONSTANT ) { throw new MathArithmeticException () ; }
catch ( IOException ioe ) {}
super ( specific , lo , hi , fLo , fHi , args ) ;
{ this ( LocalizedFormats.SAME_SIGN_AT_ENDPOINTS , lo , hi , fLo , fHi ) ; }
{ super ( specific , null ) ; }
super ( specific , wrong , max ) ;
{ this ( boundIsAllowed ? LocalizedFormats.NUMBER_TOO_LARGE : LocalizedFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED , wrong , max , boundIsAllowed ) ; }
{ super ( specific , wrong , lo , hi ) ; this . lo = lo ; this . hi = hi ; }
{ this ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , wrong , lo , hi ) ; }
super ( specific , wrong , expected ) ;
{ this ( LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ; }
{ super ( specific , wrong , expected ) ; dimension = expected ; }
public ZeroException ( Localizable specific ) { super ( specific , NUMBER_CONSTANT ) ; }
super ( specific , wrong , min ) ;
{ this ( boundIsAllowed ? LocalizedFormats.NUMBER_TOO_SMALL : LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED , wrong , min , boundIsAllowed ) ; }
{ super ( specific , wrong , args ) ; }
{ this ( LocalizedFormats.NOT_FINITE_NUMBER , wrong , args ) ; }
public MathInternalError ( final Throwable cause ) { super ( cause , LocalizedFormats.INTERNAL_ERROR , REPORT_URL ) ; }
{ ++ count ; Assert . assertEquals ( i + j / NUMBER_CONSTANT , value , NUMBER_CONSTANT ) ; }
{ ++ count ; Assert . assertEquals ( i + j / NUMBER_CONSTANT , value , NUMBER_CONSTANT ) ; }
{ Assert . assertEquals ( NUMBER_CONSTANT , l . getEntry ( i , j ) , NUMBER_CONSTANT ) ; }
{ Assert . assertEquals ( NUMBER_CONSTANT , m . getEntry ( i , j ) , NUMBER_CONSTANT ) ; }
@ Override protected void doFinalize ( ) throws MathUserException { throw new MathUserException () ; }
@ Override protected void doFinalize ( ) throws MathUserException { throw new MathUserException ( LocalizedFormats.SIMPLE_MESSAGE , STRING_CONSTANT ) ; }
catch ( IOException ioe ) { assertEquals ( NUMBER_CONSTANT , ioe . getMessage () . length () ) ; }
{ super ( cause ) ; addMessage ( LocalizedFormats.USER_EXCEPTION ) ; }
double sum = NUMBER_CONSTANT ;
Assert . assertEquals ( STRING_CONSTANT , s . getN () , u . getN () ) ;
@ Before
{ Assert . assertEquals ( a1 , MathUtils . normalizeAngle ( a2 , a1 ) , NUMBER_CONSTANT ) ; }
@ After public void tearDown () { refValues = null ; matrix = null ; }
@ Before
@ Before
@ Before public void setUp () { f = new Frequency () ; }
@ After public void tearDown () { pb = null ; integ = null ; }
@ Before
Assert . assertTrue ( bestFinal . compareTo ( bestInitial ) > NUMBER_CONSTANT ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertTrue ( Double . isNaN ( statistic . getResult () ) ) ; }
{ double [] [] variance = regression . estimateRegressionParametersVariance () ; Assert . assertEquals ( getNumberOfRegressors () , variance.length ) ; }
{ double [] e = regression . estimateResiduals () ; Assert . assertEquals ( getSampleSize () , e.length ) ; }
{ double [] beta = regression . estimateRegressionParameters () ; Assert . assertEquals ( getNumberOfRegressors () , beta.length ) ; }
{ FractionField field = FractionField . getInstance () ; Assert . assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { Assert . assertEquals ( Fraction.ONE , FractionField . getInstance () . getOne () ) ; }
@ Test public void testZero () { Assert . assertEquals ( Fraction.ZERO , FractionField . getInstance () . getZero () ) ; }
{ try { new DummyBinaryChromosome ( repr ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException e ) {} }
Assert . assertEquals ( c3 , population . getFittestChromosome () ) ;
{ BigRealField field = BigRealField . getInstance () ; Assert . assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { Assert . assertEquals ( BigReal.ONE , BigRealField . getInstance () . getOne () ) ; }
@ Test public void testZero () { Assert . assertEquals ( BigReal.ZERO , BigRealField . getInstance () . getZero () ) ; }
Assert . assertEquals ( p , TestUtils . serializeAndRecover ( p ) ) ;
Assert . assertEquals ( STRING_CONSTANT , s . getN () , u . getN () ) ;
Assert . assertEquals ( expected . getN () , observed . getN () ) ;
{ Assert . assertEquals ( y [ i ] , iResult [ i ] ) ; }
Assert . assertTrue ( FastMath . abs ( h ) < minStep ) ;
{ DummyRandomKey drk = new DummyRandomKey ( RandomKey . randomPermutation ( NUMBER_CONSTANT ) ) ; Assert . assertNotNull ( drk ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , nextGeneration . getPopulationSize () ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( STRING_CONSTANT + p , expected , actual , NUMBER_CONSTANT ) ;
Assert . assertEquals ( STRING_CONSTANT + x , expected , actual , NUMBER_CONSTANT ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
@ After public void tearDown () { pb = null ; integ = null ; }
@ Before
{ BigFractionField field = BigFractionField . getInstance () ; Assert . assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { Assert . assertEquals ( BigFraction.ONE , BigFractionField . getInstance () . getOne () ) ; }
@ Test public void testZero () { Assert . assertEquals ( BigFraction.ZERO , BigFractionField . getInstance () . getZero () ) ; }
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( approYDot , yDot [ i ] , threshold ) ;
{ ComplexField field = ComplexField . getInstance () ; Assert . assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { Assert . assertEquals ( Complex.ONE , ComplexField . getInstance () . getOne () ) ; }
@ Test public void testZero () { Assert . assertEquals ( Complex.ZERO , ComplexField . getInstance () . getZero () ) ; }
if ( isLast ) { Assert . assertTrue ( maxError > NUMBER_CONSTANT ) ; }
@ Before public void setUp () { tooShortStats = new SummaryStatistics () ; tooShortStats . addValue ( NUMBER_CONSTANT ) ; }
Assert . assertTrue ( maxError < NUMBER_CONSTANT ) ;
if ( isLast ) { Assert . assertTrue ( maxError > NUMBER_CONSTANT ) ; }
if ( isLast ) { Assert . assertTrue ( maxError > NUMBER_CONSTANT ) ; }
{ if ( column < row ) { Assert . assertEquals ( NUMBER_CONSTANT , value , entryTolerance ) ; } }
Assert . assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
Assert . assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
Assert . assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
public NoDataException ( Localizable specific ) { super ( specific ) ; }
UnivariateRealIntegratorImpl integrator = new LegendreGaussIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
public void setMinimalIterationCount ( final int count ) { minimalIterationCount = count ; }
public Set < String > getContextKeys () { throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
public Object getContext ( String key ) { throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
{ throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
{ throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
public Set < String > getContextKeys () { throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
public Object getContext ( String key ) { throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
{ throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
{ throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
Assert . assertTrue ( Double . isNaN ( PearsonsCorrelation . correlation ( noVariance , values ) ) ) ;
Assert . assertEquals ( new PearsonsCorrelation () . correlation ( x , y ) , corrInstance . getCorrelationMatrix () . getEntry ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , Double.MIN_VALUE ) ;
{ new PearsonsCorrelation () . correlation ( one , two ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertTrue ( Double . isNaN ( new PearsonsCorrelation () . correlation ( noVariance , values ) ) ) ;
normps = ps . getFrobeniusNorm () ;
normps = ps . getFrobeniusNorm () ;
{ super ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; this . max = max ; }
final SimplexTableau tableau = new SimplexTableau ( function , linearConstraints , goal , nonNegative , epsilon , maxUlps ) ;
if ( MathUtils . compareTo ( entry , minValue , maxUlps ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
{ getContext () . addMessage ( LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
{ this ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; }
{ super ( cause ) ; context . addMessage ( pattern , arguments ) ; }
{ super ( cause ) ; context . addMessage ( LocalizedFormats.USER_EXCEPTION ) ; }
{ super ( cause ) ; context . addMessage ( pattern , args ) ; }
{ getContext () . addMessage ( pattern , args ) ; }
{ super ( max ) ; getContext () . addMessage ( LocalizedFormats.EVALUATIONS ) ; }
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testData ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testDataInv ) ) , identity , entryTolerance ) ;
return new Array2DRowFieldMatrix < BigFraction > ( BigFractionField . getInstance () , Hdata ) ;
return new Array2DRowFieldMatrix < T > ( field , bp , false ) ;
return new ArrayFieldVector < T > ( field , bp , false ) ;
{ return projection ( new ArrayFieldVector < T > ( getField () , v , false ) ) ; }
return new Array2DRowFieldMatrix < T > ( field , d , false ) ;
Assert . assertEquals ( new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , fractionColMatrix ) , MatrixUtils . createFieldMatrix ( fractionColMatrix ) ) ;
return new ArrayFieldVector < T > ( getField () , outData , false ) ;
return new ArrayFieldVector < T > ( getField () , outData , false ) ;
final String source
{ super ( prefix , suffix , separator , CompositeFormat . getDefaultNumberFormat () ) ; }
public Vector3DFormat ( final NumberFormat format ) { super ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_SEPARATOR , format ) ; }
public Vector3DFormat () { super ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_SEPARATOR , CompositeFormat . getDefaultNumberFormat () ) ; }
final BSPTreeVisitor < S > visitor
void visitLeafNode ( BSPTree < S > node ) ;
BSPTree < S > node
BSPTree < S > node
Hyperplane < S > other
Vector < S > point
final Hyperplane < Euclidean1D > other
final Vector2D p
final Hyperplane < Euclidean2D > other
final Vector2D p
final Vector2D tmp = loop [ min ] ;
public Order visitOrder ( final BSPTree < Euclidean3D > node ) { return Order.MINUS_SUB_PLUS ; }
public BoundaryProjector () { projected = new PolygonsSet ( new BSPTree < Euclidean2D > ( Boolean.FALSE ) ) ; }
final BSPTree < Euclidean1D > tree
final BSPTree < Euclidean2D > tree
public Order visitOrder ( final BSPTree < Euclidean2D > node ) { return Order.MINUS_SUB_PLUS ; }
final Hyperplane < Euclidean3D > other
final Vector < Euclidean3D > point
final Vector3D p
origin = new Vector3D ( - originOffset , w ) ;
public Order visitOrder ( final BSPTree < Euclidean3D > node ) { return Order.MINUS_SUB_PLUS ; }
final BSPTree < Euclidean3D > tree
public abstract SplitSubHyperplane < S > split ( Hyperplane < S > hyper ) ;
public abstract Side side ( Hyperplane < S > hyper ) ;
{ if ( in [ i ] < NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX , i , in [ i ] ) ; } }
{ if ( val < NUMBER_CONSTANT || val > NUMBER_CONSTANT ) { throw new InvalidRepresentationException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , val , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
for ( int i : chromosomeRepresentation ) { if ( i < NUMBER_CONSTANT || i > NUMBER_CONSTANT ) throw new InvalidRepresentationException ( LocalizedFormats.INVALID_BINARY_DIGIT , i ) ; }
clusters = transformer . cluster ( Arrays . asList ( points ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
public RealVector getInitialStateEstimate () { return initialStateEstimateVector ; }
if ( t == NUMBER_CONSTANT && i >= j ) { continue; }
{ if ( maxGenerations <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . maxGenerations = maxGenerations ; }
if ( ! forward ) { h = - h ; }
if ( remA > NUMBER_CONSTANT ) { break; }
if ( remA > NUMBER_CONSTANT ) { break; }
if ( x * x == NUMBER_CONSTANT ) { return Double.NaN ; }
{ for ( Chromosome anotherChr : population ) { if ( this . isSame ( anotherChr ) ) { return anotherChr ; } } return null ; }
{ numElements -= i ; if ( front ) { startIndex += i ; } }
{ super ( relativeAccuracy , absoluteAccuracy ) ; }
public SecantSolver ( final double absoluteAccuracy ) { super ( absoluteAccuracy ) ; }
{ this . allowed = allowedSolutions ; return super . solve ( maxEval , f , min , max , startValue ) ; }
{ super ( relativeAccuracy , absoluteAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ super ( absoluteAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ se [ i ] = FastMath . sqrt ( var ) ; continue; }
if ( ! Double . isNaN ( var ) && var > Double.MIN_VALUE ) { return FastMath . sqrt ( var ) ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
{ if ( isNaN ) { return NaN ; } return createComplex ( FastMath . log ( abs () ) , FastMath . atan2 ( imaginary , real ) ) ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
{ if ( isNaN ) { return NaN ; } return createComplex ( - real , - imaginary ) ; }
if ( isNaN ) { return NUMBER_CONSTANT ; }
{ if ( isNaN ) { return NaN ; } return createComplex ( real , - imaginary ) ; }
if ( isNaN ) { return Double.NaN ; }
{ if ( rng . nextBoolean () ) { throw new MathIllegalStateException () ; } }
Assert . assertTrue ( Double . isNaN ( w . getReal () ) ) ;
{ include ( MathUtils . copyOf ( x , x.length ) , NUMBER_CONSTANT , y ) ; }
if ( index < NUMBER_CONSTANT || index >= this . parameters . length ) { throw new IndexOutOfBoundsException ( indexOutOfBound ) ; }
if ( index < NUMBER_CONSTANT || index >= this . parameters . length ) { throw new IndexOutOfBoundsException ( indexOutOfBound ) ; }
{ return outerProduct ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return getLInfDistance ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return getL1Distance ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return getDistance ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return dotProduct ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return ebeDivide ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return ebeMultiply ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return subtract ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return add ( ( ( ArrayRealVector ) v ) . data ) ; }
{ super ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , Method.REGULA_FALSI ) ; }
if ( numberOfVariables < NUMBER_CONSTANT ) { throw new ModelSpecificationException ( LocalizedFormats.NO_REGRESSORS ) ; }
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolution.ABOVE_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolution.BELOW_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolution.RIGHT_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolution.LEFT_SIDE ) ;
this . allowed = AllowedSolution.ANY_SIDE ;
this . allowed = AllowedSolution.ANY_SIDE ;
{ return solve ( maxEval , f , min , max , startValue , AllowedSolution.ANY_SIDE ) ; }
{ super ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy ) ; this . allowed = AllowedSolution.ANY_SIDE ; this . method = method ; }
{ super ( relativeAccuracy , absoluteAccuracy ) ; this . allowed = AllowedSolution.ANY_SIDE ; this . method = method ; }
{ super ( absoluteAccuracy ) ; this . allowed = AllowedSolution.ANY_SIDE ; this . method = method ; }
double x = randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double dot = v1 . dotProduct ( v2 ) ;
{ return new Solver ( singularValues , getUT () , getV () , getRank () == m ) ; }
tol = FastMath . max ( m * singularValues [ NUMBER_CONSTANT ] * EPS , FastMath . sqrt ( MathUtils.SAFE_MIN ) ) ;
{ super . setEntry ( row - INDEX_OFFSET , col - INDEX_OFFSET , value ) ; }
{ super . setEntry ( index - INDEX_OFFSET , value ) ; }
fsave = fval . getEntry ( INDEX_OFFSET ) ;
Iterator iter = entries . iterator () ;
double scaled = area * facetB . dotProduct ( plane . getNormal () ) ;
final Vector3D n = new Vector3D ( NUMBER_CONSTANT , d , - d . dotProduct ( direction ) , direction ) ;
{ return point . dotProduct ( w ) + originOffset ; }
{ setNormal ( normal ) ; originOffset = - p . dotProduct ( w ) ; setFrame () ; }
public Line revert () { return new Line ( zero , zero . subtract ( direction ) ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS , nRows , nCols ) ; }
{ return t ; }
if ( ( delta <= rLimit ) || ( delta <= absoluteAccuracy ) ) { return s ; }
if ( ( delta <= rLimit ) || ( delta <= absoluteAccuracy ) ) { return t ; }
RealVector v = RealVector . unmodifiableRealVector ( u . copy () ) ;
RealVector v = RealVector . unmodifiableRealVector ( u . copy () ) ;
RealVector v = RealVector . unmodifiableRealVector ( u ) ;
RealVector v = RealVector . unmodifiableRealVector ( u ) ;
RealVector v = RealVector . unmodifiableRealVector ( u ) ;
RealVector v = RealVector . unmodifiableRealVector ( u ) ;
final ArrayRealVector x = new ArrayRealVector ( dim ) ;
final ArrayRealVector x = new ArrayRealVector ( dim ) ;
final double [] actual = x . toArray () ;
final double [] actual = z . toArray () ;
double [] d2 = w . toArray () ;
{ return coefficients . dotProduct ( new ArrayRealVector ( point , false ) ) + constantTerm ; }
dist = new EmpiricalDistributionImpl ( NUMBER_CONSTANT , ( RandomGenerator ) null ) ;
public EmpiricalDistributionImpl ( int binCount ) { this ( binCount , new RandomDataImpl () ) ; }
empiricalDistribution = new EmpiricalDistributionImpl ( binCount , randomData ) ;
return NUMBER_CONSTANT * ( NUMBER_CONSTANT + Erf . erf ( dev / ( standardDeviation * SQRT2 ) ) ) ;
{ this ( new SimpleScalarValueChecker ( rel , abs ) ) ; }
@ Test ( expected = ConvergenceException . class )
{ solver . solve ( b . getColumnVector ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ es . solve ( b . getColumnVector ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ solver . solve ( b . getColumnVector ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
if ( divisor.isZero ) { return NaN ; }
final ExceptionContext cOut = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
final ExceptionContext cOut = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
final ExceptionContext c = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
final ExceptionContext c = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
final ExceptionContext c = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
@ Test ( expected = MaxCountExceededException . class )
@ Test ( expected = MaxCountExceededException . class )
Exception e
Exception e
int i = FACT_LEN - NUMBER_CONSTANT
final double [] x = b . toArray () ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . toArray () , entryTolerance ) ;
double [] hatResiduals = I . subtract ( hat ) . operate ( model.Y ) . toArray () ;
final double objectiveValue = computeObjectiveValue ( currentBest . toArray () ) ;
f = computeObjectiveValue ( currentBest . toArray () ) ;
final double [] actual = x . toArray () ;
final double [] actual = x . toArray () ;
final double [] actual = x . combine ( a , b , y ) . toArray () ;
final double [] actual = x . combine ( a , b , y ) . toArray () ;
Assert . assertNotSame ( STRING_CONSTANT , v1.data , v_copy . toArray () ) ;
{ double sum = NUMBER_CONSTANT ; for ( double coefficient : coefficients . toArray () ) { sum -= coefficient ; } return sum ; }
assertClose ( m . preMultiply ( new ArrayRealVector ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
assertClose ( testVector , m . operate ( new ArrayRealVector ( testVector ) ) . toArray () , entryTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . toArray () , entryTolerance ) ;
public double [] getStateEstimation () { return stateEstimation . toArray () ; }
double [] y = u . add ( x . operate ( b ) ) . toArray () ;
TestUtils . assertEquals ( new double [] { - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , b . toArray () , NUMBER_CONSTANT ) ;
TestUtils . assertEquals ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , - NUMBER_CONSTANT , NUMBER_CONSTANT } , b . toArray () , NUMBER_CONSTANT ) ;
return e . toArray () ;
{ RealVector b = calculateBeta () ; return b . toArray () ; }
if ( x instanceof ArrayRealVector ) { return ( ( ArrayRealVector ) x ) . getDataRef () ; } else { return x . toArray () ; }
if ( ltI [ i ] < absolutePositivityThreshold ) { throw new NonPositiveDefiniteMatrixException ( ltI [ i ] , i , absolutePositivityThreshold ) ; }
int i = FACT.length - NUMBER_CONSTANT
int i = FACT.length - NUMBER_CONSTANT
int i = FACT.length - NUMBER_CONSTANT
CholeskyDecompositionImpl llt = new CholeskyDecompositionImpl ( matrix ) ;
CholeskyDecompositionImpl llt = new CholeskyDecompositionImpl ( matrix ) ;
DecompositionSolver solver = new CholeskyDecomposition ( s ) . getSolver () ;
final RealMatrix matrix = EigenDecompositionTest . createTestMatrix ( new Random ( NUMBER_CONSTANT ) , refValues ) ;
EigenDecompositionImpl eig = new EigenDecompositionImpl ( C , NUMBER_CONSTANT ) ;
EigenDecomposition eig = new EigenDecomposition ( C , NUMBER_CONSTANT ) ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
EigenDecomposition ed
EigenDecomposition ed
RealMatrix v = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) . getV () ;
final int max = val.length ;
final int max = val.length ;
final int max = val.length ;
throw new MathInternalError () ;
throw new MathInternalError () ;
throw new MathInternalError () ;
throw new MathInternalError () ;
FieldDecompositionSolver < BigFraction > pSolver = new FieldLUDecomposition < BigFraction > ( bigP ) . getSolver () ;
{ return new FieldLUDecomposition < Fraction > ( m ) . getDeterminant () . doubleValue () ; }
solver = new FieldLUDecomposition < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
solver = new FieldLUDecomposition ( createFractionMatrix ( singular ) ) . getSolver () ;
solver = new FieldLUDecomposition < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
@ Test ( expected = NonMonotonicSequenceException . class )
@ Test ( expected = NonMonotonicSequenceException . class )
catch ( NonMonotonicSequenceException iae ) {}
@ Test ( expected = NonMonotonicSequenceException . class )
@ Test ( expected = NonMonotonicSequenceException . class )
catch ( NonMonotonicSequenceException iae ) {}
DecompositionSolver solver = new LUDecomposition ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = new LUDecomposition ( MatrixUtils . createRealMatrix ( singular ) ) . getSolver () ;
DecompositionSolver solver = new LUDecomposition ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = useLU ? new LUDecomposition ( mA ) . getSolver () : new QRDecompositionImpl ( mA ) . getSolver () ;
return new LUDecomposition ( XTOIX ) . getSolver () . getInverse () ;
RealMatrix inverse = new LUDecomposition ( XTOIX ) . getSolver () . getInverse () ;
RealMatrix Rinv = new LUDecomposition ( Raug ) . getSolver () . getInverse () ;
DecompositionSolver solver = useLU ? new LUDecomposition ( mA ) . getSolver () : new QRDecomposition ( mA ) . getSolver () ;
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( X ) ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( X ) ; }
RealMatrix x = new QRDecomposition ( a ) . getSolver () . solve ( b ) ;
RealMatrix x = new QRDecomposition ( a ) . getSolver () . solve ( b ) ;
DecompositionSolver solver = new QRDecomposition ( MatrixUtils . createRealMatrix ( testData3x3Singular ) ) . getSolver () ;
DecompositionSolver solver = new QRDecomposition ( MatrixUtils . createRealMatrix ( testData3x3NonSingular ) ) . getSolver () ;
final RectangularCholeskyDecomposition decomposition = new RectangularCholeskyDecomposition ( covariance , small ) ;
final RectangularCholeskyDecomposition decomposition = new RectangularCholeskyDecomposition ( covariance , small ) ;
SingularValueDecomposition svd = new SingularValueDecomposition ( rm ) ;
DecompositionSolver solver = new SingularValueDecomposition ( MatrixUtils . createRealMatrix ( testSquare ) ) . getSolver () ;
DecompositionSolver solver = new SingularValueDecomposition ( m ) . getSolver () ;
DecompositionSolver solver = new SingularValueDecomposition ( MatrixUtils . createRealMatrix ( testSquare ) ) . getSolver () ;
{ g0Positive = g0 >= NUMBER_CONSTANT ; nextAction = EventHandler.Action.CONTINUE ; }
nextAction = EventHandler.Action.CONTINUE ;
ExpandableFirstOrderDifferentialEquations equations
final ExpandableFirstOrderDifferentialEquations equations
final ExpandableFirstOrderDifferentialEquations equations
{ out . writeDouble ( polynomials [ k ] [ l ] ) ; }
final double e = polynomials [ currentDegree ] [ i ] / scale [ i ] ;
Array . newInstance ( field . getRuntimeClass () , new int [] { m , nColB } )
bp = ( T [] ) Array . newInstance ( field . getRuntimeClass () , m )
bp = ( T [] ) Array . newInstance ( field . getRuntimeClass () , m )
{ return ( T [] ) Array . newInstance ( field . getRuntimeClass () , length ) ; }
array = ( T [] ) Array . newInstance ( field . getRuntimeClass () , length )
{ return ( T [] ) Array . newInstance ( field . getRuntimeClass () , length ) ; }
{ return ( T [] ) Array . newInstance ( field . getRuntimeClass () , length ) ; }
( T [] [] ) Array . newInstance ( field . getRuntimeClass () , new int [] { dimension , dimension } )
{ return ( T [] ) Array . newInstance ( field . getRuntimeClass () , length ) ; }
final RealVector x = solver . solve ( a , m , b ) ;
final RealVector x = solver . solve ( a , m , b ) ;
final RealVector x = solver . solve ( a , b ) ;
final RealVector x = solver . solve ( a , b , x0 ) ;
final RealVector x = solver . solveInPlace ( a , b , x0 ) ;
final RealVector x = solver . solve ( a , b ) ;
if ( nSteps <= NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS , name ) ; }
throw new MathIllegalArgumentException ( LocalizedFormats.N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED , n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
catch ( MathIllegalArgumentException e ) {}
try { f1 . divide ( f2 ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( ZeroException ex ) {}
{ if ( getN () > NUMBER_CONSTANT ) { throw new MathIllegalStateException ( LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC , getN () ) ; } }
if ( i < NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.INDEX_NOT_POSITIVE , i ) ; }
{ throw new MathIllegalArgumentException ( LocalizedFormats.INITIAL_CAPACITY_NOT_POSITIVE , initialCapacity ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw new MathIllegalArgumentException ( LocalizedFormats.UNSUPPORTED_EXPANSION_MODE , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT ) { throw new ArrayIndexOutOfBoundsException ( index ) ; }
catch ( ClassCastException ex ) { throw new MathIllegalArgumentException ( LocalizedFormats.INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES , v . getClass () . getName () ) ; }
MathIllegalStateException cause = new MathIllegalStateException ( LocalizedFormats.SIMPLE_MESSAGE , inMsg ) ;
{ this . expandable = equations ; }
allocateInterpolatedArrays ( - NUMBER_CONSTANT ) ;
catch ( Exception ex ) { Assert . fail ( STRING_CONSTANT + mean + STRING_CONSTANT + x + STRING_CONSTANT + ex . getMessage () ) ; }
@ Test ( expected = NonPositiveDefiniteOperatorException . class )
@ Test ( expected = NonSquareOperatorException . class )
@ Test ( expected = NonPositiveDefiniteOperatorException . class )
@ Test ( expected = NonSquareOperatorException . class )
if ( ( str = filePointer . readLine () ) == null ) { throw new MathIllegalStateException ( LocalizedFormats.URL_CONTAINS_NO_DATA , valuesFileURL ) ; }
if ( ( empiricalDistribution == null ) || ( empiricalDistribution . getBinStats () . size () == NUMBER_CONSTANT ) ) { throw new MathIllegalStateException ( LocalizedFormats.DIGEST_NOT_INITIALIZED ) ; }
catch ( IOException e ) { throw new MathIllegalStateException ( e , LocalizedFormats.SIMPLE_MESSAGE , e . getLocalizedMessage () ) ; }
catch ( ZeroException ze ) {}
catch ( MathIllegalStateException mise ) {}
final List < BigFraction > coefficients
final List < BigFraction > coefficients
if ( FastMath . abs ( m ) <= tol || Precision . equals ( fb , NUMBER_CONSTANT ) ) { return b ; }
Assert . assertTrue ( Precision . equals ( binomial , jacobi . value ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ) ;
if ( mode == StepNormalizerMode.MULTIPLES && Precision . equals ( nextTime , lastTime , NUMBER_CONSTANT ) ) { nextTime += h ; }
{ Assert . assertTrue ( Precision . equals ( out [ i ] , expectedSample [ i ] , NUMBER_CONSTANT ) ) ; }
Assert . assertTrue ( Precision . equals ( NUMBER_CONSTANT , MathUtils . distanceInf ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( Precision . equals ( NUMBER_CONSTANT , MathUtils . distance ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( Precision . equals ( NUMBER_CONSTANT , MathUtils . distance ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( Precision . equals ( NUMBER_CONSTANT , MathUtils . distance1 ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
if ( Precision . compareTo ( entry , minValue , maxUlps ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
isLastStep = isLastStep || Precision . equals ( currentT , tEnd , NUMBER_CONSTANT ) ;
for ( double value : values ) { if ( Precision . equals ( value , x , epsilon ) ) { return; } }
Precision . equalsIncludingNaN ( stat . getN () , getN () )
if ( Precision . compareTo ( entry , NUMBER_CONSTANT , epsilon ) < NUMBER_CONSTANT ) { return false ; }
{ if ( this . parameters == null ) { return null ; } return MathArrays . copyOf ( parameters ) ; }
public int [] getOrderOfRegressors () { return MathArrays . copyOf ( vorder ) ; }
{ include ( MathArrays . copyOf ( x , x.length ) , NUMBER_CONSTANT , y ) ; }
{ this ( wrong , previous , index , MathArrays.OrderDirection.INCREASING , true ) ; }
final double [] d = MathArrays . copyOf ( direc [ i ] ) ;
RealMatrix arzneg = selectColumns ( arz , MathArrays . copyOf ( arReverseIndex , mu ) ) ;
return MathArrays . checkOrder ( x , MathArrays.OrderDirection.INCREASING , true , abort ) ;
MathArrays . sortInPlace ( this . x , this . y ) ;
public int [] getSizes () { return MathArrays . copyOf ( size ) ; }
this . size = MathArrays . copyOf ( size ) ;
public int [] getCounts () { return MathArrays . copyOf ( counter ) ; }
Assert . assertEquals ( expectedValue () , variance . evaluate ( testArray , MathArrays . normalizeArray ( identicalWeightsArray , testArray.length ) , NUMBER_CONSTANT , testArray.length ) , getTolerance () ) ;
int gcd = ArithmeticsUtils . gcd ( numerator , denominator ) ;
final int d = ArithmeticsUtils . gcd ( num , den ) ;
long lcm = FastMath . abs ( mulAndCheck ( a / ArithmeticsUtils . gcd ( a , b ) , b ) ) ;
int lcm = FastMath . abs ( mulAndCheck ( a / ArithmeticsUtils . gcd ( a , b ) , b ) ) ;
{ coeff [ i ] [ j ] = ( int ) ArithmeticsUtils . binomialCoefficient ( i , j ) ; }
double binomial = ArithmeticsUtils . binomialCoefficient ( v + i , i ) ;
double binomial = ArithmeticUtils . binomialCoefficient ( v + i , i ) ;
int gcd = ArithmeticUtils . gcd ( numerator , denominator ) ;
final int d = ArithmeticUtils . gcd ( num , den ) ;
{ coeff [ i ] [ j ] = ( int ) ArithmeticUtils . binomialCoefficient ( i , j ) ; }
{ return FastMath . abs ( x ) < SHORTCUT ? NUMBER_CONSTANT : FastMath . sin ( x ) / x ; }
tol = FastMath . max ( m * singularValues [ NUMBER_CONSTANT ] * EPS , FastMath . sqrt ( Precision.SAFE_MIN ) ) ;
if ( d > - Precision.SAFE_MIN && d < Precision.SAFE_MIN ) { return d ; }
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
final double eps = NUMBER_CONSTANT * rows * columns * Precision.EPSILON ;
if ( FastMath . abs ( diag ) < Precision.SAFE_MIN ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer ( initialStepBoundFactor , costRelativeTolerance , parRelativeTolerance , orthoTolerance , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( indefinite , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( distinct , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( repeated , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( m , Precision.SAFE_MIN ) ;
RealMatrix v = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) . getV () ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( createTestMatrix ( r , bigValues ) , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
if ( FastMath . abs ( tmp ) > Precision.EPSILON ) { w = ( di * w ) / dpi ; }
{ this ( numberOfVariables , includeConstant , Precision.EPSILON ) ; }
@ Test ( expected = NumberIsTooLargeException . class )
{ this ( numberOfInterpolationPoints , DEFAULT_INITIAL_RADIUS , DEFAULT_STOPPING_RADIUS ) ; }
this . stopfitness = stopFitness ;
this . stopFitness = stopFitness ;
@ Override public boolean isInfinite () { throw unsupported () ; }
@ Override public boolean isNaN () { throw unsupported () ; }
@ Override public boolean isInfinite () { throw unsupported () ; }
@ Override public boolean isNaN () { throw unsupported () ; }
@ Override public boolean isInfinite () { throw unsupported () ; }
@ Override public boolean isNaN () { throw unsupported () ; }
@ Override public void unitize () { throw unsupported () ; }
@ Override public double getLInfNorm () { throw unsupported () ; }
@ Override public double getL1Norm () { throw unsupported () ; }
@ Override public double getNorm () { throw unsupported () ; }
double [] bounds = empiricalDistribution2 . getGeneratorUpperBounds () ;
FieldDecompositionSolver < Fraction > solver ;
double floatn = v.length ;
final double [] eventY = interpolator . getInterpolatedState () . clone () ;
final double [] yTmp = y0 . clone () ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new BetaDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
BetaDistribution betaDistribution = new BetaDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
BetaDistribution d = new BetaDistribution ( alpha , beta ) ;
BetaDistribution d = new BetaDistribution ( alpha , beta ) ;
setDistribution ( new BinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new BinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new CauchyDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
ChiSquaredDistribution d = new ChiSquaredDistribution ( df ) ;
setDistribution ( new ChiSquaredDistribution ( NUMBER_CONSTANT ) ) ;
@ Override public ChiSquaredDistribution makeDistribution () { return new ChiSquaredDistribution ( NUMBER_CONSTANT ) ; }
double [] quartiles = TestUtils . getDistributionQuartiles ( new ChiSquaredDistribution ( NUMBER_CONSTANT ) ) ;
FDistribution fd = new FDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new FDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GammaDistribution distribution = new GammaDistribution ( a , b ) ;
GammaDistribution distribution = new GammaDistribution ( a , b ) ;
@ Override public ExponentialDistribution makeDistribution () { return new ExponentialDistribution ( NUMBER_CONSTANT ) ; }
FDistribution fdist = new FDistribution ( a.dfbg , a.dfwg ) ;
{ gamma = new GammaDistribution ( degreesOfFreedom / NUMBER_CONSTANT , NUMBER_CONSTANT ) ; solverAbsoluteAccuracy = inverseCumAccuracy ; }
HypergeometricDistribution dist = new HypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
setDistribution ( new HypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NormalDistribution normal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
NormalDistribution distribution = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
NormalDistribution d = new NormalDistribution ( mean , sd ) ;
setDistribution ( new PascalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new PascalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
normal = new NormalDistribution ( p , FastMath . sqrt ( p ) ) ;
TDistribution tDistribution = new TDistribution ( NUMBER_CONSTANT ) ;
FastMath . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / n ) + ( xbar * xbar ) / sumXX ) )
TDistribution distribution = new TDistribution ( degreesOfFreedom ) ;
TDistribution distribution = new TDistribution ( degreesOfFreedom ) ;
TDistribution td = new TDistribution ( df ) ;
setDistribution ( new TDistribution ( NUMBER_CONSTANT ) ) ;
@ Override public TDistribution makeDistribution () { return new TDistribution ( NUMBER_CONSTANT ) ; }
double [] quartiles = TestUtils . getDistributionQuartiles ( new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new TDistribution ( NUMBER_CONSTANT ) ) ;
PoissonDistribution poissonDistribution = new PoissonDistribution ( mean ) ;
PoissonDistribution dist = new PoissonDistribution ( mean ) ;
PoissonDistribution dist = new PoissonDistribution ( mean ) ;
{ PoissonDistribution dist = new PoissonDistribution ( NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , dist . getMean () , NUMBER_CONSTANT ) ; }
@ Test ( expected = NotStrictlyPositiveException . class ) public void testNegativeMean () { new PoissonDistribution ( - NUMBER_CONSTANT ) ; }
PoissonDistribution dist = new PoissonDistribution ( DEFAULT_TEST_POISSON_PARAMETER ) ;
@ Override public IntegerDistribution makeDistribution () { return new PoissonDistribution ( DEFAULT_TEST_POISSON_PARAMETER ) ; }
dist = new ZipfDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_WINDOW_SIZE , windowSize ) ; } }
if ( sign >= NUMBER_CONSTANT && magnitude == Long.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW ) ; } else { return - magnitude ; }
if ( sign >= NUMBER_CONSTANT && magnitude == Integer.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW ) ; } else { return - magnitude ; }
if ( c . isAssignableFrom ( UnivariateFunction . class ) ) { return new Sin () ; } else { throw new IllegalArgumentException ( STRING_CONSTANT + c ) ; }
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new XMinus5Function () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction function
UnivariateFunction function
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
final DifferentiableUnivariateFunction f
ParametricUnivariateFunction sif = new SimpleInverseFunction () ;
ParametricUnivariateFunction sif = new SimpleInverseFunction () ;
UnivariateFunction f
UnivariateFunction func
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction f = new Gaussian () ;
final UnivariateFunction f = new Gaussian () ;
@ Override public RealVector mapToSelf ( UnivariateFunction function ) { throw unsupported () ; }
@ Override public RealVector map ( UnivariateFunction function ) { throw unsupported () ; }
DifferentiableUnivariateFunction f
UnivariateFunction f
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f
UnivariateFunction f
UnivariateFunction p = interpolator . interpolate ( x , y ) ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction dfdx = f . derivative () ;
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
final UnivariateFunction f
final UnivariateFunction f
final UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction f = new Sigmoid () ;
UnivariateFunction function
UnivariateFunction function
UnivariateFunction function
UnivariateFunction function
UnivariateFunction function
UnivariateFunction f
UnivariateFunction f
final UnivariateFunction f
DifferentiableUnivariateFunction f = new QuinticFunction () ;
DifferentiableUnivariateFunction f = new SinFunction () ;
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
final ParametricUnivariateFunction f
final ParametricUnivariateFunction f
final ParametricUnivariateFunction f
final UnivariateFunction f
final UnivariateFunction f
UnivariateFunction p = interpolator . interpolate ( x , y ) ;
final UnivariateFunction dfdx = f . derivative () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
final UnivariateFunction f
final UnivariateFunction lsf = new LineSearchFunction ( searchDirection ) ;
DifferentiableUnivariateFunction f
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction function
UnivariateFunction function
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
@ Override public RealVector mapToSelf ( UnivariateFunction function ) { throw unsupported () ; }
@ Override public RealVector map ( UnivariateFunction function ) { throw unsupported () ; }
public MonitoredFunction ( UnivariateFunction f ) { callsCount = NUMBER_CONSTANT ; this . f = f ; }
UnivariateFunction dSpline = spline . derivative () ;
final MultivariateFunction evaluationFunction
MultivariateFunction func
MultivariateFunction coll = FunctionUtils . collector ( bi , NUMBER_CONSTANT ) ;
final MultivariateFunction evaluationFunction
final MultivariateFunction evaluationFunction
final DifferentiableMultivariateFunction f
DifferentiableMultivariateFunction func
DifferentiableMultivariateFunction func
MultivariateFunction func
final MultivariateFunction evaluationFunction
final MultivariateFunction evaluationFunction
MultivariateFunction func
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; }
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; maxError = NUMBER_CONSTANT ; }
public KeplerStepHandler ( TestProblem3 pb ) { this . pb = pb ; }
public KeplerStepHandler ( TestProblem3 pb ) { this . pb = pb ; }
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; }
final DifferentiableMultivariateVectorFunction f
final MultivariateVectorFunction function
final MultivariateVectorFunction function
final MultivariateVectorFunction function
# optimize ( int , MultivariateVectorFunction , double [] , double [] , double [] )
DifferentiableMultivariateVectorFunction problem
result = transformer . inverseTransform ( f , min , max , N ) ;
if ( forward ) { temp = transform2 ( temp ) ; } else { temp = inverseTransform2 ( temp ) ; }
double dResult [] = transformer . inverseTransform ( dY ) ;
new Fraction ( ( ( Math . abs ( w ) * d ) + n ) * MathUtils . copySign ( NUMBER_CONSTANT , w ) , d )
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
p = dist . cumulativeProbability ( ( int ) x ) ;
RealDistribution distribution
RealDistribution distribution
FastFourierTransformer transformer = FastFourierTransformer . create () ;
FastFourierTransformer transformer = FastFourierTransformer . create () ;
FastFourierTransformer transformer = FastFourierTransformer . create () ;
FastFourierTransformer transformer = FastFourierTransformer . create () ;
FastCosineTransformer transformer = FastCosineTransformer . create () ;
FastCosineTransformer transformer = FastCosineTransformer . create () ;
DifferentiableMultivariateVectorOptimizer optimizer
final DifferentiableMultivariateVectorOptimizer optimizer
public HarmonicFitter ( final DifferentiableMultivariateVectorOptimizer optimizer ) { super ( optimizer ) ; }
final DifferentiableMultivariateVectorOptimizer optimizer
public GaussianFitter ( DifferentiableMultivariateVectorOptimizer optimizer ) { super ( optimizer ) ; }
final BaseMultivariateOptimizer < FUNC > optimizer
MultivariateOptimizer optim
final DifferentiableMultivariateOptimizer optimizer
final MultivariateOptimizer optimizer
@ Override public void setSeed ( int seed ) { ran . setSeed ( seed ) ; clear () ; }
{ if ( rand == null ) { initRan () ; } rand . setSeed ( seed ) ; }
FastSineTransformer transformer = FastSineTransformer . create () ;
FastSineTransformer transformer = FastSineTransformer . create () ;
Assert . assertEquals ( NUMBER_CONSTANT , dist . inverseCumulativeProbability ( NUMBER_CONSTANT ) ) ;
setInverseCumulativeTestValues ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ;
setInverseCumulativeTestValues ( new int [] { Integer.MAX_VALUE , Integer.MAX_VALUE } ) ;
if ( ! ArithmeticUtils . isPowerOfTwo ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_PLUS_ONE , Integer . valueOf ( f.length ) ) ; }
{ if ( ! ArithmeticUtils . isPowerOfTwo ( o.length ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( o.length ) ) ; } }
{ if ( ! ArithmeticUtils . isPowerOfTwo ( d.length ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( d.length ) ) ; } }
if ( ! ArithmeticUtils . isPowerOfTwo ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , Integer . valueOf ( n ) ) ; }
if ( ! ArithmeticUtils . isPowerOfTwo ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , Integer . valueOf ( n ) ) ; }
final double [] data = FunctionUtils . sample ( f , min , max , n ) ;
final double [] data = FunctionUtils . sample ( f , min , max , n ) ;
{ final double [] data = FunctionUtils . sample ( f , min , max , n ) ; return inverseTransform ( data ) ; }
{ final double [] data = FunctionUtils . sample ( f , min , max , n ) ; return transform ( data ) ; }
final double [] unscaled = fht ( FunctionUtils . sample ( f , min , max , n ) ) ;
final double [] data = FunctionUtils . sample ( f , min , max , n ) ;
final double [] data = FunctionUtils . sample ( f , min , max , n ) ;
return TransformUtils . scaleArray ( fst ( data ) , s ) ;
return TransformUtils . scaleArray ( fst ( f ) , s ) ;
{ final double s = FastMath . sqrt ( NUMBER_CONSTANT / n ) ; return TransformUtils . scaleArray ( fst ( data ) , s ) ; }
{ final double s = FastMath . sqrt ( NUMBER_CONSTANT / f.length ) ; return TransformUtils . scaleArray ( fst ( f ) , s ) ; }
TransformUtils . scaleArray ( x2 , NUMBER_CONSTANT / FastMath . sqrt ( x2.length ) ) ;
return TransformUtils . scaleArray ( transformed , NUMBER_CONSTANT ) ;
return TransformUtils . scaleArray ( fft ( f ) , s ) ;
return TransformUtils . scaleArray ( fft ( data , true ) , s ) ;
return TransformUtils . scaleArray ( fft ( f , true ) , s ) ;
{ final double s = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ; return TransformUtils . scaleArray ( fft ( f ) , s ) ; }
return TransformUtils . scaleArray ( fft ( data , false ) , s ) ;
return TransformUtils . scaleArray ( fft ( f , false ) , s ) ;
TransformUtils . scaleArray ( x , FastMath . sqrt ( x.length / NUMBER_CONSTANT ) ) ;
return TransformUtils . scaleArray ( fct ( f ) , s1 ) ;
return TransformUtils . scaleArray ( fct ( f ) , s ) ;
return TransformUtils . scaleArray ( unscaled , NUMBER_CONSTANT / n ) ;
{ return TransformUtils . scaleArray ( fht ( f ) , NUMBER_CONSTANT / f.length ) ; }
{ for ( double diag : rDiag ) { if ( FastMath . abs ( diag ) <= threshold ) { return false ; } } return true ; }
public DecompositionSolver getSolver () { return new Solver ( qrt , rDiag , threshold ) ; }
@ Test ( expected = NumberIsTooLargeException . class )
final UnivariateSolver solver
final UnivariateSolver solver
UnivariateSolver solver = new MullerSolver () ;
UnivariateSolver solver = new MullerSolver () ;
UnivariateSolver solver = new MullerSolver () ;
UnivariateSolver solver = new MullerSolver () ;
{ return super . solve ( maxEval , f , UnivariateSolverUtils . midpoint ( min , max ) ) ; }
final UnivariateSolver lineSearchSolver
final UnivariateSolver lineSearchSolver
UnivariateSolver solver = new RiddersSolver () ;
UnivariateSolver solver = new RiddersSolver () ;
UnivariateSolver solver = new RiddersSolver () ;
UnivariateSolver solver = new RiddersSolver () ;
UnivariateSolver solver = new BrentSolver () ;
UnivariateSolver solver = new BrentSolver () ;
UnivariateSolver solver = new MullerSolver2 () ;
UnivariateSolver solver = new MullerSolver2 () ;
UnivariateSolver solver = new MullerSolver2 () ;
UnivariateSolver solver = new MullerSolver2 () ;
double x = UnivariateSolverUtils . solve ( toSolve , lowerBound , upperBound , getSolverAbsoluteAccuracy () ) ;
UnivariateSolver solver
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
final UnivariateSolver solver = new RegulaFalsiSolver () ;
final UnivariateSolver solver
final Chromosome chromosome
final List < Chromosome > chromosomes
final Population population
final Chromosome original
final Chromosome another
final Chromosome another
final List < Double > chromosomeRepresentation
final Chromosome another
final List < T > sequence
final Population current
final RandomGenerator random
{ if ( maxGenerations <= NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( maxGenerations , NUMBER_CONSTANT , true ) ; } this . maxGenerations = maxGenerations ; }
if ( elitismRate < NUMBER_CONSTANT || elitismRate > NUMBER_CONSTANT ) { throw new OutOfRangeException ( LocalizedFormats.ELITISM_RATE , elitismRate , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
partialDerivatives = new BivariateFunction [ [ [ NUMBER_CONSTANT ] [ lastI ] [ lastJ ] ;
BivariateFunction div = new Divide () ;
BivariateFunction bi = new Add () ;
BivariateFunction bi = new Add () ;
final BivariateFunction f
final BivariateFunction f
final BivariateFunction combiner
final BivariateFunction combiner
final BivariateFunction combiner
final IterativeLinearSolverEvent event = new SymmLQEvent ( this , state ) ;
{ return x . ebeDivide ( diag ) ; }
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
roots . computeOmega ( - f.length ) ;
BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
MultivariateInterpolator interpolator = new MicrosphereInterpolator () ;
MultivariateInterpolator interpolator = new MicrosphereInterpolator () ;
UnivariateInterpolator i = new LinearInterpolator () ;
UnivariateInterpolator i = new LinearInterpolator () ;
UnivariateInterpolator i = new LinearInterpolator () ;
UnivariateInterpolator i = new LinearInterpolator () ;
UnivariateInterpolator interpolator = new NevilleInterpolator () ;
UnivariateInterpolator interpolator = new NevilleInterpolator () ;
UnivariateInterpolator interpolator = new NevilleInterpolator () ;
BivariateGridInterpolator interpolator = new BicubicSplineInterpolator () ;
BivariateGridInterpolator interpolator = new BicubicSplineInterpolator () ;
BivariateGridInterpolator interpolator = new BicubicSplineInterpolator () ;
UnivariateInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateInterpolator interpolator = new DividedDifferenceInterpolator () ;
TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator () ;
TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator () ;
TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
roots . computeRoots ( - f.length ) ;
UnivariateIntegrator integrator = new TrapezoidIntegrator () ;
UnivariateIntegrator integrator = new TrapezoidIntegrator () ;
LegendreGaussIntegrator integrator = new LegendreGaussIntegrator ( n , BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY , BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY , BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT , NUMBER_CONSTANT ) ;
UnivariateIntegrator integrator = new SimpsonIntegrator () ;
UnivariateIntegrator integrator = new SimpsonIntegrator () ;
UnivariateIntegrator integrator = new RombergIntegrator () ;
UnivariateIntegrator integrator = new RombergIntegrator () ;
final BaseAbstractUnivariateIntegrator baseIntegrator
public ISAACRandom ( long seed ) { setSeed ( seed ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw new MathIllegalStateException ( LocalizedFormats.CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS ) ; } }
final double fact2 = n / ( n - NUMBER_CONSTANT ) ;
final double fact2 = n / ( NUMBER_CONSTANT + n ) ;
public void init ( double t0 , double [] y0 , double time ) {}
try { t . transform ( input ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException e ) {}
if ( ( nvars + NUMBER_CONSTANT ) * nobs != data.length ) { throw new MathIllegalArgumentException ( LocalizedFormats.INVALID_REGRESSION_ARRAY , data.length , nobs , nvars ) ; }
empiricalDistribution = new EmpiricalDistribution ( binCount , randomData ) ;
EmpiricalDistribution dist = new EmpiricalDistribution ( NUMBER_CONSTANT ) ;
{ new EmpiricalDistribution () . load ( ( File ) null ) ; }
{ new EmpiricalDistribution () . load ( ( URL ) null ) ; }
{ new EmpiricalDistribution () . load ( ( double [] ) null ) ; }
EmpiricalDistribution dist = new EmpiricalDistribution () ;
new EmpiricalDistribution () . load ( x ) ;
dataRI = new double [] [] { MathArrays . copyOf ( f , f.length ) , new double [ f.length ] }
dataRI = new double [] [] { MathArrays . copyOf ( f , f.length ) , new double [ f.length ] }
double dResult [] = transformer . transform ( dY , TransformType.INVERSE ) ;
double dResult [] = transformer . transform ( dX , TransformType.FORWARD ) ;
protected BaseAbstractMultivariateSimpleBoundsOptimizer ( ConvergenceChecker < PointValuePair > checker ) { super ( checker ) ; }
UnivariatePointValuePair [] optima = optimizer . getOptima () ;
public SimplexOptimizer ( ConvergenceChecker < PointValuePair > checker ) { super ( checker ) ; }
PointValuePair expected
protected AbstractScalarDifferentiableOptimizer ( ConvergenceChecker < PointValuePair > checker ) { super ( checker ) ; }
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < UnivariatePointValuePair > checker
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < UnivariatePointValuePair > checker
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < PointValuePair > checker
PointValuePair point
final Comparator < PointValuePair > comparator
ChiSquareTest chiSquareTest = new ChiSquareTest () ;
org.apache.commons.math.stat.inference.ChiSquareTest csti = new org.apache.commons.math.stat.inference.ChiSquareTest () ;
org.apache.commons.math.stat.inference.ChiSquareTest csti = new org.apache.commons.math.stat.inference.ChiSquareTest () ;
ChiSquareTest chiSquareTest = new ChiSquareTest () ;
PointVectorValuePair optimum
ConvergenceChecker < PointVectorValuePair > checker
ConvergenceChecker < PointVectorValuePair > checker
ConvergenceChecker < PointVectorValuePair > checker
ConvergenceChecker < PointVectorValuePair > checker
ConvergenceChecker < PointVectorValuePair > checker
protected AbstractLeastSquaresOptimizer ( ConvergenceChecker < PointVectorValuePair > checker ) { super ( checker ) ; }
SimplexOptimizer underlying = new SimplexOptimizer ( new SimpleValueChecker ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver () , preconditioner ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
SimplexOptimizer optimizer = new SimplexOptimizer ( new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer underlying = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ this ( lambda , inputSigma , boundaries , maxIterations , stopFitness , isActiveCMA , diagonalOnly , checkFeasableCount , random , generateStatistics , new SimpleValueChecker () ) ; }
{ this ( new SimpleValueChecker ( rel , abs ) ) ; }
DifferentiableMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer ( true , new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
DifferentiableMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer ( true , new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ throw new MathUnsupportedOperationException () ; }
FastSineTransformer transformer = new FastSineTransformer ( DstNormalization.STANDARD_DST_I ) ;
FastSineTransformer transformer = new FastSineTransformer ( DstNormalization.STANDARD_DST_I ) ;
{ throw new NumberIsTooSmallException ( LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION , FastMath . abs ( h ) , minStep , true ) ; }
if ( variablesToInclude == null || variablesToInclude.length == NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.ARRAY_ZERO_LENGTH_OR_NULL_NOT_ALLOWED ) ; }
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
static double [] [] loadLnMant () { return LN_MANT ; }
static double [] loadExpFracB () { return EXP_FRAC_B ; }
static double [] loadExpFracA () { return EXP_FRAC_A ; }
static double [] loadExpIntB () { return EXP_INT_B ; }
static double [] loadExpIntA () { return EXP_INT_A ; }
@ Test ( expected = DimensionMismatchException . class )
@ Test ( expected = DimensionMismatchException . class )
StringBuffer imAppendTo ;
{ if ( this . fitness == NO_FITNESS ) { this . fitness = fitness () ; } return this . fitness ; }
setControlFactors ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
setControlFactors ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
( n * ( n + NUMBER_CONSTANT ) * moment . getResult () - NUMBER_CONSTANT * moment.m2 * moment.m2 * ( n - NUMBER_CONSTANT ) )
double [] hatResiduals = I . subtract ( hat ) . operate ( model . getY () ) . toArray () ;
{ RealVector b = calculateBeta () ; return yVector . subtract ( xMatrix . operate ( b ) ) ; }
return residuals . dotProduct ( residuals ) / ( xMatrix . getRowDimension () - xMatrix . getColumnDimension () ) ;
RealVector e = yVector . subtract ( xMatrix . operate ( b ) ) ;
this . yVector = new ArrayRealVector ( y ) ;
return t / ( getX () . getRowDimension () - getX () . getColumnDimension () ) ;
int p = getX () . getColumnDimension () ;
{ return qr . getSolver () . solve ( getY () ) ; }
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( getX () ) ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( getX () ) ; }
final RealMatrix x = ols . getX () . copy () ;
final int length = b . getDimension () ;
final double epsa = ( s + MACH_PREC ) * CBRT_MACH_PREC ;
@ Override public RealVector getRightHandSideVector () { return RealVector . unmodifiableRealVector ( state . getRightHandSideVector () ) ; }
this . xL = x ;
solver = new SymmLQ ( maxIterations , NUMBER_CONSTANT , true ) ;
solver = new SymmLQ ( maxIterations , NUMBER_CONSTANT , true ) ;
{ this ( k , v , false ) ; }
{ this ( entry . getKey () , entry . getValue () ) ; }
{ key = k ; value = v ; }
throw new MathInternalError () ;
throw new MathInternalError () ;
if ( x <= NUMBER_CONSTANT ) { ret = NUMBER_CONSTANT ; } else { ret = Gamma . regularizedGammaP ( shape , x / scale ) ; }
v . walkInOptimizedOrder ( visitor , expectedStart , expectedEnd ) ;
{ ret = innerCumulativeProbability ( domain [ NUMBER_CONSTANT ] , x , NUMBER_CONSTANT ) ; }
{ tree . visit ( new BoundaryBuilder < S > () ) ; }
SimplexOptimizer optimizer = new SimplexOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
@ Override public RealVector create ( final double [] data ) { return new TestVectorImpl ( data ) ; }
TestVectorImpl ( double [] values ) { this . values = MathArrays . copyOf ( values ) ; }
catch ( MathArithmeticException e ) {}
T f
T f
final long n1n2prod = ( long ) n1 * n2 ;
{ create ( new double [ NUMBER_CONSTANT ] ) . addToEntry ( - NUMBER_CONSTANT , getPreferredEntryValue () ) ; }
{ create ( new double [ NUMBER_CONSTANT ] ) . setEntry ( - NUMBER_CONSTANT , getPreferredEntryValue () ) ; }
@ Override public RealVector createAlien ( final double [] data ) { return new RealVectorTestImpl ( data ) ; }
final RealVector x = new RealVectorTestImpl ( v . clone () ) ;
@ Override public RealVector createAlien ( double [] data ) { return new RealVectorTestImpl ( data ) ; }
@ Override public RealVector create ( final double [] data ) { return new RealVectorTestImpl ( data ) ; }
RealVectorTestImpl v7_i = new RealVectorTestImpl ( vec1 ) ;
@ Override public RealVector createAlien ( double [] data ) { return new RealVectorTestImpl ( data ) ; }
Assert . assertEquals ( dataU [ i ] + STRING_CONSTANT + dataV [ j ] , expected , actual , NUMBER_CONSTANT ) ;
Object other
final int n = coefficients.length - NUMBER_CONSTANT ;
ed = new EigenDecomposition ( indefinite ) ;
ed = new EigenDecomposition ( distinct ) ;
ed = new EigenDecomposition ( repeated ) ;
ed = new EigenDecomposition ( m ) ;
RealMatrix v = new EigenDecomposition ( matrix ) . getV () ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( symmetric ) ;
ed = new EigenDecomposition ( createTestMatrix ( r , bigValues ) ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
{ return ( int ) FastMath . min ( nextPoisson ( mean ) , Integer.MAX_VALUE ) ; }
{ final double n = random . nextGaussian () ; return FastMath . exp ( scale + shape * n ) ; }
EigenDecomposition eig = new EigenDecomposition ( C ) ;
BaseRuleFactory < ? extends Number > factory
final GaussIntegrator g = FACTORY . legendreHighPrecision ( numberOfPoints , a , b ) ;
{ this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ROW_PREFIX , DEFAULT_ROW_SUFFIX , DEFAULT_ROW_SEPARATOR , DEFAULT_COLUMN_SEPARATOR , format ) ; }
public RealMatrixFormat () { this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ROW_PREFIX , DEFAULT_ROW_SUFFIX , DEFAULT_ROW_SEPARATOR , DEFAULT_COLUMN_SEPARATOR , CompositeFormat . getDefaultNumberFormat () ) ; }
DecompositionSolver es = new EigenDecomposition ( m ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m ) . getSolver () ;
if ( entry < minValue ) { minValue = entry ; minPos = i ; }
if ( p < NUMBER_CONSTANT ) { s = - s ; }
catch ( Exception e ) { throw new MathIllegalStateException ( LocalizedFormats.SIMPLE_MESSAGE , e . getMessage () ) ; }
{ if ( ! Precision . equals ( imagEigenvalues [ i ] , NUMBER_CONSTANT , EPSILON ) ) { return true ; } }
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , realMatrixFormat . parse ( source , pos ) ) ;
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , realMatrixFormat . parse ( source , pos ) ) ;
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , realMatrixFormat . parse ( source , pos ) ) ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
DifferentiableUnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
final UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
{ return delegate . nextZipf ( numberOfElements , exponent ) ; }
{ return delegate . nextWeibull ( shape , scale ) ; }
{ return delegate . nextT ( df ) ; }
{ return delegate . nextPascal ( r , p ) ; }
{ return delegate . nextHypergeometric ( populationSize , numberOfSuccesses , sampleSize ) ; }
{ return delegate . nextF ( numeratorDf , denominatorDf ) ; }
{ return delegate . nextChiSquare ( df ) ; }
{ return delegate . nextCauchy ( median , scale ) ; }
{ return delegate . nextBinomial ( numberOfTrials , probabilityOfSuccess ) ; }
{ return delegate . nextBeta ( alpha , beta ) ; }
{ return delegate . nextUniform ( lower , upper ) ; }
double dotProduct = new IterativeLegendreGaussIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . integrate ( NUMBER_CONSTANT , f , a , b ) ;
@ Override public int hashCode () { throw new MathUnsupportedOperationException () ; }
{ throw new MathUnsupportedOperationException () ; }
final double x = randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
fillBinStats ( new StreamDataAdapter ( in ) ) ;
final UnivariateDifferentiableFunction sPrime = new Sqrt () ;
final UnivariateDifferentiableFunction f = new QuinticFunction () ;
UnivariateDifferentiableFunction f = new Sin () ;
final UnivariateDifferentiableFunction f
final UnivariateDifferentiableFunction f
UnivariateDifferentiableFunction f
final UnivariateDifferentiableFunction q = new QuinticFunction () ;
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.INDEX , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.INDEX , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.INDEX , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.INDEX , i ) ; }
final MultivariateDifferentiableVectorFunction problem ;
public CircleScalar () { points = new ArrayList < Vector2D > () ; }
{ gradient = f . gradient () ; return optimizeInternal ( maxEval , f , goalType , startPoint ) ; }
MultivariateDifferentiableVectorFunction problem
public CircleVectorial () { points = new ArrayList < Vector2D > () ; }
final Quaternion product = Quaternion . multiply ( inverseQ , q ) ;
{ return multiply ( this , q ) ; }
optimum = new PointValuePair ( fitfun . repairAndDecode ( bestArx . getColumn ( NUMBER_CONSTANT ) ) , isMinimize ? bestFitness : - bestFitness ) ;
final double tmp = wxi * xi / di ;
Iterator < Entry > it = iterator () ;
Iterator < Entry > it = iterator () ;
Iterator < Entry > it = iterator () ;
Iterator < Entry > it = iterator () ;
Iterator < Entry > it = v . iterator () ;
Iterator < Entry > it = v . iterator () ;
public double [] getStartPoint () { return start == null ? null : start . clone () ; }
{ return super . optimizeInternal ( maxEval , f , goalType , new InitialGuess ( startPoint ) ) ; }
public double [] getUpperBound () { return super . getUpperBound () ; }
public double [] getLowerBound () { return super . getLowerBound () ; }
Math . max ( NUMBER_CONSTANT , NUMBER_CONSTANT - dimension / ( NUMBER_CONSTANT + maxIterations ) )
final int dim = getDimension () ;
final int dim = getDimension () ;
final int dim = getDimension () ;
final double [] [] out = new double [ [ sampleSize ] [ dimension ] ;
{ random = rng ; dimension = n ; }
final int dim = d . getDimension () ;
final int dim = d . getDimension () ;
double [] insigma = point ( DIM + NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double [] insigma = point ( DIM , NUMBER_CONSTANT ) ;
double [] insigma = point ( DIM , NUMBER_CONSTANT ) ;
double [] insigma = point ( DIM , NUMBER_CONSTANT ) ;
jF = f ;
{ distribution . get ( i ) . reseedRandomGenerator ( i + NUMBER_CONSTANT + seed ) ; }
FUNC f
FUNC f
final RealMatrix d = MatrixUtils . createRealDiagonalMatrix ( eigenValues ) ;
RealMatrix m = MatrixUtils . createRealDiagonalMatrix ( diagonal ) ;
{ x = list . remove ( list . size () - NUMBER_CONSTANT ) . getInf () ; }
final double [] sigma = optim . computeSigma ( regress , NUMBER_CONSTANT ) ;
final double [] currentPoint = getStartPoint () ;
final double [] [] covMatrix = optimizer . computeCovariances ( paramFound , NUMBER_CONSTANT ) ;
final double [] [] covarMatrix = optimizer . computeCovariances ( solution , NUMBER_CONSTANT ) ;
qrDecomposition ( computeWeightedJacobian ( currentPoint ) ) ;
final RealMatrix j = computeWeightedJacobian ( params ) ;
final RealMatrix weightedJacobian = computeWeightedJacobian ( currentPoint ) ;
try { testStatistic . gTest ( expected , observed , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( OutOfRangeException ex ) {}
try { testStatistic . gTest ( expected , observed ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NotStrictlyPositiveException ex ) {}
final double residual = currentResiduals [ i ] ;
{ super . testAdd1000 () ; Assert . assertEquals ( STRING_CONSTANT + STRING_CONSTANT , NUMBER_CONSTANT , ( ( ResizableDoubleArray ) da ) . getCapacity () ) ; }
final ResizableDoubleArray other = ( ResizableDoubleArray ) object ;
{ final ResizableDoubleArray result = new ResizableDoubleArray () ; copy ( this , result ) ; return result ; }
hashData [ NUMBER_CONSTANT ] = expansionMode . hashCode () ;
{ if ( initialDoubleArray != null ) { eDA = new StatArray ( initialDoubleArray ) ; } }
{ if ( initialDoubleArray != null ) { eDA = new ResizableDoubleArray ( initialDoubleArray ) ; } }
{ this ( DEFAULT_INITIAL_CAPACITY , DEFAULT_EXPANSION_FACTOR , DEFAULT_CONTRACTION_DELTA + DEFAULT_EXPANSION_FACTOR , ExpansionMode.MULTIPLICATIVE , initialArray ) ; }
hashData [ NUMBER_CONSTANT ] = new Float ( contractionCriterion ) . hashCode () ;
result = result && ( other.contractionCriterion == contractionCriterion ) ;
dest.contractionCriterion = source.contractionCriterion ;
{ checkContractExpand ( getContractionCriterion () , expansionFactor ) ; synchronized ( this ) { this . expansionFactor = expansionFactor ; } }
{ checkContractExpand ( contractionCriteria , getExpansionFactor () ) ; synchronized ( this ) { this . contractionCriterion = contractionCriteria ; } }
public double getContractionCriterion () { return contractionCriterion ; }
{ super ( relativeThreshold , absoluteThreshold ) ; maxIterationCount = ITERATION_CHECK_DISABLED ; }
@ Deprecated public SimpleVectorValueChecker () { maxIterationCount = ITERATION_CHECK_DISABLED ; }
{ super ( relativeThreshold , absoluteThreshold ) ; maxIterationCount = ITERATION_CHECK_DISABLED ; }
@ Deprecated public SimpleValueChecker () { maxIterationCount = ITERATION_CHECK_DISABLED ; }
{ super ( relativeThreshold , absoluteThreshold ) ; maxIterationCount = ITERATION_CHECK_DISABLED ; }
@ Deprecated public SimplePointChecker () { maxIterationCount = ITERATION_CHECK_DISABLED ; }
NaturalRanking ranking = new NaturalRanking ( NaNStrategy.MAXIMAL , TiesStrategy.MINIMUM ) ;
{ super ( relativeThreshold , absoluteThreshold ) ; maxIterationCount = ITERATION_CHECK_DISABLED ; }
@ Deprecated public SimpleUnivariateValueChecker () { maxIterationCount = ITERATION_CHECK_DISABLED ; }
if ( y >= TWO_POWER_53 || y <= - TWO_POWER_53 ) { return pow ( - x , y ) ; }
RandomDataGenerator randomData
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataGenerator () ) ; }
RandomDataGenerator randomData
this . q0 = scalar ;
if ( diagonalOnly <= NUMBER_CONSTANT ) { updateCovariance ( hsig , bestArx , arz , arindex , xold ) ; } else { updateCovarianceDiagonalOnly ( hsig , bestArz ) ; }
if ( diagonalOnly <= NUMBER_CONSTANT ) { updateCovariance ( hsig , bestArx , arz , arindex , xold ) ; } else { updateCovarianceDiagonalOnly ( hsig , bestArz ) ; }
final CodyWaite cw = new CodyWaite ( xa ) ;
final CodyWaite cw = new CodyWaite ( xa ) ;
final CodyWaite cw = new CodyWaite ( xa ) ;
@ Override public void reseedRandomGenerator ( long seed ) { reSeed ( seed ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , ( RandomGenerator ) null ) ; }
@ Override public void reseedRandomGenerator ( long seed ) { randomData . reSeed ( seed ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataImpl () ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataGenerator () ) ; }
filePointer = new BufferedReader ( new InputStreamReader ( valuesFileURL . openStream () , STRING_CONSTANT ) ) ;
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( problem . weight () )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( circle . weight () )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( function . getWeight () )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( w )
new Weight ( w )
new Weight ( w )
new Weight ( w )
new Weight ( weights )
new Weight ( function . getWeight () )
new Weight ( w )
new Weight ( weights )
new Weight ( weights )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( circle . weight () )
new Weight ( weights )
new Weight ( w )
new Weight ( problem . weight () )
{ this ( d , true ) ; }
public SimplexSolver ( final double epsilon ) { this ( epsilon , DEFAULT_ULPS , DEFAULT_CUT_OFF ) ; }
if ( FastMath . abs ( result ) < cutOff ) { result = NUMBER_CONSTANT ; }
{ this ( f , constraints , goalType , restrictToNonNegative , epsilon , SimplexSolver.DEFAULT_ULPS , SimplexSolver.DEFAULT_CUT_OFF ) ; }
final T [] out = MathArrays . buildArray ( field , nCols ) ;
final T [] out = MathArrays . buildArray ( field , nCols ) ;
final T [] out = MathArrays . buildArray ( field , nRows ) ;
final T [] out = MathArrays . buildArray ( field , nRows ) ;
final T [] out = MathArrays . buildArray ( field , nRows ) ;
final T [] out = MathArrays . buildArray ( field , nCols ) ;
final T [] [] data = MathArrays . buildArray ( field , getRowDimension () , getColumnDimension () ) ;
final T [] out = MathArrays . buildArray ( getField () , columns ) ;
final T [] out = MathArrays . buildArray ( getField () , rows ) ;
final T [] out = MathArrays . buildArray ( getField () , rows ) ;
final T [] out = MathArrays . buildArray ( getField () , columns ) ;
final T [] outData = MathArrays . buildArray ( getField () , rows ) ;
final T [] outData = MathArrays . buildArray ( getField () , columns ) ;
final T [] [] data = MathArrays . buildArray ( getField () , getRowDimension () , getColumnDimension () ) ;
{ blocks = MathArrays . buildArray ( getField () , blockRows * blockColumns , - NUMBER_CONSTANT ) ; }
final T [] out = MathArrays . buildArray ( field , data.length + NUMBER_CONSTANT ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
data = MathArrays . buildArray ( field , v1.length + v2.length ) ;
data = MathArrays . buildArray ( field , v1.length + v2.data.length ) ;
data = MathArrays . buildArray ( field , v1.data.length + v2.length ) ;
data = MathArrays . buildArray ( field , v1.data.length + v2.data.length ) ;
data = MathArrays . buildArray ( field , v . getDimension () ) ;
data = MathArrays . buildArray ( field , size ) ;
data = MathArrays . buildArray ( field , size ) ;
final T [] [] out = MathArrays . buildArray ( getField () , nRows , getColumnDimension () ) ;
final T [] out = MathArrays . buildArray ( getField () , nCols ) ;
final T [] out = MathArrays . buildArray ( getField () , nRows ) ;
data = MathArrays . buildArray ( getField () , subMatrix.length , nCols ) ;
final T [] [] outData = MathArrays . buildArray ( getField () , nRows , nCols ) ;
final T [] [] outData = MathArrays . buildArray ( getField () , rowCount , columnCount ) ;
final T [] [] outData = MathArrays . buildArray ( getField () , rowCount , columnCount ) ;
data = MathArrays . buildArray ( getField () , nRows , NUMBER_CONSTANT ) ;
{ super ( field , rowDimension , columnDimension ) ; data = MathArrays . buildArray ( field , rowDimension , columnDimension ) ; }
T [] res = MathArrays . buildArray ( field , virtualSize ) ;
int exponent = ( int ) ( y . intLog10 () * NUMBER_CONSTANT ) ;
{ return new Decimal64 ( FastMath . IEEEremainder ( value , a.value ) ) ; }
{ return new Decimal64 ( FastMath . IEEEremainder ( value , a ) ) ; }
return ePlus . subtract ( eMinus ) . divide ( ePlus . add ( eMinus ) ) ;
DerivativeStructure ref = dsX . subtract ( x - FastMath . IEEEremainder ( x , y ) ) ;
DerivativeStructure sAccurate = FieldVector3D . dotProduct ( u1 , u2 ) ;
Assert . assertEquals ( - NUMBER_CONSTANT , FieldVector3D . dotProduct ( r . getAxis () , reverted . getAxis () ) . getReal () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( - NUMBER_CONSTANT , FieldVector3D . dotProduct ( r . getAxis () , reverted . getAxis () ) . getReal () , NUMBER_CONSTANT ) ;
randomData = new RandomDataGenerator ( randomGenerator ) ;
{ super(); this . tiesStrategy = TiesStrategy.RANDOM ; nanStrategy = DEFAULT_NAN_STRATEGY ; randomData = new RandomDataGenerator ( randomGenerator ) ; }
{ super(); this . nanStrategy = nanStrategy ; this . tiesStrategy = tiesStrategy ; randomData = new RandomDataGenerator () ; }
{ super(); this . tiesStrategy = tiesStrategy ; nanStrategy = DEFAULT_NAN_STRATEGY ; randomData = new RandomDataGenerator () ; }
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
@ Test ( expected = NumberIsTooLargeException . class )
{ getRandomGenerator () . setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ getRandomGenerator () . setSeed ( seed ) ; }
final RandomGenerator generator = getRandomGenerator () ;
{ return new FDistribution ( getRandomGenerator () , numeratorDf , denominatorDf , FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ChiSquaredDistribution ( getRandomGenerator () , df , ChiSquaredDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new CauchyDistribution ( getRandomGenerator () , median , scale , CauchyDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new BinomialDistribution ( getRandomGenerator () , numberOfTrials , probabilityOfSuccess ) . sample () ; }
{ return new BetaDistribution ( getRandomGenerator () , alpha , beta , BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ZipfDistribution ( getRandomGenerator () , numberOfElements , exponent ) . sample () ; }
{ return new WeibullDistribution ( getRandomGenerator () , shape , scale , WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new TDistribution ( getRandomGenerator () , df , TDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new PascalDistribution ( getRandomGenerator () , r , p ) . sample () ; }
{ return new HypergeometricDistribution ( getRandomGenerator () , populationSize , numberOfSuccesses , sampleSize ) . sample () ; }
{ return new GammaDistribution ( getRandomGenerator () , shape , scale , GammaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ExponentialDistribution ( getRandomGenerator () , mean , ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
return sigma * getRandomGenerator () . nextGaussian () + mu ;
{ return new PoissonDistribution ( getRandomGenerator () , mean , PoissonDistribution.DEFAULT_EPSILON , PoissonDistribution.DEFAULT_MAX_ITERATIONS ) . sample () ; }
RandomGenerator ran = getRandomGenerator () ;
if ( real == NUMBER_CONSTANT && imaginary == NUMBER_CONSTANT ) { return INF ; }
@ Test public void testReciprocalZero () { Assert . assertEquals ( Complex.ZERO . reciprocal () , Complex.INF ) ; }
{ return ( ( Float . floatToRawIntBits ( f ) > > > NUMBER_CONSTANT ) & NUMBER_CONSTANT ) - NUMBER_CONSTANT ; }
final long bits = Double . doubleToRawLongBits ( d ) ;
final long bits = Double . doubleToRawLongBits ( d ) ;
return abs ( x - Double . longBitsToDouble ( Double . doubleToRawLongBits ( x ) ^ NUMBER_CONSTANT ) ) ;
{ long bits = Double . doubleToRawLongBits ( x ) ; if ( bits < NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
{ long bits = Double . doubleToRawLongBits ( x ) ; if ( bits < NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
long inbits = Double . doubleToRawLongBits ( x ) ;
long bits = Double . doubleToRawLongBits ( x ) ;
long bits = Double . doubleToRawLongBits ( x ) ;
long xl = Double . doubleToRawLongBits ( d ) ;
File file = new File ( url . toURI () ) ;
{ return Double . longBitsToDouble ( MASK_NON_SIGN_LONG & Double . doubleToRawLongBits ( x ) ) ; }
{ return Float . intBitsToFloat ( MASK_NON_SIGN_INT & Float . floatToRawIntBits ( x ) ) ; }
{ this ( new Well19937c () , lower , upper ) ; }
sum += FastMath . pow ( distA / distB , NUMBER_CONSTANT / ( fuzziness - NUMBER_CONSTANT ) ) ;
final double u = FastMath . pow ( membershipMatrix [ i ] [ j ] , fuzziness ) ;
final long grayCode = i ^ ( i > > NUMBER_CONSTANT ) ;
int count = samples / centers ;
{ this . a [ i ] [ j ] = a [ i * N + j ] ; }
Assert . assertArrayEquals ( expected , actual , NUMBER_CONSTANT ) ;
{ final double midPoint = min + NUMBER_CONSTANT * diff ; return diff * computeObjectiveValue ( midPoint ) ; }
{ new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertFalse ( random . nextBoolean () ) ;
{ result [ i ] = r . call () . doubleValue () ; }
final int uniDimIndex = iter . next () . intValue () ;
{ super ( specific , value , INTEGER_ZERO , true ) ; }
public NotPositiveException ( Number value ) { super ( value , INTEGER_ZERO , true ) ; }
{ super ( specific , INTEGER_ZERO , arguments ) ; }
{ return expected [ index ] . intValue () ; }
{ return wrong [ index ] . intValue () ; }
{ super ( specific , value , INTEGER_ZERO , false ) ; }
public NotStrictlyPositiveException ( Number value ) { super ( value , INTEGER_ZERO , false ) ; }
{ super ( specific , Integer . valueOf ( wrong ) , Integer . valueOf ( expected ) ) ; dimension = expected ; }
final RandomGenerator secRan = getSecRan () ;
T withConvergenceChecker ( ConvergenceChecker < PAIR > checker ) ;
{ term *= FastMath . pow ( delta [ k ] , orders [ k ] ) / CombinatoricsUtils . factorial ( orders [ k ] ) ; }
RandomDataGenerator randomData = new RandomDataGenerator () ;
{ coeff [ i ] [ j ] = ( int ) CombinatoricsUtils . binomialCoefficient ( i , j ) ; }
long expected = CombinatoricsUtils . binomialCoefficient ( i + j , i ) ;
double binomial = CombinatoricsUtils . binomialCoefficient ( v + i , i ) ;
double refDer = - CombinatoricsUtils . factorial ( n - NUMBER_CONSTANT ) / FastMath . pow ( - x , n ) ;
ArithmeticUtils . pow ( - NUMBER_CONSTANT , i ) * CombinatoricsUtils . factorial ( i ) / FastMath . pow ( x , i + NUMBER_CONSTANT )
double inv = NUMBER_CONSTANT / CombinatoricsUtils . factorial ( i ) ;
AbstractOptimizer < PAIR , OPTIM > other
return Double . parseDouble ( str ) ;
{ val = Double . parseDouble ( str ) ; sampleStats . addValue ( val ) ; }
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > ( originalConstraints . size () ) ;
List < Edge > edges = new ArrayList < Edge > ( n ) ;
final List < Segment > segments = new ArrayList < Segment > ( list . size () ) ;
final List < EventHandler > list = new ArrayList < EventHandler > ( eventsStates . size () ) ;
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > ( originalConstraints . size () ) ;
List < int [] > row = new ArrayList < int [] > ( dRow.length * NUMBER_CONSTANT ) ;
final List < Segment > segments = new ArrayList < Segment > ( list . size () ) ;
final double [] vectorData ;
{ this ( value , DEFAULT_EPSILON , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , f . getCount ( THREE ) ) ;
f . addValue ( THREE ) ;
{ return new Combinations ( n , k ) . iterator () ; }
int [] index = MathArrays . natural ( n ) ;
{ final int [] natural = MathArrays . natural ( NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , natural.length ) ; }
AbstractLeastSquaresOptimizer < OPTIM > other
if ( FastMath . abs ( a0 ) > overflow ) { throw new FractionConversionException ( value , a0 , NUMBER_CONSTANT ) ; }
{ return NUMBER_CONSTANT + NUMBER_CONSTANT * MathUtils . hash ( value ) + NUMBER_CONSTANT * derivatives . hashCode () ; }
mult . multiplyInPlace ( var1 ) ;
{ return MathArrays . verifyValues ( values , weights , begin , length , allowEmpty ) ; }
{ return MathArrays . verifyValues ( values , weights , begin , length , false ) ; }
{ return MathArrays . verifyValues ( values , begin , length , allowEmpty ) ; }
{ return MathArrays . verifyValues ( values , begin , length , false ) ; }
w -= NUMBER_CONSTANT ;
num %= den ;
if ( i > NUMBER_CONSTANT ) { randInt > > = NUMBER_CONSTANT ; }
for ( final T a : data ) { h ^= a . hashCode () ; }
rhs [ m ] /= X ;
coeff1 /= pc2 ;
bits &= NUMBER_CONSTANT ;
den += NUMBER_CONSTANT ;
trial *= NUMBER_CONSTANT ;
den += NUMBER_CONSTANT ;
{ bytes [ i ++ ] = ( byte ) ( random & NUMBER_CONSTANT ) ; random > > = NUMBER_CONSTANT ; }
if ( result == NUMBER_CONSTANT ) { result *= x ; }
za *= ya ;
e > > = NUMBER_CONSTANT ;
z *= lnb ;
xl &= MASK_30BITS ;
r *= rnd ;
extra -= rh * RADIX ;
{ while ( NUMBER_CONSTANT == n % p ) { n /= p ; factors . add ( p ) ; } }
n |= NUMBER_CONSTANT ;
xx += NUMBER_CONSTANT / NUMBER_CONSTANT ;
iter ++ ;
{ data [ i ] /= d ; }
{ data [ i ] *= d ; }
{ data [ i ] -= d ; }
{ data [ i ] += d ; }
k += m ;
coeff1 /= pc2 ;
{ c [ NUMBER_CONSTANT ] ++ ; return ret ; }
coeff1 /= pc2 ;
{ m > > = NUMBER_CONSTANT ; ++ k ; }
e > > = NUMBER_CONSTANT ;
e > > = NUMBER_CONSTANT ;
e > > = NUMBER_CONSTANT ;
v *= v ;
{ ret = scale * FastMath . pow ( - FastMath . log1p ( - p ) , NUMBER_CONSTANT / shape ) ; }
( a * FastMath . log ( x ) ) + ( b * FastMath . log1p ( - x ) )
return ( FastMath . expm1 ( ss ) ) * FastMath . exp ( NUMBER_CONSTANT * scale + ss ) ;
minadj /= divisor.mant [ mant.length - NUMBER_CONSTANT ] + NUMBER_CONSTANT ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= FastMath . sqrt ( sp ) ;
{ double f = FastMath . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= FastMath . sqrt ( sp ) ;
{ double f = FastMath . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
final double max = FastMath.PI ;
{ FunctionUtils . sample ( new Sin () , NUMBER_CONSTANT , FastMath.PI , - NUMBER_CONSTANT ) ; }
double x = FastMath . random () * NUMBER_CONSTANT ;
double x = FastMath . random () ;
- NUMBER_CONSTANT / ( a * a ) - NUMBER_CONSTANT + FastMath . cos ( a )
minDiff = FastMath . min ( minDiff , boundDifference [ i ] ) ;
minDiff = FastMath . min ( minDiff , boundDifference [ i ] ) ;
{ d [ r ] [ c ] = FastMath . sqrt ( m . getEntry ( r , c ) ) ; }
{ d [ r ] [ c ] = FastMath . log ( m . getEntry ( r , c ) ) ; }
double diff = FastMath . abs ( x [ i ] - repaired [ i ] ) ;
( NUMBER_CONSTANT - ccovmu ) * NUMBER_CONSTANT * mueff / ( FastMath . pow ( dimension + NUMBER_CONSTANT , NUMBER_CONSTANT ) + NUMBER_CONSTANT * mueff )
{ d [ r ] [ c ] = FastMath . sqrt ( m . getEntry ( r , c ) ) ; }
{ d [ r ] [ c ] = FastMath . log ( m . getEntry ( r , c ) ) ; }
double diff = FastMath . abs ( x [ i ] - repaired [ i ] ) ;
( NUMBER_CONSTANT - ccovmu ) * NUMBER_CONSTANT * mueff / ( FastMath . pow ( dimension + NUMBER_CONSTANT , NUMBER_CONSTANT ) + NUMBER_CONSTANT * mueff )
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= FastMath . sqrt ( sp ) ;
{ double f = FastMath . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
double diff = FastMath . abs ( constantValue - filter . getStateEstimation () [ NUMBER_CONSTANT ] ) ;
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , FastMath . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , FastMath . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , FastMath . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= FastMath . sqrt ( sp ) ;
{ double f = FastMath . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
a1 = FastMath . sqrt ( FastMath.PI * twolpd ) * FastMath . exp ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * lambda ) )
ret += c [ i ] * ArithmeticUtils . pow ( n , i ) ;
for ( int i = NUMBER_CONSTANT ; i < length ; i ++ ) { sample [ i ] = FastMath . random () ; }
System . arraycopy ( seed , NUMBER_CONSTANT , v , NUMBER_CONSTANT , FastMath . min ( seed.length , v.length ) ) ;
expected = FastMath . abs ( period ) - delta ;
final int shift = FastMath . min ( aTwos , bTwos ) ;
double xabs = FastMath . abs ( v [ i ] ) ;
int shift = FastMath . max ( numerator . bitLength () , denominator . bitLength () ) - FastMath . getExponent ( Float.MAX_VALUE ) ;
int shift = FastMath . max ( numerator . bitLength () , denominator . bitLength () ) - FastMath . getExponent ( Double.MAX_VALUE ) ;
double denom = FastMath . abs ( val ) < EPS_MIN ? NUMBER_CONSTANT * EPS_MIN : NUMBER_CONSTANT * val ;
int k = ( int ) FastMath . ceil ( n * d ) ;
final int k = ( int ) FastMath . ceil ( n * d ) ;
final int k = ( int ) FastMath . ceil ( n * d ) ;
{ return NUMBER_CONSTANT - NUMBER_CONSTANT * FastMath . pow ( NUMBER_CONSTANT - d , n ) ; }
double denom = FastMath . abs ( val ) < EPS_MIN ? NUMBER_CONSTANT * EPS_MIN : NUMBER_CONSTANT * val ;
new Fraction ( ( ( FastMath . abs ( w ) * d ) + n ) * MathUtils . copySign ( NUMBER_CONSTANT , w ) , d )
num = FastMath . abs ( num ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
h += p_i * FastMath . log ( p_i ) ;
h += p_ij * FastMath . log ( p_ij ) ;
if ( FastMath . abs ( sumExpected - sumObserved ) > NUMBER_CONSTANT ) { ratio = sumObserved / sumExpected ; rescale = true ; }
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
public double estimateRegressionStandardError () { return FastMath . sqrt ( estimateErrorVariance () ) ; }
System . arraycopy ( seed , NUMBER_CONSTANT , rsl , NUMBER_CONSTANT , FastMath . min ( seedLen , rslLen ) ) ;
FastMath . sqrt ( d [ col ] ) < tol [ col ]
FastMath . sqrt ( d [ i ] ) < tol [ i ]
final double result = NUMBER_CONSTANT * Erf . erfc ( ref [ i ] [ NUMBER_CONSTANT ] / FastMath . sqrt ( NUMBER_CONSTANT ) ) ;
final double originalDelta = FastMath . random () ;
final double gn = factor1 * FastMath . log ( qExp1 ) * oneOverN ;
{ public double value ( double x ) { return NUMBER_CONSTANT / ( NUMBER_CONSTANT * FastMath . sqrt ( x ) ) ; } }
f = new UnivariateFunction () { public double value ( double x ) { return FastMath . sqrt ( x ) ; } }
{ minValue = entry ; minPos = i ; if ( pivotSelection == PivotSelectionRule.BLAND && isValidPivotColumn ( tableau , i ) ) { break; } }
this . pivotSelection = PivotSelectionRule.DANTZIG ;
solution = new SimplexSolver () . optimize ( DEFAULT_MAX_ITER , f , new LinearConstraintSet ( constraints ) , GoalType.MINIMIZE , new NonNegativeConstraint ( true ) , PivotSelectionRule.BLAND )
{ this ( f , constraints , goalType , restrictToNonNegative , epsilon , SimplexSolver.DEFAULT_ULPS ) ; }
if ( Precision . compareTo ( entry , NUMBER_CONSTANT , cutOff ) > NUMBER_CONSTANT ) { return true ; }
final Point < S > point
final Point < Euclidean2D > point
final Point < Euclidean2D > point
final Point < Euclidean2D > point
final Point < Euclidean1D > point
final Point < Euclidean2D > point
Point < S > point
final Point < Euclidean3D > point
final Point < Euclidean3D > point
final Point < Euclidean1D > point
final Point < Euclidean3D > point
final Point < S > point
{ final Vector2D v2 = ( Vector2D ) v ; return MathArrays . linearCombination ( x , v2.x , y , v2.y ) ; }
final Point < S > barycenter
final Point < S > point
final Point < S > point
final Point < Euclidean1D > point
public ArcsSet wholeSpace () { return new ArcsSet ( tolerance ) ; }
{ return Vector3D . angle ( pole , direction ) - NUMBER_CONSTANT * FastMath.PI ; }
public SphericalPolygonsSet wholeSpace () { return new SphericalPolygonsSet ( tolerance ) ; }
public SubCircle wholeHyperplane () { return new SubCircle ( this , new ArcsSet ( tolerance ) ) ; }
{ this ( circle.pole , circle.x , circle.y , circle.tolerance ) ; }
final Vector1D x = thisLine . toSubSpace ( ( Point < Euclidean2D > ) crossing ) ;
final Vector1D x = thisLine . toSubSpace ( ( Point < Euclidean2D > ) crossing ) ;
final double offset = plane . getOffset ( ( Point < Euclidean3D > ) point ) ;
Point < Euclidean2D > p
Point < Euclidean1D > p
Point < Euclidean3D > v
final Vector3D point = line . toSpace ( ( Point < Euclidean1D > ) Vector1D.ZERO ) ;
public SubChord copySelf () { return new SubChord ( chord . copySelf () , limits ) ; }
{ this . upper = MathUtils.TWO_PI + lower ; }
Arc arc = new Arc ( NUMBER_CONSTANT , FastMath . nextAfter ( NUMBER_CONSTANT , Double.POSITIVE_INFINITY ) , Precision.EPSILON ) ;
Segment segment = new Segment ( p1 , p2 , new Line ( p1 , p2 , NUMBER_CONSTANT ) ) ;
final EdgesBuilder visitor = new EdgesBuilder ( root , getTolerance () ) ;
{ return new SphericalPolygonsSet ( tree , getTolerance () ) ; }
{ super ( boundary , tolerance ) ; }
{ super ( tree , tolerance ) ; }
public SphericalPolygonsSet ( final double tolerance ) { super ( tolerance ) ; }
return getRemainingRegion () . side ( new OrientedPoint ( x , direct , thisLine . getTolerance () ) ) ;
public SubLine wholeLine () { return new SubLine ( this , new IntervalsSet ( tolerance ) ) ; }
{ return distance ( p ) < tolerance ; }
final BSPTree < S > cell = node . getCell ( point , tolerance ) ;
{ return new PolyhedronsSet ( tree , getTolerance () ) ; }
public IntervalsSet wholeSpace () { return new IntervalsSet ( tolerance ) ; }
return new OrientedPoint ( newLoc , op . isDirect () , originalLine.tolerance ) . wholeHyperplane () ;
{ return FastMath . abs ( getOffset ( p ) ) < tolerance ; }
public PolygonsSet wholeSpace () { return new PolygonsSet ( tolerance ) ; }
public SubLine wholeHyperplane () { return new SubLine ( this , new IntervalsSet ( tolerance ) ) ; }
if ( FastMath . abs ( d ) < tolerance ) { return null ; }
{ return new PolygonsSet ( tree , getTolerance () ) ; }
if ( line == null ) { line = new Line ( start . getLocation () , end . getLocation () , hyperplaneThickness ) ; }
{ return new ArcsSet ( tree , getTolerance () ) ; }
{ return new LimitAngle ( new S1Point ( alpha ) , true , getTolerance () ) . wholeHyperplane () ; }
{ return new LimitAngle ( new S1Point ( alpha ) , false , getTolerance () ) . wholeHyperplane () ; }
{ super ( boundary , tolerance ) ; }
{ super ( tree , tolerance ) ; }
public ArcsSet ( final double tolerance ) { super ( tolerance ) ; }
Segment segment = new Segment ( start , end , new Line ( start , end , NUMBER_CONSTANT ) ) ;
{ return new Line ( start , end , NUMBER_CONSTANT ) . wholeHyperplane () ; }
return new PolygonsSet ( edges , NUMBER_CONSTANT ) ;
final BoundaryProjector projector = new BoundaryProjector ( polyhedronsSet . getTolerance () ) ;
public PolyhedronsSet wholeSpace () { return new PolyhedronsSet ( tolerance ) ; }
public SubPlane wholeHyperplane () { return new SubPlane ( this , new PolygonsSet ( tolerance ) ) ; }
final Plane plane = new Plane ( origin . add ( translation ) , w , tolerance ) ;
PolyhedronsSet tree = new PolyhedronsSet ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new IntervalsSet ( tree , getTolerance () ) ; }
boundary . add ( new LimitAngle ( new S1Point ( MathUtils.TWO_PI - NUMBER_CONSTANT ) , true , NUMBER_CONSTANT ) . wholeHyperplane () ) ;
( Boolean ) getFirstLeaf ( getTree ( false ) ) . getAttribute ()
Assert . assertTrue ( projection . getOriginal () == v ) ;
Iterable < P > points
final Iterable < P > points
ConvexHull2D hull = generator . generate ( reducePoints ( points ) ) ;
GrahamScan generator = new GrahamScan () ;
RandomGenerator random = new MersenneTwister () ;
@ Before public void setUp () { generator = createConvexHullGenerator ( false ) ; random = new MersenneTwister ( NUMBER_CONSTANT ) ; }
final Iterable < Vector2D > points
ConvexHullGenerator2D generator = new MonotoneChain ( true ) ;
public Segment [] getLineSegments () { return retrieveLineSegments () . clone () ; }
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.PLUS_I ) . ballOnSupport ( support ) ;
cap = new SphericalCapGenerator ( new Vector3D ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ) . ballOnSupport ( support )
cap = new SphericalCapGenerator ( new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . ballOnSupport ( support )
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.PLUS_K ) . ballOnSupport ( support ) ;
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.PLUS_K ) . ballOnSupport ( support ) ;
{ return new EnclosingBall < Sphere2D , S2Point > ( new S2Point ( inside ) , - NUMBER_CONSTANT ) ; }
@ Override protected ConvexHullGenerator2D createConvexHullGenerator ( boolean includeCollinearPoints ) { return new MonotoneChain ( includeCollinearPoints ) ; }
{ return getOptimizer () . optimize ( getProblem ( points ) ) . getPoint () ; }
optimizer = new LevenbergMarquardtOptimizer () . withInitialStepBoundFactor ( initialStepBoundFactor ) . withCostRelativeTolerance ( costRelativeTolerance ) . withParameterRelativeTolerance ( parRelativeTolerance ) . withOrthoTolerance ( orthoTolerance ) . withRankingThreshold ( Precision.SAFE_MIN )
{ return new LeastSquaresProblemImpl ( model , jacobian , observed , start , checker , maxEvaluations , maxIterations ) ; }
public double [] computeValue () { return this . values . toArray () ; }
@ Test public void testGaussNewtonQR ( ) throws Exception { check ( new GaussNewtonOptimizer ( Decomposition.QR ) ) ; }
@ Test public void testGaussNewtonLU ( ) throws Exception { check ( new GaussNewtonOptimizer ( Decomposition.LU ) ) ; }
final ConvergenceChecker < Evaluation > checker
final ConvergenceChecker < Evaluation > checker
final ConvergenceChecker < Evaluation > checker
final ConvergenceChecker < Evaluation > checker
final ConvergenceChecker < Evaluation > checker
{ return new LeastSquaresBuilder () . checkerPair ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . maxEvaluations ( NUMBER_CONSTANT ) . maxIterations ( getMaxIterations () ) ; }
builder ( circle ) . checkerPair ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . maxIterations ( Integer.MAX_VALUE )
function . checkTheoreticalMinParams ( optimum . getPoint () . toArray () ) ;
RealVector point
RealVector point
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
final RealVector point
final RealVector point
final RealVector start
final RealVector target
public RealVector computeValue () { return this . weightSqrt . operate ( unweighted . computeValue () ) ; }
catch ( NonPositiveDefiniteMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM , e ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM , e ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM , e ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertTrue ( optimum . getRMS () > NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
RealVector getValue ( ) ;
final double cost = lsp . evaluate ( params ) . getCost () ;
final RealVector sigma = lsp . evaluate ( regress ) . getSigma ( NUMBER_CONSTANT ) ;
final RealVector sigma = lsp . evaluate ( init ) . getSigma ( NUMBER_CONSTANT ) ;
function . checkTheoreticalMinCost ( optimum . getRMS () ) ;
final double [] asymptoticStandardErrorFound = optimum . getSigma ( NUMBER_CONSTANT ) . toArray () ;
final RealMatrix covarMatrix = optimum . getCovariances ( NUMBER_CONSTANT ) ;
Assert . assertArrayEquals ( evaluation . getResiduals () . toArray () , new double [] { NUMBER_CONSTANT , - NUMBER_CONSTANT } , Precision.EPSILON ) ;
Assert . assertNotSame ( STRING_CONSTANT , v1 . getDataRef () , v_copy . toArray () ) ;
{ return new LocalLeastSquaresProblem ( model , observed , start , checker , maxEvaluations , maxIterations ) ; }
assertEquals ( TOl , optimum . getResiduals () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
line = new LineSearch ( this , lineRel , lineAbs ) ;
line = new LineSearch ( this , lineRel , lineAbs , NUMBER_CONSTANT ) ;
{ this ( updateFormula , checker , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , new IdentityPreconditioner () ) ; }
penalty += diff ;
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( getX () , threshold ) ; }
public RealVector getResiduals () { return residuals ; }
public RealVector getPoint () { return point ; }
public RealMatrix getJacobian () { return jacobian ; }
super ( randomData . getRandomGenerator () ) ;
@ Override protected RealDistribution getKernel ( SummaryStatistics bStats ) { return new ConstantRealDistribution ( bStats . getMean () ) ; }
return new Median () . withEstimationType ( type ) . withNaNStrategy ( strategy ) ;
double result = new Percentile ( p ) . withEstimationType ( e ) . withNaNStrategy ( nanStrategy ) . evaluate ( data ) ;
{ new Percentile ( NUMBER_CONSTANT ) . withEstimationType ( Percentile.EstimationType.LEGACY ) . withNaNStrategy ( null ) ; Assert . fail ( STRING_CONSTANT + STRING_CONSTANT ) ; }
new Percentile ( NUMBER_CONSTANT ) . withEstimationType ( Percentile.EstimationType.R_9 ) . withNaNStrategy ( NaNStrategy.FAILED ) . evaluate ( specialValues , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new Percentile ( quantile ) . withEstimationType ( type ) . withNaNStrategy ( nanStrategy ) . withPivotingStrategy ( pivotingStrategy ) ; }
final BicubicSplineInterpolator bsi = new BicubicSplineInterpolator ( true ) ;
return new BicubicSplineInterpolatingFunction ( xval , yval , fval , dFdX , dFdY , d2FdXdY , initializeDerivatives ) ;
final FieldMatrix < BigFraction > H = this . createExactH ( d , n ) ;
final Percentile p = getUnivariateStatistic () ;
final Percentile p = getUnivariateStatistic () ;
final Percentile p = getUnivariateStatistic () ;
{ for ( final Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testWeightedConsistency () ; } }
{ for ( final Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testEvaluateArraySegment () ; } }
{ for ( final Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testEvaluateArraySegmentWeighted () ; } }
final UnivariateStatistic percentile = getUnivariateStatistic () ;
final UnivariateStatistic percentile = getUnivariateStatistic () ;
final Percentile percentile = new Percentile ( NUMBER_CONSTANT ) ;
{ return new Median ( getEstimationType () , newNaNStrategy , getKthSelector () ) ; }
{ return new Median ( newEstimationType , getNaNStrategy () , getKthSelector () ) ; }
kthSelector = original . getKthSelector () ;
final double Umin = ( long ) x.length * y.length - Umax ;
Assert . assertEquals ( NUMBER_CONSTANT , ( ( ResizableDoubleArray ) da ) . getContractionCriterion () , NUMBER_CONSTANT ) ;
ResizableDoubleArray testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ExpansionMode.ADDITIVE ) ;
testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ExpansionMode.ADDITIVE ) ;
ResizableDoubleArray testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ExpansionMode.ADDITIVE ) ;
RandomDataGenerator random = new RandomDataGenerator () ;
empiricalDistribution = new EmpiricalDistribution ( binCount , randomData . getRandomGenerator () ) ;
{ this . randomData = new RandomDataGenerator ( generator ) ; }
{ this . randomData = randomData . getDelegate () ; }
{ return ( MathUtils.PI_SQUARED / NUMBER_CONSTANT ) * ( NUMBER_CONSTANT / ( s * s ) ) ; }
final NormalDistribution standardNormal = new NormalDistribution ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final FDistribution fdist = new FDistribution ( null , a.dfbg , a.dfwg ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
final NormalDistribution standardNormal = new NormalDistribution ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final BinomialDistribution distribution = new BinomialDistribution ( null , numberOfTrials , probability ) ;
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( getX () , threshold ) ; }
t . insertInTree ( parentTree , isPlusChild , new VanishingToLeaf ( true ) ) ;
return MathArrays . linearCombination ( sin , otherL.sin , cos , otherL.cos ) >= NUMBER_CONSTANT ;
tree = region1 . getTree ( false ) . merge ( region2 . getTree ( false ) , new DifferenceMerger ( region1 , region2 ) )
{ unlinkReverse () ; originOffset = offset ; }
if ( p == NUMBER_CONSTANT ) { return Double.NEGATIVE_INFINITY ; } else if ( p == NUMBER_CONSTANT ) { return Double.POSITIVE_INFINITY ; }
{ vals = MathArrays . copyOf ( b , b.length ) ; nVals = n ; }
org.apache.commons.math4.stat.inference.ChiSquareTest csti = new org.apache.commons.math4.stat.inference.ChiSquareTest () ;
org.apache.commons.math4.stat.inference.ChiSquareTest csti = new org.apache.commons.math4.stat.inference.ChiSquareTest () ;
cachedTransform = org.apache.commons.math4.geometry.euclidean.twod.Line . getTransform ( at ) ;
cachedTransform = org.apache.commons.math4.geometry.euclidean.twod.Line . getTransform ( at ) ;
@ Test ( expected = org.apache.commons.math4.linear.SingularMatrixException . class )
( numIterations < maximumIterations ) && ( a > lowerBound || b < upperBound )
public Well19937c ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well19937c ( int seed ) { super ( K , seed ) ; }
public Well512a ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well512a ( int seed ) { super ( K , seed ) ; }
public Well44497b ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well44497b ( int seed ) { super ( K , seed ) ; }
public Well1024a ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well1024a ( int seed ) { super ( K , seed ) ; }
public Well44497a ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well44497a ( int seed ) { super ( K , seed ) ; }
public Well19937a ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well19937a ( int seed ) { super ( K , seed ) ; }
TestUtils . assertEquals ( m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . toArray () ) , preMultTest ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . toArray () ) , preMultTest ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI ) ;
x = new UniformRealDistribution ( rng , lo , hi ) ;
x = new UniformRealDistribution ( rng , lo , hi ) ;
x = new UniformRealDistribution ( rng , lo , hi ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI ) ;
try { distribution . probability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
{ double actual = getDistribution () . probability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , actual , NUMBER_CONSTANT ) ; }
distribution . probability ( lower [ i ] , upper [ i ] )
final double withinBinKernelMass = kernel . probability ( lower , upper ) ;
try { distribution . probability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
distribution . logDensity ( cumulativeTestPoints [ i ] )
@ Test ( expected = NullArgumentException . class ) public void testNullFunction () { UnivariateSolverUtils . bracket ( null , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
try { StatUtils . min ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
try { StatUtils . max ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
try { StatUtils . mean ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
tournamentPopulation = new ListPopulation ( this . arity ) { @ Override public Population nextGeneration () { return null ; } }
delta = ( max - min ) / ( binCount ) ;
@ Override T reciprocal ( ) ;
delta = ( max - min ) / binCount ;
protected double getSolverAbsoluteAccuracy () { return SOLVER_DEFAULT_ABSOLUTE_ACCURACY ; }
UnivariateFunction dSpline = spline . polynomialSplineDerivative () ;
{ return FastMath . abs ( getOffset ( p ) ) < tolerance ; }
if ( direction . getNorm () < tolerance ) { return null ; }
m . incrementAll ( values ) ;
MathArrays . verifyValues ( values , begin , length ) && length > NUMBER_CONSTANT
MathArrays . verifyValues ( values , start , length ) ;
MathArrays . verifyValues ( values , begin , length ) ;
{ MathArrays . verifyValues ( values , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
ptile . incrementAll ( d ) ;
m . incrementAll ( values ) ;
catch ( MathIllegalArgumentException iae ) {}
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
catch ( MathIllegalArgumentException iae ) { return true ; }
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
try { stats . setWindowSize ( - NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException iae ) {}
{ try { new DummyBinaryChromosome ( repr ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException e ) {} }
catch ( MathIllegalArgumentException iae ) {}
final double Hs = nthHarmonic ;
final double Hs = nthHarmonic ;
return generalizedHarmonic ( x , exponent ) / nthHarmonic ;
return - FastMath . log ( x ) * exponent - FastMath . log ( nthHarmonic ) ;
if ( Double . isNaN ( x ) ) { return x ; }
if ( Double . isNaN ( x ) ) { return Double.NaN ; }
if ( Double . isNaN ( x ) ) { return Double.NaN ; }
if ( Double . isNaN ( x ) || x == NUMBER_CONSTANT ) { return x ; }
if ( Double . isNaN ( x ) ) { return x ; }
if ( Double . isNaN ( x ) ) { return x ; }
if ( Double . isNaN ( x ) ) { return x ; }
{ super ( LocalizedFormats.UNKNOWN_PARAMETER , name ) ; this . name = name ; }
MultivariateInterpolator interpolator = new MicrosphereInterpolator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return ( numerator . signum () == NUMBER_CONSTANT ) ? this : negate () ; }
final long numCalls = numberOfCalls . incrementAndGet () - NUMBER_CONSTANT ;
final Gaussian neighbourhoodDecay = new Gaussian ( currentLearning , NUMBER_CONSTANT , currentNeighbourhood ) ;
{ return divide ( new Fraction ( i ) ) ; }
{ return multiply ( new Fraction ( i ) ) ; }
TestUtils . assertRelativelyEquals ( expected , ZipfRejectionInversionSampler . helper2 ( testValue ) * testValue , tol ) ;
this . maxEvaluations = maxEvaluations ;
final int rowOffset ;
long swaps = NUMBER_CONSTANT ;
{ if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return FastMath . exp ( log1mProbabilityOfSuccess * x ) * probabilityOfSuccess ; } }
SQRT_TWO_PI / absX * FastMath . pow ( y , absX + NUMBER_CONSTANT ) * FastMath . exp ( - y )
return new CorrelatedRandomVectorGenerator ( new double [ cov.length ] , matrix , small , new GaussianRandomGenerator ( new Well1024a ( NUMBER_CONSTANT ) ) ) ;
BigFractionMatrixConverter () { super ( BigFraction.ZERO ) ; }
FractionMatrixConverter () { super ( Fraction.ZERO ) ; }
final RealFieldUnivariateFunction < T > f
final RealFieldUnivariateFunction < T > f
RealFieldUnivariateFunction < Dfp > f
final EnumeratedRealDistribution dist = new EnumeratedRealDistribution ( rng , combined ) ;
public JDKRandomGenerator ( long seed ) { setSeed ( seed ) ; }
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
starter . addStepHandler ( new NordsieckInitializer ( ( nSteps + NUMBER_CONSTANT ) / NUMBER_CONSTANT , y0.length ) ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
evaluations = evaluations . withStart ( NUMBER_CONSTANT ) ;
catch ( InitializationCompletedMarkerException icme ) { getCounter () . increment ( starter . getEvaluations () ) ; }
FieldVector3D < DerivativeStructure > axis = r . getAxis ( RotationConvention.VECTOR_OPERATOR ) ;
FieldVector3D < Dfp > axis = r . getAxis ( RotationConvention.VECTOR_OPERATOR ) ;
Vector3D axis = r . getAxis ( RotationConvention.VECTOR_OPERATOR ) ;
final Rotation composite = r1 . compose ( r2 . compose ( r3 , RotationConvention.FRAME_TRANSFORM ) , RotationConvention.FRAME_TRANSFORM ) ;
{ try { return delegate . nextInt ( n ) ; } catch ( IllegalArgumentException e ) { throw new NotStrictlyPositiveException ( n ) ; } }
{ delegate . setSeed ( RandomGeneratorFactory . convertToLong ( seed ) ) ; }
{ delegate . setSeed ( ( long ) seed ) ; }
setSeedInternal ( seed ) ;
public ISAACRandom ( long seed ) { setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ bits = nextInt () > > > NUMBER_CONSTANT ; val = bits % n ; }
if ( seed == null ) { setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
if ( seed == null ) { setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ setSeedInternal ( new int [] { seed } ) ; }
return computeInterpolatedStateAndDerivatives ( mapper , time , theta , oneMinusThetaH ) ;
mapper = null ;
yDotK [ NUMBER_CONSTANT ] = equations . getMapper () . mapDerivative ( stepStart ) ;
mainSetDimension = eqn . getStateDimension () ;
final BracketedRealFieldUnivariateSolver < T > solver
final BracketedRealFieldUnivariateSolver < T > solver
BracketedRealFieldUnivariateSolver < T > solver
public TestProblem5 () { setFinalConditions ( NUMBER_CONSTANT * t0 - t1 ) ; }
for ( int i = NUMBER_CONSTANT ; i < getDimension () ; ++ i ) { y [ i ] = c ; }
currentState = y ;
super ( field , METHOD_NAME , NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
super ( field , METHOD_NAME , - NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , - NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
start . subtract ( problem . getInitialState () . getTime () ) . divide ( integrator . getCurrentSignedStepsize () ) . abs () . getReal () > NUMBER_CONSTANT
{ super ( field ) ; setFinalConditions ( getInitialState () . getTime () . multiply ( NUMBER_CONSTANT ) . subtract ( getFinalTime () ) ) ; }
super ( field , METHOD_NAME , NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
{ return new EulerFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new DormandPrince54FieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new GillFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
final T one = getField () . getOne () ;
{ return new MidpointFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new LutherFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new ThreeEighthesFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new DormandPrince853FieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return doCopy () ; }
final T coeffDot1 = getField () . getOne () . subtract ( coeffDot2 ) ;
final T one = getField () . getOne () ;
{ return new HighamHall54FieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return getField () . getOne () . multiply ( p ) . divide ( q ) ; }
d = MathArrays . buildArray ( getField () , NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
{ return new ClassicalRungeKuttaFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
final T two = getField () . getZero () . add ( NUMBER_CONSTANT ) ;
{ return getField () . getZero () . add ( p ) . divide ( q ) ; }
{ return new EulerFieldStepInterpolator < T > ( field , forward , mapper ) ; }
mapper = new FieldEquationsMapper < T > ( mapper , secondary . getDimension () ) ;
FieldFirstOrderDifferentialEquations < T > eqn = new SinCos < T > ( field ) ;
setUpInterpolator ( field , new SinCos < T > ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
setUpInterpolator ( field , new SinCos < T > ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
integrator . integrate ( new FieldExpandableODE < T > ( problem ) , problem . getInitialState () , problem . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( equations ) , new FieldODEState < T > ( t0 , y0 ) , t ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
steps . add ( interpolator ) ;
for ( FieldStepInterpolator < T > interpolator : model.steps ) { steps . add ( interpolator ) ; }
while ( ++ index < getNumberOfEquations () ) { insertEquationData ( index , state . getSecondaryDerivative ( index ) , yDot ) ; }
while ( ++ index < getNumberOfEquations () ) { insertEquationData ( index , state . getSecondaryState ( index ) , y ) ; }
{ System . arraycopy ( mapper.start , NUMBER_CONSTANT , start , NUMBER_CONSTANT , index + NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override
@ Override
@ Override
@ Override
@ Override
@ Override
@ Override
@ Override
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
FirstOrderFieldIntegrator < T > integrator
final FirstOrderFieldDifferentialEquations < T > eqn
final FirstOrderFieldDifferentialEquations < T > eqn
final FirstOrderFieldIntegrator < T > integrator
final FirstOrderFieldDifferentialEquations < T > equations
final FirstOrderFieldDifferentialEquations < T > primary
{ return taylor ( reference , time , scalingH , scaled , nordsieck ) ; }
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ setSeed ( new int [] { seed } ) ; }
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ bits = ( nextInt () > > > NUMBER_CONSTANT ) ; val = bits % n ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
public ISAACRandom ( long seed ) { setSeed ( seed ) ; }
setSeed ( seed ) ;
{ return timeAndReport ( title , DEFAULT_MAX_NAME_WIDTH , DEFAULT_REPEAT_CHUNK , DEFAULT_REPEAT_STAT , false , methods ) ; }
@ Deprecated double sample ( ) ;
random = RandomSource . create ( RandomSource.WELL_1024_A , seed ) ;
{ this ( cityList , numNeuronsPerCity , RandomSource . createLong () ) ; }
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
{ final double u = rng . nextDouble () ; return u * upper + ( NUMBER_CONSTANT - u ) * lower ; }
return empiricalDistribution . createSampler ( randomData . getRandomProvider () ) . sample () ;
empiricalDistribution = new EmpiricalDistribution ( binCount ) ;
{ this . value = value ; }
final FDistribution fdist = new FDistribution ( a.dfbg , a.dfwg ) ;
final FDistribution fdist = new FDistribution ( a.dfbg , a.dfwg ) ;
final TDistribution distribution = new TDistribution ( degreesOfFreedom ) ;
final TDistribution distribution = new TDistribution ( degreesOfFreedom ) ;
final TDistribution distribution = new TDistribution ( n - NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final NormalDistribution standardNormal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final NormalDistribution standardNormal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final BinomialDistribution distribution = new BinomialDistribution ( numberOfTrials , probability ) ;
return complexSolver . solve ( ComplexUtils . real2Complex ( coefficients ) , new Complex ( initial , NUMBER_CONSTANT ) ) ;
return complexSolver . solveAll ( ComplexUtils . real2Complex ( coefficients ) , new Complex ( initial , NUMBER_CONSTANT ) ) ;
final Complex c [] = ComplexUtils . real2Complex ( getCoefficients () ) ;
UniformRandomProvider rng = RandomSource . create ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
RealDistribution.Sampler distribution
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
for ( int i = NUMBER_CONSTANT ; i < dim ; i ++ ) { normalVals [ i ] = gauss . sample () ; }
cachedD = MatrixUtils . createRealMatrixWithDiagonal ( realEigenvalues ) ;
ComplexFormat cf = ComplexFormat . getInstance ( getLocale () ) ;
ComplexFormat cf = ComplexFormat . getInstance ( getLocale () ) ;
UniformRandomProvider randomGenerator
{ this ( nanStrategy , tiesStrategy , RandomSource . create ( RandomSource.WELL_19937_C ) ) ; }
{ this ( DEFAULT_NAN_STRATEGY , tiesStrategy , RandomSource . create ( RandomSource.WELL_19937_C ) ) ; }
final UniformRandomProvider random
final UniformRandomProvider random
{ this ( k , maxIterations , measure , RandomSource . create ( RandomSource.MT_64 ) ) ; }
final UniformRandomProvider random
{ this ( k , fuzziness , maxIterations , measure , DEFAULT_EPSILON , RandomSource . create ( RandomSource.MT_64 ) ) ; }
final UniformRandomProvider random = RandomSource . create ( RandomSource.MT_64 ) ;
final UniformRandomProvider random
final UniformRandomProvider random = GeneticAlgorithm . getRandomGenerator () ;
final UniformRandomProvider random = GeneticAlgorithm . getRandomGenerator () ;
UniformRandomProvider randGen = getRandomGenerator () ;
final UniformRandomProvider random
final UniformRandomProvider random = GeneticAlgorithm . getRandomGenerator () ;
{ d [ r ] [ c ] = random . sample () ; }
for ( int i = NUMBER_CONSTANT ; i < size ; i ++ ) { randn [ i ] = random . sample () ; }
final UniformRandomProvider generator
UnitSphereRandomVectorGenerator random = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) ;
UnitSphereRandomVectorGenerator random = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
final double comp = rand . sample () ;
{ this ( dimension , RandomSource . create ( RandomSource.MT_64 ) ) ; }
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider generator = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider generator = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
{ field = new DfpField ( NUMBER_CONSTANT ) ; generator = RandomSource . create ( RandomSource.MT , NUMBER_CONSTANT ) ; }
UniformRandomProvider random = RandomSource . create ( RandomSource.XOR_SHIFT_1024_S , NUMBER_CONSTANT ) ;
UniformRandomProvider rng = RandomSource . create ( RandomSource.TWO_CMRES , NUMBER_CONSTANT ) ;
final UniformRandomProvider r
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider rng = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
new PivotingStrategyInterface [] { new MedianOf3PivotingStrategy () , new CentralPivotingStrategy () , new RandomPivotingStrategy ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) }
kthSelector = new KthSelector ( new RandomPivotingStrategy ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) ;
final RandomGenerator rng = new RngAdaptor ( RandomSource.MT ) ;
return InferenceTestUtils . gTest ( expected , observed ) ;
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( random ) . getState () ) ; }
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( delegate ) . getState () ) ; }
this . rng = new GaussianRandomGenerator ( RandomSource . create ( RandomSource.WELL_19937_C , seed ) ) ;
rng = new GaussianRandomGenerator ( RandomSource . create ( RandomSource.WELL_19937_C , seed ) ) ;
final UniformRandomProvider random = RandomSource . create ( RandomSource.MT ) ;
final UniformRandomProvider random = GeneticAlgorithm . getRandomGenerator () ;
return new ArrayFieldVector <> ( field , out , false ) ;
{ return new ArrayFieldVector <> ( this , v ) ; }
final FieldMatrix < T > out = new Array2DRowFieldMatrix <> ( field , m , n ) ;
final FieldMatrix < T > out = new Array2DRowFieldMatrix <> ( field , m , n ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
{ return new ArrayFieldVector <> ( this , true ) ; }
{ components = new ArrayList <> () ; firstIndex = primary . getDimension () ; }
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList <> () , transformers ) ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList <> () , transformers ) ;
DescriptiveStatistics u = new ListUnivariateImpl ( new ArrayList <> () , transformers ) ;
List < Object > externalList = new ArrayList <> () ;
List < Double > valuesList = new ArrayList <> () ;
List < Chromosome > popList = new LinkedList <> () ;
return new Array2DRowFieldMatrix <> ( out ) ;
Array2DRowFieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
return new ArrayFieldVector <> ( data , false ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
{ Assert . assertEquals ( new Array2DRowFieldMatrix <> ( reference ) , sub ) ; }
{ Assert . assertEquals ( new Array2DRowFieldMatrix <> ( reference ) , sub ) ; }
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( testData ) ;
Collection < SummaryStatistics > aggregate = new ArrayList <> () ;
Collection < SummaryStatistics > aggregate = new ArrayList <> () ;
Collection < StatisticalSummary > aggregate = new ArrayList <> () ;
Collection < SummaryStatistics > aggregate = new ArrayList <> () ;
return new FieldODEStateAndDerivative <> ( time , y , yDot ) ;
this . interpolator = new PerfectInterpolator <> ( problem ) ;
this . circles = new ArrayList <> () ;
ContinuousOutputFieldModel < T > otherCm = new ContinuousOutputFieldModel <> () ;
ContinuousOutputFieldModel < T > cm = new ContinuousOutputFieldModel <> () ;
{ new SparseFieldMatrix <> ( field , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
return new ArrayFieldVector <> ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector <> ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayFieldVector <> ( testVector ) ) . toArray () , entryTolerance ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix <> ( FractionField . getInstance () , testDataInv ) ) , identity , entryTolerance ) ;
RegionFactory < Sphere1D > factory = new RegionFactory <> () ;
List < SubHyperplane < Sphere1D > > boundary = new ArrayList <> () ;
final ArrayList < Object [] > parameters = new ArrayList <> () ;
singletons = new ArrayList <> ( pmf . size () ) ;
{ return new GillFieldIntegrator <> ( field , field . getOne () ) ; }
final ArrayList < Object [] > parameters = new ArrayList <> () ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
DBSCANClusterer < DoublePoint > clusterer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > clusterer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
HashSet < Object > sampSet = new HashSet <> () ;
final List < double [] > coordinatesList = new ArrayList <> () ;
final List < Neuron > list = new ArrayList <> () ;
final List < City > cityList = new ArrayList <> () ;
public CircleVectorial () { points = new ArrayList <> () ; }
{ return new MidpointFieldIntegrator <> ( field , field . getOne () ) ; }
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
this . convexCellsInsidePoints = new ArrayList <> () ;
root = new BSPTree <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
final List < Segment > segments = new ArrayList <> ( list . size () ) ;
{ parametersNames = new ArrayList <> () ; parametersNames . addAll ( names ) ; }
parametersNames = new ArrayList <> () ;
return new Array2DRowFieldMatrix <> ( field , d , false ) ;
{ map = new HashMap <> () ; defaultTransformer = new DefaultTransformer () ; }
final Set < T > oneSet = new HashSet <> ( one ) ;
final List < T > neighbors = new ArrayList <> () ;
List < T > seeds = new ArrayList <> ( neighbors ) ;
final List < Segment > segments = new ArrayList <> ( list . size () ) ;
return new Pair <> ( normal , jTr ) ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
List < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
List < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
{ points = new ArrayList <> () ; sigma = error ; }
final List < Long > linkEnd = new ArrayList <> () ;
List < Chromosome > chromosomes = new ArrayList <> ( population . getChromosomes () ) ;
List < Comparable < > > modeList = new ArrayList <> () ;
this . features = new AtomicReference <> ( features . clone () ) ;
List < Vector3D > reducedSupport = new ArrayList <> () ;
List < Vector3D > points = new ArrayList <> () ;
WelzlEncloser < Euclidean3D , Vector3D > encloser = new WelzlEncloser <> ( NUMBER_CONSTANT , generator ) ;
WelzlEncloser < Euclidean3D , Vector3D > encloser = new WelzlEncloser <> ( NUMBER_CONSTANT , generator ) ;
TreeSet < Double > values = new TreeSet <> () ;
final List < PairDoubleInteger > list = new ArrayList <> ( len ) ;
return new Array2DRowFieldMatrix <> ( pData , false ) ;
KMeansPlusPlusClusterer < DoublePoint > transformer = new KMeansPlusPlusClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final List < double [] > paramsAndChi2 = new ArrayList <> ( gridSize * gridSize ) ;
{ return new ThreeEighthesFieldIntegrator <> ( field , step ) ; }
p2 = new Pair <> ( STRING_CONSTANT , NUMBER_CONSTANT )
List < Chromosome > popList = new LinkedList <> () ;
final List < Neuron > neuronList = new ArrayList <> () ;
final List < Neuron > neurons = new ArrayList <> () ;
{ copy.linkMap . put ( e . getKey () , new HashSet <> ( e . getValue () ) ) ; }
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
final List < WeightedObservedPoint > points = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
List < Vector2D > reducedSupport = new ArrayList <> () ;
List < Vector2D > list = new ArrayList <> ( coordinates.length / NUMBER_CONSTANT ) ;
List < Vector2D > points = new ArrayList <> () ;
WelzlEncloser < Euclidean2D , Vector2D > encloser = new WelzlEncloser <> ( NUMBER_CONSTANT , generator ) ;
WelzlEncloser < Euclidean2D , Vector2D > encloser = new WelzlEncloser <> ( NUMBER_CONSTANT , generator ) ;
mapper = new FieldEquationsMapper <> ( mapper , secondary . getDimension () ) ;
Map < String , String > referenceRules = new HashMap <> () ;
Map < String , String > referenceRules = new HashMap <> () ;
FirstOrderFieldDifferentialEquations < T > eqn = new SinCos <> ( field ) ;
setUpInterpolator ( field , new SinCos <> ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
setUpInterpolator ( field , new SinCos <> ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
return new Array2DRowFieldMatrix <> ( pData , false ) ;
{ innerDistribution = new EnumeratedDistribution <> ( createDistribution ( singletons , probabilities ) ) ; }
{ return new ClassicalRungeKuttaFieldIntegrator <> ( field , step ) ; }
{ return new FieldLUDecomposition <> ( m ) . getDeterminant () . doubleValue () ; }
solver = new FieldLUDecomposition <> ( createFractionMatrix ( singular ) ) . getSolver () ;
solver = new FieldLUDecomposition <> ( createFractionMatrix ( testData ) ) . getSolver () ;
List < Chromosome > popList = new ArrayList <> () ;
NPointCrossover < Integer > npc = new NPointCrossover <> ( order ) ;
return new Array2DRowFieldMatrix <> ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix <> ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix <> ( getField () , outData , false ) ;
{ return new Array2DRowFieldMatrix <> ( getField () , rowDimension , columnDimension ) ; }
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , nCols , nRows ) ;
return new ArrayFieldVector <> ( getField () , outData , false ) ;
return new ArrayFieldVector <> ( getField () , outData , false ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , NUMBER_CONSTANT ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , NUMBER_CONSTANT , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , m.columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
{ return new BlockFieldMatrix <> ( getField () , rowDimension , columnDimension ) ; }
loops = new ArrayList <> () ;
final List < Integer > factors = new ArrayList <> ( NUMBER_CONSTANT ) ;
return new SparseFieldVector <> ( field , t ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
SparseFieldVector < Fraction > v1 = new SparseFieldVector <> ( field , vec1 ) ;
SparseFieldVector < Fraction > v1 = new SparseFieldVector <> ( field , vec1 ) ;
{ return new FieldODEState <> ( t0 , y0 ) ; }
RegionFactory < Sphere1D > factory = new RegionFactory <> () ;
RegionFactory < Sphere2D > factory = new RegionFactory <> () ;
RegionFactory < Sphere2D > factory = new RegionFactory <> () ;
List < SubHyperplane < Sphere2D > > boundary = new ArrayList <> () ;
List < SubHyperplane < Sphere2D > > boundary = new ArrayList <> () ;
RegionFactory < Sphere2D > factory = new RegionFactory <> () ;
RegionFactory < Sphere2D > factory = new RegionFactory <> () ;
final ArrayList < Integer > nonZeroPositions = new ArrayList <> () ;
{ this . tolerance = tolerance ; this . segments = new ArrayList <> () ; }
final List < Segment > loop = new ArrayList <> () ;
loops = new ArrayList <> ()
this . lines = new ArrayList <> () ;
this . representation = Collections . unmodifiableList ( copyList ? new ArrayList <> ( representation ) : representation ) ;
newClusters = new ArrayList <> ( k )
microsphereData = new ArrayList <> ( size ) ;
final Set < Neuron > list = new HashSet <> () ;
this . listeners = new CopyOnWriteArrayList <> () ;
this . listeners = new CopyOnWriteArrayList <> () ;
List < Integer > minRatioPositions = new ArrayList <> () ;
{ innerDistribution = new EnumeratedDistribution <> ( createDistribution ( singletons , probabilities ) ) ; }
final List < Interval > list = new ArrayList <> () ;
{ return new LutherFieldIntegrator <> ( field , step ) ; }
final FuzzyKMeansClusterer < DoublePoint > clusterer = new FuzzyKMeansClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new SparseFieldMatrix <> ( getField () , rowDimension , columnDimension ) ; }
{ return new SparseFieldMatrix <> ( this ) ; }
entries = new OpenIntToFieldHashMap <> ( getField () ) ;
entries = new OpenIntToFieldHashMap <> ( other.entries ) ;
entries = new OpenIntToFieldHashMap <> ( field ) ;
entries = new OpenIntToFieldHashMap <> ( field ) ;
steps = new ArrayList <> () ;
output = new ArrayList <> () ;
@ Before public void setUp () { evaluator = new SumOfClusterVariances <> ( new EuclideanDistance () ) ; }
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
Map < Integer , Fraction > generated = new HashMap <> () ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
Set < Integer > keysInMap = new HashSet <> ( javaMap . keySet () ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field , NUMBER_CONSTANT ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
Map < Integer , Fraction > map = new HashMap <> () ;
final List < Field > fields = new ArrayList <> () ;
RegionFactory < Euclidean1D > factory = new RegionFactory <> () ;
{ return new ArrayList <> ( observations ) ; }
final HashMap < Neuron , Integer > hit = new HashMap <> () ;
final List < PairNeuronDouble > list = new ArrayList <> () ;
List < CentroidCluster < T > > newClusters = new ArrayList <> () ;
List < Object [] > list = new ArrayList <> () ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
{ return new GillFieldIntegrator <> ( field , step ) ; }
return new FieldRotation <> ( mds , threshold ) ;
FieldRotation < DerivativeStructure > quat = new FieldRotation <> ( u1 , u2 , v1 , v2 ) ;
return new ArrayFieldVector <> ( t ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( vec1 ) ;
ArrayFieldVector < Fraction > v1 = new ArrayFieldVector <> ( vec1 ) ;
return new FieldVectorTestImpl <> ( out ) ;
final List < Object > orig = new ArrayList <> () ;
this . hParam = new HashMap <> () ;
regions = new ArrayList <> ( NUMBER_CONSTANT )
return new BoundaryProjection <> ( original , projected , offset ) ;
binStats = new ArrayList <> () ;
{ return new MidpointFieldIntegrator <> ( field , step ) ; }
RegionFactory < Euclidean2D > factory = new RegionFactory <> () ;
{ this . surrounded = new ArrayList <> () ; this . tolerance = tolerance ; }
return new FieldODEStateAndDerivative <> ( time , estimatedState , estimatedDerivatives ) ;
this . nordsieck = new Array2DRowFieldMatrix <> ( nordsieck . getData () , false ) ;
boundary = new ArrayList <> ()
{ return new BSPTree <> ( Boolean.FALSE ) ; }
SparseFieldVector < T > res = new SparseFieldVector <> ( this ) ;
FieldMatrix < T > res = new SparseFieldMatrix <> ( field , virtualSize , n ) ;
SparseFieldMatrix < T > res = new SparseFieldMatrix <> ( field , virtualSize , n ) ;
SparseFieldVector < T > res = new SparseFieldVector <> ( field , n ) ;
SparseFieldVector < T > res = new SparseFieldVector <> ( this ) ;
SparseFieldVector < T > res = new SparseFieldVector <> ( this ) ;
{ return new SparseFieldVector <> ( this ) ; }
FieldVector < T > res = new SparseFieldVector <> ( this , NUMBER_CONSTANT ) ;
FieldVector < T > res = new SparseFieldVector <> ( this , n ) ;
entries = new OpenIntToFieldHashMap <> ( v . getEntries () ) ;
entries = new OpenIntToFieldHashMap <> ( field ) ;
entries = new OpenIntToFieldHashMap <> ( field , expectedSize ) ;
entries = new OpenIntToFieldHashMap <> ( v.entries ) ;
entries = new OpenIntToFieldHashMap <> ( field ) ;
{ return new ClassicalRungeKuttaFieldIntegrator <> ( field , field . getOne () ) ; }
public ListUnivariateImpl () { this ( new ArrayList <> () ) ; }
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
TestFieldProblem3 < T > pb = new TestFieldProblem3 <> ( field ) ;
this . jacobianProviders = new ArrayList <> () ;
{ return new LutherFieldIntegrator <> ( field , field . getOne () ) ; }
List < Frequency > coll = new ArrayList <> () ;
{ return new ThreeEighthesFieldIntegrator <> ( field , field . getOne () ) ; }
List < Integer > newRepr = new ArrayList <> ( origChrom . getRepresentation () ) ;
final RegionFactory < Euclidean2D > factory = new RegionFactory <> () ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
final SimplePointChecker < PointValuePair > checker = new SimplePointChecker <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final SimplePointChecker < PointValuePair > checker = new SimplePointChecker <> ( NUMBER_CONSTANT , NUMBER_CONSTANT , max ) ;
final Collection < SummaryStatistics > categoryDataSummaryStatistics = new ArrayList <> ( categoryData . size () ) ;
final ArrayList < String > lines = new ArrayList <> () ;
List < Number > components = new ArrayList <> () ;
{ return new EulerFieldIntegrator <> ( field , step ) ; }
final ArrayList < Double > list = new ArrayList <> () ;
List < Vector3D > support = new ArrayList <> () ;
public CircleScalar () { points = new ArrayList <> () ; }
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < EventHandler > list = new ArrayList <> ( eventsStates . size () ) ;
final List < WeightedObservedPoint > observations = new ArrayList <> ( unsorted ) ;
this . chromosomes = new ArrayList <> ( populationLimit ) ;
BlockFieldMatrix < Fraction > m = new BlockFieldMatrix <> ( testData ) ;
BlockFieldMatrix < Fraction > m = new BlockFieldMatrix <> ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
return new ArrayFieldVector <> ( data , false ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
{ Assert . assertEquals ( new BlockFieldMatrix <> ( reference ) , sub ) ; }
{ Assert . assertEquals ( new BlockFieldMatrix <> ( reference ) , sub ) ; }
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( testData ) ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
RegionFactory < Sphere1D > factory = new RegionFactory <> () ;
return new ArrayList <> ( edgeToNode . keySet () ) ;
final FieldODEStateAndDerivative < T > stateTmp = new FieldODEStateAndDerivative <> ( stepEnd , yTmp , yDotTmp ) ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList <> () ) ;
List < Object > list = new ArrayList <> () ;
List < Object > externalList = new ArrayList <> () ;
final FieldODEStateAndDerivative < T > state0 = new FieldODEStateAndDerivative <> ( t0 , y0 , y0Dot ) ;
RegionFactory < Euclidean3D > factory = new RegionFactory <> () ;
integrator . integrate ( new FieldExpandableODE <> ( problem ) , problem . getInitialState () , problem . getFinalTime () ) ;
points = new ArrayList <> () ;
{ return new FieldVector3D <> ( NUMBER_CONSTANT , this , factor , v ) ; }
final List < Object > list = new ArrayList <> () ;
final List < Complex > result = new ArrayList <> () ;
return new FieldRotation <> ( mds , threshold ) ;
FieldRotation < Dfp > quat = new FieldRotation <> ( u1 , u2 , v1 , v2 ) ;
OnePointCrossover < Integer > opc = new OnePointCrossover <> () ;
BSPTree < Sphere1D > tree = new BSPTree <> ( Boolean.FALSE ) ;
final List < Arc > list = new ArrayList <> () ;
List < Double > newRepr = new ArrayList <> ( repr ) ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
Map < Integer , Double > generated = new HashMap <> () ;
Set < Integer > keysInMap = new HashSet <> ( javaMap . keySet () ) ;
Map < Integer , Double > map = new HashMap <> () ;
final Set < Integer > usedBasicRows = new HashSet <> () ;
final Set < Integer > columnsToDrop = new TreeSet <> () ;
List < LinearConstraint > normalized = new ArrayList <> ( originalConstraints . size () ) ;
final ArrayList < Object [] > parameters = new ArrayList <> () ;
{ return new Pair <> ( k , v ) ; }
public Cluster () { points = new ArrayList <> () ; }
close = new ArrayList <> ()
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
final HashSet < Double > values = new HashSet <> () ;
return new Array2DRowFieldMatrix <> ( BigFractionField . getInstance () , Hdata ) ;
TestFieldProblem3 < T > pb = new TestFieldProblem3 <> ( field ) ;
final BoundarySizeVisitor < S > visitor = new BoundarySizeVisitor <> () ;
final BoundaryProjector < S , T > projector = new BoundaryProjector <> ( point ) ;
{ tree = new BSPTree <> ( Boolean.FALSE ) ; }
{ this . tree = new BSPTree <> ( Boolean.TRUE ) ; this . tolerance = tolerance ; }
List < Integer > baseSequence = new ArrayList <> ( l ) ;
List < S > origDataCopy = new ArrayList <> ( originalData ) ;
List < S > sortedData = new ArrayList <> ( data ) ;
List < Double > repr = new ArrayList <> ( l ) ;
List < Double > repr = new ArrayList <> ( l ) ;
List < Double > sortedRepr = new ArrayList <> ( getRepresentation () ) ;
distribution = new ArrayList <> () ;
List < Vector2D > quadrilateral = new ArrayList <> () ;
final List < Vector2D > reducedPoints = new ArrayList <> ( quadrilateral ) ;
List < Integer > rList = new ArrayList <> ( length ) ;
context = new HashMap <> () ;
List < Vector2D > support = new ArrayList <> () ;
final ArrayList < Double > integrationTestPoints = new ArrayList <> () ;
edges = new ArrayList <> ()
final Collection < Vector2D > points = new ArrayList <> () ;
return new FieldODEState <> ( state . getTime () , y ) ;
ArrayList < Integer > out = new ArrayList <> () ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( fData , false ) ;
FieldMatrix < BigFraction > m = new Array2DRowFieldMatrix <> ( bfData , false ) ;
{ return new ArrayList <> () ; }
FieldBracketingNthOrderBrentSolver < Dfp > solver = new FieldBracketingNthOrderBrentSolver <> ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ;
FieldBracketingNthOrderBrentSolver < Dfp > solver = new FieldBracketingNthOrderBrentSolver <> ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ;
{ new FieldBracketingNthOrderBrentSolver <> ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ; }
List < Vector2D > points = new ArrayList <> ( size ) ;
List < Vector2D > points = new ArrayList <> () ;
List < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
ArrayList < SubHyperplane < Euclidean2D > > edges = new ArrayList <> () ;
RegionFactory < Euclidean2D > factory = new RegionFactory <> () ;
final List < WeightedObservedPoint > observations = new ArrayList <> ( unsorted ) ;
steps = new ArrayList <> () ;
final Set < City > unique = new HashSet <> () ;
final List < Future < > > execOutput = new ArrayList <> () ;
certifiedValues = new HashMap <> () ;
{ return new EulerFieldIntegrator <> ( field , field . getOne () ) ; }
FieldMatrix < T > identity = new Array2DRowFieldMatrix <> ( field , m , m ) ;
return new Array2DRowFieldMatrix <> ( field , bp , false ) ;
return new ArrayFieldVector <> ( bp , false ) ;
return new ArrayFieldVector <> ( field , bp , false ) ;
{ return new Solver <> ( field , lu , pivot , singular ) ; }
cachedP = new Array2DRowFieldMatrix <> ( field , m , m ) ;
cachedU = new Array2DRowFieldMatrix <> ( field , m , m ) ;
cachedL = new Array2DRowFieldMatrix <> ( field , m , m ) ;
List < Chromosome > popChr = new ArrayList <> () ;
Collection < Neuron > exclude = new HashSet <> () ;
Collection < Neuron > exclude = new HashSet <> () ;
final List < BigFraction > list = new ArrayList <> () ;
this . derivatives = new HashMap <> () ;
this . derivatives = new HashMap <> () ;
tasks = new ArrayList <> ()
final FieldODEStateAndDerivative < T > stateTmp = new FieldODEStateAndDerivative <> ( stepEnd , yTmp , yDotTmp ) ;
population = new ListPopulation ( chromosomes , NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
new ListPopulation ( chromosomes , NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } } ;
new ListPopulation ( chromosomes , - NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } } ;
{ new ListPopulation ( - NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } } ; }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
@ Override public StepInterpolator copy () { return this ; }
final Chromosome p1c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
@ Override public StepInterpolator copy () { return this ; }
final Chromosome p1c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p1c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p1c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
for ( int val : this . getRepresentation () ) { if ( val != NUMBER_CONSTANT ) { num ++ ; } }
if ( count ++ > NUMBER_CONSTANT ) { break; }
if ( count ++ > NUMBER_CONSTANT ) { break; }
if ( counts [ i ] == - NUMBER_CONSTANT ) { continue; }
random . restoreState ( state ) ;
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomSource.State ) random . saveState () ) . getState () ) ; }
delegate . restoreState ( state ) ;
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomSource.State ) delegate . saveState () ) . getState () ) ; }
{ double n = upperMinusLower + NUMBER_CONSTANT ; return ( n * n - NUMBER_CONSTANT ) / NUMBER_CONSTANT ; }
return ( x - lower + NUMBER_CONSTANT ) / ( upperMinusLower + NUMBER_CONSTANT ) ;
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomProviderDefaultState ) delegate . saveState () ) . getState () ) ; }
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomProviderDefaultState ) random . saveState () ) . getState () ) ; }
final double delta = ( ( Coordinates1D ) point ) . getX () - location . getX () ;
final Coordinates1D location
{ final Circle otherC = ( Circle ) other ; return Coordinates3D . dotProduct ( pole , otherC.pole ) >= NUMBER_CONSTANT ; }
final Coordinates3D direction
final Coordinates3D pole
final List < Coordinates3D > vertices
try { ps . checkPoint ( Coordinates3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
final Coordinates2D tmp = loop [ min ] ;
final Coordinates3D axis
Coordinates3D axis
Coordinates2D oneTwo = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ new Coordinates2D ( v ) ; }
{ final Coordinates1D p1 = ( Coordinates1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
Coordinates2D expected = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = Coordinates2D.NEGATIVE_INFINITY ;
Coordinates2D c = Coordinates2D.POSITIVE_INFINITY ;
Coordinates2D c = Coordinates2D.NaN ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new Line ( new Coordinates2D ( getNumber () , getNumber () ) , getNumber () , getNumber () ) ; }
{ return new OrientedPoint ( new Coordinates1D ( getNumber () ) , getBoolean () , getNumber () ) ; }
{ return new Circle ( new Coordinates3D ( getNumber () , getNumber () , getNumber () ) , getNumber () ) ; }
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D u
Coordinates1D v
Coordinates1D v = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D v = new Coordinates1D ( NUMBER_CONSTANT ) ;
{ Space space = new Coordinates1D ( NUMBER_CONSTANT ) . getSpace () ; Assert . assertEquals ( NUMBER_CONSTANT , space . getDimension () ) ; }
final Coordinates3D p = h . toSpace ( Coordinates2D.ZERO ) ;
final Coordinates2D p = h . toSpace ( Coordinates1D.ZERO ) ;
final Coordinates2D p2 = ( Coordinates2D ) vector ;
Coordinates3D c = Coordinates3D.NEGATIVE_INFINITY ;
Coordinates3D c = Coordinates3D.POSITIVE_INFINITY ;
Coordinates3D c = Coordinates3D.NaN ;
Coordinates1D expected = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = Coordinates1D.NEGATIVE_INFINITY ;
Coordinates1D c = Coordinates1D.POSITIVE_INFINITY ;
Coordinates1D c = Coordinates1D.NaN ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( - NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
final double angle = Coordinates3D . angle ( thisCircle . getPole () , otherCircle . getPole () ) ;
{ return Coordinates3D . angle ( p1.vector , p2.vector ) ; }
final Coordinates3D vector
{ return ( ( Coordinates3D ) point ) . dotProduct ( w ) + originOffset ; }
final Coordinates3D p
final Coordinates3D translation
final double angle = Coordinates3D . angle ( w , plane.w ) ;
final Coordinates3D tmp = u ;
final Coordinates3D normal
Coordinates3D v
{ new Coordinates3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Coordinates3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Coordinates1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
final Coordinates2D p
final Coordinates2D p
final Coordinates2D p
Coordinates2D p2 = ( Coordinates2D ) point ;
final Coordinates2D p
final Coordinates2D p
TranslationTransform ( final Coordinates3D translation ) { this . translation = translation ; }
final Coordinates3D translation
final Coordinates3D center
final Coordinates3D center
final Coordinates3D point
{ setSize ( NUMBER_CONSTANT ) ; setBarycenter ( ( Point < Euclidean3D > ) new Coordinates3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final List < Coordinates3D > vertices
final List < Coordinates3D > vertices
Circle circle = new Circle ( Coordinates3D.PLUS_K , NUMBER_CONSTANT ) ;
final Coordinates3D u
final Coordinates3D u
Collection < Coordinates2D > points
this . summedBarycenter = Coordinates3D.ZERO ;
{ return Coordinates2D . angle ( p1.vector , p2.vector ) ; }
final Coordinates2D vector
try { FieldVector3D . angle ( v1 , Coordinates3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
for ( Coordinates2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Coordinates2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
{ return new SphericalCoordinates ( new Coordinates3D ( x , y , z ) ) ; }
final Coordinates3D v
final Coordinates2D point
final Coordinates2D location
final Coordinates2D . . . vertices
final Coordinates2D . . . vertices
final Coordinates3D pole
final Coordinates3D p
final double angle = Coordinates3D . angle ( direction , line.direction ) ;
final Coordinates3D point
final Collection < Coordinates2D > points
final Collection < Coordinates2D > points
final Collection < Coordinates2D > points
ConvexHull2D hull = generator . generate ( Collections . < Coordinates2D > emptyList () ) ;
final double x = ( ( Coordinates1D ) point ) . getX () ;
final Cartesian2D tmp = loop [ min ] ;
final Cartesian2D p2 = ( Cartesian2D ) vector ;
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Cartesian1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
final List < Cartesian3D > vertices
try { ps . checkPoint ( Cartesian3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
final Cartesian3D p = h . toSpace ( Cartesian2D.ZERO ) ;
final Cartesian2D p = h . toSpace ( Cartesian1D.ZERO ) ;
Cartesian2D expected = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = Cartesian2D.NEGATIVE_INFINITY ;
Cartesian2D c = Cartesian2D.POSITIVE_INFINITY ;
Cartesian2D c = Cartesian2D.NaN ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final double x = ( ( Cartesian1D ) point ) . getX () ;
Cartesian3D v
{ new Cartesian3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
{ return new Line ( new Cartesian2D ( getNumber () , getNumber () ) , getNumber () , getNumber () ) ; }
{ return new OrientedPoint ( new Cartesian1D ( getNumber () ) , getBoolean () , getNumber () ) ; }
{ return new Circle ( new Cartesian3D ( getNumber () , getNumber () , getNumber () ) , getNumber () ) ; }
Circle circle = new Circle ( Cartesian3D.PLUS_K , NUMBER_CONSTANT ) ;
{ return new SphericalCoordinates ( new Cartesian3D ( x , y , z ) ) ; }
final Cartesian3D v
this . summedBarycenter = Cartesian3D.ZERO ;
{ final Cartesian1D p1 = ( Cartesian1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
{ return Cartesian2D . angle ( p1.vector , p2.vector ) ; }
final Cartesian2D vector
final Cartesian3D p
final double angle = Cartesian3D . angle ( direction , line.direction ) ;
final Cartesian3D point
Cartesian3D c = Cartesian3D.NEGATIVE_INFINITY ;
Cartesian3D c = Cartesian3D.POSITIVE_INFINITY ;
Cartesian3D c = Cartesian3D.NaN ;
Cartesian1D expected = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = Cartesian1D.NEGATIVE_INFINITY ;
Cartesian1D c = Cartesian1D.POSITIVE_INFINITY ;
Cartesian1D c = Cartesian1D.NaN ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( - NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
final Cartesian3D axis
Cartesian3D axis
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D u
final double angle = Cartesian3D . angle ( thisCircle . getPole () , otherCircle . getPole () ) ;
for ( Cartesian2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Cartesian2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
{ return ( ( Cartesian3D ) point ) . dotProduct ( w ) + originOffset ; }
final Cartesian3D p
final Cartesian3D translation
final double angle = Cartesian3D . angle ( w , plane.w ) ;
final Cartesian3D tmp = u ;
final Cartesian3D normal
try { FieldVector3D . angle ( v1 , Cartesian3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
{ final Circle otherC = ( Circle ) other ; return Cartesian3D . dotProduct ( pole , otherC.pole ) >= NUMBER_CONSTANT ; }
final Cartesian3D direction
final Cartesian3D pole
{ return Cartesian3D . angle ( p1.vector , p2.vector ) ; }
final Cartesian3D vector
Collection < Cartesian2D > points
final Collection < Cartesian2D > points
final Collection < Cartesian2D > points
final Collection < Cartesian2D > points
ConvexHull2D hull = generator . generate ( Collections . < Cartesian2D > emptyList () ) ;
final double delta = ( ( Cartesian1D ) point ) . getX () - location . getX () ;
final Cartesian1D location
final Cartesian3D u
final Cartesian3D u
final Cartesian3D pole
final Cartesian2D point
final Cartesian2D location
final Cartesian2D . . . vertices
final Cartesian2D . . . vertices
Cartesian2D oneTwo = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ new Cartesian2D ( v ) ; }
final Cartesian2D [] vertices
TranslationTransform ( final Cartesian3D translation ) { this . translation = translation ; }
final Cartesian3D translation
final Cartesian3D center
final Cartesian3D center
final Cartesian3D point
{ setSize ( NUMBER_CONSTANT ) ; setBarycenter ( ( Point < Euclidean3D > ) new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final List < Cartesian3D > vertices
final List < Cartesian3D > vertices
Cartesian1D v
Cartesian1D v = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D v = new Cartesian1D ( NUMBER_CONSTANT ) ;
{ Space space = new Cartesian1D ( NUMBER_CONSTANT ) . getSpace () ; Assert . assertEquals ( NUMBER_CONSTANT , space . getDimension () ) ; }
final Cartesian2D p
final Cartesian2D p
final Cartesian2D p
final Cartesian2D p
final Cartesian2D p
{ centered [ i ] = values [ i ] - means [ i ] ; }
private final ContinuousSampler sampler = new MarsagliaLogNormalSampler ( rng , scale , shape ) ;
private final ContinuousSampler sampler = new GaussianSampler ( new MarsagliaNormalizedGaussianSampler ( rng ) , mean , standardDeviation ) ;
public Plot ( final List < Cartesian2D > points ) { this . points = points ; }
List < Cartesian2D > points = null ;
Cartesian3D p
rings = new ChineseRings ( new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
Vector1D actual = vector1DFormat . parse ( source ) ;
Vector1D actual = vector1DFormat . parse ( source ) ;
Vector1D actual = vector1DFormat . parse ( source ) ;
Vector1D expected = new Cartesian1D ( NUMBER_CONSTANT ) ;
{ final Vector1D p1 = ( Vector1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
final Vector2D p2 = ( Vector2D ) vector ;
Vector2D actual = vector2DFormat . parse ( source ) ;
Vector2D actual = vector2DFormat . parse ( source ) ;
Vector2D actual = vector2DFormat . parse ( source ) ;
Vector3D actual = vector3DFormat . parse ( source ) ;
Vector3D actual = vector3DFormat . parse ( source ) ;
Vector3D actual = vector3DFormat . parse ( source ) ;
int j = minor
Assert . assertFalse ( STRING_CONSTANT + level , new KolmogorovSmirnovTest () . kolmogorovSmirnovTest ( betaDistribution , observed ) < level ) ;
Assert . assertEquals ( test . exactP ( d , sampleSize1 , sampleSize2 , strict ) , test . monteCarloP ( d , sampleSize1 , sampleSize2 , strict , MONTE_CARLO_ITERATIONS , rng ) , tol )
final double tol = NUMBER_CONSTANT ;
final double tol = NUMBER_CONSTANT ;
Cartesian3D p
rings = new ChineseRings ( new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
try { FieldVector3D . angle ( v1 , Cartesian3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
final Cartesian2D point
final Cartesian2D location
final Cartesian2D . . . vertices
final Cartesian2D . . . vertices
final Cartesian3D p
final double angle = Cartesian3D . angle ( direction , line.direction ) ;
final Cartesian3D point
Cartesian3D v
{ new Cartesian3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
final Collection < Cartesian2D > points
final Collection < Cartesian2D > points
final Collection < Cartesian2D > points
ConvexHull2D hull = generator . generate ( Collections . < Cartesian2D > emptyList () ) ;
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Cartesian1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
final double x = ( ( Cartesian1D ) point ) . getX () ;
for ( Cartesian2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Cartesian2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D u
final Cartesian2D [] vertices
if ( x <= NUMBER_CONSTANT ) { ret = NUMBER_CONSTANT ; } else { ret = RegularizedGamma.P . value ( shape , x / scale ) ; }
LogGamma . value ( z + NUMBER_CONSTANT ) - ( z + NUMBER_CONSTANT ) * FastMath . log ( z ) + z - HALF_LOG_2_PI
final double expected = LogGamma . value ( i + NUMBER_CONSTANT ) ;
{ return RegularizedGamma.P . value ( mu , mu * x * x / omega ) ; }
NUMBER_CONSTANT * FastMath . pow ( mu , mu ) / ( Gamma . value ( mu ) * FastMath . pow ( omega , mu ) )
Assert . assertEquals ( NUMBER_CONSTANT , Gamma . value ( t ) / s , tol ) ;
( sc * sc ) * FastMath . exp ( LogGamma . value ( NUMBER_CONSTANT + ( NUMBER_CONSTANT / sh ) ) )
return sc * FastMath . exp ( LogGamma . value ( NUMBER_CONSTANT + ( NUMBER_CONSTANT / sh ) ) ) ;
return LogGamma . value ( n + NUMBER_CONSTANT ) ;
{ ret = RegularizedBeta . value ( probabilityOfSuccess , numberOfSuccesses , x + NUMBER_CONSTANT ) ; }
{ ret = NUMBER_CONSTANT - RegularizedBeta . value ( probabilityOfSuccess , x + NUMBER_CONSTANT , numberOfTrials - x ) ; }
if ( x >= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return RegularizedBeta . value ( x , alpha , beta ) ; }
return NUMBER_CONSTANT * ErfDifference . value ( v0 , v1 ) ;
return NUMBER_CONSTANT + NUMBER_CONSTANT * Erf . value ( dev / ( shape * SQRT2 ) ) ;
final double t = InverseErfc . value ( p ) ;
return NUMBER_CONSTANT * ErfDifference . value ( v0 , v1 ) ;
return mean + standardDeviation * SQRT2 * InverseErf . value ( NUMBER_CONSTANT * p - NUMBER_CONSTANT ) ;
return NUMBER_CONSTANT * Erfc . value ( - dev / ( standardDeviation * SQRT2 ) ) ;
{ term *= FastMath . pow ( delta [ k ] , orders [ k ] ) / FACTORIAL . value ( orders [ k ] ) ; }
double refDer = - Factorial . value ( n - NUMBER_CONSTANT ) / FastMath . pow ( - x , n ) ;
ArithmeticUtils . pow ( - NUMBER_CONSTANT , i ) * Factorial . value ( i ) / FastMath . pow ( x , i + NUMBER_CONSTANT )
BinomialCoefficientDouble . value ( n + m , m )
double binomial = BinomialCoefficient . value ( v + i , i ) ;
long expected = BinomialCoefficient . value ( i + j , i ) ;
{ coeff [ i ] [ j ] = ( int ) BinomialCoefficient . value ( i , j ) ; }
Assert . assertEquals ( BinomialCoefficient . value ( n , NUMBER_CONSTANT ) , CombinatoricsUtils . stirlingS2 ( n , n - NUMBER_CONSTANT ) ) ;
return LinearCombination . value ( x1 , y1 , - x2 , y2 ) ;
{ final Cartesian2D v2 = ( Cartesian2D ) v ; return LinearCombination . value ( x , v2.x , y , v2.y ) ; }
final double n = FastMath . abs ( LinearCombination . value ( v1.x , v2.y , - v1.y , v2.x ) ) ;
out.value = LinearCombination . value ( a1 , b1.value , a2 , b2.value , a3 , b3.value ) ;
out.value = LinearCombination . value ( a1.value , b1.value , a2.value , b2.value , a3.value , b3.value ) ;
out.value = LinearCombination . value ( a1 , b1.value , a2 , b2.value ) ;
out.value = LinearCombination . value ( a1.value , b1.value , a2.value , b2.value ) ;
out.value = LinearCombination . value ( a , bDouble ) ;
out.value = LinearCombination . value ( aDouble , bDouble ) ;
{ return FastMath . abs ( LinearCombination . value ( sin , line.cos , - cos , line.sin ) ) < tolerance ; }
return LinearCombination . value ( sin , otherL.sin , cos , otherL.cos ) >= NUMBER_CONSTANT ;
{ return originOffset + ( LinearCombination . value ( cos , line.cos , sin , line.sin ) > NUMBER_CONSTANT ? - line.originOffset : line.originOffset ) ; }
final double accurateValue = LinearCombination . value ( a , bDouble ) ;
final double accurateValue = LinearCombination . value ( aDouble , bDouble ) ;
{ return new Decimal64 ( LinearCombination . value ( a1 , b1.value , a2 , b2.value , a3 , b3.value ) ) ; }
{ return new Decimal64 ( LinearCombination . value ( a1.value , b1.value , a2.value , b2.value , a3.value , b3.value ) ) ; }
{ return new Decimal64 ( LinearCombination . value ( a1 , b1.value , a2 , b2.value ) ) ; }
{ return new Decimal64 ( LinearCombination . value ( a1.value , b1.value , a2.value , b2.value ) ) ; }
return new Decimal64 ( LinearCombination . value ( aDouble , bDouble ) ) ;
final double r = LinearCombination . value ( coeff [ i ] , pY ) ;
packed [ i + NUMBER_CONSTANT ] = LinearCombination . value ( dv , partials ) ;
final double cos = CosAngle . value ( n , sampleDirection ) ;
final double diffNorm = SafeNorm . value ( diff ) ;
checkRelative ( LinearCombination . value ( aD , bD ) , bF [ NUMBER_CONSTANT ] . linearCombination ( aD , bF ) ) ;
checkRelative ( LinearCombination . value ( aD , bD ) , aF [ NUMBER_CONSTANT ] . linearCombination ( aF , bF ) ) ;
{ this ( PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( alpha ) , new Cartesian2D ( FastMath . cos ( alpha ) , FastMath . sin ( alpha ) ) ) ; }
{ Assert . assertEquals ( a1 . getReal () , PlaneAngleRadians . normalize ( a2 , a1 . getReal () ) , NUMBER_CONSTANT ) ; }
final double arcRelativeStart = PlaneAngleRadians . normalize ( arc . getInf () , edgeStart + FastMath.PI ) - edgeStart ;
Assert . assertEquals ( p , PlaneAngleRadians . normalize ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , PlaneAngleRadians . normalize ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , PlaneAngleRadians . normalize ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , PlaneAngleRadians . normalize ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
final double lB = PlaneAngleRadians . normalize ( limits . get ( j ) , lA ) ;
final double syncedStart = PlaneAngleRadians . normalize ( a [ NUMBER_CONSTANT ] , reference ) - arc . getInf () ;
final double normalizedLower = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( lower ) ;
{ Assert . assertEquals ( a1 . getReal () , PlaneAngleRadians . normalize ( a2 , a1 . getReal () ) , NUMBER_CONSTANT ) ; }
this . angle = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( angle ) ;
this . angle = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( alpha ) ;
angle = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( line.angle ) ;
final double normalizedPoint = PlaneAngleRadians . normalize ( point , middle ) ;
this . lower = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( lower ) ;
if ( knots.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION , knots.length , NUMBER_CONSTANT , true ) ; }
if ( knots.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION , knots.length , NUMBER_CONSTANT , true ) ; }
UnitSphereSampler g = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
UnitSphereSampler g = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
UnitSphereSampler g = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
UnitSphereSampler g = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
UnitSphereSampler rand
this ( new InterpolatingMicrosphere ( dimension , elements , maxDarkFraction , darkThreshold , background , new UnitSphereSampler ( dimension , RandomSource . create ( RandomSource.MT_64 ) ) ) , exponent , sharedSphere , noInterpolationTolerance ) ;
UnitSphereSampler sphRandom = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
{ sampler = new MarsagliaNormalizedGaussianSampler ( generator ) ; }
private final ContinuousSampler sampler = new LogNormalSampler ( new ZigguratNormalizedGaussianSampler ( rng ) , scale , shape ) ;
final ContinuousDistribution.Sampler random
{ return randomize ( new UniformContinuousDistribution ( min , max ) . createSampler ( rng ) , function ( new Constant ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
DiscreteDistribution.Sampler sampler
final ContinuousDistribution expectedDistribution
final NormalDistribution normalDistribution = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final NormalDistribution normalDistribution = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final NormalDistribution normalDistribution = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
ContinuousDistribution distribution
ContinuousDistribution distribution
ContinuousDistribution distribution
ContinuousDistribution distribution
ContinuousDistribution.Sampler sampler
this . random = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . createSampler ( rng ) ;
final ContinuousDistribution kernel = findKernel ( lower , upper ) ;
final ContinuousDistribution kernel = findKernel ( lower , upper ) ;
x = new UniformContinuousDistribution ( lo , hi ) . createSampler ( rng ) ;
tP = new UniformContinuousDistribution ( NUMBER_CONSTANT , MathUtils.TWO_PI ) . createSampler ( rng ) ;
@ Override public double getMean () { return NUMBER_CONSTANT ; }
final double offset = plane . getOffset ( point ) ;
{ Assert . assertEquals ( x , v . getX () , TEST_TOLERANCE ) ; }
Assert . assertFalse ( pt . isDirect () ) ;
Assert . assertTrue ( copy . isDirect () ) ;
Assert . assertTrue ( pt . isDirect () ) ;
assertContains ( result , expected , tolerance ) ;
TestUtils . assertContains ( result , expected , tolerance ) ;
y [ i ] = Complex . ofCartesian ( yr , yi ) ;
data [ i ] = Complex . ofCartesian ( re , im ) ;
Object expected = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = Complex . ofCartesian ( Double.NEGATIVE_INFINITY , Double.NEGATIVE_INFINITY ) ;
Complex expected = Complex . ofCartesian ( Double.POSITIVE_INFINITY , Double.POSITIVE_INFINITY ) ;
Complex expected = Complex . ofCartesian ( Double.NaN , Double.NaN ) ;
Complex expected = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( Double.NEGATIVE_INFINITY , Double.NEGATIVE_INFINITY ) ;
Complex c = Complex . ofCartesian ( Double.POSITIVE_INFINITY , Double.POSITIVE_INFINITY ) ;
Complex c = Complex . ofCartesian ( Double.NaN , Double.NaN ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
for ( float d : imaginary ) { c [ index ] = Complex . ofCartesian ( NUMBER_CONSTANT , d ) ; index ++ ; }
for ( double d : imaginary ) { c [ index ] = Complex . ofCartesian ( NUMBER_CONSTANT , d ) ; index ++ ; }
for ( float d : real ) { c [ index ] = Complex . ofCartesian ( d ) ; index ++ ; }
for ( double d : real ) { c [ index ] = Complex . ofCartesian ( d ) ; index ++ ; }
{ return Complex . ofCartesian ( NUMBER_CONSTANT , imaginary [ index ] ) ; }
{ return Complex . ofCartesian ( NUMBER_CONSTANT , imaginary [ index ] ) ; }
{ return Complex . ofCartesian ( real [ index ] ) ; }
{ return Complex . ofCartesian ( real [ index ] ) ; }
for ( float d : real ) { c [ index ] = Complex . ofReal ( d ) ; index ++ ; }
for ( double d : real ) { c [ index ] = Complex . ofReal ( d ) ; index ++ ; }
{ return Complex . ofReal ( real [ index ] ) ; }
{ return Complex . ofReal ( real [ index ] ) ; }
x [ i ] = Complex . ofReal ( f . value ( t ) ) ;
{ final int value = count ; count += increment ; return value ; }
{ new SimpsonIntegrator ( NUMBER_CONSTANT , SimpsonIntegrator.SIMPSON_MAX_ITERATIONS_COUNT + NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
public RealMatrix copy () { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
