expr . setLineno ( expr . getLineno () + templateLineno - NUMBER_CONSTANT ) ;
if ( definitionNodeByDefinitionSite . containsKey ( useSite ) ) { return null ; }
FeatureSet features = ( ( JsAst ) ast ) . getFeatures ( compiler ) ;
if ( tags == FALSY_MASK ) { return builder . append ( STRING_CONSTANT ) ; } else { return builder . append ( STRING_CONSTANT + tags ) ; }
output.compiledCode = compiler . toSource () ;
options . setWarningLevel ( DiagnosticGroups.MISSING_PROVIDE , CheckLevel.WARNING ) ;
resultPair = analyzeCastFwd ( expr , inEnv ) ;
options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.OFF ) ;
resultPair = analyzeCastFwd ( expr , inEnv , specializedType ) ;
resultPair = analyzeCastFwd ( expr , inEnv ) ;
public void testEs6ONoEs6 () { testSame ( STRING_CONSTANT ) ; }
options . setWarningLevel ( DiagnosticGroups.MISSING_PROVIDE , CheckLevel.WARNING ) ;
public Node getNext () { return next ; }
public Token getToken () { return token ; }
return JSType.UNKNOWN ;
@ Deprecated public AssertionFunctionSpec ( String functionName ) { this ( functionName , JSType.UNKNOWN , null ) ; }
STRING . isSubtypeOf ( this ) && this . commonTypes . getNumberInstance () . mayHaveProp ( pname )
if ( type == null && isConstant ) { type = JSType.UNKNOWN ; }
if ( isUnknown () ) { return UNKNOWN ; }
if ( isBottom () || isUnknown () || hasTruthyMask () ) { return UNKNOWN ; }
if ( this . isUnknown () ) { return TRUTHY ; }
{ globalThisType = JSType.TOP_OBJECT . withLoose () ; }
n . getChildCount () == NUMBER_CONSTANT && t . inGlobalScope ()
if ( varNode . getChildCount () > NUMBER_CONSTANT && varType != null ) { warnings . add ( JSError . make ( varNode , ONE_TYPE_FOR_MANY_VARS ) ) ; }
n . getChildCount () == NUMBER_CONSTANT && parent == googScopeBlock
initializer . isVar () && initializer . getChildCount () == NUMBER_CONSTANT
if ( n . getChildCount () == NUMBER_CONSTANT && NodeUtil . isStatement ( n ) ) { processName ( n . getFirstChild () , n ) ; }
typeNode != null && typeNode . getToken () == Token.STRING
if ( inputId == null ) { inputId = NodeUtil . getInputId ( node ) ; }
if ( inputId == null ) { inputId = NodeUtil . getInputId ( node ) ; }
String name = node . getQualifiedName () ;
options.rewritePolyfills = flags.rewritePolyfills ;
JSType t = getMaybeTypeFromComment ( jsdoc , registry , typeParameters ) ;
builder . append ( paramType . toStringHelper ( forAnnotations ) ) . append ( STRING_CONSTANT ) ;
builder . append ( STRING_CONSTANT ) . append ( paramType . toStringHelper ( forAnnotations ) ) ;
{ b . append ( p . getJSType () . toStringHelper ( forAnnotations ) ) ; }
b . append ( call.returnType . toStringHelper ( forAnnotations ) ) ;
sb . append ( getPropertyType ( property ) . toStringHelper ( forAnnotations ) ) ;
if ( n . isFromExterns () ) { this . allPropertyNames . add ( propName ) ; }
allPropertyNames . add ( getProp . getLastChild () . getString () ) ;
if ( NodeUtil . isPropertyTest ( compiler , n ) || isPropertyAbsentTest ( n ) ) { allPropertyNames . add ( n . getLastChild () . getString () ) ; }
allPropertyNames . add ( pname ) ;
compiler . getOptions () . setUseTypesForOptimization ( true ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
if ( singleSiteDefinitions . size () > NUMBER_CONSTANT ) { return false ; }
NodeTraversal . traverseEs6 ( compiler , root , new FunctionVisitor ( compiler , blacklistedPropNames ) ) ;
@ Override void endCaseBody () { super . endCaseBody () ; indent -- ; endStatement () ; }
assertEquals ( NUMBER_CONSTANT , compiler . getErrorCount () ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
options . setLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ;
JSType objectWithBadKey = findObjectWithNonStringifiableKey ( realType ) ;
Config config = findMatching ( name ) ;
if ( currentScript.defaultExportName != null ) { assignNode . getParent () . detach () ; return; }
boolean nameIsExported = name . equals ( currentScript.defaultExportName ) ;
public J2clCheckPassTest () { enableTypeCheck () ; }
JSType jsType
JSType jsType
void setMask ( int mask ) { bitmask |= mask ; checkInvariant () ; }
if ( info . isNoSideEffects () ) { sideEffectInfo . setIsPure () ; } else { sideEffectInfo . setTaintsGlobalState () ; }
features . require ( Feature.ASYNC_FUNCTIONS ) ;
features . require ( Feature.ASYNC_FUNCTIONS ) ;
config.parseTypeSyntax && peek ( TokenType.OPEN_PAREN ) || peek ( TokenType.OPEN_ANGLE )
features . require ( Feature.ASYNC_FUNCTIONS ) ;
JSDocInfo info = getJSDocInfoForFunction ( node , parent ) ;
FunctionInformation sideEffectInfo = new FunctionInformation ( inExterns ) ;
FunctionInformation representativeNode = new FunctionInformation ( false ) ;
if ( modulePath == null ) { compiler . report ( t . makeError ( require , LOAD_ERROR , requireName ) ) ; return; }
assertPasses ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String treeDiff = node . checkTreeEquals ( getSubject () ) ;
public ImmutableMap < String , Stats > getStats () { calcTotalStats () ; return summaryCopy ; }
maybeWarnForInvalidDestructuring ( t , lhs , legacyNamespace ) ;
{ options . setReportMissingOverride ( value ? CheckLevel.WARNING : CheckLevel.OFF ) ; }
this . output . print ( Joiner . on ( STRING_CONSTANT ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
NodeTraversal . traverseEs6 ( compiler , scriptRoot , new Es6RenameReferences ( renameMap ) ) ;
NodeTraversal . traverseEs6 ( compiler , root , new Es6RenameReferences ( renameMap ) ) ;
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode , definitionProvider , representativeNodesByName ) ;
this . functionSideEffectMap = new LinkedHashMap <> () ;
return IR . exprResult ( assign ) . useSourceInfoFromForTree ( var ) ;
{ if ( Matchers . functionCall ( STRING_CONSTANT ) . matches ( child . getFirstChild () , metadata ) ) { return true ; } }
Matchers . functionCall ( STRING_CONSTANT ) . matches ( child . getFirstChild () , metadata )
{ eatPredefinedString ( PredefinedName.FROM ) ; moduleSpecifier = eat ( TokenType.STRING ) . asLiteral () ; }
public void testRequireUseStrict1 () { configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( EXTERNS , STRING_CONSTANT , null ) ; }
testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
testSame ( EXTERNS , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , null ) ;
testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , null ) ;
testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , null ) ; }
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
compiler . reportCodeChange () ;
{ parent . removeChild ( node ) ; t . getCompiler () . reportCodeChange () ; }
Pattern argPattern = Pattern . compile ( STRING_CONSTANT ) ;
new ByteArrayInputStream ( inputString . getBytes () )
new ByteArrayInputStream ( inputString . getBytes () )
new ByteArrayInputStream ( inputString . getBytes () )
new ByteArrayInputStream ( inputString . getBytes () )
inputSourceMaps . put ( sourceMapPath , new SourceMapInput ( sourceMap ) ) ;
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; } }
final Node extendsClause = className . getNext () ;
{ test ( createCompilerOptions () , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; break; } }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
builder . setTagAsStrict ( firstOutput && options . getLanguageOut () . isStrict () ) ;
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; } }
com.google.javascript.jscomp.parsing.parser.Parser.Config es6config = new com.google.javascript.jscomp.parsing.parser.Parser.Config ( mode ( config.languageMode ) ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , ERROR ) ;
protected CodingConvention getCodingConvention () { return codingConvention ; }
{ super . setUp () ; codingConvention = new GoogleCodingConvention () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; }
if ( config.languageMode != LanguageMode.ECMASCRIPT6_TYPED ) { errorReporter . warning ( STRING_CONSTANT + feature , sourceName , lineno ( node ) , charno ( node ) ) ; }
Config config = ParserRunner . createConfig ( mode , Config.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , Config.RunMode.KEEP_GOING , null , true ) ;
builder . setTagAsStrict ( firstOutput && options . isEmitUseStrict () && options . getLanguageOut () . isStrict () ) ;
if ( options . getLanguageIn () . isStrict () ) { options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.ERROR ) ; }
options . setEmitUseStrict ( flags.emitUseStrict && options . getLanguageOut () . isStrict () ) ;
{ googRequireNode = IR . var ( IR . name ( shortName ) , googRequireNode ) ; }
return getTypeJSDoc ( oldJSDoc , expr ) ;
if ( ! hasConstructor ) { addSyntheticConstructor ( n ) ; }
! isCallTo ( value , STRING_CONSTANT ) && ! ( info != null && info . isConstructorOrInterface () )
if ( isCallTo ( destructuringLhsNode . getLastChild () , STRING_CONSTANT ) ) { return; }
var != null && var . getInitialValue () != null && ! isCallTo ( var . getInitialValue () , STRING_CONSTANT )
if ( aliasVarNodeRhs == null || ! isCallTo ( aliasVarNodeRhs , STRING_CONSTANT ) ) { t . report ( call , INVALID_GET_ALIAS ) ; return; }
String exportedNamespace = currentScript.declareLegacyNamespace ? currentScript.legacyNamespace : currentScript . getBinaryNamespace () ;
String exportedNamespace = rewriteState . getExportedNamespace ( legacyNamespace ) ;
String exportedNamespace = rewriteState . getExportedNamespace ( legacyNamespace ) ;
if ( isExportPropertyAssignment ( n ) ) { recordExportsPropertyAssignment ( n ) ; }
{ typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; typeCheck ( STRING_CONSTANT , JSTypeCreatorFromJSDoc.INHERITANCE_CYCLE ) ; }
IR . call ( IR . getprop ( superClass . cloneTree () , IR . string ( STRING_CONSTANT ) ) , IR . thisNode () , IR . name ( STRING_CONSTANT ) )
assertEquals ( null , LanguageMode . fromString ( STRING_CONSTANT ) ) ;
sourceMap . appendTo ( out , sourceMapOutputFile . getName () ) ;
{ if ( n . isSuper () ) { visitSuper ( n , parent ) ; } }
add ( last , Context.PRESERVE_BLOCK ) ;
assertValidOrder ( checks ) ;
assertValidOrder ( passes ) ;
CompilerPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeFoldConstants ( late , compiler . getOptions () . useTypesForLocalOptimization ) ) ;
if ( ! ( rval >= NUMBER_CONSTANT && rval < NUMBER_CONSTANT ) ) { report ( SHIFT_AMOUNT_OUT_OF_BOUNDS , n ) ; return n ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , VariableReferenceCheck.EARLY_REFERENCE ) ; }
DeclaredTypeRegistry getScope () { return this . scope ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , EARLY_REFERENCE ) ; }
{ super . setUp () ; codingConvention = new GoogleCodingConvention () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT8 ) ; }
if ( ! targetType . getGreatestSubtype ( type ) . isBottom () ) { methodPolyfills . remove ( method ) ; }
new PeepholeReplaceKnownMethods ( late )
new PeepholeReplaceKnownMethods ( late )
new PeepholeReplaceKnownMethods ( late )
public boolean isBuiltinObject () { return this . rawType . isBuiltinWithName ( STRING_CONSTANT ) ; }
boolean isClassy () { return ! isFunction () && ! isBuiltinObject () ; }
if ( this . equals ( proto ) ) { Preconditions . checkState ( this . isInstanceofObject () , STRING_CONSTANT , this ) ; return null ; }
return isUnknown () || ( isInstanceofObject () && isLoose () ) || ( ft != null && ft . isTopFunction () ) ;
return nt . isBuiltinObject () ? false : nt . isPropDefinedOnSubtype ( pname ) ;
Preconditions . checkArgument ( name . equals ( STRING_CONSTANT ) || name . equals ( STRING_CONSTANT ) || name . equals ( STRING_CONSTANT ) , STRING_CONSTANT , name ) ;
if ( this == other || other . isBuiltinWithName ( STRING_CONSTANT ) ) { return true ; }
if ( ! isBuiltinWithName ( STRING_CONSTANT ) ) { this . subtypes . add ( subtype ) ; }
public RemoveUnusedPolyfillsTest () { super ( EXTERNS ) ; enableTypeCheck () ; }
return Long . toString ( nonnegativeHash , NUMBER_CONSTANT ) . toUpperCase () ;
String lowerParam = param . toLowerCase () ;
compilationLevelParsed = COMPILATION_LEVEL_MAP . get ( compilationLevel . toUpperCase () ) ;
addParserWarning ( STRING_CONSTANT , visibility . toString () . toLowerCase () ) ;
{ result = result . toString () . toUpperCase () ; }
String canonicalizedName = value . trim () . toUpperCase () . replaceFirst ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ Node parent = n . getParent () ; return wasCast ( n ) || isAssertionCall ( parent ) ; }
return TOP_OBJECT ;
! t . isSubtypeOf ( this . commonTypes . TOP_OBJECT ) && ( ! t . hasTypeVariable () || t . hasScalar () )
JSType objLitType = commonTypes.TOP_OBJECT ;
{ globalThisType = this . commonTypes . TOP_OBJECT . withLoose () ; }
this == other || other.ns != null || ! other . getNominalType () . equals ( this . commonTypes . getObjectType () )
boolean isInhabitable () { return this != this . commonTypes . BOTTOM_OBJECT ; }
objType != null && ! objType . getNominalType () . isClassy () && ! objType . isLoose ()
if ( nameNode == null ) return;
{ throw new IllegalStateException ( STRING_CONSTANT + declaredValue . toStringTree () ) ; }
if ( name != null ) { this . definitionNodeByDefinitionSite . remove ( node ) ; this . nameDefinitionMultimap . remove ( name , node ) ; }
pattern . getParent () . replaceChild ( pattern , IR . name ( tempVarName ) ) ;
patternParam . getParent () . replaceChild ( patternParam , newParam ) ;
callNode . getParent () . replaceChild ( callNode , replacement . useSourceInfoIfMissingFrom ( callNode ) ) ;
candidateDefinition . getParent () . replaceChild ( candidateDefinition , varNode ) ;
parent . getParent () . replaceChild ( parent , replacement ) ;
n . getParent () . replaceChild ( n , replacement ) ;
n . getParent () . replaceChild ( n , replacement ) ;
first . getParent () . replaceChild ( first , name ) ;
n . getParent () . replaceChild ( n , placeholder ) ;
n . getParent () . replaceChild ( n , call ) ;
msgNode . getParent () . replaceChild ( msgNode , newValue ) ;
statement . getParent () . replaceChild ( statement , newStatement ) ;
assignNode . getParent () . replaceChild ( assignNode , rhs ) ;
if ( enclosing != null && enclosing . isGeneratorFunction () ) { n . getParent () . replaceChild ( n , IR . name ( GENERATOR_THIS ) ) ; }
n . getParent () . replaceChild ( n , replacement ) ;
n . getParent () . replaceChild ( n , elem ) ;
n . getParent () . replaceChild ( n , elem ) ;
n . getParent () . replaceChild ( n , lengthNode ) ;
n . getParent () . replaceChild ( n , newNode ) ;
n . getParent () . replaceChild ( n , newNumber ) ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . getParent () . replaceChild ( n , result ) ; reportCodeChange () ; return result ; }
n . getParent () . replaceChild ( n , newStringNode ) ;
n . getParent () . replaceChild ( n , replacement ) ;
n . getParent () . replaceChild ( n , newNode ) ;
if ( replacementNode != null ) { n . getParent () . replaceChild ( n , replacementNode ) ; reportCodeChange () ; return replacementNode ; }
originalTypeofNode . getParent () . replaceChild ( originalTypeofNode , newNode ) ;
n . getParent () . replaceChild ( n , replacement ) ;
callNode . getParent () . replaceChild ( callNode , objNode ) ;
n . getParent () . replaceChild ( n , newNode ) ;
subtree . getParent () . replaceChild ( subtree , replacement ) ;
subtree . getParent () . replaceChild ( subtree , replacement ) ;
{ parent . getParent () . replaceChild ( parent , IR . empty () ) ; }
grandparent . getParent () . replaceChild ( grandparent , functionNode ) ;
n . getParent () . replaceChild ( n , var ) ;
n . getParent () . replaceChild ( n , replacement ) ;
target . getParent () . replaceChild ( target , value . cloneTree () ) ;
node . getParent () . replaceChild ( node , replacement ) ;
n . getParent () . replaceChild ( n , stringNode ) ;
callNode . getParent () . replaceChild ( callNode , objNode ) ;
callNode . getParent () . replaceChild ( callNode , objNode ) ;
{ original . getParent () . replaceChild ( original , replacement ) ; return replacement ; }
if ( replaceParent ) { parent . getParent () . replaceChild ( parent , replacement ) ; } else { parent . replaceChild ( n , replacement ) ; }
superCall . getParent () . replaceChild ( superCall , superErrorExpr ) ;
obj . getParent () . replaceChild ( obj , result ) ;
n . getParent () . replaceChild ( n , attachTypeExpr ) ;
loadModuleStatement . getParent () . replaceChild ( loadModuleStatement , moduleBlockNode ) ;
n . getParent () . replaceChild ( n , legacyQname ) ;
exprResultNode . getParent () . replaceChild ( exprResultNode , exportsObjectCreationNode ) ;
call . getParent () . replaceChild ( call , exportedNamespaceName ) ;
expressionWithScopeCall . getParent () . replaceChild ( expressionWithScopeCall , scopeClosureBlock ) ;
callNode . getParent () . replaceChild ( callNode , replacementNode . detach () ) ;
member . getParent () . replaceChild ( member , memberVariable ) ;
{ forCondition . getParent () . replaceChild ( forCondition , IR . empty () ) ; reportCodeChange () ; }
n . getParent () . replaceChild ( n , whileNode ) ;
condition . getParent () . replaceChild ( condition , replacementConditionNode ) ;
n . getParent () . replaceChild ( n , replacement ) ;
n . getParent () . replaceChild ( n , caseBlock . detach () ) ;
{ subtree . getParent () . replaceChild ( subtree , right . detach () ) ; reportCodeChange () ; return right ; }
n . getParent () . replaceChild ( n , call ) ;
n . getParent () . replaceChild ( n , not ) ;
if ( newLiteralNode != null ) { n . getParent () . replaceChild ( n , newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
n . getParent () . replaceChild ( n , replacement ) ;
enclosingCall . getParent () . replaceChild ( enclosingCall , baseCall ) ;
callNode . getParent () . replaceChild ( callNode , replacement ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
public void testNgInjectSetVisibility ( ) throws Exception { compareJsDoc = true ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
Node scopeMethodCall = findScopeMethodCall ( t . getScope () . getRootNode () ) ;
Node n = t . getScope () . getRootNode () ;
abstract Node getRoot ( ) ;
String getContent ( ) throws ServiceException ;
String getName ( ) throws ServiceException ;
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate ) ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate , CacheBuilder . newBuilder () ) ; }
{ return Strings . nullToEmpty ( sourceMapCache . get ( path ) ) ; }
String output = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
if ( n . getChildCount () != NUMBER_CONSTANT ) { return n ; }
if ( castType . isSubtype ( exprType ) || expr . isObjectLit () ) { expr . setJSType ( castType ) ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate ) ; }
options . setLanguageOut ( LanguageMode.ECMASCRIPT5_STRICT ) ;
return new RawNominalType ( commonTypes , defSite , name , typeParameters , Kind.RECORD , objKind ) ;
return new RawNominalType ( commonTypes , defSite , name , typeParameters , Kind.INTERFACE , objKind ) ;
ImmutableCollection < Node > exports
if ( isUnknownType () || implicitPrototypeChainIsUnknown () ) { return true ; }
return list ;
if ( ! hasConstructor ) { addSyntheticConstructor ( t , n ) ; }
IR . comma ( IR . comma ( IR . comma ( getTmpError , copyMessage ) , setStack ) , IR . name ( TMP_ERROR ) ) . useSourceInfoIfMissingFromForTree ( superCall )
{ compiler . report ( JSError . make ( constructor , CANNOT_CONVERT_YET , STRING_CONSTANT + superClassQName ) ) ; }
this . implementedInterfaces = new HashMap <> () ;
script . addChildToFront ( googProvide . copyInformationFromForTree ( script ) ) ;
require . copyInformationFromForTree ( importDecl ) ;
newChild . copyInformationFrom ( child ) ;
newNode . copyInformationFromForTree ( sourceInfoNode ) ;
expr . copyInformationFromForTree ( parent ) ;
newChild . useSourceInfoWithoutLengthIfMissingFrom ( child ) ;
String name
if ( strictMismatch ) { implicitStructuralInterfaceUses . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordStructuralInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
if ( strictMismatch ) { mismatches . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordImplicitInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( rightType , leftType ) ; }
@ Override Iterable < TypeMismatch > getImplicitInterfaceUses () { return getTypeValidator () . getImplicitStructuralInterfaceUses () ; }
if ( strictMismatch ) { implicitStructuralInterfaceUses . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordStructuralInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
if ( options.tracer . isOn () && tracker != null ) { tracker . recordPassStop ( passName , result ) ; }
if ( options.tracer . isOn () && tracker != null ) { tracker . recordPassStart ( passName , true ) ; }
{ return compilerExecutor . runInCompilerThread ( callable , options != null && options.tracer . isOn () ) ; }
options.tracer = config.tracerMode ;
testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExport5 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
Map < String , DependencyInfo > parsedFiles = new HashMap <> () ;
Map < String , DependencyInfo > depsFiles = new HashMap <> () ;
Map < String , DependencyInfo > providesMap = new HashMap <> () ;
( ! NodeUtil . isPropertyTest ( compiler , n ) || objectType . isStruct () )
{ if ( canCreate ) { createName ( name ) ; } return allNames . get ( name ) ; }
if ( ! Double . isNaN ( d ) ) { cc . addNumber ( d ) ; } else { addJsString ( n ) ; }
assertThat ( result.sourceMap ) . contains ( STRING_CONSTANT ) ;
catch ( IOException e ) { compiler . report ( JSError . make ( REPORT_PATH_IO_ERROR , reportPath ) ) ; }
catch ( IOException e ) { compiler . report ( JSError . make ( REPORT_PATH_IO_ERROR , reportPath ) ) ; }
Preconditions . checkState ( current . isGetProp () ) ;
static boolean isEnhancedFor ( Node n ) { return n . isForOf () || isForIn ( n ) ; }
return newNode ( Token.FOR , initializer , transform ( loopNode.collection ) , transformBlock ( loopNode.body ) ) ;
return new Node ( Token.FOR , target , cond , body ) ;
validateNodeType ( Token.BLOCK , n ) ;
validateNodeType ( Token.BLOCK , n ) ;
String path
String path
TranspileResult transpile ( String path , String code ) ;
TranspileResult result = transpiler . transpile ( path , s ) ;
String path
BaseTranspiler.CompileResult result = compiler . compile ( STRING_CONSTANT , STRING_CONSTANT ) ;
BaseTranspiler.CompileResult result = compiler . compile ( STRING_CONSTANT , STRING_CONSTANT ) ;
String path
String path
if ( NodeUtil . isForIn ( parent ) ) { return n != parent . getFirstChild () ; } else { return NodeUtil . getConditionExpression ( parent ) != n ; }
( NodeUtil . isForIn ( parent ) )
if ( n . isForOf () || NodeUtil . isForIn ( n ) ) { return n . getSecondChild () ; }
if ( NodeUtil . isForIn ( parent ) ) { return parent ; } else { return parent . getSecondChild () . getNext () ; }
if ( NodeUtil . isVanillaFor ( cur ) ) { iter = cur . getChildAtIndex ( NUMBER_CONSTANT ) ; }
NodeUtil . isForIn ( forNode ) || forNode . isForOf ()
parent . isFor () && ! NodeUtil . isForIn ( parent )
if ( ! NodeUtil . isForIn ( parent ) && child == parent . getFirstChild () ) { return parent ; }
boolean lhsOfForInLoop = NodeUtil . isForIn ( gp ) && gp . getFirstFirstChild () == declNode ;
srcDeclaration . isConst () && ! ( NodeUtil . isForIn ( srcParent ) && srcDeclaration == srcParent . getFirstChild () )
! NodeUtil . isForIn ( n )
if ( enclosingFunc == null || ! enclosingFunc . isGeneratorFunction () || NodeUtil . isForIn ( n ) ) { return; }
if ( NodeUtil . isForIn ( currentStatement ) ) { visitForIn () ; return false ; }
if ( NodeUtil . isForIn ( parent ) && parent . getFirstChild () == n ) { return false ; }
Preconditions . checkState ( NodeUtil . isForIn ( expr ) ) ;
Preconditions . checkState ( NodeUtil . isForIn ( expr . getParent () ) ) ;
Preconditions . checkState ( NodeUtil . isForIn ( lvalue . getParent () ) ) ;
Node expr = NodeUtil . isForIn ( n ) ? n . getFirstChild () : NodeUtil . getConditionExpression ( n ) ;
if ( NodeUtil . isForIn ( n ) ) { return n ; }
if ( ! NodeUtil . isForIn ( node ) ) { tryJoinForCondition ( node ) ; tryMinimizeCondition ( NodeUtil . getConditionExpression ( node ) ) ; }
if ( ! NodeUtil . isForIn ( parent ) ) { return ( parent . getSecondChild () == expr ) ; }
( isForIn ( parent ) && parent . getFirstChild () == n )
return NodeUtil . isForIn ( n ) ? null : n . getSecondChild () ;
( isForIn ( parent ) && parent . getFirstChild () == n )
! NodeUtil . isForIn ( n )
parent . isFor () && ! NodeUtil . isForIn ( parent ) && NodeUtil . getConditionExpression ( parent ) != n
var . getParentNode () . isVar () && ! NodeUtil . isForIn ( var . getParentNode () . getParent () )
n . isAssign () && ! parent . isFor ()
n . isAssign () && ( parent . isExprResult () || parent . isFor () || parent . isReturn () )
( declaration . getParent () . isVar () && ! declaration . getGrandparent () . isFor () )
nextSibling . isFor () && nextSibling . getFirstChild () . isEmpty ()
Node initializer = n . isFor () ? n . getFirstChild () : IR . empty () ;
if ( ! parent . isFor () ) { assign = NodeUtil . newExpr ( assign ) ; }
Preconditions . checkNotNull ( scope ) ;
boolean preserveBlock = n . isBlock () && ! n . isSyntheticBlock () ;
parent . isBlock () || NodeUtil . isAnyFor ( parent ) || parent . isScript () || parent . isModuleBody () || parent . isLabel ()
boolean scanInnerBlocks = n . isSyntheticBlock () || NodeUtil . isFunctionBlock ( n ) || n . isModuleBody () ;
TypedScope s = new TypedScopeCreator ( compiler , CodingConventions . getDefault () ) . createInitialScope ( new Node ( Token.BLOCK ) ) ;
testMissingRequireCall ( js , STRING_CONSTANT ) ;
testMissingRequireCall ( js , STRING_CONSTANT ) ;
testMissingRequireCall ( js , STRING_CONSTANT ) ;
if ( this . optimizePropertyIndex && isObjectLiteralThatCanBeSkipped ( type ) ) { type = this . sentinelObjectLiteral ; }
new PeepholeMinimizeConditions ( late , useTypesForOptimization )
new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false ) , new PeepholeFoldConstants ( true , false ) )
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeMinimizeConditions ( late , useTypes ) ) ;
new PeepholeMinimizeConditions ( late , false )
new PeepholeMinimizeConditions ( late , false )
throw Throwables . propagate ( cause ) ;
if ( exception [ NUMBER_CONSTANT ] != null ) { Throwables . propagate ( exception [ NUMBER_CONSTANT ] ) ; }
try { TextFormat . merge ( textProto , builder ) ; } catch ( Exception e ) { throw Throwables . propagate ( e ) ; }
{ try { initialize ( metadata . getCompiler () ) ; } catch ( Exception e ) { Throwables . propagate ( e ) ; } }
@ Override public void setUp ( ) throws Exception { super . setUp () ; }
{ CompilerOptions options = super . getOptions () ; if ( enableUnusedLocalAssignmentCheck ) { options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ; } return options ; }
private String getNewName () { return paramPredix + uniqueId ++ ; }
{ this . compiler = Preconditions . checkNotNull ( compiler ) ; this . paramPredix = Preconditions . checkNotNull ( paramPrefix ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeMinimizeConditions ( late , useTypes , assumeAccurateNullUndefinedTypes ) ) ;
new PeepholeMinimizeConditions ( late , false , false )
new PeepholeMinimizeConditions ( late , false , false )
new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false , false ) , new PeepholeFoldConstants ( true , false ) )
new PeepholeMinimizeConditions ( late , useTypesForOptimization , options.assumeAccurateNullUndefinedTypes )
( new NodeTraversal ( compiler , this ) ) . traverseAtScope ( scope ) ;
{ addLibrary ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; setLanguage ( ES6 , ES5 ) ; testInjects ( STRING_CONSTANT ) ; }
validateSyntheticBlock ( n . getLastChild () ) ;
{ Preconditions . checkState ( body . isBlock () ) ; body . putBooleanProp ( Node.SYNTHETIC_BLOCK_PROP , true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
body . putBooleanProp ( Node.SYNTHETIC_BLOCK_PROP , true ) ;
block . putBooleanProp ( Node.SYNTHETIC_BLOCK_PROP , true ) ;
block . putBooleanProp ( Node.SYNTHETIC_BLOCK_PROP , true ) ;
public void testEmpty () { this . instrumentationPb = STRING_CONSTANT ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testSwitchCase () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveDo () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( src , src ) ;
public void testForIn () { inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ; inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ foldSame ( STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testDivision () { fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( js , js ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testNgInjectToArrowFunctions () { testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testReturnType () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRestParameter () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ testLocal ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testLocal ( STRING_CONSTANT , STRING_CONSTANT ) ; }
testLocal ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
testWithInversion ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( fullJsCode , fullJsCode ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ tryRemovingClinit ( t , node , parent ) ; if ( isNewControlBranch ( parent ) ) { clinitsCalledAtBranch = clinitsCalledAtBranch.parent ; } }
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode ) ;
this . functionSideEffectMap = ArrayListMultimap . create () ;
PropertyType pt = getPropTypeHelper ( jsdoc , initializer , rawType ) ;
{ lint ( Paths . get ( filename ) , false ) ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , VariableReferenceCheck.EARLY_REFERENCE ) ; }
testSame ( STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT ) ;
options.protectHiddenSideEffects = true ;
NodeTraversal outOfBandTraversal = new NodeTraversal ( compiler , this ) ;
{ Preconditions . checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.EXPR_RESULT , expr ) ; }
{ Node root = compiler . parseTestCode ( js ) ; assertEquals ( NUMBER_CONSTANT , compiler . getErrorCount () ) ; return root ; }
ScopeCreator scopeCreator = SyntacticScopeCreator . makeUntypedWithRedeclHandler ( compiler , new DuplicateDeclarationHandler () ) ;
if ( isConstructor ( n ) ) { processConstructor ( n ) ; }
NodeTraversal . traverseRootsEs6 ( compiler , new RemoveCode ( compiler ) , externs , root ) ;
handleTypedefDefinition ( t , n ) ;
Node memberType = parseTypeExpressionList ( next () ) ;
Node memberType = parseTypeExpressionList ( typeName , next () ) ;
lastIndex = replacement . getStartPosition () + replacement . getLength () ;
{ return compilerExecutor . runInCompilerThread ( callable , options != null && options . getTracerMode () . isOn () ) ; }
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode , definitionProvider , representativeNodesByName ) ;
this . functionSideEffectMap = new LinkedHashMap <> () ;
Object object
{ Preconditions . checkState ( token == Token.BLOCK ) ; putBooleanProp ( SYNTHETIC_BLOCK_PROP , val ) ; }
public void setTypeI ( TypeI type ) { this . typei = type ; }
public TypeI getTypeI () { return typei ; }
public void setJSType ( JSType jsType ) { this . typei = jsType ; }
Preconditions . checkArgument ( target != null , STRING_CONSTANT ) ;
public AncestorIterable getAncestors () { return new AncestorIterable ( this . getParent () ) ; }
public Node getParent () { return parent ; }
void setPropListHead ( PropListItem propListHead ) { this . propListHead = propListHead ; }
PropListItem getPropListHeadForTesting () { return propListHead ; }
public void setStaticSourceFile ( StaticSourceFile file ) { this . putProp ( STATIC_SOURCE_FILE , file ) ; }
PropListItem next
PropListItem next
Object value
{ Preconditions . checkState ( this . propListHead == null , STRING_CONSTANT ) ; this . propListHead = other.propListHead ; return this ; }
Preconditions . checkArgument ( target != null , STRING_CONSTANT ) ;
{ Preconditions . checkArgument ( child.parent == null ) ; child.parent = this ; }
public Node getSecondChild () { return first.next ; }
public Node getFirstChild () { return first ; }
PropListItem next
PropListItem next
PropListItem next
PropListItem next
@ Override public abstract PropListItem chain ( PropListItem next ) ;
PropListItem next
PropListItem chain ( PropListItem next ) ;
PropListItem getNext ( ) ;
Node memberType = parseTypeExpressionList ( next () ) ;
condition . isCall () && condition . getChildCount () == NUMBER_CONSTANT
Preconditions . checkState ( node . getChildCount () == NUMBER_CONSTANT ) ;
callName . matchesQualifiedName ( STRING_CONSTANT ) && n . getChildCount () == NUMBER_CONSTANT
boolean isDeprecatedCall = callNode . getChildCount () == NUMBER_CONSTANT && callName . isGetProp () ;
checkState ( n . getChildCount () == NUMBER_CONSTANT , n ) ;
Preconditions . checkState ( left . getChildCount () == NUMBER_CONSTANT ) ;
Preconditions . checkState ( n . getChildCount () == NUMBER_CONSTANT , n ) ;
Preconditions . checkState ( node . getChildCount () == NUMBER_CONSTANT ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope ) ; }
assertThat ( templateTypes ) . hasSize ( NUMBER_CONSTANT ) ;
String shortName = namespace . substring ( namespace . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
String shortName = namespace . substring ( namespace . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
String shortName = namespaceToRequire . substring ( namespaceToRequire . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope , true ) ; }
setReferencedType ( new NoResolvedType ( registry , getReferenceName () ) ) ;
{ Preconditions . checkState ( isAnalyzableObjectDefinePropertiesDefinition ( n ) ) ; return ImmutableList . of ( n . getLastChild () ) ; }
Preconditions . checkArgument ( parent . isVanillaFor () , STRING_CONSTANT , parent . getToken () ) ;
Preconditions . checkNotNull ( reportPath ) ;
NameInformation referring
NameInformation referring
Preconditions . checkNotNull ( ns ) ;
Preconditions . checkState ( node . isCall () ) ;
{ super ( name , node ) ; Preconditions . checkState ( node . isCall () ) ; }
{ super ( name , parent . getFirstChild () ) ; Preconditions . checkState ( parent . isAssign () ) ; }
{ checkLocalityOfMarkedCalls ( source , expected , LanguageMode.ECMASCRIPT6 ) ; checkLocalityOfMarkedCalls ( source , expected , LanguageMode.ECMASCRIPT5 ) ; }
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
assertPureCallsMarked ( templateSrc . replace ( STRING_CONSTANT , STRING_CONSTANT ) , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
JSType recvType = simpleInferExprType ( recv ) ;
JSType t = simpleInferExprType ( argNode ) ;
{ String name = NodeUtil . getName ( n ) ; noSideEffectExterns . put ( name , null ) ; }
qname != null && noSideEffectExterns . containsKey ( qname ) && ! isDefinedInSrc
Map < ParamGroup , CompilationParam [] > compilationParamsByGroup = new HashMap <> () ;
assertTrue ( functionA . getBodyNode () . isBlock () ) ;
assertTrue ( mainFunction . getAstNode () . isBlock () ) ;
assertTrue ( mainFunction . getBodyNode () . isBlock () ) ;
{ return n . isBlock () && n . hasChildren () && isReturnTypeNullable ( n . getParent () ) && ! hasSingleThrow ( n ) ; }
Preconditions . checkState ( n . getFirstChild () . isBlock () , n ) ;
markNameProcessed ( nameNode . getQualifiedName () ) ;
Preconditions . checkState ( root . isBlock () ) ;
if ( ! originalBody . isBlock () ) { originalBody = IR . block ( IR . returnNode ( originalBody ) ) . useSourceInfoFromForTree ( originalBody ) ; }
! body . isBlock ()
Preconditions . checkState ( block . isBlock () ) ;
Preconditions . checkState ( body . getNext () == null && body . isBlock () , body ) ;
checkState ( body . isBlock () , body ) ;
if ( n . isExprResult () || n . isBlock () ) { return; }
Preconditions . checkArgument ( block . isBlock () , STRING_CONSTANT ) ;
node . isFunction () && ! NodeUtil . getFunctionBody ( node ) . isBlock ()
if ( ! n . isBlock () || ! n . hasChildren () ) { return; }
if ( newChild . isBlock () ) { NodeUtil . tryMergeBlock ( newChild ) ; }
if ( ! n . isScript () && ! n . isBlock () ) { return; }
parent . isScript () || ( parent . isBlock () && parent . getParent () . isFunction () )
Preconditions . checkState ( caseBody . isBlock () ) ;
! labeledStatement . isBlock ()
if ( ! favorsCommaOverSemiColon && ! block . isBlock () ) { return false ; }
Preconditions . checkArgument ( node . isBlock () ) ;
parent != null && ( parent . isBlock () || parent . isScript () )
s . isFunctionScope () && s . getRootNode () . getLastChild () . isBlock ()
for ( Node child : node . children () ) { if ( child . isBlock () ) { blocks . add ( child ) ; } }
! target . getParent () . isScript () && ! target . getParent () . isBlock ()
! n . getParent () . isScript () && ! n . getParent () . isBlock ()
boolean isVar = NodeUtil . isNameDeclaration ( parent ) && parent . getParent () . isBlock () ;
isGoogScopeFunctionBody ( enclosingFunctionBody ) && scopeRoot . isBlock () && ! scopeRoot . getParent () . isFunction ()
NodeUtil . isControlStructureCodeBlock ( n , c ) && ! c . isBlock ()
! setFunction . hasChildren () || ! setFunction . getLastChild () . isBlock () || ! setFunction . getSecondChild () . isParamList ()
if ( ! getFunction . hasChildren () || ! getFunction . getLastChild () . isBlock () ) { return false ; }
if ( ! n . isFunction () || ! n . getLastChild () . isBlock () ) { return; }
if ( n . isEmpty () || ( n . isBlock () && ! n . hasChildren () ) ) { return; }
next != null && next . isBlock ()
if ( ! body . isBlock () || ! body . hasOneChild () || ! body . getFirstChild () . isReturn () ) { return; }
{ Preconditions . checkArgument ( blockNode . isBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
if ( n . isBlock () ) { visitBlock ( n ) ; }
{ Preconditions . checkArgument ( n . isBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
Preconditions . checkState ( addingRoot . isBlock () || addingRoot . isModuleBody () || addingRoot . isScript () ) ;
{ return n . isBlock () && n . getParent () != null && n . getParent () . isFunction () ; }
Preconditions . checkState ( block . isBlock () ) ;
for ( ; ! currentParent . isScript () && ! currentParent . isBlock () ; current = currentParent , currentParent = currentParent . getParent () ) {}
if ( ! ( parent . isScript () || grandparent != null && grandparent . isFunction () && parent . isBlock () ) ) { return; }
body . isBlock () && ! body . hasChildren ()
{ return ( n . isBlock () && n . isSyntheticBlock () ) || n . isScript () ; }
Preconditions . checkState ( block . isBlock () ) ;
return expectedBlock . isBlock () ? expectedBlock : null ;
if ( ! subtree . isScript () && ! subtree . isBlock () ) { return subtree ; }
Preconditions . checkState ( n . isBlock () , n ) ;
if ( maybeAssign . isBlock () || maybeAssign . isScript () || NodeUtil . isStatement ( maybeAssign ) ) { return; }
n . isBlock () && ! loneBlocks . isEmpty () && loneBlocks . peek () == n
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( finallyBody . isBlock () ) ;
Preconditions . checkState ( tryBody . isBlock () ) ;
{ Preconditions . checkState ( body . isBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( then . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
! isArrow && ! isSignature && ! bodyNode . isBlock ()
! irNode . isBlock ()
n . hasChildren () && n . getFirstChild () . isBlock ()
Preconditions . checkState ( collectionRoot . isScript () || collectionRoot . isBlock () ) ;
Preconditions . checkState ( externs . isBlock () ) ;
{ assertTrue ( mainRoot . isBlock () && ! mainRoot . hasChildren () ) ; }
assertTrue ( functionA . getBodyNode () . isNormalBlock () ) ;
assertTrue ( mainFunction . getAstNode () . isRoot () ) ;
assertTrue ( mainFunction . getBodyNode () . isRoot () ) ;
return ImmutableList . of ( bang , qmark ) ;
return scopeRoot . isBlock () && scopeRoot . getParent () != null && scopeRoot . getParent () . isFunction () ;
( parent . isScript () || ( parent . isBlock () && ! parent . isSyntheticBlock () && ! parent . isAddedBlock () ) )
block . isBlock () && block . getParent () . isTry () && block . getParent () . getFirstChild () == block
node . isBlock () && parent != null && parent . isTry () && NodeUtil . getCatchBlock ( parent ) == node
if ( ! n . isBlock () || ! n . hasChildren () || ! isGoogModuleCall ( n . getFirstChild () ) ) { return false ; }
if ( ! block . isBlock () ) { return false ; }
if ( node . isBlock () ) { node . setToken ( Token.SCRIPT ) ; }
boolean needsSemicolon = parent != null && ( parent . isExprResult () || parent . isBlock () || parent . isScript () ) ;
deleteWhitespaceBefore && parent != null && ( parent . isScript () || parent . isBlock () )
Preconditions . checkState ( parentNode . isBlock () , STRING_CONSTANT ) ;
endPass () ;
endPass () ;
endPass () ;
endPass () ;
! currentScope . hasThis () && NodeUtil . referencesSuper ( fn )
{ renamer = nameStack . peek () . forChildScope ( ! NodeUtil . createsBlockScope ( declarationRoot ) ) ; }
if ( isInferrableConst ( jsdoc , name ) ) { jsdoc = pullJsdocTypeFromAst ( compiler , jsdoc , name ) ; }
testSame ( STRING_CONSTANT ) ;
warnings . add ( JSError . make ( propAccessNode , ABSTRACT_METHOD_NOT_CALLABLE , funName ) ) ;
{ Preconditions . checkState ( languageIn != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
Node argList = getFunctionArgList ( function ) ;
Node argList = getFunctionArgList ( function ) ;
throw new MalformedException ( STRING_CONSTANT + node . getToken () , fnChild ) ;
findDeclaredNames ( functionBody , null , renamer ) ;
if ( ! declarationRoot . isFunction () ) { findDeclaredNames ( declarationRoot , null , renamer ) ; }
Preconditions . checkArgument ( declaration . isName () ) ;
void clear () { prefixNames . clear () ; seenNames . clear () ; constructorsToProcess . clear () ; }
for ( String prefix : Iterables . concat ( seenNames , prefixNames ) ) { if ( fullyQualifiedName . startsWith ( prefix ) ) { return true ; } }
if ( instrumentationData . get ( fileName ) != null ) { node . addChildToFront ( newHeaderNode ( traversal , node ) ) ; }
{ node . addChildToFront ( newHeaderNode ( traversal , node ) ) ; instrumentBranchCoverage ( traversal , instrumentationData . get ( fileName ) ) ; }
{ return isUnionType () ? this . toMaybeUnionType () . getAlternates () : null ; }
JSType type
JSType type = getType ( typeObj ) ;
JSType type = getType ( n ) ;
this . BOTTOM_OBJECT = this . registry . getNativeType ( JSTypeNative.NO_OBJECT_TYPE ) . toObjectType () ;
JSType type
JSType type
{ objectType = FunctionType . getTopDefiningInterface ( objectType , propName ) ; }
if ( isInterface () ) { return getTopDefiningInterface ( getInstanceType () , propertyName ) ; }
if ( lvalueType . isEnumElement () ) { lvalueType = lvalueType . getEnumeratedType () ; }
JSType enumeratedType = requiredType . getProp ( new QualifiedName ( pname ) ) . getEnumeratedType () ;
JSType enumeratedType = requiredType . getProp ( new QualifiedName ( pname ) ) . getEnumeratedType () ;
{ NominalType tmp = NominalType . pickSuperclass ( n1 , n2 ) ; if ( tmp != null ) { return tmp . getInstanceAsJSType () ; } }
NominalType nominal = NominalType . pickSuperclass ( nt1 , nt2 ) ;
{ Preconditions . checkState ( n . isName () , n ) ; n . removeChild ( n . getFirstChild () ) ; }
parent . removeChild ( parent . getFirstChild () ) ;
! currentScript.declareLegacyNamespace && currentScript.defaultExportRhs == null && namedExport . hasInlinableName ()
Preconditions . checkArgument ( o instanceof JSType ) ;
this . registry = compiler . getTypeRegistry () ;
test ( externs , js , expected , null , warning , description ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES + STRING_CONSTANT + STRING_CONSTANT ;
testSets ( BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES , js , output , STRING_CONSTANT ) ;
{ super . setUp () ; super . enableNormalize () ; super . enableTypeCheck () ; }
public DisambiguatePropertiesTest () { parseTypeInfo = true ; }
if ( ! t . inGlobalHoistScope () ) { return false ; }
{ assertEquals ( e . getType () , type ) ; assertEquals ( e.lineNumber , lineNumber ) ; }
assertEquals ( result.errors [ NUMBER_CONSTANT ] . getType () , errorType ) ;
assertTrue ( result.success ) ;
assertTrue ( compiler . getResult () . success ) ;
checkShortGoogRequireCall ( t , callNode , parent ) ;
options . setPolymerPass ( true ) ;
polymerPass = false ;
if ( options.deadAssignmentElimination ) { passes . add ( deadAssignmentsElimination ) ; if ( ! options.polymerPass ) { passes . add ( deadPropertyAssignmentElimination ) ; } }
options . setPolymerPass ( true ) ;
if ( other . isGeneric () ) { other = instantiateGenericsWithUnknown ( other ) ; }
{ if ( this . equals ( other ) ) { return true ; } return instantiateGenericsWithUnknown ( this ) . isSubtypeOfHelper ( other , checkThisType , subSuperMap , boxedInfo ) ; }
if ( isGeneric () ) { return instantiateGenericsWithUnknown ( this ) . transformByApplyProperty () ; }
Preconditions . checkArgument ( rootNode != parent.rootNode , STRING_CONSTANT , rootNode , parent.rootNode ) ;
public void testDontCrashCtorAliasWithEnum () { test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; compareJsDoc = false ; }
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
public void testGlobalObjectDeclaredToPreserveItsPreviousValue2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjLitAssignmentDepth2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; compareJsDoc = false ; }
boolean isConstDeclaration () { return getParent () . isConst () ; }
boolean isVarDeclaration () { return getParent () . isVar () ; }
String code = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
options.prettyPrint = true ;
this . prettyPrint = options.prettyPrint ;
options . setPrettyPrint ( true ) ;
this . prettyPrint = options . isPrettyPrint () ;
public void testJqueryExpandedEachExpansionEs6ComputedProp () { testErrorEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ExpandJqueryAliases.JQUERY_UNABLE_TO_EXPAND_INVALID_NAME ) ; }
options.prettyPrint = true ;
this . prettyPrint = options.prettyPrint ;
{ options . setPolymerPass ( value ) ; }
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testError ( STRING_CONSTANT , VarCheck.VAR_ARGUMENTS_SHADOWED_ERROR ) ;
{ checkState ( scope . getParent () == null ) ; scanVars ( n , true , true ) ; }
public void testTypeParsingOnWithVerbose () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ; test ( STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ; }
testSame ( DEFAULT_EXTERNS , STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ;
markConstAndCopyJsDoc ( assignNode , jsdocNode , rhs ) ;
markConstAndCopyJsDoc ( target , target , value ) ;
markConstAndCopyJsDoc ( jsdocNode , jsdocNode , parent . getLastChild () ) ;
{ return list . get ( list . size () - NUMBER_CONSTANT ) ; }
super . setCode ( cachedCode , this . getCharset () == StandardCharsets.UTF_8 ) ;
super . setCode ( cachedCode , this . getCharset () == StandardCharsets.UTF_8 ) ;
if ( this . ns != null ) { builder . append ( this . ns . toString () ) ; }
{ if ( inheritedPropDef.methodType != null ) { propMethodTypesToProcess . put ( pname , inheritedPropDef.methodType . substituteNominalGenerics ( superType ) ) ; } }
{ Preconditions . checkState ( this . rawType . isFinalized () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) . substituteGenerics ( typeMap ) ; }
this . inGeneratorContext . add ( initialGeneratorContext ) ;
Node namespaceArg = crDefineCallNode . getChildAtIndex ( NUMBER_CONSTANT ) ;
Node pathArg = crExportPathNode . getChildAtIndex ( NUMBER_CONSTANT ) ;
String target = call . getChildAtIndex ( NUMBER_CONSTANT ) . getQualifiedName () ;
{ int result = BASE64_DECODE_MAP [ c ] ; assert ( result != - NUMBER_CONSTANT ) : STRING_CONSTANT ; return BASE64_DECODE_MAP [ c ] ; }
ParseTree arrowFunctionBody = parseArrowFunctionBody ( expressionIn ) ;
ParseTree arrowFunctionBody = parseArrowFunctionBody ( expressionIn ) ;
parseGeneratorFunctionTail ( builder ) ;
parseFunctionTail ( builder ) ;
parseFunctionTail ( builder ) ;
parseFunctionTail ( builder ) ;
parseFunctionTail ( builder , isGenerator ) ;
parseFunctionTail ( builder , isGenerator ) ;
parseFunctionTail ( builder , isGenerator ) ;
recvType = recvType . removeType ( commonTypes.NULL ) ;
if ( NodeUtil . isCallTo ( destructuringLhsNode . getLastChild () , STRING_CONSTANT ) ) { return; }
if ( aliasVarNodeRhs == null || ! NodeUtil . isCallTo ( aliasVarNodeRhs , STRING_CONSTANT ) ) { t . report ( call , INVALID_GET_ALIAS ) ; return; }
return call != null && NodeUtil . isCallTo ( call , STRING_CONSTANT ) && call . getLastChild () . isFunction () ;
nameGenerator . reset ( reservedNames , STRING_CONSTANT , reservedCharacters ) ;
{ this ( compiler , generatePseudoNames , prevUsedPropertyMap , null , nameGenerator ) ; }
{ this ( compiler , generatePseudoNames , null , null , nameGenerator ) ; }
NameGenerator nameGen = new DefaultNameGenerator ( reservedNames . build () , STRING_CONSTANT , reservedCharacters ) ;
reset ( reservedNames , prefix , reservedCharacters ) ;
{ return new AmbiguateProperties ( compiler , options.anonymousFunctionNaming . getReservedCharacters () ) ; }
if ( isBottom () || isUnknown () || hasTruthyMask () ) { return this . commonTypes . UNKNOWN ; }
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; recordImplicitUseOfNativeObject ( n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; recordImplicitUseOfNativeObject ( n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , caseType , switchType ) ; }
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; recordImplicitUseOfNativeObject ( n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; recordImplicitUseOfNativeObject ( n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ; return options ; }
for ( Var v : globalExternsScope . getAllSymbols () ) { considerVar ( v , null ) ; }
parseWarning ( STRING_CONSTANT , STRING_CONSTANT ) ;
for ( Var v : globalExternsScope . getVarIterable () ) { considerVar ( v , null ) ; }
for ( TypedScope s : scopes . values () ) { Iterables . addAll ( vars , s . getVarIterable () ) ; }
{ return isContinueStructure ( target ) && matchLabel ( target . getParent () , label ) ; }
{ if ( leftOfArrow.type == ParseTreeType.CALL_EXPRESSION ) { return completeAssignmentExpressionParseAtArrow ( leftOfArrow . asCallExpression () , expressionIn ) ; } else { return completeArrowFunctionParseAtArrow ( leftOfArrow , expressionIn ) ; } }
if ( ! sourceType . isSubtypeWithoutStructuralTyping ( targetType ) ) { recordImplicitInterfaceUses ( n , sourceType , targetType ) ; }
recordImplicitInterfaceUses ( n , argType , paramType ) ;
recordImplicitInterfaceUses ( n , rightType , leftType ) ;
recordImplicitInterfaceUses ( n , rightType , leftType ) ;
recordImplicitInterfaceUses ( n , caseType , switchType ) ;
if ( topInterface != null && topInterface . getConstructor () != null ) { foundType = topInterface . getConstructor () . getPrototypeProperty () ; }
if ( isPrototypeObject () ) { return builder . append ( getOwnerFunction () . getInstanceTypeOfCtor () ) . append ( STRING_CONSTANT ) ; }
{ ObjectType obj = getObjTypeIfSingletonObj () ; return obj != null && obj . hasOwnPropery ( new QualifiedName ( propertyName ) ) ; }
if ( this . equals ( proto ) ) { Preconditions . checkState ( this . isUnknownObject () , STRING_CONSTANT , this ) ; return null ; }
test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
testSets ( js , output , STRING_CONSTANT + STRING_CONSTANT ) ;
n . isVar () && n . getFirstFirstChild () != null && n . getFirstFirstChild () . isFunction ()
return builder () . withCharset ( inputCharset ) . withOriginalPath ( originalZipPath + STRING_CONSTANT + entryPath ) . buildFromUrl ( zipEntryUrl ) ;
assertPasses ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
parent . isVar () || parent . isExprResult ()
println ( STRING_CONSTANT + funType ) ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendStringPart ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected void setUp () { style = RELAX ; compareJsDoc = false ; }
@ Override public void setUp () { enableNormalize () ; compareJsDoc = false ; }
{ if ( options == null ) { initOptions ( newCompilerOptions () ) ; } return errorManager ; }
inputsById = new HashMap <> () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = errorManager ; }
{ if ( options == null ) { initOptions ( new CompilerOptions () ) ; } return errorManager ; }
inputsById . clear () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
Preconditions . checkState ( ! areSubtypes ) ;
{ switch ( ch ) { case CHAR_CONS : case CHAR_CONS : return true ; default: return Character . isLetter ( ch ) ; } }
{ if ( options == null ) { initOptions ( newCompilerOptions () ) ; } return errorManager ; }
inputsById = new HashMap <> () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = errorManager ; }
Preconditions . checkArgument ( callNode . isCall () ) ;
fold ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ; return options ; }
Node root = compiler . getRoot () . getLastChild () ;
{ assertThat ( aggregateWarnings ) . isEmpty () ; }
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
public void testCodeMotionDoesntBreakFunctionHoisting ( ) throws Exception { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testConst () { testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testLet () { testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
{ testRewriteWarning ( code , expected , warning , LanguageMode.ECMASCRIPT3 ) ; testRewriteWarning ( code , expected , warning , LanguageMode.ECMASCRIPT6 ) ; }
{ testRewriteError ( js , error , LanguageMode.ECMASCRIPT3 ) ; testRewriteError ( js , error , LanguageMode.ECMASCRIPT6 ) ; }
{ testRewrite ( code , expected , LanguageMode.ECMASCRIPT3 ) ; testRewrite ( code , expected , LanguageMode.ECMASCRIPT6 ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; allowExternsChanges ( true ) ; }
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT8 ;
languageMode = LanguageMode.ECMASCRIPT8 ;
public void testAsyncArrowFunction () { languageMode = LanguageMode.ECMASCRIPT8 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT8 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testMemberGeneratorYield1 () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testNewTarget () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDefaultParametersWithRestParameters () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testRestParameters () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDefaultParameters () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testOctalNumericKey () { allowWarnings = true ; languageMode = LanguageMode.ECMASCRIPT6 ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testComputedPropertiesClassMethods () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
{ assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrettyPrinter_defaultValue ( ) throws Exception { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testPrettyPrinter_arrow ( ) throws Exception { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testForOf () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDestructuringForOfLoops2 () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrintDestructuringInRestParam () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrintMixedDestructuring () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testPrettyPrintObjectPattern () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrintNestedObjectPattern () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testPrettyPrintArrayPattern () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrintBlockScopedFunctions () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExponentiationAssignmentOperator () { languageMode = LanguageMode.ECMASCRIPT7 ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT7 ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; compiler = createCompiler () ; }
public void testWhileLoopBranch ( ) throws Exception { compareWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareWhileLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testDoWhileLoopMultiLineBranch ( ) throws Exception { compareDoWhileLoopMultiLineBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopMultiLineBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testDoWhileLoopBranch ( ) throws Exception { compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testForLoopBranch ( ) throws Exception { compareForLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareForLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testIfElseBranch ( ) throws Exception { compareIfElseBranch ( LanguageMode.ECMASCRIPT5 ) ; compareIfElseBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testIfBranch ( ) throws Exception { compareIfBranch ( LanguageMode.ECMASCRIPT5 ) ; compareIfBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testFunction ( ) throws Exception { compareFunctionOneMode ( LanguageMode.ECMASCRIPT5 ) ; compareFunctionOneMode ( LanguageMode.ECMASCRIPT6 ) ; }
return languageOutIsAtLeast ( LanguageMode.ECMASCRIPT6 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
{ setLanguage ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setLanguage ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; runTypeCheckAfterProcessing = true ; }
{ testExternChanges ( extern , input , expectedExtern , LanguageMode.ECMASCRIPT6 ) ; testExternChanges ( extern , input , expectedExtern , LanguageMode.ECMASCRIPT5 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testWarning ( js , warning , warningMessage ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testWarning ( js , warning ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testWarning ( js , warning ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT6 ) ; testError ( js , error , LanguageMode.ECMASCRIPT5 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testError ( js , es6Error ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testError ( js , es5Error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testError ( js , error ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testError ( js , error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( externs , js , diag , error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testSame ( externs , js , warning ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . test ( js , js ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . test ( js , js ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . test ( js , js ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
{ test ( js , expected , LanguageMode.ECMASCRIPT6 ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ test ( js , expected , LanguageMode.ECMASCRIPT6 ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . test ( js , expected ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . test ( js , expected ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; anchorUnusedVars = false ; canRemoveExterns = false ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; allowExternsChanges ( false ) ; }
{ CompilerOptions options = super . getOptions () ; options . setLanguageIn ( LanguageMode.ECMASCRIPT6_TYPED ) ; options . setLanguageOut ( LanguageMode.ECMASCRIPT6 ) ; return options ; }
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
{ super . setUp () ; compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ; compilerOptions . setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , VarCheck.VIOLATED_MODULE_DEP_ERROR ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , VarCheck.VIOLATED_MODULE_DEP_ERROR ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , VarCheck.MISSING_MODULE_DEP_ERROR ) ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , VarCheck.MISSING_MODULE_DEP_ERROR ) ; }
public void testLegalConstReferenceBetweenModules () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testLegalLetReferenceBetweenModules () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testObjLit () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; assertUnreachable ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testForLoopsEs6 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; assertUnreachable ( STRING_CONSTANT ) ; assertUnreachable ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public CheckUnusedPrivatePropertiesTest () { super ( EXTERNS ) ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; }
compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
{ compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
public void testFunctionNonMovement1 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; testSame ( createModuleStar ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
public void testInvalidVariableInScope () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_INVALID_VARIABLE ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_INVALID_VARIABLE ) ; }
public void testNonAliasLocal () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testJSDocCopiedForClasses () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testObjectLiteralMethods () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testObjectLiteralShorthand () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testDefaultParameter () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testClassDefinition3 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testClassDefinition2 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testClassDefinition1 () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testArrowFunction () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testNonTopLevelDestructuring () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testObjectDescructuringError2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testObjectDescructuringError1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testDestructuringError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testYieldExpression () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
{ testScopedNoChanges ( aliases , code , LanguageMode.ECMASCRIPT3 ) ; testScopedNoChanges ( aliases , code , LanguageMode.ECMASCRIPT6 ) ; }
{ testScoped ( code , expected , LanguageMode.ECMASCRIPT3 ) ; testScoped ( code , expected , LanguageMode.ECMASCRIPT6 ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testAsyncFunction () { setLanguage ( LanguageMode.ECMASCRIPT8 , LanguageMode.ECMASCRIPT5 ) ; testError ( STRING_CONSTANT , CANNOT_CONVERT_YET ) ; testError ( STRING_CONSTANT , CANNOT_CONVERT_YET ) ; }
public void testExponentiationAssignmentOperator () { setLanguage ( LanguageMode.ECMASCRIPT7 , LanguageMode.ECMASCRIPT5 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExponentiationOperator () { setLanguage ( LanguageMode.ECMASCRIPT7 , LanguageMode.ECMASCRIPT5 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; runTypeCheckAfterProcessing = true ; }
setLanguage ( LanguageMode.ECMASCRIPT8 , LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( LanguageMode.ECMASCRIPT8 , LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( LanguageMode.ECMASCRIPT8 , LanguageMode.ECMASCRIPT5 ) ;
public void testValidRestParameter () { setLanguage ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ; valid ( STRING_CONSTANT ) ; valid ( STRING_CONSTANT ) ; }
options . setLanguage ( LanguageMode.ECMASCRIPT8 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
return CompilerOptions.LanguageMode.ECMASCRIPT6_STRICT ;
this . languageIn = CompilerOptions.LanguageMode.ECMASCRIPT6 ;
options . setLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageOut ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
setLanguage ( LanguageMode.ECMASCRIPT6_STRICT , LanguageMode.ECMASCRIPT5_STRICT ) ;
compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
{ testOk ( createFunction ( body ) ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testOk ( createShorthandFunctionInObjLit ( body ) ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testEs6EnhancedObjLiteralsPropertyShorthand () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testEs6EnhancedObjLiteralsComputedValuesNotRemoved () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testES6ClassComputedProperty () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT ) ; }
public void testEs6GettersWithoutTranspilation () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; languageOut = LanguageMode.ECMASCRIPT3 ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( createShorthandFunctionInObjLit ( returnType , body ) ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; String js = createShorthandFunctionInObjLit ( returnType , body ) ; testWarning ( js , CheckMissingReturn.MISSING_RETURN_STATEMENT ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; runTypeCheckAfterProcessing = true ; compareJsDoc = true ; }
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
public void testNoMoveDeepFunctionDeclarations () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testInlineEmptyFunction6 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrowFunction4 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testFailure ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrowFunction3 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testFailure ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrowFunction2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testFailure ( STRING_CONSTANT ) ; }
public void testArrowFunction1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testFailure ( STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; runTypeCheckAfterProcessing = true ; propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT8 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; runTypeCheckAfterProcessing = true ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
public void testTaggedTemplateError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; }
public void testInlineIntoNestedNonHoistedNamedFunctions () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNoRewriteIfNotInGlobalScope1 ( ) throws Exception { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT + NoRewriteIfNotInGlobalScopeTestInput.INPUT + STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; runTypeCheckAfterProcessing = true ; compareJsDoc = true ; }
replaceSymbol ( n , name , t . getInput () ) ;
com.google.javascript.jscomp.newtypes.FunctionType ctorType = functionType . getFunTypeIfSingletonObj () ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
{ Preconditions . checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
checkState ( child.parent == this ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
replaceSymbol ( t , n , name , t . getInput () ) ;
findDeclaredNames ( functionBody , renamer , false ) ;
if ( ! declarationRoot . isFunction () ) { findDeclaredNames ( declarationRoot , renamer , false ) ; }
testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ;
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
checkState ( child.parent == this , STRING_CONSTANT , child , parent ) ;
{ checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
checkState ( child.parent == this ) ;
{ Preconditions . checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
Preconditions . checkState ( this . isFinalized , STRING_CONSTANT , this ) ;
{ Preconditions . checkState ( ! this . isFinalized ) ; super . addProperty ( pname , defSite , type , isConstant ) ; }
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( this . isFinalized ) ;
if ( ! this . isFinalized ) { return null ; }
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
public boolean isStruct () { Preconditions . checkState ( isFinalized () || isClass () ) ; return this . objectKind . isStruct () ; }
{ if ( isFinalized && externs . containsKey ( name ) ) { type = externs . get ( name ) ; } }
Preconditions . checkState ( isFinalized ) ;
Preconditions . checkState ( this . rawType . isFinalized () ) ;
{ Preconditions . checkState ( this . rawType . isFinalized () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
Preconditions . checkState ( this . rawType . isFinalized () ) ;
public RawNominalType getRawNominalType () { Preconditions . checkState ( ! this . rawType . isFinalized () ) ; return this . rawType ; }
Preconditions . checkArgument ( nominalType . isFinalized () ) ;
Preconditions . checkArgument ( nominalType . isFinalized () ) ;
if ( ! thisNode . isEquivalentToShallow ( thatNode ) ) { return false ; }
ScopedChangeHandler () { this . lastCodeChangeQuery = timestamp ; }
maybeSanityCheck ( externs , root ) ;
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
@ Override public void setUp () { enableNormalize () ; }
@ Override protected void setUp () { super . enableNormalize () ; }
@ Override protected void setUp () { nameGenerator = null ; }
@ Override public void setUp () { enableNormalize () ; }
@ Override public void setUp () { super . enableLineNumberCheck ( false ) ; }
@ Override public void setUp () { enableNormalize () ; }
public InlineVariablesConstantsTest () { enableNormalize () ; }
@ Override public void setUp () { enableNormalize () ; }
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; }
@ Override public void setUp () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; }
@ Override protected void setUp () { super . enableLineNumberCheck ( false ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; }
@ Override public void setUp () { enableNormalize () ; }
globalScope = TypedScope . createGlobalScope ( blockNode ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope ) ; }
setReferencedType ( registry . getNativeObjectType ( JSTypeNative.NO_RESOLVED_TYPE ) ) ;
@ Override public void setUp () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; validateAstChangeMarking ( false ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
compiler . reportCodeChange () ;
{ Node grandparent = parent . getParent () ; replaceWithEmpty ( parent , grandparent ) ; compiler . reportCodeChange () ; }
@ Override public boolean isUnresolved () { return false ; }
JSTypes getCommonTypes () { return this . commonTypes ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ newBlockNode . useSourceInfoIfMissingFromForTree ( oldBlockNode ) ; functionNode . replaceChild ( oldBlockNode , newBlockNode ) ; compiler . reportCodeChange () ; }
if ( ! origValueNode . getString () . equals ( newString ) ) { origValueNode . setString ( newString ) ; compiler . reportCodeChange () ; }
enableTypeCheck () ;
public void testCoercionSubstitution_boxedNumberVsZero () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
compiler . reportCodeChange () ;
{ Node retValue = returnedValue . cloneTree () ; parent . replaceChild ( call , retValue ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
if ( ! p.newName . equals ( oldName ) ) { n . setString ( p.newName ) ; compiler . reportCodeChange () ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( ! collapses . isEmpty () ) { applyCollapses () ; compiler . reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ callTarget . getLastChild () . setString ( STRING_CONSTANT ) ; firstArg . getNext () . detach () ; reportCodeChange () ; return n ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; reportCodeChange () ; return newNode ; }
if ( rhs . isChanged () ) { reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( placeholder , mNode . getNode () . removeFirstChild () ) ; reportCodeChange () ; }
reportCodeChange () ;
this . reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ parent . removeChild ( n ) ; compiler . reportCodeChange () ; functions . put ( t . getModule () , n ) ; }
compiler . reportCodeChange () ;
reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
t . getCompiler () . reportCodeChange () ;
compiler . reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; reportCodeChange () ; return result ; }
reportCodeChange () ;
{ n . detachChildren () ; parent . replaceChild ( n , result ) ; reportCodeChange () ; return result ; }
reportCodeChange () ;
reportCodeChange () ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; reportCodeChange () ; return replacementNode ; }
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; reportCodeChange () ; }
reportCodeChange () ;
{ node . getParent () . removeChild ( node ) ; reportCodeChange () ; return null ; }
compiler . reportCodeChange () ;
@ Override protected void setUp () { allowExternsChanges ( true ) ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
void apply () { parent . replaceChild ( oldChild , newChild ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . setString ( newName ) ; t . getCompiler () . reportCodeChange () ; return; }
{ n . setString ( prop + fileid ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
@ Override protected void setUp () { super . enableLineNumberCheck ( false ) ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
if ( node != null ) { n . setDeclaredTypeExpression ( node ) ; compiler . reportCodeChange () ; }
{ attachTypeExpr = IR . rest ( n . getString () ) ; n . replaceWith ( attachTypeExpr ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
reportCodeChange () ;
compiler . reportCodeChange () ;
{ if ( NodeUtil . getPureBooleanValue ( forCondition ) == TernaryValue.TRUE ) { forCondition . replaceWith ( IR . empty () ) ; reportCodeChange () ; } }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
{ maybeBreak . detach () ; reportCodeChange () ; }
reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; reportCodeChange () ; return right ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
@ Override protected void setUp () { super . enableNormalize () ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
for ( Node closureRequire : requiresToBeRemoved ) { closureRequire . detach () ; compiler . reportCodeChange () ; }
notifyOfRemoval ( node ) ;
{ parent . removeChild ( node ) ; notifyOfRemoval ( node ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
{ functionBody . removeChild ( current ) ; insertAfter = addToFront ( functionBody , current , insertAfter ) ; reportCodeChange ( STRING_CONSTANT ) ; }
reportCodeChange ( STRING_CONSTANT ) ;
reportCodeChange ( STRING_CONSTANT ) ;
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( maybeNormalizeFunctionDeclaration ( n ) ) { reportCodeChange ( n , STRING_CONSTANT ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ return new TypeInformationGatherer ( compiler , new DevirtualizePrototypeMethods ( compiler ) , typeInformation ) ; }
Iterable < JSModule > getAllModules () { return modules ; }
n . isName () && n . getParent () . isVar ()
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
compiler . setScope ( root ) ;
setInputId ( null , STRING_CONSTANT ) ;
setInputId ( NodeUtil . getInputId ( scopeRoot ) , STRING_CONSTANT ) ;
setInputId ( NodeUtil . getInputId ( root ) , STRING_CONSTANT ) ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ c . setQuotedString () ; compiler . reportCodeChange () ; }
@ Override public void setUp () { super . enableLineNumberCheck ( false ) ; validateAstChangeMarking ( false ) ; }
{ Node dollarChildProp = n . getGrandparent () ; dollarChildProp . setToken ( Token.GETELEM ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ parent . replaceChild ( n , declaringNode . getFirstFirstChild () . cloneTree () ) ; compiler . reportCodeChange () ; }
{ if ( isUtilGetDefineCall ( n ) ) { substituteUtilGetDefine ( n ) ; } }
t . getCompiler () . reportCodeChange () ;
t . getCompiler () . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( isGoogLoadModuleStatement ( n ) ) { updateGoogLoadModuleLate ( n ) ; }
{ n . putBooleanProp ( Node.GOOG_MODULE , true ) ; inlineModuleIntoGlobal ( n ) ; compiler . reportCodeChange () ; checkAndSetStrictModeDirective ( t , n ) ; }
if ( newJsdoc != null ) { jsdocNode . setJSDocInfo ( newJsdoc ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
{ if ( NodeUtil . isDestructuringDeclaration ( n ) ) { splitDeclaration ( n , parent ) ; } }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; compiler . reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; compiler . reportCodeChange () ; return null ; }
for ( Node childToRemove : nodesToRemove ) { node . removeChild ( childToRemove ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ visitArrowFunction ( n , checkNotNull ( thisContext ) ) ; }
if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; compiler . reportCodeChange () ; return newNode ; }
if ( rhs . isChanged () ) { compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . replaceChild ( placeholder , mNode . getNode () . removeFirstChild () ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detach () ; compiler . reportCodeChange () ; return null ; }
this . compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( tryReplaceArguments ( traversal . getScope () ) ) { traversal . getCompiler () . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; compiler . reportCodeChange () ; return newLiteralNode ; }
if ( canFoldStandardConstructors ( n ) ) { n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
visitClass ( n , parent ) ;
visitRestParam ( n , parent ) ;
compiler . reportCodeChange () ;
{ if ( NodeUtil . getPureBooleanValue ( forCondition ) == TernaryValue.TRUE ) { forCondition . replaceWith ( IR . empty () ) ; compiler . reportCodeChange () ; } }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; compiler . reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ maybeBreak . detach () ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; compiler . reportCodeChange () ; return right ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ callTarget . getLastChild () . setString ( STRING_CONSTANT ) ; firstArg . getNext () . detach () ; compiler . reportCodeChange () ; return n ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
JSTypeExpression typeExpr = getTypeFromGetterOrSetter ( member ) . clone () ;
{ if ( expr != null ) { return cloneTypeNodes ? expr . clone () : expr ; } return null ; }
if ( foundObj . isGeneric () ) { foundType = foundObj . getRawType () ; }
ImmutableMap < String , JSType > typeVars
if ( obj != null && obj . isGeneric () ) { return obj . instantiateGenericsWithUnknown () ; }
if ( foundType != null && foundType . isGeneric () ) { foundType = foundType . getRawType () ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new PropagateConstJsdoc ( compiler ) ) ; new RemoveCode ( compiler ) . process ( externs , root ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; validateAstChangeMarking ( false ) ; }
JSType type = n . getJSType () ;
JSType type = n . getJSType () ;
if ( extractionInfo . shouldExtract () ) { doExtraction ( extractionInfo ) ; compiler . reportCodeChange () ; }
compiler . reportChangeToEnclosingScope ( getKey . getParent () ) ;
{ if ( logger . isLoggable ( Level.FINE ) ) { logger . fine ( STRING_CONSTANT + callName ) ; } inlineEmptyMethod ( parent , callNode ) ; }
t . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; validateAstChangeMarking ( false ) ; }
for ( Definition def : definitionsGatherer.definitions ) { def . remove () ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; compiler . reportCodeChange () ; return result ; }
compiler . reportCodeChange () ;
{ n . detachChildren () ; parent . replaceChild ( n , result ) ; compiler . reportCodeChange () ; return result ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; compiler . reportCodeChange () ; return replacementNode ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; compiler . reportCodeChange () ; }
if ( ! precheck () ) { return; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
if ( Keywords . isKeyword ( idToken.value ) && ! Keywords . isTypeScriptSpecificKeyword ( idToken.value ) ) { reportError ( STRING_CONSTANT + name + STRING_CONSTANT ) ; }
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null , null ) ;
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null , null ) ;
optimizer = new PhaseOptimizer ( compiler , tracker , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null , null ) ;
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null , null ) ;
if ( typeWithBannedProp . isSubtypeOf ( foundType ) ) { if ( matchesPrototype ( typeWithBannedProp , foundType ) ) { return ConformanceResult.VIOLATION ; } else if ( reportLooseTypeViolations ) { return ConformanceResult.POSSIBLE_VIOLATION_DUE_TO_LOOSE_TYPES ; } }
Iterable < JSModule > getAllModules () { return modules ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ clazz . replaceChild ( clazz . getFirstChild () , IR . empty () . useSourceInfoFrom ( clazz . getFirstChild () ) ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( n . getLineno () == NUMBER_CONSTANT ) { n . setCharno ( n . getCharno () - NUMBER_CONSTANT ) ; compiler . reportCodeChange () ; }
Compiler compiler
reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ if ( isMethodOrCtorCallThatTriggersRemoval ( t , n , parent ) ) { replaceHighestNestedCallWithNull ( n , parent ) ; } }
if ( parent . getFirstChild () == n && isReferenceToRemovedVar ( t , n ) ) { replaceHighestNestedCallWithNull ( parent , parent . getParent () ) ; }
{ n . setString ( newName ) ; t . getCompiler () . reportChangeToEnclosingScope ( n ) ; return; }
maybeRewriteClassDefinition ( n ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , InliningMode.DIRECT ) ;
this . mode = TypeInferenceMode.BOTH ;
PeepholeFoldConstantsTest () { super ( DEFAULT_EXTERNS ) ; }
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
@ Override public void setUp () { setLanguage ( ECMASCRIPT_NEXT , ECMASCRIPT_NEXT ) ; }
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT ) , InliningMode.DIRECT ) ;
Iterable < JSModule > getAllModules () { return modules ; }
NodeTraversal . traverseEs6 ( currentCompiler , currentCompiler.jsRoot , s ) ;
{ currentLocationAbstractionIdentifier = locationAbstractionIdentifier ; testSame ( SHARED_EXTERNS , js , null ) ; currentJsRoot = currentCompiler.jsRoot ; return currentAnalysis ; }
JSTypeRegistry registry = compiler . getTypeRegistry () ;
JSTypeRegistry registry = compiler . getTypeRegistry () ;
JSTypeRegistry registry = compiler . getTypeRegistry () ;
NodeTraversal . traverseEs6 ( lastCompiler , lastCompiler.jsRoot , s ) ;
NodeTraversal . traverseEs6 ( lastCompiler , lastCompiler.jsRoot , findFunction ) ;
NodeTraversal . traverseEs6 ( lastCompiler , lastCompiler.jsRoot , findParameter ) ;
NodeUtil . isCompoundAssignementOp ( n ) || n . isInc () || n . isDec ()
if ( NodeUtil . isCompoundAssignementOp ( n ) ) { normalizeAssignShorthand ( n ) ; }
bundler . appendTo ( out , input , input . getSourceFile () . getCodeCharSource () ) ;
sourceMapOriginalSources . putIfAbsent ( path , originalSourcesLoader . apply ( path ) ) ;
Function < String , SourceFile > originalSourcesLoader
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
read () ;
{ ensureRequirementIsMutable () ; super . addAll ( values , requirement_ ) ; onChanged () ; }
catch ( com.google.protobuf.InvalidProtocolBufferException e ) { parsedMessage = ( com.google.javascript.jscomp.ConformanceConfig ) e . getUnfinishedMessage () ; throw e ; }
private void maybeForceBuilderInitialization () { if ( com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ) { getRequirementFieldBuilder () ; } }
private Builder ( com.google.protobuf.GeneratedMessage.BuilderParent parent ) { super ( parent ) ; maybeForceBuilderInitialization () ; }
com.google.protobuf.GeneratedMessage.BuilderParent parent
{ return PARSER . parseFrom ( input , extensionRegistry ) ; }
{ return PARSER . parseDelimitedFrom ( input , extensionRegistry ) ; }
{ return PARSER . parseFrom ( input , extensionRegistry ) ; }
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT , STRING_CONSTANT ) , InliningMode.DIRECT ) ;
declaration . isVar () && declaredVarOrProp . isName ()
testGetFunctionName ( parent . getLastChild () , STRING_CONSTANT ) ;
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; testGetFunctionName ( parent . getFirstChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; testGetFunctionName ( parent . getLastChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; testGetFunctionName ( parent . getFirstChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) ; testGetFunctionName ( parent . getFirstChild () , STRING_CONSTANT ) ; }
if ( sanityCheck != null ) { setSanityCheckState () ; }
{ sanityCheck . create ( compiler ) . process ( externs , root ) ; NodeUtil . verifyScopeChanges ( passName , mtoc , jsRoot ) ; }
if ( n . getFirstChild () . matchesQualifiedName ( Es6ToEs3Converter.INHERITS ) ) { inheritsCalls . add ( n ) ; }
parent . replaceChild ( node , Node . newNumber ( NUMBER_CONSTANT ) . useSourceInfoIfMissingFrom ( node ) ) ;
compiler . optimize () ;
n . isName () && searchIt . currentParent () . isVar () && n . getString () . equals ( STRING_CONSTANT )
( declaration . getParent () . isVar () && ! NodeUtil . isLoopStructure ( declaration . getGrandparent () ) )
public HierarchicalSet ( HierarchicalSet parent ) { this . parent = parent ; }
clinitsCalledAtBranch = new HierarchicalSet ( clinitsCalledAtBranch ) ;
lhs . isName () && currentScope . isConstVar ( lhs . getString () )
if ( ! currentScope . hasThis () ) { return new EnvTypePair ( inEnv , UNKNOWN ) ; }
return expr . isNew () || ( expr . isCall () && currentScope . isConstructor () && expr . getFirstChild () . isSuper () ) ;
guardA . addGuard ( accessControlsOff ) ;
Preconditions . checkState ( val . isObjectLit () ) ;
Preconditions . checkState ( object . isObjectLit () ) ;
Preconditions . checkState ( parent . getFirstChild () == name ) ;
checkState ( val . isObjectLit () , val ) ;
checkState ( object . isObjectLit () , object ) ;
checkState ( parent . getFirstChild () == name ) ;
Preconditions . checkState ( val . isObjectLit () ) ;
Preconditions . checkState ( object . isObjectLit () ) ;
Preconditions . checkState ( parent . getFirstChild () == name ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( t . getScope () != t . getClosestHoistScope () ) { return; }
public InlineVariablesTest () { enableNormalize () ; }
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
@ Override void reportChangeToEnclosingScope ( Node n ) { recordChange ( getEnclosingChangeScope ( n ) ) ; notifyChangeHandlers () ; }
{ return NodeUtil . precedence ( n . getToken () ) < minPrecedence ; }
{ return precedence ( n ) < minPrecedence ; }
{ invalidatingPropRef = ! maybeCandidateDefinition ( t , n , parent ) ; }
JSType type
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
checkArgument ( child.parent == null ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
catch ( IllegalStateException e ) { assertTrue ( e . getMessage () . contains ( STRING_CONSTANT ) ) ; }
Preconditions . checkState ( references . get ( NUMBER_CONSTANT ) . isDeclaration () ) ;
{ deepestModule = graph . getDeepestCommonDependencyInclusive ( m , deepestModule ) ; }
{ return NodeUtil . precedence ( n . getToken () ) < minPrecedence ; }
Preconditions . checkNotNull ( js ) ;
Preconditions . checkState ( collectionRoot . isScript () || collectionRoot . isRoot () ) ;
{ Preconditions . checkNotNull ( options ) ; return warningsGuard . level ( error ) ; }
{ Preconditions . checkState ( changeScopeRoot . isScript () || changeScopeRoot . isFunction () ) ; recordChange ( changeScopeRoot ) ; notifyChangeHandlers () ; }
if ( currentChangeScope != null ) { Preconditions . checkState ( currentChangeScope . isScript () || currentChangeScope . isFunction () ) ; recordChange ( currentChangeScope ) ; }
Preconditions . checkState ( passes instanceof DefaultPassConfig , STRING_CONSTANT ) ;
Preconditions . checkState ( input . isExtern () , STRING_CONSTANT , input . getName () ) ;
Preconditions . checkState ( currentTracer != null , STRING_CONSTANT ) ;
Preconditions . checkState ( currentTracer == null ) ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
if ( ! compiler . hasErrors () ) { compiler . checkAndTranspileAndOptimize () ; compiler . completeCompilation () ; }
if ( ! compiler . hasErrors () ) { compiler . checkAndTranspileAndOptimize () ; compiler . completeCompilation () ; }
blockStack . get ( i ) . root == containingScope . getRootNode ()
if ( clone == null ) { verifyNewNode ( n ) ; } else { verifyNodeChange ( passNameMsg , n , clone ) ; }
grandparent == null || ( ! isPrototypePropertyDeclaration ( grandparent ) && ! isClassPropertyDeclaration ( parent . getFirstChild () , currentScope ) )
ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references . get ( i ) ;
ReferenceCollectingCallback.Reference ref
compiler . reportChangeToEnclosingScope ( expr ) ;
String newName
public InlineObjectLiteralsTest () { enableNormalize () ; }
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
{ return builder () . buildFromFile ( file ) ; }
qNameRoot != null && EXPORTS . equals ( qNameRoot . getQualifiedName () ) && NodeUtil . isLValue ( qNameRoot )
callbackBlock . getParent () . removeChild ( callbackBlock ) ;
onlyExport . getParent () . removeChild ( onlyExport ) ;
@ Override public boolean isPropertyTestFunction ( Node call ) { return STRING_CONSTANT . equals ( call . getFirstChild () . getQualifiedName () ) ; }
boolean isInClass = n . getParent () . getToken () == Token.CLASS_MEMBERS ;
{ if ( alreadyRemoved ( n ) ) { continue; } compiler . reportChangeToEnclosingScope ( n ) ; n . getParent () . removeChild ( n ) ; }
if ( defined ) { compiler . reportChangeToEnclosingScope ( vnode . getParent () ) ; vnode . getParent () . removeChild ( vnode ) ; }
assignmentParent . getParent () . removeChild ( assignmentParent ) ;
return parent != null && parent . getToken () == Token.ASSIGN && parent . getFirstChild () == n ;
{ parent . removeChild ( n ) ; if ( ! parent . hasChildren () ) { parent . getParent () . removeChild ( parent ) ; } }
return enclosingNode != null && enclosingNode . getToken () != Token.FUNCTION ;
if ( ! name . equals ( anc . getFirstChild () . getQualifiedName () ) ) { return Ref.Type.ALIASING_GET ; }
Node block = t . getScope () . getRootNode () ;
isASTNormalized () && Token.NAME == constructorNameNode . getToken ()
parent . getParent () . removeChild ( parent ) ;
{ if ( isNamespacePlaceholder ( parent ) ) { compiler . reportChangeToEnclosingScope ( parent ) ; parent . getParent () . removeChild ( parent ) ; } }
NodeTraversal . traverseEs6 ( compiler , root , new Callback () ) ;
Preconditions . checkState ( ! name . equals ( ARGUMENTS ) ) ;
Preconditions . checkArgument ( ! idPrefix . isEmpty () ) ;
{ Preconditions . checkState ( n . isName () , n ) ; n . setString ( newName ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
if ( isInferrableConst ( jsdoc , name , false ) ) { jsdoc = pullJsdocTypeFromAst ( compiler , jsdoc , name ) ; }
ReferenceCollectingCallback collector
ReferenceCollectingCallback collector
ReferenceCollectingCallback collector
{ if ( null == str ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . str = str ; }
this . quoteKeywordProperties = options.quoteKeywordProperties ;
options . assumeStrictThis () || options . getLanguageIn () == LanguageMode.ECMASCRIPT5_STRICT
if ( options . shouldAmbiguateProperties () && ( options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED ) ) { passes . add ( ambiguateProperties ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
CrossModuleReferenceCollector collector = new CrossModuleReferenceCollector ( compiler , CrossModuleReferenceCollector.DO_NOTHING_BEHAVIOR , new Es6SyntacticScopeCreator ( compiler ) ) ;
@ Override public void setUp () { setLanguage ( ECMASCRIPT_NEXT , ECMASCRIPT_NEXT ) ; behavior = null ; }
public CompilerOptions setEmitUseStrict ( boolean emitUseStrict ) { this . emitUseStrict = emitUseStrict ; return this ; }
builder . setTagAsStrict ( firstOutput && shouldEmitUseStrict () ) ;
assertEquals ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , error.description ) ;
assertEquals ( STRING_CONSTANT + STRING_CONSTANT , error.description ) ;
NodeTraversal t = new NodeTraversal ( compiler , finder ) ;
NodeTraversal t = new NodeTraversal ( compiler , null ) ;
Preconditions . checkState ( reference . isName () ) ;
if ( unusedAssignment != null && ! isRead && ! hasErrors ) { checkForUnusedLocalVar ( v , unusedAssignment ) ; }
options . assumeStrictThis () || options . getLanguageIn () == ECMASCRIPT5_STRICT
ObjectsBuilder newObjs = new ObjectsBuilder ( ResolveConflictsBy.MEET ) ;
public RemoveSuperMethodsPassTest () { super ( DEFAULT_EXTERNS ) ; enableTypeCheck () ; }
while ( s.parent != null ) { if ( isDefinedLocally ( varName , false ) ) { return false ; } s = s.parent ; }
catch ( MaxIterationsExceededException e ) { assertEquals ( e . getMessage () , STRING_CONSTANT + MAX_STEP + STRING_CONSTANT ) ; }
options . assumeStrictThis () || options . isStrictModeInput ()
options . assumeStrictThis () || options . getLanguageIn () == ECMASCRIPT5_STRICT
key . isStringKey () && ! key . isQuotedString () && NodeUtil . isValidPropertyName ( compiler . getLanguageMode () , key . getString () )
public CompilerOptions setStrictModeInput ( boolean isStrictModeInput ) { this . isStrictModeInput = isStrictModeInput ; return this ; }
if ( expectStrictModeInput () ) { options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.ERROR ) ; }
return new InlineFunctions ( compiler , compiler . getUniqueNameIdSupplier () , options.inlineFunctions , options.inlineLocalFunctions , true , options . assumeStrictThis () || options . isStrictModeInput () , options.assumeClosuresOnlyCaptureReferences , options.maxFunctionSizeAfterInlining ) ;
! NodeUtil . isValidQualifiedName ( compiler . getLanguageMode () , name )
key . isStringKey () && ! key . isQuotedString () && NodeUtil . isValidPropertyName ( compiler . getOptions () . getLanguageOut () , key . getString () )
STRING_CONSTANT + number + ( unsupported ? STRING_CONSTANT : STRING_CONSTANT ) + ( es6Modules ? STRING_CONSTANT : STRING_CONSTANT ) + ( typeScript ? STRING_CONSTANT : STRING_CONSTANT ) + STRING_CONSTANT
( ( FeatureSet ) other ) . unsupported == unsupported
this . number >= other.number && ( this . unsupported || ! other.unsupported )
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
{ if ( mockToString ) { return STRING_CONSTANT ; } return appendTo ( new StringBuilder () ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
{ parent . replaceChild ( assignNode , assignNode . getLastChild () . detach () ) ; }
builder . append ( CHAR_CONS ) ;
MemoizedScopeCreator scopeCreator
MemoizedScopeCreator getTypedScopeCreator () { return typedScopeCreator ; }
typedScopeCreator = new MemoizedScopeCreator ( internalScopeCreator ) ;
scopeCreator = new MemoizedScopeCreator ( new TypedScopeCreator ( compiler ) ) ;
MemoizedScopeCreator scopeCreator
MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator () ;
{ this . names = names ; foundNodes = new HashMap <> () ; }
Preconditions . checkState ( inputs.length > NUMBER_CONSTANT ) ;
List < SourceFile > externsInputs = ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , externs ) ) ;
test ( compiler , expected , error , warning ) ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; }
validateEs6TypedFeature ( STRING_CONSTANT , n ) ;
{ validateEs6TypedFeature ( STRING_CONSTANT , n ) ; validateNodeType ( Token.DECLARE , n ) ; validateAmbientDeclarationHelper ( n . getFirstChild () ) ; }
{ validateEs6TypedFeature ( STRING_CONSTANT , n ) ; validateNodeType ( Token.TYPE_ALIAS , n ) ; validateChildCount ( n ) ; }
validateEs6Feature ( STRING_CONSTANT , n ) ;
validateEs6Feature ( STRING_CONSTANT , n ) ;
validateEs6TypedFeature ( STRING_CONSTANT , n ) ;
validateEs6Feature ( STRING_CONSTANT , n ) ;
validateEs6Feature ( STRING_CONSTANT , n ) ;
validateEs6Feature ( STRING_CONSTANT , n ) ;
{ validateEs6Feature ( STRING_CONSTANT , n ) ; validateNodeType ( Token.AWAIT , n ) ; validateWithinAsyncFunction ( n ) ; }
validateEs6Feature ( STRING_CONSTANT , n ) ;
languageMode = options . getLanguageIn () ;
this . languageMode = options . getLanguageIn () ;
{ if ( options.skipNonTranspilationPasses ) { whitespaceOnlyPasses () ; if ( options . lowerFromEs6 () ) { transpileAndDontCheck () ; } } else { check () ; } }
compiler . getOptions () . lowerFromEs6 ()
Node root2 = compiler . parseSyntheticCode ( source ) ;
if ( options.dartPass && ! options . getLanguageOut () . isEs6OrHigher () ) { checks . add ( dartSuperAccessorsPass ) ; }
options.rewritePolyfills = flags.rewritePolyfills && options . getLanguageIn () . isEs6OrHigher () ;
return replaceNode ( minCond . getPlaceholder () , minCond . getMinimized ( MinimizationStyle.PREFER_UNNEGATED ) ) ;
expectFeatures ( Feature.DESTRUCTURING , Feature.REST_PARAMETERS ) ;
{ Preconditions . checkState ( script . isScript () ) ; if ( TranspilationPasses . isScriptEs6ImplOrHigher ( script ) ) { return true ; } }
{ if ( isScriptEs6ImplOrHigher ( scriptRoot ) ) { for ( Callback callback : callbacks ) { NodeTraversal . traverseEs6 ( compiler , scriptRoot , callback ) ; } } }
{ if ( isScriptEs6ImplOrHigher ( singleRoot ) ) { for ( Callback callback : callbacks ) { NodeTraversal . traverseEs6 ( compiler , singleRoot , callback ) ; } } }
! forTranspileOnly || ( compiler . getOptions () . getLanguageIn () . toFeatureSet () . contains ( FeatureSet.ES6 ) && TranspilationPasses . isScriptEs6ImplOrHigher ( scriptRoot ) )
{ for ( Node singleRoot : root . children () ) { if ( TranspilationPasses . isScriptEs6ImplOrHigher ( singleRoot ) ) { return true ; } } }
return isConst && ! hasAnnotatedType ( jsdoc ) && ! NodeUtil . isNamespaceDecl ( nameNode ) ;
rhs . replaceWith ( IR . cast ( IR . number ( NUMBER_CONSTANT ) , getQmarkTypeJSDoc () ) . srcrefTree ( rhs ) ) ;
new ProcessEs6Modules ( this ) . processFile ( root , forceRewrite ) ;
{ compiler . stage1Passes () ; if ( ! compiler . hasErrors () ) { compiler . stage2Passes () ; } compiler . completeCompilation () ; }
{ compiler . restoreState ( serializedInputStream ) ; if ( ! compiler . hasErrors () ) { compiler . stage2Passes () ; } compiler . completeCompilation () ; }
completeCompilation () ;
completeCompilation () ;
{ if ( ! compiler . getFeatureSet () . contains ( feature ) ) { violation ( STRING_CONSTANT + feature , n ) ; } }
features = features . require ( factory . getFeatures () ) ;
for ( LanguageMode mode : LanguageMode . values () ) { if ( mode.featureSet . contains ( feature ) ) { return mode ; } }
{ features = features . require ( FeatureSet.TYPESCRIPT ) ; return nextToken () . type ; }
features = features . require ( Feature.DESTRUCTURING ) ;
features = features . require ( Feature.DESTRUCTURING ) ;
features = features . require ( Feature.ARRAY_PATTERN_REST ) ;
features = features . require ( Feature.DESTRUCTURING ) ;
features = features . require ( Feature.NEW_TARGET ) ;
features = features . require ( Feature.EXPONENT_OP ) ;
features = features . require ( Feature.ARROW_FUNCTIONS ) . require ( Feature.ASYNC_FUNCTIONS ) ;
features = features . require ( Feature.ARROW_FUNCTIONS ) ;
if ( TokenType.STAR_STAR_EQUAL . equals ( operator.type ) ) { features = features . require ( Feature.EXPONENT_OP ) ; }
{ features = features . require ( Feature.TRAILING_COMMA ) ; if ( config.warnTrailingCommas ) { errorReporter . reportWarning ( commaToken.location.start , STRING_CONSTANT ) ; } }
features = features . require ( Feature.REST_PARAMETERS ) ;
features = features . require ( Feature.DEFAULT_PARAMETERS ) ;
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
if ( Keywords . isKeyword ( name.value ) ) { features = features . require ( Feature.KEYWORDS_AS_PROPERTIES ) ; }
if ( expectedFeatures != null ) { assertThat ( result.features ) . isEqualTo ( expectedFeatures ) ; }
if ( expectedFeatures != null ) { assertThat ( result.features ) . isEqualTo ( expectedFeatures ) ; }
expectFeatures ( Feature.DESTRUCTURING , Feature.LET_DECLARATIONS ) ;
expectFeatures ( Feature.CLASSES , Feature.CONST_DECLARATIONS ) ;
expectFeatures ( Feature.DESTRUCTURING ) ;
expectFeatures ( Feature.EXTENDED_OBJECT_LITERALS ) ;
features = features . require ( Feature.STRING_CONTINUATION ) ;
features = features . require ( feature ) ;
features = features . require ( feature ) ;
features = features . require ( Feature.SETTER ) ;
features = features . require ( Feature.GETTER ) ;
features = features . require ( Feature.KEYWORDS_AS_PROPERTIES ) ;
{ if ( isValidSimpleName ( name ) ) { return true ; } else { return mode . contains ( Feature.KEYWORDS_AS_PROPERTIES ) && TokenStream . isKeyword ( name ) ; } }
setFeatureSet ( featureSet . withoutModules () ) ;
Collection < JSModule > modules
{ if ( hasConditionalAncestor ( parent . getParent () ) ) { info.allowMove = false ; } }
Node parse ( String js ) { return parse ( js , false ) ; }
Preconditions . checkArgument ( root . isRoot () ) ;
assertPrettyPrintSame ( STRING_CONSTANT ) ;
String [] parts = path . split ( Pattern . quote ( MODULE_SLASH ) ) ;
public void testConstTarget () { disableTypeCheck () ; testErrorEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , POLYMER_INVALID_DECLARATION ) ; }
testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ testEs6 ( wrapInFunction ( original ) , wrapInFunction ( expected ) ) ; }
{ fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGoogScopeClassOutput () { testEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportEs6ArrowFunction () { testEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportConst () { testEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportLet () { testEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
public void testExtractableExport4 () { testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testExtractableExport3 () { testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testEs6Class_testMethod () { testEs6 ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testAliasInModule () { enableUnusedLocalAssignmentCheck = true ; testSameEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSameEs6 ( STRING_CONSTANT ) ;
@ Override public void setUp () { injectNamespace = false ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
public void testDuplicate_destructuring () { testWarningEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , DUPLICATE_REQUIRE ) ; }
public void testDuplicate_shorthand () { testWarningEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , DUPLICATE_REQUIRE ) ; }
testWarningEs6 ( STRING_CONSTANT , UNUSED_LABEL ) ;
testSameEs6 ( STRING_CONSTANT ) ;
testErrorEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ReplaceIdGenerators.CONDITIONAL_ID_GENERATOR_CALL ) ;
public void testClass () { testSameEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ReplaceIdGenerators.INVALID_GENERATOR_PARAMETER ) ; }
public void testPassModule () { testSameEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override public void setUp () { mode = CheckRequiresForConstructors.Mode.FULL_COMPILE ; }
public void testGoogModuleWithEmptyDestructuringRequire () { testErrorEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , EXTRA_REQUIRE_WARNING ) ; }
public void testRemovalMultipleAssignment3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemovalMultipleAssignment2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveRepeatedProperties () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveUnnecessaryBodies () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testConstPropagationPrivateProperties2 () { testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testConstructorAlias4 () { testSameEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorAlias3 () { testSameEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testPathologicalCaseThatsOkAnyway () { testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , NAME_DEFINED_LATE_WARNING ) ; }
public void testNullUndefined () { testSame ( STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ; assertMismatches ( Collections . < TypeMismatch > emptyList () ) ; }
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ;
{ testSame ( STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ; assertMismatches ( ImmutableList . of ( fromNatives ( STRING_TYPE , NUMBER_TYPE ) ) ) ; }
{ testSame ( STRING_CONSTANT + params + STRING_CONSTANT + arguments + STRING_CONSTANT , type ) ; }
testSame ( fooDfn + STRING_CONSTANT , WRONG_ARGUMENT_COUNT ) ;
testSame ( declarations + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
{ testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , null ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
{ testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , null ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
public void testBadObjectLiteralCast1 () { testSame ( STRING_CONSTANT + STRING_CONSTANT , ClosureCodingConvention.OBJECTLIT_EXPECTED ) ; }
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
{ return ! found ; }
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSame ( typedefExterns , code , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT , value ( STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testCustomBanUnknownThisProp2 () { configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testCustomRestrictThrow2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
{ allowSourcelessWarnings () ; configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
testSame ( EXTERNS + STRING_CONSTANT , code + STRING_CONSTANT , null ) ;
testSame ( code + STRING_CONSTANT ) ;
{ configuration = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; testConformance ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
testSame ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ) ) ;
test ( input , input , null , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
testSame ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ) ) ;
public void testViolationWhitelisted2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
public void testViolationWhitelisted1 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
testSame ( STRING_CONSTANT ) ;
public void testNotViolation2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
testWarning ( STRING_CONSTANT , STRING_CONSTANT , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
testWarning ( STRING_CONSTANT , STRING_CONSTANT , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
NodeTraversal t
Node export = n . getFirstChild () ;
if ( options . needsTranspilationFrom ( FeatureSet.ES6 ) && ! options.skipTranspilationAndCrash ) { checks . add ( convertStaticInheritance ) ; }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
defUse = new MustBeReachingVariableDef ( cfg , scope , compiler ) ;
useDef = new MaybeReachingVariableUse ( cfg , scope , compiler ) ;
liveness = new LiveVariablesAnalysis ( cfg , functionScope , compiler ) ;
LiveVariablesAnalysis liveness = new LiveVariablesAnalysis ( cfg , scope , compiler ) ;
{ new GraphReachability <> ( controlFlowGraph , new ReachablePredicate () ) . compute ( controlFlowGraph . getEntry () . getValue () ) ; }
inheritsCall . useSourceInfoIfMissingFromForTree ( classNode ) ;
Node lp = scope . getRootNode () . getSecondChild () ;
assertEquals ( expected , cssNames ) ;
assertEquals ( expected , cssNames ) ;
assertEquals ( expected , cssNames ) ;
catch ( IOException e ) { compiler . report ( JSError . make ( COULD_NOT_DESERIALIZE_AST , filename ) ) ; }
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; disableMultistageCompilation () ; }
peepholePass . setRetraverseOnChange ( false ) ;
public void testIssue () { super . allowExternsChanges ( true ) ; test ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public RemoveUnusedClassPropertiesTest () { super ( EXTERNS ) ; enableGatherExternProperties () ; }
allowExternsChanges ( true ) ;
public void testProvideInExterns () { allowExternsChanges ( true ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
allowExternsChanges ( true ) ;
{ allowExternsChanges ( true ) ; test ( STRING_CONSTANT , STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , null , null ) ; }
allowExternsChanges ( true ) ;
allowExternsChanges ( true ) ;
allowExternsChanges ( true ) ;
if ( transpileEnabled && transpileExpected && ! compiler . hasErrors () ) { transpileToEs5 ( compiler , externsRoot , mainRoot ) ; }
public String getFilename () { return filename ; }
public J2clCheckPassTest () { super ( DEFAULT_EXTERNS ) ; enableTypeCheck () ; }
enableCheckAccessControls ( true ) ;
enableCheckAccessControls ( true ) ;
public GatherRawExportsTest () { super ( EXTERNS ) ; super . enableNormalize () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; }
compareJsDoc = false ;
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; }
public RemoveUnusedVarsTest () { super ( STRING_CONSTANT ) ; enableNormalize () ; }
public void testEs6ONoEs6 () { allowExternsChanges ( true ) ; testSame ( STRING_CONSTANT ) ; }
public Es6ExternsCheckTest () { super ( EXTERNS_BASE ) ; allowSourcelessWarnings () ; }
{ enableTypeCheck () ; allowExternsChanges ( true ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT , POSSIBLE_INEXISTENT_PROPERTY ) ; }
{ declarationCheck = ! sanityCheck ; this . enableCompareAsTree ( false ) ; testExternChanges ( extern , input , expectedExtern ) ; }
super . allowExternsChanges ( true ) ;
public ProcessDefinesTest () { super ( DEFAULT_EXTERNS + STRING_CONSTANT ) ; allowSourcelessWarnings () ; }
runSmartNameRemoval = true ;
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
allowExternsChanges ( true ) ;
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ this . enableCompareAsTree ( false ) ; super . testExternChanges ( input , expectedExtern ) ; }
validateAstChangeMarking ( false ) ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; }
{ value = key . getFirstChild () . detachFromParent () ; }
Node assign = IR . assign ( windowPropAccess , nameNode . getFirstChild () . detachFromParent () ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
binaryNamespaceName . putProp ( Node.ORIGINALNAME_PROP , currentScript.legacyNamespace ) ;
binaryNamespaceName . putProp ( Node.ORIGINALNAME_PROP , currentScript.legacyNamespace ) ;
exportedNamespaceName . putProp ( Node.ORIGINALNAME_PROP , legacyNamespace ) ;
binaryNamespaceName . putProp ( Node.ORIGINALNAME_PROP , legacyNamespace ) ;
Node initializer = n . getFirstChild () . detach () ;
Node extern = externs . getFirstChild () . detach () ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
{ testModules ( this , input , STRING_CONSTANT + expected ) ; }
if ( n . isArrayPattern () ) { validateArrayPattern ( Token.CATCH , caught ) ; } else { validateObjectPattern ( Token.CATCH , caught ) ; }
test ( options , source , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ;
public void testNotStringLiteralConstantArgument3 () { testError ( CLOSURE_DEFS + STRING_CONSTANT , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ; }
public void testNotStringLiteralConstantArgument2 () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ; }
public void testNotStringLiteralConstantArgument1 () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ; }
public void testNotConstantArgument () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ; }
shadowedVar != null && shadowedVar . isLocal ()
shadowedVar != null && ! shadowedVar . getScope () . isModuleScope ()
this . redeclarationHandler = new DefaultRedeclarationHandler () ;
public Es6SyntacticScopeCreator ( AbstractCompiler compiler , ScopeFactory scopeFactory ) { this ( compiler , SyntacticScopeCreator.DEFAULT_REDECLARATION_HANDLER , scopeFactory ) ; }
int count = RandomNameGenerator.FIRST_CHAR.length * ( RandomNameGenerator.NONFIRST_CHAR.length + NUMBER_CONSTANT ) ;
int count = RandomNameGenerator.FIRST_CHAR.length * ( RandomNameGenerator.NONFIRST_CHAR.length + NUMBER_CONSTANT ) ;
{ this . random = random ; reset ( new HashSet < String > () , STRING_CONSTANT , null ) ; }
var . getParentNode () . isVar () && ! var . getParentNode () . getParent () . isForIn ()
Scope scope = new Es6SyntacticScopeCreator ( compiler ) . createScope ( root , null ) ;
NodeTraversal . traverseEs6 ( compiler , root , new RemoveNonDeclarations () ) ;
for ( Assign assign : assignsByVar . get ( var ) ) { compiler . reportChangeToEnclosingScope ( assign.assignNode ) ; assign . remove () ; }
this . changeProxy = new AstChangeProxy () ;
map . clear () ;
if ( externsRoot != null && n == externsRoot ) { externsScope = t . getScope () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
options.chromePass = flags.chromePass ;
if ( options.chromePass ) { checks . add ( chromePass ) ; }
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
{ if ( n . isFunction () ) { NormalizeStatements . maybeNormalizeFunctionDeclaration ( n , compiler ) ; } }
if ( maybeNormalizeFunctionDeclaration ( n , compiler ) ) { reportCodeChange ( n , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT , null , Es6TypedToEs6Converter.CANNOT_CONVERT_BOUNDED_GENERICS ) ;
test ( modules , expected , null , warning ) ;
{ test ( js , js ) ; }
{ test ( modules , expected , null ) ; }
{ assertNotNull ( warning ) ; test ( js , null , null , warning , description ) ; }
{ test ( js , expected , null , null ) ; }
test ( externs , js , ( String ) null , null , ConstCheck.CONST_REASSIGNED_VALUE_ERROR ) ;
test ( externs , js , js , null , null ) ;
{ testSame ( kExterns + extraExterns , source , null ) ; assertEquals ( expected , noSideEffectCalls ) ; noSideEffectCalls . clear () ; }
public void testIssue2508576_1 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT , null ) ; }
public void testExternFunction () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT + STRING_CONSTANT , null ) ; }
public void testObjectLitExtern () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT , null ) ; }
public void testJSDocDescInExterns () { testWarning ( STRING_CONSTANT , MISPLACED_MSG_ANNOTATION ) ; testSame ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testEnum () { testSame ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , null ) ; }
testErrorExterns ( jsdoc + STRING_CONSTANT , null ) ;
public void testProvideInExterns () { allowExternsChanges () ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
{ test ( createModuleStar ( moduleInputs ) , expected , null ) ; }
{ test ( js , null , null , null ) ; assertEquals ( fieldTypes , mapToString ( lastPass . getRenamedTypesForTesting () ) ) ; }
test ( DEFAULT_EXTERNS + externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
public void testSkipNativeFunctionMethod () { String js = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( js , null ) ; }
testSame ( externs , js , null ) ;
{ test ( code , addLibraries ( code , libraries ) , null , warning ) ; }
public void testGlobalAliasWithProperties5 () { testSame ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , null ) ; }
test . test ( inputs , null , error ) ;
{ currentLocationAbstractionIdentifier = locationAbstractionIdentifier ; testSame ( SHARED_EXTERNS , js , null ) ; currentJsRoot = getLastCompiler () . jsRoot ; return currentAnalysis ; }
test ( js , null , VarCheck.VAR_MULTIPLY_DECLARED_ERROR , null , message ) ;
test ( js , null , VarCheck.VAR_MULTIPLY_DECLARED_ERROR , null , message ) ;
{ String externs = STRING_CONSTANT ; String code = STRING_CONSTANT ; testSame ( externs , code , null ) ; }
{ String externs = STRING_CONSTANT ; String code = STRING_CONSTANT ; testSame ( externs , code , null ) ; }
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
{ testSame ( externs , STRING_CONSTANT , null ) ; assertEquals ( ImmutableSet . copyOf ( properties ) , getLastCompiler () . getExternProperties () ) ; }
testSame ( STRING_CONSTANT , STRING_CONSTANT , null ) ;
tester . testSame ( STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( externs , STRING_CONSTANT , null ) ;
testSame ( externs , js , null ) ;
test ( externs , js , js , null , null ) ;
test ( externs , js , js , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
testSame ( ALL_NATIVE_EXTERN_TYPES , STRING_CONSTANT , null ) ;
testSame ( METHOD_DEFS , STRING_CONSTANT , null ) ;
testSame ( OBJECT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , null ) ;
testSame ( OBJECT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT , null ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , null , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , null , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
{ testSame ( externs , source , null ) ; assertEquals ( expected , found ) ; found . clear () ; }
{ setAcceptedLanguage ( lang ) ; test ( code , expected , null , warning ) ; }
test ( googModule , null , MISSING_MODULE_OR_PROVIDE , null , warning ) ;
public void testRenameWithExterns1 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
test ( js , js , null , MISSING_PROVIDE_WARNING , warning ) ;
test ( js , js , null , MISSING_PROVIDE_WARNING , warning ) ;
test ( js , js , null , MISSING_PROVIDE_WARNING , warning ) ;
test ( externs , input , expected , null , null ) ;
test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
public void testRenameWithExterns2 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public void testRenameWithExterns1 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
{ overrides . put ( STRING_CONSTANT , new Node ( Token.TRUE ) ) ; test ( STRING_CONSTANT , STRING_CONSTANT , null , ProcessDefines.UNKNOWN_DEFINE_WARNING ) ; }
{ overrides . put ( STRING_CONSTANT , new Node ( Token.TRUE ) ) ; test ( STRING_CONSTANT , STRING_CONSTANT , null , ProcessDefines.UNKNOWN_DEFINE_WARNING ) ; }
public void testNamespaceResetInLocalScope2 () { test ( STRING_CONSTANT , STRING_CONSTANT , null , NAMESPACE_REDEFINED_WARNING ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
public void testNamespaceResetInLocalScope1 () { test ( STRING_CONSTANT , STRING_CONSTANT , null , NAMESPACE_REDEFINED_WARNING ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
public void testNamespaceResetInGlobalScope1 () { test ( STRING_CONSTANT , STRING_CONSTANT , null , NAMESPACE_REDEFINED_WARNING ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
{ testSame ( CompilerTestCase.ACTIVE_X_OBJECT_DEF , STRING_CONSTANT , null ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
testSame ( CompilerTypeTestCase.DEFAULT_EXTERNS , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
test ( externs , code , code , null , null ) ;
if ( Es6RewriteModules . isEs6ModuleRoot ( root ) ) { moduleRewriter . processFile ( root , forceRewrite ) ; }
Preconditions . checkState ( exportsNameNode . getString () . equals ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( importNode . getFirstChild () . isDestructuringLhs () ) ;
Preconditions . checkState ( currentScript.defaultExportRhs == null ) ;
Preconditions . checkArgument ( n . isStringKey () ) ;
Preconditions . checkState ( scriptRoot . isScript () ) ;
Preconditions . checkState ( c . isScript () ) ;
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
if ( parent . isForIn () ) { return; }
{ Preconditions . checkState ( error.node . getParent () . isStringKey () ) ; fix . delete ( error.node . getParent () ) ; }
Preconditions . checkState ( regexMatcher . matches () , STRING_CONSTANT , error.description ) ;
Preconditions . checkState ( regexMatcher . matches () , STRING_CONSTANT , error.description ) ;
Preconditions . checkState ( fullNameMatcher . matches () , error.description ) ;
Preconditions . checkState ( name . isName () , name ) ;
mayWarnAboutGlobalThis ( expr , currentScope ) ;
mayWarnAboutGlobalThis ( expr , currentScope ) ;
Object o
public HierarchicalSet ( HierarchicalSet < T > parent ) { this . parent = parent ; }
if ( n . isObjectLit () && n . getParent () . isArrowFunction () ) { return true ; } else { return precedence ( n ) < minPrecedence ; }
{ for ( Var var : computeLiveness ( src ) . getEscapedLocals () ) { assertFalse ( var.name . equals ( name ) ) ; } }
public void visitCallSite ( NodeTraversal t , Node callNode , FunctionState fs ) ;
{ throw new IllegalStateException ( STRING_CONSTANT + child ) ; }
throw new IllegalStateException ( STRING_CONSTANT + parent . getFirstChild () ) ;
Map < String , Node > map = new HashMap <> () ;
ScopeCreator creator = new MemoizedScopeCreator ( SyntacticScopeCreator . makeUntyped ( compiler ) ) ;
ScopeCreator creator = new MemoizedScopeCreator ( SyntacticScopeCreator . makeUntyped ( compiler ) ) ;
{ test ( createModuleStar ( moduleInputs ) , expected ( expected ) , null ) ; }
{ Preconditions . checkState ( expected == null ) ; expected = expected ( ( ( Sources ) part ) . sources ) ; }
protected Sources srcs ( List < SourceFile > files ) { return new Sources ( files ) ; }
protected Sources srcs ( String [] srcTexts ) { return new Sources ( createSources ( STRING_CONSTANT , srcTexts ) ) ; }
protected Sources srcs ( String srcText ) { return new Sources ( maybeCreateSources ( filename , srcText ) ) ; }
{ testSame ( modules , null ) ; }
{ test ( modules , expected ( expected ) , null ) ; }
builder . setTypeRegistry ( this . typeRegistry ) ;
validateChildCount ( n , NUMBER_CONSTANT ) ;
public Es6RewriteModules ( Compiler compiler ) { this . compiler = compiler ; }
testModules ( STRING_CONSTANT , Es6RewriteModules.NAMESPACE_IMPORT_CANNOT_USE_STAR ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ;
@ Override protected FeatureSet featureSet () { return ES7 ; }
@ Override protected FeatureSet featureSet () { return ES6 ; }
if ( forAnnotations ) { return sb . append ( this . primitiveType ) ; }
{ return STRING_CONSTANT + type . toMaybeObjectType () . getElementsType () . toNonNullAnnotationString () + STRING_CONSTANT ; }
TypeI getElementsType ( ) ;
@ Override public TypeI getElementsType () { return null ; }
Preconditions . checkState ( sum > NUMBER_CONSTANT ) ;
Preconditions . checkState ( s instanceof TypedScope , STRING_CONSTANT ) ;
Preconditions . checkState ( curNode != null ) ;
Preconditions . checkNotNull ( parent ) ;
Preconditions . checkState ( s . isGlobal () || s . isModuleScope () ) ;
type = Name.Type.CLASS ;
{ super . setUp () ; compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6_TYPED ) ; compilerOptions . setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
if ( current . isDeclared ( oldName , false ) ) { return; } else { current = current . getParent () ; }
{ return n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ! jsScope . isDeclared ( ARGUMENT_ARRAY_ALIAS , false ) ; }
if ( ! jsScope . isDeclared ( name , false ) ) { return; }
{ this . warningsGuard = new ComposeWarningsGuard ( new SuppressDocWarningsGuard ( getDiagnosticGroups () . getRegisteredGroups () ) , warningsGuard ) ; }
Es6SyntacticScopeCreator createInternalScopeCreator ( AbstractCompiler compiler ) { return new Es6SyntacticScopeCreator ( compiler , new PersistentScopeFactory () ) ; }
ScopeScanner ( AbstractCompiler compiler , Scope scope ) { this ( compiler , DEFAULT_REDECLARATION_HANDLER , scope ) ; }
new ScopeScanner ( compiler , redeclarationHandler , scope ) . populate () ;
vars . remove ( var.name ) ;
{ logger . warning ( STRING_CONSTANT + scopeRoot ) ; }
{ return new J2clClinitPrunerPass ( compiler ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels () ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler ) ; }
Preconditions . checkArgument ( nameNode . isQualifiedName () ) ;
Preconditions . checkArgument ( functionNode . isFunction () ) ;
Preconditions . checkArgument ( nameNode . isQualifiedName () ) ;
Preconditions . checkState ( NodeUtil . isStatement ( statement ) , statement ) ;
Preconditions . checkState ( functionBody . isNormalBlock () ) ;
Preconditions . checkArgument ( paramList . isParamList () ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) { processRequire ( expr ) ; } else { Preconditions . checkState ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) ; }
void markConstructorToProcess ( Node ctorNode ) { Preconditions . checkArgument ( ctorNode . isFunction () ) ; constructorsToProcess . add ( ctorNode ) ; }
{ if ( currentType . getMaxArguments () <= expectedType . getMaxArguments () ) { return expectedType ; } }
{ this ( res , new Number ( op1 ) , o , op2 ) ; }
{ this ( res , op1 , o , new Number ( op2 ) ) ; }
Preconditions . checkArgument ( ! members . isEmpty () , STRING_CONSTANT ) ;
Preconditions . checkArgument ( nt . isGeneric () , nt ) ;
Preconditions . checkArgument ( nameNode . getParent () . isVar () ) ;
Preconditions . checkArgument ( funNode . isFunction () ) ;
Preconditions . checkState ( n . isOr () || n . isAnd () ) ;
Preconditions . checkState ( n . isGetElem () ) ;
return Preconditions . checkNotNull ( funType ) . toFunctionType () ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkState ( declNode . isGetProp () ) ;
Preconditions . checkArgument ( fn . isFunction () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkNotNull ( lendsName ) ;
Preconditions . checkState ( qnameNode . isName () || qnameNode . isGetProp () ) ;
Preconditions . checkState ( qnameNode . isName () || qnameNode . isGetProp () ) ;
Preconditions . checkArgument ( fn . isFunction () ) ;
Preconditions . checkState ( ! fnName . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkState ( qnameNode . isQualifiedName () ) ;
Preconditions . checkState ( qnameNode . isQualifiedName () ) ;
{ if ( maybeAssign . isAssign () ) { maybeAssign . putBooleanProp ( Node.ANALYZED_DURING_GTI , true ) ; } else { Preconditions . checkState ( maybeAssign . isExprResult () ) ; } }
Preconditions . checkState ( ! currentScope . isNamespace ( qname ) ) ;
{ PropertyDef propdef = Preconditions . checkNotNull ( getPropDefFromClass ( superType , pname ) ) ; inheritedPropDefs = ImmutableSet . of ( propdef ) ; }
{ Preconditions . checkNotNull ( part , STRING_CONSTANT ) ; parts . add ( part ) ; return this ; }
Preconditions . checkNotNull ( name , STRING_CONSTANT ) ;
Preconditions . checkState ( n . isScript () ) ;
Preconditions . checkState ( passName . equals ( logStats.pass ) ) ;
Preconditions . checkArgument ( mode != TracerMode.OFF , STRING_CONSTANT ) ;
Preconditions . checkNotNull ( qualifiedName ) ;
Preconditions . checkArgument ( lastLink.nextLink == null ) ;
Preconditions . checkState ( token == JsDocToken.PIPE ) ;
Preconditions . checkArgument ( token == JsDocToken.LEFT_CURLY ) ;
Preconditions . checkArgument ( token == JsDocToken.LEFT_CURLY ) ;
Preconditions . checkState ( annotation == Annotation.IMPLEMENTS ) ;
Preconditions . checkState ( other instanceof NominalType ) ;
{ Preconditions . checkArgument ( pname . isIdentifier () ) ; return this . rawType . getSubtypesWithProperty ( pname . getLeftmostName () ) ; }
{ Preconditions . checkArgument ( pname . isIdentifier () ) ; return this . rawType . isPropDefinedOnSubtype ( pname . getLeftmostName () ) ; }
Preconditions . checkState ( nt1.rawType . equals ( nt2.rawType ) ) ;
Preconditions . checkState ( this . rawType . equals ( other.rawType ) ) ;
Preconditions . checkState ( this . inheritsFromIObjectReflexive () && other . inheritsFromIObjectReflexive () ) ;
Preconditions . checkArgument ( other . isStructuralInterface () ) ;
Preconditions . checkState ( typeMap . size () == NUMBER_CONSTANT ) ;
Preconditions . checkState ( this . rawType . isFrozen () ) ;
{ Preconditions . checkState ( this . rawType . isFrozen () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
Preconditions . checkState ( this . rawType . isFrozen () ) ;
Preconditions . checkState ( isUninstantiatedGenericType () ) ;
Preconditions . checkState ( types . size () == typeParams . size () ) ;
public RawNominalType getRawNominalType () { Preconditions . checkState ( ! this . rawType . isFrozen () ) ; return this . rawType ; }
{ Preconditions . checkArgument ( value . isInterface () ) ; return new SubtypeCache ( this . m . with ( key , value ) ) ; }
Preconditions . checkState ( node . isSuper () ) ;
{ Preconditions . checkArgument ( ! ( scope instanceof TypedScope ) ) ; return new Arguments ( scope ) ; }
{ Preconditions . checkState ( root . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ super ( registry , null , null , isNativeType , constructor . getTemplateTypeMap () ) ; Preconditions . checkNotNull ( constructor ) ; this . constructor = constructor ; }
{ Preconditions . checkState ( m == null ) ; }
Preconditions . checkState ( line < nextLine || col <= nextCol ) ;
Preconditions . checkArgument ( n . isFunction () ) ;
Preconditions . checkState ( variableNode != null ) ;
Preconditions . checkArgument ( n . getChildCount () > NUMBER_CONSTANT ) ;
{ Preconditions . checkNotNull ( isDisposalStack ) ; if ( ! isDisposalStack . isEmpty () ) { return isDisposalStack . peek () ; } return null ; }
{ Preconditions . checkNotNull ( isConstructorStack ) ; if ( ! isDisposalStack . isEmpty () ) { return isConstructorStack . peek () ; } return null ; }
Preconditions . checkArgument ( checkingPolicy != DisposalCheckingPolicy.OFF ) ;
Preconditions . checkNotNull ( name ) ;
Preconditions . checkState ( NodeUtil . isStatementBlock ( parent ) ) ;
Preconditions . checkArgument ( ret . isReturn () ) ;
Preconditions . checkArgument ( node . isNormalBlock () ) ;
Preconditions . checkState ( subclassMember . isAssign () , subclassMember ) ;
Preconditions . checkState ( staticGetProp . isGetProp () ) ;
{ Preconditions . checkState ( n . isName () , n ) ; n . removeFirstChild () ; }
{ Preconditions . checkState ( root . isRoot () ) ; if ( root . getChangeTime () != NUMBER_CONSTANT ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
Preconditions . checkArgument ( n . isCast () ) ;
Preconditions . checkState ( first . getParent () == last . getParent () ) ;
{ Preconditions . checkState ( n . getParent () . isGetProp () , n ) ; nodeToRename = n ; }
Preconditions . checkState ( parentNode . isNormalBlock () , STRING_CONSTANT ) ;
Preconditions . checkState ( node . isName () ) ;
public boolean isLive ( Var v ) { Preconditions . checkNotNull ( v ) ; return liveSet . get ( v.index ) ; }
Preconditions . checkNotNull ( other ) ;
{ Preconditions . checkNotNull ( other ) ; this . liveSet = ( BitSet ) other.liveSet . clone () ; }
Preconditions . checkArgument ( mode != TypeInferenceMode.BOTH ) ;
Preconditions . checkState ( subns.namespaceType != null ) ;
Preconditions . checkState ( this . namespaceType == null ) ;
Preconditions . checkState ( this . namespaceType == null ) ;
Preconditions . checkState ( ! prop . isOptional () ) ;
this . defSite = Preconditions . checkNotNull ( defSite ) ;
Preconditions . checkNotNull ( clinitName ) ;
Preconditions . checkNotNull ( name ) ;
Preconditions . checkState ( hasProcessBeenRun , STRING_CONSTANT ) ;
{ super ( symbolName , value ) ; this . exportPath = Preconditions . checkNotNull ( exportPath ) ; }
Preconditions . checkArgument ( fn . isFunction () ) ;
{ Preconditions . checkState ( pathDefinition . isVar () ) ; pathDefinition . setJSDocInfo ( jsdoc ) ; }
Preconditions . checkArgument ( before . isExprResult () , STRING_CONSTANT ) ;
Preconditions . checkArgument ( keyValPairs.length % NUMBER_CONSTANT == NUMBER_CONSTANT ) ;
Preconditions . checkState ( isNamespacePlaceholder ( decl ) ) ;
Preconditions . checkState ( isNamespacePlaceholder ( decl ) ) ;
{ Preconditions . checkState ( newModule == minimumModule , STRING_CONSTANT ) ; }
Preconditions . checkArgument ( explicitNode != node ) ;
Preconditions . checkState ( n . isCall () ) ;
Preconditions . checkNotNull ( providedModule , n ) ;
Preconditions . checkState ( parent . isExprResult () ) ;
Preconditions . checkState ( isRegistered () ) ;
boolean isCorrectRegisterFunction ( TweakFunction registerFunction ) { Preconditions . checkNotNull ( registerFunction ) ; return this . registerFunction == registerFunction ; }
Preconditions . checkArgument ( scriptNodeCount == NUMBER_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ;
Preconditions . checkState ( moduleNode . isModuleBody () ) ;
Preconditions . checkArgument ( parent . isModuleBody () , parent ) ;
Preconditions . checkArgument ( parent . isModuleBody () , parent ) ;
{ Preconditions . checkArgument ( isEs6ModuleRoot ( root ) , root ) ; clearState () ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
Preconditions . checkArgument ( scriptNode . isScript () ) ;
Preconditions . checkArgument ( n . isCall () ) ;
Preconditions . checkArgument ( subtree . isCall () ) ;
Preconditions . checkArgument ( subtree . isCall () ) ;
{ Preconditions . checkState ( script . isScript () ) ; visit ( script ) ; }
Preconditions . checkState ( ! member . isStaticMember () ) ;
Preconditions . checkNotNull ( constructor ) ;
Preconditions . checkArgument ( object != null , STRING_CONSTANT ) ;
Preconditions . checkState ( ! frozen ) ;
Preconditions . checkState ( fnNode . isFunction () || type . isFunctionType () ) ;
Preconditions . checkNotNull ( registry ) ;
Preconditions . checkState ( NodeUtil . isNameDeclaration ( n ) ) ;
Preconditions . checkArgument ( ! envs . isEmpty () ) ;
{ Preconditions . checkArgument ( ! n . contains ( STRING_CONSTANT ) ) ; return typeMap . get ( n ) ; }
Preconditions . checkState ( typeMap . size () >= SIZE_THRESHOLD ) ;
Preconditions . checkState ( meaning != null ) ;
Preconditions . checkArgument ( n . isCall () || n . isNew () ) ;
Preconditions . checkState ( n . isNew () ) ;
Preconditions . checkState ( n . isCall () ) ;
Preconditions . checkState ( n . isCall () , n ) ;
Preconditions . checkArgument ( NodeUtil . isAssociative ( n . getToken () ) ) ;
Preconditions . checkArgument ( node . isGetProp () ) ;
Preconditions . checkNotNull ( compiler ) ;
{ Preconditions . checkArgument ( groupIndex >= NUMBER_CONSTANT && groupIndex <= NUMBER_CONSTANT ) ; this . groupIndex = groupIndex ; }
Preconditions . checkState ( n . isGetProp () , n ) ;
Preconditions . checkNotNull ( typei ) ;
Preconditions . checkArgument ( callSite . isCall () || callSite . isNew () ) ;
Preconditions . checkArgument ( callType == Token.CALL || callType == Token.NEW ) ;
Preconditions . checkArgument ( NodeUtil . isNameDeclaration ( node . getParent () ) ) ;
{ Preconditions . checkNotNull ( sideEffectInfo ) ; updateSideEffectsForNode ( sideEffectInfo , traversal , node , enclosingFunction ) ; }
Preconditions . checkNotNull ( functionInfo ) ;
Preconditions . checkNotNull ( cacheCall ) ;
this . compiler = Preconditions . checkNotNull ( compiler ) ;
Preconditions . checkState ( initialization . getGrandparent () . isExprResult () ) ;
Preconditions . checkState ( value != null ) ;
Preconditions . checkState ( NodeUtil . isNameDeclaration ( varNode ) , varNode ) ;
Preconditions . checkState ( scriptRoot . isScript () ) ;
Time ( String name ) { Preconditions . checkNotNull ( name ) ; this . name = name ; }
Event ( T value ) { Preconditions . checkNotNull ( value ) ; this . value = value ; }
Preconditions . checkState ( exportDefinition . hasInlinableName ( currentScript.exportsToInline . keySet () ) ) ;
Preconditions . checkState ( n . isScript () , n ) ;
Preconditions . checkState ( currentScript.willCreateExportsObject || currentScript.hasCreatedExportObject ) ;
Preconditions . checkArgument ( importNode . getFirstChild () . isDestructuringLhs () , importNode ) ;
Preconditions . checkState ( currentScript.defaultExportRhs == null , currentScript.defaultExportRhs ) ;
Preconditions . checkArgument ( n . isStringKey () , n ) ;
Preconditions . checkState ( scriptRoot . isScript () , scriptRoot ) ;
Preconditions . checkState ( c . isScript () , c ) ;
Preconditions . checkState ( returnNode . isReturn () , returnNode ) ;
{ Preconditions . checkArgument ( containsModule ( legacyNamespace ) ) ; return scriptDescriptionsByGoogModuleNamespace . get ( legacyNamespace ) . declareLegacyNamespace ; }
{ Preconditions . checkState ( isInterface () ) ; isStructuralInterface = flag ; }
Preconditions . checkArgument ( isConstructor () || isInterface () ) ;
Preconditions . checkNotNull ( that ) ;
Preconditions . checkArgument ( interfaceType . isInterface () ) ;
Preconditions . checkState ( msgBuilder != null ) ;
Preconditions . checkState ( ! STRING_CONSTANT . equals ( projectId ) ) ;
{ Preconditions . checkArgument ( classNode . isClass () ) ; return classNode . getFirstChild () . isName () && parent . isName () ; }
Preconditions . checkNotNull ( name ) ;
Preconditions . checkArgument ( n . isFunction () ) ;
Preconditions . checkState ( rootNode . isFunction () ) ;
Preconditions . checkState ( ! typeMap . isEmpty () ) ;
public JSType getRestFormalsType () { Preconditions . checkState ( restFormals != null ) ; return restFormals ; }
Preconditions . checkArgument ( propertyName . isString () ) ;
Preconditions . checkArgument ( superSet . isAssign () ) ;
Preconditions . checkArgument ( objectLit . isObjectLit () ) ;
Preconditions . checkState ( parent . isCall () ) ;
Preconditions . checkState ( parent . isObjectLit () ) ;
Preconditions . checkNotNull ( t ) ;
public JSTypeExpression getTypeExprForErrorReporting () { Preconditions . checkState ( state == State.DURING_RESOLUTION ) ; return typeExpr ; }
Preconditions . checkState ( state != State.RESOLVED ) ;
public JSType getType () { Preconditions . checkState ( state == State.RESOLVED ) ; return type ; }
Preconditions . checkNotNull ( typeExpr ) ;
{ Preconditions . checkState ( renameStrategy == RenameStrategy.MAPPED ) ; return new MappedNameSupplier ( mappings ) ; }
{ Preconditions . checkState ( grandparent . isLabel () ) ; throw new IllegalStateException ( STRING_CONSTANT ) ; }
Preconditions . checkState ( functionBody . getParent () . isFunction () ) ;
Preconditions . checkArgument ( n . isLabel () ) ;
Preconditions . checkState ( n . isFunction () , n ) ;
Preconditions . checkArgument ( ! Iterables . isEmpty ( options ) , STRING_CONSTANT ) ;
Preconditions . checkState ( oldName . equals ( p.oldName ) ) ;
Map < String , String > getRenamingMap () { Preconditions . checkNotNull ( renamingMap ) ; return renamingMap ; }
Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
Preconditions . checkNotNull ( refNode ) ;
Preconditions . checkNotNull ( value ) ;
if ( invalidatingPropRef ) { Preconditions . checkNotNull ( propName ) ; invalidateProperty ( propName ) ; }
Preconditions . checkState ( n . isName () , n ) ;
Preconditions . checkNotNull ( inputId ) ;
{ Preconditions . checkState ( mayBeExpression ( expr ) ) ; return new Node ( token , expr ) ; }
Preconditions . checkState ( function . isFunction () ) ;
{ Preconditions . checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.SPREAD , expr ) ; }
Preconditions . checkState ( mayBeExpression ( value ) ) ;
{ Preconditions . checkState ( expr . isString () ) ; return new Node ( Token.REGEXP , expr ) ; }
for ( Node expr : exprs ) { Preconditions . checkState ( mayBeExpressionOrEmpty ( expr ) ) ; arraylit . addChildToBack ( expr ) ; }
Preconditions . checkState ( mayBeExpression ( target ) ) ;
for ( Node arg : args ) { Preconditions . checkState ( mayBeExpression ( arg ) ) ; newcall . addChildToBack ( arg ) ; }
for ( Node arg : args ) { Preconditions . checkState ( mayBeExpression ( arg ) , arg ) ; call . addChildToBack ( arg ) ; }
{ Preconditions . checkState ( name . isLabelName () ) ; return new Node ( Token.CONTINUE , name ) ; }
{ Preconditions . checkState ( name . isLabelName () ) ; return new Node ( Token.BREAK , name ) ; }
Preconditions . checkState ( finallyBody . isNormalBlock () ) ;
{ Preconditions . checkState ( ! name . isEmpty () ) ; return Node . newString ( Token.LABEL_NAME , name ) ; }
{ Preconditions . checkState ( body . isNormalBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
{ Preconditions . checkState ( mayBeExpression ( expr ) , expr ) ; return new Node ( Token.EXPR_RESULT , expr ) ; }
{ Preconditions . checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.RETURN , expr ) ; }
for ( Node stmt : stmts ) { Preconditions . checkState ( mayBeStatementNoReturn ( stmt ) ) ; paramList . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { Preconditions . checkState ( mayBeStatementNoReturn ( stmt ) ) ; block . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { Preconditions . checkState ( mayBeStatement ( stmt ) ) ; paramList . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { Preconditions . checkState ( mayBeStatement ( stmt ) ) ; block . addChildToBack ( stmt ) ; }
{ Preconditions . checkState ( mayBeStatement ( stmt ) ) ; Node block = new Node ( Token.BLOCK , stmt ) ; return block ; }
{ Preconditions . checkState ( param . isName () || param . isRest () ) ; paramList . addChildToBack ( param ) ; }
{ Preconditions . checkState ( param . isName () || param . isRest () ) ; return new Node ( Token.PARAM_LIST , param ) ; }
Preconditions . checkArgument ( node . isGetProp () ) ;
Preconditions . checkArgument ( NodeUtil . isVarDeclaration ( node ) ) ;
{ super ( IR . getprop ( IR . objectlit () , name . cloneNode () ) , true ) ; Preconditions . checkArgument ( name . isString () ) ; }
{ super ( inExterns ) ; Preconditions . checkArgument ( node . isAssign () ) ; assignment = node ; }
{ super ( node , inExterns ) ; Preconditions . checkArgument ( NodeUtil . isFunctionExpression ( node ) ) ; }
{ super ( inExterns ) ; Preconditions . checkArgument ( node . isFunction () ) ; function = node ; }
Preconditions . checkNotNull ( lValue ) ;
{ Preconditions . checkState ( fileName . equals ( file . getName () ) ) ; sourceFile = file ; }
Preconditions . checkArgument ( parent . isExprResult () ) ;
Preconditions . checkState ( ! NodeUtil . isObjectLitKey ( n ) ) ;
Preconditions . checkState ( expressionRoot != null ) ;
Preconditions . checkState ( notAlreadyOutstanding ) ;
Preconditions . checkState ( Thread . currentThread () == startThread ) ;
Preconditions . checkState ( noCycles ) ;
Preconditions . checkState ( thisRoot . getToken () == Token.BANG ) ;
Preconditions . checkArgument ( params != null || jsdoc != null ) ;
Preconditions . checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
Preconditions . checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
Preconditions . checkState ( e != null , STRING_CONSTANT + STRING_CONSTANT ) ;
Preconditions . checkState ( td != null , STRING_CONSTANT + STRING_CONSTANT ) ;
Preconditions . checkNotNull ( n ) ;
Preconditions . checkNotNull ( commonTypes ) ;
Preconditions . checkState ( options.sourceMapDetailLevel != null ) ;
Preconditions . checkState ( n . isNormalBlock () , n ) ;
Preconditions . checkState ( line >= NUMBER_CONSTANT ) ;
Preconditions . checkState ( sourceMapDetailLevel != null ) ;
Preconditions . checkArgument ( getCfg () . hasNode ( useNode ) ) ;
{ Preconditions . checkState ( ownerFunction == null || type == null ) ; ownerFunction = type ; }
Preconditions . checkNotNull ( templateType , STRING_CONSTANT ) ;
Preconditions . checkState ( index >= NUMBER_CONSTANT ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkArgument ( ! values . isEmpty () ) ;
Preconditions . checkState ( scope . isFunctionScope () , scope ) ;
Preconditions . checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ;
Preconditions . checkArgument ( o instanceof ObjectType ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
Preconditions . checkArgument ( qname . isIdentifier () ) ;
Preconditions . checkArgument ( qname . isIdentifier () ) ;
{ Preconditions . checkArgument ( qname . isIdentifier () ) ; Property p = getLeftmostProp ( qname ) ; return p != null ; }
{ Preconditions . checkState ( p != null ) ; return p . getType () . getProp ( qname . getAllButLeftmost () ) ; }
Preconditions . checkNotNull ( this . ns ) ;
Preconditions . checkState ( isLoose || other.isLoose ) ;
Preconditions . checkNotNull ( pname ) ;
Preconditions . checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ;
Preconditions . checkNotNull ( resultNominalType ) ;
Preconditions . checkNotNull ( nominalType ) ;
{ return new ObjectType ( commonTypes , commonTypes . getObjectType () , Preconditions . checkNotNull ( commonTypes.BOTTOM_PROPERTY_MAP ) , null , null , false , ObjectKind.UNRESTRICTED ) ; }
Preconditions . checkNotNull ( reference ) ;
Preconditions . checkState ( node . isName () , node ) ;
public boolean isLive ( Var v ) { Preconditions . checkNotNull ( v ) ; return liveSet . get ( v.index ) ; }
Preconditions . checkNotNull ( other ) ;
{ Preconditions . checkNotNull ( other ) ; this . liveSet = ( BitSet ) other.liveSet . clone () ; }
Preconditions . checkState ( first . isString () ) ;
Preconditions . checkArgument ( ctorType . isConstructor () ) ;
{ Preconditions . checkState ( parent . isFunction () ) ; parent . setJSType ( varType ) ; }
Preconditions . checkState ( n . isGetElem () , n ) ;
Preconditions . checkNotNull ( data ) ;
Preconditions . checkNotNull ( preservedNamespaces , STRING_CONSTANT ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkState ( ! isDefined ( qnameNode ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkState ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkState ( s != null ) ;
{ Preconditions . checkArgument ( ! fnName . contains ( STRING_CONSTANT ) ) ; return getScopeHelper ( new QualifiedName ( fnName ) ) != null ; }
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( qnameNode . isQualifiedName () ) ;
{ Preconditions . checkState ( this . isTopLevel () ) ; this . unknownTypeNames = ImmutableSet . copyOf ( names ) ; }
boolean isPrototypeMethod () { Preconditions . checkArgument ( root != null ) ; return NodeUtil . isPrototypeMethod ( root ) ; }
Preconditions . checkNotNull ( declaredType ) ;
Node getBody () { Preconditions . checkArgument ( root . isFunction () ) ; return NodeUtil . getFunctionBody ( root ) ; }
Preconditions . checkNotNull ( commonTypes ) ;
Preconditions . checkArgument ( NodeUtil . isGet ( n ) ) ;
Preconditions . checkState ( left . isString () ) ;
Preconditions . checkArgument ( n . isGetElem () ) ;
Preconditions . checkArgument ( n . isNew () ) ;
Preconditions . checkArgument ( n . isCall () ) ;
{ Preconditions . checkArgument ( n . isNew () ) ; if ( inForcedStringContext ( n ) ) { return tryFoldInForcedStringContext ( n ) ; } return n ; }
Preconditions . checkArgument ( node . isAdd () ) ;
Preconditions . checkArgument ( n . isAssign () ) ;
Preconditions . checkArgument ( n . isInstanceOf () ) ;
Preconditions . checkState ( n . hasOneChild () , n ) ;
Preconditions . checkArgument ( originalTypeofNode . isTypeOf () ) ;
Preconditions . checkNotNull ( n ) ;
{ Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
public ConstParamCheck ( AbstractCompiler compiler ) { this . compiler = Preconditions . checkNotNull ( compiler ) ; }
Preconditions . checkState ( options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED ) ;
{ Preconditions . checkArgument ( ! callbacks . isEmpty () ) ; return new CombinedCompilerPass ( compiler , callbacks ) ; }
if ( checks . contains ( closureGoogScopeAliases ) ) { Preconditions . checkState ( checks . contains ( checkVariableReferences ) , STRING_CONSTANT ) ; }
if ( pass1Index != - NUMBER_CONSTANT && pass2Index != - NUMBER_CONSTANT ) { Preconditions . checkState ( pass1Index < pass2Index , msg ) ; }
{ for ( PassFactory pass : passes ) { Preconditions . checkState ( ! pass . isOneTimePass () ) ; } }
{ for ( PassFactory pass : passes ) { Preconditions . checkState ( pass . isOneTimePass () ) ; } }
Preconditions . checkState ( this . namespaceType == null ) ;
{ Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
Preconditions . checkState ( ! compiler . hasErrors () ) ;
Preconditions . checkState ( parametersList . isParamList () ) ;
Preconditions . checkNotNull ( traversal ) ;
Preconditions . checkNotNull ( traversal ) ;
Preconditions . checkArgument ( otherLocation instanceof VisibilityBasedEffectLocation ) ;
Preconditions . checkArgument ( otherLocation instanceof VisibilityBasedEffectLocation ) ;
{ Preconditions . checkArgument ( isStorageNode ( node ) ) ; return NodeUtil . isLValue ( node ) ; }
Preconditions . checkArgument ( isStorageNode ( node ) ) ;
Preconditions . checkArgument ( variableReference . isName () ) ;
Preconditions . checkState ( n . isGetProp () , n ) ;
Preconditions . checkState ( caseBody . isNormalBlock () ) ;
Preconditions . checkState ( first . getString () . isEmpty () ) ;
Preconditions . checkArgument ( token.type == TokenType.STRING ) ;
{ Preconditions . checkState ( config.keepGoing == Config.RunMode.KEEP_GOING ) ; bodyNode = IR . block () ; }
Preconditions . checkArgument ( scriptNode . isScript () ) ;
Preconditions . checkState ( ret . isString () ) ;
Preconditions . checkState ( work . isEmpty () ) ;
Preconditions . checkArgument ( isZipEntry ( zipURL ) ) ;
Preconditions . checkArgument ( arrowFunction . isArrowFunction () ) ;
{ Preconditions . checkState ( templateJs == null , STRING_CONSTANT ) ; this . templateJs = refasterJsTemplate ; }
Preconditions . checkState ( templateJs == null , STRING_CONSTANT ) ;
Preconditions . checkState ( objLit . isObjectLit () ) ;
Preconditions . checkState ( objLit . isObjectLit () ) ;
{ JSModule module = input . getModule () ; Preconditions . checkNotNull ( module ) ; entryPointInputsPerModule . put ( module , input ) ; }
Preconditions . checkState ( n . isCall () , n ) ;
{ Preconditions . checkState ( child . getParent () == n ) ; normalizeNodeTypes ( child ) ; }
Preconditions . checkNotNull ( thisType ) ;
Preconditions . checkState ( moduleSpecifier . isString () ) ;
Preconditions . checkNotNull ( ref . getTwin () ) ;
Preconditions . checkState ( isObjKey || isQName ) ;
Preconditions . checkState ( ref.node . getParent () . isExprResult () ) ;
Preconditions . checkState ( child . hasOneChild () ) ;
Preconditions . checkState ( cycleCount != maxIterations , NON_HALTING_ERROR_MSG ) ;
public int getArgIndex () { Preconditions . checkState ( this . argIndex >= NUMBER_CONSTANT ) ; return this . argIndex ; }
Preconditions . checkState ( firstScript . isScript () ) ;
Preconditions . checkState ( namespace . hasExternsRoot () ) ;
{ Preconditions . checkArgument ( namespace . hasExternsRoot () ) ; this . namespace = namespace ; return this ; }
Preconditions . checkNotNull ( prevUsedRenameMap . getNewNameToOriginalNameMap () ) ;
{ Preconditions . checkState ( this . newName == null ) ; this . newName = newName ; }
Preconditions . checkState ( nameNode . isName () ) ;
Preconditions . checkArgument ( n . isAnd () || n . isOr () ) ;
Preconditions . checkNotNull ( replacementFnType ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkNotNull ( resultType ) ;
Preconditions . checkNotNull ( var ) ;
Preconditions . checkArgument ( objectType . isUnknownType () ) ;
Preconditions . checkNotNull ( errorRoot ) ;
{ Preconditions . checkState ( this . knownConstants . isEmpty () ) ; this . knownConstants = knownConstants ; }
{ Preconditions . checkState ( ! NodeUtil . isFunctionObjectApply ( callNode ) ) ; }
Preconditions . checkArgument ( callSiteType != CallSiteType.UNSUPPORTED ) ;
if ( type == DecompositionType.DECOMPOSABLE ) { return CallSiteType.DECOMPOSABLE_EXPRESSION ; } else { Preconditions . checkState ( type == DecompositionType.UNDECOMPOSABLE ) ; }
Preconditions . checkState ( this != callSiteType ) ;
Preconditions . checkState ( this != callSiteType ) ;
Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
Preconditions . checkState ( fnRecursionName != null ) ;
Preconditions . checkArgument ( n . isDo () ) ;
Preconditions . checkArgument ( n . isVanillaFor () ) ;
Preconditions . checkArgument ( n . isWhile () ) ;
{ Preconditions . checkState ( isExprConditional ( n ) ) ; return n . getFirstFirstChild () ; }
{ Preconditions . checkState ( isSimpleAssignment ( n ) ) ; return n . getFirstChild () . getLastChild () ; }
Preconditions . checkState ( isSimpleAssignment ( n ) ) ;
Preconditions . checkState ( n . isSwitch () , n ) ;
Preconditions . checkState ( subtree . isAssign () ) ;
Preconditions . checkState ( n . isTry () , n ) ;
Preconditions . checkState ( this . namespaceType == null ) ;
{ NominalType builtinObj = Preconditions . checkNotNull ( this . commonTypes . getObjectType () , STRING_CONSTANT ) ; protoNT = builtinObj ; }
Preconditions . checkState ( ! this . isFrozen ) ;
{ Preconditions . checkState ( ! this . isFrozen ) ; super . addProperty ( pname , defSite , type , isConstant ) ; }
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
if ( isClass () ) { Preconditions . checkState ( this . name . equals ( STRING_CONSTANT ) ) ; return getAllPropsOfClass () ; }
Preconditions . checkState ( isInterface () ) ;
Preconditions . checkState ( isClass () ) ;
Preconditions . checkState ( ancestor . isInterface () ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ancestor . isClass () ) ;
{ Preconditions . checkState ( ! this . isFrozen ) ; this . ctorFn = ctorFn ; }
public boolean isStruct () { Preconditions . checkState ( isFrozen () || isClass () ) ; return this . objectKind . isStruct () ; }
JSType getPrototypeObject () { Preconditions . checkState ( this . isFrozen ) ; return this . protoObject ; }
Preconditions . checkNotNull ( objectKind ) ;
{ super ( commonTypes ) ; this . objs = Preconditions . checkNotNull ( objs ) ; }
{ super ( commonTypes ) ; this . objs = Preconditions . checkNotNull ( objs ) ; }
@ Override protected ImmutableSet < EnumType > getEnums () { return Preconditions . checkNotNull ( enums ) ; }
@ Override protected ImmutableSet < ObjectType > getObjs () { return Preconditions . checkNotNull ( objs ) ; }
@ Override public final Iterable < TypeI > getParameterTypes () { return Preconditions . checkNotNull ( getFunType () ) . getParameterTypes () ; }
{ Preconditions . checkState ( this . isSingletonObj () ) ; return this . getNominalTypeIfSingletonObj () . isClassy () ; }
Preconditions . checkState ( this . isSingletonObj () ) ;
{ Preconditions . checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getPropertyDefSite ( propertyName ) ; }
{ Preconditions . checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getOwnPropertyDefSite ( propertyName ) ; }
Preconditions . checkState ( this . isSingletonObj () ) ;
Preconditions . checkState ( this . isSingletonObj () ) ;
{ Preconditions . checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getReturnType () ; }
{ Preconditions . checkState ( this . isFunctionType () ) ; return this . getFunTypeIfSingletonObj () . getMinArity () ; }
Preconditions . checkState ( this . isFunctionType () ) ;
{ Preconditions . checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getThisType () ; }
Preconditions . checkState ( this . isFunctionType () ) ;
{ Preconditions . checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getInstanceTypeOfCtor () != null ; }
Preconditions . checkState ( this . isFunctionType () ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
Preconditions . checkState ( ! getObjs () . isEmpty () ) ;
Preconditions . checkArgument ( type != null ) ;
Preconditions . checkNotNull ( arrayType ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
if ( getObjs () . isEmpty () ) { Preconditions . checkState ( ! getEnums () . isEmpty () ) ; return this ; }
Preconditions . checkState ( ! areSubtypes ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkState ( this . isSingletonObj () ) ;
Preconditions . checkState ( ! getObjs () . isEmpty () ) ;
private JSType ( JSTypes commonTypes ) { Preconditions . checkNotNull ( commonTypes ) ; this . commonTypes = commonTypes ; }
Preconditions . checkState ( newExpr . isNew () ) ;
Preconditions . checkState ( newExpr . isNew () ) ;
Preconditions . checkArgument ( NodeUtil . isCallOrNew ( call ) , STRING_CONSTANT ) ;
Preconditions . checkArgument ( function . isFunction () , STRING_CONSTANT ) ;
Preconditions . checkState ( value . getParent () == null ) ;
Preconditions . checkState ( DefinitionUseSiteFinder . isCallOrNewSite ( site ) ) ;
Preconditions . checkState ( compiler . getLifeCycleStage () == LifeCycleStage.NORMALIZED ) ;
Preconditions . checkArgument ( ! isIdentifier () ) ;
{ Preconditions . checkArgument ( ! isIdentifier () ) ; return new QualifiedName ( parts . subList ( NUMBER_CONSTANT , parts . size () ) ) ; }
Preconditions . checkArgument ( fnNode . isFunction () ) ;
Preconditions . checkArgument ( unsafe != null ) ;
{ Preconditions . checkState ( ! NodeUtil . isFunctionObjectApply ( callNode ) ) ; argMap . put ( THIS_MARKER , NodeUtil . newUndefinedNode ( callNode ) ) ; }
Preconditions . checkArgument ( n . isScript () ) ;
Preconditions . checkNotNull ( lValue ) ;
void setIn ( L in ) { Preconditions . checkNotNull ( in ) ; this . in = in ; }
Preconditions . checkState ( outBefore . size () == state.out . size () ) ;
void setOut ( L out ) { Preconditions . checkNotNull ( out ) ; this . out = out ; }
void setIn ( L in ) { Preconditions . checkNotNull ( in ) ; this . in = in ; }
{ Preconditions . checkNotNull ( dep ) ; Preconditions . checkState ( dep != this , STRING_CONSTANT , this ) ; deps . add ( dep ) ; }
Preconditions . checkState ( inputs . contains ( other ) ) ;
Preconditions . checkState ( n . isSwitch () ) ;
Preconditions . checkState ( allCatchNodes . hasOneChild () ) ;
Preconditions . checkArgument ( type instanceof TypeDeclarationNode ) ;
Preconditions . checkNotNull ( reader ) ;
{ Preconditions . checkNotNull ( whitelist ) ; this . whitelist = normalizeWhitelist ( whitelist ) ; }
public JSTypeExpression getTypeExprForErrorReporting () { Preconditions . checkState ( this . state == State.DURING_RESOLUTION ) ; return typeExpr ; }
Preconditions . checkState ( this . state != State.RESOLVED ) ;
public JSType getPropType () { Preconditions . checkState ( this . state == State.RESOLVED ) ; return enumPropType ; }
public JSType getEnumeratedType () { Preconditions . checkState ( this . state == State.RESOLVED ) ; return declaredType ; }
Preconditions . checkNotNull ( typeExpr ) ;
{ Preconditions . checkState ( isVarBlock ( n ) ) ; return n . getFirstChild () ; }
{ Preconditions . checkState ( isReturnExpressBlock ( n ) ) ; return n . getFirstFirstChild () ; }
{ Preconditions . checkState ( isFoldableExpressBlock ( n ) ) ; return n . getFirstChild () ; }
Preconditions . checkArgument ( n . isNot () ) ;
Preconditions . checkState ( objLit . isObjectLit () ) ;
Preconditions . checkState ( objLit . isObjectLit () ) ;
Preconditions . checkState ( script . isScript () ) ;
Preconditions . checkArgument ( declaration . isName () || declaration . isStringKey () ) ;
{ Preconditions . checkState ( isCallOrNew ( call ) ) ; return getNthSibling ( call . getSecondChild () , index ) ; }
{ Preconditions . checkState ( function . isFunction () ) ; return getNthSibling ( function . getSecondChild () . getFirstChild () , index ) ; }
{ Preconditions . checkArgument ( fnNode . isFunction () ) ; return fnNode . getSecondChild () ; }
{ Preconditions . checkArgument ( n . isNormalBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
{ Preconditions . checkArgument ( n . isTry () ) ; return n . getSecondChild () ; }
{ Preconditions . checkArgument ( n . isTry () ) ; return n . getChildCount () == NUMBER_CONSTANT ; }
Preconditions . checkArgument ( NodeUtil . isObjectDefinePropertiesDefinition ( definePropertiesCall ) ) ;
{ Preconditions . checkState ( isLValue ( n ) ) ; lhsNodes . add ( n ) ; }
{ Preconditions . checkArgument ( function . isFunction () ) ; return isNameReferenced ( function . getLastChild () , STRING_CONSTANT , MATCH_NOT_THIS_BINDING ) ; }
{ Preconditions . checkArgument ( fn . isFunction () , fn ) ; return fn . getLastChild () ; }
Preconditions . checkState ( block . isNormalBlock () ) ;
Preconditions . checkState ( tryNode . isTry () ) ;
Preconditions . checkState ( n . isName () , n ) ;
Preconditions . checkState ( objlit . isObjectLit () ) ;
Preconditions . checkState ( n . isObjectLit () || n . isClassMembers () ) ;
{ Preconditions . checkState ( n . isNew () , n ) ; return n . isOnlyModifiesThisCall () ; }
{ Preconditions . checkState ( n . isCall () , n ) ; return ( n . getSideEffectFlags () & Node.FLAG_LOCAL_RESULTS ) > NUMBER_CONSTANT ; }
Preconditions . checkState ( node . hasTwoChildren () , node ) ;
{ Preconditions . checkArgument ( n . isClass () ) ; return n . getLastChild () ; }
Preconditions . checkState ( n . isFunction () || n . isClass () ) ;
Preconditions . checkState ( n . isFunction () || n . isClass () ) ;
Preconditions . checkState ( descriptor . isObjectLit () ) ;
Preconditions . checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
Preconditions . checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
Preconditions . checkNotNull ( var ) ;
Preconditions . checkState ( function . isFunction () ) ;
Preconditions . checkState ( function . isFunction () ) ;
if ( modifyCallSites ) { Preconditions . checkNotNull ( defFinder ) ; callSiteOptimizer = new CallSiteOptimizer ( compiler , defFinder ) ; }
Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
{ Preconditions . checkState ( this . fn == null ) ; this . fn = fn ; }
Preconditions . checkArgument ( changed != null ) ;
Preconditions . checkState ( functionState . hasExistingFunctionDefinition () ) ;
Preconditions . checkState ( n . isName () , n ) ;
Preconditions . checkState ( name . isName () ) ;
Preconditions . checkState ( NodeUtil . isGet ( child ) ) ;
Preconditions . checkArgument ( fn . isFunction () ) ;
Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
Preconditions . checkNotNull ( data ) ;
{ Preconditions . checkState ( hasProcessBeenRun , STRING_CONSTANT ) ; return definitionNodeByDefinitionSite . values () ; }
Preconditions . checkNotNull ( site ) ;
Preconditions . checkState ( ! hasProcessBeenRun , STRING_CONSTANT ) ;
Preconditions . checkNotNull ( colorToNodeMap , STRING_CONSTANT ) ;
int exitCodeValue = Preconditions . checkNotNull ( exitCode ) ;
{ Preconditions . checkNotNull ( entryPoints ) ; this . entryPoints = entryPoints ; return this ; }
{ Preconditions . checkState ( NUMBER_CONSTANT == Iterables . size ( inputs ) ) ; return; }
Preconditions . checkState ( compiler . getOptions () . outputJs == OutputJs.NORMAL ) ;
Preconditions . checkState ( specs != null ) ;
Preconditions . checkState ( zipEntryName . contains ( filename ) ) ;
Preconditions . checkNotNull ( input ) ;
{ this . exitCodeReceiver = Preconditions . checkNotNull ( newExitCodeReceiver ) ; }
Preconditions . checkArgument ( inputsSupplier == null ^ modulesSupplier == null ) ;
Preconditions . checkState ( currentInfo != null ) ;
{ this . compilerOptions = Preconditions . checkNotNull ( compilerOptions ) ; return this ; }
{ Preconditions . checkState ( c . isScript () ) ; hotSwapScript ( c , null ) ; }
Preconditions . checkNotNull ( sourceString ) ;
Preconditions . checkArgument ( js.length == NUMBER_CONSTANT , STRING_CONSTANT ) ;
Preconditions . checkState ( block . isNormalBlock () ) ;
{ Preconditions . checkState ( nameNode . isQualifiedName () ) ; return nameNode . getLastChild () . getString () . startsWith ( STRING_CONSTANT ) ; }
Preconditions . checkState ( TokenStream . isJSIdentifier ( tempVarName ) ) ;
Preconditions . checkArgument ( newSourceInd < sources . size () ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( result != null ) ;
Preconditions . checkState ( n . isNew () || n . isCall () ) ;
Preconditions . checkState ( compiler . getLifeCycleStage () == LifeCycleStage.NORMALIZED ) ;
Preconditions . checkState ( null == m . put ( type , top ) ) ;
{ Integer priority = priorities . get ( n ) ; Preconditions . checkNotNull ( priority ) ; return priority ; }
Preconditions . checkState ( handler . isTry () ) ;
Preconditions . checkState ( cur . getParent () != null , STRING_CONSTANT ) ;
{ Preconditions . checkState ( next . isCase () ) ; createEdge ( node , Branch.ON_FALSE , next ) ; }
{ Preconditions . checkState ( exceptionHandler . peek () == parent ) ; exceptionHandler . pop () ; }
String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName () ) ;
{ Preconditions . checkState ( ! aliasReference . hasChildren () ) ; aliasReference . addChildToFront ( replacement ) ; }
Preconditions . checkState ( matches . size () == NUMBER_CONSTANT , matches ) ;
Preconditions . checkState ( currentStatement . isDo () ) ;
Preconditions . checkNotNull ( compiler ) ;
{ Preconditions . checkState ( parent == scope . getParent () ) ; }
Preconditions . checkArgument ( nameNode . isName () ) ;
Preconditions . checkArgument ( ancestors.length > NUMBER_CONSTANT ) ;
private int getMaskForBitIndex ( int bitIndex ) { Preconditions . checkArgument ( bitIndex >= NUMBER_CONSTANT , STRING_CONSTANT ) ; return NUMBER_CONSTANT < < bitIndex ; }
Preconditions . checkState ( t . getScope () . isFunctionBlockScope () ) ;
{ Preconditions . checkNotNull ( edgeAnnotationStack , STRING_CONSTANT ) ; popAnnotations ( edgeAnnotationStack ) ; }
{ Preconditions . checkNotNull ( nodeAnnotationStack , STRING_CONSTANT ) ; popAnnotations ( nodeAnnotationStack ) ; }
{ Preconditions . checkState ( call . isCall () ) ; call . putBooleanProp ( Node.FREE_CALL , true ) ; return call ; }
Preconditions . checkArgument ( call . isCall () ) ;
{ Preconditions . checkState ( parent . isVar () ) ; parent . removeChild ( nameNode ) ; }
{ Preconditions . checkState ( NodeUtil . createsBlockScope ( root ) , scope ) ; symbolStack . push ( new NameContext ( anonymousNode , scope ) ) ; }
Preconditions . checkState ( isGeneric () ) ;
{ Preconditions . checkState ( isGeneric () ) ; return substituteParametricGenerics ( typeMap ) ; }
{ for ( String typeParam : this . typeParameters ) { Preconditions . checkState ( ! typeMap . containsKey ( typeParam ) ) ; } }
Preconditions . checkState ( this . isLoose () || f2 . isLoose () ) ;
{ Preconditions . checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ; f1 . isSubtypeOfHelper ( f2 , true , subSuperMap , boxedInfo ) ; }
Preconditions . checkArgument ( f1 . isLoose () || f2 . isLoose () ) ;
Preconditions . checkArgument ( ! isTopFunction () ) ;
{ Preconditions . checkState ( ! isTopFunction () ) ; return requiredFormals . size () ; }
{ Preconditions . checkState ( ! isTopFunction () ) ; return outerVarPreconditions . get ( name ) ; }
Preconditions . checkState ( ! isTopFunction () ) ;
public JSType getRestFormalsType () { Preconditions . checkNotNull ( restFormals ) ; return restFormals ; }
Preconditions . checkState ( isUniqueConstructor () ) ;
Preconditions . checkNotNull ( commonTypes ) ;
Preconditions . checkArgument ( o instanceof DeferredCheck ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
Preconditions . checkState ( insideQualifiedName ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkArgument ( pname == null || pname . isIdentifier () ) ;
Preconditions . checkNotNull ( type ) ;
{ Preconditions . checkArgument ( ! varName . contains ( STRING_CONSTANT ) ) ; return env . putType ( varName , type ) ; }
{ Preconditions . checkArgument ( ! pname . contains ( STRING_CONSTANT ) ) ; return env . getType ( pname ) ; }
Preconditions . checkArgument ( expr . isNew () || expr . isCall () ) ;
Preconditions . checkArgument ( callNode . isCall () || callNode . isNew () ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkArgument ( thisExpr . isThis () ) ;
Preconditions . checkState ( propAccessNode . isGetProp () || propAccessNode . isGetElem () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( propAccessNode . isGetProp () || propAccessNode . isGetElem () ) ;
Preconditions . checkNotNull ( funType ) ;
Preconditions . checkState ( receiver == null || isFwd ) ;
Preconditions . checkState ( ! formalType . isBottom () ) ;
Preconditions . checkArgument ( call . isCall () ) ;
Preconditions . checkState ( logicalOp == Token.AND ) ;
Preconditions . checkState ( n != null , STRING_CONSTANT ) ;
TypeEnv outEnv = Preconditions . checkNotNull ( getOutEnv ( dn ) ) ;
if ( fnType . getFunType () == null ) { Preconditions . checkState ( fnType . isUnknown () ) ; return this . commonTypes . qmarkFunction () ; }
Preconditions . checkState ( qnameRoot . isName () ) ;
{ Preconditions . checkNotNull ( original ) ; return original != this . node || this . isChanged () ; }
{ Preconditions . checkState ( this . isNot () ) ; return ( normalizeChildren ( node , children ) [ NUMBER_CONSTANT ] ) . change () ; }
Preconditions . checkNotNull ( n . getParent () ) ;
Preconditions . checkState ( n . getParent () != null ) ;
Preconditions . checkNotNull ( dNode ) ;
Preconditions . checkNotNull ( dNode ) ;
if ( doSanityChecks && sourceFile != null ) { Preconditions . checkState ( sourceFile . equals ( n . getSourceFileName () ) ) ; }
{ Preconditions . checkState ( this . declaration == null ) ; this . declaration = ref ; }
if ( otherScopeParent == null ) { Preconditions . checkState ( globalScope == null , STRING_CONSTANT ) ; }
Preconditions . checkNotNull ( declNode ) ;
Preconditions . checkState ( fn . isConstructor () || fn . isInterface () ) ;
Preconditions . checkState ( fn . isConstructor () || fn . isInterface () ) ;
Preconditions . checkArgument ( destructuringLhs . isDestructuringLhs () ) ;
{ Preconditions . checkState ( lhs . isName () ) ; checkShortName ( t , lhs , callNode . getLastChild () . getString () ) ; }
Preconditions . checkState ( callNode . isCall () ) ;
Preconditions . checkState ( currentModule == null ) ;
{ Preconditions . checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ; this . compiler = compiler ; }
{ Preconditions . checkState ( languageIn != LanguageMode.NO_TRANSPILE ) ; this . languageIn = languageIn ; }
{ Preconditions . checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
Preconditions . checkNotNull ( entryPoints ) ;
{ Preconditions . checkArgument ( funAstSize > NUMBER_CONSTANT ) ; this . maxFunctionSizeAfterInlining = funAstSize ; }
Preconditions . checkState ( value instanceof String ) ;
Preconditions . checkState ( script . isScript () ) ;
Preconditions . checkState ( script . isScript () ) ;
Preconditions . checkState ( script . isScript () ) ;
Preconditions . checkState ( script . isScript () ) ;
{ Preconditions . checkState ( hasReferenceName () ) ; return getReferenceName () . hashCode () ; }
{ Preconditions . checkState ( n . getParent () . getFirstChild () == n ) ; return n . getParent () . cloneTree () . getFirstChild () ; }
if ( n . isScript () ) { Preconditions . checkState ( this . script == null ) ; this . script = n ; }
Preconditions . checkState ( root . isScript () ) ;
Preconditions . checkState ( root . isScript () ) ;
Preconditions . checkState ( newReachable . getAnnotation () != REACHABLE ) ;
Preconditions . checkNotNull ( compiler ) ;
{ super ( source ) ; Preconditions . checkNotNull ( source ) ; this . excerpt = excerpt ; }
Preconditions . checkNotNull ( paramType , STRING_CONSTANT ) ;
Preconditions . checkState ( n . isAssign () ) ;
protected boolean isASTNormalized () { Preconditions . checkNotNull ( compiler ) ; return compiler . getLifeCycleStage () . isNormalized () ; }
{ Preconditions . checkNotNull ( compiler ) ; return compiler . areNodesEqualForInlining ( n1 , n2 ) ; }
Preconditions . checkNotNull ( typeParameters ) ;
{ Preconditions . checkState ( this . nominalType == null ) ; this . nominalType = t ; return this ; }
{ Preconditions . checkState ( returnType == null ) ; returnType = t ; return this ; }
{ Preconditions . checkState ( restFormals == null ) ; restFormals = t ; return this ; }
Preconditions . checkArgument ( ! t . isBottom () ) ;
public FunctionTypeBuilder ( JSTypes commonTypes ) { this . commonTypes = Preconditions . checkNotNull ( commonTypes ) ; }
Preconditions . checkArgument ( qName != null && ownerName != null ) ;
Preconditions . checkArgument ( ! variableName . isEmpty () ) ;
{ Preconditions . checkNotNull ( inputId ) ; sourceName = NodeUtil . getSourceName ( n ) ; }
Preconditions . checkArgument ( o instanceof Property ) ;
Preconditions . checkArgument ( inferredType != null ) ;
Preconditions . checkNotNull ( inputId ) ;
Preconditions . checkNotNull ( inputId ) ;
{ super ( registry , templateTypeMap ) ; setReferencedType ( Preconditions . checkNotNull ( referencedType ) ) ; }
Preconditions . checkState ( DEFAULT_EXTERNS . length () != externs . length () ) ;
Preconditions . checkState ( behaviorObjLit . isObjectLit () ) ;
Preconditions . checkState ( behaviorObjLit . isObjectLit () ) ;
Preconditions . checkNotNull ( keys ) ;
Preconditions . checkNotNull ( namedType ) ;
{ Preconditions . checkNotNull ( name ) ; nonNullableTypeNames . add ( name ) ; }
Preconditions . checkArgument ( source == null || source . isFunction () ) ;
Preconditions . checkState ( source . isFunction () , source ) ;
{ Preconditions . checkState ( namesToTypes . containsKey ( name ) ) ; register ( t , name ) ; }
{ Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) , STRING_CONSTANT ) ; namesToTypes . put ( name , type ) ; }
public TemplateType getObjectIndexKey () { Preconditions . checkNotNull ( iObjectIndexTemplateKey ) ; return this . iObjectIndexTemplateKey ; }
Preconditions . checkNotNull ( inputId ) ;
Preconditions . checkState ( n . hasOneChild () , n ) ;
{ Preconditions . checkArgument ( compiler . getLifeCycleStage () . isNormalized () ) ; this . compiler = compiler ; }
{ Preconditions . checkNotNull ( realSource ) ; this . realSource = realSource ; this . reportParseErrors = reportParseErrors ; }
Preconditions . checkNotNull ( declaration ) ;
Preconditions . checkState ( parent . isClassMembers () ) ;
Preconditions . checkState ( parent . isObjectLit () ) ;
Preconditions . checkState ( obj instanceof AstChange ) ;
Preconditions . checkArgument ( functionName != null ) ;
Preconditions . checkArgument ( parameterName != null ) ;
Preconditions . checkState ( labeledVariable . isVar () ) ;
Property nameProp = Preconditions . checkNotNull ( getOrCreateProperty ( n ) ) ;
{ Preconditions . checkArgument ( blockNode . isNormalBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
Preconditions . checkArgument ( assignedAt . isQualifiedName () ) ;
{ Preconditions . checkArgument ( lhs . isQualifiedName () ) ; writes . addLast ( new PropertyWrite ( lhs ) ) ; }
Preconditions . checkArgument ( obj . isObjectLit () ) ;
{ Preconditions . checkNotNull ( internalScopeCreator ) ; internalScopeCreator . patchGlobalScope ( topScope , scriptRoot ) ; }
Preconditions . checkState ( defParent . isExprResult () ) ;
Preconditions . checkArgument ( use . isName () ) ;
Preconditions . checkState ( t . getScopeRoot () . isFunction () ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( callOrNew . isCall () || callOrNew . isNew () ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkArgument ( userOrderedInputs . containsAll ( rootInputs ) ) ;
Preconditions . checkState ( nameNode != null ) ;
Preconditions . checkState ( ! name . isEmpty () ) ;
Preconditions . checkState ( ! current.renameMap . containsKey ( name ) ) ;
Preconditions . checkState ( fnNode . isFunction () ) ;
Preconditions . checkState ( callNode . isCall () ) ;
Preconditions . checkState ( ORDER_CODE_REPLACEMENTS . isOrdered ( replacements ) ) ;
Preconditions . checkState ( ORDER_CODE_REPLACEMENTS . isOrdered ( replacements ) ) ;
Preconditions . checkState ( this . namespaceType == null ) ;
Preconditions . checkNotNull ( interfaceType ) ;
Preconditions . checkNotNull ( node ) ;
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopeNodes , this , false ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true , true ) ; }
{ return new J2clClinitPrunerPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler , true ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () , true ) ; }
EnvTypePair pair = analyzeExprFwd ( prop , recvLvalue.env , indexType . isBottom () ? UNKNOWN : indexType ) ;
builder . put ( typeParam , t . isBottom () ? UNKNOWN : t ) ;
pair = analyzeExprFwd ( index , pair.env , indexType . isBottom () ? UNKNOWN : indexType ) ;
{ builder . addRetType ( actualRetType . isBottom () ? TOP : actualRetType ) ; }
moduleResolutionMode = ModuleLoader.ResolutionMode.LEGACY ;
public void testEs6ThisWithImportModule () { testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , Es6CheckModule.ES6_MODULE_REFERENCES_THIS ) ; }
String result = STRING_CONSTANT + STRING_CONSTANT ;
if ( forAnnotations ) { return sb . append ( getReferenceName () ) ; }
{ @ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler , true ) ; } }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler ) ; }
{ return new J2clClinitPrunerPass ( compiler ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels () ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true ) ; }
{ this ( config , errorReporter , source , offset , false , true ) ; }
return new ParseResult ( root , comments , features , p . getInlineSourceMap () ) ;
Node objectLit = n . getFirstChild () . getFirstChild () . getFirstChild () ;
@ Override MustDef createEntryLattice () { return new MustDef ( jsScope . getVarIterable () ) ; }
return JSType . fromObjectType ( ObjectType . fromNominalType ( tmp . instantiateGenerics ( typeMap ) ) ) ;
return nominal == null ? null : nominal . instantiateGenerics ( this . commonTypes . MAP_TO_UNKNOWN ) . getInstanceAsJSType () ;
{ if ( interf . inheritsFromIObjectReflexive () ) { result . add ( interf . instantiateGenerics ( typeMap ) ) ; } }
for ( NominalType interf : this . rawType . getInterfaces () ) { result . add ( interf . instantiateGenerics ( typeMap ) ) ; }
return this . rawType . getSuperClass () . instantiateGenerics ( typeMap ) ;
! isInvalidatingType ( dest )
! props . containsKey ( propName ) && ! isInvalidatingType ( type ) && NodeUtil . isImmutableValue ( value ) && NodeUtil . isExecutedExactlyOnce ( value )
{ fn = fn == null ? null : fn . withLoose () ; props = joinPropsLoosely ( commonTypes , obj1.props , obj2.props ) ; }
{ props = joinPropsLoosely ( commonTypes , obj1.props , obj2.props ) ; }
if ( doSlicing ) { pair.env = envPutType ( pair.env , name , declType != null ? declType : UNKNOWN ) ; }
preciseType = declType == null ? requiredType : declType ;
{ JSType result = ft . getSuperPrototype () ; pair.type = result != null ? result : UNDEFINED ; return pair ; }
{ JSType tmp = t . getIndexedType () ; return tmp == null ? UNKNOWN : tmp ; }
declRetType = declRetType == null ? UNKNOWN : declRetType ;
{ return new InstrumentFunctions ( compiler , functionNames , options.instrumentationTemplate , options.appNameStr ) ; }
{ variableMap = runVariableRenaming ( compiler , prevVariableMap , externs , root ) ; }
propertyMap = rprop . getPropertyMap () ;
anonymousFunctionNameMap = naf . getFunctionMap () ;
{ return new CrossModuleMethodMotion ( compiler , crossModuleIdGenerator , options.removeUnusedPrototypePropertiesInExterns , options.crossModuleCodeMotionNoStubMethods ) ; }
stringMap = pass . getStringMap () ;
idGeneratorMap = pass . getSerializedIdMappings () ;
functionNames = pass . getFunctionNames () ;
cssNames = newCssNames ;
{ return new CrossModuleMethodMotion ( compiler , new CrossModuleMethodMotion.IdGenerator () , canMoveExterns , noStubs ) ; }
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveGoogProvidesAndRequires || this . shouldGenerateTypedExterns () ; }
preserveGoogProvidesAndRequires = false ;
public static Matcher googModuleOrProvide () { return anyOf ( functionCall ( STRING_CONSTANT ) , functionCall ( STRING_CONSTANT ) ) ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
parse ( STRING_CONSTANT ) ;
skipStringLiteralEscapeSequence () ;
private boolean skipStringLiteralChar () { if ( peek ( CHAR_CONS ) ) { return skipStringLiteralEscapeSequence () ; } nextChar () ; return true ; }
return isUnknown () || ( isUnknownObject () && isLoose () ) || ( ft != null && ft . isTopFunction () ) ;
objType == null || types . contains ( objType ) || objType . isUnknownObject () || objType . isUnknownType () || objType . isBottom ()
return objType . isUnknownObject () || ( ft != null && ft . isConstructor () && isInvalidatingType ( ft . getInstanceType () ) ) ;
JSType type
JSType type
JSType type
boolean mustReplaceThisAndArguments () { return thisAndArgumentsContext . isAsyncContext () ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
parent . getParent () . isCall () && NodeUtil . isCallOrNewTarget ( parent )
checkArgument ( expr . isCall () ) ;
checkArgument ( n . isFunction () || ( n . isName () && NodeUtil . isCallOrNewTarget ( n ) ) ) ;
return analyzeCallNodeArgsFwdWhenError ( call , inEnv ) ;
{ checkArgument ( ! pname . contains ( STRING_CONSTANT ) ) ; return env . getType ( pname ) ; }
for ( FunctionTypeI impl : constructor . getSubTypes () ) { list . add ( impl . getInstanceType () ) ; }
if ( constructor != null ) { for ( FunctionTypeI subType : constructor . getSubTypes () ) { addRelatedInstance ( subType , related ) ; } }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives || this . shouldGenerateTypedExterns () ; }
preserveClosurePrimitives = false ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.TEMPLATE_ARGUMENT_MISMATCH , NewTypeInference.WRONG_ARGUMENT_COUNT ) ;
testSame ( TEST_EXTERNS + externs , STRING_CONSTANT , GlobalTypeInfo.REDECLARED_PROPERTY ) ;
testSame ( TEST_EXTERNS + externs , STRING_CONSTANT , GlobalTypeInfo.REDECLARED_PROPERTY ) ;
typeCheck ( js , GlobalTypeInfo.CTOR_IN_DIFFERENT_SCOPE , NewTypeInference.MISTYPED_ASSIGN_RHS ) ;
typeCheck ( js , GlobalTypeInfo.ANONYMOUS_NOMINAL_TYPE , GlobalTypeInfo.ANONYMOUS_NOMINAL_TYPE , NewTypeInference.MISTYPED_ASSIGN_RHS ) ;
typeCheck ( STRING_CONSTANT , GlobalTypeInfo.INEXISTENT_PARAM ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfo.WRONG_PARAMETER_COUNT ) ;
public void testUnknownTypeReferenceDoesntCrash () { typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ; }
typeCheck ( STRING_CONSTANT , GlobalTypeInfo.INEXISTENT_PARAM ) ;
public void testVarDecls () { typeCheck ( STRING_CONSTANT , GlobalTypeInfo.ONE_TYPE_FOR_MANY_VARS ) ; typeCheck ( STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; typeCheck ( STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; }
typeCheck ( STRING_CONSTANT , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ;
typeCheck ( STRING_CONSTANT , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ;
testSame ( DEFAULT_EXTERNS , STRING_CONSTANT , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ;
this . symbolTable = ( GlobalTypeInfo ) compiler . getSymbolTable () ;
passes . add ( makePassFactory ( STRING_CONSTANT , compiler . getSymbolTable () ) ) ;
test ( options , STRING_CONSTANT , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ;
symbolTable = compilerState.symbolTable ;
this . symbolTable = compiler.symbolTable ;
return getSymbolTable () . getImplicitInterfaceUses () ;
return getSymbolTable () . getMismatches () ;
symbolTable = null ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfo.INVALID_PROP_OVERRIDE ) ;
ignoreWarnings ( GlobalTypeInfo.INTERFACE_METHOD_NOT_IMPLEMENTED , TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) ) ;
parseWarning ( STRING_CONSTANT , TRAILING_COMMA_MESSAGE ) ;
parseWarning ( STRING_CONSTANT , TRAILING_COMMA_MESSAGE ) ;
parseWarning ( js , warning , warning ) ;
Node ast
features = features . union ( factory . getFeatures () ) ;
ImmutableMap . < Pattern , DiagnosticType > builder () . put ( Pattern . compile ( STRING_CONSTANT ) , TRAILING_COMMA )
{ features = features . union ( FeatureSet.TYPESCRIPT ) ; return nextToken () . type ; }
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) , getRequiresEs6Message ( Feature.ARRAY_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) , getRequiresEs6Message ( Feature.ARRAY_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.TRAILING_COMMA ) ) ;
parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.TRAILING_COMMA ) ) ;
parseWarning ( js , warning ) ;
@ Nullable Node ast
features = factory . getFeatures () ;
ImmutableMap . < Pattern , DiagnosticType > builder () . put ( Pattern . compile ( STRING_CONSTANT + STRING_CONSTANT ) , TRAILING_COMMA )
{ features = features . with ( Feature.ACCESSIBILITY_MODIFIER ) ; return nextToken () . type ; }
new CheckRequiresForConstructors ( compiler , CheckRequiresForConstructors.Mode.SINGLE_FILE )
public void testFailGoogArray () { mode = CheckRequiresForConstructors.Mode.SINGLE_FILE ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testFailConstant () { mode = CheckRequiresForConstructors.Mode.SINGLE_FILE ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; mode = CheckRequiresForConstructors.Mode.FULL_COMPILE ; }
n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ( ! jsScope . isDeclaredSloppy ( ARGUMENT_ARRAY_ALIAS , false ) || ! childDeclared )
{ return n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ! jsScope . isDeclaredSloppy ( ARGUMENT_ARRAY_ALIAS , false ) ; }
if ( ! jsScope . isDeclaredSloppy ( name , false ) ) { return; }
assertTrue ( fBlockScope . isDeclaredSloppy ( STRING_CONSTANT , false ) ) ;
assertTrue ( fBlockScope . isDeclaredSloppy ( STRING_CONSTANT , false ) ) ;
assertTrue ( fBlockScope . isDeclaredSloppy ( STRING_CONSTANT , false ) ) ;
if ( ! functionBlockScope . isDeclaredSloppy ( name , false ) ) { return; }
if ( current . isDeclaredSloppy ( oldName , false ) ) { return; } else { current = current . getParent () ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveGoogProvidesAndRequires || this . shouldGenerateTypedExterns () ; }
preserveGoogProvidesAndRequires = false ;
public static Matcher googModuleOrProvide () { return anyOf ( functionCall ( STRING_CONSTANT ) , functionCall ( STRING_CONSTANT ) ) ; }
maybeProcessAccessibilityModifier ( member , tree.access ) ;
maybeProcessAccessibilityModifier ( n , tree.access ) ;
maybeProcessAccessibilityModifier ( member , functionTree.access ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ; }
{ env = analyzeExprBwd ( prop . getFirstChild () , env , enumeratedType ) . env ; }
EnvTypePair pair = analyzeExprBwd ( prop . getFirstChild () , env , reqPtype ) ;
EnvTypePair pair = analyzeExprFwd ( prop . getFirstChild () , env , enumeratedType ) ;
EnvTypePair pair = analyzeExprFwd ( prop . getFirstChild () , env , reqPtype , specPtype ) ;
PropertyDef propdef = checkNotNull ( getPropDefFromClass ( superType , pname ) ) ;
return state . getIn () . reachingDef . get ( jsScope . getVar ( name ) ) ;
Var dep = jsScope . getVar ( n . getString () ) ;
@ Override MustDef createEntryLattice () { return new MustDef ( returnAllVars () ) ; }
Iterable < ? extends Var > vars
return state . getOut () . mayUseMap . get ( jsScope . getVar ( name ) ) ;
{ Pattern pattern = new Pattern () ; pattern.regExp = RegExp . compile ( string ) ; return pattern ; }
node = new Node <> ( e ) ;
Map < Node < E > , ImmutableSet.Builder < E > > groupsTmp = new HashMap <> () ;
E e
@ Override public void add ( E e ) { union ( e , e ) ; }
{ for ( E elem : other . elements () ) { union ( elem , other . find ( elem ) ) ; } }
public void testUnusedLocalConst_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUnusedEs6 ( STRING_CONSTANT ) ; }
public void testUnusedLocalConst () { enableUnusedLocalAssignmentCheck = true ; assertUnusedEs6 ( STRING_CONSTANT ) ; }
public void testUnusedLocalLet_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUnusedEs6 ( STRING_CONSTANT ) ; }
{ enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; assertUnusedEs6 ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
assertUnusedEs6 ( STRING_CONSTANT ) ;
public void testDefaultParam_withES6Modules () { assertEarlyReferenceError ( STRING_CONSTANT ) ; assertNoWarningEs6 ( STRING_CONSTANT ) ; }
public void testES6Module_destructuring () { enableUnusedLocalAssignmentCheck = true ; assertNoWarningEs6 ( STRING_CONSTANT ) ; }
public void testUnusedCompoundAssign_withES6Modules () { assertNoWarningEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testUsedInShorthandObjLit_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUndeclaredEs6 ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
assertUndeclaredEs6 ( STRING_CONSTANT ) ;
public void testForOf () { assertEarlyReferenceError ( STRING_CONSTANT ) ; assertNoWarningEs6 ( STRING_CONSTANT ) ; }
public void testRedeclare_withES6Modules () { assertRedeclare ( STRING_CONSTANT ) ; assertNoWarningEs6 ( STRING_CONSTANT ) ; }
assertNoWarningEs6 ( STRING_CONSTANT ) ;
Pattern includeFilePattern
new ProcessDefines ( compiler , ImmutableMap . copyOf ( replacements ) ) . injectNamespace ( namespaceForChecks ) . process ( externs , jsRoot ) ;
Set < String > defines = new ProcessDefines ( compiler , null ) . collectDefines ( root ) . keySet () ;
{ overrideDefines ( collectDefines ( root ) ) ; }
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.ES3 ; }
EnumSet . of ( TokenType.IDENTIFIER , TokenType.TYPE , TokenType.DECLARE , TokenType.MODULE , TokenType.NAMESPACE ) . contains ( type )
! peekId () && ! EnumSet . of ( TokenType.VOID , TokenType.OPEN_PAREN , TokenType.OPEN_CURLY , TokenType.TYPEOF ) . contains ( peekType () )
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
recordPropertyName ( getProp . getLastChild () . getString () , getProp ) ;
recordPropertyName ( pname , qnameNode ) ;
Function < String , Void > recordPropertyName
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.ES3 ; }
new ProcessDefines ( compiler , overrides , false ) . injectNamespace ( namespace ) . process ( externs , js ) ;
new ProcessDefines ( compiler , ImmutableMap . copyOf ( replacements ) , options.checksOnly ) . injectNamespace ( namespaceForChecks ) . process ( externs , jsRoot ) ;
Set < String > defines = new ProcessDefines ( compiler , null , false ) . collectDefines ( externs , root ) . keySet () ;
( n . isName () ) && isDeclaration ( n )
public boolean isAsyncFunction () { return getBooleanProp ( ASYNC_FN ) ; }
public boolean isArrowFunction () { return getBooleanProp ( ARROW_FN ) ; }
if ( key . isEmpty () ) { continue; }
isInvalidatingType ( recvType ) || isStructuralInterfacePrototype ( recv )
{ if ( isInvalidatingType ( type ) ) { invalidate () ; return false ; } rootTypesByNode . put ( node , type ) ; }
if ( isInvalidatingType ( top ) ) { invalidate () ; return; }
List < MemberDefinition > properties = PolymerPassStaticUtils . extractProperties ( behaviorValue , compiler ) ;
new PolymerPass ( compiler ) . process ( externs , root ) ;
new PolymerPass ( compiler ) . process ( externsRoot , mainRoot ) ;
PolymerClassDefinition def = parseAndExtractClassDef ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDef ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDef ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDef ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
Property p = getProp ( pname ) ;
Property p = getPropFromClass ( pname ) ;
rhs . matchesQualifiedName ( ABSTRACT_METHOD_NAME ) || ( GlobalTypeInfo . isCtorDefinedByCall ( lhs ) && ! isFunctionBind ( rhs . getFirstChild () , inEnv , true ) )
( GlobalTypeInfo . isCtorDefinedByCall ( nameNode ) && ! isFunctionBind ( rhs . getFirstChild () , inEnv , true ) )
return this . nominalType . getProp ( pname ) ;
if ( nom != null ) { return nom . getProp ( pname ) ; }
Property p = this . rawType . getProp ( pname ) ;
Property p = this . rawType . getOwnProp ( pname ) ;
( ns . hasProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , propDeclType , previousPropType ) )
classType . hasCtorProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , propDeclType , previousPropType )
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () ) ;
{ return new PeepholeOptimizationsPass ( compiler , new ExploitAssigns () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , new ReorderConstantExpression () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , new PeepholeCollectPropertyAssignments () ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeSubstituteAlternateSyntax ( late ) ) ;
{ PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new StatementFusion ( favorsCommas ) ) ; return peepholePass ; }
{ return new PeepholeOptimizationsPass ( compiler , new ExploitAssigns () ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return createPeepholeOptimizationsPass ( compiler ) ; }
{ return new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () ) ; }
computeEscaped ( jsScope . getParent () , jsScope , escaped , compiler , scopeCreator ) ;
computeEscaped ( jsScope . getParent () , jsScope , escaped , compiler , scopeCreator ) ;
computeEscaped ( jsScope , jsScopeChild , escaped , compiler , scopeCreator ) ;
if ( isObjLit ) { declareVarsForObjLitValues ( n , alias , rvalue , varNode , varNode . getPrevious () , varParent ) ; }
super ( inExterns ) ;
super ( isExtern ) ;
{ super ( inExterns ) ; checkArgument ( node . isAssign () ) ; assignment = node ; }
{ super ( inExterns ) ; Preconditions . checkArgument ( node . isClass () ) ; c = node ; }
{ super ( inExterns ) ; checkArgument ( node . isFunction () ) ; function = node ; }
super ( inExterns ) ;
Property p = this . rawType . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
superType . isInterface () && current . isClass () && ! isCtorDefinedByCall ( current ) && ! current . mayHaveProp ( pname )
superClass . isAbstractClass () && superClass . hasAbstractMethod ( pname ) && ! rawType . isAbstractClass () && ! rawType . mayHaveOwnProp ( pname )
if ( maybeWin != null ) { return maybeWin . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ; }
@ Override public boolean apply ( Node n ) { return isFunctionDeclaration ( n ) || n . isVar () ; }
n . getParent () . isVar ()
! NodeUtil . isVarOrSimpleAssignLhs ( callNode , parent )
{ if ( NodeUtil . isVarOrSimpleAssignLhs ( parent , grandparent ) ) { validProperties . add ( propName ) ; } else { return false ; } }
if ( NodeUtil . isVarOrSimpleAssignLhs ( n , parent ) ) { if ( referring != null ) { recordReference ( referringName , name , RefType.REGULAR ) ; } return; }
if ( NodeUtil . isVarOrSimpleAssignLhs ( n , parent ) ) { return; }
{ if ( nextParent == null || ! NodeUtil . isVarOrSimpleAssignLhs ( nextNode , nextParent ) ) { readsState = true ; } }
NodeUtil . isVarOrSimpleAssignLhs ( n , n . getParent () )
dest . isString () && NodeUtil . isExprAssign ( grandParent ) && NodeUtil . isVarOrSimpleAssignLhs ( n , parent )
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
final int prop
int propType
int propType
int propType
public void putBooleanProp ( int propType , boolean value ) { putIntProp ( propType , value ? NUMBER_CONSTANT : NUMBER_CONSTANT ) ; }
int propType
int propType
int propType
public boolean getBooleanProp ( int propType ) { return getIntProp ( propType ) != NUMBER_CONSTANT ; }
int propType
int propType
int propType
int propType
int propType
int propType
@ Override public int getType () { return propType ; }
int propType
int propType
Set < Var > escaped
Set < N > entrySet = new HashSet <> () ;
Set < N > nodes = new HashSet <> () ;
String lValueName = NodeUtil . getBestLValueName ( NodeUtil . getBestLValue ( rValue ) ) ;
isStatementBlock ( parent ) || isSwitchCase ( node )
assertThat ( computeEscapedLocals ( STRING_CONSTANT ) ) . isEmpty () ;
validateChildCount ( n ) ;
{ validateChildCount ( n ) ; validateExpression ( n . getFirstChild () ) ; validateExpression ( n . getLastChild () ) ; }
private void validateUnaryOp ( Node n ) { validateChildCount ( n ) ; validateExpression ( n . getFirstChild () ) ; }
new ReorderConstantExpression ()
{ if ( parent . isParamList () ) { return true ; } else if ( parent . isVar () ) { return n . hasChildren () ; } }
List < Scope > allScopes = liveness . getScopeStack () ;
assertThat ( statements . get ( NUMBER_CONSTANT ) . isMovableDeclaration () ) . isTrue () ;
{ if ( parent . isParamList () ) { return true ; } else if ( NodeUtil . isNameDeclaration ( parent ) ) { return n . hasChildren () ; } }
thisProps = ! thisNt . isBuiltinObject () && thisNt . isStructuralInterface () ? thisNt . getAllPropsOfInterface () : this . props . keySet ()
{ otherPropNames = otherNt . getAllPropsOfInterface () ; if ( otherPropNames == null ) { return false ; } }
QualifiedName setterPname = new QualifiedName ( JSType . createSetterPropName ( pname . getLeftmostName () ) ) ;
QualifiedName getterPname = new QualifiedName ( JSType . createGetterPropName ( pname ) ) ;
scopeRoots . push ( node ) ;
{ validateChildCount ( n ) ; validateAssignmentTarget ( n . getFirstChild () ) ; validateExpression ( n . getLastChild () ) ; }
{ validateAssignmentTarget ( n ) ; }
public void testInvalidAnnotation4 ( ) throws Exception { testWarning ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
if ( ! t . getScope () . isHoistScope () ) { return; }
{ if ( t . getScope () . isHoistScope () ) { pop ( blockStack ) ; } }
if ( t . getScope () . isHoistScope () ) { blockStack . add ( new BasicBlock ( parent , n ) ) ; }
if ( t . getScope () . isHoistScope () ) { pop ( blockStack ) ; }
if ( t . getScope () . isHoistScope () ) { blockStack . add ( new BasicBlock ( parent , n ) ) ; }
Node hoistRoot = t . getClosestHoistScope () . getRootNode () ;
{ if ( n . isVar () && t . getScope () != t . getClosestHoistScope () ) { hoistVarIfNeeded ( t , n , parent ) ; } }
if ( scopeType == ScopeType.EXEC_CONTEXT ) { return t . getClosestHoistScope () . getRootNode () == currentScript.rootNode ; } else { return n . getParent () == currentScript.rootNode ; }
Node scopeRoot = t . getClosestHoistScope () . getRootNode () ;
if ( ! n . hasChildren () ) { rewriteEs6ObjectLiteralShorthandPropertySyntax ( n , compiler ) ; reportCodeChange ( n , STRING_CONSTANT ) ; }
yield . setYieldFor ( tree.isYieldFor ) ;
if ( n . isYieldFor () ) { checkNotNull ( first ) ; add ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
{ enableTypeCheck () ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
DiagnosticType warning
{ super . setUp () ; disableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
testWarning ( STRING_CONSTANT , RhinoErrorReporter.TOO_MANY_TEMPLATE_PARAMS ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , RhinoErrorReporter.TOO_MANY_TEMPLATE_PARAMS ) ; }
{ if ( parent . isParamList () ) { return true ; } else if ( parent . isVar () ) { return n . hasChildren () ; } }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ;
if ( hasParamWithNumberObjectLit ( fnNode ) ) { functionState . setInline ( false ) ; }
NodeUtil . tryMergeBlock ( moduleBody ) ;
if ( newChild . isNormalBlock () ) { NodeUtil . tryMergeBlock ( newChild ) ; }
NodeUtil . tryMergeBlock ( scopeClosureBlock ) ;
NodeUtil . tryMergeBlock ( callbackBlock ) ;
if ( NodeUtil . tryMergeBlock ( n ) ) { reportCodeChange () ; return null ; }
NodeUtil . tryMergeBlock ( moduleBody ) ;
Exception cause
catch ( Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
Exception unexpectedException
abstract void throwInternalError ( String msg , Exception cause ) ;
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isGeneric () ? nt . getRawNominalTypeAfterTypeChecking () . getInstanceAsJSType () : null ; }
if ( ! init . isEmpty () && ! init . isVar () ) { init = trySimplifyUnusedResult ( init , false ) ; }
if ( n . isVar () && n . hasOneChild () && n . getFirstFirstChild () != null ) { return true ; }
return globalScope . getType ( typeName ) ;
JSType declRetType = this . currentScope . getDeclaredFunctionType () . getReturnType () ;
JSType declRetType = this . currentScope . getDeclaredFunctionType () . getReturnType () ;
DeclaredFunctionType dft = this . currentScope . getDeclaredFunctionType () ;
return this . registry . evaluateTypeExpression ( expr , typeEnv ) ;
TypeI type = typeEnv . getType ( name ) ;
Node mapFunctionBody = getFunctionBody ( mapFunction ) ;
this . registry = compiler . getTypeRegistry () ;
ImmutableList < String > names
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isGeneric () ? nt . getRawNominalType () . getInstanceAsJSType () : null ; }
{ TemplatizedType t = toMaybeTemplatizedType () ; return t == null ? null : t . getReferencedType () ; }
if ( STRING_CONSTANT . equals ( name ) ) { if ( ! hasThis () ) { return null ; } return getDeclaredFunctionType () . getThisType () ; }
ImmutableSet . of ( TokenType.IDENTIFIER , TokenType.TYPE , TokenType.DECLARE , TokenType.MODULE , TokenType.NAMESPACE ) . contains ( type )
! peekId () && ! ImmutableSet . of ( TokenType.VOID , TokenType.OPEN_PAREN , TokenType.OPEN_CURLY , TokenType.TYPEOF ) . contains ( peekType () )
compiler = multistageSerializeAndDeserialize ( compiler , inputs , recentChange ) ;
{ functionBody . removeChild ( current ) ; insertAfter = addToFront ( functionBody , current , insertAfter ) ; reportCodeChange ( functionBody , STRING_CONSTANT ) ; }
reportCodeChange ( n , STRING_CONSTANT ) ;
reportCodeChange ( n , STRING_CONSTANT ) ;
boolean hasUnfilledTemplateKeys () { return numUnfilledTemplateKeys () > NUMBER_CONSTANT ; }
compiler . getOptions () . setStrictModeInput ( false ) ;
Object getObjectValue ( ) ;
compiler . addToDebugLog ( STRING_CONSTANT + defineName ) ;
compiler . addToDebugLog ( STRING_CONSTANT + var.name ) ;
compiler . addToDebugLog ( STRING_CONSTANT + name + STRING_CONSTANT + newName ) ;
catch ( RuntimeException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
t . getCompiler () . addToDebugLog ( STRING_CONSTANT + fn . getName () ) ;
{ return new IntPropListItem ( getType () , intValue , next ) ; }
{ return new ObjectPropListItem ( getType () , objectValue , next ) ; }
var . setStaticSourceFile ( input . getSourceFile () ) ;
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
assertPassOrder ( checks , chromePass , checkJsDoc , STRING_CONSTANT ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
ImmutableList < String > typeParameters
public List < String > getTypeParameters () { return typeParameters ; }
builder . addTypeParameters ( nt . getTypeParameters () ) ;
this . typeParameters = ImmutableList . of () ;
ImmutableList < String > typeParameters
ImmutableList < String > typeParameters
public boolean isDeleted () { return getBooleanProp ( DELETED ) ; }
@ Nullable PropListItem getPropListHeadForTesting () { return propListHead ; }
public int getSourcePosition () { return sourcePosition ; }
public int getCharno () { return extractCharno ( sourcePosition ) ; }
public int getLineno () { return extractLineno ( sourcePosition ) ; }
{ validateExpression ( n . getLastChild () ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; super . enableNormalize () ; }
public void toStringIsEqualTo ( String typeString ) { assertEquals ( actual () . toString () , typeString ) ; }
if ( n . isParamList () ) { requiresTypes = true ; return; }
checks . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
checks . add ( createEmptyPass ( PassNames.AFTER_STANDARD_CHECKS ) ) ;
n . getParent () . isVar () && n . isName ()
checkState ( e != null , STRING_CONSTANT + STRING_CONSTANT ) ;
Typedef td = Typedef . make ( jsdoc . getTypedefType () ) ;
TypeI type = typeEnv . getNamespaceType ( name ) ;
options . setPackageJsonEntryNames ( ImmutableList . of ( STRING_CONSTANT , CompilerOptions.PACKAGE_JSON_MAIN ) ) ;
packageJsonEntryNames = ImmutableList . of ( CompilerOptions.PACKAGE_JSON_MAIN ) ;
checks . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
{ Node nameNode = n . getFirstChild () ; renamer . addDeclaredName ( nameNode . getString () , true ) ; }
if ( this . classProps . containsKey ( pname ) || this . protoProps . containsKey ( pname ) ) { return; }
this . allProps = builder . addAll ( classProps . keySet () ) . addAll ( protoProps . keySet () ) . build () ;
Property p = getOwnProp ( pname , propAccess ) ;
Property p = getOwnProp ( pname , propAccess ) ;
{ ObjectType obj = getObjTypeIfSingletonObj () ; return obj != null && obj . hasOwnProperty ( new QualifiedName ( propertyName ) ) ; }
{ checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getOwnPropertyDefSite ( propertyName ) ; }
classType . mayHaveOwnProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , typeInJsdoc , previousPropType )
this . externs = makeCompilerInput ( externs , true ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
{ for ( Var var : scriptToVarMap . get ( script ) ) { super . undeclareInteral ( var ) ; } }
visitForOf ( n , parent ) ;
compiler . ensureLibraryInjected ( STRING_CONSTANT + function . toLowerCase ( Locale.US ) , false ) ;
CompilerInput newInput = ( CompilerInput ) deserialize ( serialize ( input ) ) ;
@ Override public FeatureSet featureSet () { return ES8 ; }
madeChange = true ;
preloadEs6RuntimeFunction ( compiler , function ) ;
visitForOf ( t , n , parent ) ;
@ Override public FeatureSet featureSet () { return ES8_MODULES ; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
return this . globalScope . getInstanceType ( typeName ) ;
JSType t = getInstanceType ( typeName ) ;
public void testTypeTransformationNoneType () { inFunction ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; verify ( STRING_CONSTANT , JSTypeNative.NO_TYPE ) ; }
{ tmpEnv = collectTypesForFreeVarsFwd ( callee , tmpEnv ) ; }
TypeEnv outEnv = collectTypesForFreeVarsFwd ( expr , inEnv ) ;
TypeEnv exitEnv = getInEnv ( this . cfg . getImplicitReturn () ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
handleGet ( module , scope , n , parent , prefix , Ref.Type.PROTOTYPE_GET ) ;
handleGet ( module , scope , n , parent , name , type ) ;
{ if ( n . isEmpty () && parent . isClassMembers () ) { compiler . reportChangeToEnclosingScope ( n ) ; n . detach () ; } }
NodeTraversal . traverseEs6 ( compiler , root , new RemoveEmptyClassMembers ( compiler ) ) ;
compiler . ensureLibraryInjected ( STRING_CONSTANT + function . toLowerCase ( Locale.US ) , false ) ;
visitForOf ( n , parent ) ;
{ builder . addRetType ( firstNonBottom ( actualRetType , TOP ) ) ; }
for ( ObjectTypeI interfaceType : funType . getAncestorInterfaces () ) { interfaces . add ( interfaceType . toAnnotationString () ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT , record . toAnnotationString () ) ;
assertEquals ( STRING_CONSTANT , record . toAnnotationString () ) ;
checks . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
t . reportCodeChange () ;
if ( n . getChildCount () != NUMBER_CONSTANT ) { return false ; }
Node statementNode = rhsNode . getParent () . getParent () ;
if ( call . getChildCount () != NUMBER_CONSTANT || ! legacyNamespaceNode . isString () ) { t . report ( legacyNamespaceNode , INVALID_GET_NAMESPACE ) ; return; }
if ( call . getChildCount () != NUMBER_CONSTANT || ! namespaceNode . isString () ) { t . report ( namespaceNode , INVALID_FORWARD_DECLARE_NAMESPACE ) ; return; }
grandparent . isStringKey () && NodeUtil . isObjectDefinePropertiesDefinition ( grandparent . getParent () . getParent () )
NodeTraversal . traverseEs6 ( compiler , fnName . getParent () . getParent () , uniquifier ) ;
if ( entry . isObjectLit () ) { checkState ( entryName == STRING_CONSTANT ) ; processBrowserFieldAdvancedUsage ( dirName , entry ) ; }
{ @ Override public boolean apply ( Node n ) { return name . equals ( n . getQualifiedName () ) ; } }
catch ( IllegalArgumentException expected ) { assertTrue ( expected . getMessage () . contains ( STRING_CONSTANT + STRING_CONSTANT ) ) ; }
Node classNode = root . getFirstChild () . getFirstChild () . getFirstChild () ;
Node fNode = root . getFirstChild () . getFirstChild () . getFirstChild () ;
js = renameFunctionDefinition + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
js = renameFunctionDefinition + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
js = renameFunctionDefinition + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
catch ( IllegalStateException e ) { assertEquals ( FixedPointGraphTraversal.NON_HALTING_ERROR_MSG , e . getMessage () ) ; }
{ testSame ( kExterns + extraExterns , source ) ; assertEquals ( expected , noSideEffectCalls ) ; noSideEffectCalls . clear () ; }
Node fNode = root . getFirstChild () . getFirstChild () ;
assertEquals ( null , noInline ) ;
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; reportCodeChange () ; return null ; }
if ( line . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT ) { return line . indexOf ( STRING_CONSTANT ) ; }
checkState ( n . isName () || n . isStringKey () , STRING_CONSTANT , n ) ;
@ Override public FeatureSet featureSet () { return ES8_MODULES ; }
{ checkArgument ( n . isTry () ) ; return n . getChildCount () == NUMBER_CONSTANT ; }
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
{ iterableType = iterable . getTypeI () . toMaybeObjectType () ; typeParam = iterableType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; allowExternsChanges () ; enableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node , parent ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node , parent ) ;
newEmptyClinitMethod = true ;
if ( options . getNewTypeInference () && options . getRunOTIafterNTI () ) { addOldTypeCheckerPasses ( checks , options ) ; }
Renamer renamer = nameStack . peek () ;
{ if ( NodeUtil . isFunctionBlock ( t . getScopeRoot () ) ) { return; } if ( ! t . inGlobalScope () ) { nameStack . pop () ; } }
new PureFunctionIdentifier.Driver ( compiler , null ) . process ( externs , root ) ;
new PureFunctionIdentifier.DriverInJ2cl ( compiler , null ) . process ( externs , root ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( returnType != null ) { builder . append ( CHAR_CONS ) ; returnType . appendTo ( builder , ctx ) ; }
if ( options . getNewTypeInference () && options . getRunOTIafterNTI () && ! options.checksOnly ) { addOldTypeCheckerPasses ( checks , options ) ; }
lit . setJSType ( exportedObjectLit . getJSType () ) ;
disableTypeCheck () ;
disableTypeCheck () ;
{ super . setUp () ; enableNormalize () ; enableTypeCheck () ; }
{ super . setUp () ; allowExternsChanges () ; enableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; enableParseTypeInfo () ; }
disableTypeCheck () ;
{ disableTypeCheck () ; assertExternProperties ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
disableTypeCheck () ;
public void tagAsStrict () { add ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { enableTypeCheck () ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties4 () { enableTypeCheck () ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
enableTypeCheck () ;
{ enableTypeCheck () ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty2 () { enableTypeCheck () ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testConstructorProperty1 () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
enableTypeCheck () ;
v != null || isShadowingDisallowed ( name , s )
if ( options.j2clPassMode . shouldAddJ2clPasses () ) { passes . add ( j2clConstantHoisterPass ) ; passes . add ( j2clOptBundlePass ) ; }
boolean shouldPrintExterns () { return this . printExterns ; }
return new TypeSubject ( THROW_ASSERTION_ERROR , actualPropType ) ;
t . inGlobalScope () && isDeclaration ( n ) && ! n . getBooleanProp ( Node.IS_NAMESPACE ) && ! isWhitelisted ( n )
assertFalse ( NodeUtil . isFunctionDeclaration ( getFunctionNode ( STRING_CONSTANT ) ) ) ;
disableTypeCheck () ;
disableTypeCheck () ;
enableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
enableTypeCheck () ;
checkState ( curNode != null ) ;
boolean isFunctionExpression = ( parent != null ) && NodeUtil . isFunctionExpression ( n ) ;
checkState ( s . isGlobal () || s . isModuleScope () ) ;
checkArgument ( child.parent == null , STRING_CONSTANT , child , parent , this ) ;
passes . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
public void testJSDocCopiedForClasses () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectLiteralMethods () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectLiteralShorthand () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDefaultParameter () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition3 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition2 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition1 () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testArrowFunction () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testNonTopLevelDestructuring () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testYieldExpression () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
{ test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
NodeTraversal . traverseEs6ScopeRoots ( compiler , null , Lists . newArrayList ( fooFunction , barFunction , bazFunction ) , callback , callback , false ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT ) ;
public void testMakeLocalNamesUniqueWithContext10 () { this . useDefaultRenamer = true ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testMakeLocalNamesUniqueWithContext9 () { this . useDefaultRenamer = true ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( NodeUtil . isBleedingFunctionName ( n ) ) { renameBleedingFunctionName ( n ) ; }
{ newNode = IR . assign ( getprop , rhs . cloneNode () ) ; }
{ FunctionType getterType = typeRegistry . createFunctionType ( objectType ) ; codingConvention . applySingletonGetterOld ( functionType , getterType , objectType ) ; }
if ( superCtor != null && subCtor != null ) { codingConvention . applySubclassRelationship ( superCtor , subCtor , relationship.type ) ; }
when ( mockCompiler . compile ( FOO_JS , STRING_CONSTANT ) ) . thenReturn ( new BaseTranspiler.CompileResult ( STRING_CONSTANT , NO_ERRORS , false , STRING_CONSTANT ) ) ;
when ( mockCompiler . compile ( FOO_JS , STRING_CONSTANT ) ) . thenReturn ( new BaseTranspiler.CompileResult ( STRING_CONSTANT , NO_ERRORS , true , STRING_CONSTANT ) ) ;
inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ replacement = replacement . useSourceInfoIfMissingFrom ( node ) ; node . replaceWith ( replacement ) ; reportCodeChange () ; }
{ Node replacement = measuredNodeReplacement . applyTo ( original ) ; reportCodeChange () ; return replacement ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
this . reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
{ maybeBreak . detach () ; reportCodeChange () ; }
reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; reportCodeChange () ; return right ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
{ n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
compileFilesError ( SourceFile.DUPLICATE_ZIP_CONTENTS , zipFile1 , zipFile2 ) ;
if ( options.j2clPassMode . equals ( CompilerOptions.J2clPassMode.AUTO ) ) { checks . add ( j2clSourceFileChecker ) ; }
j2clPassMode = J2clPassMode.OFF ;
checkState ( child.parent == this , STRING_CONSTANT , child , parent ) ;
checkState ( child.parent == this ) ;
assertThat ( result.transpiled ) . isFalse () ;
assertThat ( result.transpiled ) . isTrue () ;
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new Transpiler ( mockCompiler , STRING_CONSTANT ) ; compiler = new Transpiler.CompilerSupplier () ; }
Files . asCharSink ( jsFile , Charsets.UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , Charsets.UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , Charsets.UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , Charsets.UTF_8 ) . write ( code ) ;
{ this . def = def ; this . use = use ; }
if ( ! rewriteState . containsModule ( legacyNamespace ) ) { unrecognizedRequires . add ( new UnrecognizedRequire ( call , legacyNamespace , false ) ) ; }
inFunction ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
AnalyzePrototypeProperties analyzer = new AnalyzePrototypeProperties ( compiler , null , canModifyExterns , anchorUnusedVars ) ;
this . analyzer = new AnalyzePrototypeProperties ( compiler , moduleGraph , canModifyExterns , false ) ;
compilationLevelParsed = COMPILATION_LEVEL_MAP . get ( Ascii . toUpperCase ( compilationLevel ) ) ;
boolean transformed = ! result.transpiledFiles . isEmpty () ;
@ Override public FeatureSet featureSet () { return ES8 ; }
jsDoc != null && jsDoc . isConstant () && jsDoc . getType () == null
newNode . useSourceInfoWithoutLengthIfMissingFromForTree ( sourceInfoNode ) ;
expr . useSourceInfoWithoutLengthIfMissingFromForTree ( parent ) ;
checkState ( n . isFunction () || n . isClass () ) ;
boolean shouldDisambiguateProperties () { return this . disambiguateProperties ; }
boolean shouldInlineProperties () { return inlineProperties ; }
{ return new Es6RewriteClass ( compiler ) ; }
decl . maybeRemoveRhs ( compiler ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.NULLABLE_DEREFERENCE ) ;
typeCheck ( CLOSURE_DEFS + STRING_CONSTANT ) ;
typeCheck ( CLOSURE_BASE + STRING_CONSTANT ) ;
List < Node > replacements
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
if ( hasReferenceName () ) { return sb . append ( getReferenceName () ) ; }
if ( ! isPrettyPrint () || this == registry . getNativeType ( JSTypeNative.FUNCTION_INSTANCE_TYPE ) ) { return sb . append ( STRING_CONSTANT ) ; }
{ checkArgument ( qnameNode . isQualifiedName () ) ; declarations . add ( PotentialDeclaration . from ( qnameNode , scope ) ) ; }
boolean isImport = rhs != null && isImportRhs ( rhs ) ;
this . mode = TypeInferenceMode.OTI_ONLY ;
public void testLoggerOnObject3b () { this . mode = TypeInferenceMode.OTI_ONLY ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
! callClassType . isBottom () && ! callClassType . isUnknownType ()
if ( doSanityChecks && sourceFile != null ) { checkState ( sourceFile . equals ( n . getSourceFileName () ) ) ; }
if ( devMode ) { runSanityCheck () ; if ( hasErrors () ) { return null ; } }
maybeSanityCheck () ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new SanityCheck ( compiler ) ; }
! sanityCheck
{ declarationCheck = ! sanityCheck ; disableCompareAsTree () ; testExternChanges ( extern , input , expectedExtern ) ; }
sanityCheck = true ;
public void testViolatedModuleDependencyNonStrictNotPromoted () { sanityCheck = true ; strictModuleDepErrorLevel = CheckLevel.ERROR ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testMissingModuleDependencySkipNonStrictNotPromoted () { sanityCheck = true ; strictModuleDepErrorLevel = CheckLevel.ERROR ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public void testViolatedModuleDependencySkipNonStrict () { sanityCheck = true ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testMissingModuleDependencySkipNonStrict () { sanityCheck = true ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
sanityCheck = false ;
@ Override public ObjectBuilder prototype () { return prototype ; }
@ Override public ObjectBuilder instance () { return instance ; }
@ Override public ObjectBuilder constructor () { return constructor ; }
convention . applySingletonGetter ( new NominalTypeBuilderNti ( lateProps , rawType ) , getInstanceType ) ;
new FunctionTypeBuilder ( getCommonTypes () ) . addReqFormal ( getCommonTypes () . getNativeType ( U2U_CONSTRUCTOR_TYPE ) )
testSame ( STRING_CONSTANT ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ reportBadGoogBaseUse ( t , n , STRING_CONSTANT ) ; }
{ compiler . report ( JSError . make ( node , INVALID_SUPER_CALL ) ) ; }
if ( initializer != null ) { inferredType = simpleInferExprType ( initializer ) ; }
return bindComponents.thisValue == null ? null : simpleInferExprType ( bindComponents.thisValue ) ;
currentScope . isConstructor ()
JSType rhsType = simpleInferExprType ( rhs ) ;
JSType newPropType = rhs == null ? null : simpleInferExprType ( rhs ) ;
JSType recvType = simpleInferExprType ( recv ) ;
JSType t = initializer == null ? null : simpleInferExprType ( initializer ) ;
if ( initializer != null ) { inferredType = simpleInferExprType ( initializer ) ; }
JSType t = simpleInferExprType ( prop . getFirstChild () ) ;
checkState ( n . isName () , n ) ;
String requireName = require . getSecondChild () . getString () ;
{ this ( compiler , true ) ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT , } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this , true ) ; cjs . process ( null , root ) ; }
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this ) ; cjs . process ( null , root ) ; }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String requireName = ProcessCommonJSModules . getCommonJsImportPath ( require ) ;
{ this . compiler = compiler ; }
if ( STRING_CONSTANT . equals ( type . getDisplayName () ) ) { return true ; }
case REMOVE_RHS :
{ return new ObjectLiteralPropertyDefinition ( parent , n , n . getFirstChild () , isExtern ) ; }
List < Var > orderedVars = new LinkedList <> () ;
List < Var > orderedVars = new LinkedList <> () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT , } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this , true ) ; cjs . process ( null , root ) ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String requireName = require . getSecondChild () . getString () ;
{ this ( compiler , true ) ; }
public void testDontPreserveUnknownTypeDeclarations () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
testWarning ( STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
typeCheck ( LINE_JOINER . join ( FORWARD_DECLARATION_DEFINITIONS , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
checkArgument ( nameNode . isQualifiedName () ) ;
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
options . needsTranspilationFrom ( FeatureSet.ES6_MODULES ) || options.transformAMDToCJSModules || options.processCommonJSModules
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeMinimizeConditions ( late , useTypes ) ) ;
TernaryValue result = evaluateComparison ( n . getToken () , left , right , shouldUseTypes ) ;
Double rightValObj = NodeUtil . getNumberValue ( right , shouldUseTypes ) ;
Double result = NodeUtil . getNumberValue ( n , shouldUseTypes ) ;
new PeepholeMinimizeConditions ( late , false )
new PeepholeMinimizeConditions ( late , false )
caseMatches = PeepholeFoldConstants . evaluateComparison ( Token.SHEQ , cond , caseLabel , false ) ;
new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false ) , new PeepholeFoldConstants ( true , false ) )
new PeepholeMinimizeConditions ( late , useTypesForOptimization )
optimizations . add ( new PeepholeMinimizeConditions ( late , useTypesForOptimization ) ) ;
Node n = parseError ( STRING_CONSTANT , STRING_CONSTANT ) ;
replacement . setJSType ( call . getJSType () ) ;
{ checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ; f1 . isSubtypeOfHelper ( f2 , true , subSuperMap , boxedInfo ) ; }
{ return isSubtypeOfHelper ( other , true , subSuperMap , null ) ; }
public void testCallOrApply ( ) throws Exception { testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = newlineJoin ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false , false ) ; }
void process ( Node externs , Node root , DefinitionUseSiteFinder definitions ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; disableCompareAsTree () ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false ) ; }
void process ( Node externs , Node root , ReferenceMap references ) ;
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testCallOrApply ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
options . setEmitUseStrict ( emitUseStrict ) ;
passes = new LinkedList <> () ;
passes = new LinkedList <> () ;
{ passes = new LinkedList <> () ; addInlineVariables () ; addPeephole () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
passes = new LinkedList <> () ;
passes = new LinkedList <> () ;
passes = new LinkedList <> () ;
{ passes = new LinkedList <> () ; addDeadCodeElimination () ; addInlineVariables () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
passes = new LinkedList <> () ;
{ passes = new LinkedList <> () ; addInlineVariables () ; addPeephole () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ messages = new LinkedList <> () ; mode = JsMessage.Style.LEGACY ; compilerOptions = null ; renameMessages = false ; }
return getTopObject () . getNominalTypeIfSingletonObj () . getPrototypePropertyOfCtor () ;
return superClass == null ? null : superClass . getPrototypePropertyOfCtor () ;
JSType proto = getNominalTypeIfSingletonObj () . getPrototypePropertyOfCtor () ;
checkState ( n . isCall () , n ) ;
catch ( RuntimeException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalArgumentException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
ref.scope . isGlobal ()
try { compiler . compile ( EXTERNS , inputs , options ) ; } catch ( RuntimeException e ) { fail ( STRING_CONSTANT ) ; }
Result result = compiler . compile ( EXTERNS , inputs , options ) ;
Result result = compiler . compile ( EXTERNS , inputs , options ) ;
Result result = compiler . compile ( EXTERNS , inputs , options ) ;
if ( type . contains ( STRING_CONSTANT ) ) { type = type . substring ( NUMBER_CONSTANT , type . lastIndexOf ( STRING_CONSTANT ) ) ; } else { return; }
String shortName = parent . getQualifiedName () . substring ( parent . getQualifiedName () . lastIndexOf ( STRING_CONSTANT ) + NUMBER_CONSTANT ) ;
suffixes . add ( polyfillName . substring ( polyfillName . lastIndexOf ( STRING_CONSTANT ) + NUMBER_CONSTANT ) ) ;
{ return STRING_CONSTANT + cls.target . getQualifiedName () . replaceAll ( STRING_CONSTANT , STRING_CONSTANT ) + STRING_CONSTANT ; }
Map < Node < E > , ImmutableSet.Builder < E > > groupsTmp = Maps . newLinkedHashMap () ;
Map < String , Integer > map = Maps . newHashMap () ;
Iterable < Node > allVars = NodeUtil . getLhsNodesOfDeclaration ( n ) ;
names = NodeUtil . getLhsNodesOfDeclaration ( c ) ;
Preconditions . checkNotNull ( sideEffectInfo , STRING_CONSTANT , function ) ;
if ( NodeUtil . getLhsNodesOfDeclaration ( nameDecl ) . size () > NUMBER_CONSTANT ) { continue; }
ref.scope . isGlobal ()
languageIn = LanguageMode.ECMASCRIPT3 ;
List < Var > orderedVars = new LinkedList <> () ;
List < Node > arrayFoldedChildren = new LinkedList <> () ;
Deque < ScriptDescription > scriptDescriptions = new LinkedList <> () ;
List < Node > newVars = new LinkedList <> () ;
this . orderedVars = new LinkedList <> () ;
this . orderedVars = new LinkedList <> () ;
List < Var > orderedVars = new LinkedList <> () ;
this . orderedVars = new LinkedList <> () ;
languageIn = LanguageMode.ECMASCRIPT_2017 ;
public void testCallOrApply ( ) throws Exception { testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = newlineJoin ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false , false ) ; }
void process ( Node externs , Node root , DefinitionUseSiteFinder definitions ) ;
languageIn = LanguageMode.ECMASCRIPT3 ;
languageIn = LanguageMode.ECMASCRIPT_2017 ;
varify () ;
varify () ;
Node varName
checkLocalityOfMarkedCalls ( source , ImmutableList . < String > of () ) ;
checkLocalityOfMarkedCalls ( source , ImmutableList . < String > of () ) ;
assertFalse ( NodeUtil . evaluatesToLocalValue ( n ) ) ;
languageIn = LanguageMode.ECMASCRIPT3 ;
languageIn = LanguageMode.ECMASCRIPT_2017 ;
return STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + sourceName ;
String fullExportedName = currentScript . getBinaryNamespace () + exportDefinition . getExportPostfix () ;
Node binaryNamespaceName = IR . name ( currentScript . getBinaryNamespace () ) ;
if ( ! currentScript.isModule ) { return; }
if ( ! currentScript.isModule ) { return; }
if ( ! currentScript.isModule ) { return; }
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) ;
checkState ( currentScript.isModule , currentScript ) ;
if ( ! currentScript.isModule || ! n . getString () . equals ( STRING_CONSTANT ) || ! isAssignTarget ( n ) ) { return; }
languageIn = LanguageMode.ECMASCRIPT3 ;
if ( et != null && et . enumLiteralHasKey ( pname ) ) { return et . getEnumeratedType () ; }
{ type = locals . get ( name ) ; }
{ locals . put ( name , newDeclType ) ; }
String fullExportedName = currentScript . getBinaryNamespace () . get () + exportDefinition . getExportPostfix () ;
Node binaryNamespaceName = IR . name ( currentScript . getBinaryNamespace () . get () ) ;
if ( ! currentScript . isModule () ) { return; }
if ( ! currentScript . isModule () ) { return; }
if ( ! currentScript . isModule () ) { return; }
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) . get () ;
checkState ( currentScript . isModule () , currentScript ) ;
if ( ! currentScript . isModule () || ! n . getString () . equals ( STRING_CONSTANT ) || ! isAssignTarget ( n ) ) { return; }
checkState ( n . isName () , n ) ;
finder . visitTree ( getAstRoot ( compiler ) ) ;
{ return STRING_CONSTANT + cls.target . getQualifiedName () . replace ( STRING_CONSTANT , STRING_CONSTANT ) + STRING_CONSTANT ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
checkState ( declNode . isGetProp () ) ;
compilerOptions . setPreserveGoogProvidesAndRequires ( true ) ;
compilerOptions . setPreserveGoogProvidesAndRequires ( true ) ;
keyNode . isStringKey () || keyNode . isMemberFunctionDef ()
Node externsRoot = parse ( compiler , STRING_CONSTANT + STRING_CONSTANT ) ;
Node externsRoot = parse ( compiler , STRING_CONSTANT + STRING_CONSTANT ) ;
{ helperExposeExpression ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; helperExposeExpression ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
JSType toType = symbolTable . getCastType ( expr ) ;
visitNamespacePropertyDeclaration ( getProp , recv , pname ) ;
JSType propDeclType = getDeclaredObjLitProps () . get ( prop ) ;
return this . gti . getCastTypes () . get ( n ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ; return options ; }
js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , js ) ;
String fileoverview = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ testFunctionNamesAndIds ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } ) ; }
{ testFunctionNamesAndIds ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } ) ; }
{ testFunctionNamesAndIds ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , } ) ; }
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSets ( STRING_CONSTANT , js , output , STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEarlyReferenceError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEarlyReferenceError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; assertThat ( getLastCompiler () . injected ) . isEmpty () ; }
Node script = compiler . parseSyntheticCode ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( modules , new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT , STRING_CONSTANT , } ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
{ test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
test ( createModuleChain ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT } )
test ( createModuleStar ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( modules , new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) } ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , VarCheck.UNDEFINED_VAR_ERROR ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ; }
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( DEFAULT_EXTERNS , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { STRING_CONSTANT , STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
String localVar = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
foldSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String body = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ;
String body = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testReference ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , false ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
String legacyScript = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
t . inGlobalHoistScope () && ! NodeUtil . isFunctionExpression ( n )
Preconditions . checkState ( isFunctionExpression ( n ) ) ;
return checkForNewObjects || ! isFunctionExpression ( n ) ;
if ( isEs6ModuleRoot ( root ) ) { return true ; }
testModules ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) )
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler ) ; }
if ( NodeUtil . isFunctionExpression ( parent ) ) { break; }
{ FindStaticMembers findStaticMembers = new FindStaticMembers () ; TranspilationPasses . processTranspile ( compiler , scriptRoot , findStaticMembers ) ; processInherits ( findStaticMembers.inheritsCalls ) ; }
processInherits ( findStaticMembers.inheritsCalls ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertChangesRecorded ( code , new NameChangingCallback () ) ; }
{ String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertChangesRecorded ( code , new NameChangingCallback () ) ; }
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String src = LINE_JOINER . join ( lines ) ;
String src = LINE_JOINER . join ( lines ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
if ( ! fn . isFromExterns () ) { getScopes () . add ( fnScope ) ; }
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.NULLABLE_DEREFERENCE ) ;
node . useSourceInfoWithoutLengthIfMissingFromForTree ( basisNode ) ;
{ return new JSErrorSubject ( THROW_ASSERTION_ERROR , error ) ; }
{ return new NodeSubject ( THROW_ASSERTION_ERROR , node ) ; }
TranspilationPasses . processTranspile ( compiler , scriptRoot , findStaticMembers ) ;
TranspilationPasses . processTranspile ( compiler , externs , this ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this , new SelfReferenceRewriter () ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , this , new SelfReferenceRewriter () ) ; }
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ if ( maybeExternMethod ( first ) ) { return DecompositionType.UNDECOMPOSABLE ; } else { return DecompositionType.DECOMPOSABLE ; } }
checkState ( allowObjectCallDecomposing () , STRING_CONSTANT ) ;
Node var = NodeUtil . newVarNode ( prototypeAlias , null ) . useSourceInfoIfMissingFromForTree ( injectionPoint ) ;
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isLiteralObject () || nt . isBuiltinObject () ; }
boolean isPropertyRemovable ( String propertyName ) { return isEntirelyRemovable || unreferencedPropertiesMayBeRemoved && ! referencedPropertyNames . contains ( propertyName ) ; }
resultPair = analyzeCastFwd ( expr , inEnv , specializedType ) ;
Name superclassNameObj = getOrCreateName ( superclassName , false ) ;
currentArgumentsAccess = new LinkedList <> () ;
List < MemberDefinition > allProperties = new LinkedList <> () ;
List < SourceFile > files = new LinkedList <> () ;
List < SourceFile > files = new LinkedList <> () ;
List < SourceFile > files = new LinkedList <> () ;
List < String > entryPoints = new LinkedList <> () ;
cur = instance.declarations . getLast () . node ;
PrototypeMemberDeclaration first = instance.declarations . getFirst () ;
if ( lValue . isRest () ) { lValue = lValue . getFirstChild () ; }
VarInfo varInfo = getVarInfo ( classScope . getVar ( classNameNode . getString () ) ) ;
{ VarInfo varInfo = getVarInfo ( var ) ; varInfo . addRemovable ( new RemovableBuilder () . buildDestructuringAssign ( c , c ) ) ; }
VarInfo varInfo = getVarInfo ( var ) ;
VarInfo varInfo = getVarInfo ( var ) ;
VarInfo varInfo = getVarInfo ( checkNotNull ( scope . getVar ( nameNode . getString () ) ) ) ;
VarInfo varInfo = getVarInfo ( scope . getVar ( nameNode . getString () ) ) ;
VarInfo exceptionVarInfo = getVarInfo ( scope . getVar ( exceptionNameNode . getString () ) ) ;
{ VarInfo varInfo = getVarInfo ( var ) ; varInfo . addRemovable ( new RemovableBuilder () . buildDestructuringAssign ( restNode , target ) ) ; }
VarInfo classVarInfo = getVarInfo ( classVar ) ;
Preconditions . checkState ( isCallOrNew ( invocation ) ) ;
Scope scope
Preconditions . checkState ( current . isGetProp () , STRING_CONSTANT , current ) ;
Preconditions . checkState ( current . isLabel () ) ;
Preconditions . checkState ( isControlStructure ( parent ) ) ;
Preconditions . checkState ( n . isClassMembers () || n . isObjectLit () ) ;
Preconditions . checkState ( n . isClassMembers () || n . isObjectLit () ) ;
Preconditions . checkArgument ( callNode . isNew () , STRING_CONSTANT , callNode . getToken () ) ;
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
throw new IllegalStateException ( STRING_CONSTANT ) ;
checkState ( ! NodeUtil . isObjectLitKey ( n ) ) ;
boolean isMarkedConst = n . isConst () || ( jsdoc != null && jsdoc . isConstant () ) ;
Queue < Property > propertyQueue = new LinkedList <> ( propertiesSet ) ;
{ if ( n . isFunction () ) { break; } this . ancestors . add ( NUMBER_CONSTANT , n ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; }
assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ;
Var v
Node definitionRValue
JSModule module
JSModule module
DefinitionProvider definitionProvider
if ( defs == null ) { return; }
@ VisibleForTesting Multimap < String , UseSite > getUseSitesByName () { return LinkedHashMultimap . create ( useSitesByName ) ; }
{ if ( inExterns ) { visitExterns ( traversal , node , parent ) ; } else { visitCode ( traversal , node ) ; } }
public void testAnnotationInExterns_new5 ( ) throws Exception { assertPureCallsMarked ( STRING_CONSTANT + STRING_CONSTANT , ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false ) ; }
new RemoveUnusedVars ( compiler , true , false ) . process ( externs , root ) ;
{ new RemoveUnusedVars ( compiler , removeGlobal , preserveFunctionExpressionNames ) . process ( externs , root ) ; }
return new RemoveUnusedVars ( compiler , ! removeOnlyLocals , preserveAnonymousFunctionNames ) ;
{ visitScript ( t , n , parent ) ; }
assertThat ( packageJsonMainEntries ) . containsEntry ( STRING_CONSTANT , NodeModuleResolver.JSC_BROWSER_BLACKLISTED_MARKER ) ;
checkArgument ( fnNode . isFunction () ) ;
LinkedHashMap < String , Node > actualMap = FunctionArgumentInjector . getFunctionCallParameterMap ( fn , call , getNameSupplier () ) ;
public void testFindModifiedParameters12 () { assertThat ( FunctionArgumentInjector . findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters2 () { assertThat ( FunctionArgumentInjector . findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters1 () { assertThat ( FunctionArgumentInjector . findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters0 () { assertThat ( FunctionArgumentInjector . findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
Boolean replaceParent = true ;
tracer = new Tracer ( STRING_CONSTANT ) ;
{ if ( edgeAnnotationStack == null ) { edgeAnnotationStack = new LinkedList <> () ; } pushAnnotations ( edgeAnnotationStack , getEdges () ) ; }
{ if ( nodeAnnotationStack == null ) { nodeAnnotationStack = new LinkedList <> () ; } pushAnnotations ( nodeAnnotationStack , getNodes () ) ; }
if ( LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t . getScope () . getVarCount () ) { return; }
i < LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE + NUMBER_CONSTANT
if ( var . getParentNode () . isParamList () ) { varInfo.propertyAssignmentsWillPreventRemoval = true ; varInfo.unreferencedPropertiesMayBeRemoved = false ; }
exceptionVarInfo . setCannotRemoveAnything () ;
canonicalTotallyUnremovableVarInfo . setCannotRemoveAnything () ;
Set < String > namesToAlias
Set < String > needAliases
LinkedHashMap < String , Node > argMap
return LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE > orderedVars . size () ;
if ( LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE < t . getScope () . getVarCount () ) { return; }
i < LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE + NUMBER_CONSTANT
if ( ! n . isVar () ) { return; }
parent . isVar () && nameNode . hasOneChild ()
removeUnusedProperties && r . isNamedPropertyAssignment () && ! referencedPropertyNames . contains ( r . getPropertyName () )
removeUnusedProperties && removable . isNamedPropertyAssignment () && ! referencedPropertyNames . contains ( removable . getPropertyName () )
! n . isString () && ! isConstantNameNode ( n , knownConstants )
if ( rValue == null || ! rValue . isFunction () || NodeUtil . isVarArgsFunction ( rValue ) ) { return false ; }
if ( NodeUtil . isVarArgsFunction ( fnc ) ) { return false ; }
computeEscapedEs6 ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
computeEscapedEs6 ( jsScope , escaped , compiler , scopeCreator ) ;
computeEscapedEs6 ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
private Scope newScope () { return Scope . createGlobalScope ( new Node ( Token.SCRIPT ) ) ; }
@ Override public void setUp () { allowMethodCallDecomposing = false ; }
{ test ( createCompilerOptions () , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
testModules ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
public void testES6Modules () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testB3473189 () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
BlackHoleErrorManager . silence ( compiler ) ;
String classAndItsMethodAliasedAsExtern = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
String getPropertyName () { checkState ( isNamedPropertyAssignment () ) ; return checkNotNull ( propertyName ) ; }
if ( toRemove . isParamList () ) {} else { throw new IllegalStateException ( STRING_CONSTANT ) ; }
assertTrue ( options.collapseProperties ) ;
assertTrue ( options.collapseProperties ) ;
assertTrue ( options.collapseProperties ) ;
assertTrue ( options.collapseProperties ) ;
@ Override public boolean isApplied ( CompilerOptions options ) { return options.collapseProperties ; }
@ Override public FeatureSet featureSet () { return ES5 ; }
return ! n . getFirstChild () . isVar () ;
public void testNoGlobalSchopeChanges () { testSame ( STRING_CONSTANT ) ; }
return new RemoveUnusedVars ( compiler , ! removeOnlyLocals , preserveAnonymousFunctionNames , false ) ;
( getTypeDeprecationInfo ( t . getTypedScope () . getTypeOfThis () ) != null )
TypedVar var
TypedVar var
@ Override boolean isMethodDeclaration () { return true ; }
boolean isIndependentlyRemovableNamedProperty () { return isPrototypeObjectNamedPropertyAssignment () || isMethodDeclaration () ; }
boolean isMethodDeclaration () { return false ; }
isGlobal && ! removeGlobals && ! removeUnusedProperties
removeUnusedProperties && removable . isNamedProperty ()
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedVars () ) ; }
new RemoveUnusedVars.Builder ( compiler ) . removeGlobals ( true ) . build () . process ( externs , root ) ;
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedCode () ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new RewriteGlobalFunctionStatementsToVarAssignmentsCallback () ) ;
new SimpleDependencyInfo.Builder ( closureRelativePath , filePath ) . setProvides ( provides ) . setRequires ( requires ) . setWeakRequires ( weakRequires ) . setLoadFlags ( loadFlags ) . build ()
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( removeUnusedCode ) ; }
atLeast8 = mode == Mode.ES8_OR_GREATER ;
ImmutableCollection < String > getWeakRequires ( ) ;
Collection < String > getRequires ( ) ;
Collection < String > getProvides ( ) ;
public void testDefaultParam_argIsUnknown () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testDefaultParam_argIsUndefined () { test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void disabled_testArrayPatternParam () { testSame ( STRING_CONSTANT ) ; }
visitParamList ( t , n , parent ) ;
Annotation annotation = annotationNames . get ( annotationName ) ;
config.languageMode != LanguageMode.TYPESCRIPT
if ( config.languageMode == LanguageMode.ECMASCRIPT3 ) { errorReporter . error ( SETTER_ERROR_MESSAGE , sourceName , lineno ( node ) , NUMBER_CONSTANT ) ; return true ; }
if ( config.languageMode == LanguageMode.ECMASCRIPT3 ) { errorReporter . error ( GETTER_ERROR_MESSAGE , sourceName , lineno ( node ) , NUMBER_CONSTANT ) ; return true ; }
if ( config.languageMode == LanguageMode.ECMASCRIPT3 ) { errorReporter . warning ( INVALID_ES3_PROP_NAME , sourceName , node . getLineno () , node . getCharno () ) ; }
{ checkState ( config.keepGoing == Config.RunMode.KEEP_GOING ) ; bodyNode = IR . block () ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . build () ; }
if ( options.removeUnusedPrototypeProperties ) { passes . add ( removeUnusedPrototypeProperties ) ; }
CollapseProperties collapseProperties = new CollapseProperties ( compiler ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new CollapseProperties ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CollapseProperties ( compiler ) ; }
options . setCollapseProperties ( true ) ;
@ Override public void apply ( CompilerOptions options , boolean value ) { options . setCollapseProperties ( value ) ; }
if ( p != null && ! p . canCollapse () ) { continue; }
if ( ! canCollapseChildNames || ! n . canCollapse () ) { return; }
if ( ! canCollapseChildNames || ! n . canCollapse () ) { return; }
isObjLit && n . canEliminate ()
isObjLit && n . canEliminate ()
if ( n . canCollapse () ) { updateGlobalNameDeclaration ( n , alias , canCollapseChildNames ) ; }
new CollapseProperties ( compiler ) . process ( externs , js ) ;
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new CollapseProperties ( compiler ) ; }
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
collapseProperties = false ;
{ return new RemoveUnusedCode.Builder ( compiler ) . removeLocalVars ( true ) . build () ; }
if ( parent . isVar () || parent . isFunction () ) { return true ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . build () ; }
if ( options.removeUnusedPrototypeProperties ) { passes . add ( removeUnusedPrototypeProperties ) ; }
{ options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ; }
for ( String filename : files ) { if ( fix ) { fix ( filename ) ; } else { lint ( filename ) ; } }
passes . add ( extraSmartNamePass ) ;
String qualifiedName = aliasVar . getInitialValue () . getQualifiedName () ;
String aliasExpanded = checkNotNull ( aliasDefinition . getQualifiedName () ) ;
allowGlobalFunctionInlining = false ;
public void testLocalFunctionInliningOnly4 () { this . allowGlobalFunctionInlining = false ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalFunctionInliningOnly3 () { this . allowGlobalFunctionInlining = false ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalFunctionInliningOnly2 () { this . allowGlobalFunctionInlining = false ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
allowGlobalFunctionInlining = true ;
{ options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_NEXT ) ; options . setLanguageOut ( value ? CompilerOptions.LanguageMode.ECMASCRIPT5 : CompilerOptions.LanguageMode.NO_TRANSPILE ) ; }
addToDebugLog ( STRING_CONSTANT + file . getName () ) ;
checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
Node superClassNameNode = NodeUtil . newQName ( compiler , superClassString ) . useSourceInfoIfMissingFrom ( metadata.superClassNameNode ) ;
VarInfo varInfo = traverseVar ( classScope . getVar ( classNameNode . getString () ) ) ;
VarInfo varInfo = traverseVar ( scope . getVar ( classNameNode . getString () ) ) ;
VarInfo varInfo = traverseVar ( checkNotNull ( scope . getVar ( nameNode . getString () ) ) ) ;
VarInfo varInfo = traverseVar ( scope . getVar ( nameNode . getString () ) ) ;
VarInfo exceptionVarInfo = traverseVar ( scope . getVar ( exceptionNameNode . getString () ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
public void testIssue618_2 () { this . removeGlobal = false ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
rhs == null || isTypedRhs ( rhs ) || NodeUtil . isCallTo ( rhs , STRING_CONSTANT ) || isImportRhs ( rhs )
public Iterable < Symbol > getAllSymbols () { return Collections . unmodifiableCollection ( symbols . values () ) ; }
foldSame ( STRING_CONSTANT ) ;
if ( node . isStringKey () && ! node . hasChildren () ) { t . report ( node , SHORTHAND_ASSIGNMENT_IN_ENUM ) ; }
if ( parent . isObjectPattern () ) { return ! ( n . isStringKey () && n . hasChildren () ) ; }
{ validateObjectLitStringKey ( c ) ; }
passes . add ( removeUnusedCodeOnce ) ;
options . setInlineFunctions ( false ) ;
options . setInlineFunctions ( true ) ;
options . setInlineFunctions ( true ) ;
options . setInlineFunctions ( true ) ;
{ this . inlineFunctions = inlineFunctions ; }
Iterables . addAll ( allSymbols , table . getAllSymbols () ) ;
boolean isIndependentlyRemovableNamedProperty () { return isPrototypeObjectNamedPropertyAssignment () || isClassOrPrototypeNamedProperty () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; }
if ( isClassMemberFunction ( functionNode ) ) { return STRING_CONSTANT . equals ( functionNode . getParent () . getString () ) ; }
{ if ( isImport ) { currentFile . recordImport ( name . getString () ) ; } else { currentFile . recordDeclaration ( name , t . getScope () ) ; } }
String name = ConvertToTypedInterface . getPrototypeNameOfMethod ( functionNode ) ;
if ( isConstructor ( n ) && n . getLastChild () . hasChildren () ) { currentFile . markConstructorToProcess ( n ) ; }
newJsdoc == null && isThisProp ( nameNode )
if ( isClassMethod ( n ) ) { currentFile . recordMethod ( n , t . getScope () ) ; }
! isConstructor ( n )
{ if ( isTypeCompatible ( receiverType , method.type ) ) { unusedMethodPolyfills . remove ( method ) ; } }
checkArgument ( functionNode . isFunction () ) ;
private boolean isAssignmentToPrototype ( Node n ) { return n . isAssign () && isPrototypeGetProp ( n . getFirstChild () ) ; }
long nodeCount = graph . getNodes () . size () ;
checkState ( n . isName () || n . isStringKey () || n . isImportStar () , STRING_CONSTANT , n ) ;
if ( NodeUtil . isAssignmentTarget ( n ) ) { return n ; }
if ( NodeUtil . isAssignmentTarget ( n ) ) { return n ; }
if ( NodeUtil . isAssignmentTarget ( n ) ) { return n ; }
boolean isPrototypeProperty () { return isPrototypeObjectNamedPropertyAssignment () || isClassOrPrototypeNamedProperty () ; }
removeUnusedThisProperties && removable . isThisNamedPropertyAssignment ()
RemovableBuilder builder = new RemovableBuilder () . setIsThisNamedPropertyAssignment ( true ) ;
{ fsCalled . setRemove ( false ) ; if ( ! minimizeCost ( fsCalled ) ) { fsCalled . setInline ( false ) ; } }
{ Node rootNode = scopeRoots . get ( i - NUMBER_CONSTANT ) ; if ( Scope . isHoistScopeRootNode ( rootNode ) ) { return rootNode ; } }
public boolean isHoistScope () { return Scope . isHoistScopeRootNode ( getScopeRoot () ) ; }
checkState ( ( NodeUtil . isNameDeclaration ( parent ) && var.scope . isGlobal () ) || NodeUtil . isFunctionDeclaration ( parent ) ) ;
if ( aliasVar != null ) { return aliasVar.scope . isGlobal () ; }
Node name = importSpec . getFirstChild () ;
validateChildCountIn ( n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
validateChildCountIn ( n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Builder removeUnusedConstructorProperties ( boolean value ) { this . removeUnusedConstructorProperties = value ; return this ; }
this . removeUnusedConstructorProperties = builder.removeUnusedConstructorProperties ;
test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
Scope s = getScope () ;
checkState ( name != null && ! name . isEmpty () ) ;
String name = ClassUtil . getPrototypeNameOfMethod ( functionNode ) ;
NodeUtil . deleteNode ( getStatement () , compiler ) ;
Node oldStatement = getStatement () ;
Node getStatement () { return NodeUtil . getEnclosingStatement ( lhs ) ; }
@ Override public boolean hasReferenceName () { return referencedObjType == null ? null : referencedObjType . hasReferenceName () ; }
passes . add ( extraSmartNamePass ) ;
testModules ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
if ( NodeUtil . mayHaveSideEffects ( objExpression ) ) { replaceExpressionWith ( incOrDecNode , objExpression . detach () ) ; } else { removeExpressionCompletely ( incOrDecNode ) ; }
if ( NodeUtil . mayHaveSideEffects ( objExpression ) ) { replaceExpressionWith ( referenceNode , objExpression . detach () ) ; } else { removeExpressionCompletely ( referenceNode ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
Arguments ( Scope scope ) { super ( STRING_CONSTANT , null , scope , - NUMBER_CONSTANT , null ) ; }
@ Override public TypedScope getScope ( TypedVar var ) { return var.scope ; }
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
{ scope . declare ( name , n , input ) ; }
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Scope s
private void pushScope ( Scope s ) { pushScope ( s , false ) ; }
Scope refinedScope
Scope scope
Scope s
Scope hoistedScope = t . getClosestHoistScope () ;
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Var var = new Var ( name , nameNode , this , vars . size () , input ) ;
Scope parent
ScopeCreator scopeCreator = createScopeCreator () ;
Scope parent
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ return new FeatureSet ( Sets . union ( features , other.features ) ) ; }
public FeatureSet withoutTypes () { return new FeatureSet ( Sets . difference ( features , LangVersion.TYPESCRIPT . features () ) ) ; }
private FeatureSet ( Set < Feature > features ) { this . features = ImmutableSet . copyOf ( features ) ; }
{ test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
! scope . isDeclared ( name , false ) && ! ( scope . isLocal () && name . equals ( ARGUMENTS ) )
if ( STRING_CONSTANT . equals ( name ) && NodeUtil . isVanillaFunction ( scope . getRootNode () ) ) { return scope . getArgumentsVar () ; }
public S getScope () { return scope ; }
if ( ! isFunctionScope () || rootNode . isArrowFunction () ) { return parent . getArgumentsVar () ; }
@ Override public TypedScope getScope ( TypedVar var ) { return ( TypedScope ) var.scope ; }
optimizations . add ( new MinimizeExitPoints ( compiler ) ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , null , template ) ;
assertChanges ( externs , originalCode , null , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( STRING_CONSTANT , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( STRING_CONSTANT , originalCode , expectedCode , template ) ;
checkNotNull ( funType ) ;
if ( ProcessCommonJSModules . isCommonJsImport ( n ) ) { visitRequireCall ( t , n , parent ) ; }
this . moduleLoader = new ModuleLoader ( null , options.moduleRoots , inputs , ModuleLoader.PathResolver.RELATIVE , options.moduleResolutionMode , null ) ;
options . setModuleResolutionMode ( ModuleLoader.ResolutionMode.NODE ) ;
public JsonFileSpec ( String src , String path ) { this ( src , path , null ) ; }
if ( var . getParentNode () . isParamList () ) { varInfo.propertyAssignmentsWillPreventRemoval = true ; }
catch ( RuntimeException e ) { fail ( STRING_CONSTANT ) ; }
@ Override public boolean preventsRemovalOfVariableWithNonLocalOrNonLiteralValueOrPrototype () { return true ; }
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testNewOperatior3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNewOperatior2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNewOperatior1 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
return getLeastSupertype ( this , that ) ;
checkState ( n . hasOneChild () ) ;
Node newDeclaration = IR . declaration ( lhsToSplit . detach () , rhs , n . getToken () ) . srcref ( n ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
Map < String , TypeI > props = new HashMap <> () ;
checkState ( mayBeStatement ( stmt ) ) ;
NameDeclarationStatement removable = builder . setAssignedValue ( valueNode ) . buildNameDeclarationStatement ( declarationStatement ) ;
( parent . isForIn () )
if ( grandparent != null && grandparent . isVar () ) { return false ; }
public void testLoggerMethodCallByVariableType () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
ParseTree right = parseUnaryExpression () ;
return findModifiedParameters ( fnNode . getLastChild () , null , names , unsafeNames , false ) ;
public void testDirectPrototypeAssignment2 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testPropertyInference6 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getErrorManager () . report ( CheckLevel.ERROR , JSError . make ( AbstractCompiler.READ_ERROR , getName () ) ) ; return SimpleDependencyInfo.EMPTY ; }
catch ( IOException e ) { compiler . report ( JSError . make ( AbstractCompiler.READ_ERROR , sourceFile . getName () ) ) ; }
boolean allowDupe = VarCheck . hasDuplicateDeclarationSuppression ( referenceNode , v ) ;
{ testClosureTypesMultipleWarnings ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , ImmutableList . of ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ) ; }
public void testMissingProperty30 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
TemplateAstMatcher astMatcher = new TemplateAstMatcher ( compiler . getTypeIRegistry () , templateRoot , TypeMatchingStrategy.LOOSE ) ;
return fnThisType . isUnknownType () ? null : fnThisType . toObjectType () ;
IR . string ( modulePath . toString () )
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new CheckMissingSuper ( compiler ) ; }
checks . add ( checkMissingSuper ) ;
passes . add ( checkMissingSuper ) ;
{ visitInterfaceGetprop ( t , assign , object , pname , lvalue , rvalue ) ; }
visitGetProp ( t , n , parent ) ;
checkArgument ( scriptNode . isScript () ) ;
{ Node enclosingNode = NodeUtil . getEnclosingNode ( n , loopPredicate ) ; return enclosingNode != null && ! enclosingNode . isFunction () ; }
{ return new Es6RewriteClass ( compiler , ! compiler . getOptions () . inIncrementalCheckMode () ) ; }
assertTypeEquals ( typeRegistry . getNativeType ( JSTypeNative.BOOLEAN_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
suppressors . put ( STRING_CONSTANT , new DiagnosticGroupWarningsGuard ( new DiagnosticGroup ( DiagnosticGroups.CHECK_TYPES , DiagnosticGroups.STRICT_MISSING_PROPERTIES ) , CheckLevel.OFF ) ) ;
if ( ! rewriteState . containsModule ( legacyNamespace ) ) { unrecognizedRequires . add ( new UnrecognizedRequire ( call , legacyNamespace , false , false ) ) ; }
public boolean inIncrementalCheckMode () { return incrementalCheckMode != IncrementalCheckMode.OFF ; }
Node originalFunction = functionContext.function . get () ;
{ for ( PotentialDeclaration decl : currentFile . getDeclarations () . get ( name ) ) { processDeclaration ( decl ) ; } }
if ( getRhs () == null ) { return; }
if ( ! isConstToBeInferred ( originalJsdoc , nameNode ) ) { return; }
boolean isImport = isImportRhs ( rhs ) ;
lhsToSplit . isDestructuringLhs () && ! isImportRhs ( lhsToSplit . getLastChild () )
isConstToBeInferred ( jsdoc , nameNode ) && ! nameNode . isFromExterns () && ! JsdocUtil . isPrivate ( jsdoc )
jsdoc == null || ! jsdoc . containsDeclaration () || ConvertToTypedInterface . isConstToBeInferred ( jsdoc , jsdocNode )
checkState ( caseBody . isNormalBlock () ) ;
checkState ( first . getString () . isEmpty () ) ;
public void testIssue2508576_1 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testClassExtern () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testObjectLitExtern2 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testObjectLitExtern1 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
testSame ( CompilerTypeTestCase.DEFAULT_EXTERNS , STRING_CONSTANT ) ;
testSame ( SHARED_EXTERNS , js ) ;
testSame ( externs , STRING_CONSTANT ) ;
testSame ( externs , js ) ;
testSame ( externs , js ) ;
testSame ( externs , js ) ;
testSame ( METHOD_DEFS , STRING_CONSTANT ) ;
testSame ( externs , code ) ;
testSame ( externs , code ) ;
{ testSame ( externs , source ) ; assertEquals ( expected , found ) ; found . clear () ; }
tester . testSame ( STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( ALL_NATIVE_EXTERN_TYPES , STRING_CONSTANT ) ;
testSame ( externs , STRING_CONSTANT ) ;
testSame ( externs , js ) ;
testSame ( externs , code ) ;
testSame ( EXTERNS , STRING_CONSTANT ) ;
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String externs = DEFAULT_EXTERNS . replace ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Map < String , StaticTypedSlot < JSType > > slots = new LinkedHashMap <> () ;
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil.isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil.isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil.isNameDeclaration ) ;
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil : : isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil : : isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil : : isNameDeclaration ) ;
add ( first . getNext () ) ;
public void testFindExpressionRoot5 () { assertThat ( findExpressionRoot ( STRING_CONSTANT , STRING_CONSTANT ) ) . isNull () ; }
{ return null ; }
{ return ! isStringifiable ( templatizedType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ) ; }
if ( that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; } else { return FALSE ; }
{ registerMismatchAndReport ( n , INVALID_OPERAND_TYPE , msg , type , getNativeType ( NUMBER_TYPE ) , null , null ) ; }
this . allValueTypes = typeRegistry . createUnionType ( STRING_TYPE , NUMBER_TYPE , BOOLEAN_TYPE , NULL_TYPE , VOID_TYPE ) ;
allDeps . addAll ( input . getRequires () ) ;
writeJsArray ( out , info . getRequires () ) ;
ImmutableList < String > getRequires ( ) ;
{ input . addOrderedRequire ( require ) ; }
public abstract Builder setRequires ( Collection < String > requires ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( STRING_CONSTANT ) )
ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT )
String require
requires . addAll ( deps . getRequires () ) ;
for ( String require : dependency . getRequires () ) { addDependency ( require , seen , list ) ; }
public void testGithubIssue2818 () { noInline ( STRING_CONSTANT ) ; noInline ( STRING_CONSTANT ) ; inline ( STRING_CONSTANT , STRING_CONSTANT ) ; }
testError ( srcs ( js ) , error ( BAD_PRIVATE_PROPERTY_ACCESS , STRING_CONSTANT ) ) ;
error ( BAD_PRIVATE_PROPERTY_ACCESS , STRING_CONSTANT )
error ( BAD_PRIVATE_PROPERTY_ACCESS , STRING_CONSTANT )
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_FOR_GOOG_SCOPE , warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_WARNING , warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_WARNING , warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_STRICT_WARNING , warningText ) ) ; }
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR , message ) ) ;
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR , message ) ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , expected ( expected ) , warning ( warning , description ) ) ;
test ( externs ( externs ) , srcs ( STRING_CONSTANT ) , expected ( STRING_CONSTANT ) , warning ( e , STRING_CONSTANT + STRING_CONSTANT ) ) ;
{ assertNotNull ( warning ) ; test ( externs ( externs ) , srcs ( js ) , warning ( warning , description ) ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( inputs ) , warning ( warning , description ) ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( js ) , warning ( warning , description ) ) ; }
{ assertNotNull ( error ) ; test ( srcs ( inputs ) , error ( error , description ) ) ; }
{ assertNotNull ( error ) ; test ( srcs ( js ) , error ( error , description ) ) ; }
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
public abstract Builder setRequires ( Collection < Require > requires ) ;
public void addRequire ( Require require ) { extraRequires . add ( require ) ; }
Require require
allDeps . addAll ( input . getRequiredSymbols () ) ;
requires . addAll ( deps . getRequiredSymbols () ) ;
for ( String require : dependency . getRequiredSymbols () ) { addDependency ( require , seen , list ) ; }
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) ) )
writeJsArray ( out , Require . asSymbolList ( info . getRequires () ) ) ;
ImmutableList < Require > getRequires ( ) ;
{ input . addOrderedRequire ( Require . compilerModule ( require ) ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
n . putBooleanProp ( Node.GOOG_MODULE_ALIAS , true ) ;
TranspilationPasses . addEs6ModulePass ( factories ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler ) ; }
inline ( STRING_CONSTANT , STRING_CONSTANT ) ;
inline ( STRING_CONSTANT , STRING_CONSTANT ) ;
for ( TemplateType ignore : obj . getTemplateTypeMap () . getTemplateKeys () ) { unknowns . add ( getNativeType ( UNKNOWN_TYPE ) ) ; }
public void testIssue70b () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.ES6_FEATURE ) ; }
public void testIssue70a () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.ES6_FEATURE ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
rewriteGeneratorBody ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( node . hasChildren () && node . getLastChild () . isString () ) { info.importedModules . add ( node . getLastChild () . getString () ) ; }
MemoizedTypedScopeCreator typedScopeCreator = getTypedScopeCreator () ;
scopeCreator = new MemoizedTypedScopeCreator ( new TypedScopeCreator ( compiler ) ) ;
MemoizedTypedScopeCreator scopeCreator
MemoizedTypedScopeCreator getTypedScopeCreator () { return typedScopeCreator ; }
MemoizedTypedScopeCreator scopeCreator
public abstract Builder setRequires ( Collection < String > requires ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( STRING_CONSTANT ) )
ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT )
requires . addAll ( deps . getRequires () ) ;
for ( String require : dependency . getRequires () ) { addDependency ( require , seen , list ) ; }
writeJsArray ( out , info . getRequires () ) ;
ImmutableList < String > getRequires ( ) ;
public void addRequire ( String require ) { extraRequires . add ( require ) ; }
String require
{ input . addOrderedRequire ( require ) ; }
allDeps . addAll ( input . getRequires () ) ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives || this . shouldGenerateTypedExterns () ; }
inline ( lines ( STRING_CONSTANT ) , lines ( STRING_CONSTANT ) ) ;
public void testNoInlineGetEle () { noInline ( STRING_CONSTANT ) ; }
public void testNoInlineGetProp () { noInline ( STRING_CONSTANT ) ; }
@ Override public StaticTypedScope < JSType > getParentScope () { return getFunctionScope () . getParentScope () ; }
Scope usageScope
List < String > provides = Lists . newArrayList ( depInfo . getProvides () ) ;
this . nullOrUndefined = typeRegistry . createUnionType ( NULL_TYPE , VOID_TYPE ) ;
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
rewriteGeneratorBodyWithVars ( STRING_CONSTANT , STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
context . writeGeneratedNode ( IR . ifNode ( condition , context . createJumpToBlock ( startCase , n ) ) . useSourceInfoFrom ( n ) ) ;
IR . ifNode ( IR . not ( condition ) . useSourceInfoFrom ( condition ) , context . createJumpToBlock ( endCase , n ) ) . useSourceInfoFrom ( n )
IR . ifNode ( IR . not ( condition ) . useSourceInfoFrom ( condition ) , context . createJumpToBlock ( endCase , n ) ) . useSourceInfoFrom ( n )
if ( options . needsTranspilationFrom ( ES_NEXT ) ) { TranspilationPasses . addEs2018Passes ( passes ) ; passes . add ( setFeatureSet ( ES8 ) ) ; }
parseWarning ( STRING_CONSTANT , getRequiresEsNextMessage ( Feature.OBJECT_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEsNextMessage ( Feature.OBJECT_PATTERN_REST ) ) ;
if ( options . needsTranspilationFrom ( ES_NEXT ) ) { TranspilationPasses . addEs2018Passes ( checks ) ; checks . add ( setFeatureSet ( ES8 ) ) ; }
return rhs . isQualifiedName () || NodeUtil . isCallTo ( rhs , STRING_CONSTANT ) ;
if ( replacements . isEmpty () ) { return STRING_CONSTANT ; }
allJsDocParams = ( info == null ) ? new HashSet < String > () : new HashSet <> ( info . getParameterNames () )
JSType type = typeRegistry . getType ( dottedName ) ;
JSType type = compiler . getTypeIRegistry () . getType ( STRING_CONSTANT ) ;
{ return metadata . getCompiler () . getTypeRegistry () . getType ( type ) ; }
TypeI mathType = compiler . getTypeIRegistry () . getType ( STRING_CONSTANT ) ;
{ return registry . getType ( typeName ) ; }
domHelperType = compiler . getTypeIRegistry () . getType ( STRING_CONSTANT ) ;
{ super ( compiler , requirement ) ; errorObjType = compiler . getTypeIRegistry () . getType ( STRING_CONSTANT ) ; }
TypeI methodClassType = registry . getType ( r.type ) ;
TypeI typeWithBannedProp = registry . getType ( prop.type ) ;
{ TypeI type = registry . getType ( typeName ) ; if ( type != null ) { types . add ( type ) ; } }
TypeI methodClassType = registry . getType ( className ) ;
Scope scope = t . getScope () ;
TranspilationPasses . addEs6Passes ( passes ) ;
ImmutableList.Builder < Callback > callbacks = ImmutableList . < Callback > builder () ;
parent . isAssign () && parent . getFirstChild () == getProp && parent . getFirstChild () . getLastChild () . getString () . equals ( STRING_CONSTANT )
parent . isAssign () && parent . getFirstChild () == getProp && getProp . getLastChild () . getString () . equals ( STRING_CONSTANT )
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil.isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil.isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil.isNameDeclaration ) ;
StreamSupport . stream ( fixChoices . spliterator () , false ) . map ( choices - > choices . getAlternatives () . get ( choiceIndex ) )
StreamSupport . stream ( fixChoices . spliterator () , false ) . map ( f - > f . getAlternatives () . size () )
newVar = scopeToDeclareIn . declare ( variableName , n , type , input , inferred ) ;
if ( Keywords . isKeyword ( importedName.value ) ) { reportError ( importedName , STRING_CONSTANT , importedName.value ) ; }
if ( Keywords . isKeyword ( importedName.value ) ) { reportExpectedError ( null , PredefinedName.AS ) ; }
this . scanner = new Scanner ( errorReporter , commentRecorder , source , offset ) ;
testNotEs6Typed ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testNotEs6Typed ( STRING_CONSTANT , STRING_CONSTANT ) ;
testNotEs6Typed ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ parse ( STRING_CONSTANT ) ; expectErrors ( STRING_CONSTANT ) ; parse ( STRING_CONSTANT ) ; testNotEs6Typed ( STRING_CONSTANT , STRING_CONSTANT ) ; }
checkState ( nameNode . isName () ) ;
for ( Case currentCase : allCases ) { switchNode . addChildToBack ( currentCase.caseNode ) ; }
{ currentCase.embedInto . replaceWith ( currentCase.caseBlock . detach () ) ; it . remove () ; continue; }
this . context = new TranspilationContext ( originalGeneratorBody ) ;
ImmutableSortedSet . copyOf ( ENTRY_COMPARATOR , map . entrySet () )
this . modulePaths = resolvePaths ( Iterables . transform ( Iterables . transform ( inputs , UNWRAP_DEPENDENCY_INFO ) , pathResolver ) , moduleRootPaths ) ;
{ this . cache = builder . build ( CacheLoader . from ( source - > delegate . transform ( source ) ) ) ; }
{ return x - > transform ( x ) ; }
{ return x - > function . apply ( x ) ; }
return NodeUtil . has ( node , pred , Predicates . < Node > alwaysTrue () ) ;
{ this ( compiler , behavior , creator , Predicates . < Var > alwaysTrue () ) ; }
return NodeUtil . has ( callNode , hasSpreadCallArgumentPredicate , Predicates . < Node > alwaysTrue () ) ;
return ! referencesArguments && ! NodeUtil . has ( block , p , Predicates . < Node > alwaysTrue () ) ;
return result == null ? ImmutableList . < Symbol > of () : ImmutableList . of ( result ) ;
for ( Node typeNode : info . getTypeNodes () ) { NodeUtil . visitPreOrder ( typeNode , fixJsdocTypeNodes , Predicates . < Node > alwaysTrue () ) ; }
{ maybeAddUsage ( t , n , typeNode , false , Predicates . < Node > alwaysTrue () ) ; }
List < Ref > getRefs () { return refs == null ? ImmutableList . < Ref > of () : refs ; }
{ return chars == null ? ImmutableSet . < Character > of () : ImmutableSet . copyOf ( Chars . asList ( chars ) ) ; }
reserved = previousMap != null ? previousMap . getNewNameToOriginalNameMap () . keySet () : Collections . < String > emptySet ()
return invocation . hasOneChild () ? ImmutableList . < Node > of () : invocation . getSecondChild () . siblings () ;
{ return getCount ( node , new MatchNameNode ( name ) , Predicates . < Node > alwaysTrue () ) ; }
Arrays . sort ( arr , Ordering . < String > natural () ) ;
for ( Node typeNode : info . getTypeNodes () ) { NodeUtil . visitPreOrder ( typeNode , replaceJsDocRefs , Predicates . < Node > alwaysTrue () ) ; }
invalidations = FluentIterable . from ( invalidationMap . get ( t ) ) . transform ( Suppliers . < JSError > supplierFunction () ) . limit ( MAX_INVALIDATION_WARNINGS_PER_PROPERTY )
this . invalidationMap = propertiesToErrorFor . isEmpty () ? null : LinkedHashMultimap . < TypeI , Supplier < JSError > > create () ;
return new JSTypeExpression ( typeNode , PolymerPass.VIRTUAL_FILE ) ;
JSType type = compiler . getTypeRegistry () . getType ( STRING_CONSTANT ) ;
TypeI type = registry . getType ( target . getFirstFirstChild () . getQualifiedName () ) ;
{ final JSType voidType = compiler . getTypeIRegistry () . getNativeType ( JSTypeNative.VOID_TYPE ) ; return voidType . isSubtype ( returnType ) ; }
{ return isTheObjectType () || isStringObjectType () || isDateType () || isRegexpType () || isArrayType () || isNumberObjectType () || isBooleanObjectType () || hasOverridenNativeProperty ( STRING_CONSTANT ) ; }
@ Override public boolean matchesNumberContext () { return isNumberObjectType () || isDateType () || isBooleanObjectType () || isStringObjectType () || hasOverridenNativeProperty ( STRING_CONSTANT ) ; }
TypeI type = compiler . getTypeIRegistry () . getType ( typeName ) ;
public void testMissingProperty33 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty22 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty21 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty18 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty15 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty12 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty11 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty10 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty9 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
JSTypeExpression expr = new JSTypeExpression ( getCallArgument ( ttlAst , NUMBER_CONSTANT ) , STRING_CONSTANT ) ;
compiler . getOptions () . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES6 )
if ( options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES6 ) ) { passes . add ( optimizeToEs6 ) ; }
if ( options.dartPass && ! options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
{ CompilerOptions options = super . getDefaultOptions () ; options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ; options . setLanguageOut ( LanguageMode.ECMASCRIPT5 ) ; return options ; }
{ if ( pos >= js . length () ) { return null ; } else { return js . substring ( pos , js . length () ) ; } }
if ( node . isQuotedString () || node . getFirstChild () == null ) { return; }
Collections . sort ( declList , DECLARATIONS_FIRST ) ;
{ JSType newType = objType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ; redeclareSimpleVar ( informed , item , newType ) ; }
@ Override JSType resolveInternal ( ErrorReporter t , StaticTypedScope < JSType > scope ) { return this ; }
@ Override JSType resolveInternal ( ErrorReporter t , StaticTypedScope < JSType > scope ) { return this ; }
abstract JSType resolveInternal ( ErrorReporter t , StaticTypedScope < JSType > scope ) ;
ErrorReporter t
@ Override JSType resolveInternal ( ErrorReporter t , StaticTypedScope < JSType > scope ) { return this ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModulesToCommonJsModules ( compiler ) ; }
private String transpileEs6Module ( String s ) { return transpile ( transpile ( s , es6ModuleTranspiler ) ) ; }
if ( that . isUnknownType () || that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; }
if ( t . isUnknownType () || t . isNoResolvedType () || ! t . isSubtype ( type ) ) { restricted . addAlternate ( t ) ; }
if ( ! alternate . isUnknownType () && that . isSubtype ( alternate ) ) { return this ; }
if ( isStructural && ! thisUnresolved && ! thatUnresolved ) { return rightType . isSubtype ( leftType ) ; } else { return rightType . isSubtypeWithoutStructuralTyping ( leftType ) ; }
{ return type . isSubtype ( getNativeType ( ARRAY_TYPE ) ) ? null : type ; }
if ( resultEqualsValue ) { return ctorType . getGreatestSubtype ( type ) ; } else { return type . isSubtype ( ctorType ) ? null : type ; }
assertTrue ( x . isSubtype ( windowCtor . getInstanceType () ) ) ;
assertTrue ( x . isSubtype ( windowCtor . getInstanceType () ) ) ;
assertTrue ( y . isSubtype ( getNativeType ( STRING_TYPE ) ) ) ;
{ if ( this . isSubtype ( rawThat ) ) { return this ; } else if ( rawThat . isSubtype ( this ) ) { return filterNoResolvedType ( rawThat ) ; } }
assertTrue ( unknown . isSubtype ( STRING_TYPE ) ) ;
assertTrue ( NULL_TYPE . isSubtype ( nullOrUnknown ) ) ;
! argType . isSubtype ( paramType )
! rightType . isSubtype ( leftType )
! leftType . isNoType () && ! rightType . isSubtype ( leftType )
! switchType . canTestForShallowEqualityWith ( caseType ) && ( caseType . autoboxesTo () == null || ! caseType . autoboxesTo () . isSubtype ( switchType ) )
! type . isNoType () && ! type . isUnknownType () && type . isSubtype ( nullOrUndefined ) && ! containsForwardDeclaredUnresolvedName ( type )
! type . isSubtype ( getNativeType ( NUMBER_STRING_SYMBOL ) )
! type . isSubtype ( getNativeType ( NUMBER_STRING ) )
! type . matchesNumberContext () && ! type . isSubtype ( allBitwisableValueTypes )
! type . isSubtype ( getNativeType ( NUMBER_TYPE ) )
if ( ! anyObjectType . isSubtype ( type ) && ! type . isEmptyType () ) { mismatch ( t , n , msg , type , anyObjectType ) ; }
if ( funcTarget . hasInstanceType () ) { if ( type . isSubtype ( funcTarget . getInstanceType () ) ) { return null ; } return type ; }
if ( ! objType . isNoType () && ! objType . isUnknownType () && objType . isSubtype ( getNativeType ( NULL_VOID ) ) ) { return; }
if ( castType . restrictByNotNullOrUndefined () . isSubtype ( exprType ) || expr . isObjectLit () ) { expr . setJSType ( castType ) ; }
if ( isEmptyType () || that . isEmptyType () ) { return isSubtype ( that ) || that . isSubtype ( this ) ; }
{ JSType alternate = alternatesList . get ( i ) ; if ( alternate . isSubtype ( arrayType ) ) { return true ; } }
public final boolean isSymbol () { return isSubtype ( getNativeType ( JSTypeNative.SYMBOL_VALUE_OR_OBJECT_TYPE ) ) ; }
public final boolean isNumber () { return isSubtype ( getNativeType ( JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE ) ) ; }
public final boolean isString () { return isSubtype ( getNativeType ( JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE ) ) ; }
if ( that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL ) ) ) { return UNKNOWN ; }
! type . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) )
assertTrue ( STRING_CONSTANT + varType + STRING_CONSTANT + name + STRING_CONSTANT + type + STRING_CONSTANT , varType . isSubtype ( type ) ) ;
return new BooleanOutcomePair ( jsType . getPossibleToBooleanOutcomes () , registry . getNativeType ( BOOLEAN_TYPE ) . isSubtype ( jsType ) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY , flowScope , flowScope ) ;
outcome.booleanValues == BooleanLiteralSet.EMPTY && getNativeType ( BOOLEAN_TYPE ) . isSubtype ( type )
! jsType . isUnknownType () && ! jsType . isAllType () && jsType . isSubtype ( providedJsType )
if ( that . isUnknownType () || that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; }
{ final JSType voidType = compiler . getTypeRegistry () . getNativeType ( JSTypeNative.VOID_TYPE ) ; return voidType . isSubtype ( returnType ) ; }
if ( that . isUnknownType () || that . isSubtype ( getNativeType ( JSTypeNative.NUMBER_STRING_BOOLEAN ) ) || that . isObject () ) { return UNKNOWN ; }
assertFalse ( arrayOfString . isSubtype ( createUnionType ( arrayOfNumber , NULL_VOID ) ) ) ;
@ Override public boolean isSubtype ( JSType that ) { return isSubtype ( that , ImplCache . create () , SubtypingMode.NORMAL ) ; }
return thisType . isSubtype ( thatType ) || thatType . isSubtype ( thisType ) ;
{ if ( thisType . isFunctionType () ) { return true ; } else { return thisType . isSubtype ( functionType ) || functionType . isSubtype ( thisType ) ; } }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
boolean isConstToBeInferred () { return isConstToBeInferred ( getJsDoc () , getLhs () ) ; }
maybeWarnForConstWithoutExplicitType ( compiler , jsdoc , nameNode ) ;
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new J2clPass ( compiler ) ; }
if ( astValidationEnabled ) { ( new AstValidator ( compiler ) ) . validateRoot ( root ) ; }
new PureFunctionIdentifier.DriverInJ2cl ( compiler , null ) . process ( externs , root ) ;
exportedNameToLocalQName . put ( name , name ) ;
exportedNameToLocalQName . put ( name , name ) ;
exportedNameToLocalQName . put ( STRING_CONSTANT , name ) ;
Map.Entry < String , String > entry
functionNames = compilerState.functioNames ;
this . functioNames = compiler.functionNames ;
assertTrue ( moduleScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( moduleScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( blockScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( fooScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( forOfScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( functionBlockScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( functionScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( functionBlockScope . isDeclared ( STRING_CONSTANT , false ) ) ;
catch ( FlagUsageException e ) { assertThat ( e ) . hasMessage ( STRING_CONSTANT ) ; }
return s != null ? s : createScope ( n , createScope ( NodeUtil . getEnclosingScopeRoot ( n . getParent () ) ) ) ;
TypeInference dfa = new TypeInference ( compiler , cfg , rai , assumedScope , ASSERTION_FUNCTION_MAP ) ;
return v != null && v . isLocal () && v . isMarkedEscaped () && v . getScope () == syntacticScope ;
if ( isUnflowable ( syntacticScope . getVar ( varName ) ) ) { return; }
isLocallyInferred = ( var != syntacticScope . getSlot ( qualifiedName ) ) ;
ttlObj = new TypeTransformation ( compiler , syntacticScope ) ;
TypedVar var = syntacticScope . getVar ( qKeyName ) ;
TypedVar var = syntacticScope . getVar ( qName ) ;
TypedVar var = syntacticScope . getVar ( varName ) ;
{ type = info . getType () . evaluate ( syntacticScope , registry ) ; }
if ( info != null && info . hasType () ) { n . setJSType ( info . getType () . evaluate ( syntacticScope , registry ) ) ; }
if ( rename ) { NodeTraversal . traverseEs6 ( compiler , js , new Renamer ( compiler ) ) ; }
registry . createNullableType ( registry . getType ( STRING_CONSTANT ) )
{ super ( registry , reference , sourceName , lineno , charno ) ; }
resolvedNamedTypes . putAll ( scope , unresolvedNamedTypes . removeAll ( scope ) ) ;
public void clearNamedTypes () { resolvedNamedTypes . clear () ; unresolvedNamedTypes . clear () ; }
{ checkArgument ( ! name . contains ( STRING_CONSTANT ) , STRING_CONSTANT ) ; namesToTypes . put ( name , type ) ; }
assertTrue ( findNameType ( STRING_CONSTANT , lastLocalScope ) . isEquivalentTo ( registry . getType ( STRING_CONSTANT ) ) ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , jsdoc . getImplementedInterfaces () . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , types . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , interfaces . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , NUMBER_CONSTANT , NUMBER_CONSTANT ) , jsdoc . getBaseType () ) ;
{ assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , parse ( STRING_CONSTANT ) . getBaseType () ) ; }
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , interfaces . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( createNullableType ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
! newType . isEquivalentTo ( varType )
{ assertEquals ( expected , resolve ( actual ) ) ; }
{ return ! checkEquivalenceHelper ( that , EquivalenceMethod.DATA_FLOW ) ; }
{ if ( constructorI . checkEquivalenceHelper ( constructorJ , EquivalenceMethod.IDENTITY ) ) { shouldCheck = false ; } }
{ this ( Functions . < String > identity () , errorManager ) ; }
Node ast = parseSyntheticCode ( STRING_CONSTANT + resourceName + STRING_CONSTANT , originalCode ) ;
if ( ! scope . isDeclared ( NodeUtil.JSC_PROPERTY_NAME_FN , true ) ) { scope . declare ( NodeUtil.JSC_PROPERTY_NAME_FN , null , null ) ; }
if ( scope . isDeclared ( qName , false ) ) { continue; }
! scope . isDeclared ( qName , false ) && n . isUnscopedQualifiedName ()
if ( ! name . isEmpty () && ! usageScope . isDeclared ( name , true ) ) { return true ; }
if ( t . getScope () . isDeclared ( alias , true ) ) { compiler . report ( JSError . make ( n , TYPE_ALIAS_ALREADY_DECLARED , alias ) ) ; }
n . isName () && ! t . getScope () . isDeclared ( n . getString () , true )
if ( current . isDeclared ( oldName , false ) ) { return; } else { current = current . getParent () ; }
assertTrue ( fooScope . isDeclared ( STRING_CONSTANT , false ) ) ;
if ( ! getRootNode () . isFunction () ) { return getClosestNonBlockScope () . getTypeOfThis () ; }
return v != null && v . isLocal () && v . isMarkedEscaped () && v . getScope () . getClosestNonBlockScope () == cfgRootScope ;
this . cfgRootScope = syntacticScope ;
while ( t . getScope () . isDeclared ( pseudoName , true ) ) { pseudoName += STRING_CONSTANT ; }
varsInFunctionBody . contains ( refName ) && ! scope . isDeclared ( refName , true )
AbstractVar < , > var = getSubject () . getVar ( name ) ;
AbstractVar < , > var = getSubject () . getVar ( name ) ;
if ( isUnflowable ( currentScope . getVar ( varName ) ) ) { return; }
isLocallyInferred = ( var != currentScope . getSlot ( qualifiedName ) ) ;
backwardsInferenceFromCallSite ( n , ct ) ;
backwardsInferenceFromCallSite ( n , fnType ) ;
TypedVar var = currentScope . getVar ( qKeyName ) ;
boolean unflowable = isInferred && isUnflowable ( currentScope . getVar ( varName ) ) ;
{ type = info . getType () . evaluate ( currentScope , registry ) ; }
return MODULE_EXPORTS_PREFIX + this . legacyNamespace . replace ( CHAR_CONS , CHAR_CONS ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , GOOG_MODULE_USES_GOOG_MODULE_GET ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null , false , ResolutionMode.BROWSER ) ; }
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , MODULE_USES_GOOG_MODULE_GET ) ; }
return getBinaryModuleNamespace ( legacyNamespace ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , error ( DisambiguateProperties.Warnings.INVALIDATION_ON_TYPE ) . withMessageContaining ( STRING_CONSTANT ) ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , error ( DisambiguateProperties.Warnings.INVALIDATION_ON_TYPE ) . withMessageContaining ( STRING_CONSTANT ) ) ;
{ test ( srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , error ( DisambiguateProperties.Warnings.INVALIDATION ) . withMessageContaining ( STRING_CONSTANT ) ) ; }
{ test ( srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , error ( DisambiguateProperties.Warnings.INVALIDATION ) . withMessageContaining ( STRING_CONSTANT ) ) ; }
TypedVar fnVar = scope . getVar ( fnName ) ;
Node rootNode = scope . getRootNode () ;
private GlobalScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
if ( scope . hasOwnSlot ( qName ) ) { continue; }
TypedVar ownerVar = scope . getVar ( slotName ) ;
TypedVar slot = scope . getVar ( name ) ;
{ return createEnumTypeFromNodes ( rValue , lValue . getQualifiedName () , info ) ; }
return scope . isGlobal () || ! type . isReturnTypeInferred () ;
parent == null || ! parent . isFunction () || n == parent . getFirstChild () || parent == scope . getRootNode ()
return slot != null ? slot : getFunctionScope () . getSlot ( var . getName () ) ;
ScopedName var = getVarFromFunctionScope ( symbol ) ;
{ return new LinkedFlowScope ( new FlatFlowScopeCache ( scope ) ) ; }
{ if ( type != null ) { type = type . resolve ( errorReporter , scope ) ; } }
public TemplateType getObjectIndexKey () { checkNotNull ( iObjectIndexTemplateKey ) ; return this . iObjectIndexTemplateKey ; }
public TemplateType getObjectElementKey () { return this . iObjectElementTemplateKey ; }
new InvalidatingTypes.Builder ( registry ) . recordInvalidations ( this . invalidationMap ) . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () )
Node root = NodeUtil . getEnclosingNode ( n , TypeInference : : createsContainerScope ) ;
AbstractScope ( Node rootNode ) { this . rootNode = rootNode ; }
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , GOOG_MODULE_USES_GOOG_MODULE_GET ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null ) ; }
return MODULE_EXPORTS_PREFIX + this . legacyNamespace . replace ( CHAR_CONS , CHAR_CONS ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
{ if ( moduleType == ModuleType.GOOG_MODULE ) { moduleType = ModuleType.LEGACY_GOOG_MODULE ; } else { compiler . report ( JSError . make ( declaresNamespace , DECLARE_LEGACY_NAMESPACE_OUTSIDE_GOOG_MODULE ) ) ; } }
if ( Keywords . isKeyword ( name.value ) ) { features = features . with ( Feature.KEYWORDS_AS_PROPERTIES ) ; }
{ if ( moduleType == ModuleType.GOOG_MODULE ) { moduleType = ModuleType.LEGACY_GOOG_MODULE ; } else { compiler . report ( JSError . make ( declaresLegacyNamespace , DECLARE_LEGACY_NAMESPACE_OUTSIDE_GOOG_MODULE ) ) ; } }
if ( n . isVar () ) { return n . getFirstChild () ; } else if ( NodeUtil . isExprAssign ( n ) ) { return n . getFirstFirstChild () ; }
if ( ! child . isVar () && ! NodeUtil . isExprAssign ( child ) ) { continue; }
parent != null && parent . isVar ()
Node node = withType ( IR . number ( id ) . useSourceInfoFrom ( sourceNode ) , numberType ) ;
sourceNode . replaceWith ( IR . breakNode () ) ;
IR . block ( callContextMethodResult ( sourceNode , STRING_CONSTANT , section . getNumber ( sourceNode ) ) , IR . breakNode () . useSourceInfoFrom ( sourceNode ) ) . useSourceInfoFrom ( sourceNode )
{ writeGeneratedNode ( n ) ; writeGeneratedNode ( IR . breakNode () . useSourceInfoFrom ( n ) ) ; currentCase.mayFallThrough = false ; }
var != null && var . getScope () == getSubject ()
{ checkState ( scope != getSubject () , STRING_CONSTANT ) ; expectScope ( STRING_CONSTANT , scope , scope ) ; }
private DeclarationSubject ( AbstractVar < , > var ) { this . var = var ; }
ImmutableList < AbstractVar < , > > declared = ImmutableList . copyOf ( getSubject () . getAllAccessibleVariables () ) ;
if ( replace . isVar () ) { replace . replaceWith ( NodeUtil . newExpr ( replacement ) ) ; } else { replace . replaceWith ( replacement ) ; }
ref . getParent () . isVar ()
if ( parent . isFunction () || parent . isVar () || parent . isNew () ) { return; }
{ return ( n . isVar () || n . isFunction () ) && isWhitelistedName ( n . getFirstChild () . getString () ) ; }
checkArgument ( returnNode . isReturn () ) ;
{ return ! isValidIndex ( index + offset ) ? CHAR_CONS : source.contents . charAt ( index + offset ) ; }
private char nextChar () { if ( isAtEnd () ) { return CHAR_CONS ; } return source.contents . charAt ( index ++ ) ; }
String value = this . source . contents . substring ( startOffset , index ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , collector ) ;
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , extractionInfo ) ;
NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , new Callback () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , externs , this ) ; addWindowProperties () ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , body , updater ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ symbolMap = getCssRenamingMap () ; NodeTraversal . traverseEs6 ( compiler , root , new Traversal () ) ; }
NodeTraversal . traverseEs6 ( compiler , scriptRoot , traverser ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseRootsEs6 ( compiler , renamer , externs , root ) ;
{ NodeTraversal . traverseEs6 ( compiler , checkNotNull ( root ) , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
for ( Callback callback : callbacks ) { scriptRoot . putBooleanProp ( Node.TRANSPILED , true ) ; NodeTraversal . traverseEs6 ( compiler , scriptRoot , callback ) ; }
for ( Callback callback : callbacks ) { singleRoot . putBooleanProp ( Node.TRANSPILED , true ) ; NodeTraversal . traverseEs6 ( compiler , singleRoot , callback ) ; }
do { codeChanged = false ; NodeTraversal . traverseEs6 ( compiler , root , new EliminationPass ( cfg ) ) ; } while ( codeChanged ) ;
{ checkNotNull ( root ) ; checkState ( root . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ if ( Es6RewriteModules . isEs6ModuleRoot ( script ) ) { NodeTraversal . traverseEs6 ( compiler , script , new Rewriter ( compiler , script ) ) ; } }
NodeTraversal . traverseEs6 ( compiler , root , finder ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseEs6 ( compiler , scriptRoot , finder ) ;
NodeTraversal . traverseEs6 ( compiler , block , new UnmarkedNodeTranspiler () ) ;
NodeTraversal . traverseEs6 ( compiler , wrapper , context . new UnmarkedNodeTranspiler () ) ;
NodeTraversal . traverseEs6 ( compiler , originalGeneratorBody , new YieldNodeMarker () ) ;
NodeTraversal . traverseEs6 ( compiler , root , new LabelFinder () ) ;
NodeTraversal . traverseEs6 ( compiler , root , namingCallback ) ;
NodeTraversal . traverseRootsEs6 ( compiler , pass , externs , root ) ;
NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ;
{ NodeTraversal . traverseEs6 ( compiler , originalRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , externs , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , externs , findExternsCallback ) ; }
{ NodeTraversal . traverseEs6 ( compiler , js , this ) ; }
if ( renameMessages ) { RenameMessagesVisitor renameMessagesVisitor = new RenameMessagesVisitor () ; NodeTraversal . traverseEs6 ( compiler , root , renameMessagesVisitor ) ; }
NodeTraversal . traverseEs6 ( compiler , root , namingCallback ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , originalRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , function . getLastChild () , finder ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , NodeUtil . getLoopCodeBlock ( loopNode ) , continueStatementUpdater ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , superSet . getLastChild () , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
{ CheckProvidesCallback callback = new CheckProvidesCallback ( codingConvention ) ; NodeTraversal . traverseEs6 ( compiler , scriptRoot , callback ) ; }
NodeTraversal . traverseEs6 ( compiler , cfgNode , gatherCb ) ;
NodeTraversal . traverseEs6 ( compiler , n , gatherCb ) ;
NodeTraversal . traverseEs6 ( compiler , cfgNode , gatherCb ) ;
NodeTraversal . traverseEs6 ( compiler , t . getScopeRoot () , new GatherCandidates () ) ;
NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ new InferConsts ( compiler ) . process ( externs , root ) ; NodeTraversal . traverseEs6 ( compiler , root , constFinder ) ; }
NodeTraversal . traverseEs6 ( this , n , sia ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , NodeUtil . getFunctionBody ( constructor ) , finder ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , externs , this ) ; compiler . setExternProperties ( ImmutableSet . copyOf ( externProperties ) ) ; }
NodeTraversal . traverseEs6 ( compiler , tree , test ) ;
NodeTraversal . traverseEs6 ( compiler , tree , test ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseEs6 ( compiler , root , new Callback () ) ;
NodeTraversal . traverseEs6 ( compiler , root , traversal ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , externs , externsCallback ) ;
NodeTraversal . traverseEs6 ( compiler , originalRoot , cb ) ;
NodeTraversal . traverseEs6 ( compiler , root , new ProcessProperties () ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new GatherCollapses () ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopes , new EmptyClinitPruner () , false ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseEs6 ( compiler , script , test ) ;
{ checkArgument ( isEs6ModuleRoot ( root ) , root ) ; clearState () ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
if ( isEs6ModuleRoot ( scriptNode ) ) { processFile ( scriptNode ) ; } else { NodeTraversal . traverseEs6 ( compiler , scriptNode , new RewriteRequiresForEs6Modules () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , callbacks . get ( NUMBER_CONSTANT ) ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new Strip () ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , findFunction ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , findParameter ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , new ExportTestFunctionsNodes () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , externs , findExternsCallback ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , callback , new RenameCallback ( aliasName , renamed ) ) ; aliasName = renamed ; break; }
NodeTraversal . traverseEs6 ( compiler , callbackBlock , new DefineCallbackReturnCallback () ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , new TransformAMDModulesCallback () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , script , this ) ;
NodeTraversal . traverseEs6 ( compiler , googRoot , this ) ;
{ checkArgument ( scriptNode . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , scriptNode , this ) ; }
{ if ( ! rules . isEmpty () ) { NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ; } }
NodeTraversal . traverseEs6 ( compiler , tree , cb ) ;
{ checkState ( root . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ;
NodeTraversal . traverseEs6 ( compiler , js , new Normalize.NormalizeStatements ( compiler , false ) ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new ProcessVars () ) ;
NodeTraversal . traverseEs6ScopeRoots ( compiler , null , changedScopeRoots , new UseSiteGatheringCallback () , false ) ;
{ super . process ( externs , source ) ; NodeTraversal . traverseEs6 ( compiler , source , new UseSiteGatheringCallback () ) ; }
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
{ requiresLineNumbers = false ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , constructorBody , replaceThisWithSuperThis ) ;
NodeTraversal . traverseEs6 ( compiler , functionBody , checkForDefinedReturnValue ) ;
NodeTraversal . traverseEs6 ( compiler , enclosingFunction , checkAssigns ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , findExportableNodes ) ;
NodeTraversal . traverseEs6 ( compiler , parsed.ast , new Traverser ( info ) ) ;
{ FindPrimitives pass = new FindPrimitives () ; NodeTraversal . traverseEs6 ( compiler , root , pass ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , pass ) ;
NodeTraversal . traverseEs6 ( compiler , body , traversal ) ;
NodeTraversal . traverseEs6 ( compiler , root , getterSetterCollector ) ;
NodeTraversal . traverseEs6 ( compiler , body , this ) ;
NodeTraversal . traverseEs6ScopeRoots ( compiler , null , changedScopeRoots , cb , cb , false ) ;
{ requiresTypes = false ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ mode = Mode.SINGLE_FILE ; reset () ; NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ reset () ; NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ; }
NodeTraversal . traverseEs6 ( compiler , root , definitionsGatherer ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopeNodes , new PeepCallback () , false ) ; if ( ! retraverseOnChange ) { break; } }
NodeTraversal . traverseEs6 ( compiler , root , new ReductionGatherer ( reducers , reductionMap ) ) ;
{ NodeTraversal . traverseEs6 ( compiler , js , new DeadAssignmentsElimination ( compiler ) ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new ProcessProperties () ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , new SourceInformationAnnotator ( STRING_CONSTANT , false ) ) ; }
{ PolymerPassSuppressBehaviors suppressBehaviorsCallback = new PolymerPassSuppressBehaviors ( compiler ) ; NodeTraversal . traverseEs6 ( compiler , root , suppressBehaviorsCallback ) ; }
return new IdentifierToken ( getTokenRange ( beginToken ) , value . intern () ) ;
NodeTraversal . traverseEs6 ( compiler , script , cb ) ;
NodeTraversal . traverseEs6 ( compiler , rootNode , callback ) ;
NodeTraversal . traverseEs6 ( metadata . getCompiler () , script , callback ) ;
assertEquals ( STRING_CONSTANT , x . getType () . toString () ) ;
assertEquals ( STRING_CONSTANT , bar . getType () . toString () ) ;
assertEquals ( STRING_CONSTANT , f . getPropertyType ( STRING_CONSTANT ) . toString () ) ;
if ( item . isVar () ) { item = item . getFirstChild () ; }
{ checkArgument ( parent . isFunction () || parent . isVar () || parent . isParamList () || parent . isCatch () ) ; }
NodeTraversal . traverseTyped ( compiler , root , new DiscoverEnumsAndTypedefs ( typeRegistry ) ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTranspile () ; }
NodeTraversal . traverseEs6 ( compiler , root , new IdentifyGlobalEnumsAndTypedefsAsNonNullable ( typeRegistry ) ) ;
ReferenceCollectingCallback refCollector = new ReferenceCollectingCallback ( this , ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR , SyntacticScopeCreator . makeUntyped ( this ) ) ;
private TypeCheckResult parseAndTypeCheckWithScope ( String js ) { return parseAndTypeCheckWithScope ( DEFAULT_EXTERNS , js ) ; }
private Node parseAndTypeCheck ( String js ) { return parseAndTypeCheck ( DEFAULT_EXTERNS , js ) ; }
{ testTypes ( DEFAULT_EXTERNS + STRING_CONSTANT + externs , js , diag , false ) ; }
{ testTypes ( externs , js , ( String ) null , false ) ; }
{ testTypes ( DEFAULT_EXTERNS , js , description , isError ) ; }
public void testCovariantIThenable3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testSymbol2 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testSymbol1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch6 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch5 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch4 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch2 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeCovariant2 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeCovariant1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
Node js1Node = parseAndTypeCheck ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
Node js1Node = parseAndTypeCheck ( STRING_CONSTANT + STRING_CONSTANT ) ;
{ TypeCheckResult p = parseAndTypeCheckWithScope ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testAddingMethodsUsingPrototypeIdiomComplexNamespace ( p ) ; }
{ TypeCheckResult p = parseAndTypeCheckWithScope ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testAddingMethodsUsingPrototypeIdiomComplexNamespace ( p ) ; }
Node js1Node = parseAndTypeCheck ( STRING_CONSTANT + STRING_CONSTANT ) ;
public void testFunctionBind5 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind4 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind3 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind2 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind1 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall8 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall7 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall6 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall5 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall3 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall2 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall1 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testAbstractMethodCall13 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall12 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall10 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall8 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall7 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall5 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testIssue1201b () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testThis14 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess9 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess8 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess7 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess6 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess4 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess3 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess2 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess1 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testGetelemStruct_noErrorForGettingWellKnownSymbol () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testGetelemStruct_noErrorForSettingWellKnownSymbol () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testForOf8 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf6 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf5 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf4 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ Node number = createUntypedNumber ( n ) ; number . setJSType ( NUMBER_TYPE ) ; return number ; }
{ Node n = new Node ( Token.NULL ) ; n . setJSType ( NULL_TYPE ) ; return n ; }
child . inferSlotType ( STRING_CONSTANT , NUMBER_TYPE ) ;
public void testTransformationWithUnionInMaprecord () { testTTL ( UNKNOWN_TYPE , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithInvalidMaprecord () { testTTL ( UNKNOWN_TYPE , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithInvalidNestedMapunion () { testTTL ( UNKNOWN_TYPE , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testTransformationWithNestedMapunionInMapFunctionBody () { testTTL ( STRING_TYPE , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithNestedExpressionInBooleanSecondParam () { testTTL ( STRING_TYPE , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithNestedExpressionInBooleanFirstParam () { testTTL ( STRING_TYPE , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
assertTypeEquals ( type , OBJECT_TYPE ) ;
{ Node n = parseAndTypeCheck ( STRING_CONSTANT ) ; assertTypeEquals ( ERROR_TYPE , n . getFirstFirstChild () . getJSType () ) ; }
assertTypeEquals ( NUMBER_TYPE , type ) ;
assertTypeEquals ( NUMBER_TYPE , type ) ;
assertTypeEquals ( STRING_CONSTANT , NUMBER_TYPE , googFooGetprop2ObjectType . getPropertyType ( STRING_CONSTANT ) ) ;
public void testName5 () { assertTypeEquals ( REGEXP_FUNCTION_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName4 () { assertTypeEquals ( DATE_FUNCTION_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName3 () { assertTypeEquals ( ARRAY_FUNCTION_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName2 () { assertTypeEquals ( OBJECT_FUNCTION_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName1 () { assertTypeEquals ( VOID_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
assertTypeEquals ( ARRAY_TYPE , a . getType () ) ;
assertTypeEquals ( VOID_TYPE , n . getJSType () ) ;
{ Node falseNode = typeCheck ( new Node ( Token.FALSE ) ) ; assertTypeEquals ( BOOLEAN_TYPE , falseNode . getJSType () ) ; }
{ Node trueNode = typeCheck ( new Node ( Token.TRUE ) ) ; assertTypeEquals ( BOOLEAN_TYPE , trueNode . getJSType () ) ; }
{ Node n = typeCheck ( Node . newString ( STRING_CONSTANT ) ) ; assertTypeEquals ( STRING_TYPE , n . getJSType () ) ; }
{ Node n = typeCheck ( Node . newNumber ( NUMBER_CONSTANT ) ) ; assertTypeEquals ( NUMBER_TYPE , n . getJSType () ) ; }
{ TypeCheckResult p = parseAndTypeCheckWithScope ( STRING_CONSTANT ) ; assertTypeEquals ( NUMBER_TYPE , p.scope . getVar ( STRING_CONSTANT ) . getType () ) ; }
JSDocInfo jsDoc = node . getParent () . isVar () ? node . getParent () . getJSDocInfo () : node . getJSDocInfo () ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
shouldAddTypes ? this . contextType . getPropertyType ( fieldName ) : null
String embedded = transpiled + STRING_CONSTANT + URLEncoder . encode ( sourceMap ) + STRING_CONSTANT ;
var . getParentNode () != null && var . getType () == null && var . getParentNode () . isVar ()
options . setPreserveGoogProvidesAndRequires ( true ) ;
ObjectType regType = ObjectType . cast ( registry . getType ( qualifiedName ) ) ;
JSType windowType = getType ( STRING_CONSTANT ) ;
{ typesIndexedByProperty . clear () ; eachRefTypeIndexedByProperty . clear () ; initializeBuiltInTypes () ; namesToTypes . clear () ; initializeRegistry () ; }
assertTypeEquals ( typeRegistry . getNativeType ( GENERATOR_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
assertTypeEquals ( typeRegistry . getNativeType ( ITERATOR_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
assertTypeEquals ( typeRegistry . getNativeType ( ITERABLE_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
{ warnImplicitlyNullable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; noWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
JSType type = registry . getType ( reference ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories , compiler . getOptions () ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes , compiler . getOptions () ) ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks , options ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes , options ) ;
actualYieldType = actualYieldType . dereference () . getTemplateTypeMap () . getResolvedTemplateType ( typeRegistry . getIterableTemplate () ) ;
var . getParentNode () != null && var . getType () == null && NodeUtil . isNameDeclaration ( var . getParentNode () )
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.NTI_ONLY ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; late = false ; useTypes = true ; numRepetitions = NUMBER_CONSTANT ; mode = TypeInferenceMode.NEITHER ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
Node parse ( String js ) { return parse ( js , TypeInferenceMode.NEITHER ) ; }
new CodePrinter.Builder ( parse ( js , TypeInferenceMode.OTI_ONLY ) )
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; String source = STRING_CONSTANT ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.OTI_ONLY ;
this . mode = TypeInferenceMode.OTI_ONLY ;
this . mode = TypeInferenceMode.BOTH ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; this . mode = TypeInferenceMode.NEITHER ; enableRunTypeCheckAfterProcessing () ; }
public void disable_testClassMethodUnused2 () { this . mode = TypeInferenceMode.NEITHER ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { this . mode = TypeInferenceMode.NEITHER ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassPropUnused1 () { this . mode = TypeInferenceMode.NEITHER ; unused ( STRING_CONSTANT ) ; }
public void testClassWithEmptyMembers () { this . mode = TypeInferenceMode.NEITHER ; testError ( STRING_CONSTANT , StrictModeCheck.DUPLICATE_CLASS_METHODS ) ; }
public void testStaticAndNonstaticSetterWithSameName () { this . mode = TypeInferenceMode.NEITHER ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticGetterWithSameName () { this . mode = TypeInferenceMode.NEITHER ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticMethodWithSameName () { this . mode = TypeInferenceMode.NEITHER ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testComputedPropInClass () { this . mode = TypeInferenceMode.NEITHER ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
public void testArguments6 () { this . mode = TypeInferenceMode.NEITHER ; testSame ( STRING_CONSTANT ) ; }
public void testUnknownVariable4 () { this . mode = TypeInferenceMode.NEITHER ; testSameEs6Strict ( STRING_CONSTANT ) ; testSameEs6Strict ( STRING_CONSTANT ) ; }
{ super . setUp () ; late = true ; useTypes = true ; this . mode = TypeInferenceMode.NEITHER ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefinePropertiesQuotesPreventRemoval () { this . mode = TypeInferenceMode.BOTH ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { this . mode = TypeInferenceMode.BOTH ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty1 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.NEITHER ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_boxedNumberVsZero () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_while () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ super . setUp () ; late = true ; this . mode = TypeInferenceMode.NEITHER ; ignoreWarnings ( DiagnosticGroups.NEW_CHECK_TYPES_EXTRA_CHECKS ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.BOTH ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.BOTH ; }
this . mode = TypeInferenceMode.OTI_ONLY ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.NEITHER ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.BOTH ; }
testSame ( externs ( lines ( MINIMAL_EXTERNS , STRING_CONSTANT , STRING_CONSTANT ) ) , srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , warningOtiNti ( TypeValidator.TYPE_MISMATCH_WARNING , NewTypeInference.INVALID_ARGUMENT_TYPE ) )
{ this . mode = TypeInferenceMode.NEITHER ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.NEITHER ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
test ( srcs ( STRING_CONSTANT ) , warningOtiNti ( TOO_MANY_TEMPLATE_PARAMS , INVALID_GENERICS_INSTANTIATION ) ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( srcs ( STRING_CONSTANT ) , warningOtiNti ( TOO_MANY_TEMPLATE_PARAMS , INVALID_GENERICS_INSTANTIATION ) ) ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ super . setUp () ; this . mode = TypeInferenceMode.NEITHER ; enableRunTypeCheckAfterProcessing () ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ super . setUp () ; this . mode = TypeInferenceMode.NEITHER ; enableRunTypeCheckAfterProcessing () ; }
for ( NamedType type : unresolvedNamedTypes . get ( scope ) ) { type . resolve ( reporter , scope ) ; }
activeXObject . resolve ( null , scope ) ;
namedA . resolve ( null , scope ) ;
{ if ( type != null ) { this . type = type . resolve ( errorReporter , scope ) ; } }
a . resolve ( null , EMPTY_SCOPE ) ;
for ( DeferredSetType deferred : deferredSetTypes ) { deferred . resolve ( currentScope ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( factories ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
public void testAbstractClass () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT , warning ( INSTANTIATE_ABSTRACT_CLASS ) ) ; }
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.DISABLED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
Node parse ( String js ) { return parse ( js , TypeInferenceMode.DISABLED ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefinePropertiesQuotesPreventRemoval () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties1 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testES6StaticProperty2 () { this . mode = TypeInferenceMode.DISABLED ; testSame ( STRING_CONSTANT ) ; }
public void testES6StaticProperty () { this . mode = TypeInferenceMode.DISABLED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testConstructorProperty2 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty1 () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.DISABLED ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; ignoreWarnings ( DiagnosticGroups.NEW_CHECK_TYPES_EXTRA_CHECKS ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableTranspile () ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
public void testClassWithEmptyMembers () { this . mode = TypeInferenceMode.DISABLED ; testError ( STRING_CONSTANT , StrictModeCheck.DUPLICATE_CLASS_METHODS ) ; }
public void testStaticAndNonstaticSetterWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticGetterWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticMethodWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testComputedPropInClass () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
public void testArguments6 () { this . mode = TypeInferenceMode.DISABLED ; testSame ( STRING_CONSTANT ) ; }
public void testUnknownVariable4 () { this . mode = TypeInferenceMode.DISABLED ; testSameEs6Strict ( STRING_CONSTANT ) ; testSameEs6Strict ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; late = true ; useTypes = true ; this . mode = TypeInferenceMode.DISABLED ; }
public void disable_testClassMethodUnused2 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassPropUnused1 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = STRING_CONSTANT ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; ignoreWarnings ( NewTypeInference.GLOBAL_THIS , NewTypeInference.INEXISTENT_PROPERTY ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
new CodePrinter.Builder ( parse ( js , TypeInferenceMode.CHECKED ) )
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_boxedNumberVsZero () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_while () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTranspile () ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.NTI . equals ( compiler . getMostRecentTypechecker () ) ; }
public boolean isTypecheckingEnabled () { return this . checkTypes || this . useNewTypeInference ; }
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.NTI . equals ( compiler . getMostRecentTypechecker () ) ; }
this . addTypes = MostRecentTypechecker.NTI . equals ( compiler . getMostRecentTypechecker () ) ;
return options . getNewTypeInference () ? getGlobalTypeInfo () : getTypeRegistry () ;
this . addTypes = MostRecentTypechecker.NTI . equals ( compiler . getMostRecentTypechecker () ) ;
ignoreWarnings ( GlobalTypeInfoCollector.INTERFACE_METHOD_NOT_IMPLEMENTED , TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED ) ;
public void testTypeMismatch () { ignoreWarnings ( NewTypeInference.MISTYPED_ASSIGN_RHS , TypeValidator.TYPE_MISMATCH_WARNING ) ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
DiagnosticGroup ignored = new DiagnosticGroup ( TypeCheck.INEXISTENT_PROPERTY , NewTypeInference.GLOBAL_THIS , NewTypeInference.INEXISTENT_PROPERTY , NewTypeInference.INVALID_ARGUMENT_TYPE , TypeValidator.TYPE_MISMATCH_WARNING ) ;
validator . expectCanAssignTo ( t , loopVarNode , declaredType , actualType , STRING_CONSTANT ) ;
checkArgument ( setKey . isSetterDef () , setKey ) ;
newGeneratorBody . addChildBefore ( varStatement , newGeneratorBody . getLastChild () ) ;
newGeneratorBody . addChildBefore ( n , newGeneratorBody . getLastChild () ) ;
if ( NodeUtil . isStringLiteralValue ( ast ) ) { paramNodeMatches . set ( paramIndex , ast ) ; return true ; }
{ return NodeUtil . isStringLiteralValue ( ast ) ; }
{ if ( ! isCompileTimeConstant ( traversal . getScope () , argument ) ) { compiler . report ( traversal . makeError ( argument , CONST_NOT_STRING_LITERAL_ERROR ) ) ; } }
if ( prop != null ) { if ( NodeUtil . isStringLiteralValue ( prop ) ) { continue; } return violation ; }
NodeUtil . isLhsOfAssign ( propAccess ) && ( NodeUtil . isLiteralValue ( propAccess . getNext () , false ) || NodeUtil . isStringLiteralValue ( propAccess . getNext () ) )
String lastPart = typeString . substring ( typeString . lastIndexOf ( STRING_CONSTANT ) + NUMBER_CONSTANT ) ;
int index = name . indexOf ( STRING_CONSTANT ) ;
checkArgument ( setKey == null || setKey . isSetterDef () , setKey ) ;
Path path
Path path
Path path
Path path
Path path
public void setSourceMapLocationMappings ( List < SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
{ locationMappings . add ( new SourceMap.LocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
List < LocationMapping > sourceMapLocationMappings
Path path
Path path
this . registry = compiler . getTypeIRegistry () ;
actual = new CodePrinter.Builder ( script ) . setCompilerOptions ( options ) . setTypeRegistry ( compiler . getTypeIRegistry () ) . build () . trim ()
TypeI type = fnNode . getTypeI () ;
TypeI type = n . getTypeI () ;
@ Override public boolean isPrototypeObject () { return isFunctionPrototypeType () ; }
TypeI type = srcObj . getTypeI () ;
TypeI attrsType = attrs . getTypeI () ;
TypeI type = srcObj . getTypeI () ;
ObjectTypeI targetType = target . getTypeI () . toMaybeObjectType () ;
String typeName = n . getFirstChild () . getTypeI () . toString () ;
TypeI type = n . getTypeI () ;
TypeI type = n . getTypeI () ;
{ return n . getTypeI () != null && isKnown ( n ) && invalidDeref ( n ) && ! isWhitelistedType ( n ) ; }
TypeI thrown = n . getFirstChild () . getTypeI () ;
{ super ( compiler , requirement ) ; errorObjType = compiler . getTypeIRegistry () . getGlobalType ( STRING_CONSTANT ) ; }
TemplateAstMatcher astMatcher = new TemplateAstMatcher ( compiler . getTypeIRegistry () , templateRoot , typeMatchingStrategy ) ;
FunctionTypeI restrictedCallType
FunctionTypeI restrictedCallType
FunctionTypeI functionType
TypeI type = n . getTypeI () ;
{ return isAssertionCall ( n . getParent () ) || n . getTypeIBeforeCast () != null ; }
{ TypeI type = n . getTypeI () ; return ( type == null || type . isSomeUnknownType () ) ; }
{ TypeI type = n . getTypeI () ; return ( type == null || type . isUnknownType () ) ; }
{ TypeI type = n . getTypeI () ; return type != null && type . isTop () ; }
nativeObjectType = compiler . getTypeIRegistry () . getNativeType ( JSTypeNative.OBJECT_TYPE ) ;
n . setTypeI ( type ) ;
FunctionTypeI getterType
TypeIRegistry typeRegistry
public TypeSubject ( FailureMetadata failureMetadata , TypeI type ) { super ( failureMetadata , type ) ; }
TypeI type
FunctionTypeI getterType
builder . setTypeRegistry ( getTypeIRegistry () ) ;
StaticTypedScope < ? extends TypeI > scope
private String formatTypeVar ( TypeI var ) { return var . toAnnotationString ( Nullability.IMPLICIT ) ; }
TypeIRegistry registry
TypeI typeI = getPropLhs . getTypeI () ;
Builder ( TypeIRegistry registry ) { this . registry = registry ; }
ObjectTypeI objectType
@ Nullable ObjectTypeI referenceType
TypeI type = name . getTypeI () ;
TypeIRegistry typeRegistry
TypeI type
@ Override public JSType getReturnType () { return call.returnType ; }
TypeI type
TypeI type
TypeI type
TypeI type
new InvalidatingTypes.Builder ( compiler . getTypeIRegistry () ) . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () ) . addAllTypeMismatches ( compiler . getImplicitInterfaceUses () ) . build ()
TypeIRegistry registry
public void applySingletonGetter ( NominalTypeBuilder classType , FunctionTypeI getterType ) ;
Node newThis = withType ( context . getScopedName ( GENERATOR_THIS ) , n . getTypeI () ) ;
IR . returnNode ( withType ( IR . call ( createGenerator , withType ( genFuncName . cloneNode () , generatorFunction . getTypeI () ) , program ) , originalGenReturnType ) )
TypeIRegistry typeRegistry
TypeI type = n . getTypeI () ;
TypeIRegistry registry
TypeIRegistry registry
FunctionTypeI getterType
Node stringKey = withType ( IR . stringKey ( name , n . getFirstChild () . detach () ) , n . getTypeI () ) ;
this . registry = compiler . getTypeIRegistry () ;
ImmutableMap < String , TypeI > typeVars
TypeIRegistry registry
{ TypeI type = n . getTypeI () ; return ( type != null && type . isFunctionType () ) ; }
TypeI jsType
TypeI jsType
CodePrinter.Builder builder = new CodePrinter.Builder ( externsRoot ) . setPrettyPrint ( true ) . setOutputTypes ( true ) . setTypeRegistry ( compiler . getTypeIRegistry () ) ;
lit . setTypeI ( exportedObjectLit . getTypeI () ) ;
TemplateAstMatcher matcher = new TemplateAstMatcher ( lastCompiler . getTypeIRegistry () , templateRoot . getFirstChild () , typeMatchingStrategy ) ;
replacement . setTypeI ( call . getTypeI () ) ;
TypeI type = expr . getTypeI () ;
mathDotPowCall = withType ( IR . call ( mathPow . get () . cloneTree () , left , right ) , n . getTypeI () ) . useSourceInfoIfMissingFromForTree ( n )
TypeI type = n . getTypeI () ;
TypeI type
new InvalidatingTypes.Builder ( compiler . getTypeIRegistry () ) . disallowGlobalThis () . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () ) . build ()
TypeI type
TypeI receiverType = determineReceiverType ( n ) ;
this . registry = compiler . getTypeIRegistry () ;
TypeI type = n . getTypeI () ;
replacement . setTypeI ( getNativeStringType () ) ;
newName . setTypeI ( child . getTypeI () ) ;
@ Override public TypeI getType () { return null ; }
public Builder setTypeRegistry ( TypeIRegistry registry ) { this . registry = registry ; return this ; }
ObjectTypeI prototypeOrInstance ( ) ;
void declarePrototypeProperty ( String name , TypeI type , Node defSite ) ;
void declareInstanceProperty ( String name , TypeI type , Node defSite ) ;
void declareConstructorProperty ( String name , TypeI type , Node defSite ) ;
TypeI type
TypeI type = getType ( typeObj ) ;
TypeI type = getType ( obj ) ;
TypeI objlitType = getType ( n ) ;
TypeI type = getType ( n . getFirstChild () ) ;
return n . isGetProp () && n . getLastChild () . getString () . equals ( STRING_CONSTANT ) && n . getFirstChild () . getTypeI () . isStructuralInterface () ;
TypeI recvType = getType ( recv ) ;
TypeI type
TypeI type
ObjectTypeI objectType
ObjectTypeI objectType
TypeI type = n . getTypeI () ;
this . typeRegistry = compiler . getTypeIRegistry () ;
for ( Node n : nodeList ) { n.typei = ( TypeI ) in . readObject () ; }
for ( Node n : nodeList ) { out . writeObject ( n.typei ) ; }
dst . setTypeI ( this . typei ) ;
@ Nullable public final JSType getJSTypeBeforeCast () { return ( JSType ) getTypeIBeforeCast () ; }
@ Override public FunctionType getOwnerFunction () { return null ; }
TypeI type = firstArg . getTypeI () ;
@ Nullable TypeI typeI
n . getTypeI () == null
URI path
URI path
URI path
URI path
URI path
List < ? extends LocationMapping > sourceMapLocationMappings
{ locationMappings . add ( new SourceMap.PrefixLocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
URI path
URI path
public void setSourceMapLocationMappings ( List < ? extends SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
if ( c . getString () . equals ( STRING_CONSTANT ) ) { windowInExterns = true ; continue; }
abstract MostRecentTypechecker getMostRecentTypechecker ( ) ;
this . compiler . setMostRecentTypechecker ( MostRecentTypechecker.OTI ) ;
this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ;
compiler . setMostRecentTypechecker ( MostRecentTypechecker.OTI ) ;
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ; }
mostRecentTypechecker = compilerState.mostRecentTypeChecker ;
this . mostRecentTypeChecker = compiler.mostRecentTypechecker ;
compiler . setMostRecentTypechecker ( MostRecentTypechecker.OTI ) ;
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ; }
this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ;
if ( c . getString () . equals ( WINDOW_NAME ) ) { windowInExterns = true ; continue; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ super . setUp () ; compiler . getOptions () . setWarningLevel ( DiagnosticGroups.MISSING_OVERRIDE , CheckLevel.WARNING ) ; compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.WARNING ) ; }
if ( prevUsedRenameMap != null ) { reusePreviouslyUsedVariableMap () ; }
if ( ! validator . expectIterable ( t , n , actualYieldType , STRING_CONSTANT ) ) { return; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
if ( c . getString () . equals ( STRING_CONSTANT ) ) { windowInExterns = true ; continue; }
public ModuleLoader.ResolutionMode getModuleResolutionMode () { return this . moduleResolutionMode ; }
ObjectType objectType
ObjectType objectType
if ( iterableType != null ) { typeParam = iterableType . getTemplateTypeMap () . getResolvedTemplateType ( registry . getIterableTemplate () ) ; }
JSType newType = objType . getTemplateTypeMap () . getResolvedTemplateType ( registry . getIterableTemplate () ) ;
defineSlot ( astParameter , functionNode , paramType , inferred ) ;
{ defineSlot ( fnNameNode , fnNode , fnNode . getJSType () , false ) ; }
if ( candidate . isGetProp () ) { defineSlot ( candidate , candidate . getParent () , getNativeType ( NO_TYPE ) , false ) ; }
defineSlot ( n , parent , valueType , inferred ) ;
if ( NodeUtil . isFunctionDeclaration ( n ) ) { defineSlot ( n . getFirstChild () , n , functionType ) ; }
{ boolean inferred = keyType == null ; defineSlot ( keyNode , objLit , qualifiedName , keyType , inferred ) ; }
! type . matchesNumberContext () && ! type . matchesStringContext () && ! type . matchesStringContext ()
FunctionType makeIteratorType = registry . createFunctionType ( ( JSType ) iteratorType , paramBuilder . build () ) ;
Path path
Path path
List < LocationMapping > sourceMapLocationMappings
public void setSourceMapLocationMappings ( List < SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
Path path
Path path
Path path
{ locationMappings . add ( new SourceMap.LocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
Path path
Path path
visitImport ( n ) ;
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , newMode , sourceUrl , path , sourceMapCache ) ; }
return dereferencePointer ( n . getFirstChild () , scope ) ;
return tightenTypeAfterDereference ( n . getFirstChild () , scope ) ;
{ testTypes ( DEFAULT_EXTERNS + STRING_CONSTANT + externs , js , description , false ) ; }
{ testTypes ( DEFAULT_EXTERNS , js , diagnosticType , isError ) ; }
{ testTypes ( DEFAULT_EXTERNS , js , description , isError ) ; }
public void testGenerator_yieldAll_string () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_yieldAll1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_return2 () { testTypes ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_noDeclaredReturnType3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_returnsIterator2 () { testTypes ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_returnsIterable2 () { testTypes ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator3 () { testTypes ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_StringObject2 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_StringObject1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_string1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_array3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType6a () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType5 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType4a () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrayLitSpread () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
T getTypeOfThis ( ) ;
StaticTypedScope < JSType > scope
{ if ( sym instanceof StaticTypedSlot ) { return ( ( StaticTypedSlot < JSType > ) sym ) . isTypeInferred () ; } return true ; }
{ if ( s instanceof StaticTypedScope ) { return ( ( StaticTypedScope < JSType > ) s ) . getTypeOfThis () ; } return null ; }
{ if ( sym instanceof StaticTypedSlot ) { return ( ( StaticTypedSlot < JSType > ) sym ) . getType () ; } return null ; }
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > typeEnv
StaticTypedScope < JSType > getDeclarationScope ( ) ;
@ Override public T getTypeOfThis () { return null ; }
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedSlot < JSType > slot
StaticTypedScope < JSType > scope
@ Override StaticTypedScope < T > getScope ( ) ;
if ( n . isAssignAdd () ) { updateScopeForTypeChange ( scope , left , leftType , type ) ; }
visitParameterList ( t , n , functionType ) ;
visitParameterList ( t , n , fnType ) ;
while ( current.parent != null && current.lastSlot == current.parent.lastSlot ) { current = current.parent ; }
n . isCall () || n . isYield ()
return dereferencePointer ( n . getFirstChild () , scope ) ;
updateTypeOfParameters ( n , fnType ) ;
updateTypeOfArguments ( n , fnType ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
updateTypeOfParameters ( n , fnType ) ;
if ( ! options.checksOnly ) { passes . add ( es6ForOf ) ; }
if ( isAliasDefinition ( decl ) ) { return; }
testWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
if ( n . isAssignAdd () ) { updateScopeForAssignment ( scope , left , leftType , type ) ; }
flowScope . inferSlotType ( STRING_CONSTANT , type ) ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
child . inferSlotType ( STRING_CONSTANT , getNativeNumberType () ) ;
FlowScope output = input . createChildFlowScope ( scopeCreator . createScope ( root ) ) ;
FlowScope informed = blindScope . createChildFlowScope () ;
assign . useSourceInfoIfMissingFromForTree ( member ) ;
{ scope = traverse ( name . getFirstChild () , scope ) ; }
parentModuleCanSeeSymbolsDeclaredInChildren = false ;
List < String > moduleNameRegexList = options.modulesToPrintAfterEachPassRegexList ;
{ return new CrossModuleMethodMotion ( compiler , compiler . getCrossModuleIdGenerator () , options.removeUnusedPrototypePropertiesInExterns , options.crossModuleCodeMotionNoStubMethods ) ; }
{ return new CrossModuleCodeMotion ( compiler , compiler . getModuleGraph () , options.parentModuleCanSeeSymbolsDeclaredInChildren ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RescopeGlobalSymbols ( compiler , options.renamePrefixNamespace , options.renamePrefixNamespaceAssumeCrossModuleNames ) ; }
assertTrue ( REGEXP_TYPE . canBeCalled () ) ;
obj != null && obj . isPrototypeObject ()
return subtype . isBottom () ;
@ Override public boolean isVoidable () { return true ; }
@ Override public boolean isNullable () { return true ; }
@ Override public boolean isNoObjectType () { return false ; }
! callClassType . isBottom () && ! callClassType . isSomeUnknownType ()
type == null || type . isUnknownType () || type . isUnresolved () || type . isTop ()
return ! type . isTop () && ( type . isNullable () || type . isVoidable () ) ;
targetType . isUnknownType () || targetType . isUnresolved () || targetType . isTop () || targetType . isEquivalentTo ( registry . getNativeType ( JSTypeNative.OBJECT_TYPE ) )
{ JSType type = n . getJSType () . restrictByNotNullOrUndefined () ; return type . isBottom () ; }
{ JSType type = n . getJSType () ; return type != null && type . isTop () ; }
if ( ft != null ) { functionNode . setJSType ( ft . convertMethodToFunction () ) ; }
if ( body . isBottom () || body . isEquivalentTo ( getObjectType () ) ) { continue; }
return result . isBottom () ? getUnknownType () : result ;
if ( type . isEnumElement () ) { return type . getEnumeratedTypeOfEnumElement () ; }
if ( objType . isPrototypeObject () ) { constructor = objType . getOwnerFunction () ; } else { constructor = objType . getConstructor () ; }
{ return type . isEnumObject () || type . isBoxableScalar () ; }
if ( type . isEnumElement () ) { return getTypesToSkipForType ( type . getEnumeratedTypeOfEnumElement () ) ; }
if ( ! t . isObjectType () || t . isTop () ) { return; }
type . isTop () || type . isUnknownType ()
type . isTop () || type . isUnknownType ()
public boolean isAbstract () { return isAbstract ; }
return treatThisTypesAsCovariant ( other , implicitImplCache ) && this . call . isSubtype ( other.call , implicitImplCache , subtypingMode ) ;
public ObjectType getPrototypeProperty () { return getPrototype () ; }
public boolean isReturnTypeInferred () { return call.returnTypeInferred ; }
public JSType getReturnType () { return call.returnType ; }
@ Override public boolean canBeCalled () { return true ; }
public void setDict () { propAccess = PropAccess.DICT ; }
public void setStruct () { propAccess = PropAccess.STRUCT ; }
return restricted . isBottom () ? type : restricted ;
retType != null && ! retType . isBottom () && ! funType . isInterface ()
ObjectType getReferencedObjTypeInternal () { return referencedObjType ; }
JSType getReferencedTypeInternal () { return referencedType ; }
if ( ! receiverType . meetWith ( type ) . isBottom () ) { return true ; }
@ Override public boolean matchesSymbolContext () { return true ; }
@ Override public boolean matchesStringContext () { return true ; }
@ Override public boolean matchesObjectContext () { return true ; }
@ Override public boolean matchesNumberContext () { return true ; }
@ Override public boolean isConstructor () { return false ; }
if ( type == null || type . isUnknownType () || type . isTop () ) { return allowLooseMatches ? MatchResult.LOOSE_MATCH : MatchResult.NO_MATCH ; }
propdef . setJSType ( null ) ;
visitImport ( t . getInput () . getPath () , n ) ;
@ Override public boolean isApplied ( CompilerOptions options ) { return options.crossModuleMethodMotion ; }
@ Override public boolean isApplied ( CompilerOptions options ) { return options.crossModuleCodeMotion ; }
ensureTyped ( t , n ) ;
{ ensureTyped ( t , name , valueType ) ; }
ensureTyped ( t , n ) ;
ensureTyped ( t , n ) ;
ensureTyped ( t , n , type ) ;
ensureTyped ( t , iterableNode ) ;
if ( ! options.checksOnly ) { passes . add ( lateConvertEs6ToEs3 ) ; }
if ( topScope == null ) { regenerateGlobalTypedScope ( compiler , root . getParent () ) ; } else { compiler . getTypeRegistry () . resolveTypesInScope ( topScope ) ; }
{ whitespaceOnlyPasses () ; if ( options . needsTranspilationFrom ( FeatureSet.ES6 ) ) { transpileAndDontCheck () ; } }
FeatureSet features = ( FeatureSet ) script . getProp ( Node.FEATURE_SET ) ;
body . isNormalBlock () && ! body . hasChildren ()
{ return ( n . isNormalBlock () && n . isSyntheticBlock () ) || n . isScript () ; }
checkState ( block . isNormalBlock () ) ;
if ( ! block . isNormalBlock () ) { return null ; }
stmt . isEmpty () || ( stmt . isNormalBlock () && ! stmt . hasChildren () )
{ checkState ( expr . isName () ) ; checkState ( body . isNormalBlock () ) ; return new Node ( Token.CATCH , expr , body ) ; }
checkState ( finallyBody . isNormalBlock () ) ;
checkState ( tryBody . isNormalBlock () ) ;
{ checkState ( body . isNormalBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
checkState ( body . isNormalBlock () ) ;
checkState ( body . isNormalBlock () ) ;
checkState ( body . isNormalBlock () ) ;
{ checkState ( body . isNormalBlock () ) ; checkState ( mayBeExpression ( cond ) ) ; return new Node ( Token.WHILE , cond , body ) ; }
{ checkState ( body . isNormalBlock () ) ; checkState ( mayBeExpression ( cond ) ) ; return new Node ( Token.DO , body , cond ) ; }
{ checkState ( mayBeExpression ( cond ) ) ; checkState ( then . isNormalBlock () ) ; return new Node ( Token.IF , cond , then ) ; }
checkState ( body . isNormalBlock () || mayBeExpression ( body ) ) ;
checkState ( body . isNormalBlock () ) ;
if ( n . isExprResult () || n . isNormalBlock () ) { return; }
if ( ! favorsCommaOverSemiColon && ! block . isNormalBlock () ) { return false ; }
! n . isNormalBlock ()
{ checkArgument ( blockNode . isNormalBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
if ( n . isNormalBlock () ) { visitBlock ( n ) ; }
! target . getParent () . isScript () && ! target . getParent () . isNormalBlock () && ! target . getParent () . isModuleBody ()
boolean isVar = NodeUtil . isNameDeclaration ( parent ) && parent . getParent () . isNormalBlock () ;
isGoogScopeFunctionBody ( enclosingFunctionBody ) && scopeRoot . isNormalBlock () && ! scopeRoot . getParent () . isFunction ()
if ( ! n . isNormalBlock () || ! n . hasChildren () || ! isGoogModuleCall ( n . getFirstChild () ) ) { return false ; }
{ checkArgument ( n . isNormalBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
checkState ( addingRoot . isNormalBlock () || addingRoot . isModuleBody () || addingRoot . isScript () ) ;
{ return n . isNormalBlock () && n . getParent () != null && n . getParent () . isFunction () ; }
checkState ( block . isNormalBlock () ) ;
{ return n . isRoot () || n . isScript () || n . isNormalBlock () || n . isModuleBody () ; }
if ( ! block . isNormalBlock () ) { return false ; }
NodeUtil . isControlStructureCodeBlock ( n , c ) && ! c . isNormalBlock ()
checkState ( body . getNext () == null && body . isNormalBlock () , body ) ;
if ( ! n . isFunction () || ! n . getLastChild () . isNormalBlock () ) { return; }
if ( ! subtree . isScript () && ! subtree . isNormalBlock () ) { return subtree ; }
checkState ( n . isNormalBlock () , n ) ;
if ( ! n . isNormalBlock () || ! n . hasChildren () ) { return; }
block . isNormalBlock () && block . getParent () . isTry () && block . getParent () . getFirstChild () == block
if ( parent . getParent () != null && parent . getParent () . isArrowFunction () && ! parent . isNormalBlock () ) { return false ; }
{ return getRootNode () . isNormalBlock () && getRootNode () . hasOneChild () && getRootNode () . getFirstChild () . isCatch () ; }
checkState ( block . isNormalBlock () ) ;
for ( Node child : node . children () ) { if ( child . isNormalBlock () ) { blocks . add ( child ) ; } }
n . isNormalBlock () && ! loneBlocks . isEmpty () && loneBlocks . peek () == n
( parent . isScript () || ( parent . isNormalBlock () && ! parent . isSyntheticBlock () && ! parent . isAddedBlock () ) )
scopeRoot . isNormalBlock () && scopeRoot . getParent () . isFunction ()
! setFunction . hasChildren () || ! setFunction . getLastChild () . isNormalBlock () || ! setFunction . getSecondChild () . isParamList ()
if ( ! getFunction . hasChildren () || ! getFunction . getLastChild () . isNormalBlock () ) { return false ; }
for ( ; ! currentParent . isScript () && ! currentParent . isNormalBlock () ; current = currentParent , currentParent = currentParent . getParent () ) {}
n . isFunction () && parent != null && parent . isNormalBlock () && ! parent . getParent () . isFunction ()
! n . getParent () . isScript () && ! n . getParent () . isNormalBlock ()
if ( body . isNormalBlock () ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
{ return n . isNormalBlock () && n . hasChildren () && isReturnTypeNullable ( n . getParent () ) && ! hasSingleThrow ( n ) ; }
if ( n . isEmpty () || ( n . isNormalBlock () && ! n . hasChildren () ) ) { return; }
next != null && next . isNormalBlock ()
checkArgument ( node . isNormalBlock () ) ;
node . isFunction () && ! NodeUtil . getFunctionBody ( node ) . isNormalBlock ()
! originalBody . isNormalBlock ()
checkState ( body . isNormalBlock () , body ) ;
checkState ( block . isNormalBlock () ) ;
checkState ( jumpBlock . isNormalBlock () ) ;
checkState ( block . isNormalBlock () ) ;
checkState ( catchBody . isNormalBlock () ) ;
context . transpileUnmarkedBlock ( n . isNormalBlock () || n . isAddedBlock () ? n : IR . block ( n ) ) ;
checkState ( newGeneratorHoistBlock . isNormalBlock () , newGeneratorHoistBlock ) ;
{ return node . getParent () . isExprResult () && node . getGrandparent () . isNormalBlock () && isClinitMethod ( node . getGrandparent () . getParent () ) ; }
! ( parent . isScript () || ( grandparent != null && grandparent . isFunction () && parent . isNormalBlock () ) )
! body . isNormalBlock () || body . hasChildren ()
if ( ! body . isNormalBlock () || ! body . hasOneChild () || ! body . getFirstChild () . isReturn () ) { return; }
! isArrow && ! isSignature && ! bodyNode . isNormalBlock ()
! irNode . isNormalBlock ()
n . isFunction () && n . getParent () . isNormalBlock () && ! n . getGrandparent () . isFunction ()
checkState ( ifBlock . isNormalBlock () , ifBlock ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( innerBlock . isNormalBlock () , innerBlock ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( block . isNormalBlock () , block ) ;
{ Node functionBody = NodeUtil . getFunctionBody ( n ) ; if ( ! functionBody . isNormalBlock () ) { return; } }
if ( node . isNormalBlock () ) { node . setToken ( Token.SCRIPT ) ; }
deleteWhitespaceBefore && parent != null && ( parent . isScript () || parent . isNormalBlock () )
checkState ( parentNode . isNormalBlock () , STRING_CONSTANT ) ;
parent != null && ( parent . isNormalBlock () || parent . isScript () )
if ( ! n . isScript () && ! n . isNormalBlock () ) { return; }
! body . isNormalBlock ()
! body . isNormalBlock ()
s . isFunctionScope () && s . getRootNode () . getLastChild () . isNormalBlock ()
n . isFunction () && ! NodeUtil . getFunctionBody ( n ) . isNormalBlock ()
checkState ( caseBody . isNormalBlock () , caseBody ) ;
! labeledStatement . isNormalBlock ()
if ( newChild . isNormalBlock () ) { NodeUtil . tryMergeBlock ( newChild , false ) ; }
JSType calleeTypeI = checkNotNull ( callee . getJSType () , callNode ) ;
assertFalse ( numbers . isSubtype ( EVAL_ERROR_TYPE ) ) ;
if ( ! languageOutIsAtLeast ( polyfill.polyfillVersion ) ) { traversal . report ( node , INSUFFICIENT_OUTPUT_VERSION_ERROR , name , compiler . getOptions () . getLanguageOut () . toString () ) ; }
if ( options . getLanguageOut () . toFeatureSet () . contains ( ES6 ) ) { passes . add ( optimizeToEs6 ) ; }
if ( options.dartPass && ! options . getLanguageOut () . toFeatureSet () . contains ( ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
checkState ( options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES5 ) , STRING_CONSTANT ) ;
FeatureSet languageOutFeatures = compiler . getOptions () . getLanguageOut () . toFeatureSet () ;
FeatureSet languageOutFeatures = compiler . getOptions () . getLanguageOut () . toFeatureSet () ;
{ if ( incrementalCheckMode == IncrementalCheckMode.GENERATE_IJS ) { return false ; } return this . quoteKeywordProperties || languageOut == LanguageMode.ECMASCRIPT3 ; }
{ return getLanguageIn () . toFeatureSet () . has ( feature ) && ! getLanguageOut () . toFeatureSet () . has ( feature ) ; }
{ return getLanguageIn () . toFeatureSet () . contains ( languageLevel ) && ! getLanguageOut () . toFeatureSet () . contains ( languageLevel ) ; }
{ checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
{ if ( outputTypes ) { return Format.TYPED ; } if ( prettyPrint || options . getLanguageOut () == LanguageMode.ECMASCRIPT6_TYPED ) { return Format.PRETTY ; } return Format.COMPACT ; }
public void testArrowception () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testArrowFunctionInObject () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . compiler = compiler ; this . thisContextStack = new ArrayDeque <> () ; }
private LocalScopeBuilder ( TypedScope scope ) { super ( scope ) ; thisTypeForProperties = getThisTypeForCollectingProperties () ; }
assertThat ( compiler . hasErrors () ) . isFalse () ;
{ if ( inTypeSummary ( error ) ) { return CheckLevel.WARNING ; } return null ; }
{ this . outputFeatureSet = featureSet ; }
@ JsOverlay public final List < T > asList () { return new JsArrayList < T > ( this ) ; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es7ToEs6Converter ( compiler ) ; }
GlobalScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder ( globalScope ) ;
{ return new ModulePath ( normalize ( ModuleNames . escapePath ( pathResolver . apply ( path ) ) , moduleRootPaths ) ) ; }
visitImport ( n ) ;
String path = ModuleNames . escapePath ( moduleAddress ) ;
String path = ModuleNames . escapePath ( moduleAddress ) ;
private void skipOctalDigits () { while ( isOctalDigit ( peekChar () ) ) { nextChar () ; } }
if ( ! currentInfo . isConstant () ) { currentInfo . setConstant ( true ) ; populated = true ; return true ; } else { return false ; }
assertThat ( jsdoc . isConstant () ) . isFalse () ;
isConst = nameNode . getParent () . isConst () || isExportLhs ( nameNode ) || ( jsdoc != null && jsdoc . hasConstAnnotation () )
final Token type
final String name
final String name
return parent == null || ! NodeUtil . createsScope ( n ) ;
JSType ownerType
{ currentModule . setModuleType ( ModuleType.COMMON_JS , t , n ) ; return; }
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . getGoogNamespaces () ) . isEmpty () ;
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
@ Nullable JSType ownerType
return shouldDescend ( n , parent ) ;
Token type
String name
String name
assertTypeEquals ( registry . createOptionalType ( STRING_TYPE ) , info . getParameterType ( STRING_CONSTANT ) ) ;
{ JSDocInfo info = parse ( STRING_CONSTANT ) ; assertTypeEquals ( registry . createOptionalType ( NUMBER_TYPE ) , info . getParameterType ( STRING_CONSTANT ) ) ; }
{ expandObjectLitAssignment ( t , root , export.scope ) ; return; }
@ JsMethod ( name = STRING_CONSTANT , namespace = STRING_CONSTANT )
{ validator . expectStringOrNumber ( t , n , leftType , STRING_CONSTANT ) ; }
return parent == null || ! NodeUtil . createsScope ( n ) ;
final Token type
final String name
final String name
JSType ownerType
@ JsMethod ( namespace = STRING_CONSTANT )
@ JsMethod ( name = STRING_CONSTANT , namespace = STRING_CONSTANT )
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , es6ModuleTranspiler , newMode , sourceUrl , path , sourceMapCache ) ; }
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , newMode , sourceUrl , path , sourceMapCache ) ; }
Node restRhs = newName ( this . rhsResultName ) ;
{ int baseHash = super . hashCode () ; if ( templateTypes . isEmpty () ) { return baseHash ; } return Objects . hash ( templateTypes , baseHash ) ; }
{ NodeTraversal . traverse ( compiler , rootNode , new CoverageInstrumentationCallback ( compiler , instrumentationData , reach ) ) ; }
abstract ImmutableSet.Builder < String > es6ImportSpecifiersBuilder ( ) ;
abstract ImmutableSet.Builder < String > requiredTypesBuilder ( ) ;
abstract ImmutableSet.Builder < String > googNamespacesBuilder ( ) ;
public void testSettersForbidden2 () { parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden4 () { parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden3 () { parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden2 () { parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ;
validateDefaultValue ( n , info ) ;
options . setTranspileEs6ModulesToCjsModules ( true ) ;
@ Override public boolean isVarArgsParameter ( Node parameter ) { return parameter . isVarArgs () ; }
{ if ( ! isParsed () ) { parse ( compiler ) ; root . setInputId ( inputId ) ; } return root ; }
this . root = root ;
Node originalRoot = input . getAstRoot ( this ) ;
return input . getAstRoot ( this ) ;
findDeps . process ( input . getAstRoot ( this ) ) ;
Node root = input . getAstRoot ( this ) ;
return root ;
if ( ! options.checksOnly ) { passes . add ( es6RewriteRestAndSpread ) ; }
{ matchedNodeInfo = MatchedNodeInfo . create ( node , isInClosurizedFile ( node , new NodeMetadata ( compiler ) ) ) ; return this ; }
validateRest ( type , c ) ;
validateRest ( type , c ) ;
{ validateRest ( Token.PARAM_LIST , c ) ; }
public void disabled_testForOf4 () { testTypes ( STRING_CONSTANT ) ; }
AbstractCommandLineRunner () { this ( System.in , System.out , System.err ) ; }
boolean shouldDeclareOnGlobalThis = isGlobalVar && ( NodeUtil . isNameDeclaration ( parent ) || parent . isFunction () ) ;
JSType maybeThisType = info . getThisType () . evaluate ( scope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( scope , typeRegistry ) ; returnTypeInferred = false ; }
JSType maybeThisType = info . getThisType () . evaluate ( templateScope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( templateScope , typeRegistry ) ; returnTypeInferred = false ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , new GeneratorFunctionsTranspiler () ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , new GeneratorFunctionsTranspiler () ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
if ( ! compiler . hasHaltingErrors () ) { TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , features ) ; }
checkState ( source . isFunction () , source ) ;
JSType returnType = explicitReturnExpected ( n ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new Es6RewriteImportPaths ( compiler ) ; }
case RESOLVE_IMPORT_PATHS :
SourceFile expectedEs6 = SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ;
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new Es6RewriteClass ( compiler , true ) ; }
public void testSpreadLibInjection () { testSame ( STRING_CONSTANT ) ; assertThat ( getLastCompiler () . injected ) . containsExactly ( STRING_CONSTANT ) ; }
{ JSType referencedType = getReferencedType () ; if ( referencedType == this ) { handleTypeCycle ( reporter ) ; } }
if ( this == that ) { return true ; }
public final boolean isGlobalThisType () { return this == registry . getNativeType ( JSTypeNative.GLOBAL_THIS ) ; }
public final boolean isUnresolvedOrResolvedUnknown () { return isNoResolvedType () || isNamedType () && isUnknownType () ; }
assertTrue ( objectType . getImplicitPrototype () == OBJECT_TYPE ) ;
defineVar ( n ) ;
defineVars ( n ) ;
if ( context . isAsyncContext () ) { convertAsyncFunction ( context ) ; }
JSType maybeThisType = info . getThisType () . evaluate ( scope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( scope , typeRegistry ) ; returnTypeInferred = false ; }
seenNames . add ( nameNode . getQualifiedName () ) ;
{ if ( seenNames . contains ( nameNode . getQualifiedName () ) ) { return RemovalType.REMOVE_ALL ; } jsdocNode . setJSDocInfo ( getAllTypeJSDoc () ) ; return RemovalType.REMOVE_RHS ; }
NodeTraversal . traverseEs6 ( compiler , root , new RemoveCode ( compiler ) ) ;
