{ super . setZoneRetainFields ( zone ) ; }
if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING_CONSTANT ) ) ; }
{ super ( instant ) ; }
{ super ( chronology ) ; }
{ return getField () . getAsShortText ( getReadablePartial () , get () , locale ) ; }
{ return getField () . getAsText ( getReadablePartial () , get () , locale ) ; }
public int getMaximumValue ( ReadablePartial instant ) { throw unsupported () ; }
public int getMinimumValue ( ReadablePartial instant ) { throw unsupported () ; }
{ test1 . millisOfSecond () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
{ test1 . secondOfMinute () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
{ test1 . minuteOfHour () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
{ test1 . hourOfDay () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
public int getMinimumValue ( ReadablePartial instant ) { return NUMBER_CONSTANT ; }
{ test1 . dayOfMonth () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
{ test1 . monthOfYear () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
{ test1 . year () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
public int getMaximumValue ( ReadablePartial instant , int [] values ) { return iField . getMaximumValue ( instant , values ) ; }
public int getMaximumValue ( ReadablePartial instant ) { return iField . getMaximumValue ( instant ) ; }
public int getMinimumValue ( ReadablePartial instant , int [] values ) { return iField . getMinimumValue ( instant , values ) ; }
public int getMinimumValue ( ReadablePartial instant ) { return iField . getMinimumValue ( instant ) ; }
{ t = new DateTimeFormatterBuilder ( iChrono ) . append ( hourMinuteSecondMillis () ) . append ( offsetElement () ) . toFormatter () ; }
iChronology = selectChronology ( converter . getChronology ( instant ) ) ;
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField hours () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField days () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField weeks () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField months () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField years () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
{ return getField () . remainder ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMaximumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMinimumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getLeapAmount ( getReadableInstant () . getMillis () ) ; }
{ return getField () . isLeap ( getReadableInstant () . getMillis () ) ; }
return getField () . getDifferenceAsLong ( getReadableInstant () . getMillis () , instant . getMillis () ) ;
return getField () . getDifference ( getReadableInstant () . getMillis () , instant . getMillis () ) ;
{ return getField () . getAsShortText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . getAsText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . get ( getReadableInstant () . getMillis () ) ; }
iMillis = round ( converter . getInstantMillis ( instant , chronology ) , iChronology ) ;
iMillis = round ( converter . getInstantMillis ( instant , zone ) , iChronology ) ;
iMillis = round ( converter . getInstantMillis ( instant ) , iChronology ) ;
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
{ long instant = getChronology () . getDateTimeMillis ( getMillis () , hour , minuteOfHour , secondOfMinute , millisOfSecond ) ; setMillis ( instant ) ; }
withUTC () . dayOfYear () . remainder ( iCutoverMillis ) == NUMBER_CONSTANT
return getDateMidnightMillis ( year , monthOfYear , dayOfMonth ) + millisOfDay ;
assertEquals ( ( NUMBER_CONSTANT - NUMBER_CONSTANT ) * DateTimeConstants.MILLIS_PER_DAY , test . monthOfYear () . remainder () ) ;
{ if ( chrono == getChronology () ) { return this ; } return MaskedType . mask ( iType . withChronology ( chrono ) , iMask ) ; }
if ( isPrecise () ) { return FieldUtils . safeAdd ( instant , getTotalMillis () * scalar ) ; }
{ MutableDuration test = new MutableDuration () ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( duration , type , false ) ; }
{ super ( duration , null , false ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( duration , type , false ) ; }
{ super ( duration , null , false ) ; }
public void testGetDurationType_Object ( ) throws Exception { assertEquals ( null , NullConverter.INSTANCE . getDurationType ( null ) ) ; }
{ convId = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return fixedOffsetZone ( convId , offset ) ; }
{ id = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return fixedOffsetZone ( id , offset ) ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getYearWeekType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getYearMonthType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getAllType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getDayHourType () ; }
type = ( type == null ? converter . getDurationType ( duration , totalMillisMaster ) : type ) ;
{ return ( ( ReadableDuration ) object ) . getMillis () ; }
{ try { new MutableTimePeriod ( DurationType . getAllType () , true ) ; fail () ; } catch ( IllegalArgumentException ex ) {} }
{ TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
{ MutableTimePeriod test = new MutableTimePeriod () ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
public void setInto ( ReadWritableTimePeriod duration , Object object ) {}
public void setInto ( ReadWritableTimePeriod duration , Object object ) {}
public void setInto ( ReadWritableTimePeriod duration , Object object ) {}
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( DurationType . getMillisType () ) ) ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
{ DurationConverter [] array = ConverterManager . getInstance () . getDurationConverters () ; assertEquals ( DURATION_SIZE , array.length ) ; }
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
{ add ( new TimePeriod ( duration , getDurationType () ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () , getDurationType () ) ) ; } }
{ return new TimePeriod ( toDurationMillis () , getPeriodType () ) ; }
{ add ( new TimePeriod ( duration , getPeriodType () ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () , getPeriodType () ) ) ; } }
{ if ( interval != null ) { add ( interval . toTimePeriod ( getPeriodType () ) ) ; } }
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
PeriodType type
PeriodType type
PeriodType type
if ( ! mustParse && ! isSupported ( period . getPeriodType () ) ) { return position ; }
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getMillisType () ) ;
TimePeriodConverter c = ConverterManager . getInstance () . getTimePeriodConverter ( new TimePeriod ( PeriodType . getMillisType () ) ) ;
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( PeriodType . getMillisType () ) ) ;
MillisDuration base = new MillisDuration ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getDayHourType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
PeriodType type
PeriodType type
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getMillisType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearWeekType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearWeekType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
assertEquals ( test . getPeriodType () , copy . getPeriodType () ) ;
assertEquals ( test . getPeriodType () , copy . getPeriodType () ) ;
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getMillisType () ) ;
ReadablePeriod period
ReadablePeriod period
c = ConverterManager . getInstance () . getDurationConverter ( new Period ( PeriodType . getMillisType () ) ) ;
{ MutablePeriod test = new MutablePeriod () ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
ReadablePeriod period
ReadablePeriod period
public void testSetDuration_RD () { setPeriod ( ( ReadableDuration ) null ) ; }
{ Period test = new Period ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( length , null ) ;
MutablePeriod test = new MutablePeriod ( length ) ;
MutablePeriod test = new MutablePeriod ( length ) ;
MutablePeriod test = new MutablePeriod () ;
{ return STRING_CONSTANT + iInstantConverters . size () + STRING_CONSTANT + iDurationConverters . size () + STRING_CONSTANT + iPeriodConverters . size () + STRING_CONSTANT + iIntervalConverters . size () + STRING_CONSTANT ; }
ReadablePeriod period
ReadablePeriod period
Period duration ;
Class cls = ReadablePeriodConverter . class ;
{ return PRECISE_YEAR_WEEK ; }
{ return PRECISE_YEAR_MONTH ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearWeekTypeUTC () ; }
{ return YEAR_WEEK ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearMonthTypeUTC () ; }
{ return YEAR_MONTH ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getAllTypeUTC () ; }
{ return ALL ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
{ long durationMillis = DateTimeUtils . getDurationMillis ( duration ) ; setStartMillis ( FieldUtils . safeAdd ( getEndMillis () , - durationMillis ) ) ; }
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
Object duration
{ super . setStartMillis ( startInstant ) ; }
public void normalize () { setPeriod ( toDurationMillis () ) ; }
{ return new MutableDateTime ( getMillis () , chronology ) ; }
{ long instant = getChronology () . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; setMillis ( instant ) ; }
{ super ( partial , values ) ; }
{ super ( partial , values ) ; }
{ Chronology chrono = getChronology () . withZone ( zone ) ; return resolve ( baseInstant , chrono ) ; }
BaseGJChronology chronology
BaseGJChronology chronology
GJYearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
GJMonthOfYearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
BaseGJChronology chrono = iChronology ;
CopticYearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
BaseGJChronology chronology
GJWeekyearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
BaseGJChronology chronology
NoWeekyearZeroField ( BaseGJChronology chronology , DateTimeField field ) { super ( chronology , field ) ; }
BaseGJChronology chronology
{ millis = getField ( i , chrono ) . set ( millis , getValue ( i ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendSuffix ( new SimpleAffix ( text ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendPrefix ( new SimpleAffix ( text ) ) ; }
PeriodFieldAffix affix ;
PeriodFieldAffix affix ;
PeriodFieldAffix affix ;
PeriodFieldAffix suffix
int scan ( String periodStr , int position ) ;
int parse ( String periodStr , int position ) ;
PeriodFieldAffix suffix
PeriodFieldAffix prefix
{ if ( iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue ( period ) != Long.MAX_VALUE ) { return NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
public PeriodFormatterBuilder appendMillis () { appendField ( MILLIS ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithOptionalMillis () { appendField ( SECONDS_OPTIONAL_MILLIS ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithMillis () { appendField ( SECONDS_MILLIS ) ; return this ; }
public PeriodFormatterBuilder appendSeconds () { appendField ( SECONDS ) ; return this ; }
public PeriodFormatterBuilder appendMinutes () { appendField ( MINUTES ) ; return this ; }
public PeriodFormatterBuilder appendHours () { appendField ( HOURS ) ; return this ; }
public PeriodFormatterBuilder appendDays () { appendField ( DAYS ) ; return this ; }
public PeriodFormatterBuilder appendWeeks () { appendField ( WEEKS ) ; return this ; }
public PeriodFormatterBuilder appendMonths () { appendField ( MONTHS ) ; return this ; }
public PeriodFormatterBuilder appendYears () { appendField ( YEARS ) ; return this ; }
DateTimeFieldType lowerLimit
public static DateTimeComparator getInstance () { return ALL_INSTANCE ; }
{ super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
if ( iParseField == null ) { iParseField = new PreciseDateTimeField ( DateTimeFieldType . millisOfSecond () , MillisDurationField.INSTANCE , iField . getDurationField () ) ; }
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . dayOfMonth () , days ) ; iChronology = chronology ; }
public TestGJYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . year () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . weekOfWeekyear () , weeks ) ; iChronology = chronology ; }
private ISOYearOfEraDateTimeField () { super ( GregorianChronology . getInstanceUTC () . year () , DateTimeFieldType . yearOfEra () ) ; }
{ super ( DateTimeFieldType . dayOfWeek () , days ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chrono . millisPerMonth () , chrono ) ; }
{ super ( field , field . getType () ) ; iDurationField = durationField ; iRangeDurationField = rangeDurationField ; iLeapDurationField = leapDurationField ; }
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . dayOfYear () , days ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . dayOfMonth () , days ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . monthOfYear () , months ) ; iChronology = chronology ; }
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( DateTimeFieldType . era () ) ; iChronology = chronology ; }
public DateTimeField year () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . year () , years () ) ; }
public DateTimeField monthOfYear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . monthOfYear () , months () ) ; }
public DateTimeField weekyear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . weekyear () , weekyears () ) ; }
public DateTimeField weekOfWeekyear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . weekOfWeekyear () , weeks () ) ; }
public DateTimeField dayOfYear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . dayOfYear () , days () ) ; }
public DateTimeField dayOfMonth () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . dayOfMonth () , days () ) ; }
public DateTimeField clockhourOfHalfday () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . clockhourOfHalfday () , hours () ) ; }
public DateTimeField hourOfHalfday () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . hourOfHalfday () , hours () ) ; }
public DateTimeField clockhourOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . clockhourOfDay () , hours () ) ; }
public DateTimeField hourOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . hourOfDay () , hours () ) ; }
public DateTimeField minuteOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . minuteOfDay () , minutes () ) ; }
public DateTimeField minuteOfHour () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . minuteOfHour () , minutes () ) ; }
public DateTimeField secondOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . secondOfDay () , seconds () ) ; }
public DateTimeField secondOfMinute () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . secondOfMinute () , seconds () ) ; }
public DateTimeField millisOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . millisOfDay () , millis () ) ; }
public DateTimeField millisOfSecond () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . millisOfSecond () , millis () ) ; }
{ super ( yearField , DateTimeFieldType . yearOfEra () ) ; iChronology = chronology ; }
LinkedDurationField ( DurationField durationField , ImpreciseCutoverField dateTimeField ) { super ( durationField , durationField . getType () ) ; iField = dateTimeField ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , chrono.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , chrono.MILLIS_PER_DAY , chrono ) ; }
public String toString () { return STRING_CONSTANT + getName () + CHAR_CONS ; }
{ super ( DateTimeFieldType . year () , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . year () , chrono . millisPerYear () , chrono ) ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , NUMBER_CONSTANT ) ;
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , chrono.MILLIS_PER_DAY , chrono ) ; }
super ( field . getType () ) ;
{ super ( DateTimeFieldType . year () , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . weekyear () , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . weekyear () , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , NUMBER_CONSTANT ) ;
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . millis () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . seconds () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . minutes () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . hours () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . days () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . weeks () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . months () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . years () ) ; }
{ super ( chrono ) ; iMonths = new ScaledDurationField ( chrono . days () , DurationFieldType . months () , NUMBER_CONSTANT ) ; }
{ super ( chrono ) ; iYears = new ScaledDurationField ( chrono . days () , DurationFieldType . years () , NUMBER_CONSTANT ) ; }
fields.centuryOfEra = new DividedDateTimeField ( ISOYearOfEraDateTimeField.INSTANCE , DateTimeFieldType . centuryOfEra () , NUMBER_CONSTANT ) ;
{ super ( DateTimeFieldType . monthOfYear () , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . monthOfYear () , chrono . millisPerMonth () , chrono ) ; }
int [] values = new int [ size () ] ;
int i = NUMBER_CONSTANT , isize = size ()
public int size () { return NUMBER_CONSTANT ; }
public int size () { return getFields () . length ; }
public static DateTimeFieldType era () { return ERA_TYPE ; }
public static DateTimeFieldType centuryOfEra () { return CENTURY_OF_ERA_TYPE ; }
public static DateTimeFieldType yearOfCentury () { return YEAR_OF_CENTURY_TYPE ; }
public static DateTimeFieldType yearOfEra () { return YEAR_OF_ERA_TYPE ; }
public static DateTimeFieldType year () { return YEAR_TYPE ; }
public static DateTimeFieldType monthOfYear () { return MONTH_OF_YEAR_TYPE ; }
public static DateTimeFieldType weekyearOfCentury () { return WEEKYEAR_OF_CENTURY_TYPE ; }
public static DateTimeFieldType weekyear () { return WEEKYEAR_TYPE ; }
public static DateTimeFieldType weekOfWeekyear () { return WEEK_OF_WEEKYEAR_TYPE ; }
public static DateTimeFieldType dayOfYear () { return DAY_OF_YEAR_TYPE ; }
public static DateTimeFieldType dayOfMonth () { return DAY_OF_MONTH_TYPE ; }
public static DateTimeFieldType dayOfWeek () { return DAY_OF_WEEK_TYPE ; }
public static DateTimeFieldType halfdayOfDay () { return HALFDAY_OF_DAY_TYPE ; }
public static DateTimeFieldType clockhourOfHalfday () { return CLOCKHOUR_OF_HALFDAY_TYPE ; }
public static DateTimeFieldType hourOfHalfday () { return HOUR_OF_HALFDAY_TYPE ; }
public static DateTimeFieldType clockhourOfDay () { return CLOCKHOUR_OF_DAY_TYPE ; }
public static DateTimeFieldType hourOfDay () { return HOUR_OF_DAY_TYPE ; }
public static DateTimeFieldType minuteOfDay () { return MINUTE_OF_DAY_TYPE ; }
public static DateTimeFieldType minuteOfHour () { return MINUTE_OF_HOUR_TYPE ; }
public static DateTimeFieldType secondOfDay () { return SECOND_OF_DAY_TYPE ; }
public static DateTimeFieldType secondOfMinute () { return SECOND_OF_MINUTE_TYPE ; }
public static DateTimeFieldType millisOfDay () { return MILLIS_OF_DAY_TYPE ; }
public static DateTimeFieldType millisOfSecond () { return MILLIS_OF_SECOND_TYPE ; }
int otherValue = getFieldType () . getField ( chrono ) . get ( instant . getMillis () ) ;
public static DurationFieldType eras () { return ERAS_TYPE ; }
public static DurationFieldType centuries () { return CENTURIES_TYPE ; }
public static DurationFieldType years () { return YEARS_TYPE ; }
public static DurationFieldType months () { return MONTHS_TYPE ; }
public static DurationFieldType weekyears () { return WEEKYEARS_TYPE ; }
public static DurationFieldType weeks () { return WEEKS_TYPE ; }
public static DurationFieldType days () { return DAYS_TYPE ; }
public static DurationFieldType halfdays () { return HALFDAYS_TYPE ; }
public static DurationFieldType hours () { return HOURS_TYPE ; }
public static DurationFieldType minutes () { return MINUTES_TYPE ; }
public static DurationFieldType seconds () { return SECONDS_TYPE ; }
public static DurationFieldType millis () { return MILLIS_TYPE ; }
assertEquals ( false , test . isAfter ( ( ReadableInstant ) null ) ) ;
assertEquals ( false , test . isBefore ( ( ReadableInstant ) null ) ) ;
assertEquals ( false , test . isAfter ( ( ReadableInstant ) null ) ) ;
assertEquals ( false , test . isBefore ( ( ReadableInstant ) null ) ) ;
{ if ( instant == null ) { return isAfterNow () ; } return isAfter ( instant . getMillis () ) ; }
{ if ( instant == null ) { return isBeforeNow () ; } return isBefore ( instant . getMillis () ) ; }
{ if ( instant == null ) { return containsNow () ; } return contains ( instant . getMillis () ) ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . dayTime () ) ) ) ;
{ Period test = new Period ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . standard () , test . getPeriodType () ) ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
test = new MutablePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . millis () ) ;
{ super . setField ( DurationFieldType . millis () , millis ) ; }
{ super . setField ( DurationFieldType . seconds () , seconds ) ; }
{ super . setField ( DurationFieldType . minutes () , minutes ) ; }
{ super . setField ( DurationFieldType . hours () , hours ) ; }
{ super . setField ( DurationFieldType . days () , days ) ; }
{ super . setField ( DurationFieldType . weeks () , weeks ) ; }
{ super . setField ( DurationFieldType . months () , months ) ; }
{ super . setField ( DurationFieldType . years () , years ) ; }
{ super ( period , type , null ) ; }
{ super ( period , null , null ) ; }
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . dayTime () ) ) ) ;
{ MutablePeriod test = new MutablePeriod () ; assertEquals ( PeriodType . standard () , test . getPeriodType () ) ; }
{ super ( period , type , null ) ; }
{ super ( period , null , null ) ; }
{ if ( period != null ) { setMillis ( period . addTo ( getMillis () , scalar , getChronology () ) ) ; } }
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
{ test1 . year () . compareTo ( ( ReadableInstant ) null ) ; fail () ; }
assertEquals ( PeriodType . standard () , test . getPeriodType () ) ;
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setStartMillis ( chrono . add ( getEndMillis () , period , - NUMBER_CONSTANT ) ) ; }
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setEndMillis ( chrono . add ( getStartMillis () , period , NUMBER_CONSTANT ) ) ; }
{ if ( period != null ) { setMillis ( getChronology () . add ( getMillis () , period , scalar ) ) ; } }
assertEquals ( PeriodType . standard () , test . getPeriodType () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , millis } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , seconds , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , minutes , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , hours , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , days , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , weeks , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , months , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
new Period ( new int [] { years , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () )
{ duration . setPeriod ( ( Period ) null ) ; }
iIntervalConverters = new ConverterSet ( new Converter [] { ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
{ super . setInterval ( getStartMillis () , endInstant , getChronology () ) ; }
{ super . setInterval ( startInstant , getEndMillis () , getChronology () ) ; }
public long toDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
{ IntervalConverter [] array = ConverterManager . getInstance () . getIntervalConverters () ; assertEquals ( INTERVAL_SIZE , array.length ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
public long toDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
{ MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . toDuration () ) ; }
{ test . withEnd ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withEnd ( new Instant ( TEST_TIME2 - NUMBER_CONSTANT ) ) ;
{ test . withStart ( new Instant ( TEST_TIME2 + NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withStart ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ;
{ Interval test = new Interval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . toDuration () ) ; }
{ return ( ( ( ReadableInterval ) object ) ) . toDurationMillis () ; }
{ Chronology chrono = getChronology () . withZone ( zone ) ; return chrono . set ( this , baseInstant ) ; }
{ if ( period != null ) { setMillis ( getChronology () . add ( period , getMillis () , scalar ) ) ; } }
if ( period == null ) { iStartMillis = iEndMillis ; } else { iStartMillis = chrono . add ( period , iEndMillis , - NUMBER_CONSTANT ) ; }
if ( period == null ) { iEndMillis = iStartMillis ; } else { iEndMillis = chrono . add ( period , iStartMillis , NUMBER_CONSTANT ) ; }
{ if ( period == null ) { setValues ( new int [ size () ] ) ; } else { setPeriodInternal ( period ) ; } }
{ setStartMillis ( getChronology () . add ( period , getEndMillis () , - NUMBER_CONSTANT ) ) ; }
{ if ( period != null ) { super . addPeriod ( period ) ; } }
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
{ if ( partial == null ) { return this ; } return withMillis ( getChronology () . set ( partial , getMillis () ) ) ; }
{ long millis = this . iChrono . withUTC () . set ( partial , NUMBER_CONSTANT ) ; printTo ( null , out , millis ) ; }
long millis = this . iChrono . withUTC () . set ( partial , NUMBER_CONSTANT ) ;
{ return new Period ( getStartMillis () , getEndMillis () , type , getChronology () ) ; }
{ return new Period ( getStartMillis () , getEndMillis () , getChronology () ) ; }
{ return new MutableInterval ( getStartMillis () , getEndMillis () , getChronology () ) ; }
{ return new Interval ( getStartMillis () , getEndMillis () , getChronology () ) ; }
Interval test4 = new Interval ( TEST_TIME1 , TEST_TIME2 , Chronology . getGJ () ) ;
{ if ( endInstant == getEndMillis () ) { return this ; } return new Interval ( getStartMillis () , endInstant , getChronology () ) ; }
{ if ( startInstant == getStartMillis () ) { return this ; } return new Interval ( startInstant , getEndMillis () , getChronology () ) ; }
Object f
Object f
Object f
public DateTimeFormatterBuilder appendMonthOfYearShortText () { return appendShortText ( DateTimeFieldType . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearText () { return appendText ( DateTimeFieldType . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekShortText () { return appendShortText ( DateTimeFieldType . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekText () { return appendText ( DateTimeFieldType . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendHalfdayOfDayText () { return appendText ( DateTimeFieldType . halfdayOfDay () ) ; }
String text
Object element
DateTimeParser parser
DateTimeParser parser
DateTimePrinter printer
DateTimeFormatter formatter
Chronology chrono
DateTimeZone zone
public MutableDateTime parseMutableDateTime ( String text ) { return mParser . parseMutableDateTime ( text ) ; }
public DateTime parseDateTime ( String text ) { return mParser . parseDateTime ( text ) ; }
public long parseMillis ( String text ) { return mParser . parseMillis ( text ) ; }
public String print ( long instant ) { throw unsupported () ; }
public String print ( ReadableInstant instant ) { throw unsupported () ; }
public MutableDateTime parseMutableDateTime ( String text ) { throw unsupported () ; }
public DateTime parseDateTime ( String text ) { throw unsupported () ; }
public long parseMillis ( String text ) { throw unsupported () ; }
public String print ( long instant ) { return mPrinter . print ( instant ) ; }
public String print ( ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
FPrinter ( DateTimePrinter printer ) { super(); mPrinter = printer ; }
iMillis = converter . getInstantMillis ( instant , Chronology . getISOUTC () ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
{ PartialConverter [] array = ConverterManager . getInstance () . getPartialConverters () ; assertEquals ( PARTIAL_SIZE , array.length ) ; }
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
iPartialConverters = new ConverterSet ( new Converter [] { ReadablePartialConverter.INSTANCE , ReadableInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , UnsupportedDurationField . getInstance ( getDurationType () ) ) ; }
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , UnsupportedDurationField . getInstance ( getDurationType () ) ) ; }
throw new InternalError () ;
try { MillisDurationField.INSTANCE . getDifferenceAsLong ( Long.MAX_VALUE , - NUMBER_CONSTANT ) ; fail () ; } catch ( ArithmeticException ex ) {}
BaseDateTimeField field = new MockStandardBaseDateTimeField () ;
PreciseDateTimeField field = new MockPreciseDateTimeField () ;
{ convId = printTimeZone ( offset ) ; return fixedOffsetZone ( convId , offset ) ; }
BasePeriodFormatter [] parsers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
Separator finish ( BasePeriodFormatter after ) { iAfter = after ; return this ; }
BasePeriodFormatter before
DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder ( iLocale ) ;
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket = new ParseBucket ( instantLocal , chrono ) ;
ParseBucket bucket = new ParseBucket ( NUMBER_CONSTANT , chrono ) ;
ParseBucket bucket = new ParseBucket ( instantLocal , chrono ) ;
{ if ( permission instanceof JodaTimePermission ) { return false ; } return true ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return true ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return true ; }
int offset = - ( int ) offsetFormatter () . parseMillis ( convId , ISOChronology . getInstance ( UTC ) ) ;
int offset = - ( int ) offsetFormatter () . parseMillis ( id , ISOChronology . getInstance ( UTC ) ) ;
return printOffset ( getOffset ( instant ) ) ;
return new MutableDateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new MutableDateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , chrono ) , chrono ) ; }
return new DateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new DateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , chrono ) , chrono ) ; }
return ( ( DateTimePrinter ) this ) . print ( millis , chrono ) ;
( ( DateTimePrinter ) this ) . printTo ( out , millis , chrono ) ;
( ( DateTimePrinter ) this ) . printTo ( buf , millis , chrono ) ;
public MutableDateTime parseMutableDateTime ( String text , ReadableInstant instant ) { return iParser . parseMutableDateTime ( text , instant ) ; }
public MutableDateTime parseMutableDateTime ( String text , Chronology chrono ) { return iParser . parseMutableDateTime ( text , chrono ) ; }
public DateTime parseDateTime ( String text , ReadableInstant instant ) { return iParser . parseDateTime ( text , instant ) ; }
public DateTime parseDateTime ( String text , Chronology chrono ) { return iParser . parseDateTime ( text , chrono ) ; }
public String print ( long instant , Chronology chrono ) { return iPrinter . print ( instant , chrono ) ; }
public String print ( long instant , DateTimeZone zone ) { return iPrinter . print ( instant , zone ) ; }
public void printTo ( Writer out , long instant ) throws IOException { iPrinter . printTo ( out , instant ) ; }
public int estimateParsedLength () { return iParsedLengthEstimate ; }
public int estimateParsedLength () { return iParsedLengthEstimate ; }
DateTimePrinter [] elements = iPrinters ;
DateTimePrinter [] elements = iPrinters ;
public int estimatePrintedLength () { return iPrintedLengthEstimate ; }
public int estimatePrintedLength () { return iShortFormat ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
public int estimateParsedLength () { return iMaxDigits ; }
public int estimatePrintedLength () { return iMaxDigits ; }
public int estimatePrintedLength () { return iShort ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
public int estimatePrintedLength () { return NUMBER_CONSTANT ; }
public int estimateParsedLength () { return NUMBER_CONSTANT ; }
public int estimatePrintedLength () { return iMaxParsedDigits ; }
public int estimatePrintedLength () { return iMaxParsedDigits ; }
public int estimateParsedLength () { return iMaxParsedDigits ; }
DateTimeParserBucket bucket
public int estimateParsedLength () { return NUMBER_CONSTANT ; }
PeriodFormatter [] parsers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
Separator finish ( PeriodFormatter after ) { iAfter = after ; return this ; }
PeriodFormatter before
{ return getField () . getMaximumValue ( getMillis () ) ; }
{ return getField () . getMinimumValue ( getMillis () ) ; }
{ return getField () . getLeapAmount ( getMillis () ) ; }
{ return getField () . isLeap ( getMillis () ) ; }
{ return getField () . getAsShortText ( getMillis () , locale ) ; }
{ return getField () . getAsText ( getMillis () , locale ) ; }
{ return getField () . get ( getMillis () ) ; }
iChronology = ISOChronology . getInstance ( DateTimeZone . forID ( id ) ) ;
zones [ i ++ ] = new ZoneData ( id , DateTimeZone . forID ( id ) ) ;
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , TestGJChronology.MILLIS_PER_DAY , chrono ) ; }
int dayOfWeek = ( int ) TestGJChronology . mod ( iChronology . fixedFromMillis ( millis ) , NUMBER_CONSTANT ) ;
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , TestGJChronology.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , TestGJChronology.MILLIS_PER_DAY , chrono ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . withLocale ( locale ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . print ( this ) ; }
return - ( int ) offsetFormatter () . withChronology ( chrono ) . parseMillis ( str ) ;
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . withLocale ( locale ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . print ( this ) ; }
return cOffsetFormatter . withZone ( iZone ) . print ( millis ) ;
DateTimeFormatter p
{ return append0 ( new TimeZonePrinter ( false ) , null ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , true ) ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , false ) ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter () , formatter . getParser () ) ; }
append0 ( formatter . getPrinter () , formatter . getParser () ) ;
public PeriodParser toParser () { return toFormatter () . getParser () ; }
public PeriodPrinter toPrinter () { return toFormatter () . getPrinter () ; }
InputStream in = new ByteArrayInputStream ( data . getBytes ( STRING_CONSTANT ) ) ;
Locale locale
Locale locale
Locale locale
Locale locale
{ if ( iChrono == chrono ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , iOffsetParsed , chrono , iZone , iPivotYear ) ; }
{ if ( iOffsetParsed == true ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , true , iChrono , null , iPivotYear ) ; }
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalFieldValueException ( DateTimeFieldType . era () , text ) ; } return instant ; }
catch ( NumberFormatException ex ) { throw new IllegalFieldValueException ( getType () , text ) ; }
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalFieldValueException ( DateTimeFieldType . era () , text ) ; } return instant ; }
throw new IllegalFieldValueException ( DateTimeFieldType . halfdayOfDay () , text ) ;
throw new IllegalFieldValueException ( DateTimeFieldType . dayOfWeek () , text ) ;
throw new IllegalFieldValueException ( DateTimeFieldType . monthOfYear () , text ) ;
throw new IllegalFieldValueException ( DateTimeFieldType . era () , text ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
public int getMinimumDaysInFirstWeek () { return iMinDaysInFirstWeek ; }
Period test = new Period ( length , PeriodType . standard () , ISOChronology . getInstanceUTC () ) ;
Period test = new Period ( length , PeriodType . time () . withMillisRemoved () , ISOChronology . getInstance () ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( ISOChronology . getInstance () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == ISOChronology . getInstance () . minutes () . hashCode () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( - NUMBER_CONSTANT , MillisDurationField.INSTANCE . compareTo ( ISOChronology . getInstance () . seconds () ) ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( ISOChronology . getInstance () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == ISOChronology . getInstance () . minutes () . hashCode () ) ;
{ FieldUtils . verifyValueBounds ( ISOChronology . getInstance () . monthOfYear () , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail () ; }
Chronology chrono = ISOChronology . getInstance ( ZONES [ i ] ) ;
actual = ReadablePartialConverter.INSTANCE . getPartialValues ( tod , new TimeOfDay ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , ISOChronology . getInstance ( PARIS ) )
int [] actual = NullConverter.INSTANCE . getPartialValues ( tod , null , ISOChronology . getInstance () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
int [] actual = StringConverter.INSTANCE . getPartialValues ( tod , STRING_CONSTANT , ISOChronology . getInstance () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , ISOChronology . getInstanceUTC () ) ;
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , ISOChronology . getInstance () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . standard () , ISOChronology . getInstanceUTC () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . time () . withMillisRemoved () , ISOChronology . getInstance () ) ;
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
public Chronology getChronology () { return ChronologyType . iso () . getChronologyUTC () ; }
iMillis = converter . getInstantMillis ( instant , ChronologyType . iso () . getChronologyUTC () ) ;
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = ChronologyType . iso () . getChronology () ; }
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
iZone = zone ;
iZone = zone ;
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiply ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . addWrapPartial ( this , index , newValues , FieldUtils . safeMultiply ( period . getValue ( i ) , scalar ) ) ; }
{ buf . append ( print ( instant - displayOffset , displayZone , locale ) ) ; }
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = ISOChronology . getInstance () ; }
{ super ( ISOChronology . getInstance ( zone ) ) ; }
public Chronology getChronology () { return ISOChronology . getInstanceUTC () ; }
iMillis = converter . getInstantMillis ( instant , ISOChronology . getInstanceUTC () ) ;
{ super ( ISOChronology . getInstance ( zone ) ) ; }
long difference = ( minuendYear - subtrahendYear ) * ( ( long ) iMax ) + minuendMonth - subtrahendMonth ;
{ return set ( instant , FieldUtils . getWrappedValue ( get ( instant ) , months , MIN , iMax ) ) ; }
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * MILLIS_PER_DAY ; return new TestSuite ( TestEthiopicChronology . class ) ; }
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * MILLIS_PER_DAY ; return new TestSuite ( TestCopticChronology . class ) ; }
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
BasicChronology chronology
GJEraDateTimeField ( BasicChronology chronology ) { super ( DateTimeFieldType . era () ) ; iChronology = chronology ; }
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
{ int len = parser . estimateParsedLength () ; if ( len > est ) { est = len ; } }
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
LocalTime test = LocalTime . forInstant ( ( Object ) null , JULIAN_LONDON ) ;
assertEquals ( false , test . isSupported ( DurationFieldType . eras () ) ) ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate () ;
LocalDate test = new LocalDate () ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
public void testSize () { LocalDate test = new LocalDate () ; assertEquals ( NUMBER_CONSTANT , test . size () ) ; }
LocalDate test = new LocalDate () ;
long getApproxMillisAtEpochDividedByTwo () { return ( - MILLIS_YEAR_1 ) / NUMBER_CONSTANT ; }
{ if ( newPos >= text . length () ) { return bucket . computeMillis ( true , text ) ; } }
test = new DateTime ( TEST_TIME1 , GREGORIAN_PARIS ) ;
{ super ( instant , DateTimeUtils . getChronology ( chronology ) , ISODateTimeFormat . timeParser () ) ; }
{ super ( instant , null , ISODateTimeFormat . timeParser () ) ; }
int index = ( ( dateStyle < < NUMBER_CONSTANT ) + dateStyle ) + timeStyle ;
public LocalDateTime withMinimumValue () { return setCopy ( getMinimumValue () ) ; }
public LocalDate withMinimumValue () { return setCopy ( getMinimumValue () ) ; }
public LocalTime withMinimumValue () { return setCopy ( getMinimumValue () ) ; }
public LocalTime withMaximumValue () { return setCopy ( getMaximumValue () ) ; }
LocalDateTime copy = test . hourOfDay () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . millisOfSecond () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . secondOfMinute () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . minuteOfHour () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . hourOfDay () . setCopy ( STRING_CONSTANT ) ;
if ( value >= min && value <= getMaximumValue ( instant ) ) { return super . set ( instant , value ) ; }
super ( createMessage ( fieldName , value , lowerBound , upperBound , null ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound , null ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound , null ) ) ;
DateTime now = new DateTime ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ t = new DateTimeFormatterBuilder () . append ( hourMinuteSecondFraction () ) . append ( offsetElement () ) . toFormatter () ; }
String [] [] zoneStrings = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
throw new IllegalArgumentException ( STRING_CONSTANT + id + STRING_CONSTANT ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + id + STRING_CONSTANT ) ;
{ Hibernate.DATE . nullSafeSet ( preparedStatement , ( ( LocalDate ) value ) . toDateTimeAtStartOfDay () . toDate () , index ) ; }
ReadablePartial partial
ReadableInstant readableInstant
DurationField durationField
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
List < Object > list
List < Object > elementPairs
List < Object > elementPairs
List < Object > pairs = iElementPairs ;
if ( iElementPairs == null ) { iElementPairs = new ArrayList < Object > () ; } else { iElementPairs . clear () ; }
Map < String , RuleSet > ruleSets
{ iRules = new ArrayList < Rule > () ; iRules . add ( rule ) ; }
public int compareTo ( DurationField durationField ) { return iField . compareTo ( durationField ) ; }
RuleSet () { iRules = new ArrayList < Rule > ( NUMBER_CONSTANT ) ; iUpperYear = Integer.MAX_VALUE ; }
ReadablePartial partial
ReadablePartial partial
Map < String , Object > zimap
iZoneInfoMap . put ( id , new SoftReference < DateTimeZone > ( tz ) ) ;
public int compareTo ( DurationField durationField ) { return NUMBER_CONSTANT ; }
List < Object > list
HashMap < Object , Object > converted
HashMap < Object , Object > converted
HashMap < Object , Object > converted
HashMap < Object , Object > converted
TreeMap < String , Integer > map
TreeMap < String , Integer > map
ReadableDuration obj
assertEquals ( STRING_CONSTANT , f . withZoneUTC () . print ( dt ) ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
{ if ( ldp == null ) { ldp = dateElementParser () . withZoneUTC () ; } return ldp ; }
{ if ( value == null ) { return null ; } return new Instant ( value ) ; }
TimeZone . setDefault ( DateTimeZone . forID ( STRING_CONSTANT ) . toTimeZone () ) ;
{ locale = Locale . getDefault () ; zone = DateTimeZone . getDefault () ; Locale . setDefault ( Locale.JAPAN ) ; }
TimeZone . setDefault ( DateTimeZone . forID ( STRING_CONSTANT ) . toTimeZone () ) ;
public YearMonth getYearMonth () { return iBase ; }
protected ReadablePartial getReadablePartial () { return iBase ; }
public DateTimeField getField () { return iBase . getField ( iFieldIndex ) ; }
{ super(); iBase = partial ; iFieldIndex = fieldIndex ; }
Map < String , Object > map = new ConcurrentHashMap < String , Object > () ;
return iBase . getZone () . convertLocalToUTC ( localInstant , false , instant ) ;
{ super ( duration ) ; }
{ super ( duration ) ; }
String s = ( String ) StandardBasicTypes.STRING . nullSafeGet ( resultSet , strings [ NUMBER_CONSTANT ] ) ;
{ if ( period != null ) { setValues ( addPeriodInto ( getValues () , period ) ) ; } }
{ if ( period != null ) { setValues ( mergePeriodInto ( getValues () , period ) ) ; } }
array = new Object [] { validValues , Integer . valueOf ( maxLength ) } ;
{ integers [ i ] = Integer . valueOf ( i ) ; }
array = new Object [] { validValues , Integer . valueOf ( maxLength ) } ;
protected void setUp ( ) throws Exception { originalLocale = Locale . getDefault () ; Locale . setDefault ( DE ) ; }
convId = zone . getID () ;
catch ( ArrayIndexOutOfBoundsException ex ) { throw new IOException ( STRING_CONSTANT ) ; }
try { readZoneInfoMap ( din , map ) ; } finally { try { din . close () ; } catch ( IOException ex ) {} }
StringBuilder msg = new StringBuilder () ;
StringBuilder sb = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder () ;
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
try { localDateTime . toDateTime ( this ) ; return false ; } catch ( IllegalInstantException ex ) { return true ; }
throw new IllegalInstantException ( message ) ;
{ if ( divisor == NUMBER_CONSTANT ) { return this ; } return new Duration ( FieldUtils . safeDivide ( getMillis () , divisor ) ) ; }
{ if ( multiplicand == NUMBER_CONSTANT ) { return this ; } return new Duration ( FieldUtils . safeMultiply ( getMillis () , multiplicand ) ) ; }
Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ;
f2 = new DateTimeFormatter ( ( InternalPrinter ) null , f . getParser () ) ;
InternalPrinter [] elements = iPrinters ;
InternalPrinter [] elements = iPrinters ;
f instanceof InternalPrinter
InternalPrinter printer
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , parser ) ; }
{ checkPrinter ( printer ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , null ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter0 () , formatter . getParser () ) ; }
InternalPrinter p = getFormatter ( locale ) . getPrinter0 () ;
return ( ( StyleFormatter ) formatter . getPrinter0 () ) . getPattern ( locale ) ;
{ printTo ( ( Appendable ) out , instant ) ; }
InternalPrinter printer
{ return computeMillis ( resetFields , ( CharSequence ) null ) ; }
{ return computeMillis ( false , ( CharSequence ) null ) ; }
CharSequence text
f2 = new DateTimeFormatter ( ( DateTimePrinter ) null , f . getParser () ) ;
{ reset () ; return doParseMillis ( DateTimeParserInternalParser . of ( parser ) , text ) ; }
CharSequence text
CharSequence text
CharSequence text
f instanceof InternalParser
InternalParser parser
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , DateTimeParserInternalParser . of ( parser ) ) ; }
{ checkParser ( parser ) ; return append0 ( null , DateTimeParserInternalParser . of ( parser ) ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter0 () , formatter . getParser0 () ) ; }
public DateTimeParser getParser () { return InternalParserDateTimeParser . of ( iParser ) ; }
InternalParser parser
InternalParser parser
{ this ( DateTimePrinterInternalPrinter . of ( printer ) , DateTimeParserInternalParser . of ( parser ) ) ; }
iMillis = FieldUtils . safeSubtract ( endMillis , startMillis ) ;
{ super(); iMillis = FieldUtils . safeSubtract ( endInstant , startInstant ) ; }
iSuffixes = texts . clone () ;
builder . appendDays () . appendSuffix ( STRING_CONSTANT ) . appendSuffix ( STRING_CONSTANT , STRING_CONSTANT )
if ( periodStr . regionMatches ( false , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
if ( periodStr . regionMatches ( true , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
synchronized ( cDefaultLock ) { cDefault = zone ; }
{ return iZoneInfoKeys ; }
public Set < String > getAvailableIDs () { return AVAILABLE_IDS ; }
public static Set < String > getAvailableIDs () { return getProvider () . getAvailableIDs () ; }
DateTimeZone zone = getProvider () . getZone ( id ) ;
int curMonth0 = values [ NUMBER_CONSTANT ] - NUMBER_CONSTANT ;
if ( ZoneInfoLogger . verbose () ) { System.out . println ( STRING_CONSTANT + tz . getID () ) ; }
Interval interval = new Interval ( start , end , getChronology () ) ;
{ return FieldUtils . safeSubtract ( getEndMillis () , getStartMillis () ) ; }
{ millis = iField . setExtended ( millis , iValue ) ; }
str = str . toLowerCase ( Locale.ENGLISH ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.ENGLISH ) ;
DateTimeFormatter fmt = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.ENGLISH ) ;
{ Provider provider = new ZoneInfoProvider ( DEFAULT_TZ_DATA_PATH ) ; return validateProvider ( provider ) ; }
try { retDT = new DateTime ( s ) ; } catch ( IllegalArgumentException pe ) {}
IllegalArgumentException e
final Object f
final Object f
final Object f
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final DateTimeField field
final DateTimeField field
final char c
final Object element
final DateTimeParser parser
final DateTimeParser parser
final DateTimePrinter printer
final DateTimeFormatter formatter
final Chronology chrono
final DateTimeZone zone
Chronology chrono = new LenientChronology ( ISOChronology . getInstanceUTC () ) ;
public int getMinimumValue ( long instant ) { return NUMBER_CONSTANT ; }
long value
final long millis
GJWeekyearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getRoughMillisPerYear () ) ; iChronology = chronology ; }
DateTime instant
public int get ( long instant ) { return BuddhistChronology.BE ; }
public String getNameKey ( long instant ) { return iNameKey ; }
{ return add ( millis , ( long ) value - get ( millis ) ) ; }
public long add ( long millis , long value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
IllegalArgumentException pe
{ return add ( millis , ( long ) value - get ( millis ) ) ; }
public long add ( long millis , long value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
public long add ( long millis , long value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
return ( getMillis ( readableInstant ) < readableInstant . getMillis ( this ) ) ;
{ Chronology chrono = getChronology () ; return ( chrono != null ? chrono . getDateTimeZone () : null ) ; }
protected AbstractInstant () { super(); }
catch ( IllegalArgumentException pe ) { pe . printStackTrace () ; }
try { retDT = new DateTime ( s , DateTimeZone.UTC ) ; } catch ( IllegalArgumentException pe ) { pe . printStackTrace () ; }
long value
GJMonthOfYearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getRoughMillisPerMonth () ) ; iChronology = chronology ; }
long value
public abstract boolean equals ( Object object ) ;
public String print ( final long instant ) { throw unsupported () ; }
public String print ( final ReadableInstant instant ) { throw unsupported () ; }
public String print ( final ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
final char c
final char style
final char style
