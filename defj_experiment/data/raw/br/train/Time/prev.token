{ super . moveDateTimeZone ( zone ) ; }
if ( sm != null ) { sm . checkPermission ( new DateTimeZonePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new DateTimeZonePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new DateTimeZonePermission ( STRING_CONSTANT ) ) ; }
{ this ( instant , null ) ; }
{ this ( DateTimeUtils . currentTimeMillis () , chronology ) ; }
{ return getField () . getAsShortText ( getPartialInstant () , get () , locale ) ; }
{ return getField () . getAsText ( getPartialInstant () , get () , locale ) ; }
public int getMaximumValue ( PartialInstant instant ) { throw unsupported () ; }
public int getMinimumValue ( PartialInstant instant ) { throw unsupported () ; }
{ test1 . millisOfSecond () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
{ test1 . secondOfMinute () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
{ test1 . minuteOfHour () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
{ test1 . hourOfDay () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
public int getMinimumValue ( PartialInstant instant ) { return NUMBER_CONSTANT ; }
{ test1 . dayOfMonth () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
{ test1 . monthOfYear () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
{ test1 . year () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
public int getMaximumValue ( PartialInstant instant , int [] values ) { return iField . getMaximumValue ( instant , values ) ; }
public int getMaximumValue ( PartialInstant instant ) { return iField . getMaximumValue ( instant ) ; }
public int getMinimumValue ( PartialInstant instant , int [] values ) { return iField . getMinimumValue ( instant , values ) ; }
public int getMinimumValue ( PartialInstant instant ) { return iField . getMinimumValue ( instant ) ; }
{ t = new DateTimeFormatterBuilder ( iChrono ) . append ( hourMinuteSecondFraction () ) . append ( offsetElement () ) . toFormatter () ; }
iChronology = converter . getChronology ( instant ) ;
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
public DurationField hours () { return UnsupportedDurationField.INSTANCE ; }
public DurationField days () { return UnsupportedDurationField.INSTANCE ; }
public DurationField weeks () { return UnsupportedDurationField.INSTANCE ; }
public DurationField months () { return UnsupportedDurationField.INSTANCE ; }
public DurationField years () { return UnsupportedDurationField.INSTANCE ; }
{ return getField () . remainder ( getInstant () . getMillis () ) ; }
{ return getField () . getMaximumValue ( getInstant () . getMillis () ) ; }
{ return getField () . getMinimumValue ( getInstant () . getMillis () ) ; }
{ return getField () . getLeapAmount ( getInstant () . getMillis () ) ; }
{ return getField () . isLeap ( getInstant () . getMillis () ) ; }
return getField () . getDifferenceAsLong ( getInstant () . getMillis () , instant . getMillis () ) ;
return getField () . getDifference ( getInstant () . getMillis () , instant . getMillis () ) ;
{ return getField () . getAsShortText ( getInstant () . getMillis () , locale ) ; }
{ return getField () . getAsText ( getInstant () . getMillis () , locale ) ; }
{ return getField () . get ( getInstant () . getMillis () ) ; }
iMillis = converter . getInstantMillis ( instant , chronology ) ;
iMillis = converter . getInstantMillis ( instant , zone ) ;
iMillis = converter . getInstantMillis ( instant ) ;
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
{ long instant = getChronology () . getDateTimeMillis ( getMillis () , hour , minuteOfHour , secondOfMinute , millisOfSecond ) ; setTime ( instant ) ; }
withUTC () . getTimeOnlyMillis ( iCutoverMillis ) == NUMBER_CONSTANT
return getDateOnlyMillis ( year , monthOfYear , dayOfMonth ) + millisOfDay ;
assertEquals ( NUMBER_CONSTANT * DateTimeConstants.MILLIS_PER_DAY , test . monthOfYear () . remainder () ) ;
{ if ( chrono == getChronology () ) { return this ; } return mask ( iType . withChronology ( chrono ) , iMask ) ; }
if ( isPrecise () ) { return instant += getTotalMillis () * scalar ; }
{ MutableDuration test = new MutableDuration () ; assertEquals ( DurationType . getMillisType () , test . getDurationType () ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( duration , type ) ; }
{ super ( duration , null ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( duration , type ) ; }
{ super ( duration , null ) ; }
public void testGetDurationType_Object ( ) throws Exception { assertEquals ( DurationType . getMillisType () , NullConverter.INSTANCE . getDurationType ( null ) ) ; }
{ convId = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return new FixedDateTimeZone ( convId , null , offset , offset ) ; }
{ id = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return new FixedDateTimeZone ( id , null , offset , offset ) ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearWeekType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearMonthType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getAllType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getDayHourType () ; }
type = ( type == null ? converter . getDurationType ( duration ) : type ) ;
{ return ( ( ReadableDuration ) object ) . getTotalMillis () ; }
{ try { new MutableDuration ( DurationType . getAllType () , true ) ; fail () ; } catch ( IllegalArgumentException ex ) {} }
{ Duration test = new Duration ( NUMBER_CONSTANT ) ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
{ MutableDuration test = new MutableDuration () ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
public void setInto ( ReadWritableDuration duration , Object object ) {}
public void setInto ( ReadWritableDuration duration , Object object ) {}
public void setInto ( ReadWritableDuration duration , Object object ) {}
c = ConverterManager . getInstance () . getDurationConverter ( new Duration ( DurationType . getMillisType () ) ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
{ DurationConverter [] array = ConverterManager . getInstance () . getDurationConverters () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
{ add ( new TimePeriod ( duration ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () ) ) ; } }
{ return new TimePeriod ( toDurationMillis () , getDurationType () ) ; }
{ add ( new TimePeriod ( duration , getDurationType () ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () , getDurationType () ) ) ; } }
{ if ( interval != null ) { add ( interval . toTimePeriod ( getDurationType () ) ) ; } }
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
DurationType type
DurationType type
DurationType type
if ( ! mustParse && ! isSupported ( period . getDurationType () ) ) { return position ; }
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getMillisType () ) ;
TimePeriodConverter c = ConverterManager . getInstance () . getTimePeriodConverter ( new TimePeriod ( DurationType . getMillisType () ) ) ;
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( DurationType . getMillisType () ) ) ;
MillisDuration base = new MillisDuration ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getDayHourType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
DurationType type
DurationType type
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getMillisType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearWeekType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearWeekType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
assertEquals ( test . getDurationType () , copy . getDurationType () ) ;
assertEquals ( test . getDurationType () , copy . getDurationType () ) ;
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getMillisType () ) ;
ReadableTimePeriod period
ReadableTimePeriod period
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( PeriodType . getMillisType () ) ) ;
{ MutableTimePeriod test = new MutableTimePeriod () ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
ReadableTimePeriod period
ReadableTimePeriod period
public void testSetDuration_RD () { setTimePeriod ( ( ReadableDuration ) null ) ; }
{ TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( length , null ) ;
MutableTimePeriod test = new MutableTimePeriod ( length ) ;
MutableTimePeriod test = new MutableTimePeriod ( length ) ;
MutableTimePeriod test = new MutableTimePeriod () ;
{ return STRING_CONSTANT + iInstantConverters . size () + STRING_CONSTANT + iDurationConverters . size () + STRING_CONSTANT + iTimePeriodConverters . size () + STRING_CONSTANT + iIntervalConverters . size () + STRING_CONSTANT ; }
ReadableTimePeriod period
ReadableTimePeriod period
TimePeriod duration ;
Class cls = ReadableTimePeriodConverter . class ;
{ return PRECISE_YEAR_WEEK_TYPE ; }
{ return PRECISE_YEAR_MONTH_TYPE ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getUTCYearWeekType () ; }
{ return YEAR_WEEK_TYPE ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getUTCYearMonthType () ; }
{ return YEAR_MONTH_TYPE ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getUTCAllType () ; }
{ return ALL_TYPE ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getUTCAllType () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getUTCAllType () ) ;
{ long durationMillis = DateTimeUtils . getDurationMillis ( duration ) ; setStartMillis ( FieldUtils . safeAdd ( getStartMillis () , - durationMillis ) ) ; }
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
final Object duration
{ setInterval ( startInstant , iEndMillis ) ; }
public void normalize () { super . normalize () ; }
{ return new MutableDateTime ( this , chronology ) ; }
{ long instant = getChronology () . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; setDateTime ( instant ) ; }
{ super(); iChronology = partial.iChronology ; iValues = values ; }
{ super(); iChronology = partial.iChronology ; iValues = values ; }
{ Chronology chrono = iChronology . withZone ( zone ) ; return resolve ( baseInstant , chrono ) ; }
AbstractGJChronology chronology
AbstractGJChronology chronology
GJYearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
AbstractGJChronology chronology
AbstractGJChronology chronology
AbstractGJChronology chronology
GJMonthOfYearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
AbstractGJChronology chrono = iChronology ;
CopticYearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
AbstractGJChronology chronology
GJWeekyearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
AbstractGJChronology chronology
NoWeekyearZeroField ( AbstractGJChronology chronology , DateTimeField field ) { super ( chronology , field ) ; }
AbstractGJChronology chronology
{ millis = getField ( i ) . set ( millis , getValue ( i ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendSuffix ( new SingularAffix ( text ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendPrefix ( new SingularAffix ( text ) ) ; }
DurationFieldAffix affix ;
DurationFieldAffix affix ;
DurationFieldAffix affix ;
DurationFieldAffix suffix
int scan ( String durationStr , int position ) ;
int parse ( String durationStr , int position ) ;
DurationFieldAffix suffix
DurationFieldAffix prefix
{ if ( iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue ( period ) >= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
public PeriodFormatterBuilder appendMillis () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithOptionalMillis () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithMillis () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendSeconds () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendMinutes () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendHours () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendDays () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendWeeks () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendMonths () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendYears () { appendField ( NUMBER_CONSTANT ) ; return this ; }
DateTimeField lowerLimit
public static DateTimeComparator getInstance () { return INSTANCE ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
if ( iParseField == null ) { iParseField = new PreciseDateTimeField ( STRING_CONSTANT , MillisDurationField.INSTANCE , iField . getDurationField () ) ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
public TestGJYearField ( TestGJChronology chrono ) { super ( STRING_CONSTANT , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( STRING_CONSTANT , weeks ) ; iChronology = chronology ; }
private ISOYearOfEraDateTimeField () { super ( GregorianChronology . getInstanceUTC () . year () , STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( STRING_CONSTANT , STRING_CONSTANT , chrono . millisPerMonth () , chrono ) ; }
{ super ( field , field . getName () ) ; iDurationField = durationField ; iRangeDurationField = rangeDurationField ; iLeapDurationField = leapDurationField ; }
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( STRING_CONSTANT , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , months ) ; iChronology = chronology ; }
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
public DateTimeField year () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , years () ) ; }
public DateTimeField monthOfYear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , months () ) ; }
public DateTimeField weekyear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , weekyears () ) ; }
public DateTimeField weekOfWeekyear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , weeks () ) ; }
public DateTimeField dayOfYear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , days () ) ; }
public DateTimeField dayOfMonth () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , days () ) ; }
public DateTimeField clockhourOfHalfday () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField hourOfHalfday () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField clockhourOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField hourOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField minuteOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , minutes () ) ; }
public DateTimeField minuteOfHour () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , minutes () ) ; }
public DateTimeField secondOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , seconds () ) ; }
public DateTimeField secondOfMinute () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , seconds () ) ; }
public DateTimeField millisOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , millis () ) ; }
public DateTimeField millisOfSecond () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , millis () ) ; }
{ super ( yearField , STRING_CONSTANT ) ; iChronology = chronology ; }
LinkedDurationField ( DurationField durationField , ImpreciseCutoverField dateTimeField ) { super ( durationField , durationField . getName () ) ; iField = dateTimeField ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , STRING_CONSTANT , chrono.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , STRING_CONSTANT , chrono.MILLIS_PER_DAY , chrono ) ; }
public String toString () { return STRING_CONSTANT ; }
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . year () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , STRING_CONSTANT , NUMBER_CONSTANT ) ;
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , STRING_CONSTANT , chrono.MILLIS_PER_DAY , chrono ) ; }
super ( field . getName () ) ;
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , STRING_CONSTANT , NUMBER_CONSTANT ) ;
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
{ super ( chrono ) ; iMonths = new ScaledDurationField ( chrono . days () , STRING_CONSTANT , NUMBER_CONSTANT ) ; }
{ super ( chrono ) ; iYears = new ScaledDurationField ( chrono . days () , STRING_CONSTANT , NUMBER_CONSTANT ) ; }
fields.centuryOfEra = new DividedDateTimeField ( ISOYearOfEraDateTimeField.INSTANCE , DateTimeFieldType . centuryOfEra () , STRING_CONSTANT , NUMBER_CONSTANT ) ;
{ super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chrono . millisPerMonth () , chrono ) ; }
int [] values = new int [ getFieldSize () ] ;
int i = NUMBER_CONSTANT , isize = getFieldSize ()
public int getFieldSize () { return NUMBER_CONSTANT ; }
public int getFieldSize () { return getFields () . length ; }
public static DateTimeFieldType era () { return ERA ; }
public static DateTimeFieldType centuryOfEra () { return CENTURY_OF_ERA ; }
public static DateTimeFieldType yearOfCentury () { return YEAR_OF_CENTURY ; }
public static DateTimeFieldType yearOfEra () { return YEAR_OF_ERA ; }
public static DateTimeFieldType year () { return YEAR ; }
public static DateTimeFieldType monthOfYear () { return MONTH_OF_YEAR ; }
public static DateTimeFieldType weekyearOfCentury () { return WEEKYEAR_OF_CENTURY ; }
public static DateTimeFieldType weekyear () { return WEEKYEAR ; }
public static DateTimeFieldType weekOfWeekyear () { return WEEK_OF_WEEKYEAR ; }
public static DateTimeFieldType dayOfYear () { return DAY_OF_YEAR ; }
public static DateTimeFieldType dayOfMonth () { return DAY_OF_MONTH ; }
public static DateTimeFieldType dayOfWeek () { return DAY_OF_WEEK ; }
public static DateTimeFieldType halfdayOfDay () { return HALFDAY_OF_DAY ; }
public static DateTimeFieldType clockhourOfHalfday () { return CLOCKHOUR_OF_HALFDAY ; }
public static DateTimeFieldType hourOfHalfday () { return HOUR_OF_HALFDAY ; }
public static DateTimeFieldType clockhourOfDay () { return CLOCKHOUR_OF_DAY ; }
public static DateTimeFieldType hourOfDay () { return HOUR_OF_DAY ; }
public static DateTimeFieldType minuteOfDay () { return MINUTE_OF_DAY ; }
public static DateTimeFieldType minuteOfHour () { return MINUTE_OF_HOUR ; }
public static DateTimeFieldType secondOfDay () { return SECOND_OF_DAY ; }
public static DateTimeFieldType secondOfMinute () { return SECOND_OF_MINUTE ; }
public static DateTimeFieldType millisOfDay () { return MILLIS_OF_DAY ; }
public static DateTimeFieldType millisOfSecond () { return MILLIS_OF_SECOND ; }
int otherValue = chrono . getField ( getFieldType () ) . get ( instant . getMillis () ) ;
public static DurationFieldType eras () { return ERAS ; }
public static DurationFieldType centuries () { return CENTURIES ; }
public static DurationFieldType years () { return YEARS ; }
public static DurationFieldType months () { return MONTHS ; }
public static DurationFieldType weekyears () { return WEEKYEARS ; }
public static DurationFieldType weeks () { return WEEKS ; }
public static DurationFieldType days () { return DAYS ; }
public static DurationFieldType halfdays () { return HALFDAYS ; }
public static DurationFieldType hours () { return HOURS ; }
public static DurationFieldType minutes () { return MINUTES ; }
public static DurationFieldType seconds () { return SECONDS ; }
public static DurationFieldType millis () { return MILLIS ; }
assertEquals ( false , test . isAfter ( null ) ) ;
assertEquals ( false , test . isBefore ( null ) ) ;
assertEquals ( false , test . isAfter ( null ) ) ;
assertEquals ( false , test . isBefore ( null ) ) ;
{ if ( instant == null ) { return isAfter ( DateTimeUtils . currentTimeMillis () ) ; } return isAfter ( instant . getMillis () ) ; }
{ if ( instant == null ) { return isBefore ( DateTimeUtils . currentTimeMillis () ) ; } return isBefore ( instant . getMillis () ) ; }
{ if ( instant == null ) { return contains ( DateTimeUtils . currentTimeMillis () ) ; } return contains ( instant . getMillis () ) ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
{ Period test = new Period ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadablePeriodConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
test = new MutablePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
{ super . setMillis ( millis ) ; }
{ super . setSeconds ( seconds ) ; }
{ super . setMinutes ( minutes ) ; }
{ super . setHours ( hours ) ; }
{ super . setDays ( days ) ; }
{ super . setWeeks ( weeks ) ; }
{ super . setMonths ( months ) ; }
{ super . setYears ( years ) ; }
{ super ( period , type ) ; }
{ super ( period , null ) ; }
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
{ MutablePeriod test = new MutablePeriod () ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
{ super ( period , type ) ; }
{ super ( period , null ) ; }
{ if ( period != null ) { setMillis ( period . addTo ( getMillis () , scalar ) ) ; } }
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
{ test1 . year () . compareTo ( null ) ; fail () ; }
assertEquals ( PeriodType . time () , test . getPeriodType () ) ;
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setStartMillis ( period . addTo ( getEndMillis () , - NUMBER_CONSTANT , chrono ) ) ; }
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setEndMillis ( period . addTo ( getStartMillis () , NUMBER_CONSTANT , chrono ) ) ; }
{ if ( period != null ) { setMillis ( period . addTo ( getMillis () , scalar , getChronology () ) ) ; } }
assertEquals ( PeriodType . time () , test . getPeriodType () ) ;
return new Period ( new int [] { millis } , PeriodType . standard () ) ;
return new Period ( new int [] { seconds } , PeriodType . standard () ) ;
return new Period ( new int [] { minutes } , PeriodType . standard () ) ;
return new Period ( new int [] { hours } , PeriodType . standard () ) ;
return new Period ( new int [] { days } , PeriodType . standard () ) ;
return new Period ( new int [] { weeks } , PeriodType . standard () ) ;
return new Period ( new int [] { months } , PeriodType . standard () ) ;
new Period ( new int [] { years } , PeriodType . standard () )
{ duration . setPeriod ( NUMBER_CONSTANT , chrono ) ; }
iIntervalConverters = new ConverterSet ( new Converter [] { ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , } ) ;
{ super . setEndMillis ( endInstant ) ; }
{ super . setStartMillis ( startInstant ) ; }
public long getDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
{ IntervalConverter [] array = ConverterManager . getInstance () . getIntervalConverters () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
public long getDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
{ MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . getDuration () ) ; }
{ test . withEndInstant ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withEndInstant ( new Instant ( TEST_TIME2 - NUMBER_CONSTANT ) ) ;
{ test . withStartInstant ( new Instant ( TEST_TIME2 + NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withStartInstant ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ;
{ Interval test = new Interval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . getDuration () ) ; }
{ return ( ( ( ReadableInterval ) object ) ) . getDurationMillis () ; }
{ Chronology chrono = getChronology () . withZone ( zone ) ; return resolve ( baseInstant , chrono ) ; }
{ if ( period != null ) { setMillis ( getChronology () . add ( getMillis () , period , scalar ) ) ; } }
if ( period == null ) { iStartMillis = iEndMillis ; } else { iStartMillis = chrono . add ( iEndMillis , period , - NUMBER_CONSTANT ) ; }
if ( period == null ) { iEndMillis = iStartMillis ; } else { iEndMillis = chrono . add ( iStartMillis , period , NUMBER_CONSTANT ) ; }
{ if ( period == null ) { setPeriodInternal ( NUMBER_CONSTANT , null ) ; } else { setPeriodInternal ( period ) ; } }
{ setStartMillis ( getChronology () . add ( getEndMillis () , period , - NUMBER_CONSTANT ) ) ; }
{ if ( period != null ) { addPeriod ( period ) ; } }
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
{ if ( partial == null ) { return this ; } return partial . resolveDateTime ( this ) ; }
{ long millis = partial . resolve ( NUMBER_CONSTANT , DateTimeZone.UTC ) ; printTo ( null , out , millis ) ; }
long millis = partial . resolve ( NUMBER_CONSTANT , DateTimeZone.UTC ) ;
{ return new Period ( getStartMillis () , getEndMillis () , type ) ; }
{ return new Period ( getStartMillis () , getEndMillis () ) ; }
{ return new MutableInterval ( getStartMillis () , getEndMillis () ) ; }
{ return new Interval ( getStartMillis () , getEndMillis () ) ; }
Interval test4 = new Interval ( TEST_TIME1 , TEST_TIME1 , Chronology . getGJ () ) ;
{ if ( endInstant == getEndMillis () ) { return this ; } return new Interval ( getStartMillis () , endInstant ) ; }
{ if ( startInstant == getStartMillis () ) { return this ; } return new Interval ( startInstant , getEndMillis () ) ; }
final Object f
final Object f
final Object f
public DateTimeFormatterBuilder appendMonthOfYearShortText () { return appendShortText ( iChronoUTC . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearText () { return appendText ( iChronoUTC . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekShortText () { return appendShortText ( iChronoUTC . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekText () { return appendText ( iChronoUTC . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendHalfdayOfDayText () { return appendText ( iChronoUTC . halfdayOfDay () ) ; }
final String text
final Object element
final DateTimeParser parser
final DateTimeParser parser
final DateTimePrinter printer
final DateTimeFormatter formatter
final Chronology chrono
final DateTimeZone zone
public MutableDateTime parseMutableDateTime ( final String text ) { return mParser . parseMutableDateTime ( text ) ; }
public DateTime parseDateTime ( final String text ) { return mParser . parseDateTime ( text ) ; }
public long parseMillis ( final String text ) { return mParser . parseMillis ( text ) ; }
public String print ( final long instant ) { throw unsupported () ; }
public String print ( final ReadableInstant instant ) { throw unsupported () ; }
public MutableDateTime parseMutableDateTime ( final String text ) { throw unsupported () ; }
public DateTime parseDateTime ( final String text ) { throw unsupported () ; }
public long parseMillis ( final String text ) { throw unsupported () ; }
public String print ( final long instant ) { return mPrinter . print ( instant ) ; }
public String print ( final ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
FPrinter ( final DateTimePrinter printer ) { super(); mPrinter = printer ; }
iMillis = converter . getInstantMillis ( instant ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getInstantConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
{ PartialConverter [] array = ConverterManager . getInstance () . getPartialConverters () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
iPartialConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , null ) ; }
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , null ) ; }
throw new IllegalStateException () ;
try { MillisDurationField.INSTANCE . getDifferenceAsLong ( Long.MAX_VALUE , NUMBER_CONSTANT ) ; fail () ; } catch ( ArithmeticException ex ) {}
BaseDateTimeField field = new MockBaseDateTimeField () ;
BaseDateTimeField field = new MockPreciseDateTimeField () ;
{ convId = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return fixedOffsetZone ( convId , offset ) ; }
PeriodParser [] parsers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
Separator finish ( PeriodFormatter after ) { iAfter = after ; return this ; }
PeriodFormatter before
DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder ( iChrono , iLocale ) ;
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono ) ;
DateTimeParserBucket bucket = new DateTimeParserBucket ( NUMBER_CONSTANT , chrono ) ;
DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono ) ;
{ if ( permission instanceof JodaTimePermission ) { return false ; } return super . implies ( domain , permission ) ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return super . implies ( domain , permission ) ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return super . implies ( domain , permission ) ; }
int offset = - ( int ) offsetFormatter () . parseMillis ( convId ) ;
int offset = - ( int ) offsetFormatter () . parseMillis ( id ) ;
return printTimeZone ( getOffset ( instant ) ) ;
return new MutableDateTime ( parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new MutableDateTime ( parseMillis ( text , chrono ) , chrono ) ; }
return new DateTime ( parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new DateTime ( parseMillis ( text , chrono ) , chrono ) ; }
return print ( millis , chrono ) ;
printTo ( out , millis , chrono ) ;
printTo ( buf , millis , chrono ) ;
public MutableDateTime parseMutableDateTime ( String text , ReadableInstant instant ) { return mParser . parseMutableDateTime ( text , instant ) ; }
public MutableDateTime parseMutableDateTime ( String text , Chronology chrono ) { return mParser . parseMutableDateTime ( text , chrono ) ; }
public DateTime parseDateTime ( String text , ReadableInstant instant ) { return mParser . parseDateTime ( text , instant ) ; }
public DateTime parseDateTime ( String text , Chronology chrono ) { return mParser . parseDateTime ( text , chrono ) ; }
public String print ( long instant , Chronology chrono ) { return mPrinter . print ( instant , chrono ) ; }
public String print ( long instant , DateTimeZone zone ) { return mPrinter . print ( instant , zone ) ; }
public void printTo ( Writer out , long instant ) throws IOException { mPrinter . printTo ( out , instant ) ; }
protected int estimateParsedLength () { return iParsedLengthEstimate ; }
protected int estimateParsedLength () { return iParsedLengthEstimate ; }
BaseDateTimeFormatter [] elements = iPrinters ;
BaseDateTimeFormatter [] elements = iPrinters ;
protected int estimatePrintedLength () { return iPrintedLengthEstimate ; }
protected int estimatePrintedLength () { return iShortFormat ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
protected int estimateParsedLength () { return iMaxDigits ; }
protected int estimatePrintedLength () { return iMaxDigits ; }
protected int estimatePrintedLength () { return iShort ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
protected int estimatePrintedLength () { return NUMBER_CONSTANT ; }
protected int estimateParsedLength () { return NUMBER_CONSTANT ; }
protected int estimatePrintedLength () { return iMaxParsedDigits ; }
protected int estimatePrintedLength () { return iMaxParsedDigits ; }
protected int estimateParsedLength () { return iMaxParsedDigits ; }
ParseBucket bucket
protected int estimateParsedLength () { return NUMBER_CONSTANT ; }
BasePeriodFormatter [] parsers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
Separator finish ( BasePeriodFormatter after ) { iAfter = after ; return this ; }
BasePeriodFormatter before
{ return getField () . getMaximumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMinimumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getLeapAmount ( getReadableInstant () . getMillis () ) ; }
{ return getField () . isLeap ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getAsShortText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . getAsText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . get ( getReadableInstant () . getMillis () ) ; }
iChronology = ISOChronology . getInstance ( DateTimeZone . getInstance ( id ) ) ;
zones [ i ++ ] = new ZoneData ( id , DateTimeZone . getInstance ( id ) ) ;
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , chrono.MILLIS_PER_DAY , chrono ) ; }
int dayOfWeek = ( int ) iChronology . mod ( iChronology . fixedFromMillis ( millis ) , NUMBER_CONSTANT ) ;
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , chrono.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , chrono.MILLIS_PER_DAY , chrono ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance ( locale ) . forPattern ( pattern ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance () . forPattern ( pattern ) . print ( this ) ; }
return - ( int ) offsetFormatter () . parseMillis ( str , chrono ) ;
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance ( locale ) . forPattern ( pattern ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance () . forPattern ( pattern ) . print ( this ) ; }
return cOffsetFormatter . print ( millis , iZone ) ;
DateTimeParser p
{ return append0 ( new TimeZonePrinter ( iLocale , false ) , null ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , iLocale , true ) ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , iLocale , false ) ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter ) ; }
iFormatters . add ( formatter ) ;
public PeriodParser toParser () { return toFormatter () ; }
public PeriodPrinter toPrinter () { return toFormatter () ; }
InputStream in = new StringBufferInputStream ( data ) ;
Locale iLocale
Locale iLocale
Locale iLocale
Locale iLocale
{ if ( iChrono == chrono ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , iOffsetParsed , chrono , iZone ) ; }
{ if ( iOffsetParsed == true ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , true , iChrono , null ) ; }
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalArgumentException ( STRING_CONSTANT + text ) ; } return instant ; }
catch ( NumberFormatException ex ) { throw new IllegalArgumentException ( STRING_CONSTANT + getName () + STRING_CONSTANT + text ) ; }
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalArgumentException ( STRING_CONSTANT + text ) ; } return instant ; }
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
public final int getMinimumDaysInFirstWeek () { return iMinDaysInFirstWeek ; }
Period test = new Period ( length , PeriodType . standard () , Chronology . getISOUTC () ) ;
Period test = new Period ( length , PeriodType . time () . withMillisRemoved () , Chronology . getISO () ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( Chronology . getISO () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == Chronology . getISO () . minutes () . hashCode () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( - NUMBER_CONSTANT , MillisDurationField.INSTANCE . compareTo ( Chronology . getISO () . seconds () ) ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( Chronology . getISO () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == Chronology . getISO () . minutes () . hashCode () ) ;
{ FieldUtils . verifyValueBounds ( Chronology . getISO () . monthOfYear () , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail () ; }
Chronology chrono = Chronology . getISO ( ZONES [ i ] ) ;
actual = ReadablePartialConverter.INSTANCE . getPartialValues ( tod , new TimeOfDay ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , Chronology . getISO ( PARIS ) )
int [] actual = NullConverter.INSTANCE . getPartialValues ( tod , null , Chronology . getISO () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
int [] actual = StringConverter.INSTANCE . getPartialValues ( tod , STRING_CONSTANT , Chronology . getISO () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , Chronology . getISOUTC () ) ;
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , Chronology . getISO () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . standard () , Chronology . getISOUTC () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . time () . withMillisRemoved () , Chronology . getISO () ) ;
{ super ( Chronology . getISO ( zone ) ) ; }
public Chronology getChronology () { return Chronology . getISOUTC () ; }
iMillis = converter . getInstantMillis ( instant , Chronology . getISOUTC () ) ;
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = Chronology . getISO () ; }
{ super ( Chronology . getISO ( zone ) ) ; }
this . iZone = zone ;
this . iZone = zone ;
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiplyToInt ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . addWrapPartial ( this , index , newValues , FieldUtils . safeMultiplyToInt ( period . getValue ( i ) , scalar ) ) ; }
{ buf . append ( print ( instant , displayZone , locale ) ) ; }
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = ChronologyType . iso () . getChronology () ; }
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
public Chronology getChronology () { return ChronologyType . iso () . getChronologyUTC () ; }
iMillis = converter . getInstantMillis ( instant , ChronologyType . iso () . getChronologyUTC () ) ;
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
long difference = ( minuendYear - subtrahendYear ) * NUMBER_CONSTANT + minuendMonth - subtrahendMonth ;
{ return set ( instant , FieldUtils . getWrappedValue ( get ( instant ) , months , MIN , MAX ) ) ; }
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * DateTimeConstants.MILLIS_PER_DAY ; return new TestSuite ( TestEthiopicChronology . class ) ; }
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * DateTimeConstants.MILLIS_PER_DAY ; return new TestSuite ( TestCopticChronology . class ) ; }
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
BaseGJChronology chronology
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( DateTimeFieldType . era () ) ; iChronology = chronology ; }
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
{ int len = parser . estimateParsedLength () ; if ( len > est ) { len = est ; } }
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
LocalTime test = LocalTime . forInstant ( ( Object ) null , JULIAN ) ;
assertEquals ( true , test . isSupported ( DurationFieldType . eras () ) ) ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . nowDefaultZone () ;
LocalDate test = LocalDate . nowDefaultZone () ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
public void testSize () { LocalDate test = LocalDate . nowDefaultZone () ; assertEquals ( NUMBER_CONSTANT , test . size () ) ; }
LocalDate test = LocalDate . nowDefaultZone () ;
long getApproxMillisAtEpoch () { return - MILLIS_YEAR_1 ; }
{ if ( newPos >= text . length () ) { return bucket . computeMillis ( true ) ; } }
test = new DateTime ( TEST_TIME1 , GregorianChronology . getInstance ( PARIS ) ) ;
{ super ( instant , DateTimeUtils . getChronology ( chronology ) ) ; }
{ super ( instant , null ) ; }
int index = dateStyle * NUMBER_CONSTANT + timeStyle ;
public LocalDateTime withMinimumValue () { return withValue ( getMinimumValue () ) ; }
public LocalDate withMinimumValue () { return withValue ( getMinimumValue () ) ; }
public LocalTime withMinimumValue () { return withValue ( getMinimumValue () ) ; }
public LocalTime withMaximumValue () { return withValue ( getMaximumValue () ) ; }
LocalDateTime copy = test . hourOfDay () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . millisOfSecond () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . secondOfMinute () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . minuteOfHour () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . hourOfDay () . withValue ( STRING_CONSTANT ) ;
if ( value >= min && value < getMaximumValue ( instant ) ) { return super . set ( instant , value ) ; }
super ( createMessage ( fieldName , value , lowerBound , upperBound ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound ) ) ;
DateTime now = new DateTime () ;
{ t = new DateTimeFormatterBuilder () . append ( hourMinuteSecondMillis () ) . append ( offsetElement () ) . toFormatter () ; }
String [] [] zoneStrings = new DateFormatSymbols ( locale ) . getZoneStrings () ;
throw new IllegalArgumentException ( STRING_CONSTANT + id ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + id ) ;
{ Hibernate.DATE . nullSafeSet ( preparedStatement , ( ( LocalDate ) value ) . toDateMidnight () . toDate () , index ) ; }
Object partial
Object readableInstant
Object durationField
Collection fields
Collection fields
Collection fields
List list
List elementPairs
List elementPairs
List pairs = iElementPairs ;
if ( iElementPairs == null ) { iElementPairs = new ArrayList () ; } else { iElementPairs . clear () ; }
Map ruleSets
{ iRules = new ArrayList () ; iRules . add ( rule ) ; }
public int compareTo ( Object durationField ) { return iField . compareTo ( durationField ) ; }
RuleSet () { iRules = new ArrayList ( NUMBER_CONSTANT ) ; iUpperYear = Integer.MAX_VALUE ; }
Object partial
Object partial
Map zimap
iZoneInfoMap . put ( id , new SoftReference ( tz ) ) ;
public int compareTo ( Object durationField ) { return NUMBER_CONSTANT ; }
List list
HashMap converted
HashMap converted
HashMap converted
HashMap converted
TreeMap map
TreeMap map
Object obj
assertEquals ( STRING_CONSTANT , f . withZone ( UTC ) . print ( dt ) ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
{ if ( ldp == null ) { ldp = dateElementParser () . withZone ( DateTimeZone.UTC ) ; } return ldp ; }
{ if ( value == null ) return null ; return new Instant ( value ) ; }
java.util.TimeZone . setDefault ( LONDON . toTimeZone () ) ;
{ locale = Locale . getDefault () ; zone = DateTimeZone . getDefault () ; Locale . setDefault ( Locale.UK ) ; }
java.util.TimeZone . setDefault ( LONDON . toTimeZone () ) ;
public YearMonth getYearMonth () { return iYearMonth ; }
protected ReadablePartial getReadablePartial () { return iYearMonth ; }
public DateTimeField getField () { return iYearMonth . getField ( iFieldIndex ) ; }
{ super(); iYearMonth = partial ; iFieldIndex = fieldIndex ; }
Map < String , Object > map = new TreeMap < String , Object > ( String.CASE_INSENSITIVE_ORDER ) ;
return iBase . getZone () . convertLocalToUTC ( localInstant , false ) ;
{ super ( duration , null , null ) ; }
{ super ( duration , null , null ) ; }
String s = ( String ) Hibernate.STRING . nullSafeGet ( resultSet , strings [ NUMBER_CONSTANT ] ) ;
{ if ( period != null ) { iValues = addPeriodInto ( getValues () , period ) ; } }
{ if ( period != null ) { iValues = mergePeriodInto ( getValues () , period ) ; } }
array = new Object [] { validValues , new Integer ( maxLength ) } ;
{ integers [ i ] = new Integer ( i ) ; }
array = new Object [] { validValues , new Integer ( maxLength ) } ;
protected void setUp ( ) throws Exception { originalLocale = Locale . getDefault () ; Locale . setDefault ( Locale.UK ) ; }
convId = zone . getDisplayName () ;
catch ( ArrayIndexOutOfBoundsException e ) { throw new IOException ( STRING_CONSTANT ) ; }
try { readZoneInfoMap ( din , map ) ; } finally { try { din . close () ; } catch ( IOException e ) {} }
StringBuffer msg = new StringBuffer () ;
StringBuffer sb = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer () ;
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
try { localDateTime . toDateTime ( this ) ; return false ; } catch ( IllegalArgumentException ex ) { return true ; }
throw new IllegalArgumentException ( message ) ;
{ if ( divisor == NUMBER_CONSTANT ) return this ; return new Duration ( FieldUtils . safeDivide ( getMillis () , divisor ) ) ; }
{ if ( multiplicand == NUMBER_CONSTANT ) return this ; return new Duration ( FieldUtils . safeMultiply ( getMillis () , multiplicand ) ) ; }
Partial newPartial = new Partial ( iChronology , newTypes , newValues ) ;
f2 = new DateTimeFormatter ( null , f . getParser () ) ;
DateTimePrinter [] elements = iPrinters ;
DateTimePrinter [] elements = iPrinters ;
f instanceof DateTimePrinter
DateTimePrinter printer
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( printer , parser ) ; }
{ checkPrinter ( printer ) ; return append0 ( printer , null ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter () , formatter . getParser () ) ; }
DateTimePrinter p = getFormatter ( locale ) . getPrinter () ;
return ( ( StyleFormatter ) formatter . getPrinter () ) . getPattern ( locale ) ;
{ printTo ( out , instant , null ) ; }
DateTimePrinter printer
{ return computeMillis ( resetFields , null ) ; }
{ return computeMillis ( false , null ) ; }
String text
f2 = new DateTimeFormatter ( ( InternalPrinter ) null , f . getParser () ) ;
{ reset () ; return doParseMillis ( parser , text ) ; }
String text
String text
String text
f instanceof DateTimeParser
DateTimeParser parser
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , parser ) ; }
{ checkParser ( parser ) ; return append0 ( null , parser ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter0 () , formatter . getParser () ) ; }
public DateTimeParser getParser () { return iParser ; }
DateTimeParser parser
DateTimeParser parser
{ this ( DateTimePrinterInternalPrinter . of ( printer ) , parser ) ; }
iMillis = FieldUtils . safeAdd ( endMillis , - startMillis ) ;
{ super(); iMillis = FieldUtils . safeAdd ( endInstant , - startInstant ) ; }
iSuffixes = texts ;
new PeriodFormatterBuilder () . appendDays () . appendSuffix ( STRING_CONSTANT ) . appendSuffix ( STRING_CONSTANT , STRING_CONSTANT )
if ( periodStr . regionMatches ( true , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
if ( periodStr . regionMatches ( false , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
synchronized ( DateTimeZone . class ) { cDefault = zone ; }
{ return new TreeSet < String > ( iZoneInfoMap . keySet () ) ; }
public Set < String > getAvailableIDs () { return Collections . singleton ( STRING_CONSTANT ) ; }
public static Set < String > getAvailableIDs () { return cAvailableIDs ; }
DateTimeZone zone = cProvider . getZone ( id ) ;
int curMonth0 = partial . getValue ( NUMBER_CONSTANT ) - NUMBER_CONSTANT ;
if ( ZoneInfoCompiler . verbose () ) { System.out . println ( STRING_CONSTANT + tz . getID () ) ; }
Interval interval = new Interval ( start , end ) ;
{ return FieldUtils . safeAdd ( getEndMillis () , - getStartMillis () ) ; }
{ millis = iField . set ( millis , iValue ) ; }
str = str . toLowerCase () ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter fmt = DateTimeFormat . forPattern ( STRING_CONSTANT ) ;
{ Provider provider = new ZoneInfoProvider ( STRING_CONSTANT ) ; return validateProvider ( provider ) ; }
try { retDT = new DateTime ( s ) ; } catch ( ParseException pe ) {}
ParseException e
Object f
Object f
Object f
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
DateTimeField field
DateTimeField field
char c
Object element
DateTimeParser parser
DateTimeParser parser
DateTimePrinter printer
DateTimeFormatter formatter
Chronology chrono
DateTimeZone zone
Chronology chrono = ISOChronology . getInstanceUTC () ;
public int getMinimumValue ( long millis ) { return NUMBER_CONSTANT ; }
int value
long millis
GJWeekyearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
ReadableInstant instant
public int get ( long millis ) { return BuddhistChronology.BE ; }
public String getNameKey ( long millis ) { return iNameKey ; }
{ return add ( millis , value - get ( millis ) ) ; }
public long add ( long millis , int value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
ParseException pe
{ return add ( millis , value - get ( millis ) ) ; }
public long add ( long millis , int value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
public long add ( long millis , int value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
return ( getMillis () < readableInstant . getMillis () ) ;
{ Chronology chrono = getChronology () ; return chrono != null ? chrono . getDateTimeZone () : null ; }
public AbstractInstant () { super(); }
catch ( ParseException pe ) { pe . printStackTrace () ; }
try { retDT = new DateTime ( s , DateTimeZone.UTC ) ; } catch ( ParseException pe ) { pe . printStackTrace () ; }
int value
GJMonthOfYearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
int value
public abstract boolean equals ( Object obj ) ;
public String print ( long millisUTC ) { throw unsupported () ; }
public String print ( ReadableInstant instant ) { throw unsupported () ; }
public String print ( ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
char c
char style
char style
