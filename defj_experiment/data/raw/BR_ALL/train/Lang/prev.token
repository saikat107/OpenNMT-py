Null () {}
public ObjectUtils () {}
public BooleanUtils () {}
public CharUtils () {}
public ClassUtils () {}
public NumberUtils () {}
public ArrayUtils () {}
public Validate () {}
public WordUtils () {}
public StringEscapeUtils () {}
public CharSetUtils () {}
public RandomStringUtils () {}
public EnumUtils () {}
private Entry () {}
public ExceptionUtils () {}
private Entry () {}
public EnumUtils () {}
public NumberUtils () {}
public DateFormatUtils () {}
public DateUtils () {}
public StopWatch () {}
public RandomStringUtils () { ; }
public StringEscapeUtils () { ; }
public WordUtils () { ; }
public CharSetUtils () { ; }
public CharUtils () { ; }
public NumberUtils () { ; }
public EnumUtils () { ; }
public ObjectUtils () { ; }
public BooleanUtils () { ; }
public ArrayUtils () { ; }
public ClassUtils () { ; }
{ try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {} return createBigInteger ( numeric ) ; }
{ try { if ( in != null ) { in . close () ; } } catch ( IOException ex ) {} }
{ try { if ( out != null ) { out . close () ; } } catch ( IOException ex ) {} }
{ try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {} return createBigInteger ( numeric ) ; }
if ( last == CHAR_CONS ) {} else { lastIdx ++ ; }
public StringUtils () {}
public SystemUtils () {}
{ try { if ( in != null ) { in . close () ; } } catch ( IOException ex ) { ; } }
{ try { if ( out != null ) { out . close () ; } } catch ( IOException ex ) { ; } }
public DateFormatUtils () { ; }
Null () { ; }
public DateUtils () { ; }
TwoDigitMonthField () { ; }
TwoDigitYearField () { ; }
UnpaddedMonthField () { ; }
public ExceptionUtils () { ; }
public NumberUtils () { ; }
public EnumUtils () { ; }
suite . addTestSuite ( VariableFormatTest . class ) ;
{ Object result = replaceObject ( source ) ; return ( result == null ) ? null : result . toString () ; }
sb . appendFixedWidthPadRight ( null , NUMBER_CONSTANT , CHAR_CONS ) ;
noPrimitives = new Class [] { String . class , ClassUtils . class }
assertEquals ( true , tenToTwenty . containsNumber ( nonComparable ) ) ;
Range r = new DoubleRange ( nonComparable ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparable ) ) ;
Range r = new IntRange ( nonComparable ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparable ) ) ;
Range r = new LongRange ( nonComparable ) ;
assertEquals ( true , tenToTwenty . containsFloat ( nonComparable ) ) ;
assertEquals ( true , tenToTwenty . containsDouble ( nonComparable ) ) ;
assertEquals ( true , tenToTwenty . containsInteger ( nonComparable ) ) ;
assertEquals ( true , tenToTwenty . containsLong ( nonComparable ) ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparable ) ) ;
Range r = new FloatRange ( nonComparable ) ;
{ return ( StrTokenizer ) TSV_TOKENIZER_PROTOTYPE . clone () ; }
{ return ( StrTokenizer ) CSV_TOKENIZER_PROTOTYPE . clone () ; }
int removeLen = endIndex = startIndex ;
{ return lastIndexOf ( str , size ) ; }
{ return lastIndexOf ( ch , NUMBER_CONSTANT ) ; }
{ return new String ( buf , size - length , size ) ; }
{ return new StringBuffer ( size ) . append ( buf , NUMBER_CONSTANT , size ) ; }
{ return new String ( buf , NUMBER_CONSTANT , size ) ; }
{ if ( str . charAt ( j ) != buf [ i + j ] ) { continue outer ; } }
{ if ( buf [ i ] == ch ) { return i ; } }
char [] thisBuf = buf ;
char [] thisBuf = buf ;
char [] thisBuf = buf ;
{ endIndex = validateRange ( startIndex , endIndex ) ; return new String ( buf , startIndex , endIndex - startIndex ) ; }
{ if ( buf [ pos ] != str . charAt ( i ) ) { return false ; } }
{ if ( buf [ i ] != str . charAt ( i ) ) { return false ; } }
if ( len > NUMBER_CONSTANT ) { System . arraycopy ( buf , endIndex , buf , startIndex , size - endIndex ) ; size -= len ; }
for ( int i = NUMBER_CONSTANT ; i < length ; i ++ ) { buf [ size ++ ] = padChar ; }
buf [ size ++ ] = ch ;
System . arraycopy ( chars , startIndex , buf , len , length ) ;
System . arraycopy ( chars , NUMBER_CONSTANT , buf , len , strLen ) ;
System . arraycopy ( str.buf , NUMBER_CONSTANT , buf , len , strLen ) ;
str . getChars ( NUMBER_CONSTANT , strLen , buf , len ) ;
str . getChars ( NUMBER_CONSTANT , strLen , buf , len ) ;
System . arraycopy ( buf , startIndex , destination , destinationIndex , endIndex - startIndex ) ;
System . arraycopy ( buf , NUMBER_CONSTANT , destination , NUMBER_CONSTANT , len ) ;
System . arraycopy ( buf , startIndex , chars , NUMBER_CONSTANT , len ) ;
System . arraycopy ( buf , NUMBER_CONSTANT , chars , NUMBER_CONSTANT , size ) ;
buf [ index ] = ch ;
{ if ( index < NUMBER_CONSTANT || index >= length () ) { throw new StringIndexOutOfBoundsException ( index ) ; } return buf [ index ] ; }
for ( int i = oldEnd ; i < newEnd ; i ++ ) { buf [ i ] = CHAR_CONS ; }
{ super(); if ( initialCapacity <= NUMBER_CONSTANT ) { initialCapacity = CAPACITY ; } buf = new char [ initialCapacity ] ; }
assertEquals ( true , sb.buf.length >= NUMBER_CONSTANT ) ;
if ( pos + len >= textLen ) { return NUMBER_CONSTANT ; }
{ return ( boolean [] ) add ( array , index , new Boolean ( element ) , Boolean.TYPE ) ; }
try { sb . setLength ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( StringIndexOutOfBoundsException e ) {}
try { sb . setLength ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( StringIndexOutOfBoundsException e ) {}
try { sb . deleteCharAt ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( StringIndexOutOfBoundsException e ) {}
{ if ( startPos < getPos () ) { getTokenList () . addLast ( Token . newTextToken ( startPos , getPos () - startPos ) ) ; } }
if ( last == CharUtils.CR ) { ; } else { lastIdx ++ ; }
private void setVarStartMatcher ( StrTokenizer.Matcher varStartMatcher ) { this . varStartMatcher = varStartMatcher ; }
private void setVarEndMatcher ( StrTokenizer.Matcher varEndMatcher ) { this . varEndMatcher = varEndMatcher ; }
private void setEscVarMatcher ( StrTokenizer.Matcher escVarMatcher ) { this . escVarMatcher = escVarMatcher ; }
Matcher trimmer
{ setIgnoredMatcher ( new CharMatcher ( ignored ) ) ; }
Matcher ignored
{ setQuoteMatcher ( new CharMatcher ( quote ) ) ; }
Matcher quote
start == len && delim . isMatch ( chars , len , start - NUMBER_CONSTANT ) == NUMBER_CONSTANT
Matcher delim
Matcher delim
tok . setIgnoredMatcher ( StrTokenizer.TRIM_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.TRIM_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.TRIM_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.NONE_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.NONE_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.TRIM_MATCHER ) ;
sb . replaceAll ( CHAR_CONS , CHAR_CONS ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
if ( cloned.chars != null ) { cloned.chars = ( char [] ) cloned.chars ; }
if ( cloned.chars != null ) { cloned.chars = cloned.chars ; }
public boolean isEmptyTokenAsNull () { return emptyAsNull ; }
{ if ( trimmer != null ) { this . trimmer = trimmer ; } return this ; }
public StrMatcher getTrimmerMatcher () { return trimmer ; }
{ if ( ignored != null ) { this . ignored = ignored ; } return this ; }
public StrMatcher getIgnoredMatcher () { return ignored ; }
{ if ( quote != null ) { this . quote = quote ; } return this ; }
public StrMatcher getQuoteMatcher () { return quote ; }
public StrMatcher getDelimiterMatcher () { return delim ; }
{ assertTrue ( ! bf_multi . isAllSet ( j ) ) ; assertTrue ( ! bf_zero . isAllSet ( j ) ) ; }
{ super ( msg == null ? STRING_CONSTANT : msg ) ; this . cause = cause ; }
{ super ( STRING_CONSTANT ) ; this . cause = cause ; }
{ super ( msg == null ? STRING_CONSTANT : msg ) ; }
public NotImplementedException () { super ( STRING_CONSTANT ) ; }
private void tokenize () { if ( tokens == null ) { this . tokens = readTokens () ; } }
sb . append ( true ) ;
assertLocaleLookupList ( LOCALE_EN_US_ZZZZ , null , new Locale [] { LOCALE_EN_US_ZZZZ , LOCALE_EN_US , new Locale ( STRING_CONSTANT ) } ) ;
assertLocaleLookupList ( LOCALE_EN_US_ZZZZ , null , new Locale [] { LOCALE_EN_US_ZZZZ , LOCALE_EN_US , new Locale ( STRING_CONSTANT , STRING_CONSTANT ) } ) ;
{ return str != null && str . length () > NUMBER_CONSTANT ; }
List list = new LinkedList () ;
List list = new LinkedList () ;
{ append ( str , off , len ) ; }
{ append ( cbuf , off , len ) ; }
public void write ( char [] cbuf ) { append ( cbuf ) ; }
public void write ( int c ) { append ( ( char ) c ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
{ return indexOf ( array , valueToFind , NUMBER_CONSTANT , tolerance ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , objectToFind ) != - NUMBER_CONSTANT ; }
{ return reflectionEquals ( lhs , rhs , testTransients , null ) ; }
{ return reflectionEquals ( lhs , rhs , false , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null ) ; }
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , testTransients , null ) ; }
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , false , null ) ; }
{ return reflectionCompare ( lhs , rhs , compareTransients , null ) ; }
{ return reflectionCompare ( lhs , rhs , false , null ) ; }
HashCodeBuilder . reflectionHashCode ( x , null )
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
public boolean hasPrevious () { tokenize () ; return tokenPos > NUMBER_CONSTANT ; }
public boolean hasNext () { tokenize () ; return tokenPos < tokens.length ; }
tokenize () ;
{ tokenize () ; return ( String [] ) tokens . clone () ; }
public int size () { tokenize () ; return tokens.length ; }
assertSame ( input , tok . getContent () ) ;
{ if ( ready () == false ) { return - NUMBER_CONSTANT ; } return charAt ( pos ++ ) ; }
String varValue = resolveVariable ( varName ) ;
if ( substitute ( buf , NUMBER_CONSTANT , length ) == false ) { return source . substring ( offset , length ) ; }
VariableResolver variableResolver
{ this ( new MapVariableResolver ( valueMap ) , prefix , suffix , escape ) ; }
{ this ( valueMap , prefix , suffix , DEFAULT_ESCAPE ) ; }
{ this ( new MapVariableResolver ( valueMap ) , DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ESCAPE ) ; }
{ return new StrSubstitutor ( System . getProperties () ) . replace ( source ) ; }
return ( Enum ) entry.map . get ( getName () ) ;
private Entry () { super(); }
return ( Enum ) entry.map . get ( getName () ) ;
private Entry () { super(); }
sub . replace ( builder ) ;
assertEquals ( NUMBER_CONSTANT , ExceptionUtils . getThrowableCount ( recursiveCause ) ) ;
recursiveCause = null ;
recursiveCause = new ExceptionWithCause ( a ) ;
private DefaultToStringStyle () { super(); }
protected DefaultToStringStyle () { super(); }
public Object getValue () { return new Boolean ( this . value ) ; }
public Object getValue () { return Boolean . valueOf ( this . value ) ; }
public Object getValue () { return new Boolean ( this . value ) ; }
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
{ StringWriter stringWriter = newStringWriter ( str ) ; this . unescape ( stringWriter , str ) ; return stringWriter . toString () ; }
{ StringWriter stringWriter = newStringWriter ( str ) ; this . escape ( stringWriter , str ) ; return stringWriter . toString () ; }
assertSame ( CharSet.EMPTY , CharSet . getInstance ( null ) ) ;
CharSet chars = evaluateSet ( set ) ;
CharSet chars = evaluateSet ( set ) ;
CharSet chars = evaluateSet ( set ) ;
stopTime = System . currentTimeMillis () ;
stopTime = - NUMBER_CONSTANT ;
stopTime = System . currentTimeMillis () ;
if ( this . runningState == STATE_RUNNING ) { stopTime = System . currentTimeMillis () ; }
protected void setUp ( ) throws Exception { super . setUp () ; }
if ( ! containsCsvChars ( str ) ) { return str ; }
MessageFormat f = createMessageFormat ( pattern ) ;
subformats . put ( INTEGER , NumberFormat . getIntegerInstance ( getLocale () ) ) ;
NumberFormat . getIntegerInstance ( Locale.US )
{ return splitByWholeSeparator ( str , separator , - NUMBER_CONSTANT ) ; }
{ clazz = Class . forName ( toProperClassName ( className ) , initialize , classLoader ) ; }
if ( StringUtils . containsAny ( quoteless , CSV_SEARCH_CHARS ) ) { str = StringUtils . replace ( quoteless , STRING_CONSTANT + CSV_QUOTE + CSV_QUOTE , CSV_QUOTE_STR ) ; }
catch ( IllegalArgumentException e ) {}
if ( replaceChars == null ) { replaceChars = STRING_CONSTANT ; }
{ if ( isEmpty ( str ) || isEmpty ( remove ) ) { return str ; } return replace ( str , remove , STRING_CONSTANT , - NUMBER_CONSTANT ) ; }
{ return new ExtendedMessageFormat ( pattern , locale , ExtendedMessageFormat . createDefaultMetaFormat ( locale ) ) ; }
assertEquals ( pattern , emf . toPattern () ) ;
assertEquals ( STRING_CONSTANT , pattern , emf . toPattern () ) ;
int mid = ( low + high ) > > NUMBER_CONSTANT ;
osName . toLowerCase () . startsWith ( STRING_CONSTANT )
{ return Integer . toHexString ( ch ) . toUpperCase () ; }
catch ( IOException ioe ) { ioe . printStackTrace () ; return null ; }
catch ( IOException ioe ) { ioe . printStackTrace () ; return null ; }
catch ( IOException ioe ) { ioe . printStackTrace () ; return null ; }
catch ( IOException ioe ) { ioe . printStackTrace () ; return null ; }
{ getRegistry () . remove ( toIdentityHashCodeInteger ( value ) ) ; }
{ getRegistry () . add ( toIdentityHashCodeInteger ( value ) ) ; }
{ return getRegistry () . contains ( toIdentityHashCodeInteger ( value ) ) ; }
roundUp = offset > NUMBER_CONSTANT ;
{ if ( this . runningState == STATE_UNSTARTED ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } return this . startTime ; }
this . startTime += ( System . currentTimeMillis () - this . stopTime ) ;
this . stopTime = System . currentTimeMillis () ;
this . stopTime = System . currentTimeMillis () ;
if ( this . runningState == STATE_RUNNING ) { this . stopTime = System . currentTimeMillis () ; }
public static Test suite () { return new TestSuite ( NestableErrorTestCase . class ) ; }
public static Test suite () { return new TestSuite ( NestableExceptionTestCase . class ) ; }
public static Test suite () { return new TestSuite ( NestableRuntimeExceptionTestCase . class ) ; }
public ExceptionUtilsTestCase ( String name ) { super ( name ) ; }
public String toString () { return STRING_CONSTANT ; }
{ return ( ( Boolean ) IS_SYNTHETIC . invoke ( m , null ) ) . booleanValue () ; }
objects [ NUMBER_CONSTANT ] = ( Object ) simple ;
objectsLevel2 [ NUMBER_CONSTANT ] = ( Object ) objects ;
{ if ( array == null ) { return null ; } return ( boolean [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( float [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( double [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( byte [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( char [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( short [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( int [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( long [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( Object [] ) array . clone () ; }
if ( cloned.chars != null ) { cloned.chars = ( char [] ) cloned.chars . clone () ; }
{ checkTokenized () ; return ( String [] ) tokens . clone () ; }
public Throwable getCause () { return cause ; }
public String toString () { return toString ; }
sb . appendln ( ( Object ) FOO ) ;
{ super ( msg ) ; }
{ super ( msg ) ; }
{ super ( msg ) ; }
String [] splitOnNullResults = StringUtils . splitByWholeSeparator ( STRING_CONSTANT , null ) ;
{ ObjectUtils . appendIdentityToString ( this . getStringBuffer () , object ) ; return this ; }
{ ObjectUtils . appendIdentityToString ( buffer , value ) ; }
String pBaseStr = p . getClass () . getName () ;
{ super ( DEFAULT_MESSAGE ) ; this . cause = cause ; }
final Nestable n = new UnhandledException ( t ) ;
catch ( NumberFormatException nfe ) { throw new NestableRuntimeException ( STRING_CONSTANT + unicode , nfe ) ; }
String entityValue = Entities.ISO8859_1_ARRAY [ i % Entities.ISO8859_1_ARRAY.length ] [ NUMBER_CONSTANT ] ;
String entityValue = Entities.HTML40_ARRAY [ i % Entities.HTML40_ARRAY.length ] [ NUMBER_CONSTANT ] ;
Collection collection
Collection collection
Iterator iterator
Iterator iterator
Iterator it
Iterator it
List tokens
List tokens
List list
public Byte toByte () { return new Byte ( byteValue () ) ; }
public Object getValue () { return new Byte ( this . value ) ; }
{ mutNum . compareTo ( new Byte ( ( byte ) NUMBER_CONSTANT ) ) ; fail () ; }
{ return ( byte [] ) add ( array , index , new Byte ( element ) , Byte.TYPE ) ; }
{ result [ i ] = new Byte ( array [ i ] ) ; }
Class type
Class type
Class type
Class clazz
Class clazz
List list = getCauseMethodNameList () ;
List list = getCauseMethodNameList () ;
Class clazz
Map registry
Map registry
Object obj
Object obj
Class lhsClass = lhs . getClass () ;
Class clazz
Class reflectUpToClass
Collection excludeFields
Class cls = target . getClass () ;
Class cls = target . getClass () ;
Class cls
Class cls
Class cls
Class cls
Class cls = target . getClass () ;
Class cls = target . getClass () ;
Class cls
Class cls
Class cls
Class cls
Class cls
Class cls
Class cls
Class clazz
Class clazz
Class reflectUpToClass
Collection collection
Collection excludeFieldNames
Class reflectUpToClass
List priorVariables
Class cls
Class cls
Class cls
Class cls
Class cls
Class clss
Class clss = null ;
Class newArrayComponentType
Class cls
Class expected
Class clazz
Class reflectUpToClass
Collection excludeFields
Collection excludeFields
Class reflectUpToClass
Class clazz
Class cls
Class cls
if ( methodNames == null ) { synchronized ( CAUSE_METHOD_NAMES ) { methodNames = CAUSE_METHOD_NAMES ; } }
{ synchronized ( CAUSE_METHOD_NAMES ) { return getCause ( throwable , CAUSE_METHOD_NAMES ) ; } }
if ( list . remove ( methodName ) ) { synchronized ( CAUSE_METHOD_NAMES ) { CAUSE_METHOD_NAMES = toArray ( list ) ; } }
if ( list . add ( methodName ) ) { synchronized ( CAUSE_METHOD_NAMES ) { CAUSE_METHOD_NAMES = toArray ( list ) ; } }
Iterator it
Iterator it
Iterator it
assertTrue ( ObjectUtils.NULL != null ) ;
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , obj , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ return ( boolean [] ) add ( array , index , BooleanUtils . toBooleanObject ( element ) , Boolean.TYPE ) ; }
public Object getValue () { return BooleanUtils . toBooleanObject ( this . value ) ; }
{ if ( cls == null ) { return StringUtils.EMPTY ; } return getPackageName ( cls . getName () ) ; }
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = NumberUtils . compare ( lhs , rhs ) ; return this ; }
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = NumberUtils . compare ( lhs , rhs ) ; return this ; }
return NumberUtils . compare ( value , anotherVal ) ;
return NumberUtils . compare ( value , anotherVal ) ;
int compare = ( ( Comparable ) num1 ) . compareTo ( num2 ) ;
Map map
Collection collection
Comparator comparator
Class < > clazz
Object object
Object object
Object object
Object object
Object object
Object object
Map map
public String [] getExcludeFieldNames () { return this . excludeFieldNames ; }
{ unescapeJava ( out , str ) ; }
{ return unescapeJava ( str ) ; }
{ escapeJavaStyleString ( out , str , true , true ) ; }
{ return escapeJavaStyleString ( str , true , true ) ; }
{ escapeJavaStyleString ( out , str , false , false ) ; }
{ return escapeJavaStyleString ( str , false , false ) ; }
{ return UnescapeUtils.UNESCAPE_CSV . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_CSV . translate ( str ) ; }
{ return UnescapeUtils.UNESCAPE_XML . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_XML . translate ( str ) ; }
{ return UnescapeUtils.UNESCAPE_HTML4 . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_HTML4 . translate ( str ) ; }
{ return UnescapeUtils.UNESCAPE_ECMASCRIPT . translate ( str ) ; }
{ return UnescapeUtils.UNESCAPE_JAVA . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_ECMASCRIPT . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_JAVA . translate ( str ) ; }
void setValue ( Object value ) ;
Object getValue ( ) ;
Object value
Object value
String str
String str
String str
String str
modify ( truncated , field , false ) ;
modify ( gval , field , false ) ;
modify ( rounded , field , true ) ;
modify ( gval , field , true ) ;
{ throw new NullArgumentException ( STRING_CONSTANT ) ; }
if ( target == null ) { throw new NullArgumentException ( STRING_CONSTANT ) ; }
catch ( NumberFormatException nfe ) { throw new UnhandledException ( STRING_CONSTANT + unicode , nfe ) ; }
assertGetClassThrowsIllegalArgument ( null ) ;
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
buffer = new char [ capacity ] ;
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ result [ i ] = new Float ( array [ i ] ) ; }
{ result [ i ] = new Double ( array [ i ] ) ; }
{ result [ i ] = new Short ( array [ i ] ) ; }
{ result [ i ] = new Integer ( array [ i ] ) ; }
{ result [ i ] = new Long ( array [ i ] ) ; }
{ result [ i ] = new Character ( array [ i ] ) ; }
double [] array2
float [] array2
long [] array2
int [] array2
short [] array2
byte [] array2
char [] array2
boolean [] array2
object instanceof Map.Entry
Iterator it = collection . iterator ()
Iterator it = collection . iterator ()
Iterator it = collection . iterator ()
Iterator it = collection . iterator ()
if ( num1 instanceof Comparable == false ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( num instanceof Comparable == false ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
oos . writeObject ( new ClassNotFoundSerializationTest () ) ;
{ if ( object == null ) { return valueIfNull ; } return getPackageName ( object . getClass () . getName () ) ; }
{ if ( object == null ) { return valueIfNull ; } return getShortClassName ( object . getClass () . getName () ) ; }
{ if ( cls == null ) { return StringUtils.EMPTY ; } return cls . getPackage () . getName () ; }
isEscapingPlus ()
uu . setEscapingPlus ( true ) ;
uu = new UnicodeUnescaper ( UnicodeUnescaper.PARAM.escapePlus ) ;
isSet ( PARAM.escapePlus )
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer result = new StringBuffer () ;
StringBuffer buffer = new StringBuffer ( strLen ) ;
StringBuffer buffer = new StringBuffer ( strLen ) ;
StringBuffer buffer = new StringBuffer ( strLen ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer canonicalClassNameBuffer = new StringBuffer ( className ) ;
StringBuffer classNameBuffer = new StringBuffer () ;
StringBuffer arrayPrefix = new StringBuffer () ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buffer = new StringBuffer ( strLen ) ;
new StringBuffer ( strLen ) . append ( Character . toLowerCase ( str . charAt ( NUMBER_CONSTANT ) ) ) . append ( str . substring ( NUMBER_CONSTANT ) )
new StringBuffer ( strLen ) . append ( Character . toTitleCase ( str . charAt ( NUMBER_CONSTANT ) ) ) . append ( str . substring ( NUMBER_CONSTANT ) )
StringBuffer buf = new StringBuffer ( outputLength ) ;
StringBuffer buf = new StringBuffer ( strLength ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( bufSize ) ;
StringBuffer buf = new StringBuffer ( bufSize ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buffer = new StringBuffer ( NUMBER_CONSTANT ) ;
toString = new StringBuffer ( NUMBER_CONSTANT ) . append ( getNumerator () ) . append ( CHAR_CONS ) . append ( getDenominator () ) . toString () ;
StringBuffer buffer = new StringBuffer () ;
StringBuffer buf = new StringBuffer () ;
CharRange range = new CharRange ( CHAR_CONS ) ;
Collection collection
Collection collection
Class cls
Map map
Collection coll
Class cls
Class cls
Class [] parameterTypes
Class [] parameterTypes
assertEquals ( null , StringUtils . join ( ( Collection ) null , null ) ) ;
assertEquals ( null , StringUtils . join ( ( Collection ) null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . join ( ( Iterator ) null , null ) ) ;
assertEquals ( null , StringUtils . join ( ( Iterator ) null , CHAR_CONS ) ) ;
Class exceptionType
Class c
assertFalse ( ClassUtils . isAssignable ( ( Class ) null , null , true ) ) ;
assertFalse ( ClassUtils . isAssignable ( ( Class ) null , null ) ) ;
assertEquals ( STRING_CONSTANT , ClassUtils . getPackageName ( ( Class ) null ) ) ;
iMap = new HashMap () ;
Class [] c
sb . appendWithSeparators ( ( Iterator ) null , STRING_CONSTANT ) ;
sb . appendWithSeparators ( ( Collection ) null , STRING_CONSTANT ) ;
sb . appendAll ( ( Iterator ) null ) ;
sb . appendAll ( ( Collection ) null ) ;
public String getFormattedExceptionMessage ( String baseMessage ) { return this . exceptionContext . getFormattedExceptionMessage ( baseMessage ) ; }
public String getFormattedExceptionMessage ( String baseMessage ) { return this . exceptionContext . getFormattedExceptionMessage ( baseMessage ) ; }
Serializable value
Serializable value
StringBuilder buffer = new StringBuilder () ;
Class [] c
values = new HashMap () ;
List list = tok . getTokenList () ;
Map map = null ;
Map < String , FormatFactory > registry
Map registry
Map registry
String toString = ReflectionToStringBuilder . toStringExclude ( new TestFixture () , ( Collection ) null ) ;
String toString = ReflectionToStringBuilder . toStringExclude ( new TestFixture () , new ArrayList () ) ;
T object
T object
T object
T object
T object
T object
{ this ( object , getDefaultStyle () , null ) ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( this . getMinimum () , element ) < NUMBER_CONSTANT ; }
StringEscapeUtils . unescapeCsv ( writer , value ) ;
StringEscapeUtils . escapeCsv ( writer , value ) ;
StringEscapeUtils . unescapeJava ( writer , original ) ;
StringEscapeUtils . escapeJava ( writer , original ) ;
Comparator c
{ try { return initialize () ; } finally { if ( executor != null ) { executor . shutdown () ; } } }
{ executor = exec ; }
{ this . translators = translators ; }
{ return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE , index ) ; }
{ return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EXCEPTION_MESSAGE , index ) ; }
{ return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EXCEPTION_MESSAGE , index ) ; }
Object [] values2 = ArrayUtils . addAll ( values , i ) ;
Object [] values2 = ArrayUtils . add ( values , i ) ;
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , value ) ) ; } }
{ calendar . getTime () ; calendar = ( Calendar ) calendar . clone () ; calendar . setTimeZone ( mTimeZone ) ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( element , getMaximum () ) > NUMBER_CONSTANT ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( element , getMinimum () ) < NUMBER_CONSTANT ; }
return getCauseUsingFieldName ( throwable , STRING_CONSTANT ) ;
{ return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return noNullElements ( iterable , DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EXCEPTION_MESSAGE ) ; }
{ return noNullElements ( array , DEFAULT_NO_NULL_ELEMENTS_ARRAY_EXCEPTION_MESSAGE ) ; }
{ return notBlank ( chars , DEFAULT_NOT_BLANK_EXCEPTION_MESSAGE ) ; }
{ return notEmpty ( chars , DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EXCEPTION_MESSAGE ) ; }
{ return notEmpty ( map , DEFAULT_NOT_EMPTY_MAP_EXCEPTION_MESSAGE ) ; }
{ return notEmpty ( collection , DEFAULT_NOT_EMPTY_COLLECTION_EXCEPTION_MESSAGE ) ; }
{ return notEmpty ( array , DEFAULT_NOT_EMPTY_ARRAY_EXCEPTION_MESSAGE ) ; }
{ return notNull ( object , DEFAULT_IS_NULL_EXCEPTION_MESSAGE ) ; }
StrLookup variableResolver
StrLookup resolver = getVariableResolver () ;
StrLookup variableResolver
StrLookup variableResolver
StrLookup variableResolver
public StrSubstitutor () { this ( ( StrLookup ) null , DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ESCAPE ) ; }
{ return m != null && Modifier . isPublic ( m . getModifiers () ) && ! isSynthetic ( m ) ; }
validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
{ return registry . get () ; }
String str
if ( str == null || suffix == null ) { return ( str == null && suffix == null ) ; }
{ if ( str == null ) { return null ; } return new StringBuilder ( str ) . reverse () . toString () ; }
if ( ( str == null ) || ( searchStrs == null ) ) { return - NUMBER_CONSTANT ; }
smallestIndexOfDiff == - NUMBER_CONSTANT
if ( at == - NUMBER_CONSTANT ) { return EMPTY ; }
if ( isEmpty ( str ) || str . indexOf ( remove ) == - NUMBER_CONSTANT ) { return str ; }
if ( pos == - NUMBER_CONSTANT || pos == ( str . length () - separator . length () ) ) { return EMPTY ; }
if ( pos == - NUMBER_CONSTANT ) { return str ; }
if ( pos == - NUMBER_CONSTANT ) { return EMPTY ; }
if ( pos == - NUMBER_CONSTANT ) { return str ; }
return indexOfAnyBut ( cs , valid ) == - NUMBER_CONSTANT ;
{ if ( isEmpty ( cs ) || isEmpty ( searchChars ) ) { return - NUMBER_CONSTANT ; } return indexOfAny ( cs , searchChars . toCharArray () ) ; }
if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; }
{ if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; } return str . lastIndexOf ( searchStr , startPos ) ; }
{ if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; } return str . lastIndexOf ( searchStr ) ; }
{ if ( isEmpty ( str ) ) { return - NUMBER_CONSTANT ; } return str . lastIndexOf ( searchChar , startPos ) ; }
{ if ( isEmpty ( str ) ) { return - NUMBER_CONSTANT ; } return str . lastIndexOf ( searchChar ) ; }
{ if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; } return str . indexOf ( searchStr , startPos ) ; }
{ if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; } return str . indexOf ( searchStr ) ; }
( start != strLen ) && ( stripChars . indexOf ( str . charAt ( start ) ) != - NUMBER_CONSTANT )
{ if ( str == null ) { return null ; } return CharSequenceUtils . reverse ( str ) . toString () ; }
char searchChar
char searchChar
char searchChar
char searchChar
char searchChar
Class < > [] parameterTypes
Class < > [] parameterTypes
Class < > [] parameterTypes
Class < > [] parameterTypes
Object [] args
Object [] args
Object [] args
Object [] args
String [] parsePatterns
String [] parsePatterns
String [] strs
CharSequence [] css
Boolean [] array
boolean [] array
char [] delimiters
char [] delimiters
char [] delimiters
char [] delimiters
Class < > [] parameterTypes
Class < > [] parameterTypes
Object [] args
Object [] args
String [] searchStrings
assertEquals ( NUMBER_CONSTANT , new MutableDouble ( STRING_CONSTANT ) . floatValue () , NUMBER_CONSTANT ) ;
{ return reflectionCompare ( lhs , rhs , false , reflectUpToClass , null ) ; }
isAssignable ( midClass , superClass ) && isAssignable ( ( Type ) genericInterface , ( Type ) midClass )
listeners . fire () . propertyChange ( new PropertyChangeEvent ( this , STRING_CONSTANT , STRING_CONSTANT , property ) ) ;
{ Validate . notNull ( listener , STRING_CONSTANT ) ; listeners . add ( NUMBER_CONSTANT , listener ) ; }
{ final String [] array = ArrayUtilsTest . < String > toArrayPropagatingType () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtils . < String > toArray () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtilsTest . toArrayPropagatingType () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtils . toArray () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( - NUMBER_CONSTANT , StringUtils . indexOfDifference ( null ) ) ;
String [] results = null ;
String [] results = null ;
assertEquals ( null , StringUtils . concatWith ( null , null ) ) ;
assertEquals ( null , StringUtils . concat ( null ) ) ;
{ DateUtils . parseDate ( dateStr , null ) ; fail () ; }
{ if ( expression == false ) { throw new IllegalArgumentException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } }
return new StringBuilder ( annotationType == null ? null : annotationType . getName () ) . insert ( NUMBER_CONSTANT , CHAR_CONS ) . toString () ;
SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT )
{ return isAssignable ( cls , toClass , SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ) ; }
{ return isAssignable ( classArray , toClassArray , SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ) ; }
boolean atLeastJava14 = SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ;
{ return isJavaVersionMatch ( JAVA_VERSION_TRIMMED , versionPrefix ) ; }
if ( SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ) { assertEquals ( STRING_CONSTANT , new BigDecimal ( STRING_CONSTANT ) , NumberUtils . createNumber ( STRING_CONSTANT ) ) ; }
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ;
{ if ( SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ) { assertEquals ( message , expected , actual ) ; } }
static JavaVersion getJavaVersion ( final String nom ) { return getJavaVersion ( nom ) ; }
{ return ( options == null ) ? false : options . contains ( opt ) ; }
assertEquals ( true , StringUtils . isNumeric ( STRING_CONSTANT ) ) ;
assertEquals ( true , StringUtils . isAlphanumeric ( STRING_CONSTANT ) ) ;
assertEquals ( true , StringUtils . isAlpha ( STRING_CONSTANT ) ) ;
{ return format ( date , pattern , DateUtils.UTC_TIME_ZONE , locale ) ; }
{ return format ( new Date ( millis ) , pattern , DateUtils.UTC_TIME_ZONE , locale ) ; }
{ return format ( date , pattern , DateUtils.UTC_TIME_ZONE , null ) ; }
{ return format ( new Date ( millis ) , pattern , DateUtils.UTC_TIME_ZONE , null ) ; }
Pair < IDKey , IDKey > swappedPair = Pair . of ( pair.right , pair.left ) ;
{ return isEquals () ; }
public Integer build () { return toHashCode () ; }
{ return toComparison () ; }
HashCodeBuilder . class
HashCodeBuilder . class
new StringBuilder ( strLen ) . append ( Character . toLowerCase ( cs . charAt ( NUMBER_CONSTANT ) ) ) . append ( CharSequenceUtils . subSequence ( cs , NUMBER_CONSTANT ) )
new StringBuilder ( strLen ) . append ( Character . toTitleCase ( cs . charAt ( NUMBER_CONSTANT ) ) ) . append ( CharSequenceUtils . subSequence ( cs , NUMBER_CONSTANT ) )
String cs
return sequenceToString ( str . subSequence ( start , end ) ) ;
return sequenceToString ( str . subSequence ( start , str . length () ) ) ;
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
String [] set
Object [] array
Class < > parameterTypes []
Class < > [] classes
Class < > [] classes
Class < > [] toClassArray
char [] chars
char [] chars
return types . toArray ( new Type [ NUMBER_CONSTANT ] ) ;
return frames . toArray ( new String [ NUMBER_CONSTANT ] ) ;
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
String [] searchStrs
String [] searchStrs
char [] searchChars
String [] strs
CharSequence input
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
( idx = indexOfSequence ( str , sub , idx ) ) != INDEX_NOT_FOUND
tmp = lastIndexOfSequence ( str , search , str . length () ) ;
tmp = indexOfSequence ( str , search , NUMBER_CONSTANT ) ;
{ if ( searchChars == null ) { return false ; } return containsAny ( cs , toCharArraySequence ( searchChars ) ) ; }
{ if ( regionMatchesSequence ( str , true , i , searchStr , NUMBER_CONSTANT , len ) ) { return true ; } }
return indexOfSequence ( seq , searchSeq , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ;
{ if ( isEmpty ( seq ) ) { return false ; } return indexOfSequence ( seq , searchChar , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return StringUtils . lastIndexOfSequence ( seq , searchSeq , startPos ) ; }
return StringUtils . lastIndexOfSequence ( seq , searchSeq , seq . length () ) ;
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return StringUtils . lastIndexOfSequence ( seq , searchChar , startPos ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return StringUtils . lastIndexOfSequence ( seq , searchChar , seq . length () ) ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return StringUtils . indexOfSequence ( seq , searchSeq , startPos ) ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return StringUtils . indexOfSequence ( seq , searchSeq , NUMBER_CONSTANT ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return StringUtils . indexOfSequence ( seq , searchChar , startPos ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return StringUtils . indexOfSequence ( seq , searchChar , NUMBER_CONSTANT ) ; }
{ return value == NUMBER_CONSTANT ? false : true ; }
{ if ( bool == null ) { return valueIfNull ; } return bool . booleanValue () ? true : false ; }
{ if ( bool == null ) { return null ; } return ( bool . booleanValue () ? Boolean.FALSE : Boolean.TRUE ) ; }
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
if ( lastWasGap ) { buf [ count ++ ] = ch ; lastWasGap = false ; } else {}
String [] excludeFields
{ return reflectionCompare ( lhs , rhs , compareTransients , null , null ) ; }
{ return reflectionCompare ( lhs , rhs , false , null , null ) ; }
String [] excludeFields
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , testTransients , null , null ) ; }
String [] excludeFields
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null , null ) ; }
String [] excludeFieldNames
String [] excludeFields
{ return reflectionEquals ( lhs , rhs , testTransients , null , null ) ; }
String [] excludeFields
{ this . excludeFieldNames = excludeFieldNamesParam . clone () ; Arrays . sort ( this . excludeFieldNames ) ; }
StringBuilder builder = new StringBuilder ( ClassUtils . getShortClassName ( this , null ) ) ;
char [] chars
@ Override public R getRightElement () { return rightElement ; }
@ Override public L getLeftElement () { return leftElement ; }
Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeftElement () , pair . getRightElement () ) ;
{ R result = getRightElement () ; setRightElement ( value ) ; return result ; }
public R getValue () { return getRightElement () ; }
public final L getKey () { return getLeftElement () ; }
{ try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return ( null ) ; } }
{ try { return getAccessibleConstructor ( cls . getConstructor ( parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return ( null ) ; } }
Calendar c = new GregorianCalendar ( mTimeZone ) ;
Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ;
{ return getDateTimeInstance ( dateStyle , timeStyle , null , locale ) ; }
{ return getDateTimeInstance ( dateStyle , timeStyle , null , null ) ; }
{ return getTimeInstance ( style , timeZone , null ) ; }
{ return getTimeInstance ( style , null , locale ) ; }
{ return getTimeInstance ( style , null , null ) ; }
{ return getDateInstance ( style , timeZone , null ) ; }
{ return getDateInstance ( style , null , locale ) ; }
{ return getDateInstance ( style , null , null ) ; }
{ return getInstance ( pattern , null , locale ) ; }
{ return getInstance ( pattern , timeZone , null ) ; }
{ return getInstance ( pattern , null , null ) ; }
CharSequence _ellipsis = ObjectUtils . defaultIfNull ( ellipsis , STRING_CONSTANT ) ;
return padding ( pads , padChar ) . concat ( str ) ;
return str . concat ( padding ( pads , padChar ) ) ;
if ( inputLength == NUMBER_CONSTANT && repeat <= PAD_LIMIT ) { return padding ( repeat , str . charAt ( NUMBER_CONSTANT ) ) ; }
return pad ( pads , padChar ) . concat ( str ) ;
return str . concat ( pad ( pads , padChar ) ) ;
assertSame ( Locale.GERMANY , format1 . getLocale () ) ;
{ Integer count = eventCounts . get ( eventName ) ; return count == null ? NUMBER_CONSTANT : count ; }
{ R result = getRight () ; setRightElement ( value ) ; return result ; }
{ if ( isSet ( OPTION.semiColonRequired ) ) { return NUMBER_CONSTANT ; } else if ( isSet ( OPTION.errorIfNoSemiColon ) ) { throw new RuntimeException ( STRING_CONSTANT ) ; } }
int delimLen = ( delimiters == null ? - NUMBER_CONSTANT : delimiters.length ) ;
@ Override
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
if ( timeToLive < NUMBER_CONSTANT ) { throw new IllegalStateException ( STRING_CONSTANT + timeToLive + STRING_CONSTANT + text ) ; }
{ if ( StringUtils . isEmpty ( str ) ) { return null ; } return toCharacterObject ( str . charAt ( NUMBER_CONSTANT ) ) ; }
try { FieldUtils . writeField ( field , publicChild , new Integer ( Integer.MAX_VALUE ) ) ; } catch ( IllegalAccessException e ) {}
Integer val = new Integer ( NUMBER_CONSTANT ) ;
Integer val = new Integer ( NUMBER_CONSTANT ) ;
sb . appendln ( new Integer ( NUMBER_CONSTANT ) ) ;
iInteger = new Integer ( NUMBER_CONSTANT ) ;
Integer value = new Integer ( NUMBER_CONSTANT ) ;
map . put ( STRING_CONSTANT , new Integer ( NUMBER_CONSTANT ) ) ;
map . put ( STRING_CONSTANT , new Integer ( NUMBER_CONSTANT ) ) ;
coll . add ( new Integer ( NUMBER_CONSTANT ) ) ;
coll . add ( new Integer ( NUMBER_CONSTANT ) ) ;
assertEquals ( false , sb1 . equals ( new Integer ( NUMBER_CONSTANT ) ) ) ;
mutNum . subtract ( new Integer ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Integer ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == new Integer ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , numA . equals ( new Integer ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableInt ( new Integer ( NUMBER_CONSTANT ) ) . intValue () ) ;
assertEquals ( false , f1 . equals ( new Integer ( NUMBER_CONSTANT ) ) ) ;
Integer i = new Integer ( NUMBER_CONSTANT ) ;
Integer i = new Integer ( NUMBER_CONSTANT ) ;
DurationFormatUtils.Token numToken = new DurationFormatUtils.Token ( new Integer ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
mutNum . subtract ( new Integer ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Integer ( NUMBER_CONSTANT ) ) ;
map . put ( STRING_CONSTANT , new Integer ( NUMBER_CONSTANT ) ) ;
public Integer getValue () { return new Integer ( this . value ) ; }
mutNum . subtract ( new Long ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Long ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == new Long ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( new Long ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableLong ( new Long ( NUMBER_CONSTANT ) ) . longValue () ) ;
public Long getValue () { return new Long ( this . value ) ; }
public Short getValue () { return new Short ( this . value ) ; }
mutNum . subtract ( new Short ( ( short ) NUMBER_CONSTANT ) ) ;
mutNum . add ( new Short ( ( short ) NUMBER_CONSTANT ) ) ;
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , new Double ( value ) ) ) ; } }
public Float getValue () { return new Float ( this . value ) ; }
public Double getValue () { return new Double ( this . value ) ; }
try { FieldUtils . writeField ( field , publicChild , new Double ( Double.MAX_VALUE ) ) ; } catch ( IllegalAccessException e ) {}
Object [] args = new Object [] { new Double ( STRING_CONSTANT ) } ;
args = new Object [] { STRING_CONSTANT , cal . getTime () , new Double ( STRING_CONSTANT ) }
mutNum . subtract ( new Float ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Float ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == new Float ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( new Float ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableFloat ( new Float ( NUMBER_CONSTANT ) ) . floatValue () , NUMBER_CONSTANT ) ;
mutNum . subtract ( new Double ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Double ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == new Double ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( new Double ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableDouble ( new Double ( NUMBER_CONSTANT ) ) . doubleValue () , NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , new MutableObject < Double > ( new Double ( NUMBER_CONSTANT ) ) . toString () ) ;
{ throw new UnsupportedOperationException ( STRING_CONSTANT , new UnsupportedOperationException ( java6Exception ) ) ; }
assertEquals ( null , StringUtils . splitPreserveAllTokens ( null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . splitPreserveAllTokens ( null ) ) ;
assertEquals ( null , StringUtils . splitByWholeSeparatorPreserveAllTokens ( null , STRING_CONSTANT , - NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . splitByWholeSeparator ( null , STRING_CONSTANT , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . splitByWholeSeparator ( null , STRING_CONSTANT ) ) ;
assertEquals ( null , StringUtils . split ( null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . split ( null ) ) ;
public synchronized void delete () { listField . removeFirstOccurrence ( Integer . valueOf ( random . nextInt ( N ) ) ) ; }
separator = ( separator == null ? STRING_CONSTANT : separator ) ;
separator = ( separator == null ? STRING_CONSTANT : separator ) ;
separator = ( separator == null ? STRING_CONSTANT : separator ) ;
separator = separator == null ? STRING_CONSTANT : separator ;
separator = separator == null ? STRING_CONSTANT : separator ;
separator = separator == null ? STRING_CONSTANT : separator ;
{ long bits = Double . doubleToLongBits ( value ) ; return ( int ) ( bits ^ ( bits > > > NUMBER_CONSTANT ) ) ; }
for ( E constant : values ) { total |= ( NUMBER_CONSTANT < < constant . ordinal () ) ; }
int remainder = ( len - pos ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
return super . equals ( o ) && ( b == rhs.b ) ;
return ( a == rhs.a ) ;
root = ( root == null ? th : root ) ;
return super . equals ( o ) && ( b == rhs.b ) ;
return ( a == rhs.a ) ;
dev = ( observed [ i ] - expected [ i ] ) ;
( pos + i ) >= len || chars [ pos + i ] != chars [ quoteStart + i ]
{ return ( options == null ) ? false : options . contains ( option ) ; }
return ( result != null ) ? result : value ;
{ return ( initializer != null ) ? initializer . get () : null ; }
{ return ( schedFuture != null ) ? schedFuture : super . startTimer () ; }
int d2 = ( tmodd1 == NUMBER_CONSTANT ) ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ;
long m = ( ( long ) x ) * ( ( long ) y ) ;
long m = ( ( long ) x ) * ( ( long ) y ) ;
( power % NUMBER_CONSTANT ) == NUMBER_CONSTANT
{ return ( ( double ) numerator ) / ( ( double ) denominator ) ; }
{ return ( ( float ) numerator ) / ( ( float ) denominator ) ; }
{ return ( obj == null ) ? NUMBER_CONSTANT : obj . hashCode () ; }
if ( ( object1 == null ) || ( object2 == null ) ) { return false ; }
assertEquals ( bf_zero . setShortValue ( ( short ) NUMBER_CONSTANT , ( short ) j ) , ( short ) ( NUMBER_CONSTANT ) ) ;
if ( str == null || prefix == null ) { return ( str == null && prefix == null ) ; }
if ( allStringsNull || ( longestStrLen == NUMBER_CONSTANT && ! anyStringNull ) ) { return INDEX_NOT_FOUND ; }
if ( length >= str . length () || length < ( middle . length () + NUMBER_CONSTANT ) ) { return str ; }
int noOfItems = ( endIndex - startIndex ) ;
int noOfItems = ( endIndex - startIndex ) ;
if ( match || ( preserveAllTokens && lastMatch ) ) { list . add ( str . substring ( start , i ) ) ; }
if ( match || ( preserveAllTokens && lastMatch ) ) { list . add ( str . substring ( start , i ) ) ; }
if ( ( separator == null ) || ( EMPTY . equals ( separator ) ) ) { return splitWorker ( str , null , max , preserveAllTokens ) ; }
pos < ( strLen - closeLen )
if ( pos == INDEX_NOT_FOUND || pos == ( str . length () - separator . length () ) ) { return EMPTY ; }
if ( str . length () <= ( pos + len ) ) { return str . substring ( pos ) ; }
return ( ret == Integer.MAX_VALUE ) ? INDEX_NOT_FOUND : ret ;
startPos > ( str . length () - searchStr . length () )
int endLimit = ( str . length () - searchStr . length () ) + NUMBER_CONSTANT ;
int delimLen = ( delimiters == null ? - NUMBER_CONSTANT : delimiters.length ) ;
int delimLen = ( delimiters == null ? - NUMBER_CONSTANT : delimiters.length ) ;
( inputLineLength - offset ) > wrapLength
return super . equals ( o ) && ( b == rhs.b ) ;
return ( a == rhs.a ) ;
if ( cls == null ) { return ! ( toClass . isPrimitive () ) ; }
{ boolean b = ( ch >= CHAR_CONS && ch <= CHAR_CONS ) ; t += b ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
if ( coll == null || coll . size () == NUMBER_CONSTANT ) { return false ; }
assertTrue ( triple . getRight () ) ;
assertFalse ( triple . getRight () ) ;
assertEquals ( STRING_CONSTANT , flag , t . isDaemon () ) ;
triple2 = Triple . of ( null , STRING_CONSTANT , NUMBER_CONSTANT )
Object [] original = new Object [] { true , false } ;
fdf = getInstance ( STRING_CONSTANT ) ;
@ Override public Locale getLocale () { return mLocale ; }
@ Override public TimeZone getTimeZone () { return mTimeZone ; }
@ Override public String getPattern () { return mPattern ; }
@ Override public Locale getLocale () { return locale ; }
@ Override public TimeZone getTimeZone () { return timeZone ; }
@ Override public String getPattern () { return pattern ; }
DateFormatSymbols symbols = DateFormatSymbols . getInstance ( locale ) ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
if ( str . length () == NUMBER_CONSTANT || deepEmpty ( set ) ) { return STRING_CONSTANT ; }
if ( cls != null ) return cls ; else throw cnfe ;
public Locale getLocale () { return locale ; }
public TimeZone getTimeZone () { return timeZone ; }
public String getPattern () { return pattern ; }
public Locale getLocale () { return mLocale ; }
public TimeZone getTimeZone () { return mTimeZone ; }
public String getPattern () { return mPattern ; }
new Runnable () { public void run () { endOfPeriod () ; } }
public Object getValue () { return null ; }
public Locale getLocale ( ) ;
public Locale getLocale ( ) ;
@ Override
@ Override public void setUp ( ) throws Exception { exceptionContext = new DefaultExceptionContext () ; super . setUp () ; }
assertEquals ( true , rangea . isNegated () ) ;
assertEquals ( true , rangea . isNegated () ) ;
assertEquals ( true , rangea . isNegated () ) ;
assertEquals ( false , rangea . isNegated () ) ;
assertEquals ( false , rangea . isNegated () ) ;
assertEquals ( false , rangea . isNegated () ) ;
assertEquals ( true , rangea . isNegated () ) ;
assertEquals ( false , rangea . isNegated () ) ;
assertEquals ( false , new BitField ( NUMBER_CONSTANT ) . isSet ( clearedBit ) ) ;
assertEquals ( true , hc2a != NUMBER_CONSTANT ) ;
assertEquals ( true , sb.buffer.length >= NUMBER_CONSTANT ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
@ Override public int hashCode () { return b * NUMBER_CONSTANT + t ; }
{ return parseDateWithLeniency ( str , parsePatterns , false ) ; }
{ return parseDateWithLeniency ( str , parsePatterns , true ) ; }
DateParser parser = getInstance ( STRING_CONSTANT , TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
{ return getInstance ( FormatCache . getPatternForStyle ( dateStyle , null , locale ) , TimeZone . getDefault () , Locale . getDefault () ) ; }
DateFormatSymbols symbols = new DateFormatSymbols ( locale ) ;
if ( eraBC && format . equals ( SHORT_FORMAT ) && locale . toString () . equals ( STRING_CONSTANT ) ) { continue; }
if ( year < NUMBER_CONSTANT && locale . toString () . equals ( STRING_CONSTANT ) ) { continue; }
assertEquals ( locale . toString () + STRING_CONSTANT + formattedDate , expectedTime , actualTime ) ;
Strategy strategy = cache . get ( field ) ;
{ return getInstance ( FormatCache . getPatternForStyle ( dateStyle , null , locale ) , TimeZone . getDefault () , Locale . getDefault () ) ; }
return ++ initializeCalls ;
return REPEAT ;
return initializeCalls ;
this . value instanceof StringBuffer
StringBuffer buffer = new StringBuffer () ;
StringBuffer expected = new StringBuffer () ;
StringBuffer buffer = new StringBuffer () ;
StringBuffer buffer = new StringBuffer () ;
StringBuffer result = new StringBuffer () ;
StringBuffer sb = new StringBuffer ( dstInit ) ;
StringBuffer sb = new StringBuffer ( dstInit ) ;
StringBuffer sb = new StringBuffer ( dstInit ) ;
StringBuffer sb = new StringBuffer ( dstInit ) ;
throw new java.lang.IllegalArgumentException ( STRING_CONSTANT + nibble ) ;
throw new java.lang.IllegalArgumentException ( STRING_CONSTANT + nibble ) ;
HashMap < Boolean , MutableInt > occurrences = new HashMap < Boolean , MutableInt > ( values.length ) ;
{ System.out . println ( STRING_CONSTANT ) ; }
{ System.out . println ( STRING_CONSTANT ) ; }
{ output = ( int [] ) removeAll ( array , toRemove ) ; }
return ( boolean [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( double [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( float [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( long [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( char [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( int [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( short [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( byte [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
result = ( T [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) )
{ return format ( new Date ( millis ) ) ; }
Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ;
{ if ( str == null ) { return null ; } return WHITESPACE_BLOCK . matcher ( trim ( str ) ) . replaceAll ( STRING_CONSTANT ) ; }
{ if ( str == null ) { return null ; } return WHITESPACE_PATTERN . matcher ( trim ( str ) ) . replaceAll ( STRING_CONSTANT ) ; }
if ( isEmpty ( padStr ) ) { padStr = STRING_CONSTANT ; }
if ( isEmpty ( padStr ) ) { padStr = STRING_CONSTANT ; }
if ( isEmpty ( padStr ) ) { padStr = STRING_CONSTANT ; }
{ out . write ( STRING_CONSTANT + hex ( codepoint ) ) ; }
MutableDouble other
Object obj
Number operand
double operand
Number operand
double operand
Number value
double value
String value
Number value
double value
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
T [] array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
Object [] array
boolean [] array
Boolean [] array
float [] array
Float [] array
double [] array
Double [] array
byte [] array
Byte [] array
short [] array
Short [] array
int [] array
Integer [] array
long [] array
Long [] array
char [] array
Character [] array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
Object [] array
Object array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
T [] array
Boolean [] array
Float [] array
Double [] array
Byte [] array
Character [] array
Short [] array
Integer [] array
Long [] array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
String [] array
Object [] array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
T [] array
Object [] array
Object array
Object array
MutableByte other
Object obj
Number operand
byte operand
Number operand
byte operand
Number value
byte value
String value
Number value
byte value
Object obj
@ Override public char charAt ( int index ) { return seq . charAt ( index ) ; }
public CustomCharSequence ( CharSequence seq ) { this . seq = seq ; }
int codepoint
CharSequenceTranslator . . . translators
CharSequence input
@ Override public char charAt ( int arg0 ) { return value . charAt ( arg0 ) ; }
String value
MutableInt other
Object obj
Number operand
int operand
Number operand
int operand
Number value
int value
String value
Number value
int value
String msg
DateParser getInstance ( String format ) { return getInstance ( format , TimeZone . getDefault () , Locale . getDefault () ) ; }
boolean flag
BasicThreadFactory factory
Callable < T > call
Callable < T > call
DatePrinter getInstance ( String format ) { return getInstance ( format , TimeZone . getDefault () , Locale . getDefault () ) ; }
Formattable formattable
Collection < > coll
String language
char [] str
StrBuilder str
StringBuilder str
StringBuffer str
String str
String str
Throwable cause
String msg
Boolean . . . array
boolean . . . array
Boolean . . . array
boolean . . . array
Boolean . . . array
boolean . . . array
boolean bool
boolean bool
boolean bool
Boolean bool
Boolean bool
Boolean bool
String str
String str
Boolean bool
boolean bool
boolean bool
Integer value
int value
int value
Boolean bool
Boolean bool
Boolean bool
Boolean bool
Boolean bool
Boolean bool
Object obj2
Object value
String format
long durationMillis
long durationMillis
boolean expression
T iterable
T [] array
T chars
T chars
T map
T collection
T [] array
T object
boolean expression
int nibble
int nibble
boolean [] src
boolean [] src
boolean [] src
char hexDigit
char hexDigit
char hexDigit
char hexDigit
ObjectStreamClass desc
byte [] objectData
InputStream inputStream
Serializable obj
T object
char ch
char ch
char ch
char ch
char ch
char ch
char ch
char ch
Character ch
char ch
Character ch
char ch
Character ch
char ch
String str
Character ch
String str
char ch
Class < > clazz
String . . . excludeFieldNamesParam
boolean appendTransients
boolean appendStatics
Object array
Field field
Class < > clazz
Field field
Object object
Object [] array
Collection < String > collection
Object object
R right
M middle
L left
Throwable cause
@ Override public boolean cancel ( boolean mayInterruptIfRunning ) { return false ; }
T value
T value
ConcurrentInitializer < T > initializer
ConcurrentInitializer < T > initializer
ExecutionException ex
Throwable ex
ExecutionException ex
ExecutionException ex
ExecutionException ex
ExecutionException ex
OPTION option
OPTION . . . options
JavaVersion requiredVersion
String property
String osNamePrefix
String versionPrefix
CollectionHolder ( T collection ) { this . collection = collection ; }
String replaceTemplate
public void testTwo ( ChildInterface obj ) {}
public void testTwo ( GrandParentObject obj ) {}
public void testTwo ( Object obj ) {}
public void testOne ( ParentObject obj ) {}
public void testOne ( GrandParentObject obj ) {}
public void testOne ( Object obj ) {}
Class < > c
Class < > [] c
@ Override public void setValue ( Object value ) {}
public void oneParameter ( String s ) {}
public String foo ( Object o ) { return STRING_CONSTANT ; }
public String foo ( String s ) { return STRING_CONSTANT ; }
public String foo ( double d ) { return STRING_CONSTANT ; }
public String foo ( Integer i ) { return STRING_CONSTANT ; }
public String foo ( int i ) { return STRING_CONSTANT ; }
public static String bar ( Object o ) { return STRING_CONSTANT ; }
public static String bar ( String s ) { return STRING_CONSTANT ; }
public static String bar ( Integer i ) { return STRING_CONSTANT ; }
String canonicalName
Class < > cls
String canonicalName
Class < > cls
Object . . . array
String className
Class < > cls
Class < > . . . classes
Class < > cls
Class < > . . . classes
Class < > cls
Class < > type
Class < > type
boolean autoboxing
List < Class < > > classes
List < String > classNames
HashSet < Class < > > interfacesFound
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
int superHashCode
short [] array
short value
Object [] array
Object object
long [] array
long value
int [] array
int value
float [] array
float value
double [] array
double value
char [] array
char value
byte [] array
byte value
boolean [] array
boolean value
Object value
Object value
Object value
String summaryObjectEndText
String summaryObjectStartText
String sizeEndText
String sizeStartText
String nullText
boolean fieldSeparatorAtEnd
boolean fieldSeparatorAtStart
String fieldSeparator
String fieldNameValueSeparator
String contentEnd
String contentStart
String arraySeparator
String arrayEnd
String arrayStart
boolean arrayContentDetail
boolean defaultFullDetail
boolean useFieldNames
boolean useIdentityHashCode
boolean useShortClassName
boolean useClassName
String format
Object obj
Pair < L , R > other
void warn ( String msg ) { System.err . println ( msg ) ; }
BitSet coll
HashSet < Integer > coll
int count
int count
int count
int count
int count
@ Override public boolean equals ( Object obj ) { return EqualsBuilder . reflectionEquals ( this , obj ) ; }
public void setObjectReference ( TestObjectReference reference ) { this . reference = reference ; }
public TestObjectReference ( int one ) { this . one = new TestObject ( one ) ; }
Object o
public TestBCanEqualA ( int b ) { this . b = b ; }
Object o
public TestACanEqualB ( int a ) { this . a = a ; }
boolean testTransients
public void setT ( int t ) { this . t = t ; }
public void setB ( int b ) { this . b = b ; }
Object o
public void setA ( int a ) { this . a = a ; }
Object o
public TestObject ( int a ) { this . a = a ; }
String name
boolean enableSubstitutionInVariables
StrLookup < > variableResolver
String suffix
char suffix
StrMatcher suffixMatcher
String prefix
char prefix
StrMatcher prefixMatcher
char escapeCharacter
StrBuilder source
StringBuffer source
Object source
StrBuilder source
StringBuffer source
char [] source
String source
StrLookup < > variableResolver
Map < String , V > valueMap
Object source
boolean isEquals
boolean superEquals
String toString
String superToString
Object object
short [] array
short value
Object [] array
Object obj
long [] array
long value
int [] array
int value
float [] array
float value
double [] array
double value
char [] array
char value
byte [] array
byte value
boolean [] array
boolean value
Object object
Object object
Object object
ToStringStyle style
MutableFloat other
Object obj
Number operand
float operand
Number operand
float operand
Number value
float value
String value
Number value
float value
int limit
JavaVersion requiredVersion
Object obj
char ch
String str
String . . . set
String . . . setStrs
Object obj
@ Override public Date parse ( String source ) throws ParseException { return parser . parse ( source ) ; }
Calendar calendar
Date date
long millis
int style
int style
String pattern
String str
char [] cbuf
int c
@ Override public void mark ( int readAheadLimit ) { mark = pos ; }
int index
int startIndex
Object obj
StrBuilder other
StrBuilder other
StrMatcher matcher
StrMatcher matcher
String str
String str
char ch
char ch
StrMatcher matcher
StrMatcher matcher
String str
String str
char ch
char ch
StrMatcher matcher
String str
char ch
int length
int length
int length
int startIndex
int start
String str
String str
StrMatcher matcher
StrMatcher matcher
String str
String str
char ch
char ch
int startIndex
boolean value
int index
char separator
String separator
Iterator < > it
Iterable < > iterable
Object [] array
Iterator < > it
Iterable < > iterable
T . . . array
double value
float value
long value
int value
char ch
boolean value
char [] chars
StrBuilder str
StringBuilder str
StringBuffer str
String str
Object obj
double value
float value
long value
int value
char ch
boolean value
char [] chars
StrBuilder str
StringBuilder str
StringBuffer str
String str
CharSequence seq
Object obj
int startIndex
int index
int index
int capacity
int length
String newLine
String str
private void readObject ( ObjectInputStream in ) throws ClassNotFoundException { throw new ClassNotFoundException ( SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE ) ; }
{ @ Override public void write ( int arg0 ) throws IOException { throw new IOException ( SERIALIZE_IO_EXCEPTION_MESSAGE ) ; } }
String baseMessage
String label
String label
Throwable cause
String message
MutableShort other
Object obj
Number operand
short operand
Number operand
short operand
Number value
short value
String value
Number value
short value
String str
String str
Object array
float [] array
double [] array
byte [] array
short [] array
int [] array
long [] array
float [] array
double [] array
byte [] array
short [] array
int [] array
long [] array
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
Field field
String languageCode
String countryCode
Locale locale
Locale locale
String baseMessage
String label
String label
Throwable cause
String message
ObjectInputStream objectInputStream
ObjectOutputStream objectOutputStream
L listener
L listener
Class < L > listenerInterface
Class < T > listenerInterface
protected String toUtf16Escape ( int codepoint ) { return STRING_CONSTANT + hex ( codepoint ) ; }
int codepoint
int codepoint
public NestableException ( Throwable t ) { super ( t ) ; }
public void setCause ( Throwable cause ) { this . cause = cause ; }
public ExceptionWithCause ( Throwable cause ) { super(); setCause ( cause ) ; }
String [] eventTypes
void warn ( String msg ) { System.err . println ( msg ) ; }
private void assertSupportedEncoding ( String name ) { assertTrue ( STRING_CONSTANT + name , CharEncoding . isSupported ( name ) ) ; }
public AClass ( AAClass < String > enclosingInstance ) { enclosingInstance . super ( ) ; }
public InspectingClient ( TestFixture testFixture ) { this . testFixture = testFixture ; }
public MutatingClient ( TestFixture testFixture ) { this . testFixture = testFixture ; }
String [] strings
MutableBoolean other
Object obj
Boolean value
boolean value
Boolean value
boolean value
CharRange r
Object obj
CharRange range
char ch
char ch
char ch
boolean negated
Throwable th
Throwable th
Throwable t
String stackTrace
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
int codepoint
int codepoint
int codepoint
StrTokenizer tokenizer
StrTokenizer tokenizer
String data
StrTokenizer tokenizer
int loopCount
int loopCount
int loopCount
public static void main ( String [] args ) { new CharUtilsPerfRun () . run () ; }
MutableLong other
Object obj
Number operand
long operand
Number operand
long operand
Number value
long value
String value
Number value
long value
Object obj
T obj
Object other
Object _value
T . . . items
T . . . items
T . . . values
T . . . values
Object obj
Object object
Object . . . objects
Object obj
T . . . values
@ Override int modify ( int iValue ) { return iValue % NUMBER_CONSTANT ; }
@ Override int modify ( int iValue ) { return iValue % NUMBER_CONSTANT ; }
@ Override int modify ( int iValue ) { return iValue - NUMBER_CONSTANT ; }
Locale locale
int modify ( int iValue ) { return iValue ; }
NumberStrategy ( int field ) { this . field = field ; }
CopyQuotedStrategy ( String formatField ) { this . formatField = formatField ; }
int field
Calendar definingCalendar
int twoDigitYear
String source
@ Override public Object parseObject ( String source ) throws ParseException { return parse ( source ) ; }
ObjectInputStream in
Object obj
byte holder
short holder
int holder
byte holder
short holder
int holder
int holder
int holder
short holder
int holder
short holder
int holder
int mask
Annotation a
java.lang.Class < > cls
String formattedDate
String input
boolean ignoreEmptyTokens
boolean emptyAsNull
StrMatcher trimmer
char ignored
StrMatcher ignored
char quote
StrMatcher quote
String delim
char delim
StrMatcher delim
List < String > list
String obj
String obj
char [] input
String input
char [] input
String input
char [] input
String input
char [] input
String input
int codepoint
int codepoint
CollectionHolder ( T collection ) { this . collection = collection ; }
Object obj
T value
T value
CharSequence [] . . . lookup
R value
int unit
Date date
Object o
public void setA ( int a ) { this . a = a ; }
Object o
public TestObject ( int a ) { this . a = a ; }
R value
R right
L left
String toString
String toString
String toString
Type type
Type type
ParameterizedType parameterizedType
WildcardType wildcardType
WildcardType wildcardType
TypeVariable < > typeVariable
Type [] bounds
ParameterizedType type
c = new Comparable () { @ Override public int compareTo ( Object other ) { return NUMBER_CONSTANT ; } }
Constructor < T > ctor
Class < T > cls
Class < T > cls
Class < T > cls
Class < T > cls
String str
String str
String str
char . . . delimiters
String str
String str
CharSequenceTranslator . . . translators
String [] [] array
boolean testTransients
boolean testTransients
Class < E > enumClass
Class < E > enumClass
Class < E > enumClass
Class < E > enumClass
Class < E > enumClass
CharSequence cs
String val
String str
String str
String str
String str
String str
String str
float [] array
double [] array
float [] array
double [] array
String str
CharMatcher ( char ch ) { super(); this . ch = ch ; }
char chars []
String str
String chars
char . . . chars
char ch
String name
String name
String name
String name
String name
ExecutorService exec
String format
Object obj
Range < T > other
Range < T > otherRange
Range < T > otherRange
Range < T > otherRange
Range < T > otherRange
T element
T element
T element
T element
T element
T element
T element
String str
int threshold
String . . . strs
CharSequence . . . css
String str
String str
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
String str
String str
String str
String str
String str
int size
CharSequence cs
String str
String str
String str
String str
T . . . elements
String str
String str
String str
String str
String str
String str
CharSequence seq
String input
String . . . strs
String stripChars
String str
String str
String str
String str
String str
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
String format
Object obj
ExecutorService exec
ExecutorService execDestroy
ExecutorService externalExecutor
ExecutorService exec
Throwable cause
Class < > c
Class < > [] c
public TestBean ( Object o ) { toString = STRING_CONSTANT ; }
public TestBean ( String s ) { toString = STRING_CONSTANT ; }
public TestBean ( double d ) { toString = STRING_CONSTANT ; }
public TestBean ( Integer i ) { toString = STRING_CONSTANT ; }
public TestBean ( int i ) { toString = STRING_CONSTANT ; }
public SimpleReflectionTestFixture ( Object o ) { this . o = o ; }
Object o
Collection < > coll
ParsePosition pos
String desc
Object obj
String pattern
String pattern
Object obj
Object . . . keys
String pattern
int count
int count
int count
int count
int count
int superCompareTo
Fraction other
Object obj
Fraction fraction
Fraction fraction
Fraction fraction
Fraction fraction
int power
public BackgroundInitializerTestImpl ( ExecutorService exec ) { super ( exec ) ; }
BackgroundInitializerTestImpl init
boolean fieldSeparatorAtEnd
boolean fieldSeparatorAtStart
boolean arrayContentDetail
boolean defaultFullDetail
boolean useFieldNames
boolean useIdentityHashCode
boolean useShortClassName
boolean useClassName
Class < > cls
Boolean fullDetailRequest
StringBuffer buffer
StringBuffer buffer
StringBuffer buffer
StringBuffer buffer
Object value
Object value
Object value
Object o
TestObject rhs
public void setA ( int a ) { this . a = a ; }
Object o
public TestObject ( int a ) { this . a = a ; }
private void assertGetClassThrowsClassNotFound ( String className ) throws Exception { assertGetClassThrowsException ( className , ClassNotFoundException . class ) ; }
private void assertGetClassThrowsNullPointerException ( String className ) throws Exception { assertGetClassThrowsException ( className , NullPointerException . class ) ; }
Class < > c
public void removePropertyChangeListener ( PropertyChangeListener listener ) { listeners . removeListener ( listener ) ; }
public void addPropertyChangeListener ( PropertyChangeListener listener ) { listeners . addListener ( listener ) ; }
protected void addVetoableChangeListener ( VetoableChangeListener listener ) {}
String property
public void addPropertyChangeListener ( PropertyChangeListener listener ) { throw new RuntimeException () ; }
public void addMultipleEventListener ( MultipleEventListener listener ) { listeners . addListener ( listener ) ; }
String eventName
Class < L > listenerType
public void eventOccurred ( PropertyChangeEvent e ) { count ++ ; }
new PropertyChangeListener () { @ Override public void propertyChange ( PropertyChangeEvent e ) {} }
Object obj
boolean colon
NumberRule rule
NumberRule rule
TwoDigitNumberField ( int field ) { mField = field ; }
UnpaddedNumberField ( int field ) { mField = field ; }
String value
CharacterLiteral ( char value ) { mValue = value ; }
ObjectInputStream in
Object obj
Calendar calendar
Date date
Calendar c
long millis
{ @ Override public void vetoableChange ( PropertyChangeEvent e ) { calledListeners . add ( this ) ; } }
{ @ Override public void vetoableChange ( PropertyChangeEvent e ) { listenerSupport . removeListener ( this ) ; } }
listenerSupport . addListener ( new VetoableChangeListener () { @ Override public void vetoableChange ( PropertyChangeEvent e ) {} } ) ;
String key
Map < String , V > map
Map < String , V > map
String baseMessage
String label
String label
String input
String input
String input
String input
String input
String input
String input
String input
String input
String input
String input
String input
boolean [] src
Class < > destClass
Member m
int modifiers
AccessibleObject o
Thread.UncaughtExceptionHandler handler
int prio
boolean f
String pattern
ThreadFactory factory
Thread t
Runnable r
Builder builder
{ for ( String s : strings ) { if ( StringUtils . isNotEmpty ( s ) ) { return false ; } } }
long total = System . currentTimeMillis () - start ;
char c = Character . forDigit ( nibble , NUMBER_CONSTANT ) ;
{ try { return cloneReset () ; } catch ( CloneNotSupportedException ex ) { return null ; } }
{ StrTokenizer tok = getTSVClone () ; tok . reset ( input ) ; return tok ; }
{ StrTokenizer tok = getTSVClone () ; tok . reset ( input ) ; return tok ; }
{ StrTokenizer tok = getCSVClone () ; tok . reset ( input ) ; return tok ; }
{ StrTokenizer tok = getCSVClone () ; tok . reset ( input ) ; return tok ; }
IDKey idKey = ( IDKey ) other ;
catch ( InterruptedException iex ) { Thread . currentThread () . interrupt () ; }
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
Boolean b = array [ i ] ;
Float b = array [ i ] ;
Double b = array [ i ] ;
Byte b = array [ i ] ;
Short b = array [ i ] ;
Integer b = array [ i ] ;
Long b = array [ i ] ;
Character b = array [ i ] ;
for ( CharSequence searchString : searchStrings ) { if ( StringUtils . endsWith ( string , searchString ) ) { return true ; } }
for ( CharSequence searchString : searchStrings ) { if ( StringUtils . startsWith ( string , searchString ) ) { return true ; } }
CharSequence tmp = s ;
int smallestIndexOfDiff = indexOfDifference ( strs ) ;
int at = indexOfDifference ( str1 , str2 ) ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int pads = size - str . length () ;
int pads = size - str . length () ;
char [] chars = str . toCharArray () ;
int pos = str . lastIndexOf ( separator ) ;
int pos = str . lastIndexOf ( separator ) ;
int pos = str . indexOf ( separator ) ;
int pos = str . indexOf ( separator ) ;
int strLen = seq . length () ;
{ String ts = trim ( str ) ; return isEmpty ( ts ) ? null : ts ; }
short anotherVal = other.value ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder ( NUMBER_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor ( THREAD_POOL_SIZE ) ;
StringBuilder canonicalClassNameBuffer = new StringBuilder ( className ) ;
int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ;
for ( Object name : coll ) { if ( name != null ) { return true ; } }
char [] buffer = pattern . toCharArray () ;
ExtendedMessageFormat rhs = ( ExtendedMessageFormat ) obj ;
String toString = AnnotationUtils . toString ( testAnno ) ;
byte anotherVal = other.value ;
{ boolean anotherVal = other.value ; return value == anotherVal ? NUMBER_CONSTANT : ( value ? NUMBER_CONSTANT : - NUMBER_CONSTANT ) ; }
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
OctalUnescaper oue = new OctalUnescaper () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
EqualsBuilder equalsBuilder = new EqualsBuilder () ;
EqualsBuilder equalsBuilder = new EqualsBuilder () ;
TestSubObject rhs = ( TestSubObject ) o ;
TestObject rhs = ( TestObject ) o ;
String str = f . toProperString () ;
String str = f . toString () ;
try { f1 . compareTo ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( NullPointerException ex ) {}
try { f = f . abs () ; fail ( STRING_CONSTANT ) ; } catch ( ArithmeticException ex ) {}
try { f = f . negate () ; fail ( STRING_CONSTANT ) ; } catch ( ArithmeticException ex ) {}
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
{ ExecutorService exec = Executors . newSingleThreadExecutor () ; new CallableBackgroundInitializer < Integer > ( null , exec ) ; }
StrTokenizer tkn = new StrTokenizer ( STRING_CONSTANT ) ;
StrTokenizer tok = new StrTokenizer ( STRING_CONSTANT ) ;
StrTokenizer tok = new StrTokenizer ( STRING_CONSTANT ) ;
StrTokenizer tok = new StrTokenizer () ;
String input = STRING_CONSTANT ;
try { tokenizer . next () ; fail () ; } catch ( NoSuchElementException ex ) {}
{ float anotherVal = other.value ; return Float . compare ( value , anotherVal ) ; }
int len = chars.length ;
{ MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . isException ( STRING_CONSTANT ) ; }
{ MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getException ( STRING_CONSTANT ) ; }
{ MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getResultObject ( STRING_CONSTANT ) ; }
{ MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getInitializer ( STRING_CONSTANT ) ; }
catch ( IllegalStateException istex ) { initializer . get () ; }
ExecutorService exec = Executors . newCachedThreadPool () ;
MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer . get () ;
Object item = array [ i ] ;
for ( char delimiter : delimiters ) { if ( ch == delimiter ) { return true ; } }
for ( BackgroundInitializer < > bi : childInitializers . values () ) { result += bi . getTaskCount () ; }
Integer i = Integer . valueOf ( NUMBER_CONSTANT ) ;
long millisPerUnit = getMillisPerUnit ( unit ) ;
Calendar calendar = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
{ Calendar c = Calendar . getInstance () ; c . setTime ( date ) ; return c ; }
Calendar c = Calendar . getInstance () ;
Calendar c = Calendar . getInstance () ;
try { result = neu . translate ( input ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException iae ) {}
NumericEntityUnescaper neu = new NumericEntityUnescaper () ;
{ DateParser parser = getInstance ( yMdHmsSZ , REYKJAVIK ) ; assertEquals ( REYKJAVIK , parser . getTimeZone () ) ; }
{ DateParser parser = getInstance ( yMdHmsSZ , SWEDEN ) ; assertEquals ( SWEDEN , parser . getLocale () ) ; }
{ DateParser parser = getInstance ( yMdHmsSZ ) ; assertEquals ( yMdHmsSZ , parser . getPattern () ) ; }
{ DateParser parser = getInstance ( YMD_SLASH ) ; assertTrue ( parser . toString () . startsWith ( STRING_CONSTANT ) ) ; }
Calendar cal = Calendar . getInstance () ;
int gmt = msg . indexOf ( STRING_CONSTANT ) ;
Object object = getObject () ;
int part1 = name . hashCode () * NUMBER_CONSTANT ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
{ BasicThreadFactory factory = new BasicThreadFactory ( this ) ; reset () ; return factory ; }
{ try { return getAccessibleConstructor ( cls . getConstructor ( parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } }
CustomCharSequence other = ( CustomCharSequence ) obj ;
{ BasicThreadFactory factory = builder . build () ; checkFactoryDefaults ( factory ) ; }
StrLookup < > resolver = getVariableResolver () ;
StrBuilder buf = new StrBuilder ( NUMBER_CONSTANT ) ;
StrBuilder buf = new StrBuilder ( source ) ;
int sz = cs . length () ;
int sz = cs . length () ;
T value
T value
StringBuffer buffer = new StringBuffer () ;
{ for ( Object object : objects ) { hash = hash * NUMBER_CONSTANT + ObjectUtils . hashCode ( object ) ; } }
if ( values != null ) { for ( T val : values ) { if ( val != null ) { return val ; } } }
StrBuilder buf = new StrBuilder () ;
StrSubstitutor sub = new StrSubstitutor () ;
{ StrSubstitutor sub = new StrSubstitutor () ; assertEquals ( STRING_CONSTANT , sub . replace ( STRING_CONSTANT ) ) ; }
StrSubstitutor sub = new StrSubstitutor ( values ) ;
StrSubstitutor sub = new StrSubstitutor ( values ) ;
StrSubstitutor sub = new StrSubstitutor ( values ) ;
{ StrSubstitutor sub = new StrSubstitutor () ; assertEquals ( STRING_CONSTANT , sub . replace ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
StrSubstitutor sub = new StrSubstitutor ( values ) ;
StrSubstitutor sub = new StrSubstitutor ( values ) ;
StrSubstitutor sub = new StrSubstitutor ( values ) ;
FastDateFormat other = ( FastDateFormat ) obj ;
Object obj = map . get ( key ) ;
catch ( NoSuchMethodException e ) {}
String src = STRING_CONSTANT ;
String src = STRING_CONSTANT ;
String src = STRING_CONSTANT ;
String src = STRING_CONSTANT ;
{ for ( short element : array ) { append ( element ) ; } }
{ for ( Object element : array ) { append ( element ) ; } }
{ for ( long element : array ) { append ( element ) ; } }
{ for ( int element : array ) { append ( element ) ; } }
{ for ( float element : array ) { append ( element ) ; } }
{ for ( double element : array ) { append ( element ) ; } }
{ for ( char element : array ) { append ( element ) ; } }
{ for ( byte element : array ) { append ( element ) ; } }
{ for ( boolean element : array ) { append ( element ) ; } }
Object key
CompareToBuilder compareToBuilder = new CompareToBuilder () ;
Type rawType = parameterizedType . getRawType () ;
Type replacementType = typeVarAssigns . get ( type ) ;
Type bound
catch ( Exception e ) { assertTrue ( exceptionType . isAssignableFrom ( e . getClass () ) ) ; }
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
{ R result = getRight () ; setRight ( value ) ; return result ; }
int properNumerator = getProperNumerator () ;
Fraction other = ( Fraction ) obj ;
Fraction f = this . multiplyBy ( this ) ;
int gcd = greatestCommonDivisor ( numerator , denominator ) ;
E value
E constant
try { return Enum . valueOf ( enumClass , enumName ) ; } catch ( IllegalArgumentException ex ) { return null ; }
try { Enum . valueOf ( enumClass , enumName ) ; return true ; } catch ( IllegalArgumentException ex ) { return false ; }
TimeZoneDisplayKey other = ( TimeZoneDisplayKey ) obj ;
TimeZone zone = calendar . getTimeZone () ;
{ int len = mValues [ i ] . length () ; if ( len > max ) { max = len ; } }
FastDatePrinter other = ( FastDatePrinter ) obj ;
{ for ( Rule rule : mRules ) { rule . appendTo ( buf , calendar ) ; } return buf ; }
{ Calendar c = newCalendar () ; c . setTime ( date ) ; return applyRules ( c , buf ) ; }
{ Calendar c = newCalendar () ; c . setTime ( date ) ; return applyRulesToString ( c ) ; }
{ Calendar c = newCalendar () ; c . setTimeInMillis ( millis ) ; return applyRulesToString ( c ) ; }
StrMatcher matcher = StrMatcher . stringMatcher ( STRING_CONSTANT ) ;
StrMatcher matcher = StrMatcher . stringMatcher ( STRING_CONSTANT ) ;
StrMatcher matcher = StrMatcher . charSetMatcher ( STRING_CONSTANT ) ;
StrMatcher matcher = StrMatcher . charMatcher ( CHAR_CONS ) ;
StrMatcher matcher = StrMatcher . noneMatcher () ;
StrMatcher matcher = StrMatcher . quoteMatcher () ;
StrMatcher matcher = StrMatcher . doubleQuoteMatcher () ;
StrMatcher matcher = StrMatcher . singleQuoteMatcher () ;
StrMatcher matcher = StrMatcher . trimMatcher () ;
StrMatcher matcher = StrMatcher . splitMatcher () ;
StrMatcher matcher = StrMatcher . spaceMatcher () ;
StrMatcher matcher = StrMatcher . tabMatcher () ;
StrMatcher matcher = StrMatcher . commaMatcher () ;
String oldValue = this . property ;
{ Integer count = eventCounts . get ( eventName ) ; return count == null ? NUMBER_CONSTANT : count . intValue () ; }
catch ( RuntimeException e ) {}
char pad = CHAR_CONS ;
Token tok2 = ( Token ) obj2 ;
int sz = tokens.length ;
String str = super . getContent () ;
char buf [] = buffer ;
int strLen = str . length () ;
char [] thisBuf = buffer ;
char [] thisBuf = buffer ;
int len = str . length () ;
int len = str . length () ;
char [] buf = buffer ;
int newSize = size - removeLen + insertLen ;
int len = endIndex - startIndex ;
int len = chars.length ;
{ if ( iterable != null ) { for ( Object o : iterable ) { append ( o ) ; } } return this ; }
{ for ( Object element : array ) { append ( element ) ; } }
int len = length () ;
int len = length () ;
int len = length () ;
int len = length () ;
int len = length () ;
int len = length () ;
int len = length () ;
char [] old = buffer ;
char [] old = buffer ;
for ( String textKeyValue : keyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
FastDateParser other = ( FastDateParser ) obj ;
long testResult = DateUtils . getFragmentInHours ( aCalendar , Calendar.YEAR ) ;
long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.YEAR ) ;
long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.YEAR ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.YEAR ) ;
long testResult = DateUtils . getFragmentInHours ( aCalendar , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInHours ( aDate , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInMinutes ( aDate , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.MONTH ) ;
long expectedValue = hours ;
long expectedValue = hours ;
{ long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.HOUR_OF_DAY ) ; assertEquals ( minutes , testResult ) ; }
{ long testResult = DateUtils . getFragmentInMinutes ( aDate , Calendar.HOUR_OF_DAY ) ; assertEquals ( minutes , testResult ) ; }
long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.HOUR_OF_DAY ) ;
long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.HOUR_OF_DAY ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.HOUR_OF_DAY ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.HOUR_OF_DAY ) ;
long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.MINUTE ) ;
{ long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.MINUTE ) ; assertEquals ( seconds , testResult ) ; }
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.MINUTE ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.MINUTE ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.SECOND ) ;
{ long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.SECOND ) ; assertEquals ( millis , testResult ) ; }
CharRange rangea = CharRange . isNot ( CHAR_CONS ) ;
CharRange rangea = CharRange . is ( CHAR_CONS ) ;
boolean element
for ( boolean element : array ) { if ( element ) { return true ; } }
for ( boolean element : array ) { if ( ! element ) { return false ; } }
try { intRange . elementCompareTo ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
{ String str = intRange . toString ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , str ) ; }
String str = intRange . toString () ;
{ DatePrinter printer = getInstance ( YYYY_MM_DD , NEW_YORK ) ; assertEquals ( NEW_YORK , printer . getTimeZone () ) ; }
{ DatePrinter printer = getInstance ( YYYY_MM_DD , SWEDEN ) ; assertEquals ( SWEDEN , printer . getLocale () ) ; }
{ DatePrinter printer = getInstance ( YYYY_MM_DD ) ; assertEquals ( YYYY_MM_DD , printer . getPattern () ) ; }
{ DatePrinter printer = getInstance ( YYYY_MM_DD ) ; assertTrue ( printer . toString () . startsWith ( STRING_CONSTANT ) ) ; }
try { NumberUtils . createNumber ( STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( NumberFormatException nfe ) {}
String osName = System . getProperty ( STRING_CONSTANT ) ;
String javaVersion = System . getProperty ( STRING_CONSTANT ) ;
File dir = SystemUtils . getUserHome () ;
File dir = SystemUtils . getUserDir () ;
File dir = SystemUtils . getJavaIoTmpDir () ;
File dir = SystemUtils . getJavaHome () ;
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
{ BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; assertFalse ( STRING_CONSTANT , init . isStarted () ) ; }
{ BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; init . get () ; }
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
{ BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; assertNull ( STRING_CONSTANT , init . getActiveExecutor () ) ; }
{ BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; init . start () ; checkInitialize ( init ) ; }
try { CharUtils . toIntValue ( CHAR_CONS ) ; } catch ( IllegalArgumentException ex ) {}
try { CharUtils . toChar ( ( Character ) null ) ; } catch ( IllegalArgumentException ex ) {}
{ double anotherVal = other.value ; return Double . compare ( value , anotherVal ) ; }
{ long bits = Double . doubleToLongBits ( value ) ; return ( int ) ( bits ^ bits > > > NUMBER_CONSTANT ) ; }
String o1 = STRING_CONSTANT ;
String o1 = STRING_CONSTANT ;
{ TestObject o1 = new TestObject ( NUMBER_CONSTANT ) ; CompareToBuilder . reflectionCompare ( o1 , null ) ; }
TestSubObject rhs = ( TestSubObject ) o ;
TestObject rhs = ( TestObject ) o ;
long anotherVal = other.value ;
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
{ Integer [] iArray = null ; assertEquals ( null , ArrayUtils . toPrimitive ( iArray , Integer.MIN_VALUE ) ) ; }
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
StringBuffer buf = new StringBuffer ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
{ StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , sb . toString () ) ; }
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
catch ( IndexOutOfBoundsException ex ) {}
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
{ for ( L listener : listeners ) { method . invoke ( listener , args ) ; } return null ; }
BitSet toRemove = new BitSet () ;
Locale dflt = Locale . getDefault () ;
Locale dflt = Locale . getDefault () ;
Locale dflt = Locale . getDefault () ;
Locale dflt = Locale . getDefault () ;
Locale dflt = Locale . getDefault () ;
Calendar testCalendar = Calendar . getInstance () ;
try { DateUtils . toCalendar ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
GregorianCalendar cal = new GregorianCalendar () ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
{ try { return parentClass . getMethod ( methodName , parameterTypes ) ; } catch ( NoSuchMethodException e ) { return null ; } }
{ try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } }
try { return Charset . isSupported ( name ) ; } catch ( IllegalCharsetNameException ex ) { return false ; }
catch ( SerializationException ex ) { return; }
{ Object test = SerializationUtils . clone ( null ) ; assertNull ( test ) ; }
try { SerializationUtils . deserialize ( new byte [ NUMBER_CONSTANT ] ) ; } catch ( SerializationException ex ) { return; }
try { SerializationUtils . deserialize ( ( byte [] ) null ) ; } catch ( IllegalArgumentException ex ) { return; }
catch ( SerializationException ex ) { return; }
catch ( SerializationException ex ) { return; }
try { SerializationUtils . deserialize ( ( InputStream ) null ) ; } catch ( IllegalArgumentException ex ) { return; }
{ try { SerializationUtils . serialize ( null , null ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { SerializationUtils . serialize ( iMap , null ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
Exception ex = new Exception () ;
catch ( IllegalStateException e ) {}
Object obj = new Object () ;
TestSubObject rhs = ( TestSubObject ) o ;
TestObject rhs = ( TestObject ) o ;
MessageFormat result = new MessageFormat ( pattern ) ;
for ( Locale locale : locales ) { checkBuiltInFormat ( pattern , registry , args , locale ) ; }
CharSet other = ( CharSet ) obj ;
{ for ( CharRange range : set ) { if ( range . contains ( ch ) ) { return true ; } } return false ; }
int sz = set.length ;
{ try { throw new ExceptionWithoutCause () ; } catch ( Throwable t ) { return t ; } }
try { mutNum . compareTo ( null ) ; fail () ; } catch ( NullPointerException ex ) {}
try { mutNum . setValue ( null ) ; fail () ; } catch ( NullPointerException ex ) {}
try { new MutableShort ( ( Number ) null ) ; fail () ; } catch ( NullPointerException ex ) {}
catch ( IllegalArgumentException expected ) {}
char cur = current ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
CharRange other = ( CharRange ) obj ;
if ( start > end ) { char temp = start ; start = end ; end = temp ; }
catch ( SecurityException ex ) { System.err . println ( STRING_CONSTANT + property + STRING_CONSTANT ) ; return null ; }
catch ( ConcurrentException cex ) { throw new ConcurrentRuntimeException ( cex . getCause () ) ; }
V value = map . get ( key ) ;
try { return initialize ( initializer ) ; } catch ( ConcurrentException cex ) { throw new ConcurrentRuntimeException ( cex . getCause () ) ; }
{ ConcurrentRuntimeException crex = extractCauseUnchecked ( ex ) ; if ( crex != null ) { throw crex ; } }
{ ConcurrentException cex = extractCause ( ex ) ; if ( cex != null ) { throw cex ; } }
{ ByteArrayOutputStream baos = new ByteArrayOutputStream ( NUMBER_CONSTANT ) ; serialize ( obj , baos ) ; return baos . toByteArray () ; }
String message = exceptionContext . getMessage () ;
String trace = ExceptionUtils . getStackTrace ( exceptionContext ) ;
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
Person p = new Person () ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
{ Object [] array = null ; assertEquals ( NUMBER_CONSTANT , ObjectUtils . hashCodeMulti ( array ) ) ; }
int anotherVal = other.value ;
InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture () ;
ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture () ;
SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture () ;
SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture () ;
SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture () ;
SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture () ;
Outer outer = new Outer () ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
Character c = new Character ( CHAR_CONS ) ;
{ try { coll . add ( null ) ; fail () ; } catch ( UnsupportedOperationException ex ) {} }
Locale locale = LocaleUtils . toLocale ( localeString ) ;
Locale locale = LocaleUtils . toLocale ( localeString ) ;
Locale locale = LocaleUtils . toLocale ( language ) ;
IllegalArgumentException ex
long seed = System . currentTimeMillis () ;
long seed = System . currentTimeMillis () ;
String message = exceptionContext . getMessage () ;
String trace = ExceptionUtils . getStackTrace ( exceptionContext ) ;
try { return Short . parseShort ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Byte . parseByte ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Double . parseDouble ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Float . parseFloat ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Long . parseLong ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Integer . parseInt ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
int start = index + NUMBER_CONSTANT ;
try { StrLookup . systemPropertiesLookup () . lookup ( null ) ; fail () ; } catch ( NullPointerException ex ) {}
{ final BigDecimal value = NumberUtils . createBigDecimal ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final BigInteger value = NumberUtils . createBigInteger ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final Long value = NumberUtils . createLong ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final Integer value = NumberUtils . createInteger ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final Double value = NumberUtils . createDouble ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final Float value = NumberUtils . createFloat ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ return cache . getDateTimeInstance ( null , style , timeZone , locale ) ; }
{ return cache . getDateTimeInstance ( null , style , timeZone , null ) ; }
{ return cache . getDateTimeInstance ( null , style , null , locale ) ; }
{ return cache . getDateTimeInstance ( null , style , null , null ) ; }
{ return cache . getDateTimeInstance ( style , null , timeZone , locale ) ; }
{ return cache . getDateTimeInstance ( style , null , timeZone , null ) ; }
{ return cache . getDateTimeInstance ( style , null , null , locale ) ; }
{ return cache . getDateTimeInstance ( style , null , null , null ) ; }
return org.apache.commons.lang3.SerializationUtils . < T > deserialize ( new ByteArrayInputStream ( objectData ) ) ;
exceptionContext = new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () {} ) ;
exceptionContext = new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () ) ;
Strategy strategy = cache . get ( Integer . valueOf ( field ) ) ;
if ( nullText != null && nullText . length () == NUMBER_CONSTANT ) { nullText = null ; }
if ( str . length () == NUMBER_CONSTANT ) { return ArrayUtils.EMPTY_STRING_ARRAY ; }
if ( separator . length () == NUMBER_CONSTANT ) { return EMPTY ; }
return str . length () == NUMBER_CONSTANT ? null : str ;
if ( str . length () == NUMBER_CONSTANT || deepEmpty ( set ) ) { return StringUtils.EMPTY ; }
final Integer max = TypeUtilsTest . stub () ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () {} )
{ if ( this . runningState == STATE_UNSTARTED ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } return this . startTimeMillis ; }
if ( this . splitState != STATE_SPLIT ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
{ return new GenericArrayTypeImpl ( componentType ) ; }
{ FieldUtils . readDeclaredField ( ( Object ) null , STRING_CONSTANT , true ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readDeclaredField ( ( Object ) null , STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readField ( ( Field ) null , publicChild , true ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readField ( ( Field ) null , publicChild ) ; fail ( STRING_CONSTANT ) ; }
assertEquals ( null , LocaleUtils . toLocale ( ( String ) null ) ) ;
final Iterable < E > values
final Iterable < E > values
{ return new FastDateParser ( format , timeZone , locale ) ; }
assertEquals ( null , StringUtils . normalizeSpace ( null ) ) ;
assertEquals ( null , StringUtils . difference ( null , null ) ) ;
assertEquals ( null , StringUtils . abbreviate ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . reverseDelimited ( null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . reverse ( null ) ) ;
assertEquals ( null , StringUtils . leftPad ( null , NUMBER_CONSTANT , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . leftPad ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . rightPad ( null , NUMBER_CONSTANT , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . rightPad ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . repeat ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . replaceChars ( null , CHAR_CONS , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . deleteWhitespace ( null ) ) ;
assertArrayEquals ( null , StringUtils . splitPreserveAllTokens ( null , CHAR_CONS ) ) ;
assertArrayEquals ( null , StringUtils . splitPreserveAllTokens ( null ) ) ;
assertArrayEquals ( null , StringUtils . split ( null , CHAR_CONS ) ) ;
assertArrayEquals ( null , StringUtils . split ( null ) ) ;
assertEquals ( minutes + ( ( hours * DateUtils.MILLIS_PER_HOUR ) + ( days * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_MINUTE , testResult )
assertEquals ( minutes + ( ( hours * DateUtils.MILLIS_PER_HOUR ) + ( days * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_MINUTE , testResult )
( ( minutes * DateUtils.MILLIS_PER_MINUTE ) + ( hours * DateUtils.MILLIS_PER_HOUR ) + ( days * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_SECOND
( ( minutes * DateUtils.MILLIS_PER_MINUTE ) + ( hours * DateUtils.MILLIS_PER_HOUR ) + ( days * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_SECOND
( days * DateUtils.MILLIS_PER_DAY )
( days * DateUtils.MILLIS_PER_DAY )
assertEquals ( null , StringUtils . swapCase ( null ) ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
final Class context
final Class context
list0 = new ArrayList < Object > ( Arrays . asList () )
assertEquals ( STRING_CONSTANT , StringUtils . join () ) ;
return readField ( field , target ) ;
return readField ( field , target ) ;
writeField ( field , target , value ) ;
writeField ( field , target , value ) ;
writeField ( field , ( Object ) null , value ) ;
writeStaticField ( field , value ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toShort ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toDouble ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toFloat ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toLong ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toInt ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toShort ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toDouble ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toFloat ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toLong ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toInt ( ( String ) null ) == NUMBER_CONSTANT ) ;
{ return new DiffResult ( lhs , rhs , diffs , style ) ; }
{ super ( message , cause ) ; }
public NotImplementedException ( final Throwable cause ) { super ( cause ) ; }
{ super ( message ) ; }
return input . length () ;
{ pos += Character . charCount ( Character . codePointAt ( input , pt ) ) ; }
Date centuryStart
{ return getFragment ( calendar , fragment , Calendar.DAY_OF_YEAR ) ; }
{ return getFragment ( calendar , fragment , Calendar.HOUR_OF_DAY ) ; }
{ return getFragment ( calendar , fragment , Calendar.MINUTE ) ; }
{ return getFragment ( calendar , fragment , Calendar.SECOND ) ; }
{ return getFragment ( calendar , fragment , Calendar.MILLISECOND ) ; }
{ return getFragment ( date , fragment , Calendar.DAY_OF_YEAR ) ; }
{ return getFragment ( date , fragment , Calendar.HOUR_OF_DAY ) ; }
{ return getFragment ( date , fragment , Calendar.MINUTE ) ; }
{ return getFragment ( date , fragment , Calendar.SECOND ) ; }
{ return getFragment ( date , fragment , Calendar.MILLISECOND ) ; }
return - NUMBER_CONSTANT ;
final Integer iVal = keyValues . get ( value ) ;
regex . append ( CHAR_CONS ) ;
final Integer iVal = lKeyValues . get ( value . toLowerCase () ) ;
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( locale ) : new TextStrategy ( field , definingCalendar , locale ) ;
for ( final String textKeyValue : keyValues . keySet () ) { sb . append ( textKeyValue ) . append ( CHAR_CONS ) ; }
for ( final String textKeyValue : keyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
shift = i * NUMBER_CONSTANT + srcPos ;
shift = i * NUMBER_CONSTANT + srcPos ;
shift = i * NUMBER_CONSTANT + srcPos ;
shift = i * NUMBER_CONSTANT + dstPos ;
shift = i * NUMBER_CONSTANT + dstPos ;
shift = i * NUMBER_CONSTANT + dstPos ;
shift = i * NUMBER_CONSTANT + dstPos ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
Interfaces interfacesBehavior
String [] zone
{ int trial = century + twoDigitYear ; return twoDigitYear >= startYear ? trial : trial + NUMBER_CONSTANT ; }
Calendar definingCalendar
SimpleClass obj
public SimpleClass ( boolean booleanField ) { this . booleanField = booleanField ; }
{ String pattern = STRING_CONSTANT ; FastDateFormat . getInstance ( pattern ) ; }
protected BooleanDiff ( String fieldName ) { super ( fieldName ) ; }
{ for ( Token token : tokens ) { if ( token . getValue () == value ) { return true ; } } return false ; }
Field field
Class < > cls
StringBuilder sb = new StringBuilder () ;
StringBuilder sb = new StringBuilder () ;
{ int tmpHash = ObjectUtils . hashCode ( object ) ; hash = hash * NUMBER_CONSTANT + tmpHash ; }
GenericArrayType g
WildcardType w
ParameterizedType p
TypeVariable < > v
Class < > c
TypeVariable < > var
Type type
Object obj
Object obj
Object obj
Type componentType
Type . . . bounds
Type . . . bounds
double result = RandomUtils . nextDouble ( NUMBER_CONSTANT , Double.MAX_VALUE ) ;
float result = RandomUtils . nextFloat ( NUMBER_CONSTANT , Float.MAX_VALUE ) ;
long result = RandomUtils . nextLong ( NUMBER_CONSTANT , Long.MAX_VALUE ) ;
int result = RandomUtils . nextInt ( NUMBER_CONSTANT , Integer.MAX_VALUE ) ;
long result = RandomUtils . nextLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double result = RandomUtils . nextFloat ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double result = RandomUtils . nextDouble ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
int result = RandomUtils . nextInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
@ Override public void consume ( String t ) { super . consume ( t ) ; }
@ Override public void consume ( T t ) {}
Calendar c = Calendar . getInstance () ;
Method m
Method m
char ch
char ch
Object obj
StringBuilder source
CharSequence source
T value
String fieldName
TypeTestClass class1 = new TypeTestClass () ;
@ Override public boolean equals ( Object obj ) { return EqualsBuilder . reflectionEquals ( this , obj , false ) ; }
TypeTestClass obj
char firstChar = str . charAt ( NUMBER_CONSTANT ) ;
char firstChar = str . charAt ( NUMBER_CONSTANT ) ;
CharSequence . . . css
CharSequence . . . css
Locale locale
Locale locale
Locale locale
String [] element
String [] element
for ( final CharSequence searchString : searchStrings ) { if ( StringUtils . endsWith ( string , searchString ) ) { return true ; } }
for ( final CharSequence searchString : searchStrings ) { if ( StringUtils . startsWith ( string , searchString ) ) { return true ; } }
{ return StringUtils . isEmpty ( str ) ? defaultStr : str ; }
{ return StringUtils . isBlank ( str ) ? defaultStr : str ; }
{ return ! StringUtils . isBlank ( cs ) ; }
{ return ! StringUtils . isEmpty ( cs ) ; }
{ return isDigits ( StringUtils . replaceOnce ( StringUtils . substring ( str , NUMBER_CONSTANT ) , STRING_CONSTANT , StringUtils.EMPTY ) ) ; }
modify ( ceiled , field , MODIFY_CEILING ) ;
modify ( gval , field , MODIFY_CEILING ) ;
modify ( truncated , field , MODIFY_TRUNCATE ) ;
modify ( gval , field , MODIFY_TRUNCATE ) ;
modify ( rounded , field , MODIFY_ROUND ) ;
modify ( gval , field , MODIFY_ROUND ) ;
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
{ type = array . getClass () ; }
appendQuotedString ( pattern , pos , sb , false ) ;
getQuotedString ( pattern , pos , false ) ;
appendQuotedString ( pattern , pos , stripCustom , true ) ;
{ regex . append ( PATTERN ) ; return true ; }
{ if ( value < NUMBER_CONSTANT ) { appendDigits ( buffer , value ) ; } else { buffer . append ( Integer . toString ( value ) ) ; } }
exec . awaitTermination ( Long.MAX_VALUE , TimeUnit.MILLISECONDS ) ;
{ System.out . println ( STRING_CONSTANT + osName ) ; }
return osName . startsWith ( osNamePrefix ) && osVersion . startsWith ( osVersionPrefix ) ;
return isOSNameMatch ( osName , osNamePrefix ) && osVersion . startsWith ( osVersionPrefix ) ;
{ fail ( STRING_CONSTANT + osName ) ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
final int halflength = ( shorter . length () / NUMBER_CONSTANT ) + NUMBER_CONSTANT ;
( f . getName () . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT )
( field . getName () . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT )
( f . getName () . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT )
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }
{ if ( isEquals == false ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
if ( isEquals == false ) { return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = superEquals ; return this ; }
modType == ModifyType.CEILING || ( modType == ModifyType.ROUND && roundUp )
{ result = DateUtils . setMilliseconds ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setSeconds ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setMinutes ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setHours ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setDays ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setMonths ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
try { date = DateUtils . parseDateStrictly ( dateStr , parsers ) ; fail () ; } catch ( final ParseException ex ) {}
{ regex . append ( validTimeZoneChars ) ; return true ; }
{ regex . append ( VALID_TZ ) ; return true ; }
{ regex . append ( validTimeZoneChars ) ; return true ; }
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
expected . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ this ( pattern , timeZone , locale , null ) ; }
text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT . format ( cal ) ;
{ return applyRules ( calendar , buf ) ; }
final String actualValue = FastDateFormat . getInstance ( PATTERN ) . format ( cal ) ;
if ( tokenLen == NUMBER_CONSTANT ) { rule = TimeZoneNumberRule.INSTANCE_ISO_8601 ; } else { rule = TimeZoneNumberRule.INSTANCE_COLON ; }
if ( ! threadGroup . isDestroyed () ) threadGroup . destroy () ;
this . typeArguments = typeArguments ;
@ Override public boolean test ( @ SuppressWarnings ( STRING_CONSTANT ) final Thread thread ) { return true ; }
@ Override public boolean test ( @ SuppressWarnings ( STRING_CONSTANT ) final ThreadGroup threadGroup ) { return true ; }
if ( threadGroups . isEmpty () ) { return Collections.EMPTY_LIST ; }
super ( object , style , buffer ) ;
{ super ( object , style , buffer ) ; }
{ super ( object , style ) ; }
{ super ( object ) ; }
@ Override public boolean test ( @ SuppressWarnings ( STRING_CONSTANT ) final Thread thread ) { return true ; }
@ Override public boolean test ( @ SuppressWarnings ( STRING_CONSTANT ) final ThreadGroup threadGroup ) { return true ; }
if ( threadGroups . isEmpty () ) { return Collections.EMPTY_LIST ; }
tz = tzNames . get ( value ) ;
{ regex . append ( VALID_TZ ) ; return true ; }
for ( final String textKeyValue : lKeyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
@ SuppressWarnings ( STRING_CONSTANT ) final Map < String , String > propertiesMap = ( Map ) properties ;
ISO8601TimeZoneStrategy ( String pattern ) { this . pattern = pattern ; }
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
{ this ( pattern , timeZone , locale , null , true ) ; }
final String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
final String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
final DateParser fdp = FastDateFormat . getInstance ( STRING_CONSTANT , kst , Locale.KOREA ) ;
{ return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString () ; }
assertTrue ( BooleanUtils . toBoolean ( new StringBuffer ( STRING_CONSTANT ) . append ( STRING_CONSTANT ) . toString () ) ) ;
final char newChar = Character . toUpperCase ( firstChar ) ;
{ try { throw new IOException () ; } catch ( Exception e ) { return ExceptionUtils . rethrow ( e ) ; } }
if ( count == NUMBER_CONSTANT ) { return STRING_CONSTANT ; } else if ( count < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + count + STRING_CONSTANT ) ; }
return pattern . matcher ( decomposed ) . replaceAll ( STRING_CONSTANT ) ;
return new StringBuilder ( annotationType == null ? STRING_CONSTANT : annotationType . getName () ) . insert ( NUMBER_CONSTANT , CHAR_CONS ) . toString () ;
{ if ( summaryObjectEndText == null ) { summaryObjectEndText = STRING_CONSTANT ; } this . summaryObjectEndText = summaryObjectEndText ; }
{ if ( summaryObjectStartText == null ) { summaryObjectStartText = STRING_CONSTANT ; } this . summaryObjectStartText = summaryObjectStartText ; }
{ if ( sizeEndText == null ) { sizeEndText = STRING_CONSTANT ; } this . sizeEndText = sizeEndText ; }
{ if ( sizeStartText == null ) { sizeStartText = STRING_CONSTANT ; } this . sizeStartText = sizeStartText ; }
{ if ( nullText == null ) { nullText = STRING_CONSTANT ; } this . nullText = nullText ; }
{ if ( fieldSeparator == null ) { fieldSeparator = STRING_CONSTANT ; } this . fieldSeparator = fieldSeparator ; }
{ if ( fieldNameValueSeparator == null ) { fieldNameValueSeparator = STRING_CONSTANT ; } this . fieldNameValueSeparator = fieldNameValueSeparator ; }
{ if ( contentEnd == null ) { contentEnd = STRING_CONSTANT ; } this . contentEnd = contentEnd ; }
{ if ( contentStart == null ) { contentStart = STRING_CONSTANT ; } this . contentStart = contentStart ; }
{ if ( arraySeparator == null ) { arraySeparator = STRING_CONSTANT ; } this . arraySeparator = arraySeparator ; }
{ if ( arrayEnd == null ) { arrayEnd = STRING_CONSTANT ; } this . arrayEnd = arrayEnd ; }
{ if ( arrayStart == null ) { arrayStart = STRING_CONSTANT ; } this . arrayStart = arrayStart ; }
{ return obj == null ? STRING_CONSTANT : obj . toString () ; }
if ( pos >= count ) { addToken ( tokenList , STRING_CONSTANT ) ; }
if ( delimiters != null && delimiters.length == NUMBER_CONSTANT ) { return STRING_CONSTANT ; }
if ( th == null ) { return STRING_CONSTANT ; }
if ( locale . getCountry () . length () > NUMBER_CONSTANT ) { list . add ( new Locale ( locale . getLanguage () , STRING_CONSTANT ) ) ; }
if ( length <= NUMBER_CONSTANT || index >= size ) { return STRING_CONSTANT ; }
{ return STRING_CONSTANT ; }
{ return STRING_CONSTANT ; }
if ( str == null ) { str = STRING_CONSTANT ; }
if ( str == null ) { str = STRING_CONSTANT ; }
appendDisplayNames ( definingCalendar , locale , field , regex , lKeyValues ) ;
{ return parseDateWithLeniency ( str , null , parsePatterns , false ) ; }
public TestBean ( final Object o ) { toString = STRING_CONSTANT ; }
public TestBean ( final String s ) { toString = STRING_CONSTANT ; }
public TestBean ( final double d ) { toString = STRING_CONSTANT ; }
public TestBean ( final Integer i ) { toString = STRING_CONSTANT ; }
public TestBean ( final int i ) { toString = STRING_CONSTANT ; }
public TestBean () { toString = STRING_CONSTANT ; }
{ return ( boolean [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( double [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( float [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( long [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( char [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( int [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( short [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( byte [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( T [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ assertEquals ( str , toString ) ; assertEquals ( args , varArgs ) ; }
{ return getCause ( throwable , CAUSE_METHOD_NAMES ) ; }
assertEquals ( STRING_CONSTANT , JAVA_1_9 , get ( STRING_CONSTANT ) ) ;
if ( STRING_CONSTANT . equals ( nom ) ) { return JAVA_1_8 ; } else if ( STRING_CONSTANT . equals ( nom ) ) { return JAVA_1_9 ; }
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( definingCalendar , locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
final boolean isValid = NumberUtils . isNumber ( val ) ;
if ( srcArgs.length < normalArgsLen ) return Float.MAX_VALUE ;
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
final boolean hasSign = ( firstChar == CHAR_CONS || firstChar == CHAR_CONS ) ;
final String javaVersion = System . getProperty ( STRING_CONSTANT ) ;
if ( ArrayUtils . isEmpty ( css ) ) { return true ; }
if ( ArrayUtils . isEmpty ( css ) ) { return true ; }
if ( ArrayUtils . isEmpty ( css ) ) { return true ; }
if ( ArrayUtils . isEmpty ( css ) ) { return true ; }
{ return new ImmutablePair < L , R > ( left , right ) ; }
final Set < Locale > jdkLocaleSet = new HashSet < Locale > ( jdkLocaleList ) ;
final List < Field > allFieldsInteger = new ArrayList < Field > ( fieldsInteger ) ;
final CallableBackgroundInitializer < Integer > init = new CallableBackgroundInitializer < Integer > ( call ) ;
{ new CallableBackgroundInitializer < Object > ( null ) ; }
tasks = new ArrayList < Callable < Integer > > ()
this . diffs = new ArrayList < Diff < > > () ;
final HashSet < Integer > toRemove = new HashSet < Integer > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > frames = new ArrayList < String > () ;
final List < Throwable > list = new ArrayList < Throwable > () ;
typeVarAssigns = new HashMap < TypeVariable < > , Type > ()
final List < Field > annotatedFields = new ArrayList < Field > () ;
final List < Field > allFields = new ArrayList < Field > () ;
final Map < String , E > map = new LinkedHashMap < String , E > () ;
final List < String > tokenList = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > ( tokens.length ) ;
final Set < > set = Collections . unmodifiableSet ( new HashSet < Object > () ) ;
final Set < > set = Collections . unmodifiableSet ( new HashSet < Object > () ) ;
final List < Class < > > list = new ArrayList < Class < > > () ;
final List < String > list = new ArrayList < String > () ;
{ return new ConstantFuture < T > ( value ) ; }
{ return new MapStrLookup < V > ( map ) ; }
final HashMap < Boolean , MutableInt > occurrences = new HashMap < Boolean , MutableInt > ( NUMBER_CONSTANT ) ;
final HashMap < Double , MutableInt > occurrences = new HashMap < Double , MutableInt > ( values.length ) ;
final HashMap < Float , MutableInt > occurrences = new HashMap < Float , MutableInt > ( values.length ) ;
final HashMap < Long , MutableInt > occurrences = new HashMap < Long , MutableInt > ( values.length ) ;
final HashMap < Character , MutableInt > occurrences = new HashMap < Character , MutableInt > ( values.length ) ;
final HashMap < Integer , MutableInt > occurrences = new HashMap < Integer , MutableInt > ( values.length ) ;
final HashMap < Short , MutableInt > occurrences = new HashMap < Short , MutableInt > ( values.length ) ;
final Map < Byte , MutableInt > occurrences = new HashMap < Byte , MutableInt > ( values.length ) ;
final HashMap < T , MutableInt > occurrences = new HashMap < T , MutableInt > ( values.length ) ;
final AtomicReference < InterruptedException > iex = new AtomicReference < InterruptedException > () ;
{ return new MutablePair < L , R > ( left , right ) ; }
if ( m == null ) { REGISTRY . set ( new WeakHashMap < Object , Object > () ) ; }
countries = new ArrayList < Locale > () ;
langs = new ArrayList < Locale > () ;
final List < Locale > list = new ArrayList < Locale > ( NUMBER_CONSTANT ) ;
final Set < Type > types = new HashSet < Type > ( bounds.length ) ;
{ priorVariables = new ArrayList < String > () ; priorVariables . add ( new String ( chars , offset , length ) ) ; }
final Map < String , String > valueMap = new HashMap < String , String > () ;
final Map < String , Object > map = new HashMap < String , Object > () ;
final Set < String > labels = new HashSet < String > () ;
final List < Object > values = new ArrayList < Object > () ;
{ contextValues . add ( new ImmutablePair < String , Object > ( label , value ) ) ; return this ; }
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
iMap = new HashMap < Object , Object > () ;
this . listeners = new CopyOnWriteArrayList < L > ( srcListeners ) ;
final ArrayList < L > serializableListeners = new ArrayList < L > () ;
{ return new EventListenerSupport < T > ( listenerInterface ) ; }
final List < VetoableChangeListener > calledListeners = new ArrayList < VetoableChangeListener > () ;
final List < Class < > > candidateClasses = new ArrayList < Class < > > () ;
final List < String > classNames = new ArrayList < String > ( classes . size () ) ;
final List < Class < > > classes = new ArrayList < Class < > > () ;
final HashMap < Integer , String > map = new HashMap < Integer , String > () ;
{ expectedSource = source ; changedValues = new ArrayList < Boolean > () ; }
final List < Object > list = new ArrayList < Object > () ;
final List < String > list = new ArrayList < String > ( array.length ) ;
final List < Method > annotatedMethods = new ArrayList < Method > () ;
final Set < Method > result = new LinkedHashSet < Method > () ;
this . eventTypes = new HashSet < String > ( Arrays . asList ( eventTypes ) ) ;
if ( registry == null ) { registry = new HashSet < IDKey > () ; REGISTRY . set ( registry ) ; }
final MutableObject < String > obj = new MutableObject < String > ( replaceTemplate ) ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
values = new HashMap < String , String > () ;
final HashMap < T , MutableInt > occurrences = new HashMap < T , MutableInt > ( items.length ) ;
final TreeSet < T > sort = new TreeSet < T > ( comparator ) ;
final TreeSet < T > sort = new TreeSet < T > () ;
final List < ThreadGroup > result = new ArrayList < ThreadGroup > ( count ) ;
final List < Thread > result = new ArrayList < Thread > ( count ) ;
final Collection < Thread > result = new ArrayList < Thread > () ;
{ return new ImmutablePair < L , R > ( left , right ) ; }
final Map < DateParser , Integer > map = new HashMap < DateParser , Integer > () ;
final Set < String > sorted = new TreeSet < String > ( LONGER_FIRST_LOWERCASE ) ;
{ caches [ field ] = new ConcurrentHashMap < Locale , Strategy > ( NUMBER_CONSTANT ) ; }
patterns = new ArrayList < StrategyAndWidth > () ;
final HashSet < Locale > testLocales = new HashSet < Locale > () ;
final String s = new ConstantInitializer < Object > ( null ) . toString () ;
checkEquals ( new ConstantInitializer < String > ( STRING_CONSTANT ) , false ) ;
@ Before public void setUp ( ) throws Exception { init = new ConstantInitializer < Integer > ( VALUE ) ; }
triple = new MutableTriple < Integer , String , Boolean > ()
pair = new MutablePair < Integer , String > ( NUMBER_CONSTANT , STRING_CONSTANT )
final MutablePair < Integer , String > pair = new MutablePair < Integer , String > () ;
{ return new Range < T > ( fromInclusive , toInclusive , comparator ) ; }
tasks = new ArrayList < Callable < Integer > > ()
List < TimeZone > timeZones = new ArrayList < TimeZone > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > () ;
final ArrayList < String > substrings = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > excludeList = new ArrayList < String > () ;
final List < String > excludeList = new ArrayList < String > () ;
final List < String > excludeList = new ArrayList < String > () ;
final Collection < String > coll = new ArrayList < String > () ;
final Collection < String > coll = new ArrayList < String > () ;
final List < String > coll = new ArrayList < String > () ;
final List < String > coll = new ArrayList < String > () ;
final Map < String , Integer > map = new HashMap < String , Integer > () ;
final Map < String , Integer > map = new HashMap < String , Integer > () ;
final Collection < Integer > coll = new ArrayList < Integer > () ;
final Collection < Integer > coll = new ArrayList < Integer > () ;
final List < Rule > rules = new ArrayList < Rule > () ;
public CircuitBreakingException ( Throwable cause ) { super ( cause ) ; }
public CircuitBreakingException ( String message ) { super ( message ) ; }
public Customer ( String name ) { this . name = name ; }
public Bank ( String name ) { this . name = name ; }
Object object
Object object
FastDateParser parser
FastDateParser parser
FastDateParser parser
@ Override int modify ( FastDateParser parser , final int iValue ) { return iValue - NUMBER_CONSTANT ; }
int tokenLen
ISO8601TimeZoneStrategy ( String pattern ) { createPattern ( pattern ) ; }
FastDateParser parser
FastDateParser parser
void createPattern ( String regex ) { this . pattern = Pattern . compile ( regex ) ; }
void createPattern ( StringBuilder regex ) { createPattern ( regex . toString () ) ; }
char c
char c
ListIterator < StrategyAndWidth > lt
public FastDatePrinterTimeZonesTest ( TimeZone timeZone ) { this . timeZone = timeZone ; }
int . . . args
String . . . s
class LANG1261ParentObject { @ Override public boolean equals ( Object o ) { return true ; } }
Method method
SystemDefaults defaults
SystemDefaults defaults
int len
Constructor < > constructor
Method method
private static Executable of ( Constructor < > constructor ) { return new Executable ( constructor ) ; }
private static Executable of ( Method method ) { return new Executable ( method ) ; }
Number . . . args
String . . . args
Number . . . args
String . . . args
public static String numOverload ( Number . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Long . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Integer . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Double . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Float . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Short . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Byte . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( String . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Object . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Number . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Long . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Integer . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Double . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Float . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Boolean . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Short . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Character . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Byte . . . args ) { return STRING_CONSTANT ; }
public int [] unboxing ( int . . . values ) { return values ; }
PropertyChangeListener listener
PropertyChangeListener listener
State newState
State state
Boolean . . . values
PropertyChangeEvent evt
Object source
long time
TimeZone tz
String valueAsString
String valueAsString
int spaces
Long increment
long threshold
boolean [] array
char [] array
byte [] array
short [] array
long [] array
int [] array
int offset
int offset
int offset
int offset
int offset
int offset
int offset
int offset
int offset
TimeZone tz
int tokenLen
int value
Object obj
@ Override protected long fetchCheckInterval ( EventCountCircuitBreaker breaker ) { return breaker . getClosingInterval () ; }
@ Override protected long fetchCheckInterval ( EventCountCircuitBreaker breaker ) { return breaker . getOpeningInterval () ; }
int delta
State state
State newState
int increment
Integer increment
private NotVisibleException ( Throwable cause ) { this . cause = cause ; }
boolean allowDuplicate
Calendar calendar
Calendar calendar
Class < ? extends Throwable > type
Throwable throwable
Throwable throwable
Throwable throwable
String key
long nanos
int max
StringBuilder decomposed
int maxWidth
ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
{ ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( zeroThreshold ) ; assertTrue ( STRING_CONSTANT , circuit . incrementAndCheckState ( NUMBER_CONSTANT ) ) ; }
ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
catch ( UnsupportedOperationException e ) {}
catch ( UnsupportedOperationException e ) {}
catch ( UnsupportedOperationException e ) {}
long randomResult = RandomUtils . nextLong () ;
float randomResult = RandomUtils . nextFloat () ;
double randomResult = RandomUtils . nextDouble () ;
int randomResult = RandomUtils . nextInt () ;
float result = mutableFloat . addAndGet ( NUMBER_CONSTANT ) ;
float result = mutableFloat . getAndAdd ( NUMBER_CONSTANT ) ;
float result = mutNum . getAndDecrement () ;
float result = mutNum . decrementAndGet () ;
float result = mutNum . getAndIncrement () ;
float result = mutNum . incrementAndGet () ;
Calendar cal = Calendar . getInstance () ;
catch ( Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , TestThrowable . class ) ) ; }
catch ( Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , IOException . class ) ) ; }
catch ( Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , RuntimeException . class ) ) ; }
catch ( Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , Error . class ) ) ; }
try { throw new IOException () ; } catch ( Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; }
byte result = mutNum . getAndDecrement () ;
byte result = mutNum . decrementAndGet () ;
byte result = mutNum . getAndIncrement () ;
byte result = mutNum . incrementAndGet () ;
short result = mutNum . getAndDecrement () ;
short result = mutNum . decrementAndGet () ;
short result = mutNum . getAndIncrement () ;
short result = mutNum . incrementAndGet () ;
double result = mutableDouble . addAndGet ( - NUMBER_CONSTANT ) ;
double result = mutableDouble . getAndAdd ( NUMBER_CONSTANT ) ;
double result = mutNum . getAndDecrement () ;
double result = mutNum . decrementAndGet () ;
double result = mutNum . getAndIncrement () ;
double result = mutNum . incrementAndGet () ;
StringBuilder sb = new StringBuilder () ;
int result = mutNum . getAndDecrement () ;
int result = mutNum . decrementAndGet () ;
int result = mutNum . getAndIncrement () ;
int result = mutNum . incrementAndGet () ;
catch ( IllegalAccessException e ) { return null ; }
catch ( Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; }
catch ( Exception e ) { return ExceptionUtils . < Boolean > rethrow ( e ) ; }
Format fdf = FastDateFormat . getInstance ( pattern ) ;
{ StateStrategy strategy = STRATEGY_MAP . get ( state ) ; return strategy ; }
long time = now () ;
catch ( InterruptedException iex ) {}
StringBuilder regex = new StringBuilder () ;
int sIdx = idx + pos . getIndex () ;
char c = value . charAt ( i ) ;
ParsePosition pp = new ParsePosition ( NUMBER_CONSTANT ) ;
char c = pattern . charAt ( currentIdx ) ;
{ int last = value ; this . value += operand . intValue () ; return last ; }
{ int last = value ; this . value += operand ; return last ; }
{ int last = value ; value -- ; return last ; }
{ int last = value ; value ++ ; return last ; }
{ short last = value ; this . value += operand . shortValue () ; return last ; }
{ short last = value ; this . value += operand ; return last ; }
{ short last = value ; value -- ; return last ; }
{ short last = value ; value ++ ; return last ; }
{ long last = value ; this . value += operand . longValue () ; return last ; }
{ long last = value ; this . value += operand ; return last ; }
{ long last = value ; value -- ; return last ; }
{ long last = value ; value ++ ; return last ; }
Calendar calendar = Calendar . getInstance () ;
Calendar cal = Calendar . getInstance ( SWEDEN ) ;
Calendar cal = Calendar . getInstance ( tz ) ;
{ float last = value ; this . value += operand . floatValue () ; return last ; }
{ float last = value ; this . value += operand ; return last ; }
{ float last = value ; value -- ; return last ; }
{ float last = value ; value ++ ; return last ; }
ExecutorService exec = Executors . newSingleThreadExecutor () ;
Locale save = Locale . getDefault () ;
TimeZone save = TimeZone . getDefault () ;
{ String date = STRING_CONSTANT ; DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT . parse ( date ) ; }
String encoding = STRING_CONSTANT ;
String methodStr = m . toString () ;
long result = mutNum . getAndDecrement () ;
long result = mutNum . decrementAndGet () ;
long result = mutNum . getAndIncrement () ;
long result = mutNum . incrementAndGet () ;
Exception ex
StringBuilder sb = new StringBuilder ( NUMBER_CONSTANT ) ;
int lastHold = start ;
int value = calendar . get ( Calendar.DAY_OF_WEEK ) ;
catch ( IOException ioe ) { ExceptionUtils . rethrow ( ioe ) ; }
StringBuilder sb = new StringBuilder () ;
for ( CharSequence searchCharSequence : searchCharSequences ) { if ( contains ( cs , searchCharSequence ) ) { return true ; } }
{ for ( CharSequence next : searchStrings ) { if ( equalsIgnoreCase ( string , next ) ) { return true ; } } }
{ for ( CharSequence next : searchStrings ) { if ( equals ( string , next ) ) { return true ; } } }
{ try { return System . getProperty ( key ) ; } catch ( SecurityException scex ) {} }
int [] clonedIndices = clone ( indices ) ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
short aux = array [ offset1 ] ;
Object aux = array [ offset1 ] ;
long aux = array [ offset1 ] ;
int aux = array [ offset1 ] ;
float aux = array [ offset1 ] ;
double aux = array [ offset1 ] ;
char aux = array [ offset1 ] ;
byte aux = array [ offset1 ] ;
boolean aux = array [ offset1 ] ;
{ StopWatch sw = new StopWatch () ; sw . start () ; return sw ; }
Pattern patternToWrapOn = Pattern . compile ( wrapOn ) ;
TimeZone utc = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
{ double balance = NUMBER_CONSTANT ; for ( Transaction tx : transactions ) { balance += tx.amount ; } return balance ; }
Calendar calendar = Calendar . getInstance () ;
DateParser parser = getInstance ( YMD_SLASH ) ;
Calendar cal = Calendar . getInstance ( tz ) ;
{ byte last = value ; this . value += operand . byteValue () ; return last ; }
{ byte last = value ; this . value += operand ; return last ; }
{ byte last = value ; value -- ; return last ; }
{ byte last = value ; value ++ ; return last ; }
{ double last = value ; this . value += operand . doubleValue () ; return last ; }
{ double last = value ; this . value += operand ; return last ; }
{ double last = value ; value -- ; return last ; }
{ double last = value ; value ++ ; return last ; }
Diff < > diff
methodName . equals ( method . getName () ) && ArrayUtils . isEquals ( parameterTypes , method . getParameterTypes () )
Memoizer < Integer , Integer > memoizer = new Memoizer < Integer , Integer > ( computable ) ;
Memoizer < Integer , Integer > memoizer = new Memoizer < Integer , Integer > ( computable ) ;
Memoizer < Integer , Integer > memoizer = new Memoizer < Integer , Integer > ( computable ) ;
if ( ! isEquals ) return this ;
final StrategyParser fm = new StrategyParser ( pattern , definingCalendar ) ;
public void setCycle ( TestRecursiveCycleObject cycle ) { this . cycle = cycle ; }
public TestRecursiveCycleObject ( int n ) { this . n = n ; this . cycle = this ; }
public TestRecursiveInnerObject ( int n ) { this . n = n ; }
int offset
boolean testRecursive
String . . . excludeFields
Class < > reflectUpToClass
boolean testRecursive
boolean testTransients
final Locale [] availableLocales = ChoiceFormat . getAvailableLocales () ;
{ mRule . appendTo ( buffer , CalendarReflection . getWeekYear ( calendar ) ) ; }
if ( b . compareTo ( BigDecimal . valueOf ( d ) ) == NUMBER_CONSTANT ) { return d ; }
{ spaceToWrapAt = matcher . start () ; }
@ SuppressWarnings ( STRING_CONSTANT ) final String [] sa = ArrayUtils . add ( stringArray , NUMBER_CONSTANT , aString ) ;
final T . . . array
assertPatternsEqual ( STRING_CONSTANT + locale , expectedPattern , emf . toPattern () ) ;
assertPatternsEqual ( STRING_CONSTANT , pattern , emf . toPattern () ) ;
{ assertEquals ( baseStr + STRING_CONSTANT + SystemUtils.LINE_SEPARATOR + STRING_CONSTANT , new ToStringBuilder ( base ) . toString () ) ; }
{ if ( newLine == null ) { append ( SystemUtils.LINE_SEPARATOR ) ; return this ; } return append ( newLine ) ; }
final String linebreak = SystemUtils.LINE_SEPARATOR ;
final String linebreak = SystemUtils.LINE_SEPARATOR ;
final String systemNewLine = SystemUtils.LINE_SEPARATOR ;
final String systemNewLine = SystemUtils.LINE_SEPARATOR ;
if ( newLineStr == null ) { newLineStr = SystemUtils.LINE_SEPARATOR ; }
{ if ( fieldName == null ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; } super . appendFieldStart ( buffer , FIELD_NAME_PREFIX + fieldName + FIELD_NAME_PREFIX ) ; }
assertFalse ( CharUtils . isAscii ( CHAR_COPY ) ) ;
final GenericDeclaration d = ( ( TypeVariable < > ) var ) . getGenericDeclaration () ;
{ DateUtils . isSameLocalTime ( Calendar . getInstance () , ( Calendar ) null ) ; }
{ DateUtils . isSameLocalTime ( ( Calendar ) null , Calendar . getInstance () ) ; }
{ DateUtils . isSameInstant ( Calendar . getInstance () , ( Calendar ) null ) ; }
{ DateUtils . isSameInstant ( ( Calendar ) null , Calendar . getInstance () ) ; }
{ DateUtils . isSameInstant ( new Date () , ( Date ) null ) ; }
{ DateUtils . isSameInstant ( ( Date ) null , new Date () ) ; }
{ DateUtils . isSameDay ( Calendar . getInstance () , ( Calendar ) null ) ; }
{ DateUtils . isSameDay ( ( Calendar ) null , Calendar . getInstance () ) ; }
{ DateUtils . isSameDay ( new Date () , ( Date ) null ) ; }
{ DateUtils . isSameDay ( ( Date ) null , new Date () ) ; }
assertNull ( LocaleUtils . toLocale ( ( String ) null ) ) ;
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( ( float ) NUMBER_CONSTANT ) . toHashCode () ) ;
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( ( double ) NUMBER_CONSTANT ) . toHashCode () ) ;
assertEquals ( BAR , ObjectUtils . toString ( ( Object ) null , BAR ) ) ;
assertEquals ( STRING_CONSTANT , ObjectUtils . toString ( ( Object ) null ) ) ;
intRange = Range . between ( ( int ) NUMBER_CONSTANT , ( int ) NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , BooleanUtils . toString ( ( Boolean ) null , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEquals ( null , BooleanUtils . toStringYesNo ( ( Boolean ) null ) ) ;
assertEquals ( null , BooleanUtils . toStringOnOff ( ( Boolean ) null ) ) ;
assertEquals ( null , BooleanUtils . toStringTrueFalse ( ( Boolean ) null ) ) ;
assertEquals ( null , BooleanUtils . toIntegerObject ( ( Boolean ) null ) ) ;
assertTrue ( BooleanUtils . isNotFalse ( ( Boolean ) null ) ) ;
assertFalse ( BooleanUtils . isFalse ( ( Boolean ) null ) ) ;
assertTrue ( BooleanUtils . isNotTrue ( ( Boolean ) null ) ) ;
assertFalse ( BooleanUtils . isTrue ( ( Boolean ) null ) ) ;
assertEquals ( STRING_CONSTANT , ClassUtils . getSimpleName ( ( Class < > ) null ) ) ;
final MutableInt mutNum = new MutableInt ( ( int ) NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( ( int ) NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( ( int ) NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( ( int ) NUMBER_CONSTANT ) ;
assertSame ( StrMatcher . noneMatcher () , StrMatcher . stringMatcher ( ( String ) null ) ) ;
array = ArrayUtils . removeElement ( ( boolean [] ) null , true ) ;
array = ArrayUtils . removeElement ( ( Object [] ) null , STRING_CONSTANT ) ;
sb . replace ( NUMBER_CONSTANT , NUMBER_CONSTANT , ( String ) null ) ;
sb . setNullText ( ( String ) null ) ;
sb . setNewLineText ( ( String ) null ) ;
final StrBuilder sb5 = new StrBuilder ( ( String ) null ) ;
assertSame ( ( ( ExceptionWithCause ) cyclicCause . getCause () ) . getCause () , throwables . get ( NUMBER_CONSTANT ) ) ;
assertSame ( ( ( ExceptionWithCause ) cyclicCause . getCause () ) . getCause () , throwables [ NUMBER_CONSTANT ] ) ;
assertSame ( ( ( ExceptionWithCause ) cyclicCause . getCause () ) . getCause () , ExceptionUtils . getRootCause ( cyclicCause ) ) ;
{ if ( value <= start || value >= end ) { throw new IllegalArgumentException ( String . format ( message ) ) ; } }
{ if ( value <= start || value >= end ) { throw new IllegalArgumentException ( String . format ( message ) ) ; } }
{ if ( value < start || value > end ) { throw new IllegalArgumentException ( String . format ( message ) ) ; } }
{ if ( value < start || value > end ) { throw new IllegalArgumentException ( String . format ( message ) ) ; } }
final MutableLong mutNum = new MutableLong ( ( long ) NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( ( long ) NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( ( long ) NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( ( long ) NUMBER_CONSTANT ) ;
longRange = Range . between ( ( long ) NUMBER_CONSTANT , ( long ) NUMBER_CONSTANT ) ;
{ Assert . assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , NUMBER_CONSTANT ) ) ; }
{ Assert . assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , - NUMBER_CONSTANT ) ) ; }
return parseLocale ( str , len ) ;
classes . add ( cls ) ;
assertTrue ( trace . indexOf ( TEST_MESSAGE ) >= NUMBER_CONSTANT ) ;
assertTrue ( trace . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ;
assertTrue ( trace . indexOf ( TEST_MESSAGE ) >= NUMBER_CONSTANT ) ;
assertTrue ( trace . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ;
assertTrue ( ! stackTrace . contains ( ExceptionUtils.WRAPPED_MARKER ) ) ;
assertTrue ( ! stackTrace . contains ( ExceptionUtils.WRAPPED_MARKER ) ) ;
assertTrue ( ! contextMessage . contains ( TEST_MESSAGE ) ) ;
final HashSet < Integer > toRemove = new HashSet < Integer > () ;
super . appendDetail ( buffer , fieldName , array ) ;
final List < Object > list = new ArrayList <> () ;
public static String getFieldName () { return STRING_CONSTANT ; }
public SelfInstanceTwoVarsReflectionTestFixture () { this . typeIsSelf = this ; }
public SelfInstanceVarReflectionTestFixture () { this . typeIsSelf = this ; }
public TestSubObject () { super ( NUMBER_CONSTANT ) ; }
assertSame ( StrMatcher . noneMatcher () , StrMatcher . charSetMatcher ( new char [ NUMBER_CONSTANT ] ) ) ;
{ Validate . noNullElements ( values ) ; return generateBitVector ( enumClass , Arrays . < E > asList ( values ) ) ; }
{ return TypeUtils . < T > wrap ( ( Type ) type ) ; }
if ( typeArguments == null ) { typeArguments = Collections . < TypeVariable < > , Type > emptyMap () ; }
assertTrue ( StringUtils . containsOnly ( str , new char [] { CHAR_CONS } ) ) ;
assertTrue ( StringUtils . containsOnly ( str , new char [] { CHAR_CONS } ) ) ;
assertTrue ( StringUtils . containsOnly ( str , new char [] { CHAR_CONS } ) ) ;
assertNull ( ObjectUtils . firstNonNull ( new Object [ NUMBER_CONSTANT ] ) ) ;
public void event2 ( PropertyChangeEvent e ) ;
public void event1 ( PropertyChangeEvent e ) ;
public TestSubObject () { super ( NUMBER_CONSTANT ) ; }
{ Validate . isTrue ( objectData != null , STRING_CONSTANT ) ; return SerializationUtils . < T > deserialize ( new ByteArrayInputStream ( objectData ) ) ; }
final List < String > strColl = Arrays . asList ( new String [] { STRING_CONSTANT } ) ;
final List < String > strColl = Arrays . asList ( new String [] { STRING_CONSTANT } ) ;
public TestEmptySubObject ( final int a ) { super ( a ) ; }
public TestSubObject () { super ( NUMBER_CONSTANT ) ; }
public BackgroundInitializerTestImpl () { super(); }
@ SuppressWarnings ( STRING_CONSTANT ) public NestableException () { super(); }
{ return options == null ? false : options . contains ( option ) ; }
final List < Object > list = new ArrayList <> ( NUMBER_CONSTANT ) ;
final List < Object > list = new ArrayList <> ( arraylistInitialCapacity ) ;
final List < Object > list = new ArrayList <> () ;
if ( isEmpty ( str ) || wrapChar == CHAR_CONS ) { return str ; }
if ( isEmpty ( str ) || wrapWith == CHAR_CONS ) { return str ; }
{ if ( isEmpty ( str ) || wrapWith == CHAR_CONS ) { return str ; } return wrapWith + str + wrapWith ; }
for ( int i = oldEnd ; i < newEnd ; i ++ ) { buffer [ i ] = CHAR_CONS ; }
assertNull ( StringUtils . unwrap ( null , CHAR_CONS ) ) ;
{ return ObjectUtils . equals ( object1 , object2 ) == false ; }
if ( obj instanceof TypeLiteral == false ) { return false ; }
public boolean isFalse () { return value == false ; }
public boolean isTrue () { return value == true ; }
{ if ( expression == false ) { throw new IllegalStateException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( DEFAULT_IS_TRUE_EX_MESSAGE ) ; } }
if ( obj instanceof FastDateFormat == false ) { return false ; }
if ( obj instanceof Fraction == false ) { return false ; }
if ( obj instanceof FastDatePrinter == false ) { return false ; }
if ( toClass . isPrimitive () == false ) { return false ; }
{ if ( isAsciiNumeric ( ch ) == false ) { return defaultValue ; } return ch - NUMBER_CONSTANT ; }
if ( obj instanceof CharSet == false ) { return false ; }
final I arg
final Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeft () , pair . getRight () ) ;
if ( hasNext == false ) { throw new NoSuchElementException () ; }
if ( obj instanceof CharRange == false ) { return false ; }
try { CharUtils . toIntValue ( CHAR_CONS ) ; } catch ( final IllegalArgumentException ex ) {}
if ( tzId . equalsIgnoreCase ( STRING_CONSTANT ) ) { continue; }
{ cal . setTimeZone ( TimeZone . getTimeZone ( STRING_CONSTANT + value ) ) ; }
{ cal . setTimeZone ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
{ return toAppendTo . append ( ( ( String ) obj ) . toUpperCase () ) ; }
expected . append ( args [ NUMBER_CONSTANT ] . toString () . toUpperCase () ) ;
assertFalse ( StringUtils . equalsAny ( FOO , FOO . toUpperCase () ) ) ;
{ return toAppendTo . append ( ( ( String ) obj ) . toLowerCase () ) ; }
final Calendar c = Calendar . getInstance ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
final TimeZone utc = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
TimeZone . setDefault ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
final TimeZone utc = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
timeZone = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
{ final TimeZone timeZone = TimeZone . getTimeZone ( STRING_CONSTANT ) ; assertFormats ( expectedValue , pattern , timeZone , createFebruaryTestDate ( timeZone ) ) ; }
final Calendar c = Calendar . getInstance ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
final Calendar c = Calendar . getInstance ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
final Calendar c = Calendar . getInstance ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
assertEquals ( null , StringUtils . substring ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , tok . getContent () ) ;
assertEquals ( null , tokenizer . nextToken () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , ObjectUtils . identityToString ( null ) ) ;
assertEquals ( null , StringUtils . strip ( null ) ) ;
assertEquals ( null , StringUtils . trim ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringYesNo ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringOnOff ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringTrueFalse ( null ) ) ;
assertEquals ( null , BooleanUtils . toBooleanObject ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEquals ( null , BooleanUtils . toIntegerObject ( null , six , seven , null ) ) ;
assertEquals ( null , BooleanUtils . toIntegerObject ( null ) ) ;
assertEquals ( null , BooleanUtils . toBooleanObject ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
assertEquals ( null , BooleanUtils . toBooleanObject ( ( Integer ) null ) ) ;
assertEquals ( null , StringEscapeUtils . unescapeJson ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeJson ( null ) ) ;
assertEquals ( null , StringEscapeUtils . unescapeCsv ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeCsv ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeEcmaScript ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeEcmaScript ( null ) ) ;
assertEquals ( null , StringEscapeUtils . unescapeJava ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeJava ( null ) ) ;
assertEquals ( null , new MutableObject <> () . getValue () ) ;
assertEquals ( null , StringUtils . getDigits ( null ) ) ;
assertEquals ( null , StringUtils . wrap ( null , null ) ) ;
assertEquals ( null , StringUtils . rotate ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , ClassUtils . getAllInterfaces ( null ) ) ;
assertEquals ( null , ClassUtils . getAllSuperclasses ( null ) ) ;
assertEquals ( null , WordUtils . swapCase ( null ) ) ;
assertEquals ( null , WordUtils . initials ( null ) ) ;
assertEquals ( null , WordUtils . uncapitalize ( null , null ) ) ;
assertEquals ( null , WordUtils . uncapitalize ( null ) ) ;
assertEquals ( null , WordUtils . capitalizeFully ( null , null ) ) ;
assertEquals ( null , WordUtils . capitalizeFully ( null ) ) ;
assertEquals ( null , WordUtils . capitalize ( null , null ) ) ;
assertEquals ( null , WordUtils . capitalize ( null ) ) ;
{ assertEquals ( null , CharUtils . unicodeEscaped ( null ) ) ; assertEquals ( STRING_CONSTANT , CharUtils . unicodeEscaped ( CHARACTER_A ) ) ; }
assertEquals ( null , CharUtils . toString ( null ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( l , Double.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( l , Float.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( l , Long.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
{ final Integer [] iArray = null ; assertEquals ( null , ArrayUtils . toPrimitive ( iArray , Integer.MIN_VALUE ) ) ; }
assertEquals ( null , ArrayUtils . toPrimitive ( l , Integer.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( s , Short.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b , Byte.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b , Character.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( null , false ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , ArrayUtils . toMap ( null ) ) ;
{ assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , NUMBER_CONSTANT ) ) ; }
{ assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , - NUMBER_CONSTANT ) ) ; }
{ Assert . assertTrue ( toString . indexOf ( SECRET_VALUE ) > NUMBER_CONSTANT ) ; this . validateNonSecretField ( toString ) ; }
{ Assert . assertEquals ( ArrayUtils.INDEX_NOT_FOUND , toString . indexOf ( SECRET_VALUE ) ) ; this . validateNonSecretField ( toString ) ; }
Assert . assertNotEquals ( summer . getTime () , standard . getTime () ) ;
Assert . assertEquals ( cal . getTime () , date ) ;
Assert . assertEquals ( value , SerializationUtils . deserialize ( serialized ) ) ;
{ watch . getStartTime () ; Assert . assertTrue ( watch . getStartTime () >= beforeStopWatch ) ; }
@ Test public void testUTC () { Assert . assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testZ () { Assert . assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testBareGmt () { Assert . assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testGetGmtTimeZone () { Assert . assertEquals ( NUMBER_CONSTANT , FastTimeZone . getGmtTimeZone () . getRawOffset () ) ; }
{ Assert . assertEquals ( REPEAT , future . get () . intValue () ) ; }
Assert . assertEquals ( STRING_CONSTANT , TypeUtils . toString ( method . getGenericReturnType () ) ) ;
Assert . assertTrue ( TypeUtils . isAssignable ( fromType , failingToType ) ) ;
Assert . assertArrayEquals ( expectedArray , TypeUtils . normalizeUpperBounds ( typeArray ) ) ;
@ Test public void testInvokeMethodForceAccessNoArgs ( ) throws Exception { Assert . assertEquals ( STRING_CONSTANT , MethodUtils . invokeMethod ( testBean , true , STRING_CONSTANT ) ) ; }
Assert . assertEquals ( expected , hostName ) ;
Assert . assertEquals ( isoForm , printer . format ( vulgar ) ) ;
Assert . assertEquals ( vulgar . getTime () , cal . getTime () ) ;
T object
{ super(); for ( String s : set ) { add ( s ) ; } }
boolean excludeNullValues
StringBuilder builder = new StringBuilder ( count ) ;
catch ( NoSuchMethodException expected ) {}
TimeZone tz = FastTimeZone . getGmtTimeZone ( timeZone ) ;
{ boolean result = RandomUtils . nextBoolean () ; assertTrue ( result == true || result == false ) ; }
Object other
@ Override public boolean inDaylightTime ( Date date ) { return false ; }
@ Override public void setRawOffset ( int offsetMillis ) { throw new UnsupportedOperationException () ; }
Class < > anInterface
ReflectionToStringBuilder oldBuilder = new ReflectionToStringBuilder ( BOTH_NULL ) ;
for ( char chr : chrs ) { if ( chars . contains ( chr ) == expect ) { buffer . append ( chr ) ; } }
String group
String group
double [] array
float [] array
long [] array
int [] array
short [] array
char [] array
byte [] array
boolean [] array
Object [] array
String . . . s
CharRange a = CharRange . is ( CHAR_CONS ) ;
CharSequence cs
String value
{ list . add ( throwable ) ; throwable = ExceptionUtils . getCause ( throwable ) ; }
assertTrue ( STRING_CONSTANT , delta < NUMBER_CONSTANT ) ;
{ return performStateCheck ( NUMBER_CONSTANT ) ; }
this . typeArguments = typeArguments . clone () ;
daemonFlag = null ;
{ daemonFlag = Boolean . valueOf ( f ) ; return this ; }
daemonFlag = builder.daemonFlag ;
public final Boolean getDaemonFlag () { return daemonFlag ; }
daemonFlag = builder.daemon ;
{ return valueAsString . startsWith ( getArrayStart () ) && valueAsString . startsWith ( getArrayEnd () ) ; }
{ return str == null ? EMPTY : str ; }
final String sanitizedSeparator = defaultString ( separator , StringUtils.EMPTY ) ;
if ( str == null || suffix == null ) { return str == null && suffix == null ; }
if ( str == null || prefix == null ) { return str == null && prefix == null ; }
{ bypassReflectionClasses = new ArrayList < Class < > > () ; bypassReflectionClasses . add ( String . class ) ; }
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
for ( Field field : allFields ) { if ( field . getName () . equals ( STRING_CONSTANT ) ) { expected ++ ; } }
for ( Field field : allFields ) { if ( field . getName () . equals ( STRING_CONSTANT ) ) { expected ++ ; } }
{ buffer . append ( CHAR_CONS ) . append ( value ) . append ( CHAR_CONS ) ; }
super . appendFieldStart ( buffer , FIELD_NAME_QUOTE + fieldName + FIELD_NAME_QUOTE ) ;
if ( ! iterator . hasNext () ) { return Objects . toString ( first , STRING_CONSTANT ) ; }
final StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
int [] indexesToRemove = new int [] {} ;
return str . length () > NUMBER_CONSTANT ;
if ( diffs . size () == NUMBER_CONSTANT ) { return OBJECTS_SAME_STRING ; }
{ return SystemUtils.IS_OS_WINDOWS ? System . getenv ( STRING_CONSTANT ) : System . getenv ( STRING_CONSTANT ) ; }
private Object readResolve () { return ToStringStyle.JSON_STYLE ; }
private Object readResolve () { return ToStringStyle.NO_CLASS_NAME_STYLE ; }
private Object readResolve () { return ToStringStyle.MULTI_LINE_STYLE ; }
private Object readResolve () { return ToStringStyle.SIMPLE_STYLE ; }
private Object readResolve () { return ToStringStyle.SHORT_PREFIX_STYLE ; }
private Object readResolve () { return ToStringStyle.NO_FIELD_NAMES_STYLE ; }
private Object readResolve () { return ToStringStyle.DEFAULT_STYLE ; }
return StrSubstitutor . replace ( source , valueMap ) ;
return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ;
{ Validate . isTrue ( objectData != null , STRING_CONSTANT ) ; return SerializationUtils . deserialize ( new ByteArrayInputStream ( objectData ) ) ; }
{ return ( T ) SerializationUtils . deserialize ( SerializationUtils . serialize ( msg ) ) ; }
Throwable root = ExceptionUtils . getRootCause ( th ) ;
final Throwable [] throwables = ExceptionUtils . getThrowables ( throwable ) ;
final int srcLength = ArrayUtils . getLength ( array ) ;
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
private Object readResolve () { return ObjectUtils.NULL ; }
{ final int tmpHash = ObjectUtils . hashCode ( object ) ; hash = hash * NUMBER_CONSTANT + tmpHash ; }
{ return ! ObjectUtils . equals ( object1 , object2 ) ; }
{ return MemberUtils . isMatchingExecutable ( Executable . of ( method ) , parameterTypes ) ; }
{ return MemberUtils . isMatchingExecutable ( Executable . of ( method ) , parameterTypes ) ; }
{ return ClassUtils . getPackageName ( getCanonicalName ( canonicalName ) ) ; }
{ return ClassUtils . getShortClassName ( getCanonicalName ( canonicalName ) ) ; }
{ return TypeUtils . wrap ( ( Type ) type ) ; }
{ Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , STRING_CONSTANT , owner , raw ) ; useOwner = owner ; }
{ parameterizedTypeArguments = new HashMap <> ( typeArguments ) ; parameterizedTypeArguments . putAll ( TypeUtils . getTypeArguments ( p ) ) ; }
Validate . notNull ( chars ) ;
Validate . notNull ( collection ) ;
Validate . notNull ( array ) ;
Validate . notNull ( iterable ) ;
Validate . notNull ( array ) ;
if ( StringUtils . isEmpty ( str ) ) { return str ; }
{ return replaceFirst ( text , regex , StringUtils.EMPTY ) ; }
return pattern . matcher ( decomposed ) . replaceAll ( StringUtils.EMPTY ) ;
{ return iValue != NUMBER_CONSTANT ? iValue + NUMBER_CONSTANT : Calendar.SUNDAY ; }
{ _mask = mask ; _shift_count = mask != NUMBER_CONSTANT ? Integer . numberOfTrailingZeros ( mask ) : NUMBER_CONSTANT ; }
mRule . appendTo ( buffer , value != Calendar.SUNDAY ? value - NUMBER_CONSTANT : NUMBER_CONSTANT ) ;
if ( lhs ) { comparison = + NUMBER_CONSTANT ; } else { comparison = - NUMBER_CONSTANT ; }
if ( rhs == null ) { comparison = + NUMBER_CONSTANT ; return this ; }
public int getLength () { return NUMBER_CONSTANT ; }
