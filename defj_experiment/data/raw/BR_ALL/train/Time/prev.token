{ super . moveDateTimeZone ( zone ) ; }
if ( sm != null ) { sm . checkPermission ( new DateTimeZonePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new DateTimeZonePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new DateTimeZonePermission ( STRING_CONSTANT ) ) ; }
{ return getField () . getAsText ( getInstant () . getMillis () , null ) ; }
DurationField getLeapDurationField ( ) ;
boolean isSupported ( ) ;
DateTime result = new DateTime ( test . resolve ( dt . getMillis () ) ) ;
{ this ( instant , null ) ; }
{ this ( DateTimeUtils . currentTimeMillis () , chronology ) ; }
public TimeOfDay () { this ( DateTimeUtils . currentTimeMillis () , null ) ; }
iInstantConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , PartialInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
return ( getMillis ( readableInstant ) < readableInstant . getMillis ( this ) ) ;
iInstantConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , PartialInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
PartialInstant instant
public abstract int getMaximumValue ( PartialInstant instant ) ;
PartialInstant instant
public abstract int getMinimumValue ( PartialInstant instant ) ;
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant partial
PartialInstant partial
PartialInstant partial
PartialInstant partial
public DateTimeField getField () { return iInstant . getField ( iFieldIndex ) ; }
{ return getField () . getMaximumValue ( getPartialInstant () ) ; }
{ return getField () . getMinimumValue ( getPartialInstant () ) ; }
{ return getField () . getAsShortText ( getPartialInstant () , get () , locale ) ; }
{ return getField () . getAsText ( getPartialInstant () , get () , locale ) ; }
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant partial
PartialInstant partial
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
public int getMaximumValue ( PartialInstant instant ) { throw unsupported () ; }
PartialInstant instant
public int getMinimumValue ( PartialInstant instant ) { throw unsupported () ; }
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant partial
PartialInstant partial
{ test1 . millisOfSecond () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . millisOfSecond () . getPartialInstant () ) ;
{ test1 . secondOfMinute () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . secondOfMinute () . getPartialInstant () ) ;
{ test1 . minuteOfHour () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . minuteOfHour () . getPartialInstant () ) ;
{ test1 . hourOfDay () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . hourOfDay () . getPartialInstant () ) ;
assertEquals ( false , test1 . equals ( MockPartialInstant.EMPTY_INSTANCE ) ) ;
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
public int getMinimumValue ( PartialInstant instant ) { return NUMBER_CONSTANT ; }
PartialInstant instant
void validate ( PartialInstant instant ) ;
public DateTimeField getField () { return iInstant . getField ( iFieldIndex ) ; }
PartialInstant instant
PartialInstant instant
{ test1 . dayOfMonth () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . dayOfMonth () . getPartialInstant () ) ;
{ test1 . monthOfYear () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . monthOfYear () . getPartialInstant () ) ;
{ test1 . year () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . year () . getPartialInstant () ) ;
assertEquals ( false , test1 . equals ( MockPartialInstant.EMPTY_INSTANCE ) ) ;
public int getMaximumValue ( PartialInstant instant , int [] values ) { return iField . getMaximumValue ( instant , values ) ; }
public int getMaximumValue ( PartialInstant instant ) { return iField . getMaximumValue ( instant ) ; }
public int getMinimumValue ( PartialInstant instant , int [] values ) { return iField . getMinimumValue ( instant , values ) ; }
public int getMinimumValue ( PartialInstant instant ) { return iField . getMinimumValue ( instant ) ; }
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
public String getAsShortText ( PartialInstant partial , Locale locale ) { return iField . getAsShortText ( partial , locale ) ; }
PartialInstant partial
public String getAsText ( PartialInstant partial , Locale locale ) { return iField . getAsText ( partial , locale ) ; }
PartialInstant partial
PartialInstant instant
{ t = new DateTimeFormatterBuilder ( iChrono ) . append ( hourMinuteSecondFraction () ) . append ( offsetElement () ) . toFormatter () ; }
iChronology = converter . getChronology ( instant , chronology ) ;
iChronology = converter . getChronology ( instant , zone ) ;
iChronology = converter . getChronology ( instant ) ;
{ return DurationType . getAverageYearMonthType () ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
public DurationField millis () { return UnsupportedDurationField.INSTANCE ; }
public DurationField seconds () { return UnsupportedDurationField.INSTANCE ; }
public DurationField minutes () { return UnsupportedDurationField.INSTANCE ; }
public DurationField hours () { return UnsupportedDurationField.INSTANCE ; }
public DurationField days () { return UnsupportedDurationField.INSTANCE ; }
public DurationField weeks () { return UnsupportedDurationField.INSTANCE ; }
public DurationField months () { return UnsupportedDurationField.INSTANCE ; }
public DurationField years () { return UnsupportedDurationField.INSTANCE ; }
boolean isSupported ( ) ;
assertSame ( test , test . dayOfMonth () . getInstant () ) ;
assertSame ( test , test . monthOfYear () . getInstant () ) ;
assertSame ( test , test . year () . getInstant () ) ;
assertSame ( test , test . yearOfCentury () . getInstant () ) ;
assertSame ( test , test . centuryOfEra () . getInstant () ) ;
assertSame ( test , test . yearOfEra () . getInstant () ) ;
assertSame ( test , test . era () . getInstant () ) ;
{ return getField () . remainder ( getInstant () . getMillis () ) ; }
{ return getField () . getMaximumValue ( getInstant () . getMillis () ) ; }
{ return getField () . getMinimumValue ( getInstant () . getMillis () ) ; }
{ return getField () . getLeapAmount ( getInstant () . getMillis () ) ; }
{ return getField () . isLeap ( getInstant () . getMillis () ) ; }
return getField () . getDifferenceAsLong ( getInstant () . getMillis () , instant . getMillis () ) ;
return getField () . getDifference ( getInstant () . getMillis () , instant . getMillis () ) ;
{ return getField () . getAsShortText ( getInstant () . getMillis () , locale ) ; }
{ return getField () . getAsText ( getInstant () . getMillis () , locale ) ; }
{ return getField () . get ( getInstant () . getMillis () ) ; }
try { iChrono . era () . addWrapped ( SMALL_MILLIS , NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
iMillis = converter . getInstantMillis ( instant , chronology ) ;
iMillis = converter . getInstantMillis ( instant , zone ) ;
iMillis = converter . getInstantMillis ( instant ) ;
{ super(); iChronology = selectChronology ( chronology ) ; iMillis = instant ; }
{ setDateTime ( instant ) ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
LongConverter.INSTANCE . setInto ( m , null ) ;
{ long instant = getChronology () . getDateTimeMillis ( getMillis () , hour , minuteOfHour , secondOfMinute , millisOfSecond ) ; setTime ( instant ) ; }
withUTC () . getTimeOnlyMillis ( iCutoverMillis ) == NUMBER_CONSTANT
return getDateOnlyMillis ( year , monthOfYear , dayOfMonth ) + millisOfDay ;
assertEquals ( false , zone5 . equals ( zone5 ) ) ;
protected DateTimeUtils () {}
private DateTimeUtils () { super(); }
public int size () { return iConverters.length ; }
assertNotSame ( set , result ) ;
catch ( Exception ex ) {}
assertEquals ( NUMBER_CONSTANT * DateTimeConstants.MILLIS_PER_DAY , test . monthOfYear () . remainder () ) ;
MutableDuration duration = new MutableDuration ( type , NUMBER_CONSTANT ) ;
public String toString () { return STRING_CONSTANT + getName () + CHAR_CONS ; }
{ if ( chrono == getChronology () ) { return this ; } return mask ( iType . withChronology ( chrono ) , iMask ) ; }
{ if ( chrono == iChronology ) { return this ; } return new YearWeekType ( iChronology ) ; }
{ if ( chrono == iChronology ) { return this ; } return new YearMonthType ( iChronology ) ; }
{ if ( chrono == iChronology ) { return this ; } return new AllType ( iChronology ) ; }
{ if ( chrono == iChronology ) { return this ; } return new DayHourType ( iChronology ) ; }
if ( isPrecise () ) { return instant += getTotalMillis () * scalar ; }
{ MutableDuration test = new MutableDuration () ; assertEquals ( DurationType . getMillisType () , test . getDurationType () ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( duration , type ) ; }
{ super ( duration , null ) ; }
assertEquals ( DurationType . getMillisType () , test . getDurationType () ) ;
assertEquals ( DurationType . getMillisType () , test . getDurationType () ) ;
{ duration = duration . withDurationType ( type ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( duration , type ) ; }
{ super ( duration , null ) ; }
{ assertEquals ( NUMBER_CONSTANT , Duration.ZERO . getTotalMillis () ) ; assertEquals ( DurationType . getMillisType () , Duration.ZERO . getDurationType () ) ; }
public YearMonthType ( Chronology chrono ) { super ( chrono ) ; }
public AllType ( Chronology chrono ) { super ( chrono ) ; }
assertEquals ( DurationType . getMillisType () , test . getDurationType () ) ;
MutableDuration test = new MutableDuration ( NUMBER_CONSTANT ) ;
public void testGetDurationType_Object ( ) throws Exception { assertEquals ( DurationType . getMillisType () , NullConverter.INSTANCE . getDurationType ( null ) ) ; }
{ convId = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return new FixedDateTimeZone ( convId , null , offset , offset ) ; }
{ id = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return new FixedDateTimeZone ( id , null , offset , offset ) ; }
assertEquals ( false , test1 . equals ( new Duration ( NUMBER_CONSTANT , DurationType . getAverageYearMonthType () ) ) ) ;
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearWeekType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearMonthType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getAllType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getDayHourType () ; }
type = ( type == null ? converter . getDurationType ( duration ) : type ) ;
assertEquals ( false , test1 . equals ( new Duration ( NUMBER_CONSTANT , DurationType . getAverageYearMonthType () ) ) ) ;
assertEquals ( type , type . withChronology ( ISOChronology . getInstanceUTC () ) ) ;
assertEquals ( null , type . getChronology () ) ;
ReadWritableDuration duration
{ return ( ( ReadableDuration ) object ) . getTotalMillis () ; }
{ return ( ( ReadableDuration ) object ) . isPrecise () ; }
MutableDuration test = new MutableDuration ( NUMBER_CONSTANT ) ;
MutableDuration test = new MutableDuration ( STRING_CONSTANT ) ;
MutableDuration test = new MutableDuration ( dt1 , dt2 ) ;
MutableDuration test = new MutableDuration ( dt1 , dt2 ) ;
MutableDuration test = new MutableDuration ( dt1 , dt2 ) ;
MutableDuration test = new MutableDuration ( dt1 , dt2 ) ;
MutableDuration test = new MutableDuration ( length , null ) ;
MutableDuration test = new MutableDuration ( length ) ;
{ try { new MutableDuration ( DurationType . getAllType () , true ) ; fail () ; } catch ( IllegalArgumentException ex ) {} }
MutableDuration test = new MutableDuration ( null , false ) ;
MutableDuration test = new MutableDuration ( null , true ) ;
MutableDuration test = new MutableDuration () ;
Duration test = new Duration ( NUMBER_CONSTANT ) ;
Duration test = new Duration ( NUMBER_CONSTANT ) ;
{ Duration test = new Duration ( NUMBER_CONSTANT ) ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
MutableDuration test = new MutableDuration ( NUMBER_CONSTANT ) ;
MutableDuration test = new MutableDuration () ;
{ MutableDuration test = new MutableDuration () ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
public void setInto ( ReadWritableDuration duration , Object object ) {}
public void setInto ( ReadWritableDuration duration , Object object ) {}
public void setInto ( ReadWritableDuration duration , Object object ) {}
c = ConverterManager . getInstance () . getDurationConverter ( new Duration ( DurationType . getMillisType () ) ) ;
Duration test = new Duration ( STRING_CONSTANT ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( length , null ) ;
Duration test = new Duration ( length ) ;
Duration test = Duration.ZERO ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
{ DurationConverter [] array = ConverterManager . getInstance () . getDurationConverters () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , m . getTotalMillis () ) ;
assertEquals ( NUMBER_CONSTANT , m . getTotalMillis () ) ;
{ add ( new TimePeriod ( duration ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () ) ) ; } }
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getYearMonthType () ) ;
DurationType type
DurationType type
{ return new TimePeriod ( toDurationMillis () , getDurationType () ) ; }
DurationType type
DurationType type
DurationType type
DurationType type
suite . addTest ( TestDurationType . suite () ) ;
{ add ( new TimePeriod ( duration , getDurationType () ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () , getDurationType () ) ) ; } }
{ if ( interval != null ) { add ( interval . toTimePeriod ( getDurationType () ) ) ; } }
final DurationType type = iType ;
DurationType type
DurationType type
DurationType type
DurationType type
int hash = getDurationType () . hashCode () ;
DurationType type = iType ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
public TestDurationType ( String name ) { super ( name ) ; }
DurationType type
DurationType type
DurationType type
DurationType type
DurationType type = period . getDurationType () ;
DurationType type
if ( ! mustParse && ! isSupported ( period . getDurationType () ) ) { return position ; }
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getMillisType () ) ;
TimePeriodConverter c = ConverterManager . getInstance () . getTimePeriodConverter ( new TimePeriod ( DurationType . getMillisType () ) ) ;
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( DurationType . getMillisType () ) ) ;
MillisDuration base = new MillisDuration ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getDayHourType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
DurationType type
DurationType type
if ( pos < NUMBER_CONSTANT ) { parser . parseMutableTimePeriod ( period . getDurationType () , str ) ; }
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getMillisType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
test . add ( new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseAllType () ) ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearWeekType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearWeekType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
assertEquals ( test . getDurationType () , copy . getDurationType () ) ;
assertEquals ( test . getDurationType () , copy . getDurationType () ) ;
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getMillisType () ) ;
ReadableTimePeriod period
ReadableTimePeriod period
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( PeriodType . getMillisType () ) ) ;
MutableTimePeriod result = test . toMutableTimePeriod () ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod () ;
{ MutableTimePeriod test = new MutableTimePeriod () ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
TimePeriod test = new TimePeriod ( STRING_CONSTANT ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( length , null ) ;
TimePeriod test = new TimePeriod ( length ) ;
TimePeriod test = new TimePeriod ( length ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
ReadableTimePeriod period
ReadableTimePeriod period
public void testSetDuration_RD () { setTimePeriod ( ( ReadableDuration ) null ) ; }
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ;
{ TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
MutableTimePeriod test = new MutableTimePeriod ( STRING_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( length , null ) ;
MutableTimePeriod test = new MutableTimePeriod ( length ) ;
MutableTimePeriod test = new MutableTimePeriod ( length ) ;
MutableTimePeriod test = new MutableTimePeriod () ;
{ return STRING_CONSTANT + iInstantConverters . size () + STRING_CONSTANT + iDurationConverters . size () + STRING_CONSTANT + iTimePeriodConverters . size () + STRING_CONSTANT + iIntervalConverters . size () + STRING_CONSTANT ; }
ReadableTimePeriod period
ReadableTimePeriod period
TimePeriod duration ;
Class cls = ReadableTimePeriodConverter . class ;
public void testSetTotalMillis_2 () { setPeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testSetTotalMillis_1 () { setPeriod ( NUMBER_CONSTANT ) ; }
public void testSetDuration_RD () { setDuration ( null ) ; }
{ if ( chrono == iChronology ) { return this ; } return PeriodType . getYearWeekType ( chrono ) ; }
{ return PRECISE_ALL_TYPE ; }
{ return PRECISE_YEAR_WEEK_TYPE ; }
{ return PRECISE_YEAR_MONTH_TYPE ; }
public static PeriodType getPreciseYearDayType () { return PRECISE_YEAR_DAY_TYPE ; }
public static PeriodType getPreciseDayHourType () { return PRECISE_DAY_HOUR_TYPE ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getUTCYearWeekType () ; }
{ return YEAR_WEEK_TYPE ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getUTCYearMonthType () ; }
{ return YEAR_MONTH_TYPE ; }
public static PeriodType getYearDayType () { return YEAR_DAY_TYPE ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getUTCAllType () ; }
{ return ALL_TYPE ; }
public static PeriodType getMillisType () { return MILLIS_TYPE ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getUTCAllType () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getUTCAllType () ) ;
public Duration ( long duration ) { super ( duration ) ; }
public AbstractDuration () { super(); }
{ long durationMillis = DateTimeUtils . getDurationMillis ( duration ) ; setStartMillis ( FieldUtils . safeAdd ( getStartMillis () , - durationMillis ) ) ; }
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
final Object duration
public Duration ( long duration ) { super(); iMillis = duration ; }
{ long endMillis = DateTimeUtils . getInstantMillis ( end ) ; setInterval ( iStartMillis , endMillis ) ; }
{ long startMillis = DateTimeUtils . getInstantMillis ( start ) ; setInterval ( startMillis , iEndMillis ) ; }
{ setInterval ( startInstant , iEndMillis ) ; }
public void normalize () { super . normalize () ; }
{ return new MutableDateTime ( this , chronology ) ; }
public MutableDateTime toMutableDateTime () { return new MutableDateTime ( this ) ; }
{ long instant = getChronology () . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; setDateTime ( instant ) ; }
{ super(); iChronology = partial.iChronology ; iValues = values ; }
{ super(); iChronology = partial.iChronology ; iValues = values ; }
{ Chronology chrono = iChronology . withZone ( zone ) ; return resolve ( baseInstant , chrono ) ; }
AbstractGJChronology chronology
AbstractGJChronology chronology
GJYearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
AbstractGJChronology chronology
AbstractGJChronology chronology
AbstractGJChronology chronology
GJMonthOfYearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
AbstractGJChronology chrono = iChronology ;
CopticYearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
AbstractGJChronology chronology
GJWeekyearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
AbstractGJChronology chronology
GJEraDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
NoWeekyearZeroField ( AbstractGJChronology chronology , DateTimeField field ) { super ( chronology , field ) ; }
AbstractGJChronology chronology
public static TestSuite suite () { return BulkTest . makeSuite ( TestParseISO . class ) ; }
public static TestSuite suite () { return BulkTest . makeSuite ( TestDateTimeConstants . class ) ; }
{ millis = getField ( i ) . set ( millis , getValue ( i ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendSuffix ( new SingularAffix ( text ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendPrefix ( new SingularAffix ( text ) ) ; }
DurationFieldAffix affix ;
DurationFieldAffix affix ;
DurationFieldAffix affix ;
DurationFieldAffix suffix
int scan ( String durationStr , int position ) ;
int parse ( String durationStr , int position ) ;
DurationFieldAffix suffix
DurationFieldAffix prefix
{ if ( iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue ( period ) >= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
public PeriodFormatterBuilder appendMillis () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithOptionalMillis () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithMillis () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendSeconds () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendMinutes () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendHours () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendDays () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendWeeks () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendMonths () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendYears () { appendField ( NUMBER_CONSTANT ) ; return this ; }
DateTimeComparator c = DateTimeComparator . getInstance ( ISO . hourOfDay () , ISO . dayOfYear () ) ;
DateTimeField lowerLimit
public static DateTimeComparator getInstance () { return INSTANCE ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
if ( iParseField == null ) { iParseField = new PreciseDateTimeField ( STRING_CONSTANT , MillisDurationField.INSTANCE , iField . getDurationField () ) ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
super ( gregorianField . getName () ) ;
public TestGJYearField ( TestGJChronology chrono ) { super ( STRING_CONSTANT , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( STRING_CONSTANT , weeks ) ; iChronology = chronology ; }
private ISOYearOfEraDateTimeField () { super ( GregorianChronology . getInstanceUTC () . year () , STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( STRING_CONSTANT , STRING_CONSTANT , chrono . millisPerMonth () , chrono ) ; }
{ super ( field , field . getName () ) ; iDurationField = durationField ; iRangeDurationField = rangeDurationField ; iLeapDurationField = leapDurationField ; }
super ( field . getName () ) ;
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( STRING_CONSTANT , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , months ) ; iChronology = chronology ; }
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
public DateTimeField era () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , eras () ) ; }
public DateTimeField centuryOfEra () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , centuries () ) ; }
public DateTimeField yearOfCentury () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , years () ) ; }
public DateTimeField yearOfEra () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , years () ) ; }
public DateTimeField year () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , years () ) ; }
public DateTimeField monthOfYear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , months () ) ; }
public DateTimeField weekyear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , weekyears () ) ; }
public DateTimeField weekOfWeekyear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , weeks () ) ; }
public DateTimeField dayOfYear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , days () ) ; }
public DateTimeField dayOfMonth () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , days () ) ; }
{ return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , days () ) ; }
{ return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ) ; }
public DateTimeField clockhourOfHalfday () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField hourOfHalfday () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField clockhourOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField hourOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField minuteOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , minutes () ) ; }
public DateTimeField minuteOfHour () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , minutes () ) ; }
public DateTimeField secondOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , seconds () ) ; }
public DateTimeField secondOfMinute () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , seconds () ) ; }
public DateTimeField millisOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , millis () ) ; }
public DateTimeField millisOfSecond () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , millis () ) ; }
{ super ( yearField , STRING_CONSTANT ) ; iChronology = chronology ; }
LinkedDurationField ( DurationField durationField , ImpreciseCutoverField dateTimeField ) { super ( durationField , durationField . getName () ) ; iField = dateTimeField ; }
{ return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . halfdayOfDay () , UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ) ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , STRING_CONSTANT , chrono.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , STRING_CONSTANT , chrono.MILLIS_PER_DAY , chrono ) ; }
public String toString () { return STRING_CONSTANT ; }
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . year () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , STRING_CONSTANT , NUMBER_CONSTANT ) ;
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , STRING_CONSTANT , chrono.MILLIS_PER_DAY , chrono ) ; }
super ( field . getName () ) ;
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , STRING_CONSTANT , NUMBER_CONSTANT ) ;
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
{ super ( chrono ) ; iMonths = new ScaledDurationField ( chrono . days () , STRING_CONSTANT , NUMBER_CONSTANT ) ; }
{ super ( chrono ) ; iYears = new ScaledDurationField ( chrono . days () , STRING_CONSTANT , NUMBER_CONSTANT ) ; }
fields.centuryOfEra = new DividedDateTimeField ( ISOYearOfEraDateTimeField.INSTANCE , DateTimeFieldType . centuryOfEra () , STRING_CONSTANT , NUMBER_CONSTANT ) ;
{ super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chrono . millisPerMonth () , chrono ) ; }
public int getFieldSize () { return NUMBER_CONSTANT ; }
int [] values = new int [ getFieldSize () ] ;
int i = NUMBER_CONSTANT , isize = getFieldSize ()
{ return getAsShortText ( partial , partial . get ( this ) , locale ) ; }
{ return getAsText ( partial , partial . get ( this ) , locale ) ; }
public int getFieldSize () { return NUMBER_CONSTANT ; }
int getFieldSize ( ) ;
partial . isSupported ( iField )
partial . isSupported ( iField )
partial . isSupported ( iField )
public int getFieldSize () { return getFields () . length ; }
public static DateTimeFieldType era () { return ERA ; }
public static DateTimeFieldType centuryOfEra () { return CENTURY_OF_ERA ; }
public static DateTimeFieldType yearOfCentury () { return YEAR_OF_CENTURY ; }
public static DateTimeFieldType yearOfEra () { return YEAR_OF_ERA ; }
public static DateTimeFieldType year () { return YEAR ; }
public static DateTimeFieldType monthOfYear () { return MONTH_OF_YEAR ; }
public static DateTimeFieldType weekyearOfCentury () { return WEEKYEAR_OF_CENTURY ; }
public static DateTimeFieldType weekyear () { return WEEKYEAR ; }
public static DateTimeFieldType weekOfWeekyear () { return WEEK_OF_WEEKYEAR ; }
public static DateTimeFieldType dayOfYear () { return DAY_OF_YEAR ; }
public static DateTimeFieldType dayOfMonth () { return DAY_OF_MONTH ; }
public static DateTimeFieldType dayOfWeek () { return DAY_OF_WEEK ; }
public static DateTimeFieldType halfdayOfDay () { return HALFDAY_OF_DAY ; }
public static DateTimeFieldType clockhourOfHalfday () { return CLOCKHOUR_OF_HALFDAY ; }
public static DateTimeFieldType hourOfHalfday () { return HOUR_OF_HALFDAY ; }
public static DateTimeFieldType clockhourOfDay () { return CLOCKHOUR_OF_DAY ; }
public static DateTimeFieldType hourOfDay () { return HOUR_OF_DAY ; }
public static DateTimeFieldType minuteOfDay () { return MINUTE_OF_DAY ; }
public static DateTimeFieldType minuteOfHour () { return MINUTE_OF_HOUR ; }
public static DateTimeFieldType secondOfDay () { return SECOND_OF_DAY ; }
public static DateTimeFieldType secondOfMinute () { return SECOND_OF_MINUTE ; }
public static DateTimeFieldType millisOfDay () { return MILLIS_OF_DAY ; }
public static DateTimeFieldType millisOfSecond () { return MILLIS_OF_SECOND ; }
int otherValue = chrono . getField ( getFieldType () ) . get ( instant . getMillis () ) ;
public static DurationFieldType eras () { return ERAS ; }
public static DurationFieldType centuries () { return CENTURIES ; }
public static DurationFieldType years () { return YEARS ; }
public static DurationFieldType months () { return MONTHS ; }
public static DurationFieldType weekyears () { return WEEKYEARS ; }
public static DurationFieldType weeks () { return WEEKS ; }
public static DurationFieldType days () { return DAYS ; }
public static DurationFieldType halfdays () { return HALFDAYS ; }
public static DurationFieldType hours () { return HOURS ; }
public static DurationFieldType minutes () { return MINUTES ; }
public static DurationFieldType seconds () { return SECONDS ; }
public static DurationFieldType millis () { return MILLIS ; }
assertEquals ( false , test . isAfter ( null ) ) ;
assertEquals ( false , test . isBefore ( null ) ) ;
assertEquals ( false , test . isAfter ( null ) ) ;
assertEquals ( false , test . isBefore ( null ) ) ;
{ if ( instant == null ) { return isAfter ( DateTimeUtils . currentTimeMillis () ) ; } return isAfter ( instant . getMillis () ) ; }
{ if ( instant == null ) { return isBefore ( DateTimeUtils . currentTimeMillis () ) ; } return isBefore ( instant . getMillis () ) ; }
{ if ( instant == null ) { return contains ( DateTimeUtils . currentTimeMillis () ) ; } return contains ( instant . getMillis () ) ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period result = test . withPeriodType ( PeriodType . getAllType () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
{ Period test = new Period ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadablePeriodConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
test = new MutablePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
{ super . setMillis ( millis ) ; }
{ super . setSeconds ( seconds ) ; }
{ super . setMinutes ( minutes ) ; }
{ super . setHours ( hours ) ; }
{ super . setDays ( days ) ; }
{ super . setWeeks ( weeks ) ; }
{ super . setMonths ( months ) ; }
{ super . setYears ( years ) ; }
{ super . setPeriod ( duration ) ; }
{ super ( period , type ) ; }
{ super ( period , null ) ; }
public MutablePeriod ( PeriodType type ) { super ( NUMBER_CONSTANT , type ) ; }
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
{ MutablePeriod test = new MutablePeriod () ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
{ super ( period , type ) ; }
{ super ( period , null ) ; }
{ if ( period != null ) { setMillis ( period . addTo ( getMillis () , scalar ) ) ; } }
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
{ test1 . year () . compareTo ( null ) ; fail () ; }
assertEquals ( PeriodType . time () , test . getPeriodType () ) ;
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setStartMillis ( period . addTo ( getEndMillis () , - NUMBER_CONSTANT , chrono ) ) ; }
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setEndMillis ( period . addTo ( getStartMillis () , NUMBER_CONSTANT , chrono ) ) ; }
{ if ( period != null ) { setMillis ( period . addTo ( getMillis () , scalar , getChronology () ) ) ; } }
assertEquals ( PeriodType . time () , test . getPeriodType () ) ;
try { test . setYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
return new Period ( new int [] { millis } , PeriodType . standard () ) ;
return new Period ( new int [] { seconds } , PeriodType . standard () ) ;
return new Period ( new int [] { minutes } , PeriodType . standard () ) ;
return new Period ( new int [] { hours } , PeriodType . standard () ) ;
return new Period ( new int [] { days } , PeriodType . standard () ) ;
return new Period ( new int [] { weeks } , PeriodType . standard () ) ;
return new Period ( new int [] { months } , PeriodType . standard () ) ;
new Period ( new int [] { years } , PeriodType . standard () )
{ duration . setPeriod ( NUMBER_CONSTANT , chrono ) ; }
iIntervalConverters = new ConverterSet ( new Converter [] { ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , } ) ;
{ super . setEndMillis ( endInstant ) ; }
{ super . setStartMillis ( startInstant ) ; }
public long getDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
{ IntervalConverter [] array = ConverterManager . getInstance () . getIntervalConverters () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
public long getDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
Instant getEndInstant ( ) ;
Instant getStartInstant ( ) ;
{ MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . getDuration () ) ; }
Interval result = test . withEndInstant ( null ) ;
{ test . withEndInstant ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withEndInstant ( new Instant ( TEST_TIME2 - NUMBER_CONSTANT ) ) ;
Interval result = test . withStartInstant ( null ) ;
{ test . withStartInstant ( new Instant ( TEST_TIME2 + NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withStartInstant ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ;
{ Interval test = new Interval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . getDuration () ) ; }
{ return ( ( ( ReadableInterval ) object ) ) . getDurationMillis () ; }
iValues = initValues ( millis , chronology ) ;
iValues = initValues ( millis , chronology ) ;
iValues = initValues ( instant , chronology ) ;
long resolved = resolve ( instantMillis , chrono ) ;
{ Chronology chrono = getChronology () . withZone ( zone ) ; return resolve ( baseInstant , chrono ) ; }
{ if ( period != null ) { setMillis ( getChronology () . add ( getMillis () , period , scalar ) ) ; } }
if ( period == null ) { iStartMillis = iEndMillis ; } else { iStartMillis = chrono . add ( iEndMillis , period , - NUMBER_CONSTANT ) ; }
if ( period == null ) { iEndMillis = iStartMillis ; } else { iEndMillis = chrono . add ( iStartMillis , period , NUMBER_CONSTANT ) ; }
long instant = getChronology () . add ( getMillis () , period , scalar ) ;
{ if ( period == null ) { setPeriodInternal ( NUMBER_CONSTANT , null ) ; } else { setPeriodInternal ( period ) ; } }
long endMillis = chrono . add ( startMillis , this , NUMBER_CONSTANT ) ;
setPeriodInternal ( startMillis , endMillis , chrono ) ;
{ setStartMillis ( getChronology () . add ( getEndMillis () , period , - NUMBER_CONSTANT ) ) ; }
{ setEndMillis ( getChronology () . add ( getStartMillis () , period , NUMBER_CONSTANT ) ) ; }
{ if ( period != null ) { addPeriod ( period ) ; } }
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
{ if ( partial == null ) { return this ; } return partial . resolveDateTime ( this ) ; }
DateTime result = test . resolveDateTime ( null ) ;
{ long millis = partial . resolve ( NUMBER_CONSTANT , DateTimeZone.UTC ) ; printTo ( null , out , millis ) ; }
long millis = partial . resolve ( NUMBER_CONSTANT , DateTimeZone.UTC ) ;
DateTime result = test . resolveDateTime ( null ) ;
{ return new Period ( getStartMillis () , getEndMillis () , type ) ; }
{ return new Period ( getStartMillis () , getEndMillis () ) ; }
{ return new MutableInterval ( getStartMillis () , getEndMillis () ) ; }
{ return new Interval ( getStartMillis () , getEndMillis () ) ; }
Interval test4 = new Interval ( TEST_TIME1 , TEST_TIME1 , Chronology . getGJ () ) ;
{ if ( endInstant == getEndMillis () ) { return this ; } return new Interval ( getStartMillis () , endInstant ) ; }
{ if ( startInstant == getStartMillis () ) { return this ; } return new Interval ( startInstant , getEndMillis () ) ; }
{ test . set ( ISOChronology . getInstance () . monthOfYear () , NUMBER_CONSTANT ) ; fail () ; }
test . set ( ISOChronology . getInstance () . year () , NUMBER_CONSTANT ) ;
final Object f
final Object f
final Object f
public DateTimeFormatterBuilder appendEraText () { return appendText ( iChronoUTC . era () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearShortText () { return appendShortText ( iChronoUTC . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearText () { return appendText ( iChronoUTC . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekShortText () { return appendShortText ( iChronoUTC . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekText () { return appendText ( iChronoUTC . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendHalfdayOfDayText () { return appendText ( iChronoUTC . halfdayOfDay () ) ; }
final String text
final char c
final Object element
final DateTimeParser parser
final DateTimeParser parser
final DateTimePrinter printer
final DateTimeFormatter formatter
final Chronology chrono
final DateTimeZone zone
public MutableDateTime parseMutableDateTime ( final String text ) { return mParser . parseMutableDateTime ( text ) ; }
public DateTime parseDateTime ( final String text ) { return mParser . parseDateTime ( text ) ; }
public long parseMillis ( final String text ) { return mParser . parseMillis ( text ) ; }
public String print ( final long instant ) { throw unsupported () ; }
public String print ( final ReadableInstant instant ) { throw unsupported () ; }
FParser ( final DateTimeParser parser ) { super(); mParser = parser ; }
public MutableDateTime parseMutableDateTime ( final String text ) { throw unsupported () ; }
public DateTime parseDateTime ( final String text ) { throw unsupported () ; }
public long parseMillis ( final String text ) { throw unsupported () ; }
public String print ( final long instant ) { return mPrinter . print ( instant ) ; }
public String print ( final ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
FPrinter ( final DateTimePrinter printer ) { super(); mPrinter = printer ; }
iMillis = converter . getInstantMillis ( instant ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getInstantConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
{ PartialConverter [] array = ConverterManager . getInstance () . getPartialConverters () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
iPartialConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
throw new IllegalStateException () ;
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , null ) ; }
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , null ) ; }
throw new IllegalStateException () ;
try { MillisDurationField.INSTANCE . getDifferenceAsLong ( Long.MAX_VALUE , NUMBER_CONSTANT ) ; fail () ; } catch ( ArithmeticException ex ) {}
{ return value * getUnitMillis () ; }
{ return value * iUnitMillis ; }
BaseDateTimeField field = new MockBaseDateTimeField () ;
BaseDateTimeField field = new MockPreciseDateTimeField () ;
DateTimeParser dateTimeParser = ISODateTimeFormat . getInstance () . dateTimeParser () ;
{ assertEquals ( PARIS , DateTimeUtils . getZone ( PARIS ) ) ; assertEquals ( LONDON , DateTimeUtils . getZone ( null ) ) ; }
return offsetFormatter () . print ( instant , this ) ;
return offsetFormatter () . print ( instant , this ) ;
{ convId = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return fixedOffsetZone ( convId , offset ) ; }
PeriodParser [] parsers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
Separator finish ( PeriodFormatter after ) { iAfter = after ; return this ; }
PeriodFormatter before
PeriodFormatter composite = createComposite ( formatters ) ;
DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder ( iChrono , iLocale ) ;
DateTimeParser p = ISODateTimeFormat . getInstance ( getLenientISOChronology () ) . hourMinuteSecondFraction () ;
return DateTimeFormat . getInstance ( getChronology () , locale ) . forPattern ( pattern ) . print ( this ) ;
return DateTimeFormat . getInstance ( getChronology () ) . forPattern ( pattern ) . print ( this ) ;
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono ) ;
DateTimeParserBucket bucket = new DateTimeParserBucket ( NUMBER_CONSTANT , chrono ) ;
DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono ) ;
{ if ( permission instanceof JodaTimePermission ) { return false ; } return super . implies ( domain , permission ) ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return super . implies ( domain , permission ) ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return super . implies ( domain , permission ) ; }
iFieldType >= NUMBER_CONSTANT
{ return appendSeparator ( text , finalText , true , true ) ; }
{ return appendSeparator ( text , text , true , true ) ; }
int offset = - ( int ) offsetFormatter () . parseMillis ( convId ) ;
int offset = - ( int ) offsetFormatter () . parseMillis ( id ) ;
int itimeStyle = selectStyle ( dateStyle ) ;
DateTimeField field = iFieldType . getField ( chrono ) ;
return printTimeZone ( getOffset ( instant ) ) ;
return printTimeZone ( getOffset ( instant ) ) ;
String id = printTimeZone ( offset ) ;
return new MutableDateTime ( parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new MutableDateTime ( parseMillis ( text , chrono ) , chrono ) ; }
return new DateTime ( parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new DateTime ( parseMillis ( text , chrono ) , chrono ) ; }
return print ( millis , chrono ) ;
printTo ( out , millis , chrono ) ;
printTo ( buf , millis , chrono ) ;
public MutableDateTime parseMutableDateTime ( String text , ReadableInstant instant ) { return mParser . parseMutableDateTime ( text , instant ) ; }
public MutableDateTime parseMutableDateTime ( String text , Chronology chrono ) { return mParser . parseMutableDateTime ( text , chrono ) ; }
public DateTime parseDateTime ( String text , ReadableInstant instant ) { return mParser . parseDateTime ( text , instant ) ; }
public DateTime parseDateTime ( String text , Chronology chrono ) { return mParser . parseDateTime ( text , chrono ) ; }
{ return mParser . parseMillis ( text , instant , chrono ) ; }
{ return mParser . parseInto ( instant , text , position ) ; }
public String print ( long instant , Chronology chrono ) { return mPrinter . print ( instant , chrono ) ; }
public String print ( long instant , DateTimeZone zone ) { return mPrinter . print ( instant , zone ) ; }
{ mPrinter . printTo ( out , instant , chrono ) ; }
{ mPrinter . printTo ( buf , instant , chrono ) ; }
{ mPrinter . printTo ( out , instant , zone ) ; }
{ mPrinter . printTo ( buf , instant , zone ) ; }
public void printTo ( Writer out , long instant ) throws IOException { mPrinter . printTo ( out , instant ) ; }
{ mPrinter . printTo ( out , instant ) ; }
protected int estimateParsedLength () { return iParsedLengthEstimate ; }
protected int estimateParsedLength () { return iParsedLengthEstimate ; }
BaseDateTimeFormatter [] elements = iPrinters ;
BaseDateTimeFormatter [] elements = iPrinters ;
protected int estimatePrintedLength () { return iPrintedLengthEstimate ; }
BaseDateTimeFormatter [] printers
protected int estimatePrintedLength () { return iShortFormat ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
protected int estimateParsedLength () { return estimatePrintedLength () ; }
protected int estimateParsedLength () { return iMaxDigits ; }
protected int estimatePrintedLength () { return iMaxDigits ; }
protected int estimateParsedLength () { return estimatePrintedLength () ; }
protected int estimatePrintedLength () { return iShort ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
protected int estimatePrintedLength () { return NUMBER_CONSTANT ; }
protected int estimateParsedLength () { return NUMBER_CONSTANT ; }
protected int estimatePrintedLength () { return iMaxParsedDigits ; }
protected int estimatePrintedLength () { return iMaxParsedDigits ; }
protected int estimateParsedLength () { return iMaxParsedDigits ; }
ParseBucket bucket
protected int estimateParsedLength () { return NUMBER_CONSTANT ; }
BasePeriodFormatter [] parsers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
Separator finish ( BasePeriodFormatter after ) { iAfter = after ; return this ; }
BasePeriodFormatter before
BasePeriodFormatter composite = createComposite ( formatters ) ;
{ return getField () . remainder ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMaximumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMinimumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getLeapAmount ( getReadableInstant () . getMillis () ) ; }
{ return getField () . isLeap ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getAsShortText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . getAsText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . get ( getReadableInstant () . getMillis () ) ; }
if ( value == NUMBER_CONSTANT ) { return this ; }
fields.era = BuddhistEraDateTimeField.INSTANCE ;
{ zone = DateTimeZone . getInstance ( cal . getTimeZone () ) ; }
DateTimeZone . setDefault ( DateTimeZone . getInstance ( STRING_CONSTANT ) ) ;
iChronology = ISOChronology . getInstance ( DateTimeZone . getInstance ( id ) ) ;
zones [ i ++ ] = new ZoneData ( id , DateTimeZone . getInstance ( id ) ) ;
z = DateTimeZone . getInstance ( str ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
{ DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , zone . getID () ) ; }
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , chrono.MILLIS_PER_DAY , chrono ) ; }
int dayOfWeek = ( int ) iChronology . mod ( iChronology . fixedFromMillis ( millis ) , NUMBER_CONSTANT ) ;
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , chrono.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , chrono.MILLIS_PER_DAY , chrono ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance ( locale ) . forPattern ( pattern ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance () . forPattern ( pattern ) . print ( this ) ; }
return - ( int ) offsetFormatter () . parseMillis ( str , chrono ) ;
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance ( locale ) . forPattern ( pattern ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance () . forPattern ( pattern ) . print ( this ) ; }
return cOffsetFormatter . print ( millis , iZone ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
parse ( ISODateTimeFormat . getInstance () . dateTimeParser () ) ;
DateTimeParser p
DateTimeFormatter [] printers
{ return append0 ( new TimeZoneOffsetFormatter ( zeroOffsetText , showSeparators , minFields , maxFields ) ) ; }
{ return append0 ( new TimeZonePrinter ( iLocale , true ) , null ) ; }
{ return append0 ( new TimeZonePrinter ( iLocale , false ) , null ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , iLocale , true ) ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , iLocale , false ) ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter ) ; }
DateTimeParser p = ISODateTimeFormat . getInstance () . hourMinuteSecondFraction () ;
try { g . parseMutableDateTime ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { g . parseDateTime ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
bucket . saveField ( DateTimeFieldType . year () , year ) ;
iFormatters . add ( field ) ;
iFormatters . add ( literal ) ;
iFormatters . add ( formatter ) ;
PeriodFormatter formatter = toFormatter ( iFormatters ) ;
public PeriodParser toParser () { return toFormatter () ; }
public PeriodPrinter toPrinter () { return toFormatter () ; }
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
f = ISOPeriodFormat . getInstance () . standard () ;
{ return ISOPeriodFormat . getInstance () . standard () . print ( this ) ; }
PeriodFormatter periodParser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
InputStream in = new StringBufferInputStream ( data ) ;
PeriodFormatter parser = PeriodFormat . getInstance () . getDefault () ;
Locale iLocale
Locale iLocale
Locale iLocale
Locale iLocale
fields.year = new GJYearDateTimeField ( this ) ;
fields.year = new CopticYearDateTimeField ( this ) ;
fields.year = new BasicYearDateTimeField ( this ) ;
fields.year = new BasicYearDateTimeField ( this ) ;
{ if ( iZone == zone ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , false , iChrono , zone ) ; }
{ if ( iChrono == chrono ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , iOffsetParsed , chrono , iZone ) ; }
{ if ( iOffsetParsed == true ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , true , iChrono , null ) ; }
return new DateTimeFormatter ( iPrinter , iParser , locale , iOffsetParsed , iChrono , iZone ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
{ return append0 ( new TwoDigitYear ( DateTimeFieldType . weekyear () , pivot ) ) ; }
{ return append0 ( new TwoDigitYear ( DateTimeFieldType . year () , pivot ) ) ; }
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalArgumentException ( STRING_CONSTANT + text ) ; } return instant ; }
catch ( NumberFormatException ex ) { throw new IllegalArgumentException ( STRING_CONSTANT + getName () + STRING_CONSTANT + text ) ; }
FieldUtils . verifyValueBounds ( STRING_CONSTANT , millisOfDay , NUMBER_CONSTANT , DateTimeConstants.MILLIS_PER_DAY ) ;
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalArgumentException ( STRING_CONSTANT + text ) ; } return instant ; }
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
suite . addTest ( TestSerialization . suite () ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
public final int getMinimumDaysInFirstWeek () { return iMinDaysInFirstWeek ; }
DateTimeZone test = PARIS ;
private DateTimeFormat () { super(); }
private PeriodFormat () {}
private ISOPeriodFormat () {}
cfg . setProperty ( STRING_CONSTANT , STRING_CONSTANT ) ;
fields.era = ThaiBuddhistEraDateTimeField.INSTANCE ;
Period test = new Period ( length , PeriodType . standard () , Chronology . getISOUTC () ) ;
Period test = new Period ( length , PeriodType . time () . withMillisRemoved () , Chronology . getISO () ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( Chronology . getISO () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == Chronology . getISO () . minutes () . hashCode () ) ;
assertEquals ( false , iField . equals ( Chronology . getISO () . minutes () ) ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
Chronology chrono = Chronology . getGJUTC () ;
assertEquals ( - NUMBER_CONSTANT , MillisDurationField.INSTANCE . compareTo ( Chronology . getISO () . seconds () ) ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( Chronology . getISO () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == Chronology . getISO () . minutes () . hashCode () ) ;
assertEquals ( false , iField . equals ( Chronology . getISO () . minutes () ) ) ;
{ FieldUtils . verifyValueBounds ( Chronology . getISO () . monthOfYear () , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail () ; }
Chronology chrono = Chronology . getISO ( ZONES [ i ] ) ;
Chronology chrono = Chronology . getISO ( ZONES [ i ] ) ;
Chronology chrono = Chronology . getGregorian () ;
actual = ReadablePartialConverter.INSTANCE . getPartialValues ( tod , new TimeOfDay ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , Chronology . getISO ( PARIS ) )
int [] actual = NullConverter.INSTANCE . getPartialValues ( tod , null , Chronology . getISO () ) ;
assertEquals ( new Interval ( TEST_TIME1 , TEST_TIME2 , Chronology . getISO () ) , test ) ;
test . add ( ms , Chronology . getISOUTC () ) ;
test . add ( ms , Chronology . getISO () ) ;
test . add ( NUMBER_CONSTANT , Chronology . getISO () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
try { type . getField ( Chronology . getCopticUTC () ) ; fail () ; } catch ( InternalError ex ) {}
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
int [] actual = StringConverter.INSTANCE . getPartialValues ( tod , STRING_CONSTANT , Chronology . getISO () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
try { type . getField ( Chronology . getCopticUTC () ) ; fail () ; } catch ( InternalError ex ) {}
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , Chronology . getISOUTC () ) ;
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , Chronology . getISO () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . standard () , Chronology . getISOUTC () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . time () . withMillisRemoved () , Chronology . getISO () ) ;
ReadableIntervalConverter.INSTANCE . setInto ( m , i , Chronology . getCoptic () ) ;
{ super ( Chronology . getISO ( zone ) ) ; }
public Chronology getChronology () { return Chronology . getISOUTC () ; }
iMillis = converter . getInstantMillis ( instant , Chronology . getISOUTC () ) ;
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = Chronology . getISO () ; }
{ return Chronology . getISO ( zone ) ; }
{ super ( Chronology . getISO ( zone ) ) ; }
this . iZone = zone ;
this . iZone = zone ;
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiplyToInt ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiplyToInt ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . addWrapPartial ( this , index , newValues , FieldUtils . safeMultiplyToInt ( period . getValue ( i ) , scalar ) ) ; }
if ( dt == null ) { System.out . println ( STRING_CONSTANT ) ; }
if ( dt == null ) { System.out . println ( STRING_CONSTANT ) ; }
cal . setTime ( toDate () ) ;
cal . setTime ( toDate () ) ;
{ out . write ( print ( instant , displayZone , locale ) ) ; }
{ buf . append ( print ( instant , displayZone , locale ) ) ; }
{ return ChronologyType . iso () . getChronology ( zone ) ; }
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = ChronologyType . iso () . getChronology () ; }
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
{ return ChronologyType . iso () . getChronology ( zone ) ; }
public Chronology getChronology () { return ChronologyType . iso () . getChronologyUTC () ; }
iMillis = converter . getInstantMillis ( instant , ChronologyType . iso () . getChronologyUTC () ) ;
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
return NUMBER_CONSTANT ;
return NUMBER_CONSTANT ;
FieldUtils . verifyValueBounds ( this , month , MIN , MAX ) ;
long difference = ( minuendYear - subtrahendYear ) * NUMBER_CONSTANT + minuendMonth - subtrahendMonth ;
{ return set ( instant , FieldUtils . getWrappedValue ( get ( instant ) , months , MIN , MAX ) ) ; }
assertEquals ( true , EthiopicChronology . getInstanceUTC () . months () . isPrecise () ) ;
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * DateTimeConstants.MILLIS_PER_DAY ; return new TestSuite ( TestEthiopicChronology . class ) ; }
assertEquals ( true , CopticChronology . getInstanceUTC () . months () . isPrecise () ) ;
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * DateTimeConstants.MILLIS_PER_DAY ; return new TestSuite ( TestCopticChronology . class ) ; }
fields.monthOfYear = new BasicMonthOfYearDateTimeField ( this , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
fields.monthOfYear = new IslamicMonthOfYearDateTimeField ( this ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
assertEquals ( cal . get ( Calendar.HOUR_OF_DAY ) , test . getHourOfDay () ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
BaseGJChronology chronology
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( DateTimeFieldType . era () ) ; iChronology = chronology ; }
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
GJMonthOfYearDateTimeField ( BaseGJChronology chronology ) { super ( chronology , NUMBER_CONSTANT ) ; }
BaseGJChronology chronology
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
{ int len = parser . estimateParsedLength () ; if ( len > est ) { len = est ; } }
long instant = chronology . getDateTimeMillis ( hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
LocalTime test = LocalTime . forInstant ( ( Object ) null , JULIAN ) ;
LocalTime test = LocalTime . forInstant ( date , JULIAN ) ;
LocalTime test = LocalTime . forInstant ( TEST_TIME2 , JULIAN ) ;
LocalTime test = LocalTime . now ( JULIAN ) ;
LocalTime test = LocalTime . fromMillisOfDay ( TEST_TIME1 , JULIAN ) ;
assertEquals ( true , test . isSupported ( DurationFieldType . eras () ) ) ;
DateMidnight test = base . toDateMidnightDefaultZone () ;
DateTime test = base . toDateTimeAtCurrentTimeDefaultZone () ;
DateTime test = base . toDateTimeAtMidnightDefaultZone () ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . nowDefaultZone () ;
LocalDate test = LocalDate . nowDefaultZone () ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
public void testSize () { LocalDate test = LocalDate . nowDefaultZone () ; assertEquals ( NUMBER_CONSTANT , test . size () ) ; }
LocalDate test = LocalDate . nowDefaultZone () ;
DateTime test = base . toDateTimeTodayDefaultZone () ;
long getApproxMillisAtEpoch () { return - MILLIS_YEAR_1 ; }
long millis = bucket . computeMillis ( true ) ;
long millis = bucket . computeMillis ( true ) ;
{ if ( newPos >= text . length () ) { return bucket . computeMillis ( true ) ; } }
instant . setMillis ( bucket . computeMillis () ) ;
public long computeMillis () { return computeMillis ( false ) ; }
test = new DateMidnight ( TEST_TIME1_UTC , GregorianChronology . getInstance ( PARIS ) ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( false , test1 . equals ( new DateMidnight ( TEST_TIME1_UTC , GregorianChronology . getInstance () ) ) ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
test = new DateTime ( TEST_TIME1 , GregorianChronology . getInstance ( PARIS ) ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
long millis = converter . getInstantMillis ( instant , chronology ) ;
long millis = converter . getInstantMillis ( instant , chronology ) ;
long millis = converter . getInstantMillis ( instant , chronology ) ;
long millis = converter . getInstantMillis ( instant , chronology ) ;
{ super ( instant , DateTimeUtils . getChronology ( chronology ) ) ; }
{ super ( instant , null ) ; }
int index = dateStyle * NUMBER_CONSTANT + timeStyle ;
public LocalDateTime withMinimumValue () { return withValue ( getMinimumValue () ) ; }
{ return withValue ( getMaximumValue () ) ; }
public LocalDate withMinimumValue () { return withValue ( getMinimumValue () ) ; }
{ return withValue ( getMaximumValue () ) ; }
public LocalTime withMinimumValue () { return withValue ( getMinimumValue () ) ; }
public LocalTime withMaximumValue () { return withValue ( getMaximumValue () ) ; }
LocalDateTime copy = test . millisOfSecond () . withValue ( STRING_CONSTANT ) ;
LocalDateTime copy = test . secondOfMinute () . withValue ( STRING_CONSTANT ) ;
LocalDateTime copy = test . minuteOfHour () . withValue ( STRING_CONSTANT ) ;
LocalDateTime copy = test . hourOfDay () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . millisOfSecond () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . secondOfMinute () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . minuteOfHour () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . hourOfDay () . withValue ( STRING_CONSTANT ) ;
assertEquals ( true , interval33 . contains ( new Instant ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( true , interval33 . containsNow () ) ;
assertEquals ( true , interval33 . contains ( NUMBER_CONSTANT ) ) ;
return ( getChronology () == other . getChronology () ) ;
public synchronized Set getAvailableIDs () { return Collections . unmodifiableSet ( iZoneInfoMap . keySet () ) ; }
if ( value >= min && value < getMaximumValue ( instant ) ) { return super . set ( instant , value ) ; }
DateTimeZone tz = builder . toDateTimeZone ( STRING_CONSTANT ) ;
builder . writeTo ( out ) ;
super ( createMessage ( fieldName , value , lowerBound , upperBound ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound ) ) ;
try { test . minusYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { test . plusYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { test . withYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
{ checkPrinter () ; printTo ( out , instant , null ) ; }
{ checkPrinter () ; printTo ( buf , instant , null ) ; }
DateTime now = new DateTime () ;
offsetLocal < NUMBER_CONSTANT
{ t = new DateTimeFormatterBuilder () . append ( hourMinuteSecondMillis () ) . append ( offsetElement () ) . toFormatter () ; }
DateTime start = base . toDateTimeAtMidnight ( LONDON ) ;
DateTime start = base . toDateTimeAtMidnight ( TOKYO ) ;
DateTime start = base . toDateTimeAtMidnight () ;
DateFormatSymbols dfs = new DateFormatSymbols ( locale ) ;
String [] [] zoneStrings = new DateFormatSymbols ( locale ) . getZoneStrings () ;
throw new IllegalArgumentException ( STRING_CONSTANT + id ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + id ) ;
{ Hibernate.DATE . nullSafeSet ( preparedStatement , ( ( LocalDate ) value ) . toDateMidnight () . toDate () , index ) ; }
Object partial
Object readableInstant
Object durationField
Collection fields
Collection fields
Collection fields
Collection fields
Collection fields
List list
List elementPairs
List elementPairs
List pairs = iElementPairs ;
if ( iElementPairs == null ) { iElementPairs = new ArrayList () ; } else { iElementPairs . clear () ; }
Map ruleSets
{ iRules = new ArrayList () ; iRules . add ( rule ) ; }
public int compareTo ( Object durationField ) { return iField . compareTo ( durationField ) ; }
Class type
Class type
iRules = new ArrayList ( rs.iRules ) ;
RuleSet () { iRules = new ArrayList ( NUMBER_CONSTANT ) ; iUpperYear = Integer.MAX_VALUE ; }
Object partial
f = ( DateTimeFormatter ) cCache . get ( key ) ;
formatter = ( DateTimeFormatter ) cPatternedCache . get ( pattern ) ;
Object partial
Map zimap
iZoneInfoMap . put ( id , new SoftReference ( tz ) ) ;
public int compareTo ( Object durationField ) { return NUMBER_CONSTANT ; }
List list
public DateTimeFormatterBuilder () { super(); iElementPairs = new ArrayList () ; }
HashMap converted
HashMap converted
HashMap converted
HashMap converted
TreeMap map
TreeMap map
symbols = ( GJLocaleSymbols ) cCache . get ( locale ) ;
Object obj
chrono = ( ISOChronology ) cCache . get ( zone ) ;
try { Single . between ( start , new TimeOfDay () , zero ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
assertEquals ( STRING_CONSTANT , f . withZone ( UTC ) . print ( dt ) ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.KOREAN ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withPivotYear ( NUMBER_CONSTANT ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withPivotYear ( NUMBER_CONSTANT ) . withZone ( DateTimeZone.UTC ) ;
{ if ( ldp == null ) { ldp = dateElementParser () . withZone ( DateTimeZone.UTC ) ; } return ldp ; }
{ if ( value == null ) return null ; return new Instant ( value ) ; }
{ return ( int [] ) iValues . clone () ; }
{ return ( int [] ) iValues . clone () ; }
java.util.TimeZone . setDefault ( LONDON . toTimeZone () ) ;
Locale . setDefault ( Locale.UK ) ;
{ locale = Locale . getDefault () ; zone = DateTimeZone . getDefault () ; Locale . setDefault ( Locale.UK ) ; }
Locale . setDefault ( Locale.UK ) ;
Locale . setDefault ( Locale.UK ) ;
Locale . setDefault ( Locale.ENGLISH ) ;
java.util.TimeZone . setDefault ( LONDON . toTimeZone () ) ;
Locale . setDefault ( Locale.UK ) ;
Locale . setDefault ( Locale.UK ) ;
public YearMonth getYearMonth () { return iYearMonth ; }
protected ReadablePartial getReadablePartial () { return iYearMonth ; }
public DateTimeField getField () { return iYearMonth . getField ( iFieldIndex ) ; }
{ super(); iYearMonth = partial ; iFieldIndex = fieldIndex ; }
Map < String , Object > map = new TreeMap < String , Object > ( String.CASE_INSENSITIVE_ORDER ) ;
DateTimeZone . setDefault ( LONDON ) ;
return iBase . getZone () . convertLocalToUTC ( localInstant , false ) ;
{ super ( duration , null , null ) ; }
{ super ( duration , null , null ) ; }
Object timestamp = Hibernate.STRING . nullSafeGet ( resultSet , string ) ;
Object date = Hibernate.DATE . nullSafeGet ( resultSet , string ) ;
Object value = Hibernate.LONG . nullSafeGet ( resultSet , name ) ;
Object value = Hibernate.TIMESTAMP . nullSafeGet ( resultSet , name ) ;
Object timestamp = Hibernate.TIME . nullSafeGet ( resultSet , string ) ;
Object timestamp = Hibernate.INTEGER . nullSafeGet ( resultSet , string ) ;
Object timestamp = Hibernate.DATE . nullSafeGet ( resultSet , string ) ;
Object date = Hibernate.TIME . nullSafeGet ( resultSet , string ) ;
Object timestamp = Hibernate.TIMESTAMP . nullSafeGet ( resultSet , string ) ;
Object timestamp = Hibernate.TIMESTAMP . nullSafeGet ( resultSet , string ) ;
String s = ( String ) Hibernate.STRING . nullSafeGet ( resultSet , strings [ NUMBER_CONSTANT ] ) ;
{ if ( period != null ) { iValues = addPeriodInto ( getValues () , period ) ; } }
{ if ( period != null ) { iValues = mergePeriodInto ( getValues () , period ) ; } }
iValues = newValues ;
array = new Object [] { validValues , new Integer ( maxLength ) } ;
{ integers [ i ] = new Integer ( i ) ; }
{ return withPivotYear ( new Integer ( pivotYear ) ) ; }
array = new Object [] { validValues , new Integer ( maxLength ) } ;
{ return withPivotYear ( new Integer ( pivotYear ) ) ; }
DateTimeFormatter printer = ISODateTimeFormat . dateHourMinuteSecondFraction () ;
protected void setUp ( ) throws Exception { originalLocale = Locale . getDefault () ; Locale . setDefault ( Locale.UK ) ; }
convId = zone . getDisplayName () ;
catch ( ArrayIndexOutOfBoundsException e ) { throw new IOException ( STRING_CONSTANT ) ; }
try { readZoneInfoMap ( din , map ) ; } finally { try { din . close () ; } catch ( IOException e ) {} }
StringBuffer msg = new StringBuffer () ;
StringBuffer sb = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer () ;
if ( tokenLen >= NUMBER_CONSTANT ) { builder . appendTimeZoneName () ; } else { builder . appendTimeZoneShortName () ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . startsWith ( STRING_CONSTANT ) ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . startsWith ( STRING_CONSTANT ) ) ; }
try { localDateTime . toDateTime ( this ) ; return false ; } catch ( IllegalArgumentException ex ) { return true ; }
throw new IllegalArgumentException ( message ) ;
{ if ( divisor == NUMBER_CONSTANT ) return this ; return new Duration ( FieldUtils . safeDivide ( getMillis () , divisor ) ) ; }
{ if ( multiplicand == NUMBER_CONSTANT ) return this ; return new Duration ( FieldUtils . safeMultiply ( getMillis () , multiplicand ) ) ; }
{ appendable . append ( print ( instant ) ) ; }
f2 = new DateTimeFormatter ( null , f . getParser () ) ;
DateTimePrinter [] elements = iPrinters ;
DateTimePrinter [] elements = iPrinters ;
{ printTo ( appendable , null , instant , chrono ) ; }
f instanceof DateTimePrinter
DateTimePrinter printer
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( printer , parser ) ; }
{ checkPrinter ( printer ) ; return append0 ( printer , null ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter () , formatter . getParser () ) ; }
{ DateTimePrinter p = getFormatter ( locale ) . getPrinter () ; p . printTo ( appendable , partial , locale ) ; }
DateTimePrinter p = getFormatter ( locale ) . getPrinter () ;
return ( ( StyleFormatter ) formatter . getPrinter () ) . getPattern ( locale ) ;
DateTimePrinter printer = requirePrinter () ;
DateTimePrinter printer = requirePrinter () ;
{ printTo ( out , instant , null ) ; }
DateTimePrinter printer
catch ( IllegalArgumentException ex ) {}
{ return computeMillis ( resetFields , null ) ; }
{ return computeMillis ( false , null ) ; }
{ saveField ( new SavedField ( fieldType . getField ( iChrono ) , value ) ) ; }
{ saveField ( new SavedField ( field , value ) ) ; }
String text
f2 = new DateTimeFormatter ( ( InternalPrinter ) null , f . getParser () ) ;
{ reset () ; return doParseMillis ( parser , text ) ; }
String text
String text
String text
f instanceof DateTimeParser
DateTimeParser parser
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , parser ) ; }
{ checkParser ( parser ) ; return append0 ( null , parser ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter0 () , formatter . getParser () ) ; }
DateTimeParser parser = requireParser () ;
DateTimeParser parser = requireParser () ;
DateTimeParser parser = requireParser () ;
DateTimeParser parser = requireParser () ;
DateTimeParser parser = requireParser () ;
public DateTimeParser getParser () { return iParser ; }
DateTimeParser parser
DateTimeParser parser
{ this ( DateTimePrinterInternalPrinter . of ( printer ) , parser ) ; }
iMillis = FieldUtils . safeAdd ( endMillis , - startMillis ) ;
{ super(); iMillis = FieldUtils . safeAdd ( endInstant , - startInstant ) ; }
try { builder . appendSuffix ( null , null ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { builder . appendPrefix ( null , null ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
iSuffixes = texts ;
new PeriodFormatterBuilder () . appendDays () . appendSuffix ( STRING_CONSTANT ) . appendSuffix ( STRING_CONSTANT , STRING_CONSTANT )
new PeriodFormatterBuilder () . appendPrefix ( STRING_CONSTANT ) . appendPrefix ( STRING_CONSTANT , STRING_CONSTANT )
if ( periodStr . regionMatches ( true , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
if ( periodStr . regionMatches ( false , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
synchronized ( DateTimeZone . class ) { cDefault = zone ; }
{ return new TreeSet < String > ( iZoneInfoMap . keySet () ) ; }
public Set < String > getAvailableIDs () { return Collections . singleton ( STRING_CONSTANT ) ; }
public static Set < String > getAvailableIDs () { return cAvailableIDs ; }
DateTimeZone zone = cProvider . getZone ( id ) ;
assertSame ( zone , result ) ;
int curMonth0 = partial . getValue ( NUMBER_CONSTANT ) - NUMBER_CONSTANT ;
if ( ZoneInfoCompiler . verbose () ) { System.out . println ( STRING_CONSTANT + tz . getID () ) ; }
cVerbose . set ( verbose ) ;
Interval interval = new Interval ( start , end ) ;
int compare = csCompare ( value , text , position ) ;
{ return FieldUtils . safeAdd ( getEndMillis () , - getStartMillis () ) ; }
{ millis = iField . set ( millis , iValue ) ; }
str = str . toLowerCase () ;
assertEquals ( STRING_CONSTANT , str ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter fmt = DateTimeFormat . forPattern ( STRING_CONSTANT ) ;
{ Provider provider = new ZoneInfoProvider ( STRING_CONSTANT ) ; return validateProvider ( provider ) ; }
try { retDT = new DateTime ( s ) ; } catch ( ParseException pe ) {}
ParseException e
Object f
Object f
Object f
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
DateTimeField field
DateTimeField field
char c
Object element
DateTimeParser parser
DateTimeParser parser
DateTimePrinter printer
DateTimeFormatter formatter
Chronology chrono
DateTimeZone zone
int digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
int digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
Chronology chrono = ISOChronology . getInstanceUTC () ;
public int getMinimumValue ( long millis ) { return NUMBER_CONSTANT ; }
int value
long millis
GJWeekyearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
ReadableInstant instant
public int get ( long millis ) { return BuddhistChronology.BE ; }
public String getNameKey ( long millis ) { return iNameKey ; }
{ return add ( millis , value - get ( millis ) ) ; }
public long add ( long millis , int value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
ParseException pe
{ return add ( millis , value - get ( millis ) ) ; }
public long add ( long millis , int value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
public long add ( long millis , int value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
return ( getMillis () < readableInstant . getMillis () ) ;
{ Chronology chrono = getChronology () ; return chrono != null ? chrono . getDateTimeZone () : null ; }
public AbstractInstant () { super(); }
catch ( ParseException pe ) { pe . printStackTrace () ; }
try { retDT = new DateTime ( s , DateTimeZone.UTC ) ; } catch ( ParseException pe ) { pe . printStackTrace () ; }
if ( zone == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
int value
if ( zone == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
GJMonthOfYearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
int value
public abstract boolean equals ( Object obj ) ;
public String print ( long millisUTC ) { throw unsupported () ; }
public String print ( ReadableInstant instant ) { throw unsupported () ; }
public String print ( ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
char c
char style
char style
