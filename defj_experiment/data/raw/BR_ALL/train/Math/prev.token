{ return getCumPct ( new Character ( v ) ) ; }
{ return getCumFreq ( new Character ( v ) ) ; }
{ return getPct ( new Character ( v ) ) ; }
{ return getCount ( new Character ( v ) ) ; }
public IntegratorException ( Throwable cause ) { super ( cause ) ; }
double initialStepSize
SecondOrderDifferentialEquations equations
public DerivativeException ( Throwable cause ) { super ( cause ) ; }
super ( minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
{ super ( c , a , b , new GillStepInterpolator () , step ) ; }
{ super ( c , a , b , new MidpointStepInterpolator () , step ) ; }
{ super ( c , a , b , new EulerStepInterpolator () , step ) ; }
{ super ( c , a , b , new ThreeEighthesStepInterpolator () , step ) ; }
{ super ( c , a , b , new ClassicalRungeKuttaStepInterpolator () , step ) ; }
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new VariableHandler () ) ;
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( cm ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new KeplerStepHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new VariableStepHandler () ) ;
integ . setStepHandler ( new KeplerStepHandler ( pb ) ) ;
integrator . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new VariableHandler () ) ;
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
handler = DummyStepHandler . getInstance () ;
FirstOrderIntegrator integrator
regression . addData ( y , x , omega ) ;
regression . addData ( y , x , omega ) ;
CombinedEventsManager manager = addEndTimeChecker ( t , eventsHandlersManager ) ;
CombinedEventsManager manager = addEndTimeChecker ( t , eventsHandlersManager ) ;
{ maxValueError = NUMBER_CONSTANT ; maxTimeError = NUMBER_CONSTANT ; lastError = NUMBER_CONSTANT ; expectedStepStart = problem . getInitialTime () ; }
ComplexFormat cf = new ComplexFormat () ;
ComplexFormat cf = ComplexFormat . getInstance ( getLocale () ) ;
this . step = step ;
stepSize = step ;
this . step = step ;
stepSize = step ;
this . step = step ;
{ if ( qr == null ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ System . arraycopy ( b [ i ] , NUMBER_CONSTANT , root . getDataRef () [ swap [ i ] ] , NUMBER_CONSTANT , rank ) ; }
{ new QRDecompositionImpl () . isFullRank () ; fail ( STRING_CONSTANT ) ; }
if ( ! isFullRank () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! isFullRank () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
cachedQ == null
RealMatrix sse = u . transpose () . multiply ( Omega . inverse () ) . multiply ( u ) ;
{ RealMatrix XTX = X . transpose () . multiply ( X ) ; return XTX . inverse () ; }
if ( ! isNonSingular () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! isNonSingular () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
MatrixIndexException ex = new MatrixIndexException ( msg ) ;
if ( singular ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( singular ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( singular ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! matrix . isSquare () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! matrix . isSquare () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! isSquare () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
catch ( IndexOutOfBoundsException e ) { throw new MatrixIndexException ( e . getMessage () ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
throw new RuntimeException ( STRING_CONSTANT ) ;
catch ( Exception e ) { throw new RuntimeException ( e . getMessage () ) ; }
{ return ( Object [] ) arguments . clone () ; }
{ super(); this . pattern = null ; this . arguments = new Object [ NUMBER_CONSTANT ] ; }
{ return ( Object [] ) arguments . clone () ; }
MatrixIndexException ex = new MatrixIndexException ( msg , new Object [ NUMBER_CONSTANT ] ) ;
InvalidMatrixException ex = new InvalidMatrixException ( msg , new Object [ NUMBER_CONSTANT ] ) ;
assertNull ( ex . getMessage ( Locale.FRENCH ) ) ;
{ throw new InvalidMatrixException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
assertNull ( ex . getMessage ( Locale.FRENCH ) ) ;
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
throw new MathRuntimeException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ;
public Double getZ () { throw new MathRuntimeException () ; }
if ( norm == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( s == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
if ( o == null ) { throw new MathException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
{ super(); this . pattern = null ; this . arguments = null ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
catch ( Exception e ) { throw new IOException ( e . getMessage () ) ; }
catch ( Exception e ) { throw new IOException ( e . getMessage () ) ; }
catch ( Exception e ) { throw new IOException ( e . getMessage () ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
catch ( IOException ioe ) { assertNull ( ioe . getMessage () ) ; }
catch ( IOException ioe ) { assertNull ( ioe . getMessage () ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
{ if ( qrt == null ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( resultComputed ) { return iterationCount ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( resultComputed ) { return result ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
{ if ( lu == null ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( resultComputed ) { return iterationCount ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( resultComputed ) { return result ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
if ( ! loaded ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
assertEquals ( NUMBER_CONSTANT , vTv . subtract ( id ) . getNorm () , normTolerance ) ;
assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
{ assertEquals ( refValues [ i ] , eigenValues [ eigenValues.length - NUMBER_CONSTANT - i ] , NUMBER_CONSTANT ) ; }
orthoTridiag = null ;
lu = null ;
lu = null ;
{ copyIn ( d ) ; lu = null ; }
lu = null ;
public int [] getPivot ( ) throws IllegalStateException { checkDecomposed () ; return pivot . clone () ; }
{ checkDecomposed () ; return eigenvalues [ i ] ; }
public double [] getEigenvalues ( ) throws InvalidMatrixException { checkDecomposed () ; return eigenvalues . clone () ; }
EigenDecomposition ed = new EigenDecompositionImpl ( distinct ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( repeated ) ;
RealMatrix v = new EigenDecompositionImpl ( matrix ) . getV () ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
public double getNorm ( ) throws InvalidMatrixException { checkDecomposed () ; return singularValues [ NUMBER_CONSTANT ] ; }
public double [] getSingularValues ( ) throws InvalidMatrixException { checkDecomposed () ; return singularValues . clone () ; }
ds = null ;
ds = null ;
{ copyIn ( d ) ; ds = null ; }
ds = null ;
EigenDecomposition ed = new DecompositionSolver ( distinct ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( repeated ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( m ) . eigenDecompose () ;
RealMatrix v = new DecompositionSolver ( matrix ) . eigenDecompose () . getV () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
public DescriptiveStatistics ( int window ) { super(); setWindowSize ( window ) ; }
{ return stat . evaluate ( eDA . getValues () , eDA . start () , eDA . getNumElements () ) ; }
double [] [] in
RealVectorImpl v
double [] v
RealMatrixImpl m
RealMatrixImpl m
RealMatrixImpl m
double [] v
{ setup ( f ) ; return factory . newDefaultSolver ( f ) . solve ( x0 , x1 ) ; }
UnivariateRealSolver solver = factory . newSecantSolver ( function ) ;
UnivariateRealSolver solver = factory . newBrentSolver ( function ) ;
UnivariateRealSolver solver = factory . newNewtonSolver ( function ) ;
UnivariateRealSolver solver = factory . newBisectionSolver ( function ) ;
try { iterator . next () ; } catch ( ConcurrentModificationException cme ) {}
RealMatrixImpl m_outerProduct = v1 . outerProduct ( v2 ) ;
cachedV = transformer . getV () . multiply ( new RealMatrixImpl ( iData , false ) ) ;
cachedU = transformer . getU () . multiply ( new RealMatrixImpl ( iData , false ) ) ;
RealMatrix covRM = new RealMatrixImpl ( cov , false ) ;
return new RealMatrixImpl ( bp , false ) ;
return new RealMatrixImpl ( dData , false ) ;
return new RealMatrixImpl ( data , false ) ;
return new RealMatrixImpl ( xData , false ) ;
{ this . X = new RealMatrixImpl ( x ) ; }
{ this . Y = new RealMatrixImpl ( y ) ; }
RealMatrixImpl matrix = new RealMatrixImpl ( testSquare , false ) ;
{ this . Omega = new RealMatrixImpl ( omega ) ; this . OmegaInverse = null ; }
RealMatrixImpl matrix = new RealMatrixImpl ( testData , false ) ;
RealMatrixImpl matrix = new RealMatrixImpl ( testData , false ) ;
RealMatrixImpl matrix = new RealMatrixImpl ( testData , false ) ;
RealMatrixImpl matrix = new RealMatrixImpl ( testData , false ) ;
return new RealMatrixImpl ( invData , false ) ;
return new RealMatrixImpl ( bp , false ) ;
{ this . X = new RealMatrixImpl ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
@ Test ( expected = IllegalArgumentException . class )
assertTrue ( solver . isNonSingular () ) ;
{ return new RealVectorImpl ( solve ( b . getData () ) , false ) ; }
{ this . decomposition = decomposition ; }
{ this . X = new DenseRealMatrix ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
{ this . Omega = MatrixUtils . createRealMatrix ( omega ) ; this . OmegaInverse = null ; }
{ this . X = MatrixUtils . createRealMatrix ( x ) ; }
{ this . Y = new RealVectorImpl ( y ) ; }
@ Test ( expected = ArrayIndexOutOfBoundsException . class )
return MatrixUtils . createRealMatrix ( data ) ;
public boolean isSingular ( ) ;
return new RealMatrixImpl ( data , false ) ;
{ this . decomposition = decomposition ; }
{ eigenvectors [ i ] = findEigenvector ( eigenvalues [ i ] , d , l ) ; }
{ eigenvalues [ index ] = main [ index ] ; }
{ if ( eigenvectors == null ) { findEigenVectors () ; } return new Solver ( eigenvalues , eigenvectors ) ; }
{ double determinant = NUMBER_CONSTANT ; for ( double lambda : eigenvalues ) { determinant *= lambda ; } return determinant ; }
{ if ( cachedD == null ) { cachedD = MatrixUtils . createRealDiagonalMatrix ( eigenvalues ) ; } return cachedD ; }
double [] observed = ed . getEigenvalues () ;
double lambda = ed . getEigenvalue ( i ) ;
double [] eigenValues = ed . getEigenvalues () ;
double [] eigenValues = ed . getEigenvalues () ;
double [] eigenValues = ed . getEigenvalues () ;
assertEquals ( NUMBER_CONSTANT , ed . getEigenvalue ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
singularValues = eigenDecomposition . getEigenvalues () ;
{ if ( eigenvectors == null ) { findEigenVectors () ; } return new Solver ( realEigenvalues , eigenvectors ) ; }
if ( n == NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ return fht ( f ) ; }
{ OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap () ; assertEquals ( NUMBER_CONSTANT , map . remove ( NUMBER_CONSTANT ) ) ; }
this . entries = new OpenIntToDoubleHashMap () ;
double previous = NUMBER_CONSTANT ;
values [ index ] = NUMBER_CONSTANT ;
return new LUSolver ( new LUDecompositionImpl ( XTX ) ) . getInverse () ;
assertEquals ( new RealMatrixImpl ( reference ) , new RealMatrixImpl ( sub ) ) ;
assertEquals ( new RealMatrixImpl ( reference ) , new RealMatrixImpl ( sub ) ) ;
RealMatrix m = new RealMatrixImpl ( subTestData ) ;
assertEquals ( new RealMatrixImpl ( reference ) , sub ) ;
assertEquals ( new RealMatrixImpl ( reference ) , sub ) ;
RealMatrix m = new RealMatrixImpl ( subTestData ) ;
rDiag = new double [ n ] ;
return new LUSolver ( new LUDecompositionImpl ( XTOIX ) ) . getInverse () ;
{ if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; } }
if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; }
if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; }
if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; }
if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; }
private double getDeterminant ( RealMatrix m ) { return new LUSolver ( new LUDecompositionImpl ( m ) ) . getDeterminant () ; }
{ clearResult () ; return localmin ( min , max , relativeAccuracy , absoluteAccuracy , f ) ; }
assertEquals ( Float.NaN , MathUtils . sign ( Float.NaN ) , delta ) ;
{ vals [ i ] = values [ i ] ; }
computeOmega ( - f.length ) ;
computeOmega ( - f.length ) ;
computeOmega ( f.length ) ;
{ computeOmega ( f.length ) ; return fft ( f ) ; }
{ for ( int i = NUMBER_CONSTANT ; i < virtualSize ; i ++ ) { set ( i , value ) ; } }
{ set ( i , Math . log ( getEntry ( i ) ) ) ; }
{ set ( i , Math . log10 ( getEntry ( i ) ) ) ; }
{ set ( i , NUMBER_CONSTANT / getEntry ( i ) ) ; }
{ set ( i , getEntry ( i ) + d ) ; }
{ set ( i , Math . acos ( getEntry ( i ) ) ) ; }
{ res . set ( i + virtualSize , a [ i ] ) ; }
{ RealVector res = new SparseRealVector ( this , NUMBER_CONSTANT ) ; res . set ( virtualSize , d ) ; return res ; }
{ set ( index , v.data ) ; }
w . set ( i , w . getEntry ( i ) / si ) ;
assertClose ( STRING_CONSTANT , m3 . multiply ( m4 ) , m5 , entryTolerance ) ;
MatrixIndexException ex = new MatrixIndexException ( msg , null ) ;
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( numElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( STRING_CONSTANT , null ) ; }
public Double getZ () { throw new MathRuntimeException ( STRING_CONSTANT , null ) ; }
final Object [] parts
FunctionEvaluationException ex = new FunctionEvaluationException ( NUMBER_CONSTANT , cause ) ;
FunctionEvaluationException ex = new FunctionEvaluationException ( NUMBER_CONSTANT , pattern , arguments , cause ) ;
if ( isZero ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
{ super ( STRING_CONSTANT , new Object [] { rows , columns } ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , null ) ; }
catch ( ClassCastException cce ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
Object [] arguments
catch ( DimensionMismatchException dme ) { throw new MathRuntimeException ( STRING_CONSTANT , null , dme ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT , null ) ; }
Object [] parts
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT + STRING_CONSTANT , null ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
Object [] arguments
Object [] parts
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT , null ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } return isForward ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
final Object [] arguments
{ return buildMessage ( pattern , arguments , locale ) ; }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
Object [] arguments
MathException ex = new MathException ( pattern , arguments , cause ) ;
{ super ( isCardan ? STRING_CONSTANT : STRING_CONSTANT , null ) ; }
MathConfigurationException ex = new MathConfigurationException ( pattern , arguments , cause ) ;
Object [] arguments
ConvergenceException ex = new ConvergenceException ( pattern , arguments , cause ) ;
{ return buildMessage ( pattern , arguments , locale ) ; }
{ throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , null ) ; }
final Object [] parts
final Object [] arguments
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
final Object [] parts
if ( b.length != nRows ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( v.length != nRows ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( ! isSquare () ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , null ) ; }
catch ( DerivativeException de ) { throw new MathRuntimeException ( STRING_CONSTANT , null , de ) ; }
while ( iter . hasNext () ) { iter . advance () ; if ( Double . isNaN ( iter . value () ) ) return true ; }
while ( iter . hasNext () ) { iter . advance () ; if ( Double . isInfinite ( iter . value () ) ) return true ; }
if ( delta > max ) max = delta ;
{ virtualSize = values.length ; fromDoubleArray ( values ) ; }
{ if ( data.length != n ) { throw new IllegalArgumentException ( STRING_CONSTANT + data.length + STRING_CONSTANT + n + STRING_CONSTANT ) ; } }
if ( d.length == NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
epsilon = DEFAULT_ZERO_TOLERANCE ;
public void setConvergenceChecker ( ConvergenceChecker checker ) { optimizer . setConvergenceChecker ( checker ) ; }
final Optimizer optimizer
final Comparator < PointValuePair > comparator
public void setConvergenceChecker ( ConvergenceChecker checker ) { this . checker = checker ; }
final MultiObjectiveFunction function
final MultiObjectiveFunction function
final MultiObjectiveFunction function
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , buildArray ( m , factor ) , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , buildChebyquadArray ( n , factor ) , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , buildArray ( n , x0 ) , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; if ( theoreticalStartCost > NUMBER_CONSTANT ) { setCostAccuracy ( NUMBER_CONSTANT ) ; setParamsAccuracy ( NUMBER_CONSTANT ) ; } }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; if ( theoreticalStartCost > NUMBER_CONSTANT ) { setCostAccuracy ( NUMBER_CONSTANT ) ; setParamsAccuracy ( NUMBER_CONSTANT ) ; } }
{ super ( NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , x0 ) , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
{ super ( m , buildArray ( n , x0 ) , theoreticalStartCost , theoreticalMinCost , null ) ; }
final double residual = objective [ i ] - target [ i ] ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( maxCostEval ) ;
incrementJacobianEvaluationsCounter () ;
{ setConvergenceChecker ( new SimpleVectorialValueChecker () ) ; setMaxEvaluations ( DEFAULT_MAX_EVALUATIONS ) ; }
{ super ( cause , pattern , arguments ) ; this . argument = argument ; }
{ super ( cause ) ; this . argument = argument ; }
{ super ( pattern , arguments ) ; this . argument = argument ; }
assertEquals ( NUMBER_CONSTANT , ex . getArgument () , NUMBER_CONSTANT ) ;
assertEquals ( Math.PI , ex . getArgument () , NUMBER_CONSTANT ) ;
final VectorialObjectiveFunction function
public void setConvergenceChecker ( ScalarConvergenceChecker checker ) { this . checker = checker ; }
catch ( ObjectiveException oe ) { assertTrue ( exceptionExpected ) ; }
{ if ( numerator == NUMBER_CONSTANT ) { return ZERO ; } return new BigFraction ( numerator , denominator ) . reduce () ; }
{ if ( format == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . wholeFormat = format ; }
public FractionFormat () { this ( getDefaultNumberFormat () ) ; }
{ return subtract ( new BigFraction ( l , NUMBER_CONSTANT ) ) ; }
{ return subtract ( new BigFraction ( i , NUMBER_CONSTANT ) ) ; }
{ return multiply ( new BigFraction ( l , NUMBER_CONSTANT ) ) ; }
{ return multiply ( new BigFraction ( i , NUMBER_CONSTANT ) ) ; }
{ return add ( new BigFraction ( l , NUMBER_CONSTANT ) ) ; }
{ return add ( new BigFraction ( i , NUMBER_CONSTANT ) ) ; }
final ArrayList < Fraction > coefficients
assertEquals ( ci , l40 [ i ] , ci * NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , new BigFraction ( Double.MIN_NORMAL ) . getNumeratorAsLong () ) ;
protected Locale getLocale () { return Locale.US ; }
protected Locale getLocale () { return Locale.FRENCH ; }
protected String getResourceName () { return STRING_CONSTANT ; }
protected String getResourceName () { return STRING_CONSTANT ; }
protected Locale getLocale () { return Locale.US ; }
protected Locale getLocale () { return Locale.FRENCH ; }
protected Locale getLocale () { return Locale.FRENCH ; }
protected Locale getLocale () { return Locale.US ; }
UnivariateRealSolver solver = factory . newDefaultSolver () ;
{ setup ( f ) ; return factory . newDefaultSolver () . solve ( f , x0 , x1 ) ; }
{ logSum += Math . log ( ( double ) i ) ; }
double n0 = ( double ) n ;
double n0 = ( double ) n ;
{ return ( StorelessUnivariateStatistic [] ) meanImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) geoMeanImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) sumLogImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) maxImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) minImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) sumSqImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) sumImpl . clone () ; }
double degreesOfFreedom = ( double ) ( n1 + n2 - NUMBER_CONSTANT ) ;
{ return ( sumY - slope * sumX ) / ( ( double ) n ) ; }
Math . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / ( double ) n ) + ( xbar * xbar ) / sumXX ) )
{ if ( n < NUMBER_CONSTANT ) { return Double.NaN ; } return getSumSquaredErrors () / ( double ) ( n - NUMBER_CONSTANT ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return ( RealPointValuePair [] ) optima . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return ( RealPointValuePair [] ) optima . clone () ; }
double n = ( double ) length ;
{ dest.variance = ( Variance ) source.variance . copy () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return ( VectorialPointValuePair [] ) optima . clone () ; }
{ dest.incMoment = source.incMoment ; dest.moment = ( FirstMoment ) source.moment . copy () ; }
double sampleSize = ( double ) length ;
{ dest.moment = ( FourthMoment ) source.moment . copy () ; dest.incMoment = source.incMoment ; }
{ return ( NumberTransformer ) map . get ( key ) ; }
{ return sumDifference ( sample1 , sample2 ) / ( double ) sample1.length ; }
{ dest.sumOfLogs = ( SumOfLogs ) source.sumOfLogs . copy () ; }
{ return Math . exp ( sumOfLogs . evaluate ( values , begin , length ) / ( double ) length ) ; }
{ return Math . exp ( sumOfLogs . getResult () / ( double ) sumOfLogs . getN () ) ; }
{ result [ i - NUMBER_CONSTANT ] = ( double ) i * coefficients [ i ] ; }
double n0 = ( double ) n ;
{ dest.moment = new ThirdMoment ( ( ThirdMoment ) source.moment . copy () ) ; dest.incMoment = source.incMoment ; }
{ return ( Object [] [] ) contents . clone () ; }
{ dest.moment = ( SecondMoment ) source.moment . copy () ; dest.isBiasCorrected = source.isBiasCorrected ; dest.incMoment = source.incMoment ; }
double len = ( double ) length ;
{ super ( problem ) ; y = ( double [] ) problem.y . clone () ; }
return Math . sqrt ( sum / ( double ) v.length ) ;
{ super ( problem ) ; e = problem.e ; y = ( double [] ) problem.y . clone () ; }
{ super ( problem ) ; y = ( double [] ) problem.y . clone () ; }
{ dY [ i ] = ( double ) y [ i ] ; }
{ dX [ i ] = ( double ) x [ i ] ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( asBigDecimal ( testVector ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . getTrace () . doubleValue () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) { ; }
catch ( InvalidMatrixException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
{ super ( problem ) ; a = problem.a ; y = ( double [] ) problem.y . clone () ; }
return sum / ( double ) v.length ;
try { randomData . nextExponential ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { randomData . nextSecureInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { randomData . nextSecureLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { randomData . nextLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { randomData . nextInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) { ; }
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
SimplexTableau tableau = new SimplexTableau ( f , constraints , GoalType.MAXIMIZE , false ) ;
SimplexTableau tableau = new SimplexTableau ( f , constraints , GoalType.MAXIMIZE , false ) ;
final SimplexTableau tableau = new SimplexTableau ( f , constraints , goalType , restrictToNonNegative ) ;
{ return ( sumY - slope * sumX ) / ( n ) ; }
Math . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / n ) + ( xbar * xbar ) / sumXX ) )
Math . sqrt ( ( accum - ( Math . pow ( accum2 , NUMBER_CONSTANT ) / ( length ) ) ) / ( length - NUMBER_CONSTANT ) )
double degreesOfFreedom = ( n1 + n2 - NUMBER_CONSTANT ) ;
{ checkSufficientData ( matrix ) ; nObs = matrix . getRowDimension () ; correlationMatrix = computeCorrelation ( matrix ) ; }
{ checkSufficientData ( matrix ) ; n = matrix . getRowDimension () ; covarianceMatrix = computeCovariance ( matrix , biasCorrected ) ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { testGenerator . nextInt ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { regression . getSlopeConfidenceInterval ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
catch ( IllegalStateException ex ) { ; }
{ try { vs . getNext () ; fail ( STRING_CONSTANT ) ; } catch ( IllegalStateException ex ) { ; } }
catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
Iterator it = f . valuesIterator () ;
final T [] out = buildArray ( nCols ) ;
final T [] out = buildArray ( nCols ) ;
final T [] out = buildArray ( nRows ) ;
final T [] out = buildArray ( nRows ) ;
final T [] out = buildArray ( nRows ) ;
final T [] out = buildArray ( nCols ) ;
final T [] [] data = buildArray ( getRowDimension () , getColumnDimension () ) ;
final T [] [] out = buildArray ( nRows , getColumnDimension () ) ;
final T [] out = buildArray ( nCols ) ;
final T [] out = buildArray ( nRows ) ;
data = buildArray ( subMatrix.length , nCols ) ;
final T [] [] outData = buildArray ( nRows , nCols ) ;
final T [] [] outData = buildArray ( rowCount , columnCount ) ;
final T [] [] outData = buildArray ( rowCount , columnCount ) ;
{ return ( FieldVectorImpl < T > ) subtract ( ( T [] ) v.data ) ; }
{ return ( FieldVectorImpl < T > ) add ( ( T [] ) v.data ) ; }
super ( ( Field < T > ) extractField ( v ) ) ;
super ( ( Field < T > ) extractField ( d ) ) ;
{ super ( ( Field < T > ) extractField ( d ) ) ; copyIn ( d ) ; }
nextAction = handler . eventOccurred ( t , y ) ;
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + n ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + n ) ; }
if ( f == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( f == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
return null ;
if ( Double . doubleToLongBits ( test ) != Double . doubleToLongBits ( iter . value () ) ) { return false ; }
double [] hatResiduals = I . subtract ( hat ) . multiply ( model.Y ) . getColumn ( NUMBER_CONSTANT ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkColumnIndex ( column ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkSubMatrixIndex ( row , endRow , column , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkMultiplicationCompatible ( m ) ;
checkMultiplicationCompatible ( m ) ;
checkSubtractionCompatible ( m ) ;
checkSubtractionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
{ this . Y = new RealMatrixImpl ( y ) ; }
{ if ( values == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw new IllegalArgumentException () ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
if ( n < NUMBER_CONSTANT || n != sample2.length ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( mean <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . mean = mean ; }
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkMultiplicationCompatible ( m ) ;
checkSubtractionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
if ( n <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . alpha = alpha ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( size < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } sampleSize = size ; }
{ if ( size <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } populationSize = size ; }
{ if ( num < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } numberOfSuccesses = num ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . alpha = alpha ; }
checkMultiplicationCompatible ( m ) ;
checkMultiplicationCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
checkColumnIndex ( col ) ;
checkColumnIndex ( col ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
if ( r < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
catch ( ClassCastException ex ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkColumnIndex ( column ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkSubMatrixIndex ( selectedRows , selectedColumns ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( selectedRows , selectedColumns ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkMultiplicationCompatible ( m ) ;
checkSubtractionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( successes < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } numberOfSuccesses = successes ; }
{ if ( values == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
throw new IllegalArgumentException ( STRING_CONSTANT ) ;
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . degreesOfFreedom = degreesOfFreedom ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( x0 > x1 ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( x0 > x1 ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( mean.length != standardDeviation.length ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( trials < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } numberOfTrials = trials ; }
{ if ( realFormat == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . realFormat = realFormat ; }
{ if ( imaginaryFormat == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . imaginaryFormat = imaginaryFormat ; }
if ( imaginaryCharacter == null || imaginaryCharacter . length () == NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
throw new IllegalArgumentException ( STRING_CONSTANT ) ;
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( sd <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } standardDeviation = sd ; }
if ( normProduct == NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( s <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } scale = s ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( x0 > x1 ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( mean < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( sigma <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( len <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( len <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + p ) ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + p ) ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + alpha ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + alpha ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + alpha ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + alpha ) ; }
Object obj1 = null ;
SparseRealVector v1 = new SparseRealVector ( vec1 ) ;
return new SparseRealVector ( out ) ;
{ Assert . assertEquals ( expected [ i ] , observed [ i ] , tolerance ) ; }
final int dimension = currentState.length ;
final int dimension = currentState.length ;
final MultistepStepInterpolator prototype
equations = null ;
equations = null ;
{ super(); yDotK = null ; equations = null ; }
interpolator . reinitialize ( new DummyEquations () , y , yDot , true ) ;
interpolator . reinitialize ( new DummyEquations () , y , yDot , true ) ;
interpolator . reinitialize ( new DummyEquations () , y , yDot , true ) ;
equations . computeDerivatives ( t0 + h , y1 , yDot1 ) ;
{ this . factors = new DenseRealMatrix ( factors ) ; this . target = target ; }
{ this . factors = new DenseRealMatrix ( factors ) ; this . target = target ; }
assertEquals ( MatrixUtils . createColumnRealMatrix ( col ) , new DenseRealMatrix ( colMatrix ) ) ;
assertEquals ( MatrixUtils . createRowRealMatrix ( row ) , new DenseRealMatrix ( rowMatrix ) ) ;
assertEquals ( new DenseRealMatrix ( testData ) , MatrixUtils . createRealMatrix ( testData ) ) ;
RealMatrix mA = new DenseRealMatrix ( a ) ;
RealMatrix result = new DenseRealMatrix ( dimension , dimension ) ;
return new DenseRealMatrix ( matrixData ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new DenseRealMatrix ( testDataInv ) ) , identity , entryTolerance ) ;
{ DenseRealMatrix m = new DenseRealMatrix ( testData ) ; assertEquals ( m , TestUtils . serializeAndRecover ( m ) ) ; }
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
assertEquals ( new DenseRealMatrix ( reference ) , new DenseRealMatrix ( sub ) ) ;
assertEquals ( new DenseRealMatrix ( reference ) , new DenseRealMatrix ( sub ) ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
assertEquals ( new DenseRealMatrix ( reference ) , sub ) ;
assertEquals ( new DenseRealMatrix ( reference ) , sub ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( testData ) ;
RealMatrix m = new DenseRealMatrix ( testData ) ;
RealMatrix m = new DenseRealMatrix ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ this . factors = new DenseRealMatrix ( factors ) ; this . target = target ; }
{ return computeCorrelationMatrix ( new DenseRealMatrix ( data ) ) ; }
RealMatrix outMatrix = new DenseRealMatrix ( nVars , nVars ) ;
{ return computeCorrelationMatrix ( new DenseRealMatrix ( data ) ) ; }
RealMatrix outMatrix = new DenseRealMatrix ( nVars , nVars ) ;
return new DenseRealMatrix ( out ) ;
return new DenseRealMatrix ( out ) ;
{ this ( new DenseRealMatrix ( data ) ) ; }
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
assertEquals ( new DenseFieldMatrix < Fraction > ( reference ) , sub ) ;
assertEquals ( new DenseFieldMatrix < Fraction > ( reference ) , sub ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( testData ) ;
{ return computeCovarianceMatrix ( new DenseRealMatrix ( data ) , biasCorrected ) ; }
RealMatrix outMatrix = new DenseRealMatrix ( dimension , dimension ) ;
{ this ( new DenseRealMatrix ( data ) , biasCorrected ) ; }
FieldMatrix < Fraction > matrix = new FieldMatrixImpl < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new FieldMatrixImpl < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new FieldMatrixImpl < Fraction > ( testData ) ;
{ setColumn ( column , ( ( RealVectorImpl ) vector ) . getDataRef () ) ; }
return new RealVectorImpl ( outData , false ) ;
{ setRow ( row , ( ( RealVectorImpl ) vector ) . getDataRef () ) ; }
return new RealVectorImpl ( outData , false ) ;
{ return new RealVectorImpl ( getColumn ( column ) , false ) ; }
{ return new RealVectorImpl ( getRow ( row ) , false ) ; }
eigenvectors = new RealVectorImpl [ m ] ;
final RealVectorImpl v = eigenvectors [ i ] ;
final RealVectorImpl v = eigenvectors [ i ] ;
final RealVectorImpl [] eigenvectors
{ this . X = new RealMatrixImpl ( x ) ; }
{ this . Y = new RealVectorImpl ( y ) ; }
return new RealVectorImpl ( data , false ) ;
{ m . setColumnVector ( NUMBER_CONSTANT , new RealVectorImpl ( NUMBER_CONSTANT ) ) ; fail ( STRING_CONSTANT ) ; }
TestUtils . assertEquals ( STRING_CONSTANT , m . preMultiply ( new RealVectorImpl ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , testVector , m . operate ( new RealVectorImpl ( testVector ) ) . getData () , entryTolerance ) ;
{ super ( STRING_CONSTANT , new RealVectorImpl ( argument ) ) ; this . argument = argument . clone () ; }
return new FieldMatrixImpl < Fraction > ( out ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
return new FieldVectorImpl < Fraction > ( data , false ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
assertEquals ( new FieldMatrixImpl < Fraction > ( reference ) , sub ) ;
assertEquals ( new FieldMatrixImpl < Fraction > ( reference ) , sub ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( testData ) ;
{ this ( new RealVectorImpl ( coefficients ) , constantTerm ) ; }
this . coefficients = new RealVectorImpl ( sub , false ) ;
{ this ( new RealVectorImpl ( coefficients ) , relationship , value ) ; }
return new RealMatrixImpl ( matrixData ) ;
RealMatrix repeatedColumns = new RealMatrixImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
this . tableau = new RealMatrixImpl ( matrix ) ;
this . tableau = new RealMatrixImpl ( createTableau ( goalType == GoalType.MAXIMIZE ) ) ;
nordsieck = new RealMatrixImpl ( nData , false ) ;
{ setColumn ( column , ( ( FieldVectorImpl < T > ) vector ) . getDataRef () ) ; }
return new FieldVectorImpl < T > ( outData , false ) ;
{ setRow ( row , ( ( FieldVectorImpl < T > ) vector ) . getDataRef () ) ; }
return new FieldVectorImpl < T > ( outData , false ) ;
return new RealVectorImpl ( x ) ;
{ this . X = new RealMatrixImpl ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
RealMatrixImpl augI = new RealMatrixImpl ( n , n ) ;
return new FieldMatrixImpl < BigFraction > ( pData , false ) ;
FieldMatrix < BigFraction > bigMSupdate = bigMStoN . multiply ( new FieldMatrixImpl < BigFraction > ( shiftedP , false ) ) ;
return coefficients.msToN . multiply ( new RealMatrixImpl ( multistep , false ) ) ;
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
return new RealMatrixImpl ( x , false ) ;
{ this . Omega = new RealMatrixImpl ( omega ) ; this . OmegaInverse = null ; }
{ return new FieldVectorImpl < T > ( getColumn ( column ) , false ) ; }
{ return new FieldVectorImpl < T > ( getRow ( row ) , false ) ; }
return new RealVectorImpl ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new RealVectorImpl ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new RealVectorImpl ( testVector ) ) . getData () , entryTolerance ) ;
RealVector lhs = new RealVectorImpl ( numCoefficients ) ;
final RealMatrix matrix = new RealMatrixImpl ( data , false ) ;
final RealVector vector = new RealVectorImpl ( data , false ) ;
RealMatrix getConvertedMatrix () { return new RealMatrixImpl ( data , false ) ; }
RealMatrix getConvertedMatrix () { return new RealMatrixImpl ( data , false ) ; }
{ return new FieldVectorImpl < T > ( data , true ) ; }
{ return new RealVectorImpl ( data , true ) ; }
return new FieldMatrixImpl < T > ( d , false ) ;
new FieldMatrixImpl < T > ( data )
new FieldMatrixImpl < T > ( field , rows , columns )
{ es . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
decompMatrix = new RealMatrixImpl ( decomp ) ;
RealMatrix triangularMatrix = new RealMatrixImpl ( lowerTriangularMatrix ) ;
RealMatrix triangularMatrix = new RealMatrixImpl ( lowerTriangularMatrix ) ;
solver . solve ( new RealMatrixImpl ( m3 ) , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } ) ;
solver . decompose ( new RealMatrixImpl ( m7 ) ) ;
return new FieldVectorImpl < Fraction > ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new FieldVectorImpl < Fraction > ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new FieldVectorImpl < Fraction > ( testVector ) ) . getData () , entryTolerance ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new FieldMatrixImpl < Fraction > ( testDataInv ) ) , identity , entryTolerance ) ;
return new RealMatrixImpl ( bp , false ) ;
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
return new FieldMatrixImpl < BigFraction > ( pData , false ) ;
FieldMatrix < BigFraction > bigMSupdate = bigMStoN . multiply ( new FieldMatrixImpl < BigFraction > ( shiftedP , false ) ) ;
return coefficients.msToN . multiply ( new RealMatrixImpl ( multistep , false ) ) ;
FieldMatrix < T > identity = new FieldMatrixImpl < T > ( field , m , m ) ;
return new FieldMatrixImpl < T > ( bp , false ) ;
cachedP = new FieldMatrixImpl < T > ( field , m , m ) ;
cachedU = new FieldMatrixImpl < T > ( field , m , m ) ;
cachedL = new FieldMatrixImpl < T > ( field , m , m ) ;
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n , simplex.length ) ; }
{ Arrays . fill ( corrected , NUMBER_CONSTANT ) ; }
f . set ( this , NordsieckTransformer . getInstance ( nSteps ) ) ;
{ super ( STRING_CONSTANT , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
final RealMatrix nordsieck
if ( interpolator.nordsieck != null ) { nordsieck = interpolator.nordsieck . copy () ; }
nordsieck = transformer . initializeHighOrderDerivatives ( scaled , multistep ) ;
TestProblem1 pb2 = ( TestProblem1 ) pb1 . clone () ;
v instanceof SparseFieldVector
v instanceof SparseFieldVector
v instanceof SparseFieldVector
v instanceof SparseFieldVector
! ( original instanceof RandomKey )
if ( ! ( another instanceof RandomKey ) ) return false ;
{ addMeasurement ( new LocalMeasurement ( x , y , w ) ) ; }
{ measurements [ i ] = new MinpackMeasurement ( i ) ; }
Object v
Object v
Object v
final long curN = current . getN () ;
StatisticalSummaryValues observed
StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics . aggregate ( aggregate ) ;
optimizer . setConvergenceChecker ( new SimpleScalarValueChecker ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
optimizer . setConvergenceChecker ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
final DescriptiveStatistics dstat = new DescriptiveStatistics () ;
DescriptiveStatistics stats = new DescriptiveStatistics () ;
DescriptiveStatistics stats = new DescriptiveStatistics () ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
{ super ( m , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
OpenMapRealVector res = ( OpenMapRealVector ) copy () ;
OpenMapRealVector res = ( OpenMapRealVector ) copy () ;
this . constraints = constraints ;
return factorials [ n ] ;
{ super ( STRING_CONSTANT , c , a , b , new ThreeEighthesStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , c , a , b , new EulerStepInterpolator () , step ) ; }
public static DummyStepHandler getInstance () { return instance ; }
{ super ( STRING_CONSTANT , c , a , b , new MidpointStepInterpolator () , step ) ; }
{ return percentile . evaluate ( values , begin , length , p ) ; }
{ return percentile . evaluate ( values , p ) ; }
{ return min . evaluate ( values , begin , length ) ; }
{ return min . evaluate ( values ) ; }
{ return max . evaluate ( values , begin , length ) ; }
{ return max . evaluate ( values ) ; }
{ return variance . evaluate ( values , mean ) ; }
{ return variance . evaluate ( values , mean , begin , length ) ; }
{ return variance . evaluate ( values , begin , length ) ; }
{ return variance . evaluate ( values ) ; }
{ return geometricMean . evaluate ( values , begin , length ) ; }
{ return geometricMean . evaluate ( values ) ; }
{ return mean . evaluate ( values , begin , length ) ; }
{ return mean . evaluate ( values ) ; }
{ return sumLog . evaluate ( values , begin , length ) ; }
{ return sumLog . evaluate ( values ) ; }
{ return prod . evaluate ( values , begin , length ) ; }
{ return prod . evaluate ( values ) ; }
{ return sumSq . evaluate ( values , begin , length ) ; }
{ return sumSq . evaluate ( values ) ; }
{ return sum . evaluate ( values , begin , length ) ; }
{ return sum . evaluate ( values ) ; }
{ super ( STRING_CONSTANT , c , a , b , new ClassicalRungeKuttaStepInterpolator () , step ) ; }
@ Override public Object [] [] getContents () { return contents . clone () ; }
{ super ( STRING_CONSTANT , c , a , b , new GillStepInterpolator () , step ) ; }
try { alg = MessageDigest . getInstance ( STRING_CONSTANT ) ; } catch ( NoSuchAlgorithmException ex ) { return null ; }
{ return row * columnDimension + column ; }
@ Override public int getRowDimension () { return rowDimension ; }
@ Override public int getColumnDimension () { return columnDimension ; }
{ return row * columnDimension + column ; }
@ Override public int getRowDimension () { return rowDimension ; }
@ Override public int getColumnDimension () { return columnDimension ; }
final SimplexTableau tableau = new SimplexTableau ( f , constraints , goalType , restrictToNonNegative , epsilon ) ;
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . alpha = alpha ; }
{ final double residual = residuals [ i ] ; chiSquare += residual * residual / weights [ i ] ; }
{ final double residual = residuals [ i ] ; criterion += weights [ i ] * residual * residual ; }
final double factor = - Math . sqrt ( weights [ i ] ) ;
catch ( Exception e ) { throw new MathException ( e , STRING_CONSTANT , e . getMessage () ) ; }
public UnivariateMatrixFunction derivative ( ) ;
public UnivariateRealFunction derivative ( ) ;
public double getMean ( ) ;
public double getExponent ( ) ;
public int getNumberOfElements ( ) ;
public boolean isNaN ( ) ;
public UnivariateVectorialFunction derivative ( ) ;
public abstract long getN ( ) ;
public int getDimension ( ) ;
public double fitness ( ) ;
public int getDimension ( ) ;
public int getDimension ( ) ;
public abstract int getSampleSize ( ) ;
public abstract int getPopulationSize ( ) ;
public abstract int getNumberOfSuccesses ( ) ;
public abstract double getSum ( ) ;
public abstract long getN ( ) ;
public abstract double getMin ( ) ;
public abstract double getMax ( ) ;
public double getCurrentTime ( ) ;
public double getPreviousTime ( ) ;
public abstract void resetRelativeAccuracy ( ) ;
public abstract double getRelativeAccuracy ( ) ;
public abstract void resetAbsoluteAccuracy ( ) ;
public abstract double getAbsoluteAccuracy ( ) ;
public abstract int getMaximalIterationCount ( ) ;
public void reset ( ) ;
public static DummyStepHandler getInstance () { return INSTANCE ; }
{ super(); this . randomData = randomData ; }
RandomGenerator generator
return ( anovaPValue ( categoryData ) < alpha ) ;
{ return ( internalArray ) ; }
{ return ( internalArray ) ; }
synchronized int getInternalLength () { return ( internalArray.length ) ; }
double dx = ( x2 - x1 ) ;
return ( isForward ) ? omegaImaginaryForward [ k ] : omegaImaginaryInverse [ k ] ;
isForward = ( n > NUMBER_CONSTANT ) ;
return ( stdDev ) ;
{ checkSignificanceLevel ( alpha ) ; return ( tTest ( sampleStats1 , sampleStats2 ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( homoscedasticTTest ( sample1 , sample2 ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( tTest ( sample1 , sample2 ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( tTest ( mu , sampleStats ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( tTest ( mu , sample ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( pairedTTest ( sample1 , sample2 ) < alpha ) ; }
public boolean isSquare () { return ( getColumnDimension () == getRowDimension () ) ; }
{ g0Positive = ( g0 >= NUMBER_CONSTANT ) ; nextAction = EventHandler.CONTINUE ; }
increasing = ( gb >= ga ) ;
{ t0 = tStart ; g0 = handler . g ( tStart , yStart ) ; g0Positive = ( g0 >= NUMBER_CONSTANT ) ; }
final boolean forward = ( t > t0 ) ;
final boolean forward = ( t > t0 ) ;
{ sum += ( values [ i ] * weights [ i ] ) ; }
final boolean forward = ( t > t0 ) ;
{ return ( o1 . compareTo ( ( T ) o2 ) ) ; }
return ( chiSquareTestDataSetsComparison ( observed1 , observed2 ) < alpha ) ;
unequalCounts = ( countSum1 != countSum2 ) ;
return ( chiSquareTest ( counts ) < alpha ) ;
return ( chiSquareTest ( expected , observed ) < alpha ) ;
return ( stdDev ) ;
i < this . getRowDimension ()
{ correction += ( values [ i ] - xbar ) ; }
public boolean isSquare () { return ( getColumnDimension () == getRowDimension () ) ; }
return ( super . equals ( stat ) && aggregateStatistics . equals ( stat.aggregateStatistics ) ) ;
final boolean forward = ( t > t0 ) ;
forward = ( interpolator . getCurrentTime () >= lastTime ) ;
final boolean forward = ( t > t0 ) ;
Complex N1 = new Complex ( ( n - NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
while ( ! isOptimal ( tableau ) ) { doIteration ( tableau ) ; }
while ( ! isPhase1Solved ( tableau ) ) { doIteration ( tableau ) ; }
Integer pivotRow = getPivotRow ( pivotCol , tableau ) ;
tableau . discardArtificialVariables () ;
assertTrue ( fitResidualSum < noisyResidualSum ) ;
double [] bounds = empiricalDistribution2 . getUpperBounds () ;
if ( xval.length == NUMBER_CONSTANT || xval [ NUMBER_CONSTANT ] == null ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( microsphereElements < NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , microsphereElements ) ; } this . microsphereElements = microsphereElements ; }
{ if ( brightnessExponent < NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , brightnessExponent ) ; } this . brightnessExponent = brightnessExponent ; }
super ( buildMessage ( Locale.US , pattern , arguments ) , rootCause ) ;
super ( buildMessage ( Locale.US , pattern , arguments ) , rootCause ) ;
catch ( Exception e ) { throw new MathRuntimeException ( e ) ; }
Math . sqrt ( NUMBER_CONSTANT * Math.PI * x )
double f = ( PI_2 * x * ( n - x ) ) / n ;
double d = ( x - mu ) ;
flipIfWarranted ( deflatedEnd , NUMBER_CONSTANT )
flipIfWarranted ( n , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
{ if ( BigInteger.ZERO . equals ( fraction.numerator ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; } return multiply ( fraction . reciprocal () ) ; }
if ( BigInteger.ZERO . equals ( bg ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( BigInteger.ZERO . equals ( den ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
int negativeVarColumn = columnLabels . indexOf ( STRING_CONSTANT ) ;
if ( ! restrictToNonNegative ) { columnLabels . add ( STRING_CONSTANT ) ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
{ super ( STRING_CONSTANT , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
{ super ( STRING_CONSTANT , argument ) ; this . argument = new double [] { argument } ; }
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n , startConfiguration.length ) ; }
if ( steps [ j ] == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , j , j + NUMBER_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } }
if ( function == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , pos , size , d.length ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , pos , size , d.length ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return isForward ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , o.length ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , d.length ) ; } }
int value = ( Integer ) decoded . get ( i ) ;
return mapDivide ( getNorm () ) ;
public ArrayRealVector ( ArrayRealVector v ) { data = v.data . clone () ; }
if ( isZero ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
! isZero ( value )
{ this ( values , DEFAULT_ZERO_TOLERANCE ) ; }
public OpenMapRealVector ( int dimension ) { this ( dimension , DEFAULT_ZERO_TOLERANCE ) ; }
{ this ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE ) ; }
public void setEntry ( int index , double value ) throws MatrixIndexException { throw unsupported () ; }
{ try { return mapToSelf ( UnivariateRealFunctions.ULP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.TANH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.TAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.SQRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.SINH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.SIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.SIGNUM ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.RINT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.LOG10 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.LOG ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.FLOOR ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.EXP1M ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.EXP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.COSH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.COS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.CEIL ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.CBRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ATAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ACOS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ABS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
Iterator < Entry > it = sparseIterator () ;
setDefault ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE ) ;
{ this ( values , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
setDefault ( NUMBER_CONSTANT , epsilon ) ;
public OpenMapRealVector ( int dimension ) { this ( dimension , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
{ this ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
{ return new BigReal ( d . divide ( a.d ) ) ; }
return new ArrayRealVector ( out ) ;
return new ArrayRealVector ( out ) ;
return new ArrayRealVector ( out ) ;
return new ArrayRealVector ( out ) ;
return new ArrayRealVector ( out ) ;
if ( lcm == Integer.MIN_VALUE ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
{ return new Solver ( singularValues , getUT () , getV () , getRank () == singularValues.length ) ; }
public void unitize () { throw unsupported () ; }
public RealVector unitVector () { throw unsupported () ; }
public RealVector mapCoshToSelf () { throw unsupported () ; }
public double getLInfNorm () { throw unsupported () ; }
public double getL1Norm () { throw unsupported () ; }
public double getNorm () { throw unsupported () ; }
{ dest.n = source.n ; dest.m1 = source.m1 ; dest.dev = source.dev ; dest.nDev = dest.nDev ; }
{ new LoessInterpolator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ new LoessInterpolator ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT , min , max , yMin , yMax ) ; }
assertEquals ( NUMBER_CONSTANT , es . solve ( b ) . subtract ( xRef ) . getNorm () , NUMBER_CONSTANT ) ;
{ interpolator = new DummyStepInterpolator ( yTmp , forward ) ; }
{ super ( interpolator ) ; }
{ super(); }
public BadStepInterpolator ( double [] y , boolean forward ) { super ( y , forward ) ; }
DummyStepInterpolator interpolator = new DummyStepInterpolator ( y , true ) ;
{ interpolator = new DummyStepInterpolator ( yTmp , forward ) ; }
{ interpolator = new DummyStepInterpolator ( y , forward ) ; }
{ handler . handleStep ( new StepInterpolatorWrapper ( interpolator , ode . getDimension () , ode . getParametersDimension () ) , isLast ) ; }
final ParameterizedODEWithJacobians ode
{ super(); setMean ( mean ) ; setStandardDeviation ( sd ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setTolerance ( NUMBER_CONSTANT ) ; }
{ super ( f , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( p < NUMBER_CONSTANT ) { return getMean () ; } else { return Double.MAX_VALUE ; } }
{ ret = - getMean () * Math . log ( NUMBER_CONSTANT - p ) ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - x / getMean () ) ; }
public ExponentialDistributionImpl ( double mean ) { super(); setMean ( mean ) ; }
{ return getUpperDomain ( getSampleSize () , getNumberOfSuccesses () ) ; }
{ return getLowerDomain ( getPopulationSize () , getNumberOfSuccesses () , getSampleSize () ) ; }
{ ret = Beta . regularizedBeta ( getProbabilityOfSuccess () , getNumberOfSuccesses () , x + NUMBER_CONSTANT ) ; }
{ super(); setNumberOfSuccesses ( r ) ; setProbabilityOfSuccess ( p ) ; }
if ( p < NUMBER_CONSTANT ) { ret = getAlpha () * getBeta () ; } else { ret = Double.MAX_VALUE ; }
{ ret = Gamma . regularizedGammaP ( getAlpha () , x / getBeta () ) ; }
{ super(); setAlpha ( alpha ) ; setBeta ( beta ) ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - Math . pow ( x / getScale () , getShape () ) ) ; }
{ super(); setShape ( alpha ) ; setScale ( beta ) ; }
public TDistributionImpl ( double degreesOfFreedom ) { super(); setDegreesOfFreedom ( degreesOfFreedom ) ; }
{ return Double.MIN_VALUE * getGamma () . getBeta () ; }
{ return getGamma () . cumulativeProbability ( x ) ; }
if ( x <= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else if ( x >= getNumberOfElements () ) { return NUMBER_CONSTANT ; }
if ( x <= NUMBER_CONSTANT || x > getNumberOfElements () ) { return NUMBER_CONSTANT ; }
{ setNumberOfElements ( numberOfElements ) ; setExponent ( exponent ) ; }
double d = getDenominatorDegreesOfFreedom () ;
{ super(); setNumeratorDegreesOfFreedom ( numeratorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; }
x < NUMBER_CONSTANT || x > getNumberOfTrials ()
{ return getNumberOfTrials () ; }
{ super(); setNumberOfTrials ( trials ) ; setProbabilityOfSuccess ( p ) ; }
if ( p < NUMBER_CONSTANT ) { ret = getMean () ; } else { ret = Double.MAX_VALUE ; }
if ( p < NUMBER_CONSTANT ) { ret = - Double.MAX_VALUE ; } else { ret = getMean () ; }
if ( p < NUMBER_CONSTANT ) { ret = getMedian () ; } else { ret = Double.MAX_VALUE ; }
if ( p < NUMBER_CONSTANT ) { ret = - Double.MAX_VALUE ; } else { ret = getMedian () ; }
{ super(); setMedian ( median ) ; setScale ( s ) ; }
public LaguerreSolver () { super ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
protected void setDistribution ( ContinuousDistribution distribution ) { this . distribution = distribution ; }
public TDistributionImpl ( double degreesOfFreedom ) { super(); setDegreesOfFreedomInternal ( degreesOfFreedom ) ; }
{ super(); setNumeratorDegreesOfFreedomInternal ( numeratorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedomInternal ( denominatorDegreesOfFreedom ) ; }
{ super(); setShapeInternal ( alpha ) ; setScaleInternal ( beta ) ; }
{ super(); setAlphaInternal ( alpha ) ; setBetaInternal ( beta ) ; }
public ExponentialDistributionImpl ( double mean ) { super(); setMeanInternal ( mean ) ; }
{ super(); setMedianInternal ( median ) ; setScaleInternal ( s ) ; }
final double [] row = aInv [ i ] ;
{ p = interpolator . interpolate ( xval , wyval , zval ) ; Assert . fail ( STRING_CONSTANT ) ; }
int length = eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = eliminateZeroMassPoints ( densityPoints , densityValues ) ;
if ( ak2 == NUMBER_CONSTANT ) { rank = k ; return; }
if ( ak2 < NUMBER_CONSTANT ) { rank = k ; return; }
if ( ak2 == NUMBER_CONSTANT ) { rank = k ; return; }
assertTrue ( MathUtils . equals ( Double.NaN , Double.NaN , NUMBER_CONSTANT ) ) ;
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( residuals.length != observations.length ) { throw new FunctionEvaluationException ( point , STRING_CONSTANT , residuals.length , observations.length ) ; }
if ( observations.length != scale . getColumnDimension () ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , observations.length , scale . getColumnDimension () ) ; }
if ( observations.length != weights.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , observations.length , weights.length ) ; }
if ( dimension == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , minSingularValue , singularValues [ NUMBER_CONSTANT ] ) ; }
catch ( DuplicateSampleAbscissaException e ) { throw new FunctionEvaluationException ( e , z , e . getPattern () , e . getArguments () ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , value , p , q ) ; }
{ super ( STRING_CONSTANT , value , maxIterations ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . wholeFormat = format ; }
final String specifier
if ( sampleStats . getN () == NUMBER_CONSTANT ) { throw MathRuntimeException . createEOFException ( STRING_CONSTANT , url ) ; }
if ( r < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , r ) ; }
if ( b.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v.length != getColumnDimension () ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || zval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( STRING_CONSTANT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , columns ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , columns , length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ super ( pattern , arguments ) ; }
String specifier
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
{ if ( newDegreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , newDegreesOfFreedom ) ; } this . degreesOfFreedom = newDegreesOfFreedom ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( sampleSize <= NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new MathRuntimeException ( new UnsupportedOperationException () , STRING_CONSTANT ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( successes < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , successes ) ; } numberOfSuccesses = successes ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . scale = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . shape = alpha ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public Double getZ () { throw new MathRuntimeException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( observations.length < NUMBER_CONSTANT ) { throw new OptimizationException ( STRING_CONSTANT , observations.length , NUMBER_CONSTANT ) ; }
if ( e . compareTo ( BigInteger.ZERO ) < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
{ if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; } return k . pow ( e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( lcm == Long.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , a , b ) ; }
if ( lcm == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , a , b ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREE_MESSAGE , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREE_MESSAGE , n ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POLYNOMIAL_FUNCTION_MESSAGE ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( NON_POLYNOMIAL_FUNCTION_MESSAGE ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , nRows , nCols ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( offset > NUMBER_CONSTANT ) { throw new EventException ( STRING_CONSTANT , t ) ; }
{ throw new DerivativeException ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( ( c1 / c2 < NUMBER_CONSTANT ) || ( c2 / c3 < NUMBER_CONSTANT ) ) { throw new OptimizationException ( STRING_CONSTANT ) ; }
{ super ( FAILED_EVALUATION_MESSAGE , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
{ super ( FAILED_EVALUATION_MESSAGE , argument ) ; this . argument = new double [] { argument } ; }
{ super ( cause , pattern , arguments ) ; }
{ super ( pattern , arguments ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
if ( target.length != weights.length ) { throw new OptimizationException ( STRING_CONSTANT , target.length , weights.length ) ; }
if ( rows <= cols ) { throw new OptimizationException ( STRING_CONSTANT , rows , cols ) ; }
catch ( InvalidMatrixException ime ) { throw new OptimizationException ( STRING_CONSTANT ) ; }
if ( objective.length != rows ) { throw new FunctionEvaluationException ( point , STRING_CONSTANT , objective.length , rows ) ; }
if ( jacobian.length != rows ) { throw new FunctionEvaluationException ( point , STRING_CONSTANT , jacobian.length , rows ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , data.length , n ) ; } }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , pos , size , d.length ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , abscissa , i1 , i2 ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( STRING_CONSTANT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , nRows , nCols ) ; }
{ double d = getDimension () ; if ( d != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , d , n ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
{ super ( pattern , arguments ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( ( minimalIterationCount <= NUMBER_CONSTANT ) || ( maximalIterationCount <= minimalIterationCount ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , minimalIterationCount , maximalIterationCount ) ; } }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new IntegratorException ( STRING_CONSTANT , minStep , Math . abs ( h ) ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , data.length , n ) ; } }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( NON_FITTING_POSITION_AND_SIZE_MESSAGE , pos , size , d.length ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( NON_FITTING_POSITION_AND_SIZE_MESSAGE , pos , size , d.length ) ; }
if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
{ throw MathRuntimeException . createIllegalArgumentException ( NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( newMean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , newMean ) ; } this . mean = newMean ; }
if ( isDefaultValue ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
{ if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; } quantile = p ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
{ if ( getDimension () != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , getDimension () , n ) ; } }
if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( MISSING_ROOTS_OF_UNITY_MESSAGE ) ; }
if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( MISSING_ROOTS_OF_UNITY_MESSAGE ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( MISSING_ROOTS_OF_UNITY_MESSAGE ) ; } return isForward ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( NOT_POWER_OF_TWO_MESSAGE , o.length ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( NOT_POWER_OF_TWO_MESSAGE , d.length ) ; } }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , s ) ; } this . exponent = s ; }
{ if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; } this . numberOfElements = n ; }
if ( i < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , i ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , initialCapacity ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( STRING_CONSTANT , index ) ; }
if ( expansion <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , expansion ) ; }
if ( numElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( STRING_CONSTANT ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . numeratorFormat = format ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . denominatorFormat = format ; }
if ( nSteps <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , name ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( Double . isInfinite ( norm2 ) || Double . isNaN ( norm2 ) ) { throw new OptimizationException ( STRING_CONSTANT , rows , cols ) ; }
public CardanEulerSingularityException ( boolean isCardan ) { super ( isCardan ? STRING_CONSTANT : STRING_CONSTANT ) ; }
if ( arrayDimension != expected ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , arrayDimension , expected ) ; }
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( DIMENSION_MISMATCH_MESSAGE , n , startConfiguration.length ) ; }
if ( steps [ j ] == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EQUAL_VERTICES_MESSAGE , j , j + NUMBER_CONSTANT ) ; }
{ if ( microsphereElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , microsphereElements ) ; } this . microsphereElements = elements ; }
{ if ( brightnessExponent < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , brightnessExponent ) ; } this . brightnessExponent = brightnessExponent ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
throw new OptimizationException ( STRING_CONSTANT ) ;
if ( nRows == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( nCols == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; }
if ( sigma <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , sigma ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , len ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , len ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
if ( Double . isInfinite ( norm2 ) || Double . isNaN ( norm2 ) ) { throw new EstimationException ( STRING_CONSTANT , rows , cols ) ; }
{ if ( sd <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , sd ) ; } standardDeviation = sd ; }
if ( ( str = filePointer . readLine () ) == null ) { throw MathRuntimeException . createEOFException ( STRING_CONSTANT , valuesFileURL ) ; }
if ( ( empiricalDistribution == null ) || ( empiricalDistribution . getBinStats () . size () == NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; }
{ if ( newBeta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , newBeta ) ; } this . beta = newBeta ; }
{ if ( newAlpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , newAlpha ) ; } this . alpha = newAlpha ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( getN () > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , getN () ) ; } }
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( vector . getDimension () != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( vector . getDimension () != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nCols ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , f.length ) ; }
{ if ( size < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , size ) ; } sampleSize = size ; }
{ if ( size <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , size ) ; } populationSize = size ; }
{ if ( num < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , num ) ; } numberOfSuccesses = num ; }
final String pattern
if ( xval.length != yval.length ) { throw new MathException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , xval.length , yval.length ) ; }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , s ) ; } scale = s ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( STRING_CONSTANT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
String pattern
String pattern
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ;
catch ( ClassCastException cce ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( vector . getDimension () != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( vector . getDimension () != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nCols ) ; }
{ if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return d [ NUMBER_CONSTANT ] . getField () ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
throw new NotARotationMatrixException ( STRING_CONSTANT , i - NUMBER_CONSTANT ) ;
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
{ if ( BigInteger.ZERO . equals ( fraction.numerator ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; } return multiply ( fraction . reciprocal () ) ; }
if ( BigInteger.ZERO . equals ( bg ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; }
{ if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
if ( y0 * y1 >= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT , min , max , y0 , y1 ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . wholeFormat = format ; }
{ super ( STRING_CONSTANT , dimension1 , dimension2 ) ; this . dimension1 = dimension1 ; this . dimension2 = dimension2 ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FUNCTION_MESSAGE ) ; } }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( trials < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , trials ) ; } numberOfTrials = trials ; }
{ if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , lower , initial , upper ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( f [ NUMBER_CONSTANT ] != NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , f [ NUMBER_CONSTANT ] ) ; }
{ if ( realFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . realFormat = realFormat ; }
{ if ( imaginaryFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . imaginaryFormat = imaginaryFormat ; }
if ( imaginaryCharacter == null || imaginaryCharacter . length () == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ; }
catch ( ClassCastException ex ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getClass () . getName () ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getClass () . getName () ) ; }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FRACTION ) ; }
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( OVERFLOW_MESSAGE , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
{ super ( STRING_CONSTANT , rows , columns ) ; }
final String specifier
if ( m <= p ) { throw new EstimationException ( STRING_CONSTANT , m , p ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT ) ; }
if ( ++ costEvaluations > maxCostEval ) { throw new EstimationException ( STRING_CONSTANT , maxCostEval ) ; }
{ if ( in [ i ] < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , i , in [ i ] ) ; } }
{ if ( in [ i ] <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , i , in [ i ] ) ; } }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ;
if ( Double . isNaN ( optima [ NUMBER_CONSTANT ] ) ) { throw new OptimizationException ( STRING_CONSTANT , starts ) ; }
{ if ( optimaValues == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optimaValues . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , columns ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , columns , length ) ; }
catch ( InvalidMatrixException e ) { throw new OptimizationException ( STRING_CONSTANT ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTH_MISMATCH_MESSAGE , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTH_MISMATCH_MESSAGE , b.length , m ) ; }
if ( xval.length == NUMBER_CONSTANT || xval [ NUMBER_CONSTANT ] == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( sampleSize <= NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( OUT_OF_RANGE_POINT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( WRONG_ORDER_ENDPOINTS_MESSAGE , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( WRONG_ORDER_ENDPOINTS_MESSAGE , x0 , x1 ) ; }
catch ( IllegalAccessException e2 ) { throw MathRuntimeException . createIllegalArgumentException ( ILLEGAL_ACCESS_MESSAGE , SET_QUANTILE_METHOD_NAME , percentileImpl . getClass () . getName () ) ; }
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , windowSize ) ; } }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( mean.length != standardDeviation.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean.length , standardDeviation.length ) ; }
{ throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , i , k , x [ i ] ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT + original . getClass () . getSimpleName () ) ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT , n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( sum == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , lower , upper ) ; } }
{ throw MathRuntimeException . createIllegalArgumentException ( OUT_OF_RANGE_ROOT_INDEX_MESSAGE , k , NUMBER_CONSTANT , omegaCount - NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( OUT_OF_RANGE_ROOT_INDEX_MESSAGE , k , NUMBER_CONSTANT , omegaCount - NUMBER_CONSTANT ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , lower , upper ) ; } }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , lower , upper ) ; } }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
catch ( NoSuchMethodException e1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , percentileImpl . getClass () . getName () ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
public NotStrictlyPositiveException ( Number value ) { super ( LocalizedFormats.NOT_STRICTLY_POSITIVE , value ) ; }
public NotPositiveException ( Number value ) { super ( LocalizedFormats.NOT_POSITIVE , value ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
if ( x.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( x.length , NUMBER_CONSTANT , true ) ; }
if ( x.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( x.length , NUMBER_CONSTANT , true ) ; }
if ( mean.length != standardDeviation.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , mean.length , standardDeviation.length ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_UPPER_BOUND , n ) ; }
{ return value . clone () ; }
{ return point . clone () ; }
{ return point . clone () ; }
final double [] scale = new double [ y0.length ] ;
catch ( IllegalStateException ise ) {}
{ super ( specific , LocalizedFormats.NO_DATA , null ) ; }
a [ i ] [ j ] [ k ] = aV [ i + N * j + N2 * k ]
{ return ( value == null ? null : value . clone () ) ; }
{ return ( point == null ? null : point . clone () ) ; }
super ( specific , ( boundIsAllowed ? LocalizedFormats.NUMBER_TOO_SMALL : LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED ) , wrong , min ) ;
startConfiguration == null || startConfiguration.length != startPoint.length
{ return ( point == null ? null : point . clone () ) ; }
public GoalType getGoalType () { return goal ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , column , NUMBER_CONSTANT , getColumnDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , row , NUMBER_CONSTANT , getRowDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
public void remove () { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
if ( populationLimit < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ ret = addAndCheck ( a , - b , msg ) ; }
if ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
{ return addAndCheck ( a , b , STRING_CONSTANT ) ; }
if ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
catch ( ArithmeticException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
{ checkOrder ( val , Order.Direction.INCREASING , true ) ; }
{ this ( wrong , previous , index , MathUtils.Order.Direction.INCREASING , true ) ; }
if ( e [ i + NUMBER_CONSTANT ] == NUMBER_CONSTANT && i >= j ) continue;
arguments = flatten ( args ) . toArray () ;
public void remove () { throw MathRuntimeException . createUnsupportedOperationException ( LocalizedFormats.UNSUPPORTED_OPERATION ) ; }
if ( idxStep == NUMBER_CONSTANT ) { throw new ZeroNotAllowedException () ; }
if ( idxStep == NUMBER_CONSTANT ) { throw new ZeroNotAllowedException () ; }
if ( observations == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( d == NUMBER_CONSTANT ) { throw new ZeroNotAllowedException () ; }
if ( d == NUMBER_CONSTANT ) { throw new ZeroNotAllowedException () ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FRACTION ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FRACTION ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FRACTION ) ; }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
@ Test ( expected = ZeroNotAllowedException . class )
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , xArray.length , yArray.length ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_COVARIANCE_MATRIX ) ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; } }
if ( function == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
final double [] grad = jacobian [ i ] ;
{ this ( cause , argument , new DummyLocalizable ( pattern ) , argument ) ; }
{ this ( cause , argument , new DummyLocalizable ( pattern ) , argument ) ; }
{ this ( argument , new DummyLocalizable ( pattern ) , argument ) ; }
{ this ( argument , new DummyLocalizable ( pattern ) , argument ) ; }
step *= Math . max ( NUMBER_CONSTANT , yA / yB )
return Math . sqrt ( sum / v.length ) ;
{ return Math . sqrt ( getChiSquare () / rows ) ; }
double wi = Math . sqrt ( residualsWeights [ i ] ) ;
{ this . h = Math . abs ( h ) ; this . handler = handler ; reset () ; }
double invR3 = NUMBER_CONSTANT / ( r2 * Math . sqrt ( r2 ) ) ;
double expected = Math . random () ;
double expected = Math . random () ;
return Math . sqrt ( sum2 ) ;
final int pEnd = Math . min ( pStart + BLOCK_SIZE , rows ) ;
final int pEnd = Math . min ( pStart + BLOCK_SIZE , rows ) ;
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double t = Math . abs ( rValues . getEntry ( i , j ) ) / stdErrors . getEntry ( i , j ) ;
assertEquals ( n + STRING_CONSTANT + degree + STRING_CONSTANT + i , reference , result , NUMBER_CONSTANT * ( NUMBER_CONSTANT + Math . abs ( reference ) ) ) ;
NUMBER_CONSTANT * ( NUMBER_CONSTANT + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( NUMBER_CONSTANT ) ) ) )
return Math . sqrt ( dx * dx + dy * dy ) ;
assertTrue ( Math . sqrt ( m.length ) * estimator . getRMS ( problem ) > NUMBER_CONSTANT ) ;
{ assertTrue ( Math . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
{ assertTrue ( Math . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
assertTrue ( Math . sqrt ( problem.target.length ) * optimizer . getRMS () > NUMBER_CONSTANT ) ;
{ sumLog += Math . log ( values [ i ] ) ; }
{ value += Math . log ( d ) ; n ++ ; }
{ ret = - mean * Math . log ( NUMBER_CONSTANT - p ) ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - x / mean ) ; }
{ if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } return Math . exp ( - x / mean ) / mean ; }
{ sum += Math . abs ( p1 [ i ] - p2 [ i ] ) ; }
{ return ( Math . exp ( x ) - Math . exp ( - x ) ) / NUMBER_CONSTANT ; }
float factor = ( float ) Math . pow ( NUMBER_CONSTANT , scale ) * sign ;
{ return Math . log ( x ) / Math . log ( base ) ; }
return Math . abs ( u ) + Math . abs ( v ) ;
return Math . abs ( u ) + Math . abs ( v ) ;
final boolean isEqual = Math . abs ( xInt - yInt ) <= maxUlps ;
{ return equalsIncludingNaN ( x , y ) || ( Math . abs ( y - x ) <= eps ) ; }
{ return equals ( x , y , NUMBER_CONSTANT ) || Math . abs ( y - x ) <= eps ; }
{ return ( Math . exp ( x ) + Math . exp ( - x ) ) / NUMBER_CONSTANT ; }
return Math . floor ( result + NUMBER_CONSTANT ) ;
double sigma = NUMBER_CONSTANT + Math . random () ;
double mu = Math . random () ;
double x = NUMBER_CONSTANT / Math . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / Math . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / Math . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / Math . sqrt ( NUMBER_CONSTANT ) ;
double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( f.length ) ;
double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( n ) ;
{ double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( f.length ) ; return scaleArray ( fft ( f , true ) , scaling_coefficient ) ; }
double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( f.length ) ;
double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( n ) ;
{ double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( f.length ) ; return scaleArray ( fft ( f , false ) , scaling_coefficient ) ; }
{ return Math . atan2 ( getImaginary () , getReal () ) ; }
Math . abs ( c ) < Math . abs ( d )
Math . abs ( dt ) <= Math . ulp ( stepStart )
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
assertEquals ( Math.PI , x , accuracy ) ;
{ double x = UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; assertEquals ( Math.PI , x , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( STRING_CONSTANT , expected , result , Math . ulp ( NUMBER_CONSTANT ) ) ;
Assert . assertEquals ( STRING_CONSTANT , expected , result , Math . ulp ( NUMBER_CONSTANT ) ) ;
{ singularValues [ i ] = Math . sqrt ( Math . abs ( singularValues [ i ] ) ) ; }
{ result [ i ] = Math . sqrt ( sigma * betaVariance [ i ] [ i ] ) ; }
double fpos = Math . floor ( pos ) ;
final double dist = Math . abs ( z - x [ i ] ) ;
setMaxGrowth ( Math . pow ( NUMBER_CONSTANT , - exp ) ) ;
setMaxGrowth ( Math . pow ( NUMBER_CONSTANT , - exp ) ) ;
FastFourierTransformer . scaleArray ( x , Math . sqrt ( x.length / NUMBER_CONSTANT ) ) ;
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double tolerance = Math . max ( relativeAccuracy * z . abs () , absoluteAccuracy ) ;
double sqrt = Math . sqrt ( c [ ir ] [ ir ] ) ;
int k = Math . max ( N , seed.length )
{ values [ i ] = Math . pow ( values [ i ] , d ) ; }
double t = Math . abs ( t ( m , mu , v , n ) ) ;
{ return ( m - mu ) / Math . sqrt ( v / n ) ; }
{ stepStart = Double.NaN ; stepSize = Math . sqrt ( minStep * maxStep ) ; }
{ assertEquals ( msg , expected , actual , Math . abs ( tolerance * actual ) ) ; }
Gamma . digamma ( Math . pow ( NUMBER_CONSTANT , - n ) )
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double range = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double range = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
double absAi = Math . abs ( coefficients [ i ] ) ;
{ ret = median + scale * Math . tan ( Math.PI * ( p - NUMBER_CONSTANT ) ) ; }
return ( NUMBER_CONSTANT / Math.PI ) * ( scale / ( dev * dev + scale * scale ) ) ;
Double pi = Double . valueOf ( Math.PI ) ;
final int pEnd = Math . min ( pStart + BLOCK_SIZE , rows ) ;
final int pEnd = Math . min ( pStart + BLOCK_SIZE , rows ) ;
{ stdDev [ i ] = Math . sqrt ( matrix . getEntry ( i , i ) ) ; }
( int ) ( Math . abs ( NUMBER_CONSTANT * x + NUMBER_CONSTANT * y ) ) % NUMBER_CONSTANT == NUMBER_CONSTANT
( int ) ( Math . abs ( NUMBER_CONSTANT * x + NUMBER_CONSTANT * y ) ) % NUMBER_CONSTANT == NUMBER_CONSTANT
assertTrue ( Math . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( Math . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( Math . abs ( walk ) < NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * Math . sqrt ( NUMBER_CONSTANT ) ) , sample . getStandardDeviation () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * Math . sqrt ( NUMBER_CONSTANT ) ) , sample . getStandardDeviation () , NUMBER_CONSTANT ) ;
if ( value != i ) { res += Math . abs ( value - i ) ; }
{ value += NUMBER_CONSTANT / Math . pow ( k , m ) ; }
return ( NUMBER_CONSTANT / Math . pow ( x , exponent ) ) / generalizedHarmonic ( numberOfElements , exponent ) ;
widthSufficient = Math . min ( lowerBinMass , upperBinMass ) * sampleSize >= minExpectedCount ;
return Math . sqrt ( criterion / wm.length ) ;
double factor = - Math . sqrt ( wm . getWeight () ) ;
{ assertTrue ( Math . abs ( value - expected ) < NUMBER_CONSTANT ) ; }
public double end () { return Math . sqrt ( sum ) ; }
{ return Math . atan2 ( x , y ) ; }
{ return Math . pow ( x , y ) ; }
accum3 /= variance * Math . sqrt ( variance ) ;
( n0 * moment.m3 ) / ( ( n0 - NUMBER_CONSTANT ) * ( n0 - NUMBER_CONSTANT ) * Math . sqrt ( variance ) * variance )
assertEquals ( Math . exp ( NUMBER_CONSTANT ) , u . getGeometricMean () , NUMBER_CONSTANT ) ;
{ return Math . asin ( z / getNorm () ) ; }
{ return Math . atan2 ( y , x ) ; }
double x = Math . random () ;
assertTrue ( Math . abs ( generated [ NUMBER_CONSTANT ] - NUMBER_CONSTANT ) > NUMBER_CONSTANT ) ;
{ return new HarmonicFunction ( a * omega , omega , phi + Math.PI / NUMBER_CONSTANT ) ; }
{ return a * Math . cos ( omega * x + phi ) ; }
Complex sqrtz = ComplexUtils . polar2Complex ( Math . sqrt ( r ) , theta / NUMBER_CONSTANT ) ;
TestUtils . assertEquals ( new Complex ( Math . acos ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) , Complex.ZERO . acos () , NUMBER_CONSTANT ) ;
{ assertTrue ( Math . abs ( value - reference ) < NUMBER_CONSTANT ) ; }
long index = Math . round ( ( Math . random () ) * testArray.length ) ;
{ length = list . size () - Math . max ( NUMBER_CONSTANT , list . size () - windowSize ) ; }
double c = t2 + NUMBER_CONSTANT * ( Math . exp ( - NUMBER_CONSTANT * t2 ) - NUMBER_CONSTANT ) ;
double t = NUMBER_CONSTANT * Math.PI ;
double t = NUMBER_CONSTANT * Math.PI ;
assertEquals ( Math . sqrt ( NUMBER_CONSTANT ) , e1 . distanceFrom ( e2 ) , NUMBER_CONSTANT ) ;
error = Math . sqrt ( error / scale.length ) * errfac [ currentDegree - NUMBER_CONSTANT ] ;
Math . log ( x ) - NUMBER_CONSTANT / x
double expected = Math . random () ;
double expected = Math . random () ;
final double power = Math . pow ( normalizedAbscissa , order ) ;
assertEquals ( Math . sqrt ( NUMBER_CONSTANT ) , Vector3D . distance ( v1 , v2 ) , NUMBER_CONSTANT ) ;
assertEquals ( Math . sqrt ( NUMBER_CONSTANT ) , new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getNorm () , NUMBER_CONSTANT ) ;
{ return Math . exp ( sumOfLogs . getResult () / sumOfLogs . getN () ) ; }
{ Assert . assertEquals ( Math . pow ( NUMBER_CONSTANT , x ) , f . value ( x ) , NUMBER_CONSTANT ) ; }
this . convergence = Math . abs ( convergence ) ;
final int capacity = ( int ) Math . ceil ( expectedSize / LOAD_FACTOR ) ;
double fl = Math . floor ( x ) ;
{ return cumulativeProbability ( ( int ) Math . floor ( x ) ) ; }
{ assertTrue ( Math . abs ( value - reference ) < NUMBER_CONSTANT ) ; }
{ double absError = Math . abs ( expected ) * relativeError ; Assert . assertEquals ( msg , expected , actual , absError ) ; }
return - mean * Math . log ( unif ) ;
double sigma = Math . sqrt ( mean ) ;
if ( Math . abs ( x1 - x0 ) <= absoluteAccuracy ) { setResult ( x1 , i ) ; return x1 ; }
double delta = Math . abs ( getEntry ( i ) - v [ i ] ) ;
{ double delta = Math . abs ( getEntry ( i ) - v [ i ] ) ; max += delta ; }
return Math . sqrt ( res ) ;
return Math . sqrt ( res ) ;
{ return Math . abs ( value ) < epsilon ; }
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
{ assertTrue ( Math . abs ( value - expected ) < NUMBER_CONSTANT ) ; }
new Fraction ( Math.PI , NUMBER_CONSTANT )
{ new Fraction ( ( NUMBER_CONSTANT + Math . sqrt ( NUMBER_CONSTANT ) ) / NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
max = Math . max ( max , Math . abs ( delta ) ) ;
max = Math . max ( max , Math . abs ( delta ) ) ;
{ final double delta = data [ i ] - v [ i ] ; sum += Math . abs ( delta ) ; }
sum += Math . abs ( delta ) ;
return Math . sqrt ( sum ) ;
return Math . sqrt ( sum ) ;
for ( double a : data ) { max = Math . max ( max , Math . abs ( a ) ) ; }
for ( double a : data ) { sum += Math . abs ( a ) ; }
return Math . sqrt ( sum ) ;
{ data [ i ] = Math . ulp ( data [ i ] ) ; }
{ data [ i ] = Math . signum ( data [ i ] ) ; }
{ data [ i ] = Math . rint ( data [ i ] ) ; }
{ data [ i ] = Math . floor ( data [ i ] ) ; }
{ data [ i ] = Math . ceil ( data [ i ] ) ; }
{ data [ i ] = Math . cbrt ( data [ i ] ) ; }
{ data [ i ] = Math . sqrt ( data [ i ] ) ; }
{ data [ i ] = Math . abs ( data [ i ] ) ; }
{ data [ i ] = Math . atan ( data [ i ] ) ; }
{ data [ i ] = Math . asin ( data [ i ] ) ; }
{ data [ i ] = Math . acos ( data [ i ] ) ; }
{ data [ i ] = Math . tan ( data [ i ] ) ; }
{ data [ i ] = Math . sin ( data [ i ] ) ; }
{ data [ i ] = Math . cos ( data [ i ] ) ; }
{ data [ i ] = Math . tanh ( data [ i ] ) ; }
{ data [ i ] = Math . sinh ( data [ i ] ) ; }
{ data [ i ] = Math . cosh ( data [ i ] ) ; }
{ data [ i ] = Math . log1p ( data [ i ] ) ; }
{ data [ i ] = Math . log10 ( data [ i ] ) ; }
{ data [ i ] = Math . log ( data [ i ] ) ; }
{ data [ i ] = Math . expm1 ( data [ i ] ) ; }
{ data [ i ] = Math . exp ( data [ i ] ) ; }
{ data [ i ] = Math . pow ( data [ i ] , d ) ; }
i < Math . min ( rows , columns )
final double inv = NUMBER_CONSTANT / Math . sqrt ( norm2 ) ;
{ if ( Math . abs ( value - searchArray [ i ] ) < tolerance ) { found = true ; } i ++ ; }
Math . abs ( dt ) <= Math . ulp ( stepStart )
this . step = Math . abs ( step ) ;
final int p = Math . min ( m , n ) ;
double range = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double range = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
{ return ( int ) Math . min ( randomData . nextPoisson ( mean ) , Integer.MAX_VALUE ) ; }
normal . setStandardDeviation ( Math . sqrt ( p ) ) ;
if ( unequalCounts ) { weight = Math . sqrt ( ( double ) countSum1 / ( double ) countSum2 ) ; }
if ( Math . abs ( sumExpected - sumObserved ) > NUMBER_CONSTANT ) { ratio = sumObserved / sumExpected ; rescale = true ; }
final double s17 = Math . sqrt ( NUMBER_CONSTANT ) ;
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
{ norm = Math . max ( norm , Math . abs ( e . getValue () ) ) ; }
{ norm += Math . abs ( e . getValue () ) ; }
return Math . sqrt ( sum ) ;
return Math . sqrt ( d ) ;
return Math . sqrt ( dx * dx + dy * dy ) ;
assertEquals ( NUMBER_CONSTANT , Math . sqrt ( circle . getM () ) * rms , NUMBER_CONSTANT ) ;
return a * Math . cos ( omega * x + phi ) ;
final double f = NUMBER_CONSTANT / Math . sqrt ( normSq ) ;
{ if ( getN () > NUMBER_CONSTANT ) { stdDev = Math . sqrt ( getVariance () ) ; } else { stdDev = NUMBER_CONSTANT ; } }
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
assertTrue ( Math . abs ( h ) < minStep ) ;
double maxStep = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
{ if ( getN () > NUMBER_CONSTANT ) { stdDev = Math . sqrt ( getVariance () ) ; } else { stdDev = NUMBER_CONSTANT ; } }
double [] y0 = { Math . sin ( a ) , Math . cos ( a ) } ;
new double [] { - Math . sqrt ( NUMBER_CONSTANT ) , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT }
{ new BigReal ( NUMBER_CONSTANT ) , BigReal.ONE , BigReal.ZERO , new BigReal ( NUMBER_CONSTANT ) , new BigReal ( Math.PI ) , new BigReal ( - NUMBER_CONSTANT ) }
if ( deltaNorm > NUMBER_CONSTANT * Math . max ( NUMBER_CONSTANT , initialNorm ) ) { return false ; }
assertEquals ( Math.PI , MathUtils . scalb ( Math.PI , NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
MathUtils . hash ( new double [] { MathUtils . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) } )
assertEquals ( i + STRING_CONSTANT , Math . log ( factorial ( i ) ) , MathUtils . factorialLog ( i ) , NUMBER_CONSTANT ) ;
new double [] { MathUtils . nextAfter ( MathUtils . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT ) }
MathUtils . equals ( new double [] { NUMBER_CONSTANT } , new double [] { MathUtils . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) } )
ret = Math . exp ( p1 + p2 - p3 ) ;
{ return Math . min ( k , m ) ; }
{ return Math . max ( NUMBER_CONSTANT , m - ( n - k ) ) ; }
{ return NUMBER_CONSTANT * ( NUMBER_CONSTANT - distribution . cumulativeProbability ( Math . abs ( getSlope () ) / getSlopeStdErr () ) ) ; }
{ return Math . sqrt ( getMeanSquareError () / sumXX ) ; }
double result = Math . sqrt ( getRSquare () ) ;
if ( Math . abs ( sumXX ) < NUMBER_CONSTANT * Double.MIN_VALUE ) { return Double.NaN ; }
@ Override public double value ( double d ) { return Math . ulp ( d ) ; }
@ Override public double value ( double d ) { return Math . signum ( d ) ; }
@ Override public double value ( double d ) { return Math . rint ( d ) ; }
@ Override public double value ( double d ) { return Math . cosh ( d ) ; }
@ Override public double value ( double d ) { return Math . acos ( d ) ; }
@ Override public double value ( double d ) { return Math . cos ( d ) ; }
@ Override public double value ( double d ) { return Math . log10 ( d ) ; }
@ Override public double value ( double d ) { return Math . log ( d ) ; }
@ Override public double value ( double d ) { return Math . floor ( d ) ; }
@ Override public double value ( double d ) { return Math . ceil ( d ) ; }
@ Override public double value ( double d ) { return Math . cbrt ( d ) ; }
@ Override public double value ( double d ) { return Math . tanh ( d ) ; }
@ Override public double value ( double d ) { return Math . tan ( d ) ; }
@ Override public double value ( double d ) { return Math . atan ( d ) ; }
@ Override public double value ( double d ) { return Math . asin ( d ) ; }
@ Override public double value ( double d ) { return Math . expm1 ( d ) ; }
@ Override public double value ( double d ) { return Math . exp ( d ) ; }
@ Override public double value ( double d ) { return Math . sinh ( d ) ; }
@ Override public double value ( double d ) { return Math . sqrt ( d ) ; }
@ Override public double value ( double d ) { return Math . sin ( d ) ; }
@ Override public double value ( double d ) { return Math . abs ( d ) ; }
new BigFraction ( Math.PI , NUMBER_CONSTANT )
{ new BigFraction ( ( NUMBER_CONSTANT + Math . sqrt ( NUMBER_CONSTANT ) ) / NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
FastFourierTransformer . scaleArray ( x , Math . sqrt ( NUMBER_CONSTANT * ( x.length - NUMBER_CONSTANT ) ) ) ;
double c = Math . exp ( t0 - t ) ;
assertEquals ( NUMBER_CONSTANT , Math . sqrt ( circle . getN () ) * optimizer . getRMS () , NUMBER_CONSTANT ) ;
{ product *= Math . pow ( values [ i ] , weights [ i ] ) ; }
FastFourierTransformer . scaleArray ( x2 , NUMBER_CONSTANT / Math . sqrt ( x2.length ) ) ;
assertNotSame ( v , new ArrayRealVector ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT + Math . ulp ( NUMBER_CONSTANT ) } ) ) ;
double scaling_coefficient = Math . sqrt ( NUMBER_CONSTANT / ( n - NUMBER_CONSTANT ) ) ;
double scaling_coefficient = Math . sqrt ( NUMBER_CONSTANT / ( f.length - NUMBER_CONSTANT ) ) ;
if ( Math . abs ( fn1 - fn ) <= threshold ) return o ;
assertNotSame ( v , new OpenMapRealVector ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT + Math . ulp ( NUMBER_CONSTANT ) } ) ) ;
Math . sin ( i * Math.PI / n ) * ( f [ i ] + f [ n - i ] )
double scaling_coefficient = Math . sqrt ( NUMBER_CONSTANT / n ) ;
{ double scaling_coefficient = Math . sqrt ( NUMBER_CONSTANT / f.length ) ; return FastFourierTransformer . scaleArray ( fst ( f ) , scaling_coefficient ) ; }
double tmp2 = Math . exp ( tmp1 ) ;
double tmp2 = Math . sqrt ( tmpSquare ) ;
double absTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
Math . abs ( max - min ) <= absoluteAccuracy
assertEquals ( ci , l40 [ i ] , Math . abs ( ci ) * NUMBER_CONSTANT ) ;
Math . abs ( Tk . value ( x ) ) < ( NUMBER_CONSTANT + NUMBER_CONSTANT )
double tmp2 = Math . exp ( tmp1 ) ;
double tmp2 = Math . sqrt ( tmpSquare ) ;
assertEquals ( mi , vi , paramsAccuracy * ( NUMBER_CONSTANT + Math . abs ( mi ) ) ) ;
assertEquals ( theoreticalMinCost , Math . sqrt ( m ) * rms , threshold ) ;
{ assertTrue ( Math . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
final int capacity = ( int ) Math . ceil ( expectedSize / LOAD_FACTOR ) ;
{ return Math . sqrt ( variance . evaluate ( values , mean ) ) ; }
{ return Math . sqrt ( variance . evaluate ( values , mean , begin , length ) ) ; }
{ return Math . sqrt ( variance . evaluate ( values , begin , length ) ) ; }
{ return Math . sqrt ( variance . evaluate ( values ) ) ; }
@ Override public double getResult () { return Math . sqrt ( variance . getResult () ) ; }
minor < Math . min ( m , n )
j < Math . min ( i + NUMBER_CONSTANT , n )
int row = Math . min ( m , n ) - NUMBER_CONSTANT
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
catch ( OptimizationException e ) { assertTrue ( ( ! solvable ) && ( degree > NUMBER_CONSTANT ) ) ; }
RealConvergenceChecker convergenceChecker
public GoalType getGoalType () { return optimizationGoal ; }
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
catch ( OptimizationException ee ) {}
assertTrue ( Double . isNaN ( sum . getResult () ) ) ;
@ Override public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
public SumOfSquares () { n = NUMBER_CONSTANT ; value = Double.NaN ; }
assertTrue ( Double . isNaN ( sumSq . getResult () ) ) ;
@ Override public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
public Sum () { n = NUMBER_CONSTANT ; value = Double.NaN ; }
assertTrue ( Double . isNaN ( statistic . getResult () ) ) ;
assertTrue ( Double . isNaN ( statistic . getResult () ) ) ;
@ Override public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
public Product () { n = NUMBER_CONSTANT ; value = Double.NaN ; }
assertTrue ( Double . isNaN ( product . getResult () ) ) ;
{ return NUMBER_CONSTANT + ( sign < < NUMBER_CONSTANT ) + ( nans < < NUMBER_CONSTANT ) + exp + mant . hashCode () ; }
@ Override protected int getNumberOfRegressors () { return x [ NUMBER_CONSTANT ] . length ; }
@ Override protected int getNumberOfRegressors () { return x [ NUMBER_CONSTANT ] . length ; }
final boolean isMinim = ( getGoalType () == GoalType.MINIMIZE ) ;
public Well44497b ( long seed ) { super ( seed ) ; }
{ super ( seed ) ; }
public Well44497b ( int seed ) { super ( seed ) ; }
public Well44497b () {}
public Well19937c ( long seed ) { super ( seed ) ; }
{ super ( seed ) ; }
public Well19937c ( int seed ) { super ( seed ) ; }
public Well19937c () {}
v [ indexRm2 ] &= mp ;
v [ indexRm2 ] &= mp ;
v [ indexRm2 ] &= mp ;
v [ indexRm2 ] &= mp ;
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , columns ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIFFERENT_ROWS_LENGTHS , columns , length ) ; }
{ super ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , wrong , expected ) ; dimension = expected ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , columns ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIFFERENT_ROWS_LENGTHS , columns , length ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
dist . setMean ( NUMBER_CONSTANT ) ;
{ this ( p , new NormalDistributionImpl () ) ; }
distribution . setDegreesOfFreedom ( df ) ;
{ distribution . setDegreesOfFreedom ( expected.length - NUMBER_CONSTANT ) ; return NUMBER_CONSTANT - distribution . cumulativeProbability ( chiSquare ( expected , observed ) ) ; }
double density ( Double x ) ;
( FastMath . max ( FastMath . abs ( mij ) , Math . abs ( mji ) ) * eps )
protected AbstractContinuousDistribution () { super(); }
org.apache.commons.math.distribution.FDistributionImpl fd = new org.apache.commons.math.distribution.FDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( n > NUMBER_CONSTANT ) { distribution . setDegreesOfFreedom ( n - NUMBER_CONSTANT ) ; }
if ( n > NUMBER_CONSTANT ) { distribution . setDegreesOfFreedom ( n - NUMBER_CONSTANT ) ; }
@ SuppressWarnings ( STRING_CONSTANT ) private RandomAdaptor () {}
return a . dotrap ( DfpField.FLAG_INVALID , STRING_CONSTANT , a , a . newInstance ( ( byte ) NUMBER_CONSTANT , ( byte ) Dfp.QNAN ) ) ;
if ( ia > NUMBER_CONSTANT ) { return a . newInstance ( ( byte ) NUMBER_CONSTANT , ( byte ) Dfp.INFINITE ) ; }
protected AbstractIntegerDistribution () { super(); }
public int [] getSizes () { return Arrays . copyOf ( size , dimension ) ; }
this . size = Arrays . copyOf ( size , dimension ) ;
public int [] getCounts () { return Arrays . copyOf ( counter , dimension ) ; }
final double [] d = Arrays . copyOf ( direc [ i ] , n ) ;
AbstractMultipleLinearRegression regression = ( AbstractMultipleLinearRegression ) createRegression () ;
{ try { ExponentialDistribution distribution = new ExponentialDistributionImpl ( NUMBER_CONSTANT ) ; } catch ( NotStrictlyPositiveException e ) {} }
{ realVectorFormat . parseObject ( STRING_CONSTANT ) ; }
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
zb += ( za - temp2 ) ;
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
{ setQuantile ( p ) ; }
if ( isDefaultValue ( norm ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
{ this ( n , DEFAULT_RHO , DEFAULT_KHI , DEFAULT_GAMMA , DEFAULT_SIGMA ) ; }
public MultiDirectionalSimplex ( final int n ) { this ( n , DEFAULT_KHI , DEFAULT_GAMMA ) ; }
catch ( FunctionEvaluationException ee ) { assertTrue ( shouldFail ) ; }
try { es . getInverse () ; fail ( STRING_CONSTANT ) ; } catch ( InvalidMatrixException ime ) {}
catch ( FunctionEvaluationException oe ) {}
{ super ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ; dimension = expected ; }
catch ( InvalidMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
@ Test ( expected = NotPositiveDefiniteMatrixException . class )
@ Test ( expected = NotPositiveDefiniteMatrixException . class )
@ Test ( expected = NotSymmetricMatrixException . class )
catch ( InvalidMatrixException ime ) {}
catch ( InvalidMatrixException ime ) {}
catch ( NotPositiveDefiniteMatrixException e ) { fail ( STRING_CONSTANT ) ; }
public LaguerreSolver () { super ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; p = null ; }
{ return MessageFactory . buildMessage ( locale , pattern , LocalizedFormats.USER_EXCEPTION , arguments ) ; }
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( FunctionEvaluationException fe ) { assertTrue ( exceptionExpected ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
{ try { return mapToSelf ( ComposableFunction.ULP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TANH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SQRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SINH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIGNUM ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.RINT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
try { return mapToSelf ( BinaryFunction.POW . fix2ndArgument ( d ) ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; }
try { return mapToSelf ( BinaryFunction.MULTIPLY . fix1stArgument ( d ) ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; }
{ try { return mapToSelf ( ComposableFunction.LOG1P ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG10 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.INVERT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.FLOOR ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXPM1 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
try { return mapToSelf ( BinaryFunction.DIVIDE . fix2ndArgument ( d ) ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; }
{ try { return mapToSelf ( ComposableFunction.COSH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.COS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CEIL ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CBRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ATAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ACOS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ABS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
{ return x + y ; }
Circle circle = new Circle () ;
Circle circle = new Circle () ;
Circle circle = new Circle () ;
ConvergenceException ex
assertTrue ( handler . getMaximalValueError () < NUMBER_CONSTANT ) ;
public RealVector mapPowToSelf ( double d ) { return mapToSelf ( BinaryFunction.POW . fix2ndArgument ( d ) ) ; }
{ if ( d != NUMBER_CONSTANT ) { return mapToSelf ( BinaryFunction.ADD . fix1stArgument ( d ) ) ; } return this ; }
{ if ( ++ iterations > maxIterations ) { throw new OptimizationException ( new MaxIterationsExceededException ( maxIterations ) ) ; } }
throw new MaxIterationsExceededException ( maximalIterationCount ) ;
{ throw new MaxIterationsExceededException ( maxIterations ) ; }
if ( n >= maxIterations ) { throw new MaxIterationsExceededException ( maxIterations , LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION , x ) ; }
if ( dimension == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE , minSingularValue , singularValues [ NUMBER_CONSTANT ] ) ; }
{ return solve ( f , Double.NaN , Double.NaN , startValue ) ; }
StringBuffer buffer
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer msgBuffer = new StringBuffer () ;
StringBuffer out = new StringBuffer ( msg ) ;
StringBuffer messageBuffer = new StringBuffer () ;
StringBuffer s = new StringBuffer () ;
final StringBuffer buff = new StringBuffer ( STRING_CONSTANT ) ;
StringBuffer msgBuffer = new StringBuffer () ;
StringBuffer sb = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
Assert . assertEquals ( FastMath.PI , solver . solve ( f , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , solver . getAbsoluteAccuracy () ) ;
result = solver . solve ( f , min , max ) ;
{ this ( new SimpleVectorialValueChecker () , Integer.MAX_VALUE ) ; }
{ this ( new SimpleScalarValueChecker () , Integer.MAX_VALUE ) ; }
@ Test ( expected = java.lang.IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = java.lang.IllegalArgumentException . class )
catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p ) ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p ) ; }
if ( x1 < x0 ) { throw new NumberIsTooSmallException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 , true ) ; }
if ( x1 < x0 ) { throw new NumberIsTooSmallException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 , true ) ; }
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( new BlockRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . multiply ( new BlockRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( new BlockRealMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ if ( a < NUMBER_CONSTANT ) { ret = a - b ; } else { throw new ArithmeticException ( msg ) ; } }
try { optimizer . getOptima () ; fail ( STRING_CONSTANT ) ; } catch ( IllegalStateException ise ) {}
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.OVERFLOW_IN_FRACTION , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
{ try { UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {} }
{ try { UnivariateRealSolverUtils . solve ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail () ; } catch ( IllegalArgumentException ex ) {} }
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
if ( begin + length > values.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END ) ; }
try { m . preMultiply ( new Array2DRowRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . multiply ( new Array2DRowRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( new Array2DRowRealMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { StatUtils . min ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { StatUtils . max ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { StatUtils . mean ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ NumberFormat f = getDefaultNumberFormat ( locale ) ; return new ComplexFormat ( f ) ; }
public ComplexFormat ( String imaginaryCharacter ) { this ( imaginaryCharacter , getDefaultNumberFormat () ) ; }
{ return new Vector3DFormat ( getDefaultNumberFormat ( locale ) ) ; }
{ this ( prefix , suffix , separator , getDefaultNumberFormat () ) ; }
if ( ! found ) { Assert . fail ( msg + STRING_CONSTANT + ComplexFormat . formatComplex ( z ) ) ; }
formatDouble ( vector . getEntry ( i ) , format , toAppendTo , pos ) ;
{ return new RealVectorFormat ( getDefaultNumberFormat ( locale ) ) ; }
{ this ( prefix , suffix , separator , getDefaultNumberFormat () ) ; }
Class type
{ this ( imaginaryCharacter , format , ( NumberFormat ) format . clone () ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
throw MathRuntimeException . createInternalError ( null ) ;
throw MathRuntimeException . createInternalError ( null ) ;
try { alg = MessageDigest . getInstance ( STRING_CONSTANT ) ; } catch ( NoSuchAlgorithmException ex ) { throw MathRuntimeException . createInternalError ( ex ) ; }
denseOutput = requiresDenseOutput () || ( ! eventsHandlersManager . isEmpty () ) ;
{ super . addStepHandler ( handler ) ; denseOutput = requiresDenseOutput () || ( ! eventsHandlersManager . isEmpty () ) ; initializeArrays () ; }
denseOutput = requiresDenseOutput () || ( ! eventsHandlersManager . isEmpty () ) ;
denseOutput = requiresDenseOutput () || ( ! eventsHandlersManager . isEmpty () ) ;
stepStart = acceptStep ( interpolator , stepHandlers , y , yDot , t ) ;
stepStart = acceptStep ( interpolator , stepHandlers , y , yDot , t ) ;
final double temp = sinEpsA * NUMBER_CONSTANT ;
final double tmp = hiPrec [ NUMBER_CONSTANT ] * NUMBER_CONSTANT ;
if ( x >= NUMBER_CONSTANT || x <= - NUMBER_CONSTANT ) { return x ; }
if ( y >= NUMBER_CONSTANT || y <= - NUMBER_CONSTANT ) { return pow ( - x , y ) ; }
final double epsilon = xa - EIGHTHES [ idx ] ;
final double epsilon = xa - EIGHTHES [ idx ] ;
final boolean fatal = false ;
final boolean fatal = true ;
if ( invx == NUMBER_CONSTANT ) { if ( x > NUMBER_CONSTANT ) { return y ; } else { return getSign ( y ) * Math.PI ; } }
if ( xa == NUMBER_CONSTANT ) { return leftPlane ? getSign ( xa ) * Math.PI : xa ; }
@ Test
{ return Math . round ( x ) ; }
final double [] d = copyOf ( direc [ i ] , n ) ;
public int [] getSizes () { return copyOf ( size , dimension ) ; }
this . size = copyOf ( size , dimension ) ;
public int [] getCounts () { return copyOf ( counter , dimension ) ; }
{ return oneWayAnova . anovaTest ( categoryData , alpha ) ; }
{ return oneWayAnova . anovaPValue ( categoryData ) ; }
{ return oneWayAnova . anovaFValue ( categoryData ) ; }
{ return unknownDistributionChiSquareTest . chiSquareTestDataSetsComparison ( observed1 , observed2 , alpha ) ; }
{ return unknownDistributionChiSquareTest . chiSquareTestDataSetsComparison ( observed1 , observed2 ) ; }
{ return unknownDistributionChiSquareTest . chiSquareDataSetsComparison ( observed1 , observed2 ) ; }
{ return chiSquareTest . chiSquareTest ( counts ) ; }
{ return chiSquareTest . chiSquareTest ( counts , alpha ) ; }
{ return chiSquareTest . chiSquareTest ( expected , observed ) ; }
{ return chiSquareTest . chiSquareTest ( expected , observed , alpha ) ; }
{ return chiSquareTest . chiSquare ( counts ) ; }
{ return chiSquareTest . chiSquare ( expected , observed ) ; }
{ return tTest . tTest ( sampleStats1 , sampleStats2 ) ; }
{ return tTest . tTest ( sampleStats1 , sampleStats2 , alpha ) ; }
{ return tTest . tTest ( sample1 , sample2 ) ; }
{ return tTest . tTest ( sample1 , sample2 , alpha ) ; }
{ return tTest . tTest ( mu , sampleStats ) ; }
{ return tTest . tTest ( mu , sampleStats , alpha ) ; }
{ return tTest . tTest ( mu , sample ) ; }
{ return tTest . tTest ( mu , sample , alpha ) ; }
{ return tTest . t ( sampleStats1 , sampleStats2 ) ; }
{ return tTest . t ( sample1 , sample2 ) ; }
{ return tTest . t ( mu , sampleStats ) ; }
{ return tTest . t ( mu , observed ) ; }
{ return tTest . pairedTTest ( sample1 , sample2 ) ; }
{ return tTest . pairedTTest ( sample1 , sample2 , alpha ) ; }
{ return tTest . pairedT ( sample1 , sample2 ) ; }
{ return tTest . homoscedasticTTest ( sampleStats1 , sampleStats2 ) ; }
{ return tTest . homoscedasticTTest ( sample1 , sample2 ) ; }
{ return tTest . homoscedasticTTest ( sample1 , sample2 , alpha ) ; }
{ return tTest . homoscedasticT ( sampleStats1 , sampleStats2 ) ; }
{ return tTest . homoscedasticT ( sample1 , sample2 ) ; }
protected TestUtils () { super(); }
return ( double ) y ;
RealMatrix arzneg = selectColumns ( arz , Arrays . copyOf ( arReverseIndex , mu ) ) ;
double numer = ( bits & NUMBER_CONSTANT ) ;
statesInitialized = false ;
statesInitialized = false ;
statesInitialized = false ;
statesInitialized = false ;
statesInitialized = false ;
ParametricRealFunction sif = new SimpleInverseFunction () ;
ParametricRealFunction sif = new SimpleInverseFunction () ;
final ParametricRealFunction f
final ParametricRealFunction f
final ParametricRealFunction f
final double g = Gaussian . this . value ( x ) ;
{ fitter = new CurveFitter ( optimizer ) ; }
final boolean fatal = false ;
{ super ( null , specific , LocalizedFormats.ILLEGAL_STATE , args ) ; }
{ super ( null , null , specific , general , args ) ; }
{ super ( null , null , LocalizedFormats.CANNOT_PARSE , wrong , new Integer ( position ) ) ; }
{ assertEquals ( reference , p . toString () ) ; }
{ assertEquals ( reference , p . toString () ) ; }
assertEquals ( reference , p . multiply ( q ) . toString () ) ;
this . n = n ;
return isMinimize ? penalty : - penalty ;
if ( boundaries == null ) return true ;
return _isMinimize ? penalty : - penalty ;
if ( _boundaries == null ) return true ;
final FitnessFunction fitfun = new FitnessFunction ( boundaries , isMinimize ) ;
if ( result == - NUMBER_CONSTANT ) { throw new MathArithmeticException ( STRING_CONSTANT ) ; }
catch ( IOException ioe ) { assertEquals ( NUMBER_CONSTANT , ioe . getMessage () . length () ) ; }
super ( specific , LocalizedFormats.SAME_SIGN_AT_ENDPOINTS , lo , hi , fLo , fHi , args ) ;
{ this ( null , lo , hi , fLo , fHi ) ; }
{ super ( specific , LocalizedFormats.NO_DATA , ( Object [] ) null ) ; }
super ( specific , boundIsAllowed ? LocalizedFormats.NUMBER_TOO_LARGE : LocalizedFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED , wrong , max ) ;
{ this ( null , wrong , max , boundIsAllowed ) ; }
{ super ( specific , LocalizedFormats.OUT_OF_RANGE_SIMPLE , wrong , lo , hi ) ; this . lo = lo ; this . hi = hi ; }
{ this ( null , wrong , lo , hi ) ; }
super ( specific , LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ;
{ this ( null , wrong , expected ) ; }
{ this ( cause , LocalizedFormats.USER_EXCEPTION ) ; }
{ super ( specific , LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ; dimension = expected ; }
public ZeroException ( Localizable specific ) { super ( specific , LocalizedFormats.ZERO_NOT_ALLOWED , NUMBER_CONSTANT ) ; }
super ( specific , boundIsAllowed ? LocalizedFormats.NUMBER_TOO_SMALL : LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED , wrong , min ) ;
{ this ( null , wrong , min , boundIsAllowed ) ; }
{ super ( specific , LocalizedFormats.NOT_FINITE_NUMBER , wrong , args ) ; }
{ this ( null , wrong , args ) ; }
{ super ( specific , LocalizedFormats.MAX_COUNT_EXCEEDED , max , args ) ; this . max = max ; }
public MaxCountExceededException ( Number max ) { this ( null , max ) ; }
public MathInternalError ( final Throwable cause ) { super ( LocalizedFormats.INTERNAL_ERROR , REPORT_URL ) ; }
{ super ( null , null , LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
{ ++ count ; assertEquals ( i + j / NUMBER_CONSTANT , value , NUMBER_CONSTANT ) ; }
{ ++ count ; assertEquals ( i + j / NUMBER_CONSTANT , value , NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
{ assertEquals ( NUMBER_CONSTANT , l . getEntry ( i , j ) , NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
{ assertEquals ( NUMBER_CONSTANT , m . getEntry ( i , j ) , NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
@ Override protected void doFinalize ( ) throws MathUserException { throw new MathUserException ( LocalizedFormats.SIMPLE_MESSAGE , null ) ; }
@ Override protected void doFinalize ( ) throws MathUserException { throw new MathUserException () ; }
catch ( IOException ioe ) {}
{ super ( cause ) ; addMessage ( LocalizedFormats.USER_EXCEPTION , null ) ; }
private Erf () { super(); }
private Beta () { super(); }
private Gamma () { super(); }
assertEquals ( STRING_CONSTANT , s . getN () , u . getN () ) ;
@ Override
{ assertEquals ( a1 , MathUtils . normalizeAngle ( a2 , a1 ) , NUMBER_CONSTANT ) ; }
@ Override public void tearDown () { refValues = null ; matrix = null ; }
@ Override
{ assertTrue ( isIncludedColumn ( eigenVector , ed . getV () , tolerance ) ) ; }
@ Override
@ Override public void setUp () { f = new Frequency () ; }
@ Override public void tearDown () { pb = null ; integ = null ; }
@ Override
assertTrue ( bestFinal . compareTo ( bestInitial ) > NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertTrue ( Double . isNaN ( statistic . getResult () ) ) ; }
{ double variance = regression . estimateRegressandVariance () ; assertTrue ( variance > NUMBER_CONSTANT ) ; }
{ double [] [] variance = regression . estimateRegressionParametersVariance () ; assertEquals ( getNumberOfRegressors () , variance.length ) ; }
{ double [] e = regression . estimateResiduals () ; assertEquals ( getSampleSize () , e.length ) ; }
{ double [] beta = regression . estimateRegressionParameters () ; assertEquals ( getNumberOfRegressors () , beta.length ) ; }
{ FractionField field = FractionField . getInstance () ; assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { assertEquals ( Fraction.ONE , FractionField . getInstance () . getOne () ) ; }
@ Test public void testZero () { assertEquals ( Fraction.ZERO , FractionField . getInstance () . getZero () ) ; }
assertTrue ( fitnessCalls <= neededCalls ) ;
assertEquals ( NUMBER_CONSTANT , numDifferent ) ;
{ try { new DummyBinaryChromosome ( repr ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException e ) {} }
assertEquals ( c3 , population . getFittestChromosome () ) ;
{ assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ assertEquals ( null , expected , actual , delta ) ; }
{ BigRealField field = BigRealField . getInstance () ; assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { assertEquals ( BigReal.ONE , BigRealField . getInstance () . getOne () ) ; }
@ Test public void testZero () { assertEquals ( BigReal.ZERO , BigRealField . getInstance () . getZero () ) ; }
assertTrue ( uniquePointIsCenter ) ;
assertEquals ( p , TestUtils . serializeAndRecover ( p ) ) ;
assertEquals ( STRING_CONSTANT , s . getN () , u . getN () ) ;
assertEquals ( expected . getN () , observed . getN () ) ;
try { new Fraction ( a , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( ConvergenceException ce ) {}
{ assertEquals ( y [ i ] , iResult [ i ] ) ; }
assertTrue ( FastMath . abs ( h ) < minStep ) ;
catch ( FractionConversionException fce ) { fail ( fce . getMessage () ) ; }
catch ( FractionConversionException fce ) { fail ( fce . getMessage () ) ; }
{ DummyRandomKey drk = new DummyRandomKey ( RandomKey . randomPermutation ( NUMBER_CONSTANT ) ) ; assertNotNull ( drk ) ; }
assertEquals ( NUMBER_CONSTANT , nextGeneration . getPopulationSize () ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
assertEquals ( STRING_CONSTANT + p , expected , actual , NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT + x , expected , actual , NUMBER_CONSTANT ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
@ Override public void tearDown () { pb = null ; integ = null ; }
@ Override
{ BigFractionField field = BigFractionField . getInstance () ; assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { assertEquals ( BigFraction.ONE , BigFractionField . getInstance () . getOne () ) ; }
@ Test public void testZero () { assertEquals ( BigFraction.ZERO , BigFractionField . getInstance () . getZero () ) ; }
fail ( STRING_CONSTANT ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
assertEquals ( approYDot , yDot [ i ] , threshold ) ;
{ ComplexField field = ComplexField . getInstance () ; assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { assertEquals ( Complex.ONE , ComplexField . getInstance () . getOne () ) ; }
@ Test public void testZero () { assertEquals ( Complex.ZERO , ComplexField . getInstance () . getZero () ) ; }
if ( isLast ) { assertTrue ( maxError > NUMBER_CONSTANT ) ; }
@ Override public void setUp () { tooShortStats = new SummaryStatistics () ; tooShortStats . addValue ( NUMBER_CONSTANT ) ; }
assertTrue ( maxError < NUMBER_CONSTANT ) ;
if ( isLast ) { assertTrue ( maxError > NUMBER_CONSTANT ) ; }
if ( isLast ) { assertTrue ( maxError > NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , changes ) ;
{ if ( column > row ) { assertEquals ( NUMBER_CONSTANT , value , entryTolerance ) ; } }
{ if ( column < row ) { assertEquals ( NUMBER_CONSTANT , value , entryTolerance ) ; } }
assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
public NoDataException ( Localizable specific ) { super ( specific , null ) ; }
double [] param
double [] param
final double [] parameters
double [] parameters
double [] param
double [] param
double [] param
double [] param
double [] param
double [] param
double [] doubles
double [] parameters
double [] param
double [] param
UnivariateRealIntegrator integrator = new LegendreGaussIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
public void setMinimalIterationCount ( int count ) { minimalIterationCount = count ; }
public Set < String > getContextKeys () { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
public Object getContext ( String key ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
final double [] z = concatinateSamples ( x , y ) ;
public double getRelativeAccuracy ( ) ;
public double getAbsoluteAccuracy ( ) ;
public int getMaximalIterationCount ( ) ;
public Set < String > getContextKeys () { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
public Object getContext ( String key ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
Assert . assertEquals ( new PearsonsCorrelation () . correlation ( x , y ) , corrInstance . getCorrelationMatrix () . getEntry ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , Double.MIN_VALUE ) ;
{ new PearsonsCorrelation () . correlation ( one , two ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertTrue ( Double . isNaN ( new PearsonsCorrelation () . correlation ( noVariance , values ) ) ) ;
Assert . assertEquals ( PearsonsCorrelation . correlation ( x , y ) , corrInstance . getCorrelationMatrix () . getEntry ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , Double.MIN_VALUE ) ;
{ PearsonsCorrelation . correlation ( one , two ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertTrue ( Double . isNaN ( PearsonsCorrelation . correlation ( noVariance , values ) ) ) ;
normps = norm ( ps ) ;
normps = norm ( ps ) ;
{ this ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; }
final SimplexTableau tableau = new SimplexTableau ( function , linearConstraints , goal , nonNegative , epsilon ) ;
if ( MathUtils . compareTo ( entry , minValue , getEpsilon ( entry ) ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
if ( MathUtils . compareTo ( entry , NUMBER_CONSTANT , getEpsilon ( entry ) ) > NUMBER_CONSTANT ) { columnsToDrop . add ( i ) ; }
{ addMessage ( pattern , args ) ; }
{ addMessage ( LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
{ super ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; this . max = max ; }
{ super ( cause ) ; addMessage ( pattern , arguments ) ; }
{ addMessage ( pattern , arguments ) ; }
{ super ( cause ) ; addMessage ( LocalizedFormats.USER_EXCEPTION ) ; }
{ addMessage ( pattern , args ) ; }
{ super ( cause ) ; addMessage ( pattern , args ) ; }
{ addMessage ( pattern , args ) ; }
{ addMessage ( pattern , args ) ; }
{ addMessage ( pattern , args ) ; }
{ super ( LocalizedFormats.EVALUATIONS , max ) ; }
this . field = data [ NUMBER_CONSTANT ] . getField () ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayRealVector ( out ) ;
return new Array2DRowFieldMatrix < T > ( outData , false ) ;
{ super ( extractField ( d ) ) ; copyIn ( d ) ; }
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
return new Array2DRowFieldMatrix < T > ( outData , false ) ;
return new Array2DRowFieldMatrix < T > ( outData , false ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix < Fraction > ( testDataInv ) ) , identity , entryTolerance ) ;
return new Array2DRowFieldMatrix < BigFraction > ( Hdata ) ;
return new Array2DRowFieldMatrix < T > ( bp , false ) ;
return new ArrayFieldVector < T > ( bp , false ) ;
{ return projection ( new ArrayFieldVector < T > ( v , false ) ) ; }
return new Array2DRowFieldMatrix < T > ( d , false ) ;
Assert . assertEquals ( new Array2DRowFieldMatrix < Fraction > ( fractionColMatrix ) , MatrixUtils . createFieldMatrix ( fractionColMatrix ) ) ;
return new ArrayFieldVector < T > ( outData , false ) ;
return new ArrayFieldVector < T > ( outData , false ) ;
String source
{ this ( prefix , suffix , separator , CompositeFormat . getDefaultNumberFormat () ) ; }
public Vector3DFormat ( final NumberFormat format ) { this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_SEPARATOR , format ) ; }
public Vector3DFormat () { this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_SEPARATOR , CompositeFormat . getDefaultNumberFormat () ) ; }
final BSPTreeVisitor visitor
void visitLeafNode ( BSPTree node ) ;
BSPTree node
BSPTree node
Hyperplane other
Point point
final Hyperplane other
final Point2D p
final Hyperplane other
final Point2D p
final Point2D tmp = loop [ min ] ;
final Point2D [] bLoop
Point3D point = p . intersection ( l ) ;
public Order visitOrder ( final BSPTree node ) { return Order.MINUS_SUB_PLUS ; }
public BoundaryProjector () { projected = new PolygonsSet ( new BSPTree ( Boolean.FALSE ) ) ; }
final BSPTree tree
Point3D [] points
final BSPTree tree
public Order visitOrder ( final BSPTree node ) { return Order.MINUS_SUB_PLUS ; }
final Hyperplane other
final Point point
final Point3D p
origin = new Point3D ( - originOffset , w ) ;
public Order visitOrder ( final BSPTree node ) { return Order.MINUS_SUB_PLUS ; }
final BSPTree tree
public abstract SplitSubHyperplane < S > split ( Hyperplane < S > hyperplane ) ;
public abstract Side side ( Hyperplane < S > hyperplane ) ;
{ if ( in [ i ] < NUMBER_CONSTANT ) { throw new NotPositiveException ( in [ i ] ) ; } }
{ if ( val < NUMBER_CONSTANT || val > NUMBER_CONSTANT ) { throw new InvalidRepresentationException ( STRING_CONSTANT ) ; } }
for ( int i : chromosomeRepresentation ) { if ( i < NUMBER_CONSTANT || i > NUMBER_CONSTANT ) throw new InvalidRepresentationException ( STRING_CONSTANT ) ; }
clusters = transformer . cluster ( Arrays . asList ( points ) , NUMBER_CONSTANT , NUMBER_CONSTANT )
public RealVector getInitialStateEstimate () { return initialStateEstimate ; }
if ( t == NUMBER_CONSTANT && i >= j ) continue;
{ if ( maxGenerations <= NUMBER_CONSTANT ) throw new IllegalArgumentException ( STRING_CONSTANT ) ; this . maxGenerations = maxGenerations ; }
if ( ! forward ) h = - h ;
if ( remA > NUMBER_CONSTANT ) break;
if ( remA > NUMBER_CONSTANT ) break;
if ( remA > NUMBER_CONSTANT ) break;
if ( x * x == NUMBER_CONSTANT ) return Double.NaN ;
{ for ( Chromosome anotherChr : population ) { if ( this . isSame ( anotherChr ) ) return anotherChr ; } return null ; }
if ( y . equals ( py ) ) break;
if ( x < NUMBER_CONSTANT ) return NUMBER_CONSTANT ;
if ( boundaries == null ) return x ;
if ( boundaries == null ) return x ;
if ( negccov > negcovMax ) negccov = negcovMax ;
{ numElements -= i ; if ( front ) startIndex += i ; }
{ super ( relativeAccuracy , absoluteAccuracy , Method.SECANT ) ; }
public SecantSolver ( final double absoluteAccuracy ) { super ( absoluteAccuracy , Method.SECANT ) ; }
{ this . allowedSolutions = allowedSolutions ; return super . solve ( maxEval , f , min , max , startValue ) ; }
{ super ( relativeAccuracy , absoluteAccuracy ) ; this . allowedSolutions = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ super ( absoluteAccuracy ) ; this . allowedSolutions = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ se [ i ] = FastMath . sqrt ( rank ) ; continue; }
if ( ! Double . isNaN ( var ) && var > Double.MIN_VALUE ) { return FastMath . sqrt ( rank ) ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
{ if ( isNaN () ) { return Complex.NaN ; } return createComplex ( FastMath . log ( abs () ) , FastMath . atan2 ( imaginary , real ) ) ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () || rhs . isNaN () ) { return NaN ; }
{ if ( isNaN () ) { return NaN ; } return createComplex ( - real , - imaginary ) ; }
if ( isNaN () || Double . isNaN ( rhs ) ) { return NaN ; }
if ( isNaN () || rhs . isNaN () ) { return NaN ; }
if ( isNaN () ) { return NUMBER_CONSTANT ; }
if ( isNaN () || rhs . isNaN () ) { return NaN ; }
{ if ( isNaN () ) { return NaN ; } return createComplex ( real , - imaginary ) ; }
if ( isNaN () ) { return Double.NaN ; }
{ if ( rng . nextBoolean () ) { throw new MathRuntimeException () ; } }
Assert . assertEquals ( w . getReal () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ include ( Arrays . copyOf ( x , x.length ) , NUMBER_CONSTANT , y ) ; }
if ( index < NUMBER_CONSTANT || index >= this . parameters . length ) { throw new IndexOutOfBoundsException ( STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT || index >= this . parameters . length ) { throw new IndexOutOfBoundsException ( STRING_CONSTANT ) ; }
{ return outerProduct ( ( ArrayRealVector ) v ) ; }
{ return getLInfDistance ( ( ArrayRealVector ) v ) ; }
{ return getL1Distance ( ( ArrayRealVector ) v ) ; }
{ return getDistance ( ( ArrayRealVector ) v ) ; }
{ return dotProduct ( ( ArrayRealVector ) v ) ; }
{ return ebeDivide ( ( ArrayRealVector ) v ) ; }
{ return ebeMultiply ( ( ArrayRealVector ) v ) ; }
{ return subtract ( ( ArrayRealVector ) v ) ; }
{ return add ( ( ArrayRealVector ) v ) ; }
{ super ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , Method.PEGASUS ) ; }
Assert . assertTrue ( z . isNaN () ) ;
{ return ( ( Integer ) node . getElement () ) . intValue () ; }
if ( numberOfVariables < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BrentSolver ( convergence ) ) ; }
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolutions.ABOVE_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolutions.BELOW_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolutions.RIGHT_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolutions.LEFT_SIDE ) ;
this . allowed = AllowedSolutions.ANY_SIDE ;
this . allowed = AllowedSolutions.ANY_SIDE ;
this . allowed = AllowedSolutions.ANY_SIDE ;
{ return solve ( maxEval , f , min , max , startValue , AllowedSolutions.ANY_SIDE ) ; }
{ super ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ super ( relativeAccuracy , absoluteAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ super ( absoluteAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
double x = FastMath . random () ;
double dot = dotProduct ( v1 , v2 ) ;
{ return new Solver ( singularValues , getUT () , getV () , getRank () == Math . max ( m , n ) ) ; }
tol = FastMath . max ( FastMath . max ( m , n ) * singularValues [ NUMBER_CONSTANT ] * EPS , FastMath . sqrt ( MathUtils.SAFE_MIN ) ) ;
{ super . setEntry ( row - NUMBER_CONSTANT , col - NUMBER_CONSTANT , value ) ; }
{ super . setEntry ( index - NUMBER_CONSTANT , value ) ; }
fsave = fval . getEntry ( NUMBER_CONSTANT ) ;
Vector3D . dotProduct ( crossP , otherPlane . getNormal () ) < NUMBER_CONSTANT
Vector3D . dotProduct ( crossP , otherPlane . getNormal () ) < NUMBER_CONSTANT
double scaled = area * Vector3D . dotProduct ( facetB , plane . getNormal () ) ;
final Vector3D n = new Vector3D ( NUMBER_CONSTANT , d , - Vector3D . dotProduct ( d , direction ) , direction ) ;
{ return Vector3D . dotProduct ( ( Vector3D ) point , w ) + originOffset ; }
{ setNormal ( normal ) ; originOffset = - Vector3D . dotProduct ( p , w ) ; setFrame () ; }
public Line revert () { return new Line ( zero , direction . negate () ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS , nRows , nCols ) ; }
{ setResult ( t ) ; return result ; }
if ( ( delta <= rLimit ) || ( delta <= absoluteAccuracy ) ) { setResult ( s ) ; return result ; }
if ( ( delta <= rLimit ) || ( delta <= absoluteAccuracy ) ) { setResult ( t ) ; return result ; }
RealVector v = AbstractRealVector . unmodifiableRealVector ( u . copy () ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u . copy () ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u ) ;
final RealVector x = new ArrayRealVector ( dim ) ;
final RealVector x = new ArrayRealVector ( dim ) ;
final double [] actual = x . getData () ;
final double [] actual = z . getData () ;
double [] d2 = w . getData () ;
{ return coefficients . dotProduct ( point ) + constantTerm ; }
dist = new EmpiricalDistributionImpl ( NUMBER_CONSTANT , null ) ;
public EmpiricalDistributionImpl ( int binCount ) { this ( binCount , null ) ; }
empiricalDistribution = new EmpiricalDistributionImpl ( binCount ) ;
return NUMBER_CONSTANT * ( NUMBER_CONSTANT + Erf . erf ( dev / ( standardDeviation * FastMath . sqrt ( NUMBER_CONSTANT ) ) ) ) ;
{ setConvergenceChecker ( new SimpleScalarValueChecker ( rel , abs ) ) ; }
@ Test ( expected = TooManyEvaluationsException . class )
{ solver . solve ( b . getColumn ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ solver . solve ( b . getColumn ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ es . solve ( b . getColumn ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ solver . solve ( b . getColumn ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertEquals ( z , Complex.NaN ) ;
Assert . assertEquals ( z , Complex.INF ) ;
final ExceptionContext cOut = new ExceptionContext () ;
final ExceptionContext cOut = new ExceptionContext () ;
final ExceptionContext c = new ExceptionContext () ;
final ExceptionContext c = new ExceptionContext () ;
final ExceptionContext c = new ExceptionContext () ;
@ Test ( expected = MathUserException . class )
@ Test ( expected = MathUserException . class )
MathUserException e
MathUserException e
int i = NUMBER_CONSTANT
final double [] x = b . getData () ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
double [] hatResiduals = I . subtract ( hat ) . operate ( model.Y ) . getData () ;
final double objectiveValue = computeObjectiveValue ( currentBest . getData () ) ;
f = computeObjectiveValue ( currentBest . getData () ) ;
final double [] actual = x . getData () ;
final double [] actual = x . getData () ;
final double [] actual = x . combine ( a , b , y ) . getData () ;
final double [] actual = x . combine ( a , b , y ) . getData () ;
Assert . assertNotSame ( STRING_CONSTANT , v1.data , v_copy . getData () ) ;
{ double sum = NUMBER_CONSTANT ; for ( double coefficient : coefficients . getData () ) { sum -= coefficient ; } return sum ; }
assertClose ( m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
public double [] getStateEstimation () { return stateEstimation . getData () ; }
double [] y = u . add ( x . operate ( b ) ) . getData () ;
TestUtils . assertEquals ( new double [] { - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , b . getData () , NUMBER_CONSTANT ) ;
TestUtils . assertEquals ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , - NUMBER_CONSTANT , NUMBER_CONSTANT } , b . getData () , NUMBER_CONSTANT ) ;
return e . getData () ;
{ RealVector b = calculateBeta () ; return b . getData () ; }
if ( x instanceof ArrayRealVector ) { return ( ( ArrayRealVector ) x ) . getDataRef () ; } else { return x . getData () ; }
if ( ltI [ i ] < absolutePositivityThreshold ) { throw new NonPositiveDefiniteMatrixException ( i , absolutePositivityThreshold ) ; }
{ return getIntercept ( getSlope () ) ; }
int i = FACT_LEN - NUMBER_CONSTANT
int i = FACT_LEN - NUMBER_CONSTANT
int i = FACT_LEN - NUMBER_CONSTANT
CholeskyDecomposition llt = new CholeskyDecompositionImpl ( matrix ) ;
CholeskyDecomposition llt = new CholeskyDecompositionImpl ( matrix ) ;
DecompositionSolver solver = new CholeskyDecompositionImpl ( s ) . getSolver () ;
DecompositionSolver solver = new CholeskyDecompositionImpl ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = new CholeskyDecompositionImpl ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
final RealMatrix matrix = EigenDecompositionImplTest . createTestMatrix ( new Random ( NUMBER_CONSTANT ) , refValues ) ;
EigenDecomposition eig = new EigenDecompositionImpl ( C , NUMBER_CONSTANT ) ;
EigenDecompositionImpl eig = new EigenDecompositionImpl ( C , NUMBER_CONSTANT ) ;
DecompositionSolver es = new EigenDecompositionImpl ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecompositionImpl ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecompositionImpl ( m , MathUtils.SAFE_MIN ) . getSolver () ;
EigenDecompositionImpl ed
EigenDecompositionImpl ed
RealMatrix v = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) . getV () ;
int max = val.length ;
int max = val.length ;
int max = val.length ;
throw new IllegalArgumentException () ;
throw new IllegalArgumentException () ;
throw new IllegalArgumentException () ;
throw new IllegalArgumentException () ;
double slope
double slope
double alpha
FieldDecompositionSolver < BigFraction > pSolver = new FieldLUDecompositionImpl < BigFraction > ( bigP ) . getSolver () ;
{ return new FieldLUDecompositionImpl < Fraction > ( m ) . getDeterminant () . doubleValue () ; }
solver = new FieldLUDecompositionImpl < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
solver = new FieldLUDecompositionImpl ( createFractionMatrix ( singular ) ) . getSolver () ;
solver = new FieldLUDecompositionImpl < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
@ Test ( expected = NonMonotonousSequenceException . class )
@ Test ( expected = NonMonotonousSequenceException . class )
catch ( NonMonotonousSequenceException iae ) {}
@ Test ( expected = NonMonotonousSequenceException . class )
@ Test ( expected = NonMonotonousSequenceException . class )
catch ( NonMonotonousSequenceException iae ) {}
final DecompositionSolver solver = new LUDecompositionImpl ( MatrixUtils . createRealMatrix ( jTj ) , threshold ) . getSolver () ;
DecompositionSolver solver = new LUDecompositionImpl ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = new LUDecompositionImpl ( MatrixUtils . createRealMatrix ( singular ) ) . getSolver () ;
DecompositionSolver solver = new LUDecompositionImpl ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = useLU ? new LUDecompositionImpl ( mA ) . getSolver () : new QRDecompositionImpl ( mA ) . getSolver () ;
return new LUDecompositionImpl ( XTOIX ) . getSolver () . getInverse () ;
RealMatrix inverse = new LUDecompositionImpl ( XTOIX ) . getSolver () . getInverse () ;
RealMatrix Rinv = new LUDecompositionImpl ( Raug ) . getSolver () . getInverse () ;
DecompositionSolver solver = useLU ? new LUDecomposition ( mA ) . getSolver () : new QRDecompositionImpl ( mA ) . getSolver () ;
{ super . newXSampleData ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecompositionImpl ( X ) ; }
RealMatrix x = new QRDecompositionImpl ( a ) . getSolver () . solve ( b ) ;
RealMatrix x = new QRDecompositionImpl ( a ) . getSolver () . solve ( b ) ;
DecompositionSolver solver = new QRDecompositionImpl ( MatrixUtils . createRealMatrix ( testData3x3Singular ) ) . getSolver () ;
DecompositionSolver solver = new QRDecompositionImpl ( MatrixUtils . createRealMatrix ( testData3x3NonSingular ) ) . getSolver () ;
final RectangularCholeskyDecomposition decomposition = new RectangularCholeskyDecompositionImpl ( covariance , small ) ;
final RectangularCholeskyDecomposition decomposition = new RectangularCholeskyDecompositionImpl ( covariance , small ) ;
SingularValueDecomposition svd = new SingularValueDecompositionImpl ( rm ) ;
DecompositionSolver solver = new SingularValueDecompositionImpl ( MatrixUtils . createRealMatrix ( testSquare ) ) . getSolver () ;
DecompositionSolver solver = new SingularValueDecompositionImpl ( m ) . getSolver () ;
DecompositionSolver solver = new SingularValueDecompositionImpl ( MatrixUtils . createRealMatrix ( testSquare ) ) . getSolver () ;
{ g0Positive = g0 >= NUMBER_CONSTANT ; nextAction = EventHandler.CONTINUE ; }
nextAction = EventHandler.CONTINUE ;
FirstOrderDifferentialEquations equations
final FirstOrderDifferentialEquations equations
final FirstOrderDifferentialEquations equations
{ out . writeDouble ( polynoms [ k ] [ l ] ) ; }
final double e = polynoms [ currentDegree ] [ i ] / scale [ i ] ;
Array . newInstance ( field . getZero () . getClass () , new int [] { m , nColB } )
bp = ( T [] ) Array . newInstance ( field . getZero () . getClass () , m )
bp = ( T [] ) Array . newInstance ( field . getZero () . getClass () , m )
{ return ( T [] ) Array . newInstance ( field . getZero () . getClass () , length ) ; }
array = ( T [] ) Array . newInstance ( field . getZero () . getClass () , length )
{ return ( T [] ) Array . newInstance ( field . getZero () . getClass () , length ) ; }
{ return ( T [] ) Array . newInstance ( field . getZero () . getClass () , length ) ; }
( T [] [] ) Array . newInstance ( zero . getClass () , new int [] { dimension , dimension } )
{ return ( T [] ) Array . newInstance ( field . getZero () . getClass () , length ) ; }
solver . solve ( a , b , null , false ) ;
final RealVector x = solver . solve ( a , m , b , null , false ) ;
final RealVector x = solver . solve ( a , m , b , null , false ) ;
solver . solve ( a , m , b , null , false ) ;
solver . solve ( a , m , b , null , false ) ;
solver . solve ( a , m , b , null , false ) ;
final RealVector x = solver . solve ( a , b , null , false ) ;
final RealVector x = solver . solve ( a , b , x0 , false ) ;
final RealVector x = solver . solve ( a , b , x0 , true ) ;
final RealVector x = solver . solve ( a , b , null , false ) ;
solver . solve ( a , b , x , false ) ;
solver . solve ( a , b , x , false ) ;
solver . solve ( a , b , x , false ) ;
solver . solve ( a , b , x , false ) ;
if ( nSteps <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS , name ) ; }
throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED , n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
catch ( ArithmeticException e ) {}
catch ( ParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
catch ( ParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
catch ( ParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
catch ( ParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
try { f1 . divide ( f2 ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( ArithmeticException ex ) {}
{ if ( getN () > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC , getN () ) ; } }
if ( i < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INDEX_NOT_POSITIVE , i ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INITIAL_CAPACITY_NOT_POSITIVE , initialCapacity ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.UNSUPPORTED_EXPANSION_MODE , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( LocalizedFormats.CANNOT_SET_AT_NEGATIVE_INDEX , index ) ; }
catch ( ClassCastException ex ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES , v . getClass () . getName () ) ; }
MathException cause = new MathConfigurationException ( inMsg ) ;
{ evaluations . incrementCount () ; equations . computeDerivatives ( t , y , yDot ) ; }
{ this . equations = equations ; }
allocateInterpolatedArrays ( y.length , primaryMapper , secondaryMappers ) ;
allocateInterpolatedArrays ( - NUMBER_CONSTANT , null , null ) ;
catch ( MathException ex ) { Assert . fail ( STRING_CONSTANT + mean + STRING_CONSTANT + p + STRING_CONSTANT + ex . getMessage () ) ; }
catch ( MathException ex ) { Assert . fail ( STRING_CONSTANT + mean + STRING_CONSTANT + x + STRING_CONSTANT + ex . getMessage () ) ; }
@ Test ( expected = NonPositiveDefiniteLinearOperatorException . class )
@ Test ( expected = NonSquareLinearOperatorException . class )
@ Test ( expected = NonPositiveDefiniteLinearOperatorException . class )
@ Test ( expected = NonSquareLinearOperatorException . class )
if ( ( str = filePointer . readLine () ) == null ) { throw MathRuntimeException . createEOFException ( LocalizedFormats.URL_CONTAINS_NO_DATA , valuesFileURL ) ; }
if ( ( empiricalDistribution == null ) || ( empiricalDistribution . getBinStats () . size () == NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.DIGEST_NOT_INITIALIZED ) ; }
if ( sampleStats . getN () == NUMBER_CONSTANT ) { throw MathRuntimeException . createEOFException ( LocalizedFormats.URL_CONTAINS_NO_DATA , url ) ; }
catch ( IOException e ) { throw new MathRuntimeException ( e ) ; }
catch ( EOFException eof ) {}
catch ( EOFException eof ) {}
final ArrayList < BigFraction > coefficients
final ArrayList < BigFraction > coefficients
double y = x * NUMBER_CONSTANT - NUMBER_CONSTANT ;
if ( FastMath . abs ( m ) <= tol || MathUtils . equals ( fb , NUMBER_CONSTANT ) ) { return b ; }
Assert . assertTrue ( MathUtils . equals ( binomial , jacobi . value ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ) ;
if ( mode == StepNormalizerMode.MULTIPLES && MathUtils . equals ( nextTime , lastTime , NUMBER_CONSTANT ) ) { nextTime += h ; }
{ Assert . assertTrue ( MathUtils . equals ( out [ i ] , expectedSample [ i ] , NUMBER_CONSTANT ) ) ; }
Assert . assertTrue ( MathUtils . equals ( NUMBER_CONSTANT , MathUtils . distanceInf ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( MathUtils . equals ( NUMBER_CONSTANT , MathUtils . distance ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( MathUtils . equals ( NUMBER_CONSTANT , MathUtils . distance ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( MathUtils . equals ( NUMBER_CONSTANT , MathUtils . distance1 ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
if ( MathUtils . compareTo ( entry , minValue , maxUlps ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
isLastStep = isLastStep || MathUtils . equals ( currentT , tEnd , NUMBER_CONSTANT ) ;
! MathUtils . equalsIncludingNaN ( expected [ i ] , observed [ i ] , tolerance )
for ( double value : values ) { if ( MathUtils . equals ( value , x , epsilon ) ) { return; } }
MathUtils . equalsIncludingNaN ( stat . getN () , getN () )
if ( MathUtils . compareTo ( entry , NUMBER_CONSTANT , epsilon ) < NUMBER_CONSTANT ) { return false ; }
if ( MathUtils . compareTo ( entry , NUMBER_CONSTANT , maxUlps ) > NUMBER_CONSTANT ) { columnsToDrop . add ( i ) ; }
{ if ( this . parameters == null ) { return null ; } return MathUtils . copyOf ( parameters ) ; }
MathUtils . checkOrder ( knots ) ;
public int [] getOrderOfRegressors () { return MathUtils . copyOf ( vorder ) ; }
{ include ( MathUtils . copyOf ( x , x.length ) , NUMBER_CONSTANT , y ) ; }
MathUtils . checkOrder ( x ) ;
{ this ( wrong , previous , index , MathUtils.OrderDirection.INCREASING , true ) ; }
MathUtils . checkOrder ( xval ) ;
final double [] d = MathUtils . copyOf ( direc [ i ] ) ;
MathUtils . checkOrder ( x ) ;
{ return MathUtils . distance ( point , p . getPoint () ) ; }
RealMatrix arzneg = selectColumns ( arz , MathUtils . copyOf ( arReverseIndex , mu ) ) ;
return MathUtils . checkOrder ( x , MathUtils.OrderDirection.INCREASING , true , abort ) ;
MathUtils . sortInPlace ( xNew , yNew ) ;
MathUtils . sortInPlace ( this . x , this . y ) ;
public int [] getSizes () { return MathUtils . copyOf ( size ) ; }
this . size = MathUtils . copyOf ( size ) ;
public int [] getCounts () { return MathUtils . copyOf ( counter ) ; }
Assert . assertEquals ( expectedValue () , variance . evaluate ( testArray , MathUtils . normalizeArray ( identicalWeightsArray , testArray.length ) , NUMBER_CONSTANT , testArray.length ) , getTolerance () ) ;
int gcd = MathUtils . gcd ( numerator , denominator ) ;
final int d = MathUtils . gcd ( num , den ) ;
long lcm = FastMath . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ;
int lcm = FastMath . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ;
{ coeff [ i ] [ j ] = ( int ) MathUtils . binomialCoefficient ( i , j ) ; }
double binomial = MathUtils . binomialCoefficient ( v + i , i ) ;
double binomial = ArithmeticsUtils . binomialCoefficient ( v + i , i ) ;
int gcd = ArithmeticsUtils . gcd ( numerator , denominator ) ;
final int d = ArithmeticsUtils . gcd ( num , den ) ;
{ coeff [ i ] [ j ] = ( int ) ArithmeticsUtils . binomialCoefficient ( i , j ) ; }
MathUtils . sign ( y0 ) + MathUtils . sign ( ym ) == NUMBER_CONSTANT
{ return FastMath . abs ( x ) < NUMBER_CONSTANT ? NUMBER_CONSTANT : FastMath . sin ( x ) / x ; }
if ( n < MathUtils.EPSILON ) { return zero ; }
if ( n < MathUtils.SAFE_MIN ) { return distance ( line.zero ) ; }
tol = FastMath . max ( m * singularValues [ NUMBER_CONSTANT ] * EPS , FastMath . sqrt ( MathUtils.SAFE_MIN ) ) ;
if ( d > - MathUtils.SAFE_MIN && d < MathUtils.SAFE_MIN ) { return d ; }
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
final double eps = NUMBER_CONSTANT * rows * columns * MathUtils.EPSILON ;
if ( FastMath . abs ( diag ) < MathUtils.SAFE_MIN ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
if ( FastMath . abs ( diag ) < MathUtils.SAFE_MIN ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer ( initialStepBoundFactor , costRelativeTolerance , parRelativeTolerance , orthoTolerance , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( indefinite , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( distinct , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( repeated , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) ;
RealMatrix v = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) . getV () ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( createTestMatrix ( r , bigValues ) , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () , MathUtils.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , MathUtils.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , MathUtils.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
if ( FastMath . abs ( tmp ) > MathUtils.EPSILON ) { w = ( di * w ) / dpi ; }
{ this ( numberOfVariables , includeConstant , MathUtils.EPSILON ) ; }
FastMath . abs ( sumXX ) > MathUtils.SAFE_MIN
@ Test ( expected = OutOfRangeException . class )
{ this ( numberOfInterpolationPoints , null , null ) ; }
this . stopfitness = stopfitness ;
this . stopfitness = stopFitness ;
public boolean isInfinite () { throw unsupported () ; }
public boolean isNaN () { throw unsupported () ; }
public boolean isInfinite () { throw unsupported () ; }
public boolean isNaN () { throw unsupported () ; }
public boolean isInfinite () { throw unsupported () ; }
public boolean isNaN () { throw unsupported () ; }
public void unitize () { throw unsupported () ; }
public double getLInfNorm () { throw unsupported () ; }
public double getL1Norm () { throw unsupported () ; }
public double getNorm () { throw unsupported () ; }
double [] bounds = ( ( EmpiricalDistributionImpl ) empiricalDistribution2 ) . getGeneratorUpperBounds () ;
FieldDecompositionSolver solver ;
double floatn = ( double ) v.length ;
final double [] eventY = interpolator . getInterpolatedState () ;
final double [] yTmp = new double [ y0.length ] ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new BetaDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
BetaDistributionImpl betaDistribution = new BetaDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
BetaDistribution d = new BetaDistributionImpl ( alpha , beta ) ;
BetaDistribution d = new BetaDistributionImpl ( alpha , beta ) ;
setDistribution ( new BinomialDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new BinomialDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new CauchyDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
ChiSquaredDistribution d = new ChiSquaredDistributionImpl ( df ) ;
setDistribution ( new ChiSquaredDistributionImpl ( NUMBER_CONSTANT ) ) ;
@ Override public ChiSquaredDistribution makeDistribution () { return new ChiSquaredDistributionImpl ( NUMBER_CONSTANT ) ; }
double [] quartiles = TestUtils . getDistributionQuartiles ( new ChiSquaredDistributionImpl ( NUMBER_CONSTANT ) ) ;
FDistributionImpl fd = new FDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new FDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GammaDistribution distribution = new GammaDistributionImpl ( a , b ) ;
GammaDistribution distribution = new GammaDistributionImpl ( a , b ) ;
@ Override public ExponentialDistribution makeDistribution () { return new ExponentialDistributionImpl ( NUMBER_CONSTANT ) ; }
FDistribution fdist = new FDistributionImpl ( a.dfbg , a.dfwg ) ;
{ gamma = new GammaDistributionImpl ( degreesOfFreedom / NUMBER_CONSTANT , NUMBER_CONSTANT ) ; solverAbsoluteAccuracy = inverseCumAccuracy ; }
HypergeometricDistribution dist = new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
setDistribution ( new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NormalDistribution normal = new NormalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
NormalDistribution distribution = new NormalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
NormalDistribution d = new NormalDistributionImpl ( mean , sd ) ;
setDistribution ( new PascalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new PascalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;
TDistribution tDistribution = new TDistributionImpl ( NUMBER_CONSTANT ) ;
FastMath . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / ( double ) n ) + ( xbar * xbar ) / sumXX ) )
TDistribution distribution = new TDistributionImpl ( degreesOfFreedom ) ;
TDistribution distribution = new TDistributionImpl ( degreesOfFreedom ) ;
TDistribution td = new TDistributionImpl ( df ) ;
setDistribution ( new TDistributionImpl ( NUMBER_CONSTANT ) ) ;
{ TDistributionImpl td = new TDistributionImpl ( NUMBER_CONSTANT ) ; td . cumulativeProbability ( NUMBER_CONSTANT ) ; td . cumulativeProbability ( NUMBER_CONSTANT ) ; }
@ Override public TDistribution makeDistribution () { return new TDistributionImpl ( NUMBER_CONSTANT ) ; }
double [] quartiles = TestUtils . getDistributionQuartiles ( new WeibullDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new TDistributionImpl ( NUMBER_CONSTANT ) ) ;
PoissonDistribution poissonDistribution = new PoissonDistributionImpl ( mean ) ;
PoissonDistribution dist = new PoissonDistributionImpl ( mean ) ;
PoissonDistribution dist = new PoissonDistributionImpl ( mean ) ;
{ PoissonDistribution dist = new PoissonDistributionImpl ( NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , dist . getMean () , NUMBER_CONSTANT ) ; }
@ Test ( expected = NotStrictlyPositiveException . class ) public void testNegativeMean () { new PoissonDistributionImpl ( - NUMBER_CONSTANT ) ; }
PoissonDistribution dist = new PoissonDistributionImpl ( DEFAULT_TEST_POISSON_PARAMETER ) ;
@ Override public IntegerDistribution makeDistribution () { return new PoissonDistributionImpl ( DEFAULT_TEST_POISSON_PARAMETER ) ; }
dist = new ZipfDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_WINDOW_SIZE , windowSize ) ; } }
if ( sign >= NUMBER_CONSTANT && magnitude == Long.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW ) ; } else { return ( long ) - magnitude ; }
if ( sign >= NUMBER_CONSTANT && magnitude == Integer.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW ) ; } else { return ( int ) - magnitude ; }
if ( c . isAssignableFrom ( UnivariateRealFunction . class ) ) { return new Sin () ; } else { throw new IllegalArgumentException ( STRING_CONSTANT + c ) ; }
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new Expm1Function () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new XMinus5Function () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new Expm1Function () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final DifferentiableUnivariateRealFunction f
ParametricUnivariateRealFunction sif = new SimpleInverseFunction () ;
ParametricUnivariateRealFunction sif = new SimpleInverseFunction () ;
UnivariateRealFunction f
UnivariateRealFunction func
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction f = new Gaussian () ;
final UnivariateRealFunction f = new Gaussian () ;
@ Override public RealVector mapToSelf ( UnivariateRealFunction function ) { throw unsupported () ; }
@ Override public RealVector map ( UnivariateRealFunction function ) { throw unsupported () ; }
DifferentiableUnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction p = interpolator . interpolate ( x , y ) ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction dfdx = f . derivative () ;
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final UnivariateRealFunction f
final UnivariateRealFunction f
final UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction f = new Sigmoid () ;
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction f
UnivariateRealFunction f
final UnivariateRealFunction f
DifferentiableUnivariateRealFunction f = new QuinticFunction () ;
DifferentiableUnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final ParametricUnivariateRealFunction f
final ParametricUnivariateRealFunction f
final ParametricUnivariateRealFunction f
final UnivariateRealFunction f
final UnivariateRealFunction f
UnivariateRealFunction p = interpolator . interpolate ( x , y ) ;
final UnivariateRealFunction dfdx = f . derivative () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new Expm1Function () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final UnivariateRealFunction f
final UnivariateRealFunction lsf = new LineSearchFunction ( searchDirection ) ;
DifferentiableUnivariateRealFunction f
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
@ Override public RealVector mapToSelf ( UnivariateRealFunction function ) { throw unsupported () ; }
@ Override public RealVector map ( UnivariateRealFunction function ) { throw unsupported () ; }
public MonitoredFunction ( UnivariateRealFunction f ) { callsCount = NUMBER_CONSTANT ; this . f = f ; }
UnivariateRealFunction dSpline = spline . derivative () ;
final MultivariateRealFunction evaluationFunction
MultivariateRealFunction func
MultivariateRealFunction coll = FunctionUtils . collector ( bi , NUMBER_CONSTANT ) ;
final MultivariateRealFunction evaluationFunction
final MultivariateRealFunction evaluationFunction
final DifferentiableMultivariateRealFunction f
DifferentiableMultivariateRealFunction func
DifferentiableMultivariateRealFunction func
MultivariateRealFunction func
final MultivariateRealFunction evaluationFunction
final MultivariateRealFunction evaluationFunction
MultivariateRealFunction func
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
public KeplerStepHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
resetEvaluations () ;
public KeplerStepHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
final DifferentiableMultivariateVectorialFunction f
final MultivariateVectorialFunction function
final MultivariateVectorialFunction function
final MultivariateVectorialFunction function
# optimize ( int , MultivariateVectorialFunction , double [] , double [] , double [] )
DifferentiableMultivariateVectorialFunction problem
result = transformer . inversetransform ( f , min , max , N ) ;
if ( forward ) { temp = transform2 ( temp ) ; } else { temp = inversetransform2 ( temp ) ; }
double dResult [] = transformer . inversetransform ( dY ) ;
Object o []
double d []
Complex f []
double f []
Complex f []
double f []
double f []
double f []
double f []
double f []
int x []
double x []
int f []
double f []
double f []
double f []
double f []
double f []
double f []
new Fraction ( ( ( Math . abs ( w ) * d ) + n ) * MathUtils . sign ( w ) , d )
final int bits
if ( seed == null ) { setSeed ( System . currentTimeMillis () ) ; return; }
catch ( Exception e ) { fail ( STRING_CONSTANT ) ; }
catch ( Exception e ) { fail ( STRING_CONSTANT ) ; }
double x
p = dist . cumulativeProbability ( x ) ;
ContinuousDistribution distribution
ContinuousDistribution distribution
FastFourierTransformer transformer = new FastFourierTransformer () ;
FastFourierTransformer transformer = new FastFourierTransformer () ;
FastFourierTransformer transformer = new FastFourierTransformer () ;
FastFourierTransformer transformer = new FastFourierTransformer () ;
FastCosineTransformer transformer = new FastCosineTransformer () ;
FastCosineTransformer transformer = new FastCosineTransformer () ;
DifferentiableMultivariateVectorialOptimizer optimizer
{ DifferentiableMultivariateVectorialOptimizer optimizer = new GaussNewtonOptimizer ( true ) ; checkUnsolvableProblem ( optimizer , false ) ; }
final DifferentiableMultivariateVectorialOptimizer optimizer
public HarmonicFitter ( final DifferentiableMultivariateVectorialOptimizer optimizer ) { super ( optimizer ) ; }
final DifferentiableMultivariateVectorialOptimizer optimizer
public GaussianFitter ( DifferentiableMultivariateVectorialOptimizer optimizer ) { super ( optimizer ) ; }
final BaseMultivariateRealOptimizer < FUNC > optimizer
MultivariateRealOptimizer optim
final DifferentiableMultivariateRealOptimizer optimizer
final MultivariateRealOptimizer optimizer
@ Override public void setSeed ( int seed ) { ran . setSeed ( seed ) ; }
{ if ( rand == null ) { rand = new JDKRandomGenerator () ; } rand . setSeed ( seed ) ; }
FastSineTransformer transformer = new FastSineTransformer () ;
FastSineTransformer transformer = new FastSineTransformer () ;
Assert . assertEquals ( - NUMBER_CONSTANT , dist . inverseCumulativeProbability ( NUMBER_CONSTANT ) ) ;
setInverseCumulativeTestValues ( new int [] { - NUMBER_CONSTANT , - NUMBER_CONSTANT } ) ;
setInverseCumulativeTestValues ( new int [] { Integer.MAX_VALUE - NUMBER_CONSTANT , Integer.MAX_VALUE - NUMBER_CONSTANT } ) ;
{ return getNumberOfTrials () * getProbabilityOfSuccess () ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_PLUS_ONE , Integer . valueOf ( f.length ) ) ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( o.length ) ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( d.length ) ) ; } }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , Integer . valueOf ( n ) ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , Integer . valueOf ( n ) ) ; }
final double [] data = FastFourierTransformer . sample ( f , min , max , n ) ;
final double [] data = FastFourierTransformer . sample ( f , min , max , n ) ;
{ final double [] data = FastFourierTransformer . sample ( f , min , max , n ) ; return inverseTransform ( data ) ; }
{ final double [] data = FastFourierTransformer . sample ( f , min , max , n ) ; return transform ( data ) ; }
final double [] unscaled = fht ( FastFourierTransformer . sample ( f , min , max , n ) ) ;
{ return fht ( FastFourierTransformer . sample ( f , min , max , n ) ) ; }
final double [] data = sample ( f , min , max , n ) ;
final double [] data = sample ( f , min , max , n ) ;
return FastFourierTransformer . scaleArray ( fst ( data ) , s ) ;
return FastFourierTransformer . scaleArray ( fst ( f ) , s ) ;
{ final double s = FastMath . sqrt ( NUMBER_CONSTANT / n ) ; return FastFourierTransformer . scaleArray ( fst ( data ) , s ) ; }
{ final double s = FastMath . sqrt ( NUMBER_CONSTANT / f.length ) ; return FastFourierTransformer . scaleArray ( fst ( f ) , s ) ; }
FastFourierTransformer . scaleArray ( x2 , NUMBER_CONSTANT / FastMath . sqrt ( x2.length ) ) ;
return scaleArray ( transformed , NUMBER_CONSTANT ) ;
return scaleArray ( fft ( f ) , s ) ;
return scaleArray ( fft ( data , true ) , s ) ;
return scaleArray ( fft ( f , true ) , s ) ;
{ final double s = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ; return scaleArray ( fft ( f ) , s ) ; }
return scaleArray ( fft ( data , false ) , s ) ;
return scaleArray ( fft ( f , false ) , s ) ;
FastFourierTransformer . scaleArray ( x , FastMath . sqrt ( x.length / NUMBER_CONSTANT ) ) ;
return FastFourierTransformer . scaleArray ( fct ( f ) , s1 ) ;
return FastFourierTransformer . scaleArray ( fct ( f ) , s ) ;
return FastFourierTransformer . scaleArray ( unscaled , NUMBER_CONSTANT / n ) ;
{ return FastFourierTransformer . scaleArray ( fht ( f ) , NUMBER_CONSTANT / f.length ) ; }
{ for ( double diag : rDiag ) { if ( diag == NUMBER_CONSTANT ) { return false ; } } return true ; }
public DecompositionSolver getSolver () { return new Solver ( qrt , rDiag ) ; }
@ Test ( expected = NonMonotonicSequenceException . class )
final UnivariateRealSolver solver
final UnivariateRealSolver solver
UnivariateRealSolver solver = new MullerSolver () ;
UnivariateRealSolver solver = new MullerSolver () ;
UnivariateRealSolver solver = new MullerSolver () ;
UnivariateRealSolver solver = new MullerSolver () ;
UnivariateRealSolverUtils . verifyInterval ( lower , upper ) ;
{ return super . solve ( maxEval , f , UnivariateRealSolverUtils . midpoint ( min , max ) ) ; }
final UnivariateRealSolver lineSearchSolver
final UnivariateRealSolver lineSearchSolver
UnivariateRealSolver solver = new RiddersSolver () ;
UnivariateRealSolver solver = new RiddersSolver () ;
UnivariateRealSolver solver = new RiddersSolver () ;
UnivariateRealSolver solver = new RiddersSolver () ;
UnivariateRealSolver solver = new BrentSolver () ;
UnivariateRealSolver solver = new BrentSolver () ;
UnivariateRealSolver solver = new MullerSolver2 () ;
UnivariateRealSolver solver = new MullerSolver2 () ;
UnivariateRealSolver solver = new MullerSolver2 () ;
UnivariateRealSolver solver = new MullerSolver2 () ;
double x = UnivariateRealSolverUtils . solve ( toSolve , lowerBound , upperBound , getSolverAbsoluteAccuracy () ) ;
UnivariateRealSolver solver
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
final UnivariateRealSolver solver = new RegulaFalsiSolver () ;
final UnivariateRealSolver solver
int populationLimit
Chromosome chromosome
List < Chromosome > chromosomes
int arity
Population population
Chromosome original
Chromosome another
Chromosome another
int l
java.util.List < Double > chromosomeRepresentation
Chromosome another
List < T > sequence
Double [] representation
Population current
RandomGenerator random
{ if ( maxGenerations <= NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.TOO_SMALL_GENERATION_COUNT , maxGenerations , NUMBER_CONSTANT , true ) ; } this . maxGenerations = maxGenerations ; }
if ( elitismRate < NUMBER_CONSTANT || elitismRate > NUMBER_CONSTANT ) { throw new OutOfRangeException ( LocalizedFormats.OUT_OF_RANGE_ELITISM_RATE , elitismRate , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
partialDerivatives = new BivariateRealFunction [ [ [ NUMBER_CONSTANT ] [ lastI ] [ lastJ ] ;
BivariateRealFunction div = new Divide () ;
BivariateRealFunction bi = new Add () ;
BivariateRealFunction bi = new Add () ;
final BivariateRealFunction f
final BivariateRealFunction f
final BivariateRealFunction combiner
final BivariateRealFunction combiner
final BivariateRealFunction combiner
final IterativeLinearSolverEvent event = createEvent ( state ) ;
{ return x . ebeMultiply ( diag ) ; }
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
roots . computeOmega ( - f.length ) ;
roots . computeOmega ( f.length ) ;
BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
MultivariateRealInterpolator interpolator = new MicrosphereInterpolator () ;
MultivariateRealInterpolator interpolator = new MicrosphereInterpolator () ;
UnivariateRealInterpolator i = new LinearInterpolator () ;
UnivariateRealInterpolator i = new LinearInterpolator () ;
UnivariateRealInterpolator i = new LinearInterpolator () ;
UnivariateRealInterpolator i = new LinearInterpolator () ;
UnivariateRealInterpolator interpolator = new NevilleInterpolator () ;
UnivariateRealInterpolator interpolator = new NevilleInterpolator () ;
UnivariateRealInterpolator interpolator = new NevilleInterpolator () ;
BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator () ;
BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator () ;
BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator () ;
UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator () ;
TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator () ;
TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator () ;
TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
roots . computeOmega ( f.length ) ;
roots . computeOmega ( - f.length ) ;
UnivariateRealIntegrator integrator = new TrapezoidIntegrator () ;
UnivariateRealIntegrator integrator = new TrapezoidIntegrator () ;
LegendreGaussIntegrator integrator = new LegendreGaussIntegrator ( n , UnivariateRealIntegratorImpl.DEFAULT_RELATIVE_ACCURACY , UnivariateRealIntegratorImpl.DEFAULT_ABSOLUTE_ACCURACY , UnivariateRealIntegratorImpl.DEFAULT_MIN_ITERATIONS_COUNT , NUMBER_CONSTANT ) ;
UnivariateRealIntegrator integrator = new SimpsonIntegrator () ;
UnivariateRealIntegrator integrator = new SimpsonIntegrator () ;
UnivariateRealIntegrator integrator = new RombergIntegrator () ;
UnivariateRealIntegrator integrator = new RombergIntegrator () ;
final UnivariateRealIntegratorImpl baseIntegrator
{ allocArrays () ; setSeed ( seed ) ; }
public ISAACRandom ( long seed ) { allocArrays () ; setSeed ( seed ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS ) ; } }
final double fact2 = ( n ) / ( n - NUMBER_CONSTANT ) ;
final double fact2 = ( n ) / ( NUMBER_CONSTANT + n ) ;
public void init ( double t0 , double [] y0 , double t ) {}
try { t . transform ( input ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathException e ) {}
catch ( MathException e ) { e . printStackTrace () ; }
if ( ( nvars + NUMBER_CONSTANT ) * nobs != data.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_REGRESSION_ARRAY , data.length , nobs , nvars ) ; }
empiricalDistribution = new EmpiricalDistributionImpl ( binCount , randomData ) ;
{ computeDistribution ( EmpiricalDistributionImpl.DEFAULT_BIN_COUNT ) ; }
EmpiricalDistributionImpl dist = new EmpiricalDistributionImpl ( NUMBER_CONSTANT ) ;
{ new EmpiricalDistributionImpl () . load ( ( File ) null ) ; }
{ new EmpiricalDistributionImpl () . load ( ( URL ) null ) ; }
{ new EmpiricalDistributionImpl () . load ( ( double [] ) null ) ; }
EmpiricalDistribution dist = new EmpiricalDistributionImpl () ;
new EmpiricalDistributionImpl () . load ( x ) ;
dataRI = new double [] [] { Arrays . copyOf ( f , f.length ) , new double [ f.length ] }
dataRI = new double [] [] { Arrays . copyOf ( f , f.length ) , new double [ f.length ] }
Collection < double [] > categoryData
Collection < double [] > categoryData
Collection < double [] > categoryData
boolean exactPValue
double dResult [] = transformer . inverseTransform ( dY ) ;
double dResult [] = transformer . transform ( dX ) ;
protected BaseAbstractMultivariateSimpleBoundsOptimizer ( ConvergenceChecker < RealPointValuePair > checker ) { super ( checker ) ; }
UnivariateRealPointValuePair [] optima = optimizer . getOptima () ;
public SimplexOptimizer ( ConvergenceChecker < RealPointValuePair > checker ) { super ( checker ) ; }
RealPointValuePair expected
protected AbstractScalarDifferentiableOptimizer ( ConvergenceChecker < RealPointValuePair > checker ) { super ( checker ) ; }
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < UnivariateRealPointValuePair > checker
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < UnivariateRealPointValuePair > checker
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < RealPointValuePair > checker
RealPointValuePair [] points
RealPointValuePair point
final Comparator < RealPointValuePair > comparator
ChiSquareTest chiSquareTest = new ChiSquareTestImpl () ;
org.apache.commons.math.stat.inference.ChiSquareTestImpl csti = new org.apache.commons.math.stat.inference.ChiSquareTestImpl () ;
org.apache.commons.math.stat.inference.ChiSquareTestImpl csti = new org.apache.commons.math.stat.inference.ChiSquareTestImpl () ;
ChiSquareTest chiSquareTest = new ChiSquareTestImpl () ;
VectorialPointValuePair optimum
ConvergenceChecker < VectorialPointValuePair > checker
ConvergenceChecker < VectorialPointValuePair > checker
ConvergenceChecker < VectorialPointValuePair > checker
ConvergenceChecker < VectorialPointValuePair > checker
ConvergenceChecker < VectorialPointValuePair > checker
protected AbstractLeastSquaresOptimizer ( ConvergenceChecker < VectorialPointValuePair > checker ) { super ( checker ) ; }
SimplexOptimizer optimizer = new SimplexOptimizer ( new SimpleRealPointChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
SimplexOptimizer underlying = new SimplexOptimizer ( new SimpleScalarValueChecker ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver () , preconditioner ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
SimplexOptimizer optimizer = new SimplexOptimizer ( new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer underlying = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ this ( lambda , inputSigma , boundaries , maxIterations , stopFitness , isActiveCMA , diagonalOnly , checkFeasableCount , random , generateStatistics , new SimpleScalarValueChecker () ) ; }
{ this ( new SimpleScalarValueChecker ( rel , abs ) ) ; }
DifferentiableMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer ( true , new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
DifferentiableMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer ( true , new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ throw new UnsupportedOperationException () ; }
FastSineTransformer transformer = FastSineTransformer . create () ;
FastSineTransformer transformer = FastSineTransformer . create () ;
{ throw new NumberIsTooSmallException ( LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION , minStep , FastMath . abs ( h ) , true ) ; }
if ( variablesToInclude == null || variablesToInclude.length == NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.ARRAY_ZERO_LENGTH_OR_NULL_NOTALLOWED ) ; }
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
static double [] [] loadLnMant () { return LN_MANT . clone () ; }
static double [] loadExpFracB () { return EXP_FRAC_B . clone () ; }
static double [] loadExpFracA () { return EXP_FRAC_A . clone () ; }
static double [] loadExpIntB () { return EXP_INT_B . clone () ; }
static double [] loadExpIntA () { return EXP_INT_A . clone () ; }
@ Test ( expected = MultiDimensionMismatchException . class )
@ Test ( expected = MultiDimensionMismatchException . class )
StringBuffer imAppendTo = new StringBuffer () ;
{ if ( this . fitness == Double.MIN_VALUE ) { this . fitness = fitness () ; } return this . fitness ; }
setStepsizeControl ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
setStepsizeControl ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
( n * ( n + NUMBER_CONSTANT ) * moment.m4 - NUMBER_CONSTANT * moment.m2 * moment.m2 * ( n - NUMBER_CONSTANT ) )
double [] hatResiduals = I . subtract ( hat ) . operate ( model.Y ) . toArray () ;
{ RealVector b = calculateBeta () ; return Y . subtract ( X . operate ( b ) ) ; }
return residuals . dotProduct ( residuals ) / ( X . getRowDimension () - X . getColumnDimension () ) ;
RealVector e = Y . subtract ( X . operate ( b ) ) ;
this . Y = new ArrayRealVector ( y ) ;
return t / ( X . getRowDimension () - X . getColumnDimension () ) ;
int p = X . getColumnDimension () ;
{ return qr . getSolver () . solve ( Y ) ; }
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( X ) ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( X ) ; }
final RealMatrix x = ols.X . copy () ;
final int length = b . getDataRef () . length ;
final double epsa = ( s + SymmLQ.MACH_PREC ) * SymmLQ.CBRT_MACH_PREC ;
@ Override public RealVector getRightHandSideVector () { return RealVector . unmodifiableRealVector ( state.b ) ; }
this . x . set ( NUMBER_CONSTANT ) ;
this . x = x ;
solver = new ConjugateGradient ( maxIterations , NUMBER_CONSTANT , true ) ;
solver = new ConjugateGradient ( maxIterations , NUMBER_CONSTANT , true ) ;
double array []
double [] [] householderMatrix
{ key = k ; value = v ; }
{ this ( entry , false ) ; }
{ this ( k , v , false ) ; }
throw new RuntimeException ( STRING_CONSTANT ) ;
throw new RuntimeException ( STRING_CONSTANT ) ;
if ( x <= NUMBER_CONSTANT ) { ret = NUMBER_CONSTANT ; } else { ret = Gamma . regularizedGammaP ( alpha , x / beta ) ; }
{ return getAlpha () * getBeta () ; }
v . walkInDefaultOrder ( visitor , expectedStart , expectedEnd ) ;
{ ret = innerCumulativeProbability ( domain [ NUMBER_CONSTANT ] , x , NUMBER_CONSTANT , populationSize , numberOfSuccesses , sampleSize ) ; }
{ recurseBuildBoundary ( tree ) ; }
SimplexOptimizer optimizer = new SimplexOptimizer () ;
@ Override public RealVector create ( final double [] data ) { return new OpenMapRealVector ( data ) ; }
TestVectorImpl ( double [] values ) { this . values = values ; }
catch ( IllegalArgumentException e ) {}
final ParametricUnivariateFunction f
final ParametricUnivariateFunction f
final double n1n2prod = n1 * n2 ;
{ create ( data1 ) . addToEntry ( - NUMBER_CONSTANT , getPreferredEntryValue () ) ; }
{ create ( data1 ) . setEntry ( - NUMBER_CONSTANT , getPreferredEntryValue () ) ; }
@ Override public RealVector createAlien ( double [] data ) { return new RealVectorTestImpl ( data ) ; }
final RealVector x = new TestVectorImpl ( v . clone () ) ;
@ Override public RealVector createAlien ( double [] data ) { return new TestVectorImpl ( data ) ; }
@ Override public RealVector create ( final double [] data ) { return new TestVectorImpl ( data ) ; }
SparseRealVectorTestImpl v7_i = new SparseRealVectorTestImpl ( vec1 ) ;
@ Override public RealVector createAlien ( double [] data ) { return new SparseRealVectorTestImpl ( data ) ; }
Assert . assertEquals ( STRING_CONSTANT + i + STRING_CONSTANT + j + STRING_CONSTANT , expected , actual , NUMBER_CONSTANT ) ;
private ComplexUtils () { super(); }
Object obj
int n = coefficients.length - NUMBER_CONSTANT ;
ed = new EigenDecomposition ( indefinite , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( distinct , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( repeated , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( m , Precision.SAFE_MIN ) ;
RealMatrix v = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) . getV () ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( symmetric , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( createTestMatrix ( r , bigValues ) , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
{ return ( int ) FastMath . min ( randomData . nextPoisson ( mean ) , Integer.MAX_VALUE ) ; }
{ double n = randomData . nextGaussian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; return FastMath . exp ( scale + shape * n ) ; }
EigenDecomposition eig = new EigenDecomposition ( C , NUMBER_CONSTANT ) ;
BaseRuleFactory factory
final GaussIntegrator g = factory . legendreHighPrecision ( numberOfPoints , a , b ) ;
{ this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ROW_SEPARATOR , DEFAULT_COLUMN_SEPARATOR , format ) ; }
public RealMatrixFormat () { this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ROW_SEPARATOR , DEFAULT_COLUMN_SEPARATOR , CompositeFormat . getDefaultNumberFormat () ) ; }
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
{ double multiplier = tableau . getEntry ( i , pivotCol ) ; tableau . subtractRow ( i , pivotRow , multiplier ) ; }
if ( Precision . compareTo ( entry , minValue , maxUlps ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
if ( Precision . compareTo ( p , NUMBER_CONSTANT , epsilon ) < NUMBER_CONSTANT ) { s = - s ; }
catch ( Exception e ) { throw new MathIllegalStateException () ; }
{ if ( ! Precision . equals ( imagEigenvalues [ i ] , NUMBER_CONSTANT , epsilon ) ) { return true ; } }
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , new RealMatrixFormat () . parse ( source , pos ) ) ;
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , new RealMatrixFormat () . parse ( source , pos ) ) ;
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , new RealMatrixFormat () . parse ( source , pos ) ) ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
DifferentiableUnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
final UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
{ secRand = SecureRandom . getInstance ( algorithm , provider ) ; }
{ return nextInversionDeviate ( new ZipfDistribution ( numberOfElements , exponent ) ) ; }
{ return nextInversionDeviate ( new WeibullDistribution ( shape , scale ) ) ; }
{ return nextInversionDeviate ( new TDistribution ( df ) ) ; }
{ return nextInversionDeviate ( new PascalDistribution ( r , p ) ) ; }
{ return nextInversionDeviate ( new HypergeometricDistribution ( populationSize , numberOfSuccesses , sampleSize ) ) ; }
{ return nextInversionDeviate ( new FDistribution ( numeratorDf , denominatorDf ) ) ; }
{ return nextInversionDeviate ( new ChiSquaredDistribution ( df ) ) ; }
{ return nextInversionDeviate ( new CauchyDistribution ( median , scale ) ) ; }
{ return nextInversionDeviate ( new BinomialDistribution ( numberOfTrials , probabilityOfSuccess ) ) ; }
{ return nextInversionDeviate ( new BetaDistribution ( alpha , beta ) ) ; }
{ return nextUniform ( lower , upper , false ) ; }
{ super(); this . rand = rand ; }
double dotProduct = new LegendreGaussIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . integrate ( NUMBER_CONSTANT , f , a , b ) ;
FastMath . exp ( Gamma . logGamma ( shape ) )
@ Override public int hashCode () { throw new UnsupportedOperationException () ; }
{ throw new UnsupportedOperationException () ; }
double x = randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
fillBinStats ( in ) ;
final UnivariateDifferentiable sPrime = new Sqrt () ;
final UnivariateDifferentiable f = new QuinticFunction () ;
UnivariateDifferentiable f = new Sin () ;
final UnivariateDifferentiable f
final UnivariateDifferentiable f
UnivariateDifferentiable f
final UnivariateDifferentiable q = new QuinticFunction () ;
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.ENTRY , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.ENTRY , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.ENTRY , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.ENTRY , i ) ; }
final DifferentiableMultivariateVectorFunction problem ;
public CircleScalar () { points = new ArrayList < Point2D.Double > () ; }
{ gradient = f . gradient () ; return super . optimize ( maxEval , f , goalType , startPoint ) ; }
DifferentiableMultivariateVectorFunction problem
public CircleVectorial () { points = new ArrayList < Point2D.Double > () ; }
final Quaternion product = Quaternion . product ( inverseQ , q ) ;
final double normSquareRef = Quaternion . product ( q , q . getConjugate () ) . getScalarPart () ;
{ return product ( this , q ) ; }
optimum = new PointValuePair ( fitfun . decode ( bestArx . getColumn ( NUMBER_CONSTANT ) ) , isMinimize ? bestFitness : - bestFitness ) ;
double tmp = wxi * xi / di ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = v . sparseIterator () ;
Iterator < Entry > it = v . sparseIterator () ;
public double [] getStartPoint () { return start . clone () ; }
{ return optimize ( maxEval , f , goalType , startPoint , null , null ) ; }
public double [] getUpperBound () { return upperBound . clone () ; }
public double [] getLowerBound () { return lowerBound . clone () ; }
Math . max ( NUMBER_CONSTANT , NUMBER_CONSTANT - dimension / ( NUMBER_CONSTANT + Math . min ( maxIterations , getMaxEvaluations () / lambda ) ) )
final int dim = getDimensions () ;
final int dim = getDimensions () ;
final int dim = getDimensions () ;
final double [] [] out = new double [ [ sampleSize ] [ numDimensions ] ;
{ random = rng ; numDimensions = n ; }
final int dim = d . getDimensions () ;
final int dim = d . getDimensions () ;
double [] insigma = point ( DIM + NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
double [] insigma = null ;
double [] insigma = null ;
double [] insigma = null ;
final double [] f
jF = new JacobianFunction ( f ) ;
{ distribution . get ( i ) . reseedRandomGenerator ( seed ) ; }
MultivariateFunction f
MultivariateFunction f
final RealMatrix d = createDiagonalMatrix ( eigenValues , n , n ) ;
RealMatrix m = createDiagonalMatrix ( diagonal , diagonal.length , diagonal.length ) ;
{ x = list . remove ( list . size () - NUMBER_CONSTANT ) . getLower () ; }
final double [] sigma = optim . getSigma () ;
double [] currentPoint = getStartPoint () ;
final double [] [] covMatrix = optimizer . getCovariances () ;
final double [] [] covarMatrix = optimizer . getCovariances () ;
qrDecomposition ( computeJacobian ( currentPoint ) ) ;
final RealMatrix j = computeJacobian ( params ) ;
final RealMatrix weightedJacobian = computeJacobian ( currentPoint ) ;
try { testStatistic . gTestGoodnessOfFit ( expected , observed , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( OutOfRangeException ex ) {}
try { testStatistic . gTestGoodnessOfFitPValue ( expected , observed ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NotStrictlyPositiveException ex ) {}
final double residual = - currentResiduals [ i ] ;
{ super . testAdd1000 () ; Assert . assertEquals ( STRING_CONSTANT + STRING_CONSTANT , NUMBER_CONSTANT , ( ( ResizableDoubleArray ) da ) . getInternalLength () ) ; }
ResizableDoubleArray other = ( ResizableDoubleArray ) object ;
{ ResizableDoubleArray result = new ResizableDoubleArray () ; copy ( this , result ) ; return result ; }
hashData [ NUMBER_CONSTANT ] = expansionMode ;
expansionMode == MULTIPLICATIVE_MODE
expansionMode == MULTIPLICATIVE_MODE
{ if ( initialDoubleArray != null ) { eDA = new ResizableDoubleArray ( initialDoubleArray ) ; } }
{ if ( initialDoubleArray != null ) { eDA = new StatArray ( initialDoubleArray ) ; } }
{ this ( DEFAULT_INITIAL_CAPACITY , DEFAULT_EXPANSION_FACTOR , NUMBER_CONSTANT + DEFAULT_EXPANSION_FACTOR , ExpansionMode.MULTIPLICATIVE , initialArray ) ; }
hashData [ NUMBER_CONSTANT ] = new Float ( contractionCriteria ) . hashCode () ;
result = result && ( other.contractionCriteria == contractionCriteria ) ;
dest.contractionCriteria = source.contractionCriteria ;
{ checkContractExpand ( getContractionCriteria () , expansionFactor ) ; synchronized ( this ) { this . expansionFactor = expansionFactor ; } }
{ checkContractExpand ( contractionCriteria , getExpansionFactor () ) ; synchronized ( this ) { this . contractionCriteria = contractionCriteria ; } }
public double getContractionCriterion () { return contractionCriteria ; }
{ super ( relativeThreshold , absoluteThreshold ) ; }
@ Deprecated public SimpleVectorValueChecker () {}
{ super ( relativeThreshold , absoluteThreshold ) ; }
@ Deprecated public SimpleValueChecker () {}
{ super ( relativeThreshold , absoluteThreshold ) ; }
@ Deprecated public SimplePointChecker () {}
NaturalRanking ranking = new NaturalRanking ( TiesStrategy.MINIMUM ) ;
{ super ( relativeThreshold , absoluteThreshold ) ; }
@ Deprecated public SimpleUnivariateValueChecker () {}
logBeta ( a , b , epsilon , maxIterations )
RandomDataImpl randomData
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataImpl () ) ; }
RandomDataImpl randomData
this . q0 = NUMBER_CONSTANT ;
if ( diagonalOnly <= NUMBER_CONSTANT ) { updateCovariance ( hsig , bestArx , arz , arindex , xold ) ; } else { updateCovarianceDiagonalOnly ( hsig , bestArz , xold ) ; }
if ( diagonalOnly <= NUMBER_CONSTANT ) { updateCovariance ( hsig , bestArx , arz , arindex , xold ) ; } else { updateCovarianceDiagonalOnly ( hsig , bestArz , xold ) ; }
final CodyWaite cw = new CodyWaite ( xa , xb ) ;
final CodyWaite cw = new CodyWaite ( xa , xb ) ;
final CodyWaite cw = new CodyWaite ( xa , xb ) ;
@ Override public void reseedRandomGenerator ( long seed ) { randomData . reSeed ( seed ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataGenerator () ) ; }
@ Override public void reseedRandomGenerator ( long seed ) { reSeed ( seed ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , ( RandomGenerator ) null ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataImpl () ) ; }
filePointer = new BufferedReader ( new InputStreamReader ( valuesFileURL . openStream () ) ) ;
new Weight ( w )
new Weight ( weights )
new Weight ( weights )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( w )
new Weight ( problem . weight () )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( circle . weight () )
new Weight ( weights )
new Weight ( weights )
new Weight ( function . getWeight () )
new Weight ( w )
new Weight ( w )
new Weight ( w )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( function . getWeight () )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( circle . weight () )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( problem . weight () )
{ data = d . clone () ; }
public SimplexSolver ( final double epsilon ) { this ( epsilon , DEFAULT_ULPS ) ; }
if ( FastMath . abs ( result ) < CUTOFF_THRESHOLD ) { result = NUMBER_CONSTANT ; }
{ this ( f , constraints , goalType , restrictToNonNegative , epsilon , DEFAULT_ULPS ) ; }
final T [] out = buildArray ( field , nCols ) ;
final T [] out = buildArray ( field , nCols ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nCols ) ;
final T [] [] data = buildArray ( field , getRowDimension () , getColumnDimension () ) ;
final T [] out = buildArray ( getField () , columns ) ;
final T [] out = buildArray ( getField () , rows ) ;
final T [] out = buildArray ( getField () , rows ) ;
final T [] out = buildArray ( getField () , columns ) ;
final T [] outData = buildArray ( getField () , rows ) ;
final T [] outData = buildArray ( getField () , columns ) ;
final T [] [] data = buildArray ( getField () , getRowDimension () , getColumnDimension () ) ;
{ blocks = buildArray ( getField () , blockRows * blockColumns , - NUMBER_CONSTANT ) ; }
final T [] out = buildArray ( data.length + NUMBER_CONSTANT ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
data = buildArray ( v1.length + v2.length ) ;
data = buildArray ( v1.length + v2.data.length ) ;
data = buildArray ( v1.data.length + v2.length ) ;
data = buildArray ( v1.data.length + v2.data.length ) ;
data = buildArray ( v . getDimension () ) ;
data = buildArray ( size ) ;
data = buildArray ( size ) ;
final T [] [] out = buildArray ( getField () , nRows , getColumnDimension () ) ;
final T [] out = buildArray ( getField () , nCols ) ;
final T [] out = buildArray ( getField () , nRows ) ;
data = buildArray ( getField () , subMatrix.length , nCols ) ;
final T [] [] outData = buildArray ( getField () , nRows , nCols ) ;
final T [] [] outData = buildArray ( getField () , rowCount , columnCount ) ;
final T [] [] outData = buildArray ( getField () , rowCount , columnCount ) ;
data = buildArray ( getField () , nRows , NUMBER_CONSTANT ) ;
{ super ( field , rowDimension , columnDimension ) ; data = buildArray ( field , rowDimension , columnDimension ) ; }
T [] res = buildArray ( virtualSize ) ;
int exponent = ( int ) ( y . log10 () * NUMBER_CONSTANT ) ;
{ return new Decimal64 ( value % a.value ) ; }
{ return new Decimal64 ( value % a ) ; }
return ePlus . add ( eMinus ) . divide ( ePlus . subtract ( eMinus ) ) ;
DerivativeStructure ref = dsX . subtract ( x - ( x % y ) ) ;
DerivativeStructure sAccurate = u1 . dotProduct ( u2 ) ;
Assert . assertEquals ( - NUMBER_CONSTANT , r . getAxis () . dotProduct ( reverted . getAxis () ) . getReal () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( - NUMBER_CONSTANT , r . getAxis () . dotProduct ( reverted . getAxis () ) . getReal () , NUMBER_CONSTANT ) ;
randomData = new RandomDataImpl ( randomGenerator ) ;
{ super(); this . tiesStrategy = TiesStrategy.RANDOM ; nanStrategy = DEFAULT_NAN_STRATEGY ; randomData = new RandomDataImpl ( randomGenerator ) ; }
{ super(); this . nanStrategy = nanStrategy ; this . tiesStrategy = tiesStrategy ; randomData = new RandomDataImpl () ; }
{ super(); this . tiesStrategy = tiesStrategy ; nanStrategy = DEFAULT_NAN_STRATEGY ; randomData = new RandomDataImpl () ; }
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
@ Test ( expected = MathUnsupportedOperationException . class )
{ getRan () . setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ getRan () . setSeed ( seed ) ; }
final RandomGenerator generator = getRan () ;
{ return new FDistribution ( getRan () , numeratorDf , denominatorDf , FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ChiSquaredDistribution ( getRan () , df , ChiSquaredDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new CauchyDistribution ( getRan () , median , scale , CauchyDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new BinomialDistribution ( getRan () , numberOfTrials , probabilityOfSuccess ) . sample () ; }
{ return new BetaDistribution ( getRan () , alpha , beta , BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ZipfDistribution ( getRan () , numberOfElements , exponent ) . sample () ; }
{ return new WeibullDistribution ( getRan () , shape , scale , WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new TDistribution ( getRan () , df , TDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new PascalDistribution ( getRan () , r , p ) . sample () ; }
{ return new HypergeometricDistribution ( getRan () , populationSize , numberOfSuccesses , sampleSize ) . sample () ; }
{ return new GammaDistribution ( getRan () , shape , scale , GammaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ExponentialDistribution ( getRan () , mean , ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
return sigma * getRan () . nextGaussian () + mu ;
{ return new PoissonDistribution ( getRan () , mean , PoissonDistribution.DEFAULT_EPSILON , PoissonDistribution.DEFAULT_MAX_ITERATIONS ) . sample () ; }
RandomGenerator ran = getRan () ;
{ return randomData . nextGaussian ( stats . getMean () , stats . getStandardDeviation () ) ; }
@ Test public void testReciprocalZero () { Assert . assertEquals ( Complex.ZERO . reciprocal () , Complex.NaN ) ; }
{ return ( ( Float . floatToIntBits ( f ) > > > NUMBER_CONSTANT ) & NUMBER_CONSTANT ) - NUMBER_CONSTANT ; }
final long bits = Double . doubleToLongBits ( d ) ;
final long bits = Double . doubleToLongBits ( d ) ;
return abs ( x - Double . longBitsToDouble ( Double . doubleToLongBits ( x ) ^ NUMBER_CONSTANT ) ) ;
{ long bits = Double . doubleToLongBits ( x ) ; if ( bits < NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
{ long bits = Double . doubleToLongBits ( x ) ; if ( bits < NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
long inbits = Double . doubleToLongBits ( x ) ;
long bits = Double . doubleToLongBits ( x ) ;
long bits = Double . doubleToLongBits ( x ) ;
long xl = Double . doubleToLongBits ( d ) ;
File file = new File ( url . getFile () ) ;
{ return Double . longBitsToDouble ( Long.MAX_VALUE & Double . doubleToRawLongBits ( x ) ) ; }
{ return Float . intBitsToFloat ( Integer.MAX_VALUE & Float . floatToRawIntBits ( x ) ) ; }
double [] [] matrix
{ this ( lower , upper , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ fit ( initialMixture , defaultMaxIterations , defaultThreshold ) ; }
sum += FastMath . pow ( distA / distB , NUMBER_CONSTANT / ( fuzzyness - NUMBER_CONSTANT ) ) ;
final double u = FastMath . pow ( membershipMatrix [ i ] [ j ] , fuzzyness ) ;
final long grayCode = i ^ ( i / NUMBER_CONSTANT ) ;
int count = ( samples / centers ) * centers ;
{ this . a [ i ] [ j ] = a [ i + N * j ] ; }
assertArrayEquals ( expected , actual , NUMBER_CONSTANT ) ;
{ double tEnd = test ( NUMBER_CONSTANT ) ; assertEquals ( NUMBER_CONSTANT , tEnd , NUMBER_CONSTANT ) ; }
{ double tEnd = test ( NUMBER_CONSTANT ) ; assertEquals ( NUMBER_CONSTANT , tEnd , NUMBER_CONSTANT ) ; }
{ final double midPoint = NUMBER_CONSTANT * diff ; return diff * computeObjectiveValue ( midPoint ) ; }
{ dist = new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ dist = new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
incrementValue ( entry . getKey () , entry . getValue () ) ;
Assert . assertEquals ( false , random . nextBoolean () ) ;
{ result [ i ] = r . call () ; }
final int uniDimIndex = iter . next () ;
{ super ( specific , value , NUMBER_CONSTANT , true ) ; }
public NotPositiveException ( Number value ) { super ( value , NUMBER_CONSTANT , true ) ; }
{ super ( specific , NUMBER_CONSTANT , arguments ) ; }
{ return expected [ index ] ; }
{ return wrong [ index ] ; }
{ super ( specific , value , NUMBER_CONSTANT , false ) ; }
public NotStrictlyPositiveException ( Number value ) { super ( value , NUMBER_CONSTANT , false ) ; }
{ super ( specific , wrong , expected ) ; dimension = expected ; }
{ secRand = SecureRandom . getInstance ( algorithm , provider ) ; }
SecureRandom secRan = getSecRan () ;
T withConvergenceChecker ( ConvergenceChecker < PointVectorValuePair > checker ) ;
{ term *= FastMath . pow ( delta [ k ] , orders [ k ] ) / ArithmeticUtils . factorial ( orders [ k ] ) ; }
RandomDataImpl randomData = new RandomDataImpl () ;
{ coeff [ i ] [ j ] = ( int ) ArithmeticUtils . binomialCoefficient ( i , j ) ; }
long expected = ArithmeticUtils . binomialCoefficient ( i + j , i ) ;
double binomial = ArithmeticUtils . binomialCoefficient ( v + i , i ) ;
double refDer = - ArithmeticUtils . factorial ( n - NUMBER_CONSTANT ) / FastMath . pow ( - x , n ) ;
ArithmeticUtils . pow ( - NUMBER_CONSTANT , i ) * ArithmeticUtils . factorial ( i ) / FastMath . pow ( x , i + NUMBER_CONSTANT )
double inv = NUMBER_CONSTANT / ArithmeticUtils . factorial ( i ) ;
AbstractOptimizer other
{ return Double . valueOf ( o . toString () ) . doubleValue () ; }
return Double . valueOf ( str ) . doubleValue () ;
{ val = Double . valueOf ( str ) . doubleValue () ; sampleStats . addValue ( val ) ; }
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > () ;
List < Edge > edges = new ArrayList < Edge > () ;
final List < Segment > segments = new ArrayList < Segment > () ;
final List < EventHandler > list = new ArrayList < EventHandler > () ;
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > () ;
List < int [] > row = new ArrayList < int [] > () ;
final List < Segment > segments = new ArrayList < Segment > () ;
double [] vectorData = null ;
{ this ( value , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , f . getCount ( THREEE ) ) ;
f . addValue ( THREEE ) ;
{ return new Combinations ( n , k , Combinations.IterationOrder.LEXICOGRAPHIC ) . iterator () ; }
int [] index = getNatural ( n ) ;
{ final int [] natural = MathArrays . natural ( NUMBER_CONSTANT ) ; Assert . assertEquals ( natural.length , NUMBER_CONSTANT ) ; }
AbstractLeastSquaresOptimizer other
if ( a0 > overflow ) { throw new FractionConversionException ( value , a0 , NUMBER_CONSTANT ) ; }
{ return NUMBER_CONSTANT + NUMBER_CONSTANT * + NUMBER_CONSTANT * MathUtils . hash ( value ) + NUMBER_CONSTANT * derivatives . hashCode () ; }
mult . multInPlace ( var1 ) ;
{ return MathArrays . test ( values , weights , begin , length , allowEmpty ) ; }
{ return MathArrays . test ( values , weights , begin , length , false ) ; }
{ return MathArrays . test ( values , begin , length , allowEmpty ) ; }
{ return MathArrays . test ( values , begin , length , false ) ; }
w = w - NUMBER_CONSTANT ;
num = num % den ;
if ( i > NUMBER_CONSTANT ) { randInt = randInt > > NUMBER_CONSTANT ; }
for ( final T a : data ) { h = h ^ a . hashCode () ; }
rhs [ m ] = rhs [ m ] / X ;
coeff1 = coeff1 / pc2 ;
bits = bits & NUMBER_CONSTANT ;
den = den + NUMBER_CONSTANT ;
trial = trial * NUMBER_CONSTANT ;
den = den + NUMBER_CONSTANT ;
{ bytes [ i ++ ] = ( byte ) ( random & NUMBER_CONSTANT ) ; random = random > > NUMBER_CONSTANT ; }
if ( result == NUMBER_CONSTANT ) { result = result * x ; }
za = za * ya ;
e = e > > NUMBER_CONSTANT ;
z = z * lnb ;
xl = xl & MASK_30BITS ;
r = r * rnd ;
extra = extra - rh * RADIX ;
{ while ( NUMBER_CONSTANT == n % p ) { n = n / p ; factors . add ( p ) ; } }
n = n | NUMBER_CONSTANT ;
xx = xx + NUMBER_CONSTANT / NUMBER_CONSTANT ;
iter = iter + NUMBER_CONSTANT ;
{ data [ i ] = data [ i ] / d ; }
{ data [ i ] = data [ i ] * d ; }
{ data [ i ] = data [ i ] - d ; }
{ data [ i ] = data [ i ] + d ; }
k = k + m ;
coeff1 = coeff1 / pc2 ;
{ c [ NUMBER_CONSTANT ] = c [ NUMBER_CONSTANT ] + NUMBER_CONSTANT ; return ret ; }
coeff1 = coeff1 / pc2 ;
{ m = m > > NUMBER_CONSTANT ; ++ k ; }
e = e > > NUMBER_CONSTANT ;
e = e > > NUMBER_CONSTANT ;
e = e > > NUMBER_CONSTANT ;
v = v * v ;
{ ret = scale * FastMath . pow ( - FastMath . log ( NUMBER_CONSTANT - p ) , NUMBER_CONSTANT / shape ) ; }
( a * FastMath . log ( x ) ) + ( b * FastMath . log ( NUMBER_CONSTANT - x ) )
return ( FastMath . exp ( ss ) - NUMBER_CONSTANT ) * FastMath . exp ( NUMBER_CONSTANT * scale + ss ) ;
{ correct ( new ArrayRealVector ( z ) ) ; }
{ predict ( new ArrayRealVector ( u ) ) ; }
minadj /= ( divisor.mant [ mant.length - NUMBER_CONSTANT ] + NUMBER_CONSTANT ) ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= Math . sqrt ( sp ) ;
{ double f = Math . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= Math . sqrt ( sp ) ;
{ double f = Math . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
final double max = Math.PI ;
{ FunctionUtils . sample ( new Sin () , NUMBER_CONSTANT , Math.PI , NUMBER_CONSTANT ) ; }
{ FunctionUtils . sample ( new Sin () , NUMBER_CONSTANT , Math.PI , - NUMBER_CONSTANT ) ; }
{ FunctionUtils . sample ( new Sin () , Math.PI , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
double x = Math . random () * NUMBER_CONSTANT ;
double x = Math . random () ;
- NUMBER_CONSTANT / ( a * a ) - NUMBER_CONSTANT + Math . cos ( a )
minDiff = Math . min ( minDiff , boundDifference [ i ] ) ;
minDiff = Math . min ( minDiff , boundDifference [ i ] ) ;
{ d [ r ] [ c ] = Math . sqrt ( m . getEntry ( r , c ) ) ; }
{ d [ r ] [ c ] = Math . log ( m . getEntry ( r , c ) ) ; }
double diff = Math . abs ( x [ i ] - repaired [ i ] ) ;
( NUMBER_CONSTANT - ccovmu ) * NUMBER_CONSTANT * mueff / ( Math . pow ( dimension + NUMBER_CONSTANT , NUMBER_CONSTANT ) + NUMBER_CONSTANT * mueff )
{ d [ r ] [ c ] = Math . sqrt ( m . getEntry ( r , c ) ) ; }
{ d [ r ] [ c ] = Math . log ( m . getEntry ( r , c ) ) ; }
double diff = Math . abs ( x [ i ] - repaired [ i ] ) ;
( NUMBER_CONSTANT - ccovmu ) * NUMBER_CONSTANT * mueff / ( Math . pow ( dimension + NUMBER_CONSTANT , NUMBER_CONSTANT ) + NUMBER_CONSTANT * mueff )
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= Math . sqrt ( sp ) ;
{ double f = Math . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
double diff = Math . abs ( constantValue - filter . getStateEstimation () [ NUMBER_CONSTANT ] ) ;
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , Math . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , Math . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , Math . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= Math . sqrt ( sp ) ;
{ double f = Math . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
a1 = FastMath . sqrt ( FastMath.PI * twolpd ) * FastMath . exp ( NUMBER_CONSTANT / NUMBER_CONSTANT * lambda )
ret += c [ i ] * ArithmeticUtils . pow ( n , ( long ) i ) ;
for ( int i = NUMBER_CONSTANT ; i < length ; i ++ ) { sample [ i ] = Math . random () ; }
System . arraycopy ( seed , NUMBER_CONSTANT , v , NUMBER_CONSTANT , Math . min ( seed.length , v.length ) ) ;
expected = Math . abs ( period ) - delta ;
final int shift = Math . min ( aTwos , bTwos ) ;
double xabs = Math . abs ( v [ i ] ) ;
int shift = Math . max ( numerator . bitLength () , denominator . bitLength () ) - FastMath . getExponent ( Float.MAX_VALUE ) ;
int shift = Math . max ( numerator . bitLength () , denominator . bitLength () ) - FastMath . getExponent ( Double.MAX_VALUE ) ;
double denom = Math . abs ( val ) < EPS_MIN ? NUMBER_CONSTANT * EPS_MIN : NUMBER_CONSTANT * val ;
int k = ( int ) Math . ceil ( n * d ) ;
final int k = ( int ) Math . ceil ( n * d ) ;
final int k = ( int ) Math . ceil ( n * d ) ;
{ return NUMBER_CONSTANT - NUMBER_CONSTANT * Math . pow ( NUMBER_CONSTANT - d , n ) ; }
double err = Math . abs ( actual - expected ) / Math . ulp ( expected ) ;
double denom = Math . abs ( val ) < EPS_MIN ? NUMBER_CONSTANT * EPS_MIN : NUMBER_CONSTANT * val ;
{ return Math . exp ( x ) - Math . pow ( Math.PI , NUMBER_CONSTANT ) ; }
new Fraction ( ( ( Math . abs ( w ) * d ) + n ) * MathUtils . copySign ( NUMBER_CONSTANT , w ) , d )
num = Math . abs ( num ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
h += p_i * Math . log ( p_i ) ;
h += p_ij * Math . log ( p_ij ) ;
if ( Math . abs ( sumExpected - sumObserved ) > NUMBER_CONSTANT ) { ratio = sumObserved / sumExpected ; rescale = true ; }
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
public double estimateRegressionStandardError () { return Math . sqrt ( estimateErrorVariance () ) ; }
Assert . assertTrue ( STRING_CONSTANT , Math . abs ( v - randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) > NUMBER_CONSTANT ) ;
System . arraycopy ( seed , NUMBER_CONSTANT , rsl , NUMBER_CONSTANT , Math . min ( seedLen , rslLen ) ) ;
Math . sqrt ( d [ col ] ) < tol [ col ]
Math . sqrt ( d [ i ] ) < tol [ i ]
final double result = NUMBER_CONSTANT * Erf . erfc ( ref [ i ] [ NUMBER_CONSTANT ] / Math . sqrt ( NUMBER_CONSTANT ) ) ;
final double originalDelta = Math . random () ;
final double gn = factor1 * Math . log ( qExp1 ) * oneOverN ;
{ public double value ( double x ) { return NUMBER_CONSTANT / ( NUMBER_CONSTANT * Math . sqrt ( x ) ) ; } }
f = new UnivariateFunction () { public double value ( double x ) { return Math . sqrt ( x ) ; } }
{ minValue = entry ; minPos = i ; if ( pivotSelection == PivotSelectionRule.Bland && isValidPivotColumn ( tableau , i ) ) { break; } }
this . pivotSelection = PivotSelectionRule.Dantzig ;
solution = new SimplexSolver () . optimize ( DEFAULT_MAX_ITER , f , new DeterministicLinearConstraintSet ( constraints ) , GoalType.MINIMIZE , new NonNegativeConstraint ( true ) , PivotSelectionRule.BLAND )
{ this ( f , constraints , goalType , restrictToNonNegative , epsilon , SimplexSolver.DEFAULT_ULPS , SimplexSolver.DEFAULT_CUT_OFF ) ; }
if ( Precision . compareTo ( entry , NUMBER_CONSTANT , maxUlps ) > NUMBER_CONSTANT ) { return true ; }
final Vector < S > point
final Vector < Euclidean2D > point
final Vector < Euclidean2D > point
final Vector < Euclidean2D > point
final Vector < Euclidean1D > point
final Vector < Euclidean2D > point
Vector < S > point
final Vector < Euclidean3D > point
final Vector < Euclidean3D > point
final Vector < Euclidean1D > point
final Vector < Euclidean3D > point
final Vector < S > point
{ final Vector2D v2 = ( Vector2D ) v ; return x * v2.x + y * v2.y ; }
final Vector < S > barycenter
final Vector < S > point
final Vector < S > point
final Vector < Euclidean1D > point
public ArcsSet wholeSpace () { return new ArcsSet () ; }
{ return Vector3D . angle ( pole , direction ) - radius ; }
public SphericalPolygonsSet wholeSpace () { return new SphericalPolygonsSet () ; }
public SubCircle wholeHyperplane () { return new SubCircle ( this , new ArcsSet () ) ; }
{ this ( circle.pole , circle.x , circle.y , circle.radius , circle.cos , circle.sin ) ; }
{ return new ArcsSet ( tree ) ; }
final Vector1D x = thisLine . toSubSpace ( crossing ) ;
final Vector1D x = thisLine . toSubSpace ( crossing ) ;
final double offset = plane . getOffset ( point ) ;
Vector < Euclidean2D > p
Vector < Euclidean1D > p
Vector < Euclidean3D > v
final Vector3D point = line . toSpace ( Vector1D.ZERO ) ;
public SubChord copySelf () { return new SubChord ( chord , limits ) ; }
{ this . upper = NUMBER_CONSTANT * FastMath.PI + lower ; }
Arc arc = new Arc ( NUMBER_CONSTANT , FastMath . nextAfter ( NUMBER_CONSTANT , Double.POSITIVE_INFINITY ) ) ;
{ return buildNew ( hyperplane , remainingRegion ) ; }
Segment segment = new Segment ( p1 , p2 , new Line ( p1 , p2 ) ) ;
final EdgesBuilder visitor = new EdgesBuilder ( root , tolerance ) ;
{ return new SphericalPolygonsSet ( tree , tolerance ) ; }
{ super ( boundary ) ; this . tolerance = tolerance ; }
{ super ( tree ) ; this . tolerance = tolerance ; }
public SphericalPolygonsSet ( final double tolerance ) { this . tolerance = tolerance ; }
return getRemainingRegion () . side ( new OrientedPoint ( x , direct ) ) ;
public SubLine wholeLine () { return new SubLine ( this , new IntervalsSet () ) ; }
{ return distance ( p ) < NUMBER_CONSTANT ; }
final BSPTree < S > cell = node . getCell ( point ) ;
{ return new PolyhedronsSet ( tree ) ; }
public IntervalsSet wholeSpace () { return new IntervalsSet () ; }
{ add ( new NestedLoops ( bLoop ) ) ; }
return new OrientedPoint ( newLoc , op . isDirect () ) . wholeHyperplane () ;
{ return FastMath . abs ( getOffset ( p ) ) < NUMBER_CONSTANT ; }
public PolygonsSet wholeSpace () { return new PolygonsSet () ; }
public SubLine wholeHyperplane () { return new SubLine ( this , new IntervalsSet () ) ; }
if ( FastMath . abs ( d ) < NUMBER_CONSTANT ) { return null ; }
{ return new PolygonsSet ( tree ) ; }
if ( line == null ) { line = new Line ( start . getLocation () , end . getLocation () ) ; }
{ return new ArcsSet ( tree , tolerance ) ; }
{ return new LimitAngle ( new S1Point ( alpha ) , true , tolerance ) . wholeHyperplane () ; }
{ return new LimitAngle ( new S1Point ( alpha ) , false , tolerance ) . wholeHyperplane () ; }
{ super ( boundary ) ; this . tolerance = tolerance ; }
{ super ( tree ) ; this . tolerance = tolerance ; }
public ArcsSet ( final double tolerance ) { this . tolerance = tolerance ; }
Segment segment = new Segment ( start , end , new Line ( start , end ) ) ;
{ return new Line ( start , end ) . wholeHyperplane () ; }
return new PolygonsSet ( edges ) ;
final BoundaryProjector projector = new BoundaryProjector () ;
public PolyhedronsSet wholeSpace () { return new PolyhedronsSet () ; }
public SubPlane wholeHyperplane () { return new SubPlane ( this , new PolygonsSet () ) ; }
final Plane plane = new Plane ( origin . add ( translation ) , w ) ;
PolyhedronsSet tree = new PolyhedronsSet ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new IntervalsSet ( tree ) ; }
boundary . add ( new LimitAngle ( new S1Point ( MathUtils.TWO_PI ) , true , NUMBER_CONSTANT ) . wholeHyperplane () ) ;
( Boolean ) getTree ( false ) . getAttribute ()
Assert . assertTrue ( projection . get0riginal () == v ) ;
List < P > points
final List < P > points
ConvexHull2D hull = generator . generate ( points ) ;
GrahamScan2D generator = new GrahamScan2D () ;
RandomGenerator random = new MersenneTwister ( NUMBER_CONSTANT ) ;
@ Before public void setUp () { generator = createConvexHullGenerator () ; random = new MersenneTwister ( NUMBER_CONSTANT ) ; }
final Collection < Vector2D > points
checkConvexHull ( points , hull ) ;
ConvexHullGenerator2D generator = new MonotoneChain () ;
public Segment [] getLineSegments () { return lineSegments . clone () ; }
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.MINUS_I ) . ballOnSupport ( support ) ;
cap = new SphericalCapGenerator ( new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . ballOnSupport ( support )
cap = new SphericalCapGenerator ( new Vector3D ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ) . ballOnSupport ( support )
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.MINUS_K ) . ballOnSupport ( support ) ;
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.MINUS_K ) . ballOnSupport ( support ) ;
{ return new EnclosingBall < Sphere2D , S2Point > ( new S2Point ( outside . negate () ) , - NUMBER_CONSTANT ) ; }
@ Override protected ConvexHullGenerator2D createConvexHullGenerator ( boolean includeCollinearPoints ) { return new GrahamScan ( includeCollinearPoints ) ; }
{ return getOptimizer ( points ) . optimize () . getPoint () ; }
boolean useLU
{ return LevenbergMarquardtOptimizer . create () ; }
optimizer = LevenbergMarquardtOptimizer . create () . withInitialStepBoundFactor ( initialStepBoundFactor ) . withCostRelativeTolerance ( costRelativeTolerance ) . withParameterRelativeTolerance ( parRelativeTolerance ) . withOrthoTolerance ( orthoTolerance ) . withRankingThreshold ( Precision.SAFE_MIN )
{ return new LeastSquaresProblemImpl ( maxEvaluations , maxIterations , checker , observed , model , jacobian , start ) ; }
public RealMatrix computeJacobian () { return MatrixUtils . createRealMatrix ( this . jacobian ) ; }
public double [] computeValue () { return this . values ; }
@ Test public void testGaussNewtonQR ( ) throws Exception { check ( new GaussNewtonOptimizer ( false ) ) ; }
@ Test public void testGaussNewtonLU ( ) throws Exception { check ( new GaussNewtonOptimizer ( true ) ) ; }
final ConvergenceChecker < PointVectorValuePair > checker
final ConvergenceChecker < PointVectorValuePair > checker
final ConvergenceChecker < PointVectorValuePair > checker
final ConvergenceChecker < PointVectorValuePair > checker
final ConvergenceChecker < PointVectorValuePair > checker
{ return new LeastSquaresBuilder () . checker ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . maxEvaluations ( NUMBER_CONSTANT ) . maxIterations ( getMaxIterations () ) ; }
builder ( circle ) . checker ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . maxIterations ( Integer.MAX_VALUE )
function . checkTheoreticalMinParams ( optimum . getPoint () ) ;
double [] point
double [] computeValue ( ) ;
double [] point
double [] getStart ( ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , NUMBER_CONSTANT ) ;
final double [] point
final double [] point
final double [] start
final double [] target
public RealVector computeValue () { return unweighted . computeValue () ; }
catch ( NonPositiveDefiniteMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertTrue ( optimum . computeRMS () > NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
RealVector computeValue ( ) ;
final double cost = lsp . evaluate ( params ) . computeCost () ;
final RealVector sigma = lsp . evaluate ( regress ) . computeSigma ( NUMBER_CONSTANT ) ;
final RealVector sigma = lsp . evaluate ( init ) . computeSigma ( NUMBER_CONSTANT ) ;
function . checkTheoreticalMinCost ( optimum . computeRMS () ) ;
final double [] asymptoticStandardErrorFound = optimum . computeSigma ( NUMBER_CONSTANT ) . toArray () ;
final RealMatrix covarMatrix = optimum . computeCovariances ( NUMBER_CONSTANT ) ;
final double actual = lsp . evaluate ( lsp . getStart () ) . computeRMS () ;
final double cost = lsp . evaluate ( lsp . getStart () ) . computeCost () ;
Assert . assertArrayEquals ( evaluation . computeResiduals () . toArray () , new double [] { NUMBER_CONSTANT , - NUMBER_CONSTANT } , Precision.EPSILON ) ;
Assert . assertNotSame ( STRING_CONSTANT , v1 . getDataRef () , v_copy . getData () ) ;
{ return new LeastSquaresProblemImpl ( model , observed , start , checker , maxEvaluations , maxIterations ) ; }
assertEquals ( TOl , optimum . getValue () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
line = new LineSearch ( lineRel , lineAbs ) ;
line = new LineSearch ( this , lineRel , lineAbs ) ;
{ this ( updateFormula , checker , NUMBER_CONSTANT , NUMBER_CONSTANT , new IdentityPreconditioner () ) ; }
penalty += diff * valueRange ;
public FitnessFunction () { valueRange = NUMBER_CONSTANT ; isRepairMode = true ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( getX () ) ; }
public RealVector getResiduals () { return this . residuals ; }
public RealVector getPoint () { return this . point ; }
public RealMatrix getJacobian () { return this . jacobian ; }
super ( null ) ;
@ Override protected RealDistribution getKernel ( SummaryStatistics bStats ) { return new ConstantDistribution ( bStats . getMean () ) ; }
return new Median () . withEstimationtype ( type ) . withNaNStrategy ( strategy ) ;
double result = new Percentile ( p ) . withEstimationtype ( e ) . withNaNStrategy ( nanStrategy ) . evaluate ( data ) ;
{ new Percentile ( NUMBER_CONSTANT ) . withEstimationtype ( Percentile.EstimationType.LEGACY ) . withNaNStrategy ( null ) ; Assert . fail ( STRING_CONSTANT + STRING_CONSTANT ) ; }
new Percentile ( NUMBER_CONSTANT ) . withEstimationtype ( Percentile.EstimationType.R_9 ) . withNaNStrategy ( NaNStrategy.FAILED ) . evaluate ( specialValues , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new Percentile ( quantile ) . withEstimationtype ( type ) . withNaNStrategy ( nanStrategy ) . withPivotingStrategy ( pivotingStrategy ) ; }
final BicubicSplineInterpolator bsi = new BicubicSplineInterpolator () ;
return new BicubicSplineInterpolatingFunction ( xval , yval , fval , dFdX , dFdY , d2FdXdY ) ;
final FieldMatrix < BigFraction > H = this . createH ( d , n ) ;
Percentile p = getUnivariateStatistic () ;
Percentile p = getUnivariateStatistic () ;
Percentile p = getUnivariateStatistic () ;
{ for ( Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testWeightedConsistency () ; } }
{ for ( Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testEvaluateArraySegment () ; } }
{ for ( Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testEvaluateArraySegmentWeighted () ; } }
UnivariateStatistic percentile = getUnivariateStatistic () ;
UnivariateStatistic percentile = getUnivariateStatistic () ;
Percentile percentile = new Percentile ( NUMBER_CONSTANT ) ;
{ return new Median ( getEstimationType () , newNaNStrategy , getPivotingStrategy () ) ; }
{ return new Median ( newEstimationType , getNaNStrategy () , getPivotingStrategy () ) ; }
return work.length == NUMBER_CONSTANT ? Double.NaN : estimationType . evaluate ( work , pivotsHeap , p , pivotingStrategy ) ;
pivotingStrategy = original . getPivotingStrategy () ;
final double Umin = x.length * y.length - Umax ;
{ return new LazyUnweightedEvaluation ( model , target , p ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , ( ( ResizableDoubleArray ) da ) . getContractionCriteria () , NUMBER_CONSTANT ) ;
ResizableDoubleArray testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ADDITIVE_MODE ) ;
testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ADDITIVE_MODE ) ;
ResizableDoubleArray testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ADDITIVE_MODE ) ;
RandomDataImpl random = new RandomDataImpl () ;
empiricalDistribution = new EmpiricalDistribution ( binCount , randomData ) ;
{ this . randomData = new RandomDataImpl ( generator ) ; }
{ this . randomData = randomData ; }
{ return ( FastMath.PI * FastMath.PI / NUMBER_CONSTANT ) * ( NUMBER_CONSTANT / ( s * s ) ) ; }
final NormalDistribution standardNormal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final FDistribution fdist = new FDistribution ( a.dfbg , a.dfwg ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
final NormalDistribution standardNormal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final BinomialDistribution distribution = new BinomialDistribution ( numberOfTrials , probability ) ;
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( getX () ) ; }
t . insertInTree ( parentTree , isPlusChild ) ;
return ( sin * otherL.sin + cos * otherL.cos ) >= NUMBER_CONSTANT ;
tree = region1 . getTree ( false ) . merge ( region2 . getTree ( false ) , new DifferenceMerger () )
{ originOffset = offset ; }
if ( p == NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else if ( p == NUMBER_CONSTANT ) { return Double.POSITIVE_INFINITY ; }
{ vals = Arrays . copyOf ( b , b.length ) ; nVals = n ; }
org.apache.commons.math3.stat.inference.ChiSquareTest csti = new org.apache.commons.math3.stat.inference.ChiSquareTest () ;
org.apache.commons.math3.stat.inference.ChiSquareTest csti = new org.apache.commons.math3.stat.inference.ChiSquareTest () ;
cachedTransform = org.apache.commons.math3.geometry.euclidean.twod.Line . getTransform ( at ) ;
cachedTransform = org.apache.commons.math3.geometry.euclidean.twod.Line . getTransform ( at ) ;
@ Test ( expected = org.apache.commons.math3.linear.SingularMatrixException . class )
( numIterations < maximumIterations ) && ( a > lowerBound || b > upperBound )
public Well19937c ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937c ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well512a ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well512a ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497b ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497b ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well1024a ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well1024a ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497a ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497a ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937a ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937a ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
TestUtils . assertEquals ( m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . getData () ) , preMultTest ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . getData () ) , preMultTest ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
x = new UniformRealDistribution ( rng , lo , hi , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
x = new UniformRealDistribution ( rng , lo , hi , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
x = new UniformRealDistribution ( rng , lo , hi , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
try { distribution . cumulativeProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
{ double actual = getDistribution () . cumulativeProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , actual , NUMBER_CONSTANT ) ; }
distribution . cumulativeProbability ( lower [ i ] , upper [ i ] )
final double withinBinKernelMass = kernel . cumulativeProbability ( lower , upper ) ;
try { distribution . cumulativeProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
( ( AbstractRealDistribution ) distribution ) . logDensity ( cumulativeTestPoints [ i ] )
@ Test ( expected = MathIllegalArgumentException . class ) public void testNullFunction () { UnivariateSolverUtils . bracket ( null , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
try { StatUtils . min ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . max ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . mean ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
tournamentPopulation = new ListPopulation ( this . arity ) { public Population nextGeneration () { return null ; } }
delta = ( max - min ) / ( ( double ) binCount ) ;
T reciprocal ( ) ;
delta = ( max - min ) / ( binCount ) ;
protected double getSolverAbsoluteAccuracy () { return solverAbsoluteAccuracy ; }
SparseGradient sgY2 = sgX . compose ( poly . value ( x ) , poly . derivative () . value ( x ) ) ;
Assert . assertEquals ( f . polynomialDerivative () . derivative () . value ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , tolerance ) ;
UnivariateFunction dSpline = spline . derivative () ;
{ return FastMath . abs ( getOffset ( p ) ) < NUMBER_CONSTANT ; }
if ( direction . getNorm () < NUMBER_CONSTANT ) { return null ; }
test ( values , weights , begin , length , true )
test ( values , begin , length , true )
m . evaluate ( values ) ;
test ( values , begin , length , true )
test ( values , begin , length , true )
test ( values , begin , length ) && length > NUMBER_CONSTANT
test ( values , start , length ) ;
test ( values , begin , length )
test ( values , begin , length )
test ( values , begin , length ) ;
test ( values , weights , begin , length , true )
{ test ( values , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
ptile . evaluate ( d ) ;
test ( values , weights , begin , length )
test ( values , begin , length )
test ( values , weights , begin , length )
test ( values , begin , length )
m . evaluate ( values ) ;
catch ( IllegalArgumentException iae ) {}
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
catch ( IllegalArgumentException iae ) { return true ; }
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
try { stats . setWindowSize ( - NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException iae ) {}
{ try { new DummyBinaryChromosome ( repr ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException e ) {} }
catch ( IllegalArgumentException iae ) {}
final double Hs = generalizedHarmonic ( N , s ) ;
final double Hs = generalizedHarmonic ( N , s ) ;
return generalizedHarmonic ( x , exponent ) / generalizedHarmonic ( numberOfElements , exponent ) ;
return - FastMath . log ( x ) * exponent - FastMath . log ( generalizedHarmonic ( numberOfElements , exponent ) ) ;
if ( x != x ) { return x ; }
if ( x != x ) { return x ; }
if ( x != x ) { return Double.NaN ; }
if ( x != x ) { return Double.NaN ; }
if ( x != x || y != y ) { return Double.NaN ; }
if ( x != x || x == NUMBER_CONSTANT ) { return x ; }
if ( x != x ) { return x ; }
if ( x != x ) { return x ; }
if ( x != x ) { return x ; }
{ super ( LocalizedFormats.UNKNOWN_PARAMETER ) ; this . name = name ; }
final int exponent
MultivariateInterpolator interpolator = new MicrosphereInterpolator () ;
int brightnessExponent
{ return ( BigInteger.ZERO . compareTo ( numerator ) <= NUMBER_CONSTANT ) ? this : negate () ; }
final long numCalls = numberOfCalls . incrementAndGet () ;
final Gaussian neighbourhoodDecay = new Gaussian ( currentLearning , NUMBER_CONSTANT , NUMBER_CONSTANT / currentNeighbourhood ) ;
{ return new Fraction ( numerator , denominator * i ) ; }
{ return new Fraction ( numerator * i , denominator ) ; }
TestUtils . assertRelativelyEquals ( expected , ZipfRejectionSampler . helper2 ( testValue ) * testValue , tol ) ;
evaluations . setMaximalCount ( maxEvaluations ) ;
int rowOffset = NUMBER_CONSTANT ;
int swaps = NUMBER_CONSTANT ;
{ if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return FastMath . pow ( NUMBER_CONSTANT - probabilityOfSuccess , x ) * probabilityOfSuccess ; } }
SQRT_TWO_PI / x * FastMath . pow ( y , absX + NUMBER_CONSTANT ) * FastMath . exp ( - y )
return new CorrelatedRandomVectorGenerator ( new double [ cov.length ] , matrix , small , new GaussianRandomGenerator ( new JDKRandomGenerator () ) ) ;
public BigFractionMatrixConverter () { super ( BigFraction.ZERO ) ; }
public FractionMatrixConverter () { super ( Fraction.ZERO ) ; }
final FieldUnivariateFunction < T > f
final FieldUnivariateFunction < T > f
FieldUnivariateFunction < Dfp > f
final EnumeratedRealDistribution dist = new EnumeratedRealDistribution ( combined ) ;
public JDKRandomGenerator ( int seed ) { setSeed ( seed ) ; }
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
starter . addStepHandler ( new NordsieckInitializer ( nSteps , y0.length ) ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
{ evaluations . incrementCount () ; expandable . computeDerivatives ( t , y , yDot ) ; }
evaluations . resetCount () ;
catch ( InitializationCompletedMarkerException icme ) { getEvaluationsCounter () . incrementCount ( starter . getEvaluations () ) ; }
FieldVector3D < DerivativeStructure > axis = r . getAxis () ;
FieldVector3D < Dfp > axis = r . getAxis () ;
Vector3D axis = r . getAxis () ;
{ return r1 . applyInverseTo ( r2 ) . getAngle () ; }
{ return r1 . applyInverseTo ( r2 ) . getAngle () ; }
final Rotation composite = r3 . applyTo ( r2 . applyTo ( r1 ) ) ;
{ try { return super . nextInt ( n ) ; } catch ( IllegalArgumentException e ) { throw new NotStrictlyPositiveException ( n ) ; } }
{ setSeed ( RandomGeneratorFactory . convertToLong ( seed ) ) ; }
{ setSeed ( ( long ) seed ) ; }
setSeed ( seed ) ;
{ setSeed ( seed ) ; }
public ISAACRandom ( long seed ) { setSeed ( seed ) ; }
{ setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ bits = ( nextInt () > > > NUMBER_CONSTANT ) ; val = bits % n ; }
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ setSeed ( new int [] { seed } ) ; }
return computeInterpolatedStateAndDerivatives ( equations , theta , oneMinusThetaH ) ;
equations = null ;
yDotK [ NUMBER_CONSTANT ] = stepStart . getDerivative () ;
mainSetDimension = eqn . getState () . length ;
final FieldBracketingNthOrderBrentSolver < T > solver
final FieldBracketingNthOrderBrentSolver < T > solver
FieldBracketingNthOrderBrentSolver < T > solver
public TestProblem5 () { super(); setFinalConditions ( NUMBER_CONSTANT * t0 - t1 ) ; }
i < n
i < n
i < n
for ( int i = NUMBER_CONSTANT ; i < n ; ++ i ) { y [ i ] = c ; }
i < n
currentState = y . clone () ;
super ( field , METHOD_NAME , true , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , true , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
super ( field , METHOD_NAME , false , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , false , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
start . subtract ( problem . getInitialTime () ) . divide ( integrator . getCurrentSignedStepsize () ) . abs () . getReal () > NUMBER_CONSTANT
{ super ( field ) ; setFinalConditions ( getInitialTime () . multiply ( NUMBER_CONSTANT ) . subtract ( getFinalTime () ) ) ; }
super ( field , METHOD_NAME , true , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , true , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
{ return new EulerFieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new DormandPrince54FieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new GillFieldStepInterpolator < T > ( this , forward , mapper ) ; }
final T one = time . getField () . getOne () ;
{ return new MidpointFieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new LutherFieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new ThreeEighthesFieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new DormandPrince853FieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ finalizeStep () ; return doCopy () ; }
final T coeffDot1 = time . getField () . getOne () . subtract ( coeffDot2 ) ;
final T one = time . getField () . getOne () ;
{ return new HighamHall54FieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return integrator . getField () . getOne () . multiply ( p ) . divide ( q ) ; }
d = MathArrays . buildArray ( integrator . getField () , NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
{ return new ClassicalRungeKuttaFieldStepInterpolator < T > ( this , forward , mapper ) ; }
final T two = getField () . getOne () . multiply ( NUMBER_CONSTANT ) ;
{ return getField () . getOne () . multiply ( p ) . divide ( q ) ; }
{ return new EulerFieldStepInterpolator <> ( field , forward , mapper ) ; }
mapper = new FieldEquationsMapper <> ( mapper , secondary . getDimension () ) ;
FieldFirstOrderDifferentialEquations < T > eqn = new SinCos <> ( field ) ;
setUpInterpolator ( field , new SinCos <> ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
setUpInterpolator ( field , new SinCos <> ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
integrator . integrate ( new FieldExpandableODE <> ( problem ) , problem . getInitialState () , problem . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( equations ) , new FieldODEState < T > ( t0 , y0 ) , t ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
steps . add ( interpolator . copy () ) ;
for ( FieldStepInterpolator < T > interpolator : model.steps ) { steps . add ( interpolator . copy () ) ; }
while ( ++ index < getNumberOfEquations () ) { insertEquationData ( index , state . getSecondaryDerivative ( index - NUMBER_CONSTANT ) , yDot ) ; }
while ( ++ index < getNumberOfEquations () ) { insertEquationData ( index , state . getSecondaryState ( index - NUMBER_CONSTANT ) , y ) ; }
{ System . arraycopy ( mapper.start , NUMBER_CONSTANT , start , NUMBER_CONSTANT , index ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test
@ Test
@ Test
@ Test
@ Test
@ Test
@ Test
@ Test
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
FieldFirstOrderIntegrator < T > integrator
final FieldFirstOrderDifferentialEquations < T > eqn
final FieldFirstOrderDifferentialEquations < T > eqn
final FieldFirstOrderIntegrator < T > integrator
final FieldFirstOrderDifferentialEquations < T > equations
final FieldFirstOrderDifferentialEquations < T > primary
@ Test ( expected = MaxCountExceededException . class ) public void exceedMaxEvaluations () { doExceedMaxEvaluations ( Decimal64Field . getInstance () ) ; }
{ return taylor ( getPreviousState () , time , scalingH , scaled , nordsieck ) ; }
if ( seed == null ) { setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ setSeedInternal ( new int [] { seed } ) ; }
if ( seed == null ) { setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ bits = nextInt () > > > NUMBER_CONSTANT ; val = bits % n ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ setSeedInternal ( seed ) ; }
public ISAACRandom ( long seed ) { setSeedInternal ( seed ) ; }
{ setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
setSeedInternal ( seed ) ;
{ return timeAndReport ( title , DEFAULT_REPEAT_CHUNK , DEFAULT_REPEAT_STAT , false , methods ) ; }
double sample ( ) ;
random = new Well44497b ( seed ) ;
{ this ( cityList , numNeuronsPerCity , new Well44497b () . nextLong () ) ; }
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
{ final double u = random . nextDouble () ; return u * upper + ( NUMBER_CONSTANT - u ) * lower ; }
return empiricalDistribution . getNextValue () ;
empiricalDistribution = new EmpiricalDistribution ( binCount , randomData . getRandomGenerator () ) ;
{ super ( null ) ; this . value = value ; }
final FDistribution fdist = new FDistribution ( null , a.dfbg , a.dfwg ) ;
final FDistribution fdist = new FDistribution ( null , a.dfbg , a.dfwg ) ;
final TDistribution distribution = new TDistribution ( null , degreesOfFreedom ) ;
final TDistribution distribution = new TDistribution ( null , degreesOfFreedom ) ;
final TDistribution distribution = new TDistribution ( null , n - NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final NormalDistribution standardNormal = new NormalDistribution ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final NormalDistribution standardNormal = new NormalDistribution ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final BinomialDistribution distribution = new BinomialDistribution ( null , numberOfTrials , probability ) ;
{ randomSource = RandomSource.WELL_19937_C ; }
return complexSolver . solve ( ComplexUtils . convertToComplex ( coefficients ) , new Complex ( initial , NUMBER_CONSTANT ) ) ;
return complexSolver . solveAll ( ComplexUtils . convertToComplex ( coefficients ) , new Complex ( initial , NUMBER_CONSTANT ) ) ;
final Complex c [] = ComplexUtils . convertToComplex ( getCoefficients () ) ;
RandomGenerator rng = new Well19937c ( NUMBER_CONSTANT ) ;
NormalDistribution distribution
if ( shuffle ) { Collections . shuffle ( points ) ; }
if ( shuffle ) { Collections . shuffle ( points ) ; }
if ( shuffle ) { Collections . shuffle ( points ) ; }
for ( int i = NUMBER_CONSTANT ; i < dim ; i ++ ) { normalVals [ i ] = random . nextGaussian () ; }
cachedD = MatrixUtils . createRealDiagonalMatrix ( realEigenvalues ) ;
ComplexFormat cf = ComplexFormat . getInstance () ;
ComplexFormat cf = ComplexFormat . getInstance () ;
RandomGenerator randomGenerator
public NaturalRanking ( RandomGenerator randomGenerator ) { this ( DEFAULT_NAN_STRATEGY , TiesStrategy.RANDOM , randomGenerator ) ; }
{ this ( nanStrategy , tiesStrategy , new Well19937c () ) ; }
{ this ( DEFAULT_NAN_STRATEGY , tiesStrategy , new Well19937c () ) ; }
final RandomGenerator random
final RandomGenerator random
{ this ( k , maxIterations , measure , new JDKRandomGenerator () ) ; }
final RandomGenerator random
{ this ( k , fuzziness , maxIterations , measure , DEFAULT_EPSILON , new JDKRandomGenerator () ) ; }
final RandomGenerator random = new JDKRandomGenerator () ;
final RandomGenerator random
final RandomGenerator random = GeneticAlgorithm . getRandomGenerator () ;
final RandomGenerator random = GeneticAlgorithm . getRandomGenerator () ;
RandomGenerator randGen = getRandomGenerator () ;
final RandomGenerator random
final RandomGenerator random = GeneticAlgorithm . getRandomGenerator () ;
{ d [ r ] [ c ] = random . nextGaussian () ; }
for ( int i = NUMBER_CONSTANT ; i < size ; i ++ ) { randn [ i ] = random . nextGaussian () ; }
final RandomGenerator generator
UnitSphereRandomVectorGenerator random = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , new Well1024a ( NUMBER_CONSTANT ) ) ;
UnitSphereRandomVectorGenerator random = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , new Well1024a ( NUMBER_CONSTANT ) ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
final double comp = rand . nextGaussian () ;
{ this ( dimension , new MersenneTwister () ) ; }
RandomGenerator random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator generator = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator generator = new Well1024a ( NUMBER_CONSTANT ) ;
{ field = new DfpField ( NUMBER_CONSTANT ) ; generator = new MersenneTwister ( NUMBER_CONSTANT ) ; }
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator rng = new Well19937a ( NUMBER_CONSTANT ) ;
final RandomGenerator r
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator rng = new Well1024a ( NUMBER_CONSTANT ) ;
new PivotingStrategyInterface [] { new MedianOf3PivotingStrategy () , new CentralPivotingStrategy () , new RandomPivotingStrategy ( RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) }
kthSelector = new KthSelector ( new RandomPivotingStrategy ( RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) ) ;
final RandomGenerator rng = new MersenneTwister () ;
return TestUtils . gTest ( expected , observed ) ;
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( random ) ) ; }
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( delegate ) ) ; }
this . rng = new Well19937c ( seed ) ;
rng = new Well19937c ( seed ) ;
RandomGenerator random = new MersenneTwister () ;
final RandomGenerator random = GeneticAlgorithm . getRandomGenerator () ;
final Collection < Neuron > exclude = new ArrayList < Neuron > () ;
ArrayFieldVector < T > out = new ArrayFieldVector < T > ( field , n ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
{ return new ArrayFieldVector < T > ( this , v ) ; }
final FieldMatrix < T > out = new Array2DRowFieldMatrix < T > ( field , m , n ) ;
final FieldMatrix < T > out = new Array2DRowFieldMatrix < T > ( field , m , n ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
{ return new ArrayFieldVector < T > ( this , true ) ; }
{ components = new ArrayList < ExpandableStatefulODE.SecondaryComponent > () ; firstIndex = primary . getDimension () ; }
this . components = new ArrayList < ExpandableStatefulODE.SecondaryComponent > () ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList < Object > () , transformers ) ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList < Object > () , transformers ) ;
DescriptiveStatistics u = new ListUnivariateImpl ( new ArrayList < Object > () , transformers ) ;
List < Object > externalList = new ArrayList < Object > () ;
List < Double > valuesList = new ArrayList < Double > () ;
List < Chromosome > popList = new LinkedList < Chromosome > () ;
return new Array2DRowFieldMatrix < Fraction > ( out ) ;
Array2DRowFieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
return new ArrayFieldVector < Fraction > ( data , false ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
{ Assert . assertEquals ( new Array2DRowFieldMatrix < Fraction > ( reference ) , sub ) ; }
{ Assert . assertEquals ( new Array2DRowFieldMatrix < Fraction > ( reference ) , sub ) ; }
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
Collection < SummaryStatistics > aggregate = new ArrayList < SummaryStatistics > () ;
Collection < SummaryStatistics > aggregate = new ArrayList < SummaryStatistics > () ;
Collection < StatisticalSummary > aggregate = new ArrayList < StatisticalSummary > () ;
Collection < SummaryStatistics > aggregate = new ArrayList < SummaryStatistics > () ;
return new FieldODEStateAndDerivative < T > ( time , y , yDot ) ;
this . interpolator = new PerfectInterpolator < T > ( problem ) ;
this . circles = new ArrayList < Circle > () ;
ContinuousOutputFieldModel < T > otherCm = new ContinuousOutputFieldModel < T > () ;
ContinuousOutputFieldModel < T > cm = new ContinuousOutputFieldModel < T > () ;
{ new SparseFieldMatrix < Fraction > ( field , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
return new ArrayFieldVector < Fraction > ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayFieldVector < Fraction > ( testVector ) ) . toArray () , entryTolerance ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testDataInv ) ) , identity , entryTolerance ) ;
RegionFactory < Sphere1D > factory = new RegionFactory < Sphere1D > () ;
List < SubHyperplane < Sphere1D > > boundary = new ArrayList < SubHyperplane < Sphere1D > > () ;
final ArrayList < Object [] > parameters = new ArrayList < Object [] > () ;
singletons = new ArrayList < T > ( pmf . size () ) ;
{ return new GillFieldIntegrator < T > ( field , field . getOne () ) ; }
final ArrayList < Object [] > parameters = new ArrayList < Object [] > () ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
DBSCANClusterer < DoublePoint > clusterer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > clusterer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
HashSet < Object > sampSet = new HashSet < Object > () ;
final List < double [] > coordinatesList = new ArrayList < double [] > () ;
final List < Neuron > list = new ArrayList < Neuron > () ;
final List < City > cityList = new ArrayList < City > () ;
public CircleVectorial () { points = new ArrayList < Vector2D > () ; }
{ return new MidpointFieldIntegrator < T > ( field , field . getOne () ) ; }
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
this . convexCellsInsidePoints = new ArrayList < Vector3D > () ;
root = new BSPTree < S > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
final List < Segment > segments = new ArrayList < Segment > ( list . size () ) ;
{ parametersNames = new ArrayList < String > () ; parametersNames . addAll ( names ) ; }
parametersNames = new ArrayList < String > () ;
return new Array2DRowFieldMatrix < T > ( field , d , false ) ;
{ map = new HashMap < Class < > , NumberTransformer > () ; defaultTransformer = new DefaultTransformer () ; }
final Set < T > oneSet = new HashSet < T > ( one ) ;
final List < T > neighbors = new ArrayList < T > () ;
List < T > seeds = new ArrayList < T > ( neighbors ) ;
final List < Segment > segments = new ArrayList < Segment > ( list . size () ) ;
return new Pair < RealMatrix , RealVector > ( normal , jTr ) ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
List < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
List < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
{ points = new ArrayList < double [] > () ; sigma = error ; }
final List < Long > linkEnd = new ArrayList < Long > () ;
List < Chromosome > chromosomes = new ArrayList < Chromosome > ( population . getChromosomes () ) ;
List < Comparable < > > modeList = new ArrayList < Comparable < > > () ;
this . features = new AtomicReference < double [] > ( features . clone () ) ;
List < Vector3D > reducedSupport = new ArrayList < Vector3D > () ;
List < Vector3D > points = new ArrayList < Vector3D > () ;
WelzlEncloser < Euclidean3D , Vector3D > encloser = new WelzlEncloser < Euclidean3D , Vector3D > ( NUMBER_CONSTANT , generator ) ;
WelzlEncloser < Euclidean3D , Vector3D > encloser = new WelzlEncloser < Euclidean3D , Vector3D > ( NUMBER_CONSTANT , generator ) ;
TreeSet < Double > values = new TreeSet < Double > () ;
final List < PairDoubleInteger > list = new ArrayList < PairDoubleInteger > ( len ) ;
return new Array2DRowFieldMatrix < BigFraction > ( pData , false ) ;
KMeansPlusPlusClusterer < DoublePoint > transformer = new KMeansPlusPlusClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final List < double [] > paramsAndChi2 = new ArrayList < double [] > ( gridSize * gridSize ) ;
{ return new ThreeEighthesFieldIntegrator < T > ( field , step ) ; }
p2 = new Pair < String , Integer > ( STRING_CONSTANT , NUMBER_CONSTANT )
List < Chromosome > popList = new LinkedList < Chromosome > () ;
final List < Neuron > neuronList = new ArrayList < Neuron > () ;
final List < Neuron > neurons = new ArrayList < Neuron > () ;
{ copy.linkMap . put ( e . getKey () , new HashSet < Long > ( e . getValue () ) ) ; }
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator < Dfp > () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator < Dfp > () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator < Dfp > () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator < Dfp > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
final List < WeightedObservedPoint > points = new ArrayList < WeightedObservedPoint > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
List < Vector2D > reducedSupport = new ArrayList < Vector2D > () ;
List < Vector2D > list = new ArrayList < Vector2D > ( coordinates.length / NUMBER_CONSTANT ) ;
List < Vector2D > points = new ArrayList < Vector2D > () ;
WelzlEncloser < Euclidean2D , Vector2D > encloser = new WelzlEncloser < Euclidean2D , Vector2D > ( NUMBER_CONSTANT , generator ) ;
WelzlEncloser < Euclidean2D , Vector2D > encloser = new WelzlEncloser < Euclidean2D , Vector2D > ( NUMBER_CONSTANT , generator ) ;
mapper = new FieldEquationsMapper < T > ( mapper , secondary . getDimension () ) ;
Map < String , String > referenceRules = new HashMap < String , String > () ;
Map < String , String > referenceRules = new HashMap < String , String > () ;
FirstOrderFieldDifferentialEquations < T > eqn = new SinCos < T > ( field ) ;
setUpInterpolator ( field , new SinCos < T > ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
setUpInterpolator ( field , new SinCos < T > ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
return new Array2DRowFieldMatrix < T > ( pData , false ) ;
{ innerDistribution = new EnumeratedDistribution < Integer > ( createDistribution ( singletons , probabilities ) ) ; }
{ return new ClassicalRungeKuttaFieldIntegrator < T > ( field , step ) ; }
{ return new FieldLUDecomposition < Fraction > ( m ) . getDeterminant () . doubleValue () ; }
solver = new FieldLUDecomposition < Fraction > ( createFractionMatrix ( singular ) ) . getSolver () ;
solver = new FieldLUDecomposition < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
List < Chromosome > popList = new ArrayList < Chromosome > () ;
NPointCrossover < Integer > npc = new NPointCrossover < Integer > ( order ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
{ return new Array2DRowFieldMatrix < T > ( getField () , rowDimension , columnDimension ) ; }
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , nCols , nRows ) ;
return new ArrayFieldVector < T > ( getField () , outData , false ) ;
return new ArrayFieldVector < T > ( getField () , outData , false ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , NUMBER_CONSTANT ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , NUMBER_CONSTANT , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , m.columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
{ return new BlockFieldMatrix < T > ( getField () , rowDimension , columnDimension ) ; }
loops = new ArrayList < Vertex > () ;
final List < Integer > factors = new ArrayList < Integer > ( NUMBER_CONSTANT ) ;
return new SparseFieldVector < Fraction > ( field , t ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
SparseFieldVector < Fraction > v1 = new SparseFieldVector < Fraction > ( field , vec1 ) ;
SparseFieldVector < Fraction > v1 = new SparseFieldVector < Fraction > ( field , vec1 ) ;
{ return new FieldODEState < T > ( t0 , y0 ) ; }
RegionFactory < Sphere1D > factory = new RegionFactory < Sphere1D > () ;
RegionFactory < Sphere2D > factory = new RegionFactory < Sphere2D > () ;
RegionFactory < Sphere2D > factory = new RegionFactory < Sphere2D > () ;
List < SubHyperplane < Sphere2D > > boundary = new ArrayList < SubHyperplane < Sphere2D > > () ;
List < SubHyperplane < Sphere2D > > boundary = new ArrayList < SubHyperplane < Sphere2D > > () ;
RegionFactory < Sphere2D > factory = new RegionFactory < Sphere2D > () ;
RegionFactory < Sphere2D > factory = new RegionFactory < Sphere2D > () ;
final ArrayList < Integer > nonZeroPositions = new ArrayList < Integer > () ;
{ this . tolerance = tolerance ; this . segments = new ArrayList < ConnectableSegment > () ; }
final List < Segment > loop = new ArrayList < Segment > () ;
loops = new ArrayList < List < Segment > > ()
this . lines = new ArrayList < Line > () ;
this . representation = Collections . unmodifiableList ( copyList ? new ArrayList < T > ( representation ) : representation ) ;
newClusters = new ArrayList < CentroidCluster < T > > ( k )
microsphereData = new ArrayList < FacetData > ( size ) ;
final Set < Neuron > list = new HashSet < Neuron > () ;
this . listeners = new CopyOnWriteArrayList < IterationListener > () ;
this . listeners = new CopyOnWriteArrayList < IterationListener > () ;
List < Integer > minRatioPositions = new ArrayList < Integer > () ;
{ innerDistribution = new EnumeratedDistribution < Double > ( createDistribution ( singletons , probabilities ) ) ; }
final List < Interval > list = new ArrayList < Interval > () ;
{ return new LutherFieldIntegrator < T > ( field , step ) ; }
final FuzzyKMeansClusterer < DoublePoint > clusterer = new FuzzyKMeansClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new SparseFieldMatrix < T > ( getField () , rowDimension , columnDimension ) ; }
{ return new SparseFieldMatrix < T > ( this ) ; }
entries = new OpenIntToFieldHashMap < T > ( getField () ) ;
entries = new OpenIntToFieldHashMap < T > ( other.entries ) ;
entries = new OpenIntToFieldHashMap < T > ( field ) ;
entries = new OpenIntToFieldHashMap < T > ( field ) ;
steps = new ArrayList < StepInterpolator > () ;
output = new ArrayList < Double > () ;
@ Before public void setUp () { evaluator = new SumOfClusterVariances < DoublePoint > ( new EuclideanDistance () ) ; }
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
Map < Integer , Fraction > generated = new HashMap < Integer , Fraction > () ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
Set < Integer > keysInMap = new HashSet < Integer > ( javaMap . keySet () ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field , NUMBER_CONSTANT ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
Map < Integer , Fraction > map = new HashMap < Integer , Fraction > () ;
final List < Field > fields = new ArrayList < Field > () ;
RegionFactory < Euclidean1D > factory = new RegionFactory < Euclidean1D > () ;
{ return new ArrayList < WeightedObservedPoint > ( observations ) ; }
final HashMap < Neuron , Integer > hit = new HashMap < Neuron , Integer > () ;
final List < PairNeuronDouble > list = new ArrayList < PairNeuronDouble > () ;
List < CentroidCluster < T > > newClusters = new ArrayList < CentroidCluster < T > > () ;
List < Object [] > list = new ArrayList < Object [] > () ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
{ return new GillFieldIntegrator < T > ( field , step ) ; }
return new FieldRotation < DerivativeStructure > ( mds , threshold ) ;
FieldRotation < DerivativeStructure > quat = new FieldRotation < DerivativeStructure > ( u1 , u2 , v1 , v2 ) ;
return new ArrayFieldVector < Fraction > ( t ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( vec1 ) ;
ArrayFieldVector < Fraction > v1 = new ArrayFieldVector < Fraction > ( vec1 ) ;
return new FieldVectorTestImpl < T > ( out ) ;
final List < Object > orig = new ArrayList < Object > () ;
this . hParam = new HashMap < String , Double > () ;
regions = new ArrayList < Region < T > > ( NUMBER_CONSTANT )
return new BoundaryProjection < S > ( original , projected , offset ) ;
binStats = new ArrayList < SummaryStatistics > () ;
{ return new MidpointFieldIntegrator < T > ( field , step ) ; }
RegionFactory < Euclidean2D > factory = new RegionFactory < Euclidean2D > () ;
{ this . surrounded = new ArrayList < NestedLoops > () ; this . tolerance = tolerance ; }
return new FieldODEStateAndDerivative < S > ( time , estimatedState , estimatedDerivatives ) ;
this . nordsieck = new Array2DRowFieldMatrix < T > ( nordsieck . getData () , false ) ;
boundary = new ArrayList < SubHyperplane < Euclidean3D > > ()
{ return new BSPTree < Euclidean3D > ( Boolean.FALSE ) ; }
SparseFieldVector < T > res = new SparseFieldVector < T > ( this ) ;
FieldMatrix < T > res = new SparseFieldMatrix < T > ( field , virtualSize , n ) ;
SparseFieldMatrix < T > res = new SparseFieldMatrix < T > ( field , virtualSize , n ) ;
SparseFieldVector < T > res = new SparseFieldVector < T > ( field , n ) ;
SparseFieldVector < T > res = new SparseFieldVector < T > ( this ) ;
SparseFieldVector < T > res = new SparseFieldVector < T > ( this ) ;
{ return new SparseFieldVector < T > ( this ) ; }
FieldVector < T > res = new SparseFieldVector < T > ( this , NUMBER_CONSTANT ) ;
FieldVector < T > res = new SparseFieldVector < T > ( this , n ) ;
entries = new OpenIntToFieldHashMap < T > ( v . getEntries () ) ;
entries = new OpenIntToFieldHashMap < T > ( field ) ;
entries = new OpenIntToFieldHashMap < T > ( field , expectedSize ) ;
entries = new OpenIntToFieldHashMap < T > ( v.entries ) ;
entries = new OpenIntToFieldHashMap < T > ( field ) ;
{ return new ClassicalRungeKuttaFieldIntegrator < T > ( field , field . getOne () ) ; }
public ListUnivariateImpl () { this ( new ArrayList < Object > () ) ; }
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
TestFieldProblem3 < T > pb = new TestFieldProblem3 < T > ( field ) ;
this . jacobianProviders = new ArrayList < ParameterJacobianProvider > () ;
{ return new LutherFieldIntegrator < T > ( field , field . getOne () ) ; }
List < Frequency > coll = new ArrayList < Frequency > () ;
{ return new ThreeEighthesFieldIntegrator < T > ( field , field . getOne () ) ; }
List < Integer > newRepr = new ArrayList < Integer > ( origChrom . getRepresentation () ) ;
final RegionFactory < Euclidean2D > factory = new RegionFactory < Euclidean2D > () ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
final SimplePointChecker < PointValuePair > checker = new SimplePointChecker < PointValuePair > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final SimplePointChecker < PointValuePair > checker = new SimplePointChecker < PointValuePair > ( NUMBER_CONSTANT , NUMBER_CONSTANT , max ) ;
final Collection < SummaryStatistics > categoryDataSummaryStatistics = new ArrayList < SummaryStatistics > ( categoryData . size () ) ;
final ArrayList < String > lines = new ArrayList < String > () ;
List < Number > components = new ArrayList < Number > () ;
{ return new EulerFieldIntegrator < T > ( field , step ) ; }
final ArrayList < Double > list = new ArrayList < Double > () ;
List < Vector3D > support = new ArrayList < Vector3D > () ;
public CircleScalar () { points = new ArrayList < Vector2D > () ; }
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < EventHandler > list = new ArrayList < EventHandler > ( eventsStates . size () ) ;
final List < WeightedObservedPoint > observations = new ArrayList < WeightedObservedPoint > ( unsorted ) ;
this . chromosomes = new ArrayList < Chromosome > ( populationLimit ) ;
BlockFieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
BlockFieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
return new ArrayFieldVector < Fraction > ( data , false ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
{ Assert . assertEquals ( new BlockFieldMatrix < Fraction > ( reference ) , sub ) ; }
{ Assert . assertEquals ( new BlockFieldMatrix < Fraction > ( reference ) , sub ) ; }
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
RegionFactory < Sphere1D > factory = new RegionFactory < Sphere1D > () ;
return new ArrayList < Edge > ( edgeToNode . keySet () ) ;
final FieldODEStateAndDerivative < T > stateTmp = new FieldODEStateAndDerivative < T > ( stepEnd , yTmp , yDotTmp ) ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList < Object > () ) ;
List < Object > list = new ArrayList < Object > () ;
List < Object > externalList = new ArrayList < Object > () ;
final FieldODEStateAndDerivative < T > state0 = new FieldODEStateAndDerivative < T > ( t0 , y0 , y0Dot ) ;
RegionFactory < Euclidean3D > factory = new RegionFactory < Euclidean3D > () ;
integrator . integrate ( new FieldExpandableODE < T > ( problem ) , problem . getInitialState () , problem . getFinalTime () ) ;
points = new ArrayList < double [] > () ;
{ return new FieldVector3D < T > ( NUMBER_CONSTANT , this , factor , v ) ; }
final List < Object > list = new ArrayList < Object > () ;
final List < Complex > result = new ArrayList < Complex > () ;
return new FieldRotation < Dfp > ( mds , threshold ) ;
FieldRotation < Dfp > quat = new FieldRotation < Dfp > ( u1 , u2 , v1 , v2 ) ;
OnePointCrossover < Integer > opc = new OnePointCrossover < Integer > () ;
BSPTree < Sphere1D > tree = new BSPTree < Sphere1D > ( Boolean.FALSE ) ;
final List < Arc > list = new ArrayList < Arc > () ;
List < Double > newRepr = new ArrayList < Double > ( repr ) ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
Map < Integer , Double > generated = new HashMap < Integer , Double > () ;
Set < Integer > keysInMap = new HashSet < Integer > ( javaMap . keySet () ) ;
Map < Integer , Double > map = new HashMap < Integer , Double > () ;
final Set < Integer > usedBasicRows = new HashSet < Integer > () ;
final Set < Integer > columnsToDrop = new TreeSet < Integer > () ;
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > ( originalConstraints . size () ) ;
final ArrayList < Object [] > parameters = new ArrayList < Object [] > () ;
{ return new Pair < K , V > ( k , v ) ; }
public Cluster () { points = new ArrayList < T > () ; }
close = new ArrayList < BSPTree < S > > ()
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
final HashSet < Double > values = new HashSet < Double > () ;
return new Array2DRowFieldMatrix < BigFraction > ( BigFractionField . getInstance () , Hdata ) ;
TestFieldProblem3 < T > pb = new TestFieldProblem3 < T > ( field ) ;
final BoundarySizeVisitor < S > visitor = new BoundarySizeVisitor < S > () ;
final BoundaryProjector < S , T > projector = new BoundaryProjector < S , T > ( point ) ;
{ tree = new BSPTree < S > ( Boolean.FALSE ) ; }
{ this . tree = new BSPTree < S > ( Boolean.TRUE ) ; this . tolerance = tolerance ; }
List < Integer > baseSequence = new ArrayList < Integer > ( l ) ;
List < S > origDataCopy = new ArrayList < S > ( originalData ) ;
List < S > sortedData = new ArrayList < S > ( data ) ;
List < Double > repr = new ArrayList < Double > ( l ) ;
List < Double > repr = new ArrayList < Double > ( l ) ;
List < Double > sortedRepr = new ArrayList < Double > ( getRepresentation () ) ;
distribution = new ArrayList < T > () ;
List < Vector2D > quadrilateral = new ArrayList < Vector2D > () ;
final List < Vector2D > reducedPoints = new ArrayList < Vector2D > ( quadrilateral ) ;
List < Integer > rList = new ArrayList < Integer > ( length ) ;
context = new HashMap < String , Object > () ;
List < Vector2D > support = new ArrayList < Vector2D > () ;
final ArrayList < Double > integrationTestPoints = new ArrayList < Double > () ;
edges = new ArrayList < SubHyperplane < Euclidean2D > > ()
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
return new FieldODEState < T > ( state . getTime () , y ) ;
ArrayList < Integer > out = new ArrayList < Integer > () ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( fData , false ) ;
FieldMatrix < BigFraction > m = new Array2DRowFieldMatrix < BigFraction > ( bfData , false ) ;
{ return new ArrayList < String > () ; }
FieldBracketingNthOrderBrentSolver < Dfp > solver = new FieldBracketingNthOrderBrentSolver < Dfp > ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ;
FieldBracketingNthOrderBrentSolver < Dfp > solver = new FieldBracketingNthOrderBrentSolver < Dfp > ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ;
{ new FieldBracketingNthOrderBrentSolver < Dfp > ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ; }
List < Vector2D > points = new ArrayList < Vector2D > ( size ) ;
List < Vector2D > points = new ArrayList < Vector2D > () ;
List < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
ArrayList < SubHyperplane < Euclidean2D > > edges = new ArrayList < SubHyperplane < Euclidean2D > > () ;
RegionFactory < Euclidean2D > factory = new RegionFactory < Euclidean2D > () ;
final List < WeightedObservedPoint > observations = new ArrayList < WeightedObservedPoint > ( unsorted ) ;
steps = new ArrayList < FieldStepInterpolator < T > > () ;
final Set < City > unique = new HashSet < City > () ;
final List < Future < > > execOutput = new ArrayList < Future < > > () ;
certifiedValues = new HashMap < String , Double > () ;
{ return new EulerFieldIntegrator < T > ( field , field . getOne () ) ; }
FieldMatrix < T > identity = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
return new Array2DRowFieldMatrix < T > ( field , bp , false ) ;
return new ArrayFieldVector < T > ( bp , false ) ;
return new ArrayFieldVector < T > ( field , bp , false ) ;
{ return new Solver < T > ( field , lu , pivot , singular ) ; }
cachedP = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
cachedU = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
cachedL = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
List < Chromosome > popChr = new ArrayList < Chromosome > () ;
Collection < Neuron > exclude = new HashSet < Neuron > () ;
Collection < Neuron > exclude = new HashSet < Neuron > () ;
final List < BigFraction > list = new ArrayList < BigFraction > () ;
this . derivatives = new HashMap < Integer , Double > () ;
this . derivatives = new HashMap < Integer , Double > () ;
tasks = new ArrayList < Callable < Double > > ()
final FieldODEStateAndDerivative < T > stateTmp = new FieldODEStateAndDerivative < T > ( stepEnd , yTmp , yDotTmp ) ;
population = new ListPopulation ( chromosomes , NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
new ListPopulation ( chromosomes , NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } } ;
new ListPopulation ( chromosomes , - NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } } ;
{ new ListPopulation ( - NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } } ; }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
public StepInterpolator copy () { return this ; }
final Chromosome p1c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
public StepInterpolator copy () { return this ; }
final Chromosome p1c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p1c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p1c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
for ( int val : this . getRepresentation () ) { if ( val != NUMBER_CONSTANT ) num ++ ; }
if ( count ++ > NUMBER_CONSTANT ) break;
if ( count ++ > NUMBER_CONSTANT ) break;
if ( counts [ i ] == - NUMBER_CONSTANT ) continue;
RandomSource . restoreState ( random , state ) ;
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( random ) . getState () ) ; }
RandomSource . restoreState ( delegate , state ) ;
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( delegate ) . getState () ) ; }
{ double n = upper - lower + NUMBER_CONSTANT ; return ( n * n - NUMBER_CONSTANT ) / NUMBER_CONSTANT ; }
{ return NUMBER_CONSTANT * ( lower + upper ) ; }
return ( x - lower + NUMBER_CONSTANT ) / ( upper - lower + NUMBER_CONSTANT ) ;
return NUMBER_CONSTANT / ( upper - lower + NUMBER_CONSTANT ) ;
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomSource.State ) delegate . saveState () ) . getState () ) ; }
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomSource.State ) random . saveState () ) . getState () ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
final double delta = ( ( Vector1D ) point ) . getX () - location . getX () ;
final Vector1D location
{ final Circle otherC = ( Circle ) other ; return Vector3D . dotProduct ( pole , otherC.pole ) >= NUMBER_CONSTANT ; }
final Vector3D direction
final Vector3D pole
Vector3D [] points
final List < Vector3D > vertices
Arrays . asList ( Vector3D.ZERO , Vector3D.PLUS_I , Vector3D.PLUS_J , Vector3D.PLUS_K )
try { ps . checkPoint ( Vector3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
final Vector2D tmp = loop [ min ] ;
final Vector2D [] bLoop
final Vector3D axis
Vector3D axis
Vector2D oneTwo = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ new Vector2D ( v ) ; }
{ final Vector1D p1 = ( Vector1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
Vector2D expected = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = Vector2D.NEGATIVE_INFINITY ;
Vector2D c = Vector2D.POSITIVE_INFINITY ;
Vector2D c = Vector2D.NaN ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new Line ( new Vector2D ( getNumber () , getNumber () ) , getNumber () , getNumber () ) ; }
{ return new OrientedPoint ( new Vector1D ( getNumber () ) , getBoolean () , getNumber () ) ; }
{ return new Circle ( new Vector3D ( getNumber () , getNumber () , getNumber () ) , getNumber () ) ; }
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v1
final Vector3D v2
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D u
Vector1D v
Vector1D v = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D v = new Vector1D ( NUMBER_CONSTANT ) ;
{ Space space = new Vector1D ( NUMBER_CONSTANT ) . getSpace () ; Assert . assertEquals ( NUMBER_CONSTANT , space . getDimension () ) ; }
final Vector3D p = h . toSpace ( Vector2D.ZERO ) ;
final Vector2D p = h . toSpace ( Vector1D.ZERO ) ;
final Vector2D p2 = ( Vector2D ) vector ;
Vector3D c = Vector3D.NEGATIVE_INFINITY ;
Vector3D c = Vector3D.POSITIVE_INFINITY ;
Vector3D c = Vector3D.NaN ;
Vector1D expected = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = Vector1D.NEGATIVE_INFINITY ;
Vector1D c = Vector1D.POSITIVE_INFINITY ;
Vector1D c = Vector1D.NaN ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( - NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
final double angle = Vector3D . angle ( thisCircle . getPole () , otherCircle . getPole () ) ;
{ return Vector3D . angle ( p1.vector , p2.vector ) ; }
final Vector3D vector
{ return ( ( Vector3D ) point ) . dotProduct ( w ) + originOffset ; }
final Vector3D p
final Vector3D translation
final double angle = Vector3D . angle ( w , plane.w ) ;
final Vector3D tmp = u ;
final Vector3D normal
Vector3D v
{ new Vector3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Vector1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
final Vector2D p
final Vector2D p
final Vector2D p
Vector2D p2 = ( Vector2D ) point ;
final Vector2D p
final Vector2D p
TranslationTransform ( final Vector3D translation ) { this . translation = translation ; }
final Vector3D translation
final Vector3D center
final Vector3D center
final Vector3D point
{ setSize ( NUMBER_CONSTANT ) ; setBarycenter ( ( Point < Euclidean3D > ) new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final List < Vector3D > vertices
final List < Vector3D > vertices
Circle circle = new Circle ( Vector3D.PLUS_K , NUMBER_CONSTANT ) ;
final Vector3D u
final Vector3D u
final Vector2D [] vertices
Collection < Vector2D > points
this . summedBarycenter = Vector3D.ZERO ;
{ return Vector2D . angle ( p1.vector , p2.vector ) ; }
final Vector2D vector
try { FieldVector3D . angle ( v1 , Vector3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
for ( Vector2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Vector2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
{ return new SphericalCoordinates ( new Vector3D ( x , y , z ) ) ; }
final Vector3D v
final Vector2D point
final Vector2D location
final Vector2D . . . vertices
final Vector2D . . . vertices
final Vector3D pole
final Vector3D p
final double angle = Vector3D . angle ( direction , line.direction ) ;
final Vector3D point
final Collection < Vector2D > points
final Collection < Vector2D > points
final Collection < Vector2D > points
ConvexHull2D hull = generator . generate ( Collections . < Vector2D > emptyList () ) ;
final double x = ( ( Vector1D ) point ) . getX () ;
final Coordinates2D tmp = loop [ min ] ;
final Coordinates2D [] bLoop
final Coordinates2D p2 = ( Coordinates2D ) vector ;
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Coordinates1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
Coordinates3D [] points
final List < Coordinates3D > vertices
Arrays . asList ( Coordinates3D.ZERO , Coordinates3D.PLUS_I , Coordinates3D.PLUS_J , Coordinates3D.PLUS_K )
try { ps . checkPoint ( Coordinates3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
final Coordinates3D p = h . toSpace ( Coordinates2D.ZERO ) ;
final Coordinates2D p = h . toSpace ( Coordinates1D.ZERO ) ;
Coordinates2D expected = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = Coordinates2D.NEGATIVE_INFINITY ;
Coordinates2D c = Coordinates2D.POSITIVE_INFINITY ;
Coordinates2D c = Coordinates2D.NaN ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final double x = ( ( Coordinates1D ) point ) . getX () ;
Coordinates3D v
{ new Coordinates3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Coordinates3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
{ return new Line ( new Coordinates2D ( getNumber () , getNumber () ) , getNumber () , getNumber () ) ; }
{ return new OrientedPoint ( new Coordinates1D ( getNumber () ) , getBoolean () , getNumber () ) ; }
{ return new Circle ( new Coordinates3D ( getNumber () , getNumber () , getNumber () ) , getNumber () ) ; }
Circle circle = new Circle ( Coordinates3D.PLUS_K , NUMBER_CONSTANT ) ;
{ return new SphericalCoordinates ( new Coordinates3D ( x , y , z ) ) ; }
final Coordinates3D v
this . summedBarycenter = Coordinates3D.ZERO ;
{ final Coordinates1D p1 = ( Coordinates1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
{ return Coordinates2D . angle ( p1.vector , p2.vector ) ; }
final Coordinates2D vector
final Coordinates3D p
final double angle = Coordinates3D . angle ( direction , line.direction ) ;
final Coordinates3D point
Coordinates3D c = Coordinates3D.NEGATIVE_INFINITY ;
Coordinates3D c = Coordinates3D.POSITIVE_INFINITY ;
Coordinates3D c = Coordinates3D.NaN ;
Coordinates1D expected = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = Coordinates1D.NEGATIVE_INFINITY ;
Coordinates1D c = Coordinates1D.POSITIVE_INFINITY ;
Coordinates1D c = Coordinates1D.NaN ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( - NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
final Coordinates3D axis
Coordinates3D axis
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D u
final double angle = Coordinates3D . angle ( thisCircle . getPole () , otherCircle . getPole () ) ;
for ( Coordinates2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Coordinates2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
{ return ( ( Coordinates3D ) point ) . dotProduct ( w ) + originOffset ; }
final Coordinates3D p
final Coordinates3D translation
final double angle = Coordinates3D . angle ( w , plane.w ) ;
final Coordinates3D tmp = u ;
final Coordinates3D normal
try { FieldVector3D . angle ( v1 , Coordinates3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
{ final Circle otherC = ( Circle ) other ; return Coordinates3D . dotProduct ( pole , otherC.pole ) >= NUMBER_CONSTANT ; }
final Coordinates3D direction
final Coordinates3D pole
{ return Coordinates3D . angle ( p1.vector , p2.vector ) ; }
final Coordinates3D vector
Collection < Coordinates2D > points
final Collection < Coordinates2D > points
final Collection < Coordinates2D > points
final Collection < Coordinates2D > points
ConvexHull2D hull = generator . generate ( Collections . < Coordinates2D > emptyList () ) ;
final double delta = ( ( Coordinates1D ) point ) . getX () - location . getX () ;
final Coordinates1D location
final Coordinates3D u
final Coordinates3D u
final Coordinates3D pole
final Coordinates2D point
final Coordinates2D location
final Coordinates2D . . . vertices
final Coordinates2D . . . vertices
Coordinates2D oneTwo = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ new Coordinates2D ( v ) ; }
final Coordinates2D [] vertices
TranslationTransform ( final Coordinates3D translation ) { this . translation = translation ; }
final Coordinates3D translation
final Coordinates3D center
final Coordinates3D center
final Coordinates3D point
{ setSize ( NUMBER_CONSTANT ) ; setBarycenter ( ( Point < Euclidean3D > ) new Coordinates3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final List < Coordinates3D > vertices
final List < Coordinates3D > vertices
Coordinates1D v
Coordinates1D v = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D v = new Coordinates1D ( NUMBER_CONSTANT ) ;
{ Space space = new Coordinates1D ( NUMBER_CONSTANT ) . getSpace () ; Assert . assertEquals ( NUMBER_CONSTANT , space . getDimension () ) ; }
final Coordinates2D p
final Coordinates2D p
final Coordinates2D p
final Coordinates2D p
final Coordinates2D p
{ centered [ i ] = values [ i ] - getMeans () [ i ] ; }
private final ContinuousSampler sampler = new BoxMullerLogNormalSampler ( rng , scale , shape ) ;
private final ContinuousSampler sampler = new BoxMullerGaussianSampler ( rng , mean , standardDeviation ) ;
public Plot ( final List < Vector2D > points ) { this . points = points ; }
List < Vector2D > points = null ;
Vector3D p
rings = new ChineseRings ( new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
Cartesian1D actual = vector1DFormat . parse ( source ) ;
Cartesian1D actual = vector1DFormat . parse ( source ) ;
Cartesian1D actual = vector1DFormat . parse ( source ) ;
Cartesian1D expected = new Cartesian1D ( NUMBER_CONSTANT ) ;
{ final Cartesian1D p1 = ( Cartesian1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
final Cartesian2D p2 = ( Cartesian2D ) vector ;
Cartesian2D actual = vector2DFormat . parse ( source ) ;
Cartesian2D actual = vector2DFormat . parse ( source ) ;
Cartesian2D actual = vector2DFormat . parse ( source ) ;
Cartesian3D actual = vector3DFormat . parse ( source ) ;
Cartesian3D actual = vector3DFormat . parse ( source ) ;
Cartesian3D actual = vector3DFormat . parse ( source ) ;
int j = NUMBER_CONSTANT
Assert . assertFalse ( STRING_CONSTANT + level , new KolmogorovSmirnovTest ( RandomSource.JDK , NUMBER_CONSTANT ) . kolmogorovSmirnovTest ( betaDistribution , observed ) < level ) ;
Assert . assertEquals ( test . exactP ( d , sampleSize1 , sampleSize2 , strict ) , test . monteCarloP ( d , sampleSize1 , sampleSize2 , strict , KolmogorovSmirnovTest.MONTE_CARLO_ITERATIONS , rng ) , tol )
final double tol = KolmogorovSmirnovTestTest.TOLERANCE ;
final double tol = KolmogorovSmirnovTestTest.TOLERANCE ;
Vector3D p
rings = new ChineseRings ( new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
try { FieldVector3D . angle ( v1 , Vector3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
final Vector2D point
final Vector2D location
final Vector2D . . . vertices
final Vector2D . . . vertices
final Vector3D p
final double angle = Vector3D . angle ( direction , line.direction ) ;
final Vector3D point
Vector3D v
{ new Vector3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
final Collection < Vector2D > points
final Collection < Vector2D > points
final Collection < Vector2D > points
ConvexHull2D hull = generator . generate ( Collections . < Vector2D > emptyList () ) ;
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Vector1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
final double x = ( ( Vector1D ) point ) . getX () ;
for ( Vector2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Vector2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v1
final Vector3D v2
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D u
final Vector2D [] vertices
if ( x <= NUMBER_CONSTANT ) { ret = NUMBER_CONSTANT ; } else { ret = Gamma . regularizedGammaP ( shape , x / scale ) ; }
Gamma . logGamma ( z + NUMBER_CONSTANT ) - ( z + NUMBER_CONSTANT ) * FastMath . log ( z ) + z - HALF_LOG_2_PI
final double expected = Gamma . logGamma ( i + NUMBER_CONSTANT ) ;
{ return Gamma . regularizedGammaP ( mu , mu * x * x / omega ) ; }
NUMBER_CONSTANT * FastMath . pow ( mu , mu ) / ( Gamma . gamma ( mu ) * FastMath . pow ( omega , mu ) )
Assert . assertEquals ( NUMBER_CONSTANT , Gamma . gamma ( t ) / s , tol ) ;
( sc * sc ) * FastMath . exp ( Gamma . logGamma ( NUMBER_CONSTANT + ( NUMBER_CONSTANT / sh ) ) )
return sc * FastMath . exp ( Gamma . logGamma ( NUMBER_CONSTANT + ( NUMBER_CONSTANT / sh ) ) ) ;
return Gamma . logGamma ( n + NUMBER_CONSTANT ) ;
{ ret = Beta . regularizedBeta ( probabilityOfSuccess , numberOfSuccesses , x + NUMBER_CONSTANT ) ; }
Beta . logBeta ( nhalf , mhalf )
{ ret = NUMBER_CONSTANT - Beta . regularizedBeta ( probabilityOfSuccess , x + NUMBER_CONSTANT , numberOfTrials - x ) ; }
if ( x >= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return Beta . regularizedBeta ( x , alpha , beta ) ; }
return NUMBER_CONSTANT * Erf . erf ( v0 , v1 ) ;
return NUMBER_CONSTANT + NUMBER_CONSTANT * Erf . erf ( dev / ( shape * SQRT2 ) ) ;
final double t = Erf . erfcInv ( p ) ;
return NUMBER_CONSTANT * Erf . erf ( v0 , v1 ) ;
return mean + standardDeviation * SQRT2 * Erf . erfInv ( NUMBER_CONSTANT * p - NUMBER_CONSTANT ) ;
return NUMBER_CONSTANT * Erf . erfc ( - dev / ( standardDeviation * SQRT2 ) ) ;
{ term *= FastMath . pow ( delta [ k ] , orders [ k ] ) / CombinatoricsUtils . factorial ( orders [ k ] ) ; }
double refDer = - CombinatoricsUtils . factorial ( n - NUMBER_CONSTANT ) / FastMath . pow ( - x , n ) ;
ArithmeticUtils . pow ( - NUMBER_CONSTANT , i ) * CombinatoricsUtils . factorial ( i ) / FastMath . pow ( x , i + NUMBER_CONSTANT )
CombinatoricsUtils . binomialCoefficientDouble ( n + m , m )
double binomial = CombinatoricsUtils . binomialCoefficient ( v + i , i ) ;
final int numCombinations = ( int ) CombinatoricsUtils . binomialCoefficient ( arraySize , numberOfTrueValues ) ;
long expected = CombinatoricsUtils . binomialCoefficient ( i + j , i ) ;
{ coeff [ i ] [ j ] = ( int ) CombinatoricsUtils . binomialCoefficient ( i , j ) ; }
Assert . assertEquals ( CombinatoricsUtils . binomialCoefficient ( n , NUMBER_CONSTANT ) , CombinatoricsUtils . stirlingS2 ( n , n - NUMBER_CONSTANT ) ) ;
return MathArrays . linearCombination ( x1 , y1 , - x2 , y2 ) ;
{ final Cartesian2D v2 = ( Cartesian2D ) v ; return MathArrays . linearCombination ( x , v2.x , y , v2.y ) ; }
final double n = FastMath . abs ( MathArrays . linearCombination ( v1.x , v2.y , - v1.y , v2.x ) ) ;
out.value = MathArrays . linearCombination ( a1 , b1.value , a2 , b2.value , a3 , b3.value ) ;
out.value = MathArrays . linearCombination ( a1.value , b1.value , a2.value , b2.value , a3.value , b3.value ) ;
out.value = MathArrays . linearCombination ( a1 , b1.value , a2 , b2.value ) ;
out.value = MathArrays . linearCombination ( a1.value , b1.value , a2.value , b2.value ) ;
out.value = MathArrays . linearCombination ( a , bDouble ) ;
out.value = MathArrays . linearCombination ( aDouble , bDouble ) ;
{ return FastMath . abs ( MathArrays . linearCombination ( sin , line.cos , - cos , line.sin ) ) < tolerance ; }
return MathArrays . linearCombination ( sin , otherL.sin , cos , otherL.cos ) >= NUMBER_CONSTANT ;
{ return originOffset + ( MathArrays . linearCombination ( cos , line.cos , sin , line.sin ) > NUMBER_CONSTANT ? - line.originOffset : line.originOffset ) ; }
final double accurateValue = MathArrays . linearCombination ( a , bDouble ) ;
final double accurateValue = MathArrays . linearCombination ( aDouble , bDouble ) ;
{ return new Decimal64 ( MathArrays . linearCombination ( a1 , b1.value , a2 , b2.value , a3 , b3.value ) ) ; }
{ return new Decimal64 ( MathArrays . linearCombination ( a1.value , b1.value , a2.value , b2.value , a3.value , b3.value ) ) ; }
{ return new Decimal64 ( MathArrays . linearCombination ( a1 , b1.value , a2 , b2.value ) ) ; }
{ return new Decimal64 ( MathArrays . linearCombination ( a1.value , b1.value , a2.value , b2.value ) ) ; }
return new Decimal64 ( MathArrays . linearCombination ( a , bDouble ) ) ;
return new Decimal64 ( MathArrays . linearCombination ( aDouble , bDouble ) ) ;
final double r = MathArrays . linearCombination ( coeff [ i ] , pY ) ;
packed [ i + NUMBER_CONSTANT ] = MathArrays . linearCombination ( dv , partials ) ;
final double cos = MathArrays . cosAngle ( n , sampleDirection ) ;
final double diffNorm = MathArrays . safeNorm ( diff ) ;
checkRelative ( MathArrays . linearCombination ( aD , bD ) , bF [ NUMBER_CONSTANT ] . linearCombination ( aD , bF ) ) ;
checkRelative ( MathArrays . linearCombination ( aD , bD ) , aF [ NUMBER_CONSTANT ] . linearCombination ( aF , bF ) ) ;
{ this ( MathUtils . normalizeAngle ( alpha , FastMath.PI ) , new Cartesian2D ( FastMath . cos ( alpha ) , FastMath . sin ( alpha ) ) ) ; }
{ Assert . assertEquals ( a1 . getReal () , MathUtils . normalizeAngle ( a2 , a1 . getReal () ) , NUMBER_CONSTANT ) ; }
final double arcRelativeStart = MathUtils . normalizeAngle ( arc . getInf () , edgeStart + FastMath.PI ) - edgeStart ;
Assert . assertEquals ( p , MathUtils . normalizeAngle ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , MathUtils . normalizeAngle ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , MathUtils . normalizeAngle ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , MathUtils . normalizeAngle ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
final double lB = MathUtils . normalizeAngle ( limits . get ( j ) , lA ) ;
final double syncedStart = MathUtils . normalizeAngle ( a [ NUMBER_CONSTANT ] , reference ) - arc . getInf () ;
final double normalizedLower = MathUtils . normalizeAngle ( lower , FastMath.PI ) ;
{ Assert . assertEquals ( a1 . getReal () , MathUtils . normalizeAngle ( a2 , a1 . getReal () ) , NUMBER_CONSTANT ) ; }
this . angle = MathUtils . normalizeAngle ( angle , FastMath.PI ) ;
this . angle = MathUtils . normalizeAngle ( alpha , FastMath.PI ) ;
angle = MathUtils . normalizeAngle ( line.angle , FastMath.PI ) ;
final double normalizedPoint = MathUtils . normalizeAngle ( point , middle ) ;
this . lower = MathUtils . normalizeAngle ( lower , FastMath.PI ) ;
if ( knots.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION , NUMBER_CONSTANT , knots.length , false ) ; }
if ( knots.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION , NUMBER_CONSTANT , knots.length , false ) ; }
UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
UnitSphereRandomVectorGenerator rand
this ( new InterpolatingMicrosphere ( dimension , elements , maxDarkFraction , darkThreshold , background , new UnitSphereRandomVectorGenerator ( dimension ) ) , exponent , sharedSphere , noInterpolationTolerance ) ;
UnitSphereRandomVectorGenerator sphRandom = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
{ sampler = new NormalDistribution () . createSampler ( generator ) ; }
private final ContinuousSampler sampler = new MarsagliaLogNormalSampler ( rng , scale , shape ) ;
final RealDistribution.Sampler random
{ return randomize ( new UniformRealDistribution ( min , max ) . createSampler ( rng ) , function ( new Constant ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
IntegerDistribution.Sampler sampler
final RealDistribution expectedDistribution
final NormalDistribution normalDistribution = new NormalDistribution () ;
final NormalDistribution normalDistribution = new NormalDistribution () ;
final NormalDistribution normalDistribution = new NormalDistribution () ;
RealDistribution distribution
RealDistribution distribution
RealDistribution distribution
RealDistribution distribution
RealDistribution.Sampler sampler
this . random = new NormalDistribution () . createSampler ( rng ) ;
final RealDistribution kernel = findKernel ( lower , upper ) ;
final RealDistribution kernel = findKernel ( lower , upper ) ;
x = new UniformRealDistribution ( lo , hi ) . createSampler ( rng ) ;
tP = new UniformRealDistribution ( NUMBER_CONSTANT , MathUtils.TWO_PI ) . createSampler ( rng ) ;
@ Override public double getNumericalMean () { return NUMBER_CONSTANT ; }
final double offset = plane . getOffset ( ( Point < Euclidean3D > ) point ) ;
{ Assert . assertEquals ( x , v . getX () , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( false , pt . isDirect () ) ;
Assert . assertEquals ( true , copy . isDirect () ) ;
Assert . assertEquals ( true , pt . isDirect () ) ;
TestUtils . assertContains ( result , expected , tolerance ) ;
assertContains ( result , expected , tolerance ) ;
y [ i ] = new Complex ( yr , yi ) ;
data [ i ] = new Complex ( re , im ) ;
for ( Complex cc : c ) { TestUtils . assertEquals ( new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , cc , NUMBER_CONSTANT ) ; }
Object expected = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = new Complex ( Double.NEGATIVE_INFINITY , Double.NEGATIVE_INFINITY ) ;
Complex expected = new Complex ( Double.POSITIVE_INFINITY , Double.POSITIVE_INFINITY ) ;
Complex expected = new Complex ( Double.NaN , Double.NaN ) ;
Complex expected = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( Double.NEGATIVE_INFINITY , Double.NEGATIVE_INFINITY ) ;
Complex c = new Complex ( Double.POSITIVE_INFINITY , Double.POSITIVE_INFINITY ) ;
Complex c = new Complex ( Double.NaN , Double.NaN ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
for ( float d : imaginary ) { c [ index ] = new Complex ( NUMBER_CONSTANT , d ) ; index ++ ; }
for ( double d : imaginary ) { c [ index ] = new Complex ( NUMBER_CONSTANT , d ) ; index ++ ; }
for ( float d : real ) { c [ index ] = new Complex ( d ) ; index ++ ; }
for ( double d : real ) { c [ index ] = new Complex ( d ) ; index ++ ; }
{ return new Complex ( NUMBER_CONSTANT , imaginary [ index ] ) ; }
{ return new Complex ( NUMBER_CONSTANT , imaginary [ index ] ) ; }
{ return new Complex ( real [ index ] ) ; }
{ return new Complex ( real [ index ] ) ; }
for ( float d : real ) { c [ index ] = Complex . ofCartesian ( d ) ; index ++ ; }
for ( double d : real ) { c [ index ] = Complex . ofCartesian ( d ) ; index ++ ; }
{ return Complex . ofCartesian ( real [ index ] ) ; }
{ return Complex . ofCartesian ( real [ index ] ) ; }
x [ i ] = Complex . ofCartesian ( f . value ( t ) ) ;
{ final int value = count ; increment () ; return value ; }
{ new SimpsonIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
public RealMatrix copy () { return null ; }
