NumberOfInvocationsVerifierTest . class
stub ( mock . simpleMethod () ) . andThrow ( new RuntimeException () ) ;
state . verifyingStarted ( OngoingVerifyingMode . atLeastOnce () ) ;
OngoingVerifyingMode mode
{ return verify ( mock , OngoingVerifyingMode . times ( wantedNumberOfInvocations ) ) ; }
{ stub ( mock . simpleMethod () ) . andThrow ( null ) ; }
{ stub ( mock . simpleMethod () ) . andThrow ( new Exception () ) ; }
OngoingVerifyingModeTest . class
stub ( mock . size () ) . andThrow ( new RuntimeException () ) ;
stub ( mock . size () ) . andThrow ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( error ) ;
stub ( reader . read () ) . andThrow ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( expected ) ;
assertNull ( Mockito.mockitoState . pullStubable () ) ;
< T > T verify ( T mock , OngoingVerifyingMode ongoingVerifyingMode ) ;
assertNull ( Mockito.mockingProgress . pullStubable () ) ;
MockingProgressImpl state = new MockingProgressImpl () ;
MockingProgressImplTest . class
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable ) ) ; }
public void addReturnValue ( Object value ) { mockingProgress . stubbingCompleted () ; addResult ( Result . createReturnResult ( value ) ) ; }
state = new MockingProgressImpl () ;
{ MockControl < T > control = MockUtil . getControl ( mock ) ; mockingProgress . stubbingStarted () ; return control ; }
mockingProgress . validateState () ;
mockingProgress . validateState () ;
{ MockUtil . validateMock ( mock ) ; mockingProgress . verifyingStarted ( mode ) ; return mock ; }
MockControl < T > mockControl = new MockControl < T > ( mockingProgress , new MatchersBinder () ) ;
verifyingRecorder . recordInvocation ( invocationMatcher . getInvocation () ) ;
verifyingRecorder = new VerifyingRecorder < T > () ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT ) ) ;
{ setStackTrace ( STRING_CONSTANT ) ; setCauseStackTrace ( STRING_CONSTANT ) ; remove () ; assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder () ) ; }
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
void verify ( InvocationsCalculator calculator , InvocationMatcher wanted , OngoingVerifyingMode mode ) ;
@ Test ( expected = TooLittleActualInvocationsError . class )
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . oneArg ( true ) ; fail () ; } catch ( TooLittleActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooLittleActualInvocationsError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooLittleActualInvocationsError e ) {}
@ Test ( expected = TooLittleActualInvocationsError . class )
@ Test ( expected = TooManyActualInvocationsError . class )
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk ( null ) ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk ( null ) ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk ( null ) ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk ( null ) ;
verifyingRecorder = createRecorder () ;
InvocationsCalculator calculator = new InvocationsCalculator ( invocations ) ;
Invocation differentMethod = new InvocationBuilder () . differentMethod () . toInvocation () ;
Invocation differentMethod = new InvocationBuilder () . differentMethod () . toInvocation () ;
simpleMethod = new InvocationBuilder () . simpleMethod () . toInvocation () ;
VerificationModeTest . class
< T > T verify ( T mock , VerificationMode verificationMode ) ;
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( VerificationMode . times ( NUMBER_CONSTANT ) ) ) ;
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( VerificationMode . times ( NUMBER_CONSTANT ) ) ) ;
VerificationMode mode
VerificationMode mode
VerificationMode mode
VerificationMode mode
VerificationMode mode = VerificationMode . atLeastOnce () ;
VerificationMode mode = VerificationMode . atLeastOnce () ;
VerificationMode mode
VerificationMode mode
public void reset () { stubbingInProgress = false ; verificationMode = null ; invocationSequenceNumber = NUMBER_CONSTANT ; }
void verify ( InvocationsCalculator calculator , InvocationMatcher wanted , VerificationMode mode ) ;
VerificationMode mode
{ return verify ( mock , VerificationMode . times ( wantedNumberOfInvocations ) ) ; }
VerificationMode mode
{ calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ; }
{ calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ; }
HasStackTrace firstUndesired = calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ;
{ if ( mode . isStrict () ) { return chunker . getFirstUnverifiedInvocationChunk ( mode . getAllMocksToBeVerifiedInSequence () ) ; } else { return registeredInvocations ; } }
public boolean isStrict () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
if ( i . isVerifiedStrictly () ) { continue; }
for ( Object mock : mocks ) { MockUtil . validateMock ( mock ) ; strictOrderVerifier . addMockToBeVerifiedStrictly ( mock ) ; }
List < Verifier > verifiers = Arrays . asList ( new MissingInvocationVerifier () , new NumberOfInvocationsVerifier ( new Reporter () ) ) ;
if ( unverified != null ) { reporter . zeroInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
if ( unverified != null ) { reporter . noMoreInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
if ( ! mocksToBeVerifiedSrictly . contains ( mock ) ) { reporter . strictlyRequiresFamiliarMock () ; }
if ( mocks.length == NUMBER_CONSTANT ) { reporter . mocksHaveToBePassedWhenCreatingStrictly () ; }
if ( stubable == null ) { reporter . missingMethodInvocation () ; }
for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( wanted ) ) { return s . answer () ; } }
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( times ( NUMBER_CONSTANT ) ) ) ;
IAnswer result
assertThat ( chunk , collectionHasExactlyInOrder ( invocationOneChunkOne , invocationTwoChunkOne ) ) ;
VerificationMode mode = new VerificationModeBuilder () . strict () ;
strictly . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
{ strictly . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; }
{ strictly . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
{ strictly . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
strictly . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
strictly . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
{ strictly . verify ( two , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
strictly . verify ( two , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
strictly . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . varargsObject ( NUMBER_CONSTANT , textOne , textOne ) ;
strictly . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod ( textOne ) ;
verify ( mockOne , times ( NUMBER_CONSTANT ) ) . varargsObject ( NUMBER_CONSTANT , textOne , textOne ) ;
verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod ( textOne ) ;
Mockito . verify ( mock , times ( NUMBER_CONSTANT ) ) . add ( STRING_CONSTANT ) ;
{ Mockito . verify ( mock , times ( NUMBER_CONSTANT ) ) . clear () ; fail () ; }
verify ( list , times ( NUMBER_CONSTANT ) ) . add ( STRING_CONSTANT ) ;
verify ( mock , times ( NUMBER_CONSTANT ) ) . add ( STRING_CONSTANT ) ;
verify ( map , times ( NUMBER_CONSTANT ) ) . put ( anyObject () , anyObject () ) ;
verify ( mock , times ( NUMBER_CONSTANT ) ) . oneArg ( two ) ;
{ return new VerificationMode ( wantedNumberOfInvocations , mocksToBeVerifiedStrictly , Verification.EXPLICIT ) ; }
assertNotNull ( STRING_CONSTANT , verifierStub.calculator ) ;
assertNotNull ( STRING_CONSTANT , verifierStub.invocations ) ;
assertThat ( verifierStub.invocations , collectionHasExactlyInOrder ( differentMethod . getInvocation () ) ) ;
assertThat ( verifierStub.invocations , collectionHasExactlyInOrder ( simpleMethod ) ) ;
verifier . verify ( asList ( wanted . getInvocation () ) , wanted , mode ) ;
verifier . verify ( asList ( wanted . getInvocation () ) , wanted , mode ) ;
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationMode mode ) ;
verifiers = Arrays . asList ( new MissingInvocationVerifier () , new NumberOfInvocationsVerifier () , new NoMoreInvocationsVerifier () )
{ this . invocations = invocations ; return invocationToReturn ; }
{ calculator.invocationToReturn = null ; verifier . verify ( null , null , VerificationMode . noMoreInteractions () ) ; }
{ times ( - NUMBER_CONSTANT ) ; fail () ; }
if ( ! mode . exactNumberOfInvocationsMode () ) { return; }
if ( mode . strictMode () ) { markVerifiedStrictly ( invocations ) ; } else { markVerified ( wanted , invocations ) ; }
{ if ( mode . strictMode () ) { return chunker . getFirstUnverifiedInvocationChunk ( mode . getAllMocksToBeVerifiedInSequence () ) ; } else { return registeredInvocations ; } }
if ( mode . explicitMode () ) { marker . markInvocationsAsVerified ( invocations , wanted , mode ) ; }
if ( mode . explicitMode () ) { return; }
public boolean exactNumberOfInvocationsMode () { return ! atLeastOnceMode () && explicitMode () ; }
public boolean missingMethodMode () { return explicitMode () && ( atLeastOnceMode () || wantedInvocationCount == NUMBER_CONSTANT ) ; }
public boolean explicitMode () { return verification == Verification.EXPLICIT ; }
public boolean strictMode () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
public boolean atLeastOnceMode () { return wantedInvocationCount == null && verification == Verification.EXPLICIT ; }
assertNull ( Mockito.MOCKING_PROGRESS . pullStubable () ) ;
if ( mocks.length == NUMBER_CONSTANT ) { REPORTER . mocksHaveToBePassedWhenCreatingStrictly () ; }
{ MockControl < T > control = MockUtil . getControl ( mock ) ; MOCKING_PROGRESS . stubbingStarted () ; return control ; }
{ MockUtil . validateMock ( mock ) ; MOCKING_PROGRESS . verificationStarted ( mode ) ; return mock ; }
MockControl < T > mockControl = new MockControl < T > ( MOCKING_PROGRESS , new MatchersBinder () ) ;
void say ( String message ) ;
void say ( Object message ) ;
boolean withBooleanVarargs ( int value , boolean . . . b ) ;
String throwsError ( int count ) ;
String throwsIOException ( int count ) throws IOException ;
String throwsNothing ( boolean value ) ;
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
MockHandlerTest . class
@ Test ( expected = MockitoException . class ) public void shouldScreamWhenNullPassed () { getMockHandler ( null ) ; }
@ Test ( expected = NotAMockException . class ) public void shouldScreamWhenNotAMockPassed () { getMockHandler ( STRING_CONSTANT ) ; }
try { getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List < Invocation > invocationsOfSingleMock = MockUtil . getMockHandler ( mock ) . getRegisteredInvocations () ; allInvocations . addAll ( invocationsOfSingleMock ) ; }
for ( Object mock : mocks ) { MockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions () ; }
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
{ mock . clear () ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {} }
{ mock . clear () ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {} }
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
NoInteractionsWantedError e
NoInteractionsWantedError e
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
{ UndesiredInvocation cause = buildUndesiredInvocationCause ( actualInvocationStackTrace , STRING_CONSTANT , undesired ) ; throw new NoInteractionsWantedError ( join ( STRING_CONSTANT ) , cause ) ; }
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
Invocation actual = analyzer . findActualInvocation ( invocations , wanted ) ;
int actualCount = analyzer . countActual ( invocations , wanted ) ;
public MissingInvocationVerifier () { this ( new InvocationsAnalyzer () , new Reporter () ) ; }
Invocation unverified = analyzer . getFirstUnverified ( invocations ) ;
public NoMoreInvocationsVerifier () { this ( new InvocationsAnalyzer () , new Reporter () ) ; }
{ verifier . verify ( invocations , wanted , times ( NUMBER_CONSTANT ) ) ; assertSame ( wanted , analyzerStub.wanted ) ; }
@ Test public void shouldPassBecauseActualInvocationFound () { analyzerStub.actualCountToReturn = NUMBER_CONSTANT ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
{ analyzer.invocationToReturn = null ; verifier . verify ( null , null , VerificationMode . noMoreInteractions () ) ; }
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsAnalyzer () ) ; }
return actualbyName != null ? actualbyName : findFirstUnverified ( invocations ) ;
Invocation unverified = analyzer . findFirstUnverified ( invocations ) ;
{ verify ( sub ) . say ( contains ( STRING_CONSTANT ) ) ; fail () ; }
mockingProgress . reportStubbable ( this ) ;
OngoingStubbing pullStubbable ( ) ;
void reportStubbable ( OngoingStubbing ongoingStubbing ) ;
VerificationModeImplTest . class
VerificationModeImpl mode
state . verificationStarted ( VerificationModeImpl . atLeastOnce () ) ;
VerificationModeImpl verificationMode = mockingProgress . pullVerificationMode () ;
VerificationModeImpl mode
VerificationModeImpl mode = new VerificationModeBuilder () . strict () ;
VerificationModeImpl mode = new VerificationModeBuilder () . strict () ;
VerificationModeImpl mode
public void verify ( VerificationModeImpl mode ) { verify ( null , mode ) ; }
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationModeImpl mode ) ;
verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ;
verifier . verify ( invocations , null , VerificationModeImpl . noMoreInteractions () ) ;
{ return VerificationModeImpl . times ( wantedNumberOfInvocations ) ; }
{ return VerificationModeImpl . atLeastOnce () ; }
VerificationModeImpl mode = VerificationModeImpl . times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode
{ analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ; }
{ analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ; }
HasStackTrace firstUndesired = analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ;
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode
VerificationModeImpl mode
{ VerificationModeImpl mode = VerificationModeImpl . noMoreInteractions () ; recorder . verify ( mode ) ; assertNull ( markerStub.mode ) ; }
VerificationModeImpl mode = new VerificationModeBuilder () . strict () ;
VerificationModeImpl mode = VerificationModeImpl . atLeastOnce () ;
VerificationModeImpl mode = VerificationModeImpl . atLeastOnce () ;
VerificationModeImpl mode
public MissingInvocationVerifier () { this ( new InvocationsAnalyzer () , new ActualInvocationsFinder () , new Reporter () ) ; }
{ setStackTrace ( STRING_CONSTANT ) ; setCauseStackTrace ( STRING_CONSTANT ) ; remove () ; assertTrue ( methodsOnTraceAfterRemoving . isEmpty () ) ; }
three . simpleMethod ( NUMBER_CONSTANT ) ;
public VerificationModeImpl strict () { return VerificationModeImpl . strict ( times , Arrays . asList ( new Object () ) ) ; }
assertSame ( verifierStub.mode , mode ) ;
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsAnalyzer () , new ActualInvocationsFinder () ) ; }
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
catch ( VerificationError e ) {}
StackTraceFilteringTest . class
{ verify ( mock , times ( NUMBER_CONSTANT ) ) . clear () ; fail () ; }
@ Before public void setup () { mock = mock ( LinkedList . class ) ; }
catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
InvocationDiffersFromActual e
TooManyActualInvocations e
TooLittleActualInvocations e
try { verify ( mock ) . oneArg ( same ( three ) ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
@ Test ( expected = TooLittleActualInvocations . class )
WantedButNotInvoked e
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { verifyNoMoreInteractions ( mockTwo ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { verifyNoMoreInteractions ( mockThree ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocations e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
catch ( NoInteractionsWanted e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
try { verifyNoMoreInteractions ( mockTwo ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
@ Test ( expected = InvocationDiffersFromActual . class )
catch ( WantedButNotInvoked e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
@ Test ( expected = InvocationDiffersFromActual . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = InvocationDiffersFromActual . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooLittleActualInvocations e ) {}
@ Test ( expected = TooLittleActualInvocations . class )
@ Test ( expected = TooManyActualInvocations . class )
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
InvocationDiffersFromActual error
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
{ mock . clear () ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {} }
{ mock . clear () ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {} }
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
catch ( TooManyActualInvocations e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooManyActualInvocations e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooLittleActualInvocations e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
throw new NoInteractionsWanted ( join ( STRING_CONSTANT ) , cause ) ;
public void wantedButNotInvoked ( String wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted ) ) ; }
throw new InvocationDiffersFromActual ( join ( STRING_CONSTANT , STRING_CONSTANT , wanted ) , cause ) ;
wantedInvocation . differsWithArgumentTypes ( actualInvocation )
try { verify ( mock ) . clear () ; fail () ; } catch ( TooManyActualInvocations e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual expected ) {}
@ Test ( expected = WantedButNotInvoked . class ) public void shouldFailVerification ( ) throws Exception { verify ( mock ) . clear () ; }
catch ( InvocationDiffersFromActual e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
catch ( InvocationDiffersFromActual e ) {}
catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( WantedButNotInvoked e ) {}
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
@ Test ( expected = WantedButNotInvoked . class )
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
TooLittleActualInvocations e
TooManyActualInvocations e
TooManyActualInvocations e
WantedButNotInvoked e
InvocationDiffersFromActual e
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
NoInteractionsWanted e
NoInteractionsWanted e
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
InvocationDiffersFromActual e
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
try { strictly . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( StrictVerificationFailure e ) {}
chunked = chunker . chunk ( Collections . < Integer > emptyList () , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
List < ObjectsChunk < Integer > > chunked = chunker . chunk ( asList ( NUMBER_CONSTANT ) , new EqualityBasedDistributor () ) ;
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
catch ( StrictVerificationFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
@ Test ( expected = StrictVerificationFailure . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = StrictVerificationFailure . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
@ Test ( expected = StrictVerificationFailure . class )
@ Test ( expected = StrictVerificationFailure . class )
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
strictly . verify ( mockOne , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
public NumberOfInvocationsVerifier () { this ( new Reporter () , new ActualInvocationsFinder () ) ; }
public boolean strictMode () { return ! mocksToBeVerifiedStrictly . isEmpty () && explicitMode () ; }
Invocation unverified = finder . findFirstUnverified ( invocations ) ;
public NoMoreInvocationsVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
{ Invocation similar = finder . findSimilarInvocation ( invocations , wanted , mode ) ; reportMissingInvocationError ( wanted , similar ) ; }
public MissingInvocationVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
List < Invocation > chunk = finder . findFirstUnverifiedChunk ( invocations , wanted ) ;
List < Invocation > chunk = finder . findFirstUnverifiedChunk ( invocations , wanted ) ;
{ finder.firstUnverifiedToReturn = null ; verifier . verify ( null , null , VerificationModeImpl . noMoreInteractions () ) ; }
finderStub.similarToReturn = actualInvocation ;
finderStub.similarToReturn = null ;
{ verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ; assertSame ( invocations , finderStub.invocations ) ; }
finderStub = new InvocationsFinderStub () ;
InvocationsFinder finder
public MissingInvocationVerifier () { this ( new InvocationsFinder () , new Reporter () ) ; }
InvocationsFinder finder
public StrictlyNumberOfInvocationsVerifier () { this ( new InvocationsFinder () , new Reporter () ) ; }
InvocationsFinder finder
public StrictlyMissingInvocationVerifier () { this ( new InvocationsFinder () , new Reporter () ) ; }
if ( mode . strictMode () ) { invocations = globalInvocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedStrictly () ) ; } else { invocations = registeredInvocations ; }
InvocationsFinder finder
public NoMoreInvocationsVerifier () { this ( new InvocationsFinder () , new Reporter () ) ; }
InvocationsFinder finder
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsFinder () ) ; }
finderStub = new InvocationsFinderStub () ;
finder = new InvocationsFinderStub () ;
List < ? extends Object > mocksToBeVerifiedStrictly
List < ? extends Object > mocksToBeVerifiedStrictly
HasStackTrace lastInvocation = finder . getLastStackTrace ( chunk ) ;
HasStackTrace lastInvocation = finder . getLastStackTrace ( actualInvocations ) ;
stub ( mock . oneArg ( anyString () ) ) . toReturn ( STRING_CONSTANT ) ;
mockingProgress . reportOngoingStubbing ( new OngoingStubbingImpl () ) ;
{ stub ( mock . simpleMethod () ) . toThrow ( null ) ; }
{ stub ( mock . simpleMethod () ) . toThrow ( new Exception () ) ; }
stub ( mock . booleanReturningMethod ( NUMBER_CONSTANT ) ) . toReturn ( true ) ;
OngoingStubbing pullOngoingStubbing ( ) ;
void reportOngoingStubbing ( OngoingStubbing ongoingStubbing ) ;
return handler . voidMethodStubbable () ;
stub ( mock . simpleMethod () ) . toThrow ( new RuntimeException () ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . toReturn ( Boolean.FALSE ) ;
stub ( mock . size () ) . toThrow ( new RuntimeException () ) ;
stub ( mock . size () ) . toThrow ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( error ) ;
stub ( reader . read () ) . toThrow ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( expected ) ;
{ Strictly strictly = strictly ( mock ) ; strictly . verify ( null ) ; fail () ; }
{ strictly () ; fail () ; }
Strictly strictly = strictly ( mock ) ;
{ Strictly strictly = strictly ( mock ) ; strictly . verify ( mockTwo ) . simpleMethod () ; }
@ Test ( expected = MockitoException . class ) public void shouldNotCreateStrictlyWithoutMocks () { strictly () ; }
strictly = strictly ( mock , mockTwo ) ;
Strictly strictly = strictly ( mockDatabase ) ;
strictly = strictly ( mockOne , mockTwo , mockThree ) ;
strictly = strictly ( mockOne ) ;
strictly = strictly ( mockOne , mockTwo , mockThree ) ;
strictly = strictly ( mock , mockTwo ) ;
strictly = strictly ( one , two , three ) ;
strictly = strictly ( mockOne ) ;
strictly = strictly ( mockOne ) ;
strictly = strictly ( mockOne , mockThree ) ;
strictly = strictly ( mockOne , mockTwo , mockThree ) ;
Strictly strictly = strictly ( mockTwo , mockThree ) ;
Strictly strictly = strictly ( mockTwo , mockThree ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockOne ) ;
Strictly strictly = strictly ( mockOne ) ;
Strictly strictly = strictly ( mockOne ) ;
Strictly strictly = strictly ( mockOne , mockThree ) ;
Strictly strictly = strictly ( mockTwo , mockThree ) ;
Strictly strictly = strictly ( mockOne , mockTwo , mockThree ) ;
Strictly strictly = strictly ( mock ) ;
T argument
T actual
{ for ( ArgumentMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
public Not ( ArgumentMatcher first ) { this . first = first ; }
{ for ( ArgumentMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
List < ArgumentMatcher > matchers
public void reportMatcher ( ArgumentMatcher matcher ) { matcherStack . push ( matcher ) ; }
List < ArgumentMatcher > matchers
List < ArgumentMatcher > matchers
return null ;
{ return reportMatcher ( matcher ) . < T > nullValue () ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . < String > nullValue () ; }
public static String anyString () { return isA ( String . class ) ; }
{ return reportMatcher ( matcher ) . < T > returnNull () ; }
public static double doubleThat ( CustomMatcher < Double > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static float floatThat ( CustomMatcher < Float > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static long longThat ( CustomMatcher < Long > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static int intThat ( CustomMatcher < Integer > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static short shortThat ( CustomMatcher < Short > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static byte byteThat ( CustomMatcher < Byte > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static boolean booleanThat ( CustomMatcher < Boolean > matcher ) { return reportMatcher ( matcher ) . returnFalse () ; }
public static char charThat ( CustomMatcher < Character > matcher ) { return reportMatcher ( matcher ) . returnChar () ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . < String > returnNull () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . < String > returnNull () ; }
{ return reportMatcher ( new Matches ( regex ) ) . < String > returnNull () ; }
{ return reportMatcher ( new Contains ( substring ) ) . < String > returnNull () ; }
public static Object notNull () { return reportMatcher ( NotNull.NOT_NULL ) . returnNull () ; }
public static Object isNull () { return reportMatcher ( Null.NULL ) . returnNull () ; }
{ return reportMatcher ( new Same ( value ) ) . returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnChar () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnFalse () ; }
{ return reportMatcher ( new InstanceOf ( clazz ) ) . returnNull () ; }
public static Object anyObject () { return reportMatcher ( Any.ANY ) . returnNull () ; }
public static short anyShort () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static double anyDouble () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static float anyFloat () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static long anyLong () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static int anyInt () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static char anyChar () { return reportMatcher ( Any.ANY ) . returnChar () ; }
public static byte anyByte () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static boolean anyBoolean () { return reportMatcher ( Any.ANY ) . returnFalse () ; }
public boolean returnFalse () { return false ; }
public < T > T returnNull () { return null ; }
public char returnChar () { return NUMBER_CONSTANT ; }
public byte returnZero () { return NUMBER_CONSTANT ; }
{ return LastArguments . instance () . reportNot () . returnFalse () ; }
{ return LastArguments . instance () . reportNot () . returnChar () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnNull () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnChar () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnNull () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnFalse () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnNull () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnChar () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnFalse () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnChar () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnNull () ; }
{ return LastArguments . instance () . reportOr () . returnFalse () ; }
{ return LastArguments . instance () . reportAnd () . returnNull () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnChar () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnFalse () ; }
{ return reportMatcher ( new Same ( value ) ) . < T > returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . < T > returnNull () ; }
{ return reportMatcher ( new InstanceOf ( clazz ) ) . < T > returnNull () ; }
{ return LastArguments . instance () . reportNot () . < T > returnNull () ; }
{ return LastArguments . instance () . reportOr () . < T > returnNull () ; }
{ return LastArguments . instance () . reportAnd () . < T > returnNull () ; }
{ return reportMatcher ( new Find ( regex ) ) . < String > returnNull () ; }
detects ( new OnVerifyInOrder () , UnfinishedVerificationException . class ) ;
detects ( new OnVerifyInOrder () , UnfinishedStubbingException . class ) ;
detects ( new OnVerifyInOrder () , UnfinishedStubbingException . class ) ;
assertFalse ( inOrder ( NUMBER_CONSTANT , asList ( new Object () ) ) . exactNumberOfInvocationsMode () ) ;
inOrder = inOrder ( mock , mockTwo ) ;
List < Invocation > unverified = ListUtil . filter ( invocations , new RemoveVerifiedInOrder () ) ;
inOrder = inOrder ( mock , mockTwo ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod () ;
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
@ Test ( expected = VerifcationInOrderFailed . class )
@ Override public void wantedButNotInvoked ( Object wanted ) { this . wanted = wanted ; }
finderStub.allMatchingUnverifiedChunksToReturn . add ( invocation ) ;
finderStub.allMatchingUnverifiedChunksToReturn . addAll ( asList ( first , second ) ) ;
finderStub.allMatchingUnverifiedChunksToReturn . addAll ( asList ( first , second ) ) ;
finderStub.allMatchingUnverifiedChunksToReturn . add ( differentMethod ) ;
assertTrue ( finderStub.allMatchingUnverifiedChunksToReturn . isEmpty () ) ;
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
@ Test ( expected = WantedButNotInvoked . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { inOrder . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = WantedButNotInvoked . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
@ Test ( expected = WantedButNotInvoked . class )
@ Override public void wantedButNotInvoked ( Printable wanted ) { this . wanted = wanted ; }
assertEquals ( wanted , reporterStub.wanted ) ;
{ reporter . wantedButNotInvoked ( wanted ) ; }
@ Override public void wantedButNotInvoked ( Printable wanted ) { this . wanted = wanted ; }
Printable wanted
List < Invocation > chunk = finder . findMatchingChunk ( invocations , wanted , mode ) ;
Printable wanted
public void wantedButNotInvoked ( Printable wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted . toString () ) ) ; }
Printable previous
Printable undesired
assertEquals ( firstUnverified , reporterStub.undesired ) ;
if ( unverified != null ) { reporter . noMoreInteractionsWanted ( unverified , unverified . getStackTrace () ) ; }
Printable wanted
Printable wanted
assertEquals ( wanted , reporterStub.wanted ) ;
assertEquals ( wanted , reporterStub.wanted ) ;
Printable previous
Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( invocations ) ;
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
@ Test ( expected = VerifcationInOrderFailure . class )
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
try { inOrder . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
public String toString () { return actual ; }
public String toString () { return wanted ; }
stub ( mockCalculator . countArticlesInPolish ( anyString () ) ) . toReturn ( NUMBER_CONSTANT ) ;
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { REPORTER . mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
Matcher < T > matcher
List < Matcher > matchers
public Not ( Matcher first ) { this . first = first ; }
List < Matcher > matchers
{ for ( Matcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < Matcher > matchers ) { this . matchers = matchers ; }
Object actual
List < Matcher > matchers
{ for ( Matcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < Matcher > matchers ) { this . matchers = matchers ; }
private static ReturnValues reportMatcher ( Matcher < > matcher ) { return LastArguments . instance () . reportMatcher ( matcher ) ; }
Matcher < Double > matcher
Matcher < Float > matcher
Matcher < Long > matcher
Matcher < Integer > matcher
Matcher < Short > matcher
Matcher < Byte > matcher
Matcher < Boolean > matcher
Matcher < Character > matcher
public ReturnValues reportMatcher ( Matcher matcher ) { matcherStack . push ( matcher ) ; return new ReturnValues () ; }
catch ( NeverWantedButInvoked e ) {}
catch ( NeverWantedButInvoked e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
if ( mode . neverWanted () && noMatchFound ) { return; }
ArgumentsAreDifferentException e
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( ArgumentsAreDifferentException expected ) {}
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) {}
catch ( ArgumentsAreDifferentException e ) {}
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
OverloadingPuzzleTest . class
PrintableInvocation undesired
@ Override public void wantedButNotInvoked ( PrintableInvocation wanted ) { this . wanted = wanted ; }
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
@ Override public void wantedButNotInvoked ( PrintableInvocation wanted ) { this . wanted = wanted ; }
PrintableInvocation undesired
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
public void wantedButNotInvoked ( PrintableInvocation wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted . toString () ) ) ; }
if ( matchers == null ) { this . matchers = invocation . argumentsToMatchers () ; } else { this . matchers = matchers ; }
mock . simpleMethod ( null , ( Integer ) null ) ;
argumentsMatch ( actual )
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( ArgumentsAreDifferent expected ) {}
@ Test ( expected = ArgumentsAreDifferent . class )
@ Test ( expected = ArgumentsAreDifferent . class )
@ Test ( expected = ArgumentsAreDifferent . class )
@ Test ( expected = ArgumentsAreDifferent . class )
catch ( ArgumentsAreDifferent e ) {}
catch ( ArgumentsAreDifferent e ) {}
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferent e
assertTrue ( invocation . hasSimilarMethod ( overloadedInvocation ) ) ;
assertFalse ( invocation . hasSimilarMethod ( overloadedInvocation ) ) ;
assertFalse ( simpleMethod . hasSimilarMethod ( onDifferentMock ) ) ;
assertFalse ( simpleMethod . hasSimilarMethod ( verified ) ) ;
assertTrue ( STRING_CONSTANT + cause . getMessage () + STRING_CONSTANT + text , cause . getMessage () . contains ( text ) ) ;
invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && argumentsMatch ( actual )
assertTrue ( STRING_CONSTANT + text + STRING_CONSTANT + value . getMessage () , ( ( Throwable ) value ) . getMessage () . contains ( text ) ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
if ( verificationMode != null ) { verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . emptyValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
if ( mode . inOrderMode () ) { invocations = globalInvocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedInOrder () ) ; } else { invocations = getRegisteredInvocations () ; }
DefaultReturnValuesTest . class
if ( verificationMode != null ) { verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . defaultReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
return MockitoConfiguration . defaultReturnValues () . valueFor ( invocation ) ;
ExampleTest . class
@ After public void resetDefaultReturnValues () { MockitoConfiguration . resetCustomReturnValues () ; }
return MockitoConfiguration . instance () . getReturnValues () . valueFor ( invocation ) ;
@ Before public void configureDefaultReturnValues () { MockitoConfiguration . instance () . setReturnValues ( new MyDefaultReturnValues () ) ; }
{ verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . instance () . getReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
@ Before public void configureDefaultReturnValues () { myDefaultReturnValues = new MyDefaultReturnValues () ; MockitoConfiguration . instance () . setReturnValues ( myDefaultReturnValues ) ; }
Invocation . isToString ( invocation )
InvocationOnMock invocation
InvocationOnMock invocation
InvocationOnMock invocation
InvocationOnMock invocation
return returnValueFor ( returnType ) ;
assertEquals ( ( char ) NUMBER_CONSTANT , mock . charReturningMethod ( NUMBER_CONSTANT ) ) ;
{ FakeReturnValues fakeReturnValues = getFakeReturnValues () ; fakeReturnValues . addMocks ( mocks ) ; }
catch ( MockitoException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
String mockDescription = STRING_CONSTANT + ClassNameFinder . classNameForMock ( mock ) + STRING_CONSTANT + mock . hashCode () ;
{ return MockUtil . createMock ( classToMock , null , MOCKING_PROGRESS ) ; }
assertThat ( m . getMatchers () , hasExactlyInOrder ( new Equals ( STRING_CONSTANT ) ) ) ;
assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ;
assertThat ( verifierStub.invocations , hasExactlyInOrder ( simpleMethod , differentMethod . getInvocation () ) ) ;
assertThat ( verifierStub.invocations , hasExactlyInOrder ( simpleMethod ) ) ;
MockHandler handler = new MockHandler ( null , state , new ExceptionThrowingBinder () ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
{ f . set ( testClass , Mockito . mock ( f . getType () , f . getName () ) ) ; }
assertThat ( filtered , hasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
stub ( mock . oneArg ( not ( Matchers . contains ( STRING_CONSTANT ) ) ) ) . toReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( and ( Matchers . contains ( STRING_CONSTANT ) , Matchers . contains ( STRING_CONSTANT ) ) ) ) . toReturn ( STRING_CONSTANT ) ;
try { MockUtil . getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List mock = Mockito . mock ( List . class ) ; assertNotNull ( MockUtil . getMockHandler ( mock ) ) ; }
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , hasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , hasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , hasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , hasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( mode . inOrderMode () ) { invocations = invocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedInOrder () ) ; } else { invocations = getRegisteredInvocations () ; }
{ return ! Modifier . isFinal ( clazz . getModifiers () ) ; }
{ if ( mocksReturningFakes . contains ( invocation . getMock () ) ) { return returnFake ( invocation ) ; } else { return ConfigurationSupport . defaultValueFor ( invocation ) ; } }
{ super . run ( notifier ) ; ConfigurationSupport . getConfiguration () . resetReturnValues () ; }
{ Object test = super . createTest () ; ConfigurationSupport . getConfiguration () . setReturnValues ( new FriendlyReturnValues () ) ; return test ; }
{ verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return Configuration . instance () . getReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
return Configuration . instance () . getReturnValues () . valueFor ( invocation ) ;
MockitoConfiguration config = ConfigurationSupport . getConfiguration () ;
{ super ( invocation . getInvocation () , invocation . getMatchers () ) ; this . answers . add ( result ) ; }
private Result ( Answer value ) { this . value = value ; }
public void addConsecutiveReturnValue ( Object value ) { stubbed . getFirst () . addAnswer ( Result . createReturnResult ( value ) ) ; }
AnswerFactoryTest . class
{ validateThrowable ( throwable ) ; stubbed . getFirst () . addAnswer ( AnswerFactory . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
Answer result
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( AnswerFactory . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
Answer result = AnswerFactory . createThrowingAnswer ( new RuntimeException () , filterStub ) ;
{ AnswerFactory . createThrowingAnswer ( new RuntimeException () , new StackTraceFilter () ) . answer () ; }
{ Answer result = AnswerFactory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
{ validateThrowable ( throwable ) ; stubbed . getFirst () . addAnswer ( AnswerFactory . createThrowingAnswer ( throwable , new StackTraceFilter () ) ) ; }
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( AnswerFactory . createThrowingAnswer ( throwable , new StackTraceFilter () ) ) ; }
assertEquals ( null , mock . oneArg ( ( Object ) null ) ) ;
assertEquals ( null , mock . oneArg ( ( Object ) null ) ) ;
public String toString () { return toString ( argumentsToMatchers () , false ) ; }
{ Answer result = factory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
{ return ( String ) anyObject () ; }
Answer answer = answerFactory . createReturningAnswer ( value ) ;
for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) { return s . answer ( invocation ) ; } }
{ result . answer ( null ) ; fail () ; }
{ factory . createThrowingAnswer ( new RuntimeException () , null ) . answer ( null ) ; }
{ Answer result = factory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer ( null ) ) ; }
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , not ( isNotNull () ) , eq ( STRING_CONSTANT ) ) ) . toReturn ( STRING_CONSTANT ) ;
Answer < > answer
Answer < > answer
Answer < > answer
{ stubber . addConsecutiveAnswer ( new ThrowsException ( throwable ) ) ; return this ; }
{ stubber . addConsecutiveAnswer ( new Returns ( value ) ) ; return this ; }
Answer < > answer
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( new ThrowsException ( throwable ) ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( new Returns ( value ) ) ; return new ConsecutiveStubbing () ; }
{ stubber . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
{ try { stubber . addAnswer ( new ThrowsException ( null ) ) ; fail () ; } catch ( MockitoException e ) {} }
stubber . addAnswer ( new Returns ( STRING_CONSTANT ) ) ;
{ state . stubbingStarted () ; stubber . addAnswer ( new Returns ( STRING_CONSTANT ) ) ; state . validateState () ; }
{ stubber . addAnswer ( new ThrowsException ( new Exception () ) ) ; fail () ; }
public void setInstance ( Object mock ) {}
ClassWithDodgyConstructor mock = factory . createMock ( ClassWithDodgyConstructor . class , new MockAwareStub () , null ) ;
ClassWithoutConstructor proxy = factory . createMock ( ClassWithoutConstructor . class , new MockAwareStub () , null ) ;
SomeInterface proxy = factory . createMock ( SomeInterface . class , new MockAwareStub () , null ) ;
{ return mock ( classToMock , null ) ; }
return delegate . intercept ( proxy , method , args , methodProxy ) ;
try { stubber . getResultFor ( simpleMethod ) ; fail () ; } catch ( MyException e ) {}
this . stubber = new Stubber ( mockingProgress ) ;
void setInstance ( T mock ) ;
@ Before public void setUp () { StateMaster . reset () ; mock = Mockito . mock ( IMethods . class ) ; }
{ StateMaster . reset () ; mock = mock ( IMethods . class ) ; }
{ MOCKING_PROGRESS . stubbingStarted () ; return new MethodSelectorImpl ( new ThrowsException ( toBeThrown ) ) ; }
{ MOCKING_PROGRESS . stubbingStarted () ; return new MethodSelectorImpl ( new Returns ( toBeReturned ) ) ; }
{ doReturn ( STRING_CONSTANT ) . when ( ( Object ) null ) . toString () ; fail () ; }
{ mockitoStubber . addConsecutiveAnswer ( answer ) ; return this ; }
{ mockitoStubber . addConsecutiveAnswer ( new ThrowsException ( throwable ) ) ; return this ; }
{ mockitoStubber . addConsecutiveAnswer ( new Returns ( value ) ) ; return this ; }
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( new ThrowsException ( throwable ) ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( new Returns ( value ) ) ; return new ConsecutiveStubbing () ; }
{ mockitoStubber . addAnswerForVoidMethod ( answer ) ; return this ; }
public VoidMethodStubbable < T > toReturn () { mockitoStubber . addAnswerForVoidMethod ( new Returns () ) ; return this ; }
{ mockitoStubber . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
this . mockitoStubber = new MockitoStubber ( mockingProgress ) ;
return handler . voidMethodStubbable ( mock ) ;
@ SuppressWarnings ( STRING_CONSTANT ) public void setAnswersForStubbing ( List < Answer > answers ) { mockitoStubber . setAnswersForStubbing ( answers ) ; }
try { mockitoStubber . setMethodForStubbing ( new InvocationMatcher ( simpleMethod ) ) ; fail () ; } catch ( MockitoException e ) {}
mockitoStubber . setMethodForStubbing ( new InvocationMatcher ( simpleMethod ) ) ;
{ return MockUtil . createMock ( classToMock , MOCKING_PROGRESS , name , null ) ; }
{ validator . validate ( new DoesNothing () , new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ; }
{ validator . validate ( new DoesNothing () , new InvocationBuilder () . simpleMethod () . toInvocation () ) ; }
DoesNothing answer
doNothing () . doNothing () . doThrow ( new RuntimeException () ) . when ( mock ) . voidMethod () ;
Stubber doNothing ( ) ;
if ( answer instanceof DoesNothing ) { validateDoNothing ( ( DoesNothing ) answer , invocation ) ; }
detects ( new OnDoAnswer () , UnfinishedVerificationException . class ) ;
detects ( new OnDoAnswer () , UnfinishedStubbingException . class ) ;
detects ( new OnDoAnswer () , UnfinishedStubbingException . class ) ;
enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( toMock ) ) ;
AtLeastXVerificationTest . class
try { mockitoStubber . answerTo ( simpleMethod ) ; fail () ; } catch ( MyException e ) {}
InvocationOnMock invocation
mockingProgress . reportOngoingStubbing ( new DeprecatedOngoingStubbingImpl () ) ;
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
mode . atLeastMode () || ! mode . matchesActualCount ( firstChunk . size () )
public boolean neverWanted () { return ! atLeastMode () && wantedInvocationCount == NUMBER_CONSTANT ; }
public boolean tooManyActualInvocations ( int actualCount ) { return ! atLeastMode () && wantedInvocationCount < actualCount ; }
public boolean tooLittleActualInvocations ( int actualCount ) { return ! atLeastMode () && wantedInvocationCount > actualCount ; }
public boolean missingMethodMode () { return explicitMode () && ( atLeastMode () || wantedInvocationCount > NUMBER_CONSTANT ) ; }
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new VerificationModeImpl ( wantedNumberOfInvocations , null , mocksToBeVerifiedInOrder , Verification.EXPLICIT ) ; }
when ( mock . size () ) . thenThrow ( new RuntimeException () ) ;
when ( mock . size () ) . thenThrow ( new RuntimeException () ) ;
{ when ( mock . add ( STRING_CONSTANT ) ) . thenThrow ( null ) ; }
when ( mock . add ( STRING_CONSTANT ) ) . thenThrow ( error ) ;
when ( reader . read () ) . thenThrow ( ioException ) ;
when ( mock . add ( STRING_CONSTANT ) ) . thenThrow ( expected ) ;
when ( mockTwo . toString () ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . booleanReturningMethod () ) . thenReturn ( true ) ;
when ( mock . add ( STRING_CONSTANT ) ) . thenReturn ( Boolean.FALSE ) ;
{ when ( mock . simpleMethod () ) . thenThrow ( null ) ; }
{ when ( mock . simpleMethod () ) . thenThrow ( new Exception () ) ; }
Mockito . when ( mock . add ( STRING_CONSTANT ) ) . thenReturn ( true ) ;
when ( mock . simpleMethod () ) . thenThrow ( new RuntimeException () ) ;
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
mockingProgress . reportOngoingStubbing ( new OngoingStubbingImpl () ) ;
when ( mock . oneArg ( anyString () ) ) . thenReturn ( STRING_CONSTANT ) ;
AssertionError e
catch ( AssertionError e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( AssertionError expected ) {}
{ HasStackTrace lastInvocation = finder . getLastStackTrace ( actualInvocations ) ; reporter . tooLittleActualInvocationsInAtLeastMode ( mode . wantedCount () , actualCount , wanted , lastInvocation ) ; }
if ( mode . explicitMode () || mode . atLeastMode () ) { return; }
boolean atLeast = atLeastMode () && actualCount >= wantedInvocationCount ;
public boolean exactNumberOfInvocationsMode () { return ! inOrderMode () && ( explicitMode () || atLeastMode () ) ; }
public static VerificationModeImpl noMoreInteractions () { return new VerificationModeImpl ( NUMBER_CONSTANT , Collections . emptyList () , Verification.NO_MORE_WANTED ) ; }
ClassImposterizerTest . class
@ Test public void shouldNeverVerifyWhenVerificationIsInAtLeastMode ( ) throws Exception { assertFalse ( verifier . appliesTo ( VerificationModeImpl . atLeastOnce () ) ) ; }
@ Test public void shouldNeverVerifyWhenVerificationIsExplicit ( ) throws Exception { assertFalse ( verifier . appliesTo ( VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ) ; }
new VerificationModeDecoder ( mode ) . atLeastMode ()
new VerificationModeDecoder ( mode ) . inOrderMode ()
VerificationMode mode
public void verify ( VerificationMode mode ) { verify ( null , mode ) ; }
VerificationMode verificationMode = mockingProgress . pullVerificationMode () ;
VerificationMode atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
VerificationMode mode
VerificationMode mode
VerificationMode mode
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = atLeastOnce () ;
public VerificationModeDecoder ( VerificationMode mode ) { this . mode = mode ; }
VerificationMode mode = VerificationModeImpl . times ( NUMBER_CONSTANT ) ;
VerificationMode mode
VerificationMode mode
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationMode mode ) ;
VerificationMode mode
public boolean appliesTo ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) . missingMethodMode () ; }
VerificationMode mode
public boolean appliesTo ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) . missingMethodInOrderMode () ; }
VerificationMode mode
VerificationMode inOrderMode = new VerificationModeBuilder () . inOrder () ;
VerificationMode mode = VerificationModeImpl . atLeastOnce () ;
VerificationMode mode = atLeastOnce () ;
private VerificationModeDecoder decode ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) ; }
VerificationMode mode
public boolean appliesTo ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) . inOrderMode () ; }
VerificationMode mode
public boolean appliesTo ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) . exactNumberOfInvocationsMode () ; }
VerificationMode mode
VerificationMode mode
VerificationMode mode
VerificationMode mode
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new InOrderVerificationMode ( minNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.AT_LEAST ) ; }
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new InOrderVerificationMode ( wantedNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.EXPLICIT ) ; }
verifyingRecorder = new VerifyingRecorder () ;
state . verificationStarted ( VerificationModeFactory . atLeastOnce () ) ;
MockitoVerificationMode atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedDifferentMethod ) , VerificationModeFactory . atLeastOnce () ) ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedSimpleMethod ) , VerificationModeFactory . atLeastOnce () ) ;
MockitoVerificationMode mode
MockitoVerificationMode mode
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ; }
VerificationMode mode = VerificationModeFactory . atLeastOnce () ;
VerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
public VerificationModeDecoder ( MockitoVerificationMode mode ) { this . mode = mode ; }
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode
MockitoVerificationMode mode
MockitoVerificationModeTest . class
{ return VerificationModeFactory . atLeast ( minNumberOfInvocations ) ; }
{ return VerificationModeFactory . atLeastOnce () ; }
{ return VerificationModeFactory . times ( wantedNumberOfInvocations ) ; }
private VerificationModeDecoder decode ( MockitoVerificationMode mode ) { return new VerificationModeDecoder ( mode ) ; }
{ mode . verify ( new VerificationDataImpl ( getRegisteredInvocations () , wanted ) ) ; }
public InvocationMatcher getWanted () { return wanted ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . returnString () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . returnString () ; }
{ return reportMatcher ( new Matches ( regex ) ) . returnString () ; }
{ return reportMatcher ( new Contains ( substring ) ) . returnString () ; }
{ return reportMatcher ( Any.ANY ) . returnList () ; }
{ return reportMatcher ( Any.ANY ) . returnMap () ; }
{ return reportMatcher ( Any.ANY ) . returnList () ; }
{ return reportMatcher ( Any.ANY ) . returnString () ; }
verifier . verify ( invocations , wanted ) ;
verifier . verify ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted ) ; }
{ missingInvocation . verify ( data . getAllInvocations () , data . getWanted () ) ; }
@ Override public String toString () { return STRING_CONSTANT + wantedCount () ; }
AtMostXVerificationTest . class
{ registeredInvocations . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
{ registeredInvocations . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
this . registeredInvocations = new RegisteredInvocations () ;
{ VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll () , null ) ; VerificationModeFactory . noMoreInteractions () . verify ( data ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll () , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
RegisteredInvocationsTest . class
if ( ! ( mode instanceof VerificationInOrderMode ) ) { throw new MockitoException ( mode . getClass () . getSimpleName () + STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoAssertionError e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
public boolean neverWanted () { return mode . wantedCount () == NUMBER_CONSTANT ; }
public boolean tooManyActualInvocations ( int actualCount ) { return mode . wantedCount () < actualCount ; }
public boolean tooLittleActualInvocations ( int actualCount ) { return mode . wantedCount () > actualCount ; }
public static MockitoVerificationMode times ( int wantedNumberOfInvocations ) { return new MockitoVerificationMode ( wantedNumberOfInvocations ) ; }
Times mode
Times mode
public VerificationModeDecoder ( Times mode ) { this . mode = mode ; }
TimesTest . class
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode
private VerificationModeDecoder decode ( Times mode ) { return new VerificationModeDecoder ( mode ) ; }
Times atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
Times mode
return Mockito . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ;
int wantedCount
List < Invocation > chunk = finder . findMatchingChunk ( invocations , wanted , mode . wantedCount () ) ;
{ if ( wantedNumberOfInvocations < NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedCount = wantedNumberOfInvocations ; }
{ if ( wantedNumberOfInvocations <= NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedCount = wantedNumberOfInvocations ; }
numberOfCalls . verify ( allInvocations , wanted , wantedCount ) ;
wantedCount > NUMBER_CONSTANT
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted ) ;
verifier . check ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . check ( invocations , wanted ) ; }
verifier . check ( invocations , wanted ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
if ( wantedCount == NUMBER_CONSTANT ) { missingInvocation . check ( allInvocations , wanted , this ) ; }
if ( wantedCount == NUMBER_CONSTANT ) { missingInvocation . check ( data . getAllInvocations () , data . getWanted () ) ; }
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
checker = new NumberOfInvocationsInOrderChecker ( finderStub , reporter ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; checker . check ( invocations , wanted ) ; }
checker . check ( invocations , wanted ) ;
checker = new MissingInvocationChecker ( finderStub , reporterStub ) ;
checker . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
checker . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
checker . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
checker = new MissingInvocationInOrderChecker ( finderStub , reporterStub ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker = new NumberOfInvocationsChecker ( reporterStub , finderStub ) ;
numberOfCalls . check ( allInvocations , wanted , wantedCount ) ;
numberOfInvocations . check ( data . getAllInvocations () , data . getWanted () , wantedCount ) ;
if ( stubbing == null ) { MOCKING_PROGRESS . reset () ; REPORTER . missingMethodInvocation () ; }
Object value
public DeprecatedOngoingStubbing < T > toReturn ( T value ) { return toAnswer ( new Returns ( value ) ) ; }
public NewOngoingStubbing < T > thenReturn ( T value ) { return thenAnswer ( new Returns ( value ) ) ; }
T value
MockHandler handler = new MockHandler ( null , state , new ExceptionThrowingBinder () , null ) ;
{ return returnValues . valueFor ( invocation ) ; }
{ return mock ( classToMock , name , null , USING_GLOBAL_CONFIG ) ; }
{ return mock ( classToMock , null , null , USING_GLOBAL_CONFIG ) ; }
if ( mockedType . getSigners () != null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy.INSTANCE ) ; }
MockingProgress state = new MockingProgressImpl () ;
public void reset () { stubbingInProgress = false ; verificationMode = null ; getLastArguments () . reset () ; }
getLastArguments () . validateState () ;
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnFalse () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnFalse () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnFalse () ; }
ArgumentMatcherStorage argumentMatcherStorage
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnFalse () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnFalse () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnFalse () ; }
public void reset () { stubbingInProgress = false ; verificationMode = null ; getArgumentMatcherStorage () . reset () ; }
getArgumentMatcherStorage () . validateState () ;
public void stubbingCompleted ( Invocation invocation ) { debuggingHelper . addStubbedInvocation ( invocation ) ; stubbingInProgress = false ; }
public ExperimentalMockitoJUnitRunner ( Class < > klass ) throws InitializationError { super ( klass ) ; logger = new MockitoLoggerImpl () ; }
private boolean shouldPrint () { return ! unusedStubs . isEmpty () || ! unstubbedInvocations . isEmpty () ; }
public byte [] naughtyMethodUnderTestWhichDoesNotFailBecauseItReturnsAValue ( String filename ) { return null ; }
public void addUnstubbedInvocation ( InvocationMatcher invocation ) { unstubbedInvocations . add ( invocation ) ; }
if ( ! invocation . isVoid () && answer == null ) { mockingProgress . getDebuggingHelper () . addPotentiallyUnstubbed ( invocationMatcher ) ; }
if ( ! invocation . isVoid () && answer == null ) { mockingProgress . getDebuggingInfo () . addPotentiallyUnstubbed ( invocationMatcher ) ; }
void println ( Object what ) ;
public void stubbingCompleted ( Invocation invocation ) { debuggingInfo . addStubbedInvocation ( invocation ) ; stubbingInProgress = false ; }
public void println () { System.out . println () ; }
public ExperimentalMockitoJUnitRunner ( Class < > klass ) throws InitializationError { super ( klass ) ; }
void log ( Object what ) ;
{ if ( hasData () ) { WarningsPrinter warningsPrinter = new WarningsPrinter ( unusedStubs , unstubbedInvocations ) ; warningsPrinter . print ( logger ) ; } }
public void addPotentiallyUnstubbed ( InvocationMatcher invocationMatcher ) { if ( ! collectingData ) { return; } unstubbedInvocations . add ( invocationMatcher ) ; }
public ExperimentalMockitoJUnitRunnerPMStub ( ) throws InitializationError { super ( ExperimentalMockitoJUnitRunnerPMTest . class , loggerStub ) ; }
String loggedInfo = loggerStub . getLoggedInfo () ;
String loggedInfo = loggerStub . getLoggedInfo () ;
String loggedInfo = loggerStub . getLoggedInfo () ;
String loggedInfo = loggerStub . getLoggedInfo () ;
public void log ( Object what ) { super . log ( what ) ; loggedInfo . append ( what ) ; }
{ return DEFAULT_RETURN_VALUES . valueFor ( invocation ) ; }
{ someUnusedStubbingThatQualifiesForWarning () ; notifier . fireTestFailure ( null ) ; assertTrue ( debuggingInfo . hasData () ) ; }
EmptyReturnValuesTest . class
HandyReturnValues reportMatcher ( Matcher matcher ) ;
Foo mock = mock ( Foo . class , RETURNS_SMART_NULLS ) ;
Foo mock = mock ( Foo . class , RETURNS_SMART_NULLS ) ;
@ Before public void setup () { mock = mock ( IMethods . class , Mockito.RETURNS_SMART_NULLS ) ; }
{ return mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
MockName mockName
catch ( NoSuchMethodException e ) { throw new RuntimeException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
unfinishedVerificationHere () ;
{ validateState () ; resetOngoingStubbing () ; verificationMode = new Localized ( verify ) ; }
verify ( mock ) ;
{ mock ( IMethods . class ) ; fail () ; }
this . firstTraceElement = filter . filterStackTrace ( stackTrace ) [ NUMBER_CONSTANT ] ;
if ( callback instanceof MethodInterceptorFilter ) { return ( MethodInterceptorFilter < MockHandler < T > > ) callback ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
ClickableStackTracesTest . class
STRING_CONSTANT + pluralize ( actualCount ) + STRING_CONSTANT
{ matcherStack . push ( new LocalizedMatcher ( matcher ) ) ; return new HandyReturnValues () ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( expectedMessage , actualMessage ) ;
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NeverWantedButInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ;
reporter . tooLittleActualInvocations ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ;
reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ;
STRING_CONSTANT + Pluralizer . pluralize ( wantedCount ) + STRING_CONSTANT
reporter . tooLittleActualInvocationsInOrder ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ;
catch ( SmartNullPointerException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
@ Test ( expected = VerificationInOrderFailure . class )
@ Test ( expected = VerificationInOrderFailure . class )
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( spy ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure f ) {}
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
@ Test ( expected = VerificationInOrderFailure . class )
catch ( VerificationInOrderFailure e ) {}
@ Test ( expected = VerificationInOrderFailure . class )
try { inOrder . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
VerificationInOrderFailure e
VerificationInOrderFailure e
VerificationInOrderFailure e
VerificationInOrderFailure e
catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
{ String message = createTooLittleInvocationsMessage ( discrepancy , wanted , lastActualStackTrace ) ; throw new VerificationInOrderFailure ( join ( STRING_CONSTANT + message ) ) ; }
throw new VerificationInOrderFailure ( join ( STRING_CONSTANT + message ) ) ;
if ( stubbingInProgress ) { stubbingInProgress = false ; reporter . unfinishedStubbing ( debuggingInfo . getLastInvocationLocation () ) ; }
assertContains ( expectedMessage , actualMessage ) ;
private void misplacedArgumentMatcherHere () { anyString () ; }
mockitoStubber . setInvocationForPotentialStubbing ( new InvocationBuilder () . toInvocationMatcher () , null ) ;
{ return new VoidMethodStubbableImpl < T > ( mock , mockitoStubber ) ; }
{ return new VoidMethodStubbableImpl ( mock ) ; }
if ( stubbingInProgress ) { stubbingInProgress = false ; reporter . unfinishedStubbing () ; }
mockitoStubber . setInvocationForPotentialStubbing ( new InvocationBuilder () . toInvocationMatcher () ) ;
public void reset () { stubbingInProgress = null ; verificationMode = null ; getArgumentMatcherStorage () . reset () ; }
public void stubbingCompleted ( Invocation invocation ) { debuggingInfo . addStubbedInvocation ( invocation ) ; stubbingInProgress = null ; }
{ Throwable filtered = throwable . fillInStackTrace () ; filter . filterStackTrace ( filtered ) ; throw filtered ; }
assertEquals ( invocation . getLocation () , reporterStub.location ) ;
assertSame ( third . getLocation () , reporterStub.location ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.location ) ; }
assertSame ( second . getLocation () , reporterStub.location ) ;
if ( previousInOrder == null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder , previousInOrder . getLocation () ) ; }
Location firstUndesired
Location firstUndesired
Throwable hasStackTrace
reporter . argumentsAreDifferent ( syncingPrinter . getWanted () , syncingPrinter . getActual () , similar . getLocation () ) ;
if ( unverified != null ) { new Reporter () . noMoreInteractionsWanted ( unverified , unverified . getLocation () ) ; }
assertSame ( previous . getLocation () , reporterStub.previousLocation ) ;
assertSame ( actualInvocation . getLocation () , reporterStub.actualLocation ) ;
assertNull ( reporterStub.actualLocation ) ;
final boolean overloadedButSameArgs = ! methodEquals && argumentsMatch ( candidate . getArguments () ) ;
int expectedMatchersSize = invocation . getArgumentsCount () ;
Location lastLocation = finder . getLastLocation ( chunk ) ;
Location lastLocation = finder . getLastLocation ( actualInvocations ) ;
Location lastInvocation = finder . getLastLocation ( actualInvocations ) ;
Location lastInvocation = finder . getLastLocation ( chunk ) ;
if ( previousInOrder == null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder ) ; }
if ( unverified != null ) { new Reporter () . noMoreInteractionsWanted ( unverified ) ; }
@ Override public String toString () { return STRING_CONSTANT + this . firstTraceElement . toString () ; }
if ( matcherStack . isEmpty () ) { return Collections . emptyList () ; }
assertNull ( new ThreadSafeMockingProgress () . pullOngoingStubbing () ) ;
assertTrue ( ret . getClass () . isArray () ) ;
{ return MockitoCore . doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return MockitoCore . doAnswer ( new DoesNothing () ) ; }
{ return MockitoCore . doAnswer ( new ThrowsException ( toBeThrown ) ) ; }
{ MockitoCore . verifyNoMoreInteractions ( mocks ) ; }
{ return MockitoCore . verify ( mock , times ( NUMBER_CONSTANT ) ) ; }
{ return MockitoCore . mock ( classToMock , null , ( T ) null , returnValues ) ; }
{ return MockitoCore . mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return MockitoCore . mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
return mockitoCore . mock ( ( Class ) class1 , null , null , this ) ;
{ return MOCKITO_CORE . inOrder ( mocks ) ; }
{ return MOCKITO_CORE . doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return MOCKITO_CORE . doAnswer ( new DoesNothing () ) ; }
{ return MOCKITO_CORE . doAnswer ( answer ) ; }
{ return MOCKITO_CORE . doAnswer ( new ThrowsException ( toBeThrown ) ) ; }
{ return MOCKITO_CORE . stubVoid ( mock ) ; }
{ MOCKITO_CORE . verifyNoMoreInteractions ( mocks ) ; }
{ MOCKITO_CORE . verifyNoMoreInteractions ( mocks ) ; }
{ return MOCKITO_CORE . verify ( mock , mode ) ; }
{ MOCKITO_CORE . reset ( mock ) ; }
{ return MOCKITO_CORE . verify ( mock , times ( NUMBER_CONSTANT ) ) ; }
{ return MOCKITO_CORE . when ( methodCall ) ; }
{ return MOCKITO_CORE . stub ( methodCall ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , ( T ) null , returnValues ) ; }
{ return MOCKITO_CORE . mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
for ( T m : mocks ) { MockUtil . resetMock ( m , MOCKING_PROGRESS ) ; }
mockingProgress . stubbingStarted () ;
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { reporter . mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
{ mockingProgress . stubbingStarted () ; return ( NewOngoingStubbing ) stub () ; }
{ mockingProgress . stubbingStarted () ; return ( DeprecatedOngoingStubbing ) stub () ; }
super . makeStackTracesClean () ;
super . makeStackTracesClean () ;
{ mock = mock ( IMethods . class , Mockito.RETURNS_SMART_NULLS ) ; super . makeStackTracesClean () ; }
{ super . makeStackTracesClean () ; first () ; second () ; third () ; fourth () ; }
@ Before public void init () { new StateMaster () . validate () ; MockitoAnnotations . initMocks ( this ) ; }
new StateMaster () . validate () ;
{ return anyObject () ; }
filter . filterConditionally ( t ) ;
{ unfilteredStackTrace = getStackTrace () ; StackTraceFilter filter = new StackTraceFilter () ; filter . filterConditionally ( this ) ; }
filter . filterConditionally ( this ) ;
filter . filterConditionally ( this ) ;
this . firstTraceElement = filter . filter ( stackTrace ) [ NUMBER_CONSTANT ] ;
public void cleanStackTraces () { super . makeStackTracesClean () ; }
filter . filter ( t ) ;
catch ( AssertionError e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
catch ( InvalidUseOfMatchersException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NeverWantedButInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertContains ( STRING_CONSTANT , mockTwo . toString () ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , mock . toString () ) ;
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
final boolean overloadedButSameArgs = ! methodEquals && safelyArgumentsMatch ( candidate . getArguments () ) ;
{ return ( T ) anyObject () ; }
Invocation i = new Invocation ( mock , method , args , sequenceNumber , null ) ;
TestedObject mock = mock ( TestedObject . class ) ;
public Person ( Integer age ) { this . age = age ; }
if ( arguments . isEmpty () ) { new Reporter () . noArgumentValueWasCaptured () ; } else { return ( T ) arguments . getLast () ; }
{ anyObject () ; try { Mockito . validateMockitoUsage () ; fail () ; } catch ( InvalidUseOfMatchersException e ) {} }
try { Mockito . validateMockitoUsage () ; fail () ; } catch ( UnfinishedStubbingException e ) {}
{ verify ( mock ) ; try { Mockito . validateMockitoUsage () ; fail () ; } catch ( UnfinishedVerificationException e ) {} }
{ return this . capturingMatcher . getAllValues () ; }
{ Mockito . argThat ( capturingMatcher ) ; return null ; }
{ notifier . addListener ( new FrameworkUsageValidator ( notifier ) ) ; legacyRunner . run ( notifier ) ; }
{ if ( classProvider . isJUnit45OrHigherAvailable () ) { return classProvider . newInstance ( STRING_CONSTANT , klass ) ; } else { return classProvider . newInstance ( STRING_CONSTANT , klass ) ; } }
RunnerFactory ( RunnerProvider classProvider ) { this . classProvider = classProvider ; }
{ this . runner = new JUnit44RunnerImpl ( klass ) ; }
catch ( Throwable t ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , t ) ; }
runner . run ( notifier ) ;
if ( MockUtil . isMock ( instance ) ) { return returnValues . valueFor ( invocation ) ; } else { return methodProxy . invokeSuper ( proxy , args ) ; }
{ try { new ShallowCopyTool () . copyToMock ( optionalInstance , mock ) ; } catch ( UnableToCopyFieldValue e ) {} }
@ Test public void shouldCallRealMethdsEvenDelegatedToOtherSelfMethod () { String name = spy . getName () ; assertEquals ( STRING_CONSTANT , name ) ; }
Name guessName () { return defaultName ; }
public String getName () { return guessName () . name ; }
{ return new VoidMethodStubbableImpl < T > ( mock , mockitoStubber ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , name , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , null , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , configureWith () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
assertTrue ( new MockUtil () . isMock ( classMock ) ) ;
assertTrue ( new MockUtil () . isMock ( interfaceMock ) ) ;
if ( new MockUtil () . isMock ( throwable ) ) { throw throwable ; }
new MockUtil () . isMock ( instance )
new MockUtil () . getMockHandler ( withFinal ) ;
MockName name = new MockUtil () . getMockName ( mock ) ;
try { mockUtil . getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List mock = Mockito . mock ( List . class ) ; assertNotNull ( mockUtil . getMockHandler ( mock ) ) ; }
List < Invocation > fromSingleMock = new MockUtil () . getMockHandler ( mock ) . getRegisteredInvocations () ;
MockHandler < T > handler = mockUtil . getMockHandler ( mock ) ;
if ( mock == null ) { reporter . nullPassedWhenCreatingInOrder () ; } else if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder () ; }
{ if ( mock == null ) { reporter . nullPassedToVerifyNoMoreInteractions () ; } mockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions () ; }
for ( T m : mocks ) { mockUtil . resetMock ( m , mockingProgress ) ; }
if ( mock == null ) { reporter . nullPassedToVerify () ; } else if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify () ; }
{ mockingProgress . validateState () ; mockingProgress . resetOngoingStubbing () ; return mockUtil . createMock ( classToMock , mockingProgress , ( MockSettingsImpl ) mockSettings ) ; }
{ mock ( IMethods . class , withSettings () . extraInterfaces ( IMethods . class ) ) ; fail () ; }
{ mock ( Foo . class , withSettings () . extraInterfaces ( Foo . class ) ) ; fail () ; }
{ mock ( Foo . class , withSettings () . extraInterfaces ( ( Class [] ) null ) ) ; fail () ; }
{ mock ( Foo . class , withSettings () . extraInterfaces () ) ; fail () ; }
{ mock ( Foo . class , withSettings () . extraInterfaces ( IFoo . class , null ) ) ; fail () ; }
Foo mock = mock ( Foo . class , withSettings () . extraInterfaces ( IFoo . class , IBar . class ) ) ;
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultBehavior ( RETURNS_DEFAULTS ) )
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . defaultBehavior ( returnValues ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . name ( name ) . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ mock ( IMethods . class , withSettings () . extraInterfaces ( ( Class [] ) null ) ) ; }
@ Test public void shouldScreamWhenExtraIsTheSame () { mock ( IMethods . class , withSettings () . extraInterfaces ( IMethods . class ) ) ; }
@ Test public void shouldScreamWhenNonInterfacePassed () { mock ( IMethods . class , withSettings () . extraInterfaces ( LinkedList . class ) ) ; }
{ mock ( IMethods . class , withSettings () . extraInterfaces ( List . class , null ) ) ; }
{ return mock ( classToMock , withSettings () . defaultBehavior ( returnValues ) ) ; }
{ return mock ( classToMock , withSettings () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ MockSettingsImpl settings = ( MockSettingsImpl ) Mockito . withSettings () ; assertEquals ( Mockito.RETURNS_DEFAULTS , settings . getDefaultAnswer () ) ; }
IMethods mock = mock ( IMethods . class , withSettings () . defaultAnswer ( RETURNS_SMART_NULLS ) . name ( STRING_CONSTANT ) ) ;
{ return mockSettings . getDefaultAnswer () . answer ( invocation ) ; }
{ assertEquals ( STRING_CONSTANT , values . answer ( invocationOf ( StringMethods . class , STRING_CONSTANT ) ) ) ; }
ret = ( String [] ) values . answer ( invocationOf ( StringMethods . class , STRING_CONSTANT ) )
public static MockSettings withSettings () { return new MockSettingsImpl () . defaultAnswer ( RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . doAnswer ( new CallsRealMethods () ) ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultAnswer ( RETURNS_DEFAULTS ) )
{ return mock ( classToMock , withSettings () . name ( name ) . defaultAnswer ( RETURNS_DEFAULTS ) ) ; }
{ return mock ( classToMock , withSettings () . defaultAnswer ( RETURNS_DEFAULTS ) ) ; }
ReturnsEmptyValuesTest . class
{ ConfigurationAccess . getConfig () . overrideCleansStackTrace ( false ) ; ConfigurationAccess . getConfig () . overrideDefaultAnswer ( null ) ; }
runner = new ConsoleSpammingMockitoJUnitRunner ( DummyTest . class ) ;
public Object answer ( InvocationOnMock invocation ) throws Throwable { return invocation . callRealMethod () ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultAnswer ( CALLS_REAL_METHODS ) )
catch ( Throwable t ) { throw t ; }
this . firstTraceElement = filter . filter ( stackTrace , NUMBER_CONSTANT ) [ NUMBER_CONSTANT ] ;
this . firstTraceElement = filter . filter ( stackTrace , false ) [ NUMBER_CONSTANT ] ;
StackTraceElement [] filtered = filter . filter ( throwable . getStackTrace () , true ) ;
StackTraceElement [] filtered = filter . filter ( new StackTraceElement [ NUMBER_CONSTANT ] , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
line = printer . getArgumentsLine ( ( List ) Arrays . asList ( new Equals ( NUMBER_CONSTANT ) , NotNull.NOT_NULL ) , PrintSettings . verboseMatchers () )
printer . getArgumentsBlock ( ( List ) Arrays . asList ( new Equals ( NUMBER_CONSTANT ) , new Equals ( NUMBER_CONSTANT ) ) , PrintSettings . verboseMatchers () )
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseSelfDescribing () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseSelfDescribing () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
public void setMatchersToBePrintedVerbosely ( Integer [] toBePrintedVerbosely ) { this . verboseMatchers = Arrays . asList ( toBePrintedVerbosely ) ; }
Integer . . . verboselyPrinted
Integer . . . toBePrintedVerbosely
{ withPrintSettings . add ( ( ( CanPrintArgumentVerbosely ) matcher ) . getSelfDescribingVerbosely () ) ; }
SelfDescribing getSelfDescribingVerbosely ( ) ;
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getSelfDescribingVerbosely () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getSelfDescribingVerbosely () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
ContainsExtraTypeInformation equals = new Equals ( NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , describe ( m . withExtraTypeInfo () ) ) ;
try { verify ( withFinal ) ; fail () ; } catch ( UnfinishedVerificationException e ) {}
public BDDOngoingStubbingImpl ( OngoingStubbing < T > ongoingStubbing ) { this . mockitoOngoingStubbing = ongoingStubbing ; }
Field createInfoField = reflectOnCreateInfo ( methodProxy ) ;
{ return getInterceptor ( mock ) . getMockHandler () ; }
{ Mockito . argThat ( capturingMatcher ) ; return new HandyReturnValues () . returnFor ( clazz ) ; }
ArgumentCaptor < String > captor = ArgumentCaptor . forClass ( String . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < String > argument = ArgumentCaptor . forClass ( String . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < Person > person = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
{ Mockito . argThat ( capturingMatcher ) ; return handyReturnValues . returnFor ( clazz ) ; }
ArgumentCaptor < String > argument = ArgumentCaptor . forClass ( String . class ) ;
newMessage += STRING_CONSTANT + debuggingInfo . getWarnings () + STRING_CONSTANT ;
newMessage += STRING_CONSTANT + debuggingInfo . getWarnings ( false ) + STRING_CONSTANT ;
private String thisStubWasNotUsed ( Invocation i ) { return STRING_CONSTANT + i . getLocation () + STRING_CONSTANT ; }
{ this ( unusedStubs , unstubbedInvocations , false ) ; }
invocationMarker . markVerified ( actualInvocations , wanted ) ;
{ if ( wantedNumberOfInvocations < NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedCount = wantedNumberOfInvocations ; }
private int hashCodeForMock ( Object mock ) { return System . identityHashCode ( mock ) ; }
{ return ( MockHandler ) getInterceptor ( mock ) . getMockHandler () ; }
for ( T m : mocks ) { mockUtil . resetMock ( m ) ; }
public static boolean isToString ( InvocationOnMock invocation ) { return ObjectMethodsGuru . isToString ( invocation . getMethod () ) ; }
if ( ObjectMethodsGuru . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
objectMethodsGuru . isEqualsMethod ( method )
MethodInterceptorFilter newFilter = new MethodInterceptorFilter ( newMockHandler ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHandler ) ;
if ( objectMethodsGuru . isHashCodeMethod ( method ) ) { return hashCodeForMock ( proxy ) ; }
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
public static boolean isToString ( InvocationOnMock invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
marker . markVerified ( chunk . get ( NUMBER_CONSTANT ) , wantedMatcher ) ;
{ try { return new ArgumentsComparator () . argumentsMatch ( this , actualArgs ) ; } catch ( Throwable t ) { return false ; } }
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( STRING_CONSTANT ) , capturingMatcher ) ) ;
proxy . setCallbacks ( new Callback [] { interceptor , SerializableNoOp.SERIALIZABLE_INSTANCE } ) ;
{ return methodProxy . getMethodProxy () . invokeSuper ( target , arguments ) ; }
public CGLIBProxyRealMethod ( MockitoMethodProxy methodProxy ) { this . methodProxy = methodProxy ; }
public FilteredCGLIBProxyRealMethod ( MockitoMethodProxy methodProxy ) { this ( new CGLIBProxyRealMethod ( methodProxy ) ) ; }
Any mock = mock ( Any . class , withSettings () . serializable () ) ;
{ return methodProxy . invokeSuper ( target , arguments ) ; }
public MockitoMethod getMethod () { return invocation . getMethod () ; }
MockitoMethod method
MockitoMethod getMethod ( ) ;
Invocation i = new Invocation ( mock , new SerializableMockitoMethod ( method ) , args , sequenceNumber , null ) ;
{ new ObjectOutputStream ( new ByteArrayOutputStream () ) . writeObject ( new MethodInterceptorFilter ( null , null ) ) ; }
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHandler , settings ) ;
assertFalse ( new MockitoMethod ( testBaseToStringMethod ) . equals ( mockMethod ) ) ;
mockMethod = new MockitoMethod ( toStringMethod ) ;
public Class < > getReturnType () { return returnType ; }
MockitoMethod mockitoMethod = new MockitoMethod ( method ) ;
Invocation i = new Invocation ( mock , new MockitoMethod ( method ) , args , sequenceNumber , null ) ;
assertFalse ( new SerializableMethod ( testBaseToStringMethod ) . equals ( mockMethod ) ) ;
mockMethod = new SerializableMethod ( toStringMethod ) ;
public SerializableMethod getMethod () { return invocation . getMethod () ; }
SerializableMethod getMethod ( ) ;
SerializableMethod method
Invocation i = new Invocation ( mock , new SerializableMethod ( method ) , args , sequenceNumber , null ) ;
Method getMethod ( ) ;
public Method getMethod () { return invocation . getMethod () ; }
{ if ( isDeclaredOnInterface () ) { new Reporter () . cannotCallRealMethodOnInterface () ; } return realMethod . invoke ( mock , rawArguments ) ; }
{ if ( invocation . isDeclaredOnInterface () ) { reporter . cannotCallRealMethodOnInterface () ; } }
MockitoMethod method
{ if ( isPrimitiveWrapper ( clazz ) ) { return primitiveWrapperOf ( clazz ) ; } return primitiveValueOrNullFor ( clazz ) ; }
public MethodProxy getMethodProxy () { return methodProxy ; }
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
List < Invocation > allInvocations = ongoingStubbing . getRegisteredInvocations () ;
{ mockitoStubber . getRegisteredInvocations () . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing < T > ( mockitoStubber ) ; }
{ mockitoStubber . getRegisteredInvocations () . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing < T > ( mockitoStubber ) ; }
OngoingStubbingImpl < T > ongoingStubbing = new OngoingStubbingImpl < T > ( mockitoStubber ) ;
public void addAnswer ( Answer answer ) { registeredInvocations . removeLast () ; addAnswer ( answer , false ) ; }
public MockHandler ( MockHandler < T > oldMockHandler ) { this ( oldMockHandler.mockingProgress , oldMockHandler.matchersBinder , oldMockHandler.mockSettings ) ; }
return handler . handle ( invocation ) ;
{ return ( MockHandler ) getInterceptor ( mock ) . getHandler () ; }
MethodInterceptorFilter filter = new MethodInterceptorFilter ( handler , ( MockSettingsImpl ) withSettings () ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( handler , ( MockSettingsImpl ) withSettings () ) ;
Mockito . verify ( handler , never () ) . handle ( any ( Invocation . class ) ) ;
Mockito . verify ( handler , never () ) . handle ( any ( Invocation . class ) ) ;
{ mockingProgress . validateState () ; mockingProgress . resetOngoingStubbing () ; return mockUtil . createMock ( classToMock , ( MockSettingsImpl ) mockSettings ) ; }
public MockName getMockName ( Object mock ) { return getMockHandler ( mock ) . getMockSettings () . getMockName () ; }
MockHandler () { this ( new MockSettingsImpl () ) ; }
{ invocationContainerImpl . addAnswerForVoidMethod ( answer ) ; return this ; }
public VoidMethodStubbable < T > toReturn () { invocationContainerImpl . addAnswerForVoidMethod ( new DoesNothing () ) ; return this ; }
{ invocationContainerImpl . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
{ try { invocationContainerImpl . addAnswer ( new ThrowsException ( null ) ) ; fail () ; } catch ( MockitoException e ) {} }
{ state . stubbingStarted () ; invocationContainerImpl . addAnswer ( new Returns ( STRING_CONSTANT ) ) ; state . validateState () ; }
{ invocationContainerImpl . addAnswer ( new ThrowsException ( new Exception () ) ) ; fail () ; }
{ invocationContainerImpl . addConsecutiveAnswer ( answer ) ; return this ; }
{ invocationContainerImpl . addConsecutiveAnswer ( answer ) ; return this ; }
@ SuppressWarnings ( STRING_CONSTANT ) public void setAnswersForStubbing ( List < Answer > answers ) { invocationContainerImpl . setAnswersForStubbing ( answers ) ; }
{ return new VoidMethodStubbableImpl < T > ( mock , invocationContainerImpl ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl . getInvocations () , null ) ; VerificationModeFactory . noMoreInteractions () . verify ( data ) ; }
this . invocationContainerImpl = new InvocationContainerImpl ( mockingProgress ) ;
if ( i . stubInfo () != null ) { System.out . println ( STRING_CONSTANT + i . stubInfo () . stubbedAt () ) ; }
String printInvocations ( Object . . . mocks ) ;
{ return MOCKITO_CORE . mock ( classToMock , mockSettings ) ; }
int varargs ( String . . . string ) ;
int varargs ( Object . . . object ) ;
List < Invocation > allInvocations = new AllInvocationsFinder () . find ( mocksToBeVerifiedInOrder ) ;
List < Invocation > invocations = finder . find ( asList ( mockOne , mockOne , mockOne ) ) ;
List < Invocation > invocations = finder . find ( asList ( mockOne , mockTwo ) ) ;
public void log ( Object what ) { System.out . print ( what . toString () ) ; }
public void stubbingCompleted ( Invocation invocation ) { stubbingInProgress = null ; }
for ( InvocationMatcher i : allInvocations ) { findingsListener . foundUnstubbed ( i ) ; }
verify ( listener , only () ) . foundUnstubbed ( unstubbedInvocation ) ;
void foundUnstubbed ( InvocationMatcher unstubbed ) ;
{ this ( new ConsoleMockitoLogger () , new RunnerFactory () . create ( klass ) ) ; }
@ Before public void cleanStackTraces () { super . makeStackTracesClean () ; }
public MockUtil ( MockCreationValidator creationValidator ) { this . creationValidator = creationValidator ; }
private boolean isEmpty ( String warnings ) { return warnings == null || STRING_CONSTANT . equals ( warnings ) ; }
SimpleTestCase test = new SimpleTestCase () ;
SimpleTestCase test = new SimpleTestCase () ;
@ Test ( expected = ArgumentsAreDifferent . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
if ( instance == null ) { throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
String log = NewMockito . debug () . printInvocations ( mock , mockTwo ) ;
String log = NewMockito . debug () . printInvocations ( mock , mockTwo ) ;
String log = NewMockito . debug () . printInvocations ( mock , mockTwo ) ;
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMocks Object iAmNull = null ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMocks @ Captor ArgumentCaptor captor ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMocks @ Mock List mock ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMocks @ Spy List mock ; } ) ; }
null != field . getAnnotation ( InjectMocks . class )
if ( field . isAnnotationPresent ( annotation ) ) { new Reporter () . unsupportedCombinationOfAnnotations ( annotation . getSimpleName () , InjectMocks . class . getSimpleName () ) ; }
field . isAnnotationPresent ( InjectMocks . class )
{ checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ; fail () ; }
{ checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ; }
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
return mockitoCore . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , this ) ) ;
if ( invocation . isVoid () ) { reporter . cannotStubVoidMethodWithAReturnValue ( invocation . getMethod () . getName () ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
{ try { Thread . sleep ( sleep ) ; } catch ( InterruptedException ie ) {} }
try { t . verify ( data ) ; fail () ; } catch ( MockitoAssertionError e ) {}
public InvocationMatcher getWanted () { return wanted ; }
public InOrderContext getOrderingContext () { return inOrder ; }
{ throw new MockitoException ( join ( STRING_CONSTANT + methodName + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnFor ( clazz ) ; }
Object instance = new FieldInitializer ( testClass , field ) . initialize () ;
{ throw new MockitoException ( STRING_CONSTANT + field . getType () . getSimpleName () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getType () . getSimpleName () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getType () . getSimpleName () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getType () . getSimpleName () + STRING_CONSTANT ) ; }
NestedClassWithNoArgConstructor ( String f ) {}
if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify ( mock . getClass () ) ; }
validateMostStuff () ;
new ObjectMethodsGuru () . isToString ( invocation . getMethod () )
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + formatMethodCall () + STRING_CONSTANT ; }
new Reporter () . smartNullPointerException ( invocation . toString () , location ) ;
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + invocation . toString () ; }
null != field . getAnnotation ( org.mockito.MockitoAnnotations.Mock . class )
final Object testClass
int index = filter . accept ( actualMethod , actualMethods ) ;
notifyAllInvocationListener ( invocation ) ;
MockHandler < > handler
{ given ( handler . getMockSettings () . getDefaultAnswer () ) . willReturn ( SOME_ANSWER ) ; stubOrdinaryInvocationWithInvocationMatcher ( handler , null ) ; }
doThrow ( SOME_EXCEPTION ) . when ( throwingListener )
public OngoingMockInjection tryPropertyOrFieldInjection () { injectionStrategies . thenTry ( new PropertyAndSetterInjection () ) ; return this ; }
public OngoingMockInjection tryConstructorInjection () { injectionStrategies . thenTry ( new ConstructorInjection () ) ; return this ; }
{ return nextStrategy != null && nextStrategy . process ( field , fieldOwner , mockCandidates ) ; }
{ assert wasAccessible != null : STRING_CONSTANT ; try { accessibleObject . setAccessible ( wasAccessible ) ; } catch ( Throwable t ) {} }
VerifiableInvocationsFinder finder = new VerifiableInvocationsFinder () ;
{ for ( InvocationListener listener : mockSettings . getInvocationListeners () ) { notifyListenerOfInvocationWithException ( invocation , exception , listener ) ; } }
{ for ( InvocationListener listener : mockSettings . getInvocationListeners () ) { notifyListenerOfInvocationWithReturnValue ( invocation , returnValue , listener ) ; } }
given ( handler . getMockSettings () . getInvocationListeners () ) . willReturn ( Arrays . asList ( listener ) ) ;
@ Test ( expected = MockitoException . class ) public void shouldThrowCorrectExceptionForNullInvocationListener ( ) throws Exception { new Reporter () . invocationListenerDoesNotAcceptNullParameters () ; }
Foo foo = mock ( Foo . class , withSettings () . invocationListeners ( listener1 ) . invocationListeners ( listener2 ) ) ;
Foo foo = mock ( Foo . class , withSettings () . invocationListeners ( listener ) ) ;
Foo foo = mock ( Foo . class , withSettings () . invocationListeners ( listener1 ) . invocationListeners ( listener2 ) ) ;
Foo foo = mock ( Foo . class , withSettings () . invocationListeners ( listener ) ) ;
{ assertFalse ( mockSettingsImpl . hasInvocationListeners () ) ; mockSettingsImpl . verboseLogging () ; assertContainsType ( mockSettingsImpl . getInvocationListeners () , VerboseMockInvocationLogger . class ) ; }
MethodInvocationReport mcr
public void invocationListenersRequiresAtLeastOneListener () { throw new MockitoException ( STRING_CONSTANT ) ; }
public void invocationListenerDoesNotAcceptNullParameters () { throw new MockitoException ( STRING_CONSTANT ) ; }
{ notifier . handle ( invocation ) ; fail () ; }
{ notifier . handle ( invocation ) ; fail () ; }
{ mockSettingsImpl . invocationListeners ( invocationListener , null ) ; fail () ; }
{ mockSettingsImpl . invocationListeners () ; fail () ; }
{ mapOngoingStubbing . thenReturn ( STRING_CONSTANT ) ; fail () ; }
{ super ( new URL [] { obtainClassPath () , obtainClassPath ( STRING_CONSTANT ) } , parentClassLoader ) ; this . reloadClassPredicate = reloadClassPredicate ; }
{ super ( new URL [] { obtainClassPath () , obtainClassPath ( STRING_CONSTANT ) } ) ; this . reloadClassPredicate = reloadClassPredicate ; }
return report . fieldWasInitializedUsingContructorArgs () ;
mocks . addAll ( scanAndPrepareMocks ( testClassInstance , clazz ) ) ;
@ Test public void inject_mocks_even_in_declared_spy ( ) throws Exception { assertNotNull ( spiedReceiver.oldAntenna ) ; assertNotNull ( spiedReceiver.tuner ) ; }
new InjectMocksScanner ( clazz ) . addTo ( mockDependentFields ) ;
{ return ( MockHandlerInterface ) mockMaker . getHandler ( mock ) ; }
String canThrowException ( ) throws CharacterCodingException ;
MockSettingsInfo mockSettings
MockSettingsInfo settings
MockSettingsInfo settings
MockSettingsInfo settings
public void setTheField ( final File theField ) { theFieldSetterWasUsed = true ; this . theField = theField ; }
Class configClass ;
private void misplaced_anyBoolean_argument_matcher () { anyBoolean () ; }
private void misplaced_anyInt_argument_matcher () { anyInt () ; }
private void misplaced_anyObject_argument_matcher () { anyObject () ; }
List < LocalizedMatcher > pullLocalizedMatchers ( ) ;
Set < Object > mocks = newMockSafeHashSet () ;
Set < Object > mocks = newMockSafeHashSet () ;
{ this . delegatedInstance = delegatedInstance ; return defaultAnswer ( new ForwardsInvocations ( this . delegatedInstance ) ) ; }
public int getSequenceNumber () { return sequenceNumber ; }
int expectedMatchersSize = invocation . getArguments () . length ;
if ( this . getMethod () . getDeclaringClass () . isInterface () ) { new Reporter () . cannotCallRealMethodOnInterface () ; }
List matchers = Invocation . argumentsToMatchers ( i . getArguments () ) ;
public String toString () { return new PrintSettings () . print ( matchers , invocation ) ; }
{ this . matchers = Invocation . argumentsToMatchers ( invocation . getArguments () ) ; }
{ this . matchers = ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) ; }
public String print ( Invocation invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
public String toString () { return new PrintSettings () . print ( ArgumentsProcessor . argumentsToMatchers ( getArguments () ) , this ) ; }
this . arguments = ArgumentsProcessor . expandVarArgs ( mockitoMethod . isVarArgs () , args ) ;
List matchers = ArgumentsProcessor . argumentsToMatchers ( i . getArguments () ) ;
throw new NoInteractionsWanted ( join ( STRING_CONSTANT , new LocationImpl () , STRING_CONSTANT , undesired . getLocation () , scenario ) ) ;
LocationImpl lastActualLocation
LocationImpl lastActualLocation
LocationImpl firstUndesired
LocationImpl firstUndesired
join ( STRING_CONSTANT , STRING_CONSTANT , wanted . toString () , new LocationImpl () , STRING_CONSTANT , previous . toString () , previous . getLocation () , STRING_CONSTANT )
new LocationImpl ()
LocationImpl location
LocationImpl location
public Localized ( T object ) { this . object = object ; location = new LocationImpl () ; }
LocationImpl lastLocation = finder . getLastLocation ( chunk ) ;
LocationImpl actualLocation
public LocationImpl getLocation () { return invocation . getLocation () ; }
LocationImpl last = finder . getLastLocation ( invocations ) ;
this . location = new LocationImpl () ;
String loc = new LocationImpl ( filterReturningEmptyArray ) . toString () ;
LocationImpl lastLocation = null ;
{ this . actualMatcher = actualMatcher ; this . location = new LocationImpl () ; }
LocationImpl lastLocation = finder . getLastLocation ( actualInvocations ) ;
LocationImpl actualLocation
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl lastActualLocation
{ LocationImpl location = verificationMode . getLocation () ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; }
if ( stubbingInProgress != null ) { LocationImpl temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; }
invocation . markStubbed ( new StubInfoImpl ( stubbedInvocation ) ) ;
{ out += line ( STRING_CONSTANT + i . stubInfo () . stubbedAt () . toString () ) ; }
{ s . markStubUsed ( invocation ) ; invocation . markStubbed ( new StubInfoImpl ( s ) ) ; return s ; }
isMultiline () || ( ! matchers . isEmpty () && invocationString . length () > MAX_LINE_LENGTH )
public void stubbingCompleted ( InvocationImpl invocation ) { threadSafely () . stubbingCompleted ( invocation ) ; }
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl undesired
InvocationImpl undesired
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation
Mockito . verify ( handler , never () ) . handle ( any ( InvocationImpl . class ) ) ;
Mockito . verify ( handler , never () ) . handle ( any ( InvocationImpl . class ) ) ;
public void foundUnusedStub ( InvocationImpl unused ) { logger . log ( STRING_CONSTANT + unused . getLocation () + STRING_CONSTANT ) ; }
InvocationImpl unused
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
public void markVerified ( InvocationImpl i ) { verified . add ( i ) ; }
public boolean isVerified ( InvocationImpl invocation ) { return verified . contains ( invocation ) ; }
List < InvocationImpl > getAllInvocations ( ) ;
InvocationImpl invocationOnInterface = new InvocationBuilder () . toInvocation () ;
List < InvocationImpl > unusedStubs
InvocationImpl actual
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl previous = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
assertNull ( finder . getLastLocation ( Collections . < InvocationImpl > emptyList () ) ) ;
InvocationImpl invocationOnClass = getLastInvocation () ;
InvocationImpl i
InvocationImpl candidate
InvocationImpl candidate
InvocationImpl actual
public InvocationImpl getInvocation () { return this . invocation ; }
public InvocationMatcher ( InvocationImpl invocation ) { this ( invocation , Collections . < Matcher > emptyList () ) ; }
InvocationImpl invocation
WarningsFinder finder = new WarningsFinder ( Arrays . < InvocationImpl > asList () , Arrays . < InvocationMatcher > asList ( unstubbedInvocation ) ) ;
public boolean isOut ( InvocationImpl invocation ) { return ! orderingContext . isVerified ( invocation ) ; }
public boolean isOut ( InvocationImpl invocation ) { return ! wanted . matches ( invocation ) ; }
public boolean isOut ( InvocationImpl invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
public void add ( InvocationImpl invocation ) { invocations . add ( invocation ) ; }
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
public ExposedInvocation ( InvocationImpl toBeExposed ) { methodProxy = ( ( HasCGLIBMethodProxy ) toBeExposed.realMethod ) . getMethodProxy () ; }
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation
List < InvocationImpl > getAllInvocations ( ) ;
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocation
public void markVerified ( InvocationImpl i ) { inOrderContext . markVerified ( i ) ; }
public boolean isVerified ( InvocationImpl i ) { return inOrderContext . isVerified ( i ) ; }
List < InvocationImpl > getInvocations ( ) ;
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocation
List < InvocationImpl > allInvocations
InvocationImpl invocation
given ( handler.invocationContainerImpl . findAnswerFor ( any ( InvocationImpl . class ) ) ) . willReturn ( value ) ;
InvocationImpl previous = new InvocationBuilder () . toInvocation () ;
InvocationImpl actual = new InvocationBuilder () . toInvocation () ;
public String print ( InvocationImpl invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
InvocationImpl invocation
InvocationImpl invocation
Object answerTo ( InvocationImpl invocation ) throws Throwable { return findAnswerFor ( invocation ) . answer ( invocation ) ; }
InvocationImpl invocation = invocationForStubbing . getInvocation () ;
InvocationImpl actualInvocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl actual
InvocationImpl actual
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocation
List < InvocationImpl > unusedStubs
List < InvocationImpl > unusedStubs
InvocationImpl nullDereference
InvocationImpl compareTo = this . getLastInvocation () ;
public MethodInfo ( Invocation theInvocation ) { this . method = theInvocation . getMethod () ; }
Invocation theInvocation
Invocation compareTo = this . getLastInvocation () ;
List < Invocation > allInvocations
Invocation previous = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
Invocation actual = new InvocationBuilder () . toInvocation () ;
List < Invocation > getAllInvocations ( ) ;
List < Invocation > getAllInvocations ( ) ;
public String print ( Invocation invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
Invocation invocation
Invocation i
Invocation candidate
Invocation candidate
Invocation actual
public Invocation getInvocation () { return this . invocation ; }
public InvocationMatcher ( Invocation invocation ) { this ( invocation , Collections . < Matcher > emptyList () ) ; }
Invocation invocation
List < Invocation > invocations
Invocation i = new InvocationBuilder () . toInvocation () ;
public void stubbingCompleted ( Invocation invocation ) { threadSafely () . stubbingCompleted ( invocation ) ; }
public void markVerified ( Invocation i ) { inOrderContext . markVerified ( i ) ; }
public boolean isVerified ( Invocation i ) { return inOrderContext . isVerified ( i ) ; }
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
public void foundUnusedStub ( Invocation unused ) { logger . log ( STRING_CONSTANT + unused . getLocation () + STRING_CONSTANT ) ; }
Invocation unused
List < Invocation > getInvocations ( ) ;
Invocation invocation
Invocation invocation
Invocation invocationOnInterface = new InvocationBuilder () . toInvocation () ;
Invocation actual
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation invocation
Invocation invocation = new InvocationBuilder () . toInvocation () ;
List < Invocation > unusedStubs
{ public InvocationMatcher bindMatchers ( ArgumentMatcherStorage argumentMatcherStorage , Invocation invocation ) { throw new InvalidUseOfMatchersException () ; } }
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
public boolean isOut ( Invocation invocation ) { return ! orderingContext . isVerified ( invocation ) ; }
public boolean isOut ( Invocation invocation ) { return ! wanted . matches ( invocation ) ; }
Invocation undesired
Invocation undesired
List < Invocation > chunk
Invocation invocation
List < Invocation > unusedStubs
List < Invocation > unusedStubs
Invocation invocationOnClass = getLastInvocation () ;
public boolean isOut ( Invocation invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
public void add ( Invocation invocation ) { invocations . add ( invocation ) ; }
public void markVerified ( Invocation i ) { verified . add ( i ) ; }
public boolean isVerified ( Invocation invocation ) { return verified . contains ( invocation ) ; }
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation
Invocation actualInvocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = invocationForStubbing . getInvocation () ;
Invocation actual
Invocation actual
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
public Location getLocation () { return invocation . getLocation () ; }
Location lastLocation = finder . getLastLocation ( chunk ) ;
Location lastLocation = null ;
Location actualLocation
{ Location location = verificationMode . getLocation () ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; }
if ( stubbingInProgress != null ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; }
Location firstUndesired
Location firstUndesired
Location lastActualLocation
Location lastLocation = finder . getLastLocation ( actualInvocations ) ;
Location location
Location lastActualLocation
Location lastActualLocation
Location lastActualInvocation
Location firstUndesired
Location firstUndesired
Location firstUndesired
Location firstUndesired
Location actualLocation
Location location
Location location
Location last = finder . getLastLocation ( invocations ) ;
Location actualLocation
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation
Invocation invocation
for ( Invocation i : unusedStubs ) { findingsListener . foundUnusedStub ( i ) ; }
Invocation invocation
Invocation invocation
Invocation invocation
Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
Invocation invocation
Object answerTo ( Invocation invocation ) throws Throwable { return findAnswerFor ( invocation ) . answer ( invocation ) ; }
Invocation nullDereference
Invocation invocation
Invocation previous = new InvocationBuilder () . toInvocation () ;
Invocation invocation
{ markVerified ( chunk , wanted ) ; for ( Invocation i : chunk ) { context . markVerified ( i ) ; } }
Invocation invocation
return new LinkedList < Invocation > ( invocationsInOrder ) ;
assertNull ( finder . getLastLocation ( Collections . < Invocation > emptyList () ) ) ;
synchronized ( invocations ) { copiedList = new LinkedList < Invocation > ( invocations ) ; }
WarningsFinder finder = new WarningsFinder ( Arrays . < Invocation > asList ( stub ) , Arrays . < InvocationMatcher > asList ( wrongArg ) ) ;
WarningsFinder finder = new WarningsFinder ( Arrays . < Invocation > asList () , Arrays . < InvocationMatcher > asList ( unstubbedInvocation ) ) ;
{ new Reporter () . tooLittleActualInvocations ( new org.mockito.internal.reporting.Discrepancy ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new InvocationBuilder () . toInvocation () , null ) ; }
org.mockito.internal.reporting.Discrepancy discrepancy
org.mockito.internal.reporting.Discrepancy discrepancy
org.mockito.internal.reporting.Discrepancy discrepancy
org.mockito.internal.reporting.Discrepancy discrepancy
STRING_CONSTANT + pluralize ( wantedCount ) + STRING_CONSTANT
@ Override public void wantedButNotInvoked ( DescribedInvocation wanted ) { this . wanted = wanted ; }
DescribedInvocation invocation
public StubInfoImpl ( DescribedInvocation stubbedAt ) { this . stubbedAt = stubbedAt ; }
public void markStubUsed ( DescribedInvocation usedAt ) { this . usedAt = usedAt ; }
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
public void wantedButNotInvoked ( DescribedInvocation wanted ) { throw new WantedButNotInvoked ( createWantedButNotInvokedMessage ( wanted ) ) ; }
{ return new DefaultMockingDetails ( toInspect , new MockUtil () ) ; }
Invocation invocationOnClass = new MockitoCore () . getLastInvocation () ;
InvocationImplTest . class
Mock annotation
{ return ( Answer < T > ) new ReturnsArgumentAt ( position ) ; }
new ReturnsArgumentAt ( NUMBER_CONSTANT )
{ validator . validate ( new ReturnsArgumentAt ( ReturnsArgumentAt.LAST_ARGUMENT ) , new InvocationBuilder () . simpleMethod () . toInvocation () ) ; fail () ; }
validator . validate ( new ReturnsArgumentAt ( NUMBER_CONSTANT ) , new InvocationBuilder () . method ( STRING_CONSTANT ) . arg ( STRING_CONSTANT ) . toInvocation () ) ;
{ ( ( Factory ) mock ) . setCallback ( NUMBER_CONSTANT , new MethodInterceptorFilter ( cast ( newHandler ) , settings ) ) ; }
MockHandlerInterface handler
InvocationNotifierHandler oldHandler = ( InvocationNotifierHandler ) getMockHandler ( mock ) ;
Set < Class > extraInterfaces
public MockSettingsInfo getMockSettings () { return mockHandler . getMockSettings () ; }
MockSettingsInfo settings
Set < Class > extraInterfaces
if ( isMockOrSpy ( instance ) ) { mockUtil . maybeRedefineMockName ( instance , field . getName () ) ; return instance ; }
MockSettingsInfo settings = oldHandler . getMockSettings () ;
mockUtil . maybeRedefineMockName ( mock , STRING_CONSTANT ) ;
mockUtil . maybeRedefineMockName ( mock , STRING_CONSTANT ) ;
public void validateExtraInterfaces ( Class classToMock , Collection < Class > interfaces ) { extraInterfacesValidated = true ; }
MockSettingsInfo mockSettings
@ SuppressWarnings ( STRING_CONSTANT ) MockHandler < > handler = new MockHandler ( new MockSettingsImpl () ) ;
T mock = mockUtil . createMock ( classToMock , mockSettings ) ;
Collection < Class > extraInterfaces
name . isDefault ()
{ this . mockName = toInstanceName ( classToMock ) ; this . defaultName = true ; }
{ if ( getMockName ( mock ) . isDefault () ) { getMockHandler ( mock ) . getMockSettings () . redefineMockName ( newName ) ; } }
IMethods methods = mock ( IMethods . class , delegatesTo ( new MethodsImpl () ) ) ;
List < String > mockedList = mock ( List . class , delegatesTo ( delegatedList ) ) ;
List < String > mock = mock ( List . class , delegatesTo ( delegatedList ) ) ;
List < String > mock = mock ( List . class , delegatesTo ( delegatedList ) ) ;
MockCreationSettings settings = oldHandler . getMockSettings () ;
MockCreationSettings mockSettings
public MockCreationSettings getMockSettings () { return mockHandler . getMockSettings () ; }
MockCreationSettings settings
MockCreationSettings settings
MockCreationSettings settings
MockCreationSettings mockSettings
{ mockingProgress . setListener ( null ) ; mockingProgress . mockingStarted ( null , null ) ; }
mockingProgress . mockingStarted ( mock , typeToMock ) ;
MockHandlerImpl < T > mockHandler
MockHandlerImplTest . class
newHandler = new InvocationNotifierHandler < T > ( new MockHandlerImpl < T > ( settings ) , settings )
InternalMockHandler mockitoHandler = cast ( handler ) ;
InternalMockHandler handler
MockHandler newHandler
MockHandler handler
MockHandler newHandler
given ( iMethods . varargsObject ( eq ( NUMBER_CONSTANT ) , anyVararg () ) ) . will ( returnsArgAt ( NUMBER_CONSTANT ) ) ;
InternalMockHandler < T > mockHandler
{ return Primitives . primitiveValueOrNullFor ( type ) ; }
result = NUMBER_CONSTANT * result + ( clazz != null ? clazz . hashCode () : NUMBER_CONSTANT ) ;
registerTypeParametersOn ( clazz . getTypeParameters () ) ;
return typeVariable . equals ( ( ( TypeVarBoundedType ) o ) . typeVariable ) ;
< O extends K > O typeVar_with_type_params ( ) ;
< S , T extends S > T two_type_params ( ) ;
List < ? super Integer > returning_wildcard_with_class_lower_bound ( ) ;
public void setMockitoGenericMetadata ( GenericMetadataSupport mockitoGenericMetadata ) { this . mockitoGenericMetadata = mockitoGenericMetadata ; }
public MockSettings parameterizedInfo ( GenericMetadataSupport mockitoGenericMetadata ) { this . mockitoGenericMetadata = mockitoGenericMetadata ; return this ; }
GenericMetadataSupport returnTypeGenericMetadata
{ VerificationDataImpl data = createVerificationData ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
this . invocationContainerImpl = new InvocationContainerImpl ( mockingProgress , mockSettings ) ;
RegisteredInvocationsAllTest . class
DefaultRegisteredInvocationsTest . class
{ return mockSettings . isStubOnly () ? new RegisteredInvocationsStubOnly () : new DefaultRegisteredInvocations () ; }
{ return mockSettings . isStubOnly () ? new SingleRegisteredInvocation () : new DefaultRegisteredInvocations () ; }
catch ( CannotVerifyStubOnlyMock e ) {}
@ After public void yes_I_know_some_matchers_are_misplaced () { resetState () ; }
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingOnPurposeBecauseWrongStubbingSyntaxInConfigurationMethod . class ) ;
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingOnPurposeBecauseIncorrectStubbingSyntax . class ) ;
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingOnPurposeBecauseIncorrectAnnotationUsage . class ) ;
{ if ( mockitoGenericMetadata == null ) { this . mockitoGenericMetadata = GenericMetadataSupport . inferFrom ( typeToMock ) ; } return mockitoGenericMetadata ; }
GenericMetadataSupport genericMetadata = inferFrom ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = inferFrom ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = inferFrom ( StringBuilder . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , StringBuilder . class ) ) ;
GenericMetadataSupport genericMetadata = inferFrom ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = inferFrom ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
return recordDeepStubMock ( createNewDeepStubMock ( returnTypeGenericMetadata ) , container ) ;
static MockMaker findPlatformMockMaker () { return findPluginImplementation ( MockMaker . class , DEFAULT_MOCK_MAKER_CLASS ) ; }
if ( ! mockitoCore . isTypeMockable ( clazz ) ) { return null ; }
{ if ( ! mockUtil . isTypeMockable ( classToMock ) ) { new Reporter () . cannotMockFinalClass ( classToMock ) ; } }
{ return mockitoCore . mock ( returnTypeGenericMetadata . rawType () , withSettingsUsing ( returnTypeGenericMetadata ) ) ; }
if ( ! mockitoCore . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; }
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + pluginType , e ) ; }
SerializableAndNoDefaultConstructor ( Observable o ) { super(); }
MockCreationSettings mockSettings = new MockUtil () . getMockSettings ( mockitoMock ) ;
public boolean isSpy ( Object mock ) { return mock instanceof MockitoSpy ; }
{ if ( mockUtil . isMock ( cl ) ) { return STRING_CONSTANT ; } else { return STRING_CONSTANT ; } }
{ return ! MOCKITO_PROXY_MARKER . equals ( marker ) ; }
public boolean isMock ( Object mock ) { return mock instanceof MockitoMock && isMockitoMock ( mock ) ; }
public boolean isSpy ( Object mock ) { return mock instanceof MockitoSpy ; }
public boolean isMock ( Object mock ) { return mock instanceof MockitoMock && isMockitoMock ( mock ) ; }
catch ( ObjectStreamException e ) { Assertions . assertThat ( e . toString () ) . contains ( STRING_CONSTANT ) ; }
{ SimpleSerializationUtil . serializeAndBack ( mockWithPrivateConstructor ) ; fail ( STRING_CONSTANT ) ; }
AClassToBeMockedInThisTestOnlyAndInCallablesOnly mock = Mockito . mock ( AClassToBeMockedInThisTestOnlyAndInCallablesOnly . class , Mockito . withSettings () . serializable ( SerializableMode.ACROSS_CLASSLOADERS ) ) ;
this . serializableMode = copy.serializableMode ;
{ if ( AcrossJVMMockitoMockSerializable . class . isAssignableFrom ( cl ) ) { return MOCKITO_PROXY_MARKER ; } else { return NOTHING ; } }
public boolean isMock ( Object mock ) { return isMockitoMock ( mock ) ; }
verify ( mock , timeout ( NUMBER_CONSTANT ) . atLeast ( NUMBER_CONSTANT ) ) . clear () ;
public VerificationMode never () { new Reporter () . atMostAndNeverShouldNotBeUsedWithTimeout () ; return null ; }
{ new Reporter () . atMostAndNeverShouldNotBeUsedWithTimeout () ; return null ; }
verify ( target , timeout ( TEST_TIMEOUT_MILLIS * NUMBER_CONSTANT ) . times ( TIMES * nThreads ) ) . targetMethod ( STRING_CONSTANT ) ;
public int getPollingPeriod () { return pollingPeriod ; }
{ return new After ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDelay () , verificationMode ) ; }
{ return new Timeout ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDuration () , newVerificationMode ) ; }
{ super ( new VerificationOverTimeImpl ( pollingPeriod , millis , delegate , true ) ) ; }
{ return new After ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDuration () , verificationMode ) ; }
{ super ( new VerificationOverTimeImpl ( pollingPeriod , delayMillis , verificationMode , false ) ) ; }
assertEquals ( expectedTimeout , ( ( Timeout ) t ) . wrappedVerification . getDuration () ) ;
{ if ( canRecoverFromFailure ( delegate ) ) { error = e ; sleep ( pollingPeriodMillis ) ; } else { throw e ; } }
ClassLoader cl = isolatedClassLoader () . withCurrentCodeSourceUrls () . withPrivateCopyOf ( CLASS_NAME_USING_INTERFACE ) . withPrivateCopyOf ( INTERFACE_NAME ) . build () ;
{ cl . loadClass ( STRING_CONSTANT ) ; fail () ; }
{ cl . loadClass ( CLASS_NAME_USING_INTERFACE ) ; fail () ; }
{ cl . loadClass ( CLASS_NAME_USING_INTERFACE ) ; fail () ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = new SerializableTypeVariable ( typeVariable ) ; }
{ Type actualType = getActualTypeArgumentFor ( typeParameter ) ; actualTypeArguments . put ( new SerializableTypeVariable ( typeParameter ) , actualType ) ; }
return new SerializableBoundedType ( wildCardBoundedType ) ;
return new SerializableBoundedType ( new TypeVarBoundedType ( typeParameter ) ) ;
{ for ( TypeVariable typeParameter : typeParameters ) { contextualActualTypeParameters . put ( new SerializableTypeVariable ( typeParameter ) , boundsOf ( typeParameter ) ) ; } }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = typeVariable ; }
{ Type actualType = getActualTypeArgumentFor ( typeParameter ) ; actualTypeArguments . put ( typeParameter , actualType ) ; }
return wildCardBoundedType ;
return new TypeVarBoundedType ( typeParameter ) ;
{ return mockitoCore () . mock ( returnTypeGenericMetadata . rawType () , withSettingsUsing ( returnTypeGenericMetadata ) ) ; }
private ReturnsDeepStubs returnsDeepStubsAnswerUsing ( final GenericMetadataSupport returnTypeGenericMetadata ) { return new ReturnsDeepStubsSerializationFallback ( returnTypeGenericMetadata ) ; }
return deepStub ( invocation , returnTypeGenericMetadata ) ;
{ return Mockito . verify ( mock , mode ) ; }
public T should () { return Mockito . verify ( mock ) ; }
{ return verify ( mock , mode ) ; }
public T should () { return verify ( mock ) ; }
{ if ( ! isEquals ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }
{ if ( ! isEquals ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }
if ( ! isEquals ) { return this ; }
{ return ( T ) PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES . get ( primitiveOrWrapperType ) ; }
{ return PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES . containsKey ( type ) ; }
{ if ( clazz . isPrimitive () ) { return clazz ; } return ( Class < T > ) PRIMITIVE_TYPES . get ( clazz ) ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnFalse () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . < T > returnNull () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . < T > returnNull () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnFalse () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . < T > returnNull () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnFalse () ; }
if ( ! CLEANER . isOut ( unfilteredStackTrace . get ( i ) ) ) { continue; }
T
long delayMillis
long millis
long millis
public long getDuration () { return durationMillis ; }
public long getPollingPeriod () { return pollingPeriodMillis ; }
long sleep
{ verifyNoMoreInteractions ( ( Object [] ) null ) ; }
{ verifyNoMoreInteractions ( ( Object [] ) null ) ; }
{ inOrder ( ( Object [] ) null ) ; }
String expectedCause = STRING_CONSTANT + STRING_CONSTANT + mock + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
String expectedCause = STRING_CONSTANT + STRING_CONSTANT + mock + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
@ Override public int hashCode () { return method . hashCode () ; }
timer . isUp ( startTime )
this . timer = new Timer ( durationMillis ) ;
when ( timer . isCounting () ) . thenReturn ( true , true , true , true , true , false ) ;
public void reset () { mockingProgress . reset () ; mockingProgress . resetOngoingStubbing () ; }
when ( clazzMock . isValid () ) . thenReturn ( true ) ;
catch ( CannotStubVoidMethodWithReturnValue e ) { Assertions . assertThat ( e . getMessage () ) . contains ( MockitoLimitations.NON_PUBLIC_PARENT ) ; }
{ return type == null ? STRING_CONSTANT : STRING_CONSTANT + type . getCanonicalName () + STRING_CONSTANT + type . getClassLoader () + STRING_CONSTANT ; }
ClassImposterizer imposterizer = new ClassImposterizer ( new CachingObjenesisInstantiator () ) ;
return new ClassImposterizer ( new CachingObjenesisInstantiator () ) . imposterise ( new MethodInterceptorFilter ( mockitoHandler , settings ) , settings . getTypeToMock () , settings . getExtraInterfaces () ) ;
imposterizer = new ClassImposterizer ( new ConstructorInstantiator () ) ;
Factory proxy = instantiator . newInstance ( proxyClass ) ;
STRING_CONSTANT + instantiator . getClass () . getSimpleName ()
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
ClassImposterizer imposterizer = new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () ) ;
new DefaultClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
DefaultClassImposterizerTest . class
CglibClassImposterizerTest . class
new CglibClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
ClassImposterizerTest . class
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
new CGLIBHacker () . setMockitoNamingPolicy ( methodProxy ) ;
{ return getMethodProxy () . invokeSuper ( target , arguments ) ; }
CleanTraceRealMethod realMethod = new CleanTraceRealMethod ( mockitoMethodProxy ) ;
{ sourceJarComparator . setPair ( left , right ) ; }
boolean jars = binaryComparator . areEqual () ;
mock = mock ( List . class , delegatesTo ( new FakeListWithWrongMethods < String > () ) )
mock = mock ( List . class , delegatesTo ( new FakeListWithWrongMethods < String > () ) )
mock = mock ( List . class , delegatesTo ( new FakeList < String > () ) )
mock = mock ( List . class , delegatesTo ( new FakeList < String > () ) )
mock = mock ( List . class , delegatesTo ( new FakeList < String > () ) )
{ return new ArrayList < T > () ; }
{ return new ArrayList < T > () ; }
ZipComparator.Result result = zipComparator . compareFiles () ;
{ zipComparator . setPair ( left , right ) ; }
ClassImposterizer imposterizer = new ClassImposterizer ( new InstantiatorProvider () . getInstantiator ( new CreationSettings () ) ) ;
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator ( settings ) )
{ if ( settings . isUsingConstructor () ) { return new ConstructorInstantiator ( settings . getOuterClassInstance () ) ; } else { return INSTANCE ; } }
imposterizer = new ClassImposterizer ( new ConstructorInstantiator ( null ) ) ;
catch ( InstantationException e ) { assertEquals ( STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
public String toString () { return commits . size () + STRING_CONSTANT + author ; }
{ authorId = commit . getAuthorId () ; author = commit . getAuthor () ; commits . add ( commit ) ; }
public String getAuthorId () { return email ; }
Commit commit
Commit commit
{ return new GitContributionsProvider ( new GitLogProvider ( runner ) ) ; }
{ return new GitContributionsProvider ( new GitLogProvider ( runner ) , new IgnoreCiSkip () ) ; }
DefaultContributionSet contributions = new DefaultContributionSet ( ignoredCommit ) ;
if ( ignoreCommit . isTrue ( commit ) ) { return; }
Map.Entry < String , Contribution > entry
if ( ! m . matches () ) { throw new ReleaseNotesException ( STRING_CONSTANT + releaseNotesContent , null ) ; }
if ( out == null ) { throw new ReleaseNotesException ( STRING_CONSTANT + envVariableName + STRING_CONSTANT , null ) ; }
long id
public GitHubImprovementsProvider ( String authToken ) { this . authToken = authToken ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return Answers.CALLS_REAL_METHODS . get () . answer ( invocation ) ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return Answers.RETURNS_DEFAULTS . get () . answer ( invocation ) ; }
String content = IOUtil . readFully ( response ) ;
catch ( NoSuchMethodException noDefaultConstructor ) { throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + type . getSimpleName () + STRING_CONSTANT ) ; }
{ return new ThenImpl < T > ( mock ) ; }
try { closeable . close () ; } catch ( IOException e ) { throw new MockitoException ( STRING_CONSTANT + closeable , e ) ; }
catch ( IOException e ) { throw new MockitoException ( STRING_CONSTANT + reader , e ) ; }
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + output , e ) ; }
assertEquals ( asList ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , IOUtil . readLines ( new FileInputStream ( file ) ) ) ;
if ( ! pluginSwitch . isEnabled ( pluginClassName ) ) { continue; }
String foundPluginClass = new PluginFinder ( pluginSwitch ) . findPluginClass ( Iterables . toIterable ( resources ) ) ;
LinkedList < ReleaseStep > targets = new LinkedList < ReleaseStep > ( attempted ) ;
{ jUnitRule . apply ( new ExceptionStatement () , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
{ injectTestCase = new InjectTestCase () ; jUnitRule = new JUnitRule () ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return RETURNS_DEFAULTS . answer ( invocation ) ; }
mockSettings . defaultAnswer ( annotation . answer () ) ;
ReleaseStep getStep ( int stepNumber ) ;
return new DefaultGitAuthor ( currentLocalUser , currentLocalEmail , runner ) ;
{ return anyObject () ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnFor ( clazz ) ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnNull () ; }
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public static VersionTool getVersionTool () { return new DefaultVersionTool ( new VersionBumper () ) ; }
long millis
public ClassLoader build () { return new InMemoryClassLoader ( parent , inMemoryClassObjects ) ; }
catch ( AssertionError e ) { error = handleVerifyException ( e ) ; }
if ( paramsMatch ( types , params ) ) { return invokeConstructor ( constructor , params ) ; }
catch ( InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + proxyClass . getSuperclass () . getSimpleName () + STRING_CONSTANT , e ) ; }
int result = mockedType . hashCode () ;
if ( ! mockedType . equals ( mockKey.mockedType ) ) return false ;
Class < T > mockedType
{ return ( Class < ? extends T > ) PREVIOUS_CLASSES . get ( mockKey ) ; }
@ Origin ( cacheMethod = true ) Method method
@ Origin ( cacheMethod = true ) Method method
@ Origin ( cacheMethod = true ) Method method
Class < > proxyClass = new ByteBuddyMockMaker () . getOrMakeMock ( typeToMock , extraInterfaces ) ;
{ return ( Class < ? extends T > ) PREVIOUSLY_GENERATED_MOCK_CLASSES . get ( mockKey ) ; }
PREVIOUSLY_GENERATED_MOCK_CLASSES . put ( mockKey , mockType ) ;
T mock = classInstantiator . instantiate ( mockedType ) ;
if ( ! ( handler instanceof InternalMockHandler ) ) { throw new MockitoException ( join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
Class < > proxyClass = new CachingBytecodeGenerator () . get ( typeToMock , extraInterfaces ) ;
Class < > proxyClass = new CachingMockBytecodeGenerator () . get ( typeToMock , extraInterfaces ) ;
assertThat ( cache ) . hasSize ( NUMBER_CONSTANT ) ;
assertThat ( cachingMockBytecodeGenerator.avoidingClassLeakageCache ) . hasSize ( NUMBER_CONSTANT ) ;
byteBuddy . subclass ( mockedType , ConstructorStrategy.Default.IMITATE_SUPER_TYPE ) . name ( nameFor ( mockedType ) )
{ return thiz . getMockitoInterceptor () . getSerializationSupport () . writeReplace ( thiz ) ; }
{ this . handler = handler ; this . mockCreationSettings = mockCreationSettings ; serializationSupport = new ByteBuddyCrossClassLoaderSerializationSupport () ; }
CachingMockBytecodeGeneratorTest . class
Collections . sort ( unsortedFields , cmp ) ;
Collections . sort ( unsortedFields , cmp ) ;
PropertyAndSetterInjection . sortSuperTypesLast ( unsortedFields ) ;
sortSuperTypesLast ( declaredFields ) ;
ArrayList < Improvement > pagedImprovements = new ArrayList < Improvement > () ;
STRING_CONSTANT + mockMethod + STRING_CONSTANT + safelyGetMockName ( mock )
STRING_CONSTANT + mockMethod + STRING_CONSTANT + safelyGetMockName ( mock )
STRING_CONSTANT + safelyGetMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT
STRING_CONSTANT + safelyGetMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT
@ Before public void setup () { mock = Mockito . mock ( IMethods . class , STRING_CONSTANT ) ; }
try { validator . validate ( new CallsRealMethods () , invocationOnInterface ) ; fail () ; } catch ( MockitoException expected ) {}
catch ( MockitoException expected ) {}
{ try { Thread . sleep ( sleep ) ; } catch ( InterruptedException ie ) { throw new RuntimeException ( STRING_CONSTANT , ie ) ; } }
{ this ( pollingPeriodMillis , delegate , returnOnSuccess , new Timer ( durationMillis ) ) ; }
{ return new After ( wrappedVerification . copyWithVerificationMode ( verificationMode ) ) ; }
{ return new Timeout ( wrappedVerification . copyWithVerificationMode ( newVerificationMode ) ) ; }
{ this ( new VerificationOverTimeImpl ( pollingPeriodMillis , millis , delegate , true ) ) ; }
@ Origin ( cache = true ) Method invokedMethod
@ Origin ( cache = true ) Method invokedMethod
@ Origin ( cache = true ) Method invokedMethod
ArrayList < Improvement > pagedImprovements = new ArrayList < Improvement > () ;
try { argument . getValue () ; fail () ; } catch ( MockitoException e ) { Assert . assertTrue ( true ) ; }
CapturesArgumentsFromInvocation wanted
CapturesArgumentsFromInvocation wanted
CapturesArgumentsFromInvocation wanted
Mockito . verify ( c.invocationMarker ) . markVerified ( eq ( asList ( invocation ) ) , any ( CapturesArgumentsFromInvocation . class ) ) ;
{ injectionOccurred |= injectMockCandidates ( fieldClass , fieldInstanceNeedingInjection , newMockSafeHashSet ( mockCandidates ) ) ; fieldClass = fieldClass . getSuperclass () ; }
{ ( ( MockAccess ) mock ) . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( newHandler ) , settings ) ) ; }
MockAccess mockAccess = ( MockAccess ) mockInstance ;
if ( interceptor == null ) { return superCall . call () ; }
{ return new MatchersPrinter () . print ( m ) . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
{ ContainsTypedDescription equals = new Equals ( NUMBER_CONSTANT ) ; assertFalse ( equals . typeMatches ( null ) ) ; }
{ ContainsTypedDescription equals = new Equals ( null ) ; assertFalse ( equals . typeMatches ( NUMBER_CONSTANT ) ) ; }
ContainsTypedDescription equals = new Equals ( NUMBER_CONSTANT ) ;
{ String descStr = new Equals ( NUMBER_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( describe ( m ) , m . getTypedDescription () ) ; }
ContainsTypedDescription equals10 = new Equals ( NUMBER_CONSTANT ) ;
{ return HamcrestPrinter . print ( m ) . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
Class < > classToMock
Class < > classToMock
Class < > classToMock
Class < > classToMock
the_mock_type = cachingMockBytecodeGenerator . get ( withMockFeatures ( classloader_with_life_shorter_than_cache . loadClass ( STRING_CONSTANT ) , Collections . < Class < > > emptySet () , false ) )
Set < Class < > > extraInterfaces
Set < Class < > > interfaces
Set < Class < > > interfaces
Set < Class < > > interfaces
Set < Class < > > interfaces
Set < Class < > > extraInterfaces
{ byteBuddy = new ByteBuddy () . withDefaultMethodAttributeAppender ( MethodAttributeAppender.ForInstrumentedMethod.INSTANCE ) . withAttribute ( TypeAttributeAppender.ForSuperType.INSTANCE ) ; random = new Random () ; }
MockitoMatcher m
MockitoMatcher m = matchers . get ( position ) ;
List < MockitoMatcher > matchers
MockitoMatcher m
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( m . describe () , m . getTypedDescription () ) ; }
if ( actualMatcher instanceof ContainsTypedDescription ) { return ( ( ContainsTypedDescription ) actualMatcher ) . getTypedDescription () ; } else { return actualMatcher . describe () ; }
MockitoMatcher actualMatcher
List < MockitoMatcher > matchers
{ for ( MockitoMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < MockitoMatcher > matchers ) { this . matchers = matchers ; }
InvocationMatcher invocationWithMatchers = new InvocationMatcher ( invocation , ( List < MockitoMatcher > ) ( List ) lastMatchers ) ;
MockitoMatcher matcher
{ for ( MockitoMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < MockitoMatcher > matchers ) { this . matchers = matchers ; }
private static HandyReturnValues reportMatcher ( MockitoMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
private static HandyReturnValues reportMatcher ( MockitoMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
MockitoMatcher < Double > matcher
MockitoMatcher < Float > matcher
MockitoMatcher < Long > matcher
MockitoMatcher < Integer > matcher
MockitoMatcher < Short > matcher
MockitoMatcher < Byte > matcher
MockitoMatcher < Boolean > matcher
MockitoMatcher < Character > matcher
assertEquals ( name + STRING_CONSTANT , compareTo . describe () ) ;
public Not ( MockitoMatcher first ) { this . first = first ; }
{ String descStr = new Equals ( null ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( CHAR_CONS ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
@ Test public void matchesToString () { assertEquals ( STRING_CONSTANT , new Matches ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void findToString () { assertEquals ( STRING_CONSTANT , new Find ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void containsToString () { assertEquals ( STRING_CONSTANT , new Contains ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void endsWithToString () { assertEquals ( STRING_CONSTANT , new EndsWith ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void startsWithToString () { assertEquals ( STRING_CONSTANT , new StartsWith ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void notToString () { assertEquals ( STRING_CONSTANT , new Not ( new Equals ( NUMBER_CONSTANT ) ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new Equals ( o ) . describe () ) ;
@ Test public void equalsToStringWithChar () { assertEquals ( STRING_CONSTANT , new Equals ( CHAR_CONS ) . describe () ) ; }
@ Test public void equalsToStringWithString () { assertEquals ( STRING_CONSTANT , new Equals ( STRING_CONSTANT ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new Same ( o ) . describe () ) ;
@ Test public void sameToStringWithChar () { assertEquals ( STRING_CONSTANT , new Same ( CHAR_CONS ) . describe () ) ; }
@ Test public void sameToStringWithString () { assertEquals ( STRING_CONSTANT , new Same ( STRING_CONSTANT ) . describe () ) ; }
public String toString () { return STRING_CONSTANT ; }
public String toString () { return STRING_CONSTANT ; }
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( m . toString () , m . toStringWithType () ) ; }
ContainsExtraTypeInfo equals10 = new Equals ( NUMBER_CONSTANT ) ;
{ ContainsExtraTypeInfo equals = new Equals ( NUMBER_CONSTANT ) ; assertFalse ( equals . typeMatches ( null ) ) ; }
{ ContainsExtraTypeInfo equals = new Equals ( null ) ; assertFalse ( equals . typeMatches ( NUMBER_CONSTANT ) ) ; }
ContainsExtraTypeInfo equals = new Equals ( NUMBER_CONSTANT ) ;
{ String descStr = new Equals ( null ) . toString () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . toString () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( CHAR_CONS ) . toString () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . toString () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . toStringWithType () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . toStringWithType () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . toStringWithType () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
Equals matcherWithBadDescription = new Equals ( NUMBER_CONSTANT ) { public String toString () { return STRING_CONSTANT ; } } ;
{ return reportMatcher ( new Find ( regex ) ) . returnNull () ; }
public String toString () { return describe ( wanted ) ; }
assertEquals ( name + STRING_CONSTANT , compareTo . toString () ) ;
@ Test public void matchesToString () { assertEquals ( STRING_CONSTANT , new Matches ( STRING_CONSTANT ) . toString () ) ; }
@ Test public void findToString () { assertEquals ( STRING_CONSTANT , new Find ( STRING_CONSTANT ) . toString () ) ; }
@ Test public void containsToString () { assertEquals ( STRING_CONSTANT , new Contains ( STRING_CONSTANT ) . toString () ) ; }
@ Test public void endsWithToString () { assertEquals ( STRING_CONSTANT , new EndsWith ( STRING_CONSTANT ) . toString () ) ; }
@ Test public void startsWithToString () { assertEquals ( STRING_CONSTANT , new StartsWith ( STRING_CONSTANT ) . toString () ) ; }
assertEquals ( STRING_CONSTANT , new And ( matchers ) . toString () ) ;
@ Test public void notToString () { assertEquals ( STRING_CONSTANT , new Not ( new Equals ( NUMBER_CONSTANT ) ) . toString () ) ; }
assertEquals ( STRING_CONSTANT , new Or ( matchers ) . toString () ) ;
assertEquals ( STRING_CONSTANT , new Equals ( o ) . toString () ) ;
@ Test public void equalsToStringWithChar () { assertEquals ( STRING_CONSTANT , new Equals ( CHAR_CONS ) . toString () ) ; }
@ Test public void equalsToStringWithString () { assertEquals ( STRING_CONSTANT , new Equals ( STRING_CONSTANT ) . toString () ) ; }
assertEquals ( STRING_CONSTANT , new Same ( o ) . toString () ) ;
@ Test public void sameToStringWithChar () { assertEquals ( STRING_CONSTANT , new Same ( CHAR_CONS ) . toString () ) ; }
@ Test public void sameToStringWithString () { assertEquals ( STRING_CONSTANT , new Same ( STRING_CONSTANT ) . toString () ) ; }
{ return m . toString () . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
public String toString () { return STRING_CONSTANT ; }
public String toString () { return STRING_CONSTANT ; }
out . append ( new Equals ( array [ i ] ) . toString () ) ;
public String toString () { return STRING_CONSTANT ; }
public String toString () { return STRING_CONSTANT ; }
{ out . add ( new FormattedText ( MatcherToString . toString ( matcher ) ) ) ; }
{ for ( ArgumentMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
List < ArgumentMatcher > matchers
List < ArgumentMatcher > matchers
ArgumentMatcher m
ArgumentMatcher m
private static HandyReturnValues reportMatcher ( ArgumentMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
ArgumentMatcher < Double > matcher
ArgumentMatcher < Float > matcher
ArgumentMatcher < Long > matcher
ArgumentMatcher < Integer > matcher
ArgumentMatcher < Short > matcher
ArgumentMatcher < Byte > matcher
ArgumentMatcher < Boolean > matcher
ArgumentMatcher < Character > matcher
ArgumentMatcher matcher
ArgumentMatcher m
ArgumentMatcher m = matchers . get ( position ) ;
List < ArgumentMatcher > matchers
private static HandyReturnValues reportMatcher ( ArgumentMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
ArgumentMatcher matcher
ArgumentMatcher matcher
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , Arrays . < ArgumentMatcher > asList ( new Equals ( NUMBER_CONSTANT ) , m ) ) ;
{ for ( ArgumentMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
List < ArgumentMatcher > matchers
public Not ( ArgumentMatcher first ) { this . first = first ; }
@ After public void reset_state () { super . resetState () ; }
{ return MOCKITO_CORE . stubber () . doReturn ( toBeReturned ) ; }
{ return MOCKITO_CORE . stubber () . doNothing () ; }
{ return MOCKITO_CORE . stubber () . doAnswer ( answer ) ; }
{ return MOCKITO_CORE . stubber () . doCallRealMethod () ; }
if ( throwables == null ) { return thenThrow ( ( Throwable ) null ) ; }
Assertions . assertThat ( returnedMock ) . isEqualTo ( expectedMock ) ;
Assertions . assertThat ( dog . bark () ) . isEqualTo ( STRING_CONSTANT ) ;
Assertions . assertThat ( dog . bark () ) . isEqualTo ( STRING_CONSTANT ) ;
public ThrowsExceptionClass ( Class < ? extends Throwable > throwableClass ) { this . throwableClass = checkNonNullThrowable ( throwableClass ) ; }
verify ( mock ) . simpleMethod ( ( Object ) anyObject () ) ;
when ( mock . oneArg ( ( Object ) anyObject () ) ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . oneArg ( ( Object ) anyObject () ) ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . oneArg ( ( Object ) any () ) ) . thenReturn ( STRING_CONSTANT ) ;
Instantiator instantiator = Plugins . getInstantiatorProvider () . getInstantiator ( settings ) ;
byteBuddy = new ByteBuddy () . withDefaultMethodAttributeAppender ( new MethodAttributeAppender.ForInstrumentedMethod ( AnnotationAppender.ValueFilter.AppendDefaults.INSTANCE ) ) . withAttribute ( new TypeAttributeAppender.ForInstrumentedType ( AnnotationAppender.ValueFilter.AppendDefaults.INSTANCE ) ) ;
for ( AllTestsRunner t : threads ) { t . join () ; failed |= t . isFailed () ; }
{ pomComparator = new PomComparator ( left , right ) ; }
ContributionsProvider contributionsProvider = Vcs . getGitProvider ( Exec.INSTANCE . getProcessRunner ( workDir ) ) ;
ContributionsProvider contributionsProvider = Vcs . getGitProvider ( Exec . getProcessRunner ( workDir ) ) ;
public MockBytecodeGenerator () { byteBuddy = new ByteBuddy () . with ( TypeValidation.DISABLED ) ; random = new Random () ; }
runner . addListener ( new TextListener ( DevNull.out ) ) ;
{ return invocation . getMock () == invocation . getArgument ( NUMBER_CONSTANT ) ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
String arg = invocation . getArgument ( NUMBER_CONSTANT ) ;
{ ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgument ( position ) ) ; }
int secondArgument = invocationOnInterface . getArgument ( NUMBER_CONSTANT ) ;
{ validateIndexWithinInvocationRange ( invocation ) ; return invocation . getArgument ( actualArgumentPosition ( invocation ) ) ; }
ImportLogBean bean = invocation . getArgument ( NUMBER_CONSTANT ) ;
{ return invocation . getArgument ( NUMBER_CONSTANT ) ; }
{ return invocation . getArgument ( NUMBER_CONSTANT ) ; }
{ return invocation . getArgument ( NUMBER_CONSTANT ) ; }
runner = new MockitoJUnitRunner ( DummyTest . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
{ try { AdditionalAnswers . returnsElementsOf ( null ) ; fail () ; } catch ( MockitoException e ) {} }
{ this . jUnitRule = new JUnitRule ( new ConsoleMockitoLogger () ) ; }
{ assertEquals ( STRING_CONSTANT , e . getMessage () ) ; assertTrue ( logger . getLoggedInfo () . contains ( STRING_CONSTANT ) ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , listener . getStubbingInfo () ) ;
{ ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgument ( position ) ) ; }
assertTrue ( mock instanceof List ) ;
{ return CoreMatchers . isA ( ( Class ) type ) ; }
assertTrue ( runner instanceof JUnit45AndHigherRunnerImpl ) ;
assertTrue ( runner instanceof JUnit44RunnerImpl ) ;
assertThat ( result ) . isSuccessful () ;
{ return new RunnerProvider () . newInstance ( STRING_CONSTANT , klass ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { filterRequested = true ; runner . filter ( filter ) ; }
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
public void reportOngoingStubbing ( OngoingStubbing iOngoingStubbing ) { threadSafely () . reportOngoingStubbing ( iOngoingStubbing ) ; }
doAnswer ( recordCall ) . when ( mock ) . voidMethod () ;
doThrow ( new RuntimeException () ) . when ( mock ) . clone () ;
doThrow ( new RuntimeException () ) . when ( mock ) . clone () ;
doThrow ( expected ) . when ( mock ) . clear () ;
{ return CoreMatchers . is ( ( Class ) type ) ; }
{ jUnitRule . apply ( new UnfinishedStubbingStatement () , null , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
{ jUnitRule . apply ( new ExceptionStatement () , null , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
jUnitRule . apply ( new DummyStatement () , null , injectTestCase ) . evaluate () ;
{ return new JUnitRule ( new ConsoleMockitoLogger () ) ; }
VerificationCollectorImpl () { this . resetBuilder () ; }
verify ( methods ) . simpleMethod () ;
{ IMethods methods = mock ( IMethods . class ) ; verify ( methods ) . simpleMethod () ; }
MockHandler newHandler = createMockHandler ( settings ) ;
MockHandler mockHandler = createMockHandler ( settings ) ;
{ setField ( testClass , field , mock ) ; }
setField ( descInstance , classNameField , proxyClass . getCanonicalName () ) ;
{ setField ( instance , field , value ) ; }
{ setField ( testInstance , field , mock ) ; }
setField ( testClass , field , newFieldInstance ) ;
setField ( testClass , field , newFieldInstance ) ;
if ( ! new BeanPropertySetter ( injectee , candidateFieldToBeInjected ) . set ( matchingMock ) ) { setField ( injectee , candidateFieldToBeInjected , matchingMock ) ; }
InternalMockHandler handler = createMockHandler ( settings ) ;
InternalMockHandler handler = createMockHandler ( settings ) ;
catch ( Throwable listenerThrowable ) { throw invocationListenerThrewException ( listener , listenerThrowable ) ; }
catch ( Throwable listenerThrowable ) { throw invocationListenerThrewException ( listener , listenerThrowable ) ; }
public NumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () ) ; }
if ( expectedMatchersSize != recordedMatchersSize ) { throw invalidUseOfMatchers ( expectedMatchersSize , lastMatchers ) ; }
{ if ( ! superMethod . isInvokable () ) { throw cannotCallAbstractRealMethod () ; } return superMethod . invoke () ; }
{ if ( argumentPosition != LAST_ARGUMENT && argumentPosition < NUMBER_CONSTANT ) { throw invalidArgumentRangeAtIdentityAnswerCreationTime () ; } return argumentPosition ; }
if ( unverified != null ) { throw noMoreInteractionsWantedInOrder ( unverified ) ; }
public NonGreedyNumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () , new InvocationMarker () ) ; }
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { throw mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
if ( stubbing == null ) { mockingProgress . reset () ; throw missingMethodInvocation () ; }
{ this . defaultAnswer = defaultAnswer ; if ( defaultAnswer == null ) { throw defaultAnswerDoesNotAcceptNullParameter () ; } return this ; }
{ if ( alreadyAssigned ) { throw moreThanOneAnnotationNotAllowed ( field . getName () ) ; } }
if ( o . isToString ( wanted . getMethod () ) ) { throw cannotVerifyToString () ; }
catch ( RuntimeException e ) { throw cannotInjectDependency ( candidateFieldToBeInjected , matchingMock , e ) ; }
{ if ( alreadyAssigned ) { throw moreThanOneAnnotationNotAllowed ( field . getName () ) ; } }
{ if ( usingConstructor && mode == SerializableMode.ACROSS_CLASSLOADERS ) { throw usingConstructorWithFancySerializable ( mode ) ; } }
if ( delegatedInstance . getClass () . isAssignableFrom ( classToMock ) ) { throw mockedTypeIsInconsistentWithDelegatedInstanceType ( classToMock , delegatedInstance ) ; }
if ( ! classToMock . equals ( spiedInstance . getClass () ) ) { throw mockedTypeIsInconsistentWithSpiedInstanceType ( classToMock , spiedInstance ) ; }
for ( Class i : extraInterfaces ) { if ( classToMock == i ) { throw extraInterfacesCannotContainMockedType ( classToMock ) ; } }
{ if ( mockSettings . isStubOnly () ) { throw stubPassedToVerify () ; } return new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; }
if ( ! invocationContainerImpl . hasInvocationForPotentialStubbing () ) { throw incorrectUseOfApi () ; }
{ if ( ! methodInfo . isVoid () ) { throw onlyVoidMethodsCanBeSetToDoNothing () ; } }
{ if ( methodInfo . isAbstract () ) { throw cannotCallAbstractRealMethod () ; } }
if ( foundSize > maxNumberOfInvocations ) { throw wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; }
{ if ( method . isAbstract () ) { throw cannotCallAbstractRealMethod () ; } return realMethod . invoke ( mock , rawArguments ) ; }
public MissingInvocationChecker () { this ( new InvocationsFinder () ) ; }
if ( throwableClass == null || ! Throwable . class . isAssignableFrom ( throwableClass ) ) { throw notAnException () ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . invocationListenerDoesNotAcceptNullParameters () ; }
for ( StackTraceElement element : target ) { if ( CLEANER . isOut ( element ) ) { filtered . add ( element ) ; } }
{ assertThat ( cleaner . isOut ( type ( className ) ) ) . describedAs ( STRING_CONSTANT , className ) . isFalse () ; }
{ assertThat ( cleaner . isOut ( type ( className ) ) ) . describedAs ( STRING_CONSTANT , className ) . isTrue () ; }
markVerified ( actualInvocations , wanted ) ;
markVerified ( next , wanted ) ;
public NonGreedyNumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () ) ; }
markVerified ( chunk . get ( NUMBER_CONSTANT ) , wantedMatcher ) ;
markVerifiedInOrder ( chunk , wanted , context ) ;
markVerifiedInOrder ( chunk , wanted , orderingContext ) ;
markVerified ( actualInvocations , wanted ) ;
markVerified ( found , wanted ) ;
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return false ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
void reportMatcher ( ArgumentMatcher matcher ) ;
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return false ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return null ; }
{ reportMatcher ( new StartsWith ( prefix ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new EndsWith ( suffix ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new Matches ( regex ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new Contains ( substring ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( NotNull.NOT_NULL ) ; return null ; }
{ reportMatcher ( NotNull.NOT_NULL ) ; return null ; }
{ reportMatcher ( Null.NULL ) ; return null ; }
{ reportMatcher ( Null.NULL ) ; return null ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return false ; }
{ reportMatcher ( AnyVararg.ANY_VARARG ) ; return null ; }
{ reportMatcher ( Any.ANY ) ; return null ; }
{ Mockito . argThat ( capturingMatcher ) ; return defaultValue ( clazz ) ; }
{ return Primitives . defaultValue ( type ) ; }
assertThat ( new ThreadSafeMockingProgress () . pullOngoingStubbing () ) . isNull () ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return false ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return false ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return false ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new Find ( regex ) ) ; return null ; }
{ if ( ENABLED && candidate . getMethodName () . contains ( STRING_CONSTANT ) ) { return true ; } return defaultCleaner . isOut ( candidate ) ; }
T argument
String argument
new ArgumentMatcher < String > () { public boolean matches ( String argument ) { return true ; } }
public void setAnswersForStubbing ( List < Answer < > > answers ) { answersForStubbing . addAll ( answers ) ; }
Class < > clazz
public InOrderImpl ( List < ? extends Object > mocksToBeVerifiedInOrder ) { this . mocksToBeVerifiedInOrder . addAll ( mocksToBeVerifiedInOrder ) ; }
Map < , > map () { return null ; }
LinkedList < > linkedList () { return null ; }
List < > list () { return null ; }
List < Answer < > > answers
public void setAnswersForStubbing ( List < Answer < > > answers ) { mockHandler . setAnswersForStubbing ( answers ) ; }
MockCreationSettings < > settings
assertEquals ( NUMBER_CONSTANT , captor . getValue () ) ;
Long longPretendingAnInt = NUMBER_CONSTANT ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( new HamcrestArgumentMatcher < T > ( matcher ) ) ; }
assertFalse ( mockUtil . isSpy ( null ) ) ;
void setAnswersForStubbing ( List < Answer < > > answers ) ;
int compareTo ( HasCompare redHerring ) ;
int foo ( HasCompare other ) ;
int compareTo ( HasCompareToButDoesNotImplementComparable other ) ;
assertNotNull ( readObject ) ;
public NullResultGuardian ( InternalMockHandler < T > delegate ) { this . delegate = delegate ; }
verify ( mock ) . simpleMethod ( anyObject () ) ;
catch ( Exception e ) { throw new IllegalStateException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + pluginType , e ) ; }
Class < > classToMock
int secondArgument = ( Integer ) invocationOnInterface . getArgument ( NUMBER_CONSTANT ) ;
void reportMatcher ( ArgumentMatcher < > matcher ) ;
void mockingStarted ( Object mock , Class < > classToMock ) ;
void mockingStarted ( Object mock , Class < > classToMock ) ;
OngoingStubbing < > pullOngoingStubbing ( ) ;
void reportOngoingStubbing ( OngoingStubbing < > ongoingStubbing ) ;
Class < > classToMock
public void reportOngoingStubbing ( OngoingStubbing < > iOngoingStubbing ) { threadSafely () . reportOngoingStubbing ( iOngoingStubbing ) ; }
public ArgumentMatcher < > getMatcher () { return matcher ; }
ArgumentMatcher < > matcher
createdMocks = new LinkedList < Object > () ;
public void mockingStarted ( Object mock , Class < > classToMock ) { toBeFilled . add ( mock ) ; }
public CollectCreatedMocks ( List < Object > toBeFilled ) { this . toBeFilled = toBeFilled ; }
Class < > expected
{ copy ( from , to , from . getClass () ) ; }
Class < > actualType
Class < > lhsClass = lhs . getClass () ;
Class < > reflectUpToClass
Class < > typeToMock
Iterable < > lines
new SerializableMethod ( type . getMethod ( methodName , new Class < > [ NUMBER_CONSTANT ] ) )
Class < > classToMock
Class < > mockedType
Class < > type
Class < > [] argTypes
{ mock ( IMethods . class , withSettings () . extraInterfaces ( ( Class < > [] ) null ) ) ; }
for ( Class < > anInterface : interfaces ) { types . add ( anInterface . getName () ) ; }
for ( Class < > i : extraInterfaces ) { if ( classToMock == i ) { throw extraInterfacesCannotContainMockedType ( classToMock ) ; } }
Class < > currentExploredClass = clazz
Class < > type
{ mock . oneArg ( ( char ) ( CHAR_CONS + i ) ) ; }
Answer < > answer
Answer < > answer
public BDDStubber will ( Answer < > answer ) { return new BDDStubberImpl ( mockitoStubber . doAnswer ( answer ) ) ; }
public BDDStubber willAnswer ( Answer < > answer ) { return new BDDStubberImpl ( mockitoStubber . doAnswer ( answer ) ) ; }
Answer < > answer
Answer < > answer
return matchers ;
HoldingAReference ( WeakReference < Class < > > a ) { this . a = a ; }
Class < > . . . extraInterfaces
List < Invocation > chunk = InvocationsFinder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = InvocationsFinder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = InvocationsFinder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
Invocation found = InvocationsFinder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedDifferentMethod ) ) ;
Invocation found = InvocationsFinder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedSimpleMethod ) ) ;
Invocation unverified = findFirstUnverifiedInOrder ( data . getOrderingContext () , invocations ) ;
Invocation unverified = findFirstUnverified ( data . getAllInvocations () ) ;
Invocation next = findFirstMatchingUnverifiedInvocation ( invocations , wanted , context ) ;
public int size ( Collection < > collection ) { return collection . size () ; }
public int size ( Map < , > map ) { return map . size () ; }
verify ( ( Iterable < String > ) iterable ) . iterator () ;
Assert . assertNotNull ( ( ( Iterable < String > ) iterable ) . iterator () ) ;
notifier . setAnswersForStubbing ( new ArrayList < Answer < > > () ) ;
FailingConstructor ( Set < > set ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
public Set < > getHistogram2 () { return histogram2 ; }
public Set < > getHistogram1 () { return histogram1 ; }
public TreeSet < > getSearchTree () { return searchTree ; }
public List < > getAList () { return aList ; }
ConstructorInjection.SimpleArgumentResolver resolver = new ConstructorInjection.SimpleArgumentResolver ( newSetOf ( new HashSet < Float > () , new ByteArrayOutputStream () ) ) ;
public some_class_with_parametered_constructor ( List < > collaborator ) { constructor_instantiation ++ ; }
public ByteBuddyMockMaker () { cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator ( false ) ; }
public LessThan ( T value ) { super ( value ) ; }
public LessOrEqual ( T value ) { super ( value ) ; }
public GreaterOrEqual ( T value ) { super ( value ) ; }
T value
T value
T value
T value
T value
public CompareTo ( T value ) { this . wanted = value ; }
public GreaterThan ( T value ) { super ( value ) ; }
public CompareEqual ( T value ) { super ( value ) ; }
UnmockableHashCodeAndEquals mock = mock1 ;
Transformer.ForMethod . withModifiers ( SynchronizationState.PLAIN )
VerificationMode only ( ) ;
VerificationMode atLeastOnce ( ) ;
VerificationMode never ( ) ;
@ Before public void initialize_dependencies () { underTest = new ConstructorInjection () ; }
Method getJavaMethod ( ) ;
Class < > [] getExceptionTypes ( ) ;
Class < > [] getParameterTypes ( ) ;
Class < > getReturnType ( ) ;
String getName ( ) ;
{ return false ; }
Object writeReplace ( ) ;
{ mockingProgress () . getArgumentMatcherStorage () . reportMatcher ( new HamcrestArgumentMatcher < T > ( matcher ) ) ; }
mockingProgress () . validateState () ;
mockingProgress () . validateState () ;
mockingProgress () . mockingStarted ( mock , typeToMock ) ;
MockingProgress p = mockingProgress () ;
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return false ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return null ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return null ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return false ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return null ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return false ; }
assertThat ( mockingProgress () . pullOngoingStubbing () ) . isNull () ;
mockingProgress () . stubbingCompleted ( invocation ) ;
InvocationContainerImpl invocations = new InvocationContainerImpl ( new MockSettingsImpl () ) ;
mockingProgress () . setVerificationStrategy ( MockingProgressImpl . getDefaultVerificationStrategy () ) ;
{ mockingProgress () . setVerificationStrategy ( MockingProgressImpl . getDefaultVerificationStrategy () ) ; }
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( ANY ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( null ) , ANY ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( NUMBER_CONSTANT ) , ANY ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( NUMBER_CONSTANT ) , ANY ) ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
public void filter ( Filter filter ) throws NoTestsRemainException { runner . filter ( filter ) ; }
FailureDetecter listener = new FailureDetecter () ;
assertThat ( result ) . isSuccessful () ;
{ return new RunnerProvider () . newInstance ( STRING_CONSTANT , klass ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { filterRequested = true ; runner . filter ( filter ) ; }
notifier . fireTestFailure ( new Failure ( unnecessaryStubbings , Reporter . formatUnncessaryStubbingException ( testClass , stubbings . values () ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
public void filter ( Filter filter ) throws NoTestsRemainException { runner . filter ( filter ) ; }
FailureDetecter listener = new FailureDetecter () ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
{ try { return argumentsMatch ( this , actualArgs ) ; } catch ( Throwable t ) { return false ; } }
return invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && argumentsMatch ( this , actual ) ;
! hasTestMethods ( klass )
MockCreationSettings < T > settings
MockCreationSettings < T > mockSettings
{ reportMatcher ( new InstanceOf ( Collection . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Map . class ) ) ; return new HashMap ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Set . class ) ) ; return new HashSet ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( List . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( chunk ) . containsSequence ( simpleMethodInvocation , simpleMethodInvocationTwo , simpleMethodInvocationThree ) ;
Assertions . assertThat ( chunk ) . containsSequence ( simpleMethodInvocation , simpleMethodInvocationTwo , simpleMethodInvocationThree ) ;
Assertions . assertThat ( chunk ) . containsSequence ( simpleMethodInvocation , simpleMethodInvocationTwo ) ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , MyAssertionError . class ) ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , UnnecessaryStubbingException . class ) ;
JUnitResultAssert . assertThat ( result ) . isSuccessful () ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT ) ) ;
JUnitResultAssert . assertThat ( result ) . isSuccessful () ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , UnfinishedStubbingException . class ) ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , TooLittleActualInvocations . class ) ;
{ Result result = runner . run ( SomeFeature . class ) ; JUnitResultAssert . assertThat ( result ) . isSuccessful () ; }
catch ( RuntimeException e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { Assertions . assertThat ( expected ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { Assertions . assertThat ( expected ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { Assertions . assertThat ( expected ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { Assertions . assertThat ( expected ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
Assertions . assertThat ( t ) . has ( onlyThoseClassesInStackTrace ( STRING_CONSTANT ) ) ;
Assertions . assertThat ( t ) . has ( onlyThoseClassesInStackTrace ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . containsSequence ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
Assertions . assertThat ( timer . isCounting () ) . isFalse () ;
Assertions . assertThat ( timer . isCounting () ) . isTrue () ;
{ reportMatcher ( new InstanceOf ( Iterable . class , STRING_CONSTANT ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Collection . class , STRING_CONSTANT ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Map . class , STRING_CONSTANT ) ) ; return new HashMap ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Set . class , STRING_CONSTANT ) ) ; return new HashSet ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( List . class , STRING_CONSTANT ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( String . class , STRING_CONSTANT ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Short . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Double . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Float . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Long . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Integer . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Character . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Byte . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Boolean . class , STRING_CONSTANT ) ) ; return false ; }
void save ( Person capture ) ;
String targetMethod ( String arg ) ;
Integer getValue ( Integer param ) ;
Object otherMethod ( Object param ) ;
Object someMethod ( Object param ) ;
MyIterator < T > iterator ( ) ;
public void setSpy ( List < > spy ) { this . spy = spy ; }
public List < > getList () { return list ; }
assertThat ( log ) . containsIgnoringCase ( STRING_CONSTANT ) ;
catch ( NeverWantedButInvoked e ) { assertThat ( e . getMessage () ) . doesNotContain ( STRING_CONSTANT ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e . getMessage () ) . doesNotContain ( STRING_CONSTANT ) ; }
catch ( AssertionError e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
{ String expected = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; assertThat ( e ) . hasMessageContaining ( expected ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
{ assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; e . getCause () . getMessage () . equals ( STRING_CONSTANT ) ; }
assertThat ( out ) . contains ( STRING_CONSTANT ) ;
catch ( NeverWantedButInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
assertThat ( name ) . contains ( STRING_CONSTANT ) ;
assertThat ( name ) . contains ( STRING_CONSTANT ) ;
assertThat ( name ) . contains ( STRING_CONSTANT ) ;
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( NeverWantedButInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( InvalidUseOfMatchersException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( SmartNullPointerException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( UnfinishedVerificationException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
assertThat ( mockTwo . toString () ) . contains ( STRING_CONSTANT ) ;
catch ( InstantiationException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT + STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
assertThat ( failure . getException () ) . hasMessageContaining ( STRING_CONSTANT ) ;
assertThat ( mockTwo . toString () ) . contains ( STRING_CONSTANT ) ;
assertThat ( mockTwo . toString () ) . contains ( STRING_CONSTANT ) ;
catch ( MockitoException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
assertNotNull ( MockUtil . getMockSettings ( mock ) ) ;
assertNotNull ( MockUtil . getMockHandler ( mock ) ) ;
if ( MockUtil . isMock ( throwable ) ) { throw throwable ; }
{ assertNotNull ( notInitializedSpy ) ; assertNotNull ( notInitializedSpy . getAList () ) ; assertTrue ( MockUtil . isMock ( notInitializedSpy ) ) ; }
@ Test public void should_inject_mocks_in_spy () { assertNotNull ( initializedSpy . getAList () ) ; assertTrue ( MockUtil . isMock ( initializedSpy ) ) ; }
Class < > mockType = MockUtil . getMockHandler ( mock ) . getMockSettings () . getTypeToMock () ;
MockUtil . isMock ( instance )
MockUtil . isMock ( instance )
if ( isMockOrSpy ( instance ) ) { MockUtil . maybeRedefineMockName ( instance , field . getName () ) ; return instance ; }
MockCreationSettings < > mockSettings = MockUtil . getMockSettings ( mockitoMock ) ;
MockCreationSettings parentMockSettings = MockUtil . getMockSettings ( parentMock ) ;
InternalMockHandler < Object > handler = MockUtil . getMockHandler ( invocation . getMock () ) ;
assertTrue ( MockUtil . isMock ( subClass.list ) ) ;
assertTrue ( MockUtil . isMock ( classMock ) ) ;
assertTrue ( MockUtil . isMock ( interfaceMock ) ) ;
InternalMockHandler < Object > handler = MockUtil . getMockHandler ( mock ) ;
public MockingDetails mockingDetails ( Object toInspect ) { return new DefaultMockingDetails ( toInspect ) ; }
InvocationContainer invocationContainer = getMockHandler ( m ) . getInvocationContainer () ;
{ if ( mock == null ) { throw nullPassedWhenCreatingInOrder () ; } if ( ! isMock ( mock ) ) { throw notAMockPassedWhenCreatingInOrder () ; } }
InvocationContainer invocations = getMockHandler ( mock ) . getInvocationContainer () ;
for ( T m : mocks ) { getMockHandler ( m ) . getInvocationContainer () . clearInvocations () ; }
for ( T m : mocks ) { resetMock ( m ) ; }
if ( ! isMock ( mock ) ) { throw notAMockPassedToVerify ( mock . getClass () ) ; }
T mock = createMock ( creationSettings ) ;
InternalMockHandler < Object > handler = MockUtil . getMockHandler ( mock ) ;
TypeMockability typeMockability = MockUtil . typeMockabilityOf ( classToMock ) ;
{ if ( MockUtil . typeMockabilityOf ( aClass ) . mockable () ) { constructorMockableParamsSize ++ ; } }
String mockName = getMockName ( mocks . iterator () . next () ) . toString () ;
{ if ( candidateFieldToBeInjected . getName () . equals ( getMockName ( mock ) . toString () ) ) { mockNameMatches . add ( mock ) ; } }
String qualifiedName = MockUtil . getMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () ;
List < Invocation > invocations = AllInvocationsFinder . find ( asList ( mockOne , mockOne , mockOne ) ) ;
List < Invocation > invocations = AllInvocationsFinder . find ( asList ( mockOne , mockTwo ) ) ;
List < Invocation > all = AllInvocationsFinder . find ( createdMocks ) ;
List < Invocation > invocations = VerifiableInvocationsFinder . find ( inOrder . getMocksToBeVerifiedInOrder () ) ;
List < Invocation > invocations = AllInvocationsFinder . find ( asList ( mocks ) ) ;
assumeTrue ( ClassFileVersion . forThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
assumeTrue ( ClassFileVersion . forThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
verify ( mockHandler ) . setAnswersForStubbing ( ArgumentMatchers . < Answer < > > anyList () ) ;
when ( sorter . sort ( ArgumentMatchers . < String > anyList () ) ) . thenReturn ( null ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
{ results . add ( sortSuperTypesLast ( Arrays . asList ( o ) ) ) ; }
List < Field > sortedFields = sortSuperTypesLast ( unsortedFields ) ;
List < Field > l = sortSuperTypesLast ( Arrays . asList ( o1 , o2 ) ) ;
return sortSuperTypesLast ( declaredFields ) ;
isNullOrEmpty ( args )
@ Override public InvocationMatcher getWanted () { return wanted ; }
public boolean isOut ( Invocation invocation ) { return isToStringMethod ( invocation . getMethod () ) ; }
if ( isToStringMethod ( currentInvocation . getMethod () ) ) { return STRING_CONSTANT + unstubbedInvocation . toString () ; }
if ( ! filterRequested && listener . isSussessful () ) { reporter . validateUnusedStubs ( testClass , notifier ) ; }
mockingProgress () . mockingStarted ( mock , creationSettings ) ;
@ Test public void shouldNotifyListenerSafely ( ) throws Exception { mockingProgress . addListener ( null ) ; mockingProgress . mockingStarted ( null , null ) ; }
Iterable < > mocks
throw cannotInitializeForInjectMocksAnnotation ( field . getName () , e . getMessage () ) ;
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
{ if ( value == null ) { throw new IllegalArgumentException ( checkedValue + STRING_CONSTANT ) ; } return value ; }
public TypeVariable < > typeVariable () { return typeVariable ; }
public TypeVarBoundedType ( TypeVariable < > typeVariable ) { this . typeVariable = typeVariable ; }
TypeVariable < > [] typeParameters
if ( type instanceof TypeVariable ) { return new TypeVariableReturnType ( this , method . getTypeParameters () , ( TypeVariable < > ) type ) ; }
if ( wildCardBoundedType . firstBound () instanceof TypeVariable ) { return boundsOf ( ( TypeVariable < > ) wildCardBoundedType . firstBound () ) ; }
TypeVariable < > typeVariable
assertThat ( to.privateTransientField ) . isNotEqualTo ( NUMBER_CONSTANT ) ;
assertThat ( to.finalField ) . isNotEqualTo ( NUMBER_CONSTANT ) ;
Class < > classToMock
public int size () { return unused . size () ; }
assumeTrue ( ClassFileVersion . ofThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
assumeTrue ( ClassFileVersion . ofThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
String getAuthorName ( ) ;
String getAuthorEmail ( ) ;
public String toText () { return commits . size () + STRING_CONSTANT + authorName ; }
public String getAuthorName () { return author ; }
public String getAuthorEmail () { return email ; }
UnusedStubbings ( Collection < ? extends Stubbing > unused ) { this . unused = unused ; }
if ( type instanceof Class ) { return new NotGenericReturnTypeSupport ( this , type ) ; }
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT , MILLISECONDS ) ;
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT , MILLISECONDS ) ;
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT , MILLISECONDS ) ;
generatedMockClass = generator . generateMockClass ( features ) ;
@ Test public void shouldRunInMultipleThreads ( ) throws Exception { assertEquals ( STRING_CONSTANT , Collections . emptySet () , runInMultipleThreads ( NUMBER_CONSTANT ) ) ; }
Class < ? extends T > mockedProxyType = createMockType ( settings ) ;
Class < ? extends T > type = createMockType ( settings ) ;
dispatcher == null || ! dispatcher . isMocked ( mock , origin )
public AbstractByteBuddyMockMakerTest ( MM mockMaker ) { this . mockMaker = mockMaker ; }
generatedMockClass = bytecodeGenerator . mockClass ( features ) ;
{ return invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && argumentsMatch ( actual ) ; }
given ( mock ( ConstructorArgumentResolver . class ) . resolveTypeInstances ( any ( Class . class ) ) )
withModifiers ( SynchronizationState.PLAIN , Visibility.PUBLIC )
{ addStep ( task , config ) ; return this ; }
MatchableInvocation wanted
MatchableInvocation wantedMatcher = data . getWanted () ;
MatchableInvocation wanted = data . getWanted () ;
public String print ( MatchableInvocation invocationMatcher ) { return print ( invocationMatcher . getMatchers () , invocationMatcher . getInvocation () ) ; }
MatchableInvocation wanted = data . getWanted () ;
MatchableInvocation wanted = data . getWanted () ;
MatchableInvocation wanted = data . getWanted () ;
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation getWanted ( ) ;
private RemoveNotMatching ( MatchableInvocation wanted ) { this . wanted = wanted ; }
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
VerificationDataInOrderImpl dataInOrder = new VerificationDataInOrderImpl ( inOrder , invocations , data . getTarget () ) ;
MatchableInvocation wanted = data . getTarget () ;
{ Checks . checkNotNull ( listener , STRING_CONSTANT ) ; mockingProgress () . removeListener ( listener ) ; return this ; }
{ Checks . checkNotNull ( listener , STRING_CONSTANT ) ; mockingProgress () . addListener ( listener ) ; return this ; }
@ Before public void setUp () { delayedExecution = new DelayedExecution () ; stopWatch = createNotStarted () ; }
@ Advice.Return ( readOnly = false , typing = Assigner.Typing.DYNAMIC ) Object returned
@ Advice.AllArguments Object [] arguments
private ExcludeHandler ( Object root ) { this . root = root ; }
@ Override public Invocation getInvocation () { return invocation ; }
{ return isMock ( mock ) && getMockSettings ( mock ) . getDefaultAnswer () == Mockito.CALLS_REAL_METHODS ; }
isMock ( mock )
mockingProgress () . stubbingCompleted () ;
AnnotationEngine customizedEngine = new IndependentAnnotationEngine () {} ;
AnnotationEngine annotationEngine = new GlobalConfiguration () . tryGetPluginAnnotationEngine () ;
ClassLoader cl = isolatedClassLoader () . withCurrentCodeSourceUrls () . withPrivateCopyOf ( CLASS_NAME_DEPENDING_ON_INTERFACE ) . withPrivateCopyOf ( INTERFACE_NAME ) . build () ;
{ throw new IllegalArgumentException ( format ( STRING_CONSTANT , classLoader ) ) ; }
public ExcludingURLClassLoaderBuilder without ( String . . . privatePrefixes ) { excludedPrefixes . addAll ( asList ( privatePrefixes ) ) ; return this ; }
MockitoStatement statement
mock . otherMethod () ;
public void doAssert ( Throwable throwable ) { assertThrowable ( throwable , expected ) . hasMessage ( expectedMessage ) ; }
rule . expectThrowable ( UnnecessaryStubbingException . class ) ;
public void beforeTest ( Object testClassInstance , String testMethodName ) {}
public JUnitRule silent () { return new JUnitRule ( logger , Strictness.SILENT ) ; }
{ return new JUnitRule ( new ConsoleMockitoLogger () , JUnitRule.Strictness.WARN ) ; }
void doAssert ( Throwable t ) ;
@ Test public void rule_validates_mockito_usage ( ) throws Throwable { rule . expectFailure ( UnfinishedVerificationException . class ) ; verify ( mock ) ; }
rule . expectFailure ( PotentialStubbingProblem . class ) ;
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectFailure ( UnnecessaryStubbingException . class ) ;
rule . expectFailure ( RuntimeException . class , STRING_CONSTANT ) ;
{ rule . expectFailure ( UnfinishedStubbingException . class ) ; when ( mock . simpleMethod () ) ; }
{ rule . expectFailure ( RuntimeException . class , STRING_CONSTANT ) ; throw new RuntimeException ( STRING_CONSTANT ) ; }
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
notifyStubbedAnswerLookup ( invocation , stubbedInvocation ) ;
List < StubbingLookupListener > getStubbingLookupListeners ( ) ;
{ return new JUnitRule ( new ConsoleMockitoLogger () , Strictness.WARN ) ; }
public MockitoRule silent () { return new JUnitRule ( logger , Strictness.LENIENT ) ; }
case LENIENT :
( ( CreationSettings ) settings ) . getStubbingLookupListeners ()
mockingProgress . verificationStarted ( new MockAwareVerificationMode ( mock , actualMode , mockingProgress . verificationListeners () ) ) ;
private int wantedArgumentPosition () { return wantedArgumentPosition ; }
DefaultAnswerValidator . validateReturnValueFor ( invocation , ret ) ;
private boolean returnsNull () { return value == null ; }
public void reportMatcher ( ArgumentMatcher < > matcher ) { matcherStack . push ( new LocalizedMatcher ( matcher ) ) ; }
{ this ( new StrictRunner ( new RunnerFactory () . createStrict ( klass ) , klass ) ) ; }
{ super ( new StrictRunner ( new RunnerFactory () . createStrict ( klass ) , klass ) ) ; }
RunnerImpl runner = provider . newInstance ( STRING_CONSTANT , this . getClass () , null ) ;
MockitoJUnitRunner ( InternalRunner runner ) throws InvocationTargetException { this . runner = runner ; }
InternalRunner runner
loader . getStrategy ( features.mockedType )
assertThat ( InlineByteBuddyMockMaker . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ) . isSameAs ( throwable ) ;
throwable = InlineByteBuddyMockMaker . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ;
@ Override public boolean mockable () { return INSTRUMENTATION . isModifiableClass ( type ) && ! EXCLUDES . contains ( type ) ; }
if ( i != successCount ) { throw new AssertionError ( STRING_CONSTANT + successCount + STRING_CONSTANT + i + STRING_CONSTANT + result . getRunCount () + STRING_CONSTANT ) ; }
Result result = runner . run ( StubbingArgMismatch . class ) ;
Result result = runner . run ( UnnecessaryStubbing . class ) ;
{ return mock ( classToMock , withSettings () ) ; }
return new AndroidClassLoadingStrategy.Injecting ( target ) ;
MockSettings settings = withSettings () . defaultAnswer ( CALLS_REAL_METHODS ) . name ( field . getName () ) ;
Mockito . mock ( instance . getClass () , withSettings () . spiedInstance ( instance ) . defaultAnswer ( CALLS_REAL_METHODS ) . name ( field . getName () ) )
InnerStaticClassWithNoArgConstructor ( String f ) {}
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
throw noMatchingConstructor ( cls ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
if ( ! argMismatchStubbings . isEmpty () ) { mismatchesReported = true ; Reporter . potentialStubbingProblem ( invocation , argMismatchStubbings ) ; }
try { Mockito . framework () . addListener ( listener ) ; } catch ( RedundantListenerException e ) { Reporter . unfinishedMocking () ; }
Failure f = firstOf ( result . getFailures () ) ;
mockito . finishMocking () ;
mockito . finishMocking () ;
mockito . finishMocking () ;
mockito . finishMocking () ;
{ mock . simpleMethod ( NUMBER_CONSTANT ) ; mock . otherMethod () ; mockito . finishMocking () ; logger . assertEmpty () ; }
assertThat ( new Runnable () { public void run () { mockito . finishMocking () ; } } ) . throwsException ( UnnecessaryStubbingException . class )
{ this . currentStrictness = strictness ; this . stubbingLookupListener . setCurrentStrictness ( strictness ) ; }
event . getFailure () == null && ! stubbingLookupListener . isMismatchesReported ()
try { Mockito . framework () . addListener ( listener ) ; } catch ( RedundantListenerException e ) { Reporter . unfinishedMockingSession () ; }
assertThat ( result ) . fails ( UnfinishedMockingSessionException . class , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
assertThat ( result ) . succeeds ( NUMBER_CONSTANT ) ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , PotentialStubbingProblem . class ) ;
return decamelizeMatcher ( matcher . getClass () . getSimpleName () ) ;
return ExceptionFactory . createArgumentsAreDifferentException ( message , wanted , actual ) ;
withModifiers ( SynchronizationState.PLAIN )
assertThat ( MockMethodAdvice . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ) . isSameAs ( throwable ) ;
throwable = MockMethodAdvice . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ;
if ( paramsMatch ( types , params ) ) { evaluateConstructor ( matchingConstructors , constructor ) ; }
assertEquals ( STRING_CONSTANT , mock . forObject ( null ) ) ;
catch ( Throwable throwable ) { lastException = throwable ; return null ; }
if ( unused . isEmpty () ) { return; }
return STRING_CONSTANT . equals ( method . getName () ) ;
STRING_CONSTANT . equals ( method . getName () )
STRING_CONSTANT . equals ( m . getName () )
Type genericInterface = findGenericInterface ( match , targetBaseInterface ) ;
public Class < > [] getParameterTypes () { return parameterTypes ; }
this . arguments = ArgumentsProcessor . expandArgs ( mockitoMethod , args ) ;
this . arguments = ArgumentsProcessor . expandArgs ( mockitoMethod , arguments ) ;
parameterTypes = SuspendMethod . trimSuspendParameterTypes ( method . getParameterTypes () ) ;
{ if ( ! wantedArgumentPositionIsValidForInvocation ( invocation , argumentPosition ) ) { throw invalidArgumentPositionRangeAtInvocationTime ( invocation , wantedArgumentPosition == LAST_ARGUMENT , wantedArgumentPosition ) ; } }
validateArgumentTypeCompatibility ( ( Invocation ) invocation , argumentPosition ) ;
public InOrderImpl ( List < > mocksToBeVerifiedInOrder ) { this . mocksToBeVerifiedInOrder . addAll ( mocksToBeVerifiedInOrder ) ; }
assertThat ( m . getAllValues () ) . containsSequence ( STRING_CONSTANT , STRING_CONSTANT ) ;
Iterable < > mocks
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
given ( iMethods . varargsObject ( eq ( NUMBER_CONSTANT ) , any () ) ) . will ( returnsArgAt ( NUMBER_CONSTANT ) ) ;
@ Override public String indirect () { return STRING_CONSTANT ; }
UnusedStubbings stubbings = new UnusedStubbings ( Arrays . < Stubbing > asList () ) ;
List < Stubbing > getStubbedInvocations ( ) ;
MockHandler handler
public NullResultGuardian ( MockHandler < T > delegate ) { this . delegate = delegate ; }
{ ( ( MockAccess ) mock ) . setMockitoInterceptor ( new MockMethodInterceptor ( newHandler , settings ) ) ; }
mockAccess . setMockitoInterceptor ( new MockMethodInterceptor ( handler , settings ) ) ;
MockHandler < > handler = createMockHandler ( settings ) ;
MockHandler < > handler = createMockHandler ( settings ) ;
MockHandler < T > mockHandler
MatchableInvocation invocation
public void setAnswersForStubbing ( List < Answer < > > answers ) { invocationContainer . setAnswersForStubbing ( answers ) ; }
this . invocationContainer = new InvocationContainerImpl ( mockSettings ) ;
@ SuppressWarnings ( STRING_CONSTANT ) public < M > M getMock () { return ( M ) invocationContainer . invokedMock () ; }
MockUtil . getMockHandler ( mock ) . getInvocationContainer () . setAnswersForStubbing ( answers ) ;
List < ? extends Stubbing > stubbings = getInvocationContainer () . getStubbedInvocations () ;
InvocationContainerImpl invocations
InvocationContainerImpl invocations = getInvocationContainer ( mock ) ;
for ( T m : mocks ) { getInvocationContainer ( m ) . clearInvocations () ; }
MockUtil . getInvocationContainer ( mock ) . setAnswersForStubbing ( answers ) ;
InvocationContainerImpl invocationContainer
MockCreationSettings < T > creationSettings = impl . build ( typeToMock ) ;
private MockHandler < Object > mockHandler () { assertGoodMock () ; return MockUtil . getMockHandler ( toInspect ) ; }
given ( handler.invocationContainer . findAnswerFor ( any ( Invocation . class ) ) ) . willReturn ( value ) ;
{ if ( interceptor == null ) { return stubValue ; } return interceptor . doIntercept ( mock , invokedMethod , arguments , InterceptedInvocation.RealMethod.IsIllegal.INSTANCE ) ; }
return interceptor . doIntercept ( mock , invokedMethod , arguments , new InterceptedInvocation.RealMethod.FromCallable ( superCall ) ) ;
verify ( mock ) ;
{ RealMethod.FromCallable superMethod = new RealMethod.FromCallable ( realMethod ) ; return MockMethodInterceptor . createInvocation ( target , method , args , superMethod , settings ) ; }
{ if ( interceptor == null ) { return stubValue ; } return interceptor . doIntercept ( mock , invokedMethod , arguments , RealMethod.IsIllegal.INSTANCE ) ; }
return interceptor . doIntercept ( mock , invokedMethod , arguments , new RealMethod.FromCallable ( superCall ) ) ;
RealMethod realMethod
RealMethod realMethod
RealMethod realMethod
RealMethod realMethod
RealMethod realMethod ;
return ! node . getSort () . isResolved () || ! node . getRepresentative () . asDefined () . represents ( origin ) ;
if ( ! isMock ( mock ) ) { throw notAMockPassedToWhenMethod () ; }
UnusedStubbings stubbings = new UnusedStubbings ( Collections . < Stubbing > emptyList () ) ;
{ addListeners ( listeners , this . verificationStartedListeners , STRING_CONSTANT ) ; return this ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . methodDoesNotAcceptNullParameters ( STRING_CONSTANT , STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . methodDoesNotAcceptParameter ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ if ( mock == null ) { throw Reporter . methodDoesNotAcceptParameter ( STRING_CONSTANT , STRING_CONSTANT ) ; } this . mock = mock ; }
VerificationStartedEvent event = new Event () ;
mock = ( T ) VerificationStartedNotifier . notifyVerificationStarted ( handler . getMockSettings () . getVerificationStartedListeners () , mockitoMock ) ;
public static MockitoMock getMockitoMock ( Object mock ) { return new MockitoMock ( mock , mockMaker . getHandler ( mock ) ) ; }
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
@ Test public void does_not_do_anything_when_list_is_empty ( ) throws Exception { VerificationStartedNotifier . notifyVerificationStarted ( ( List ) emptyList () , mockitoMock ) ; }
catch ( Exception e ) { assertEquals ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockingDetails ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockingDetails ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockingDetails ) ;
@ Test public void does_not_do_anything_when_list_is_empty ( ) throws Exception { VerificationStartedNotifier . notifyVerificationStarted ( ( List ) emptyList () , mockingDetails ) ; }
assertEquals ( Double . valueOf ( NUMBER_CONSTANT ) , captor . getValue () ) ;
catch ( NotAMockException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
@ Override public Object getOuterClassInstance () { return outerClassInstance ; }
@ Override public Object getSpiedInstance () { return spiedInstance ; }
@ Override public MockName getMockName () { return mockName ; }
@ Override public Object getOuterClassInstance () { return outerClassInstance ; }
@ Override public SerializableMode getSerializableMode () { return serializableMode ; }
@ Override public MockName getMockName () { return mockName ; }
@ Override public Object getSpiedInstance () { return spiedInstance ; }
SerializableClass proxy = mockMaker . createMock ( serializableSettingsFor ( SerializableClass . class , SerializableMode.BASIC ) , dummyHandler () ) ;
OtherClass mock = mockMaker . createMock ( settingsWithConstructorFor ( OtherClass . class ) , dummyHandler () ) ;
SomeClass mock = mockMaker . createMock ( settingsFor ( SomeClass . class , SomeInterface . class ) , dummyHandler () ) ;
ClassWithDodgyConstructor mock = mockMaker . createMock ( settingsFor ( ClassWithDodgyConstructor . class ) , dummyHandler () ) ;
ClassWithoutConstructor proxy = mockMaker . createMock ( settingsFor ( ClassWithoutConstructor . class ) , dummyHandler () ) ;
SomeInterface proxy = mockMaker . createMock ( settingsFor ( SomeInterface . class ) , dummyHandler () ) ;
new MockitoMockKey ( params.mockedType , params.interfaces , params.serializableMode , params.stripAnnotations )
{ this . bytecodeGenerator = bytecodeGenerator ; typeCache = new TypeCache.WithInlineExpunction < MockitoMockKey > ( weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT ) ; }
{ return ! selfCallInfo . isSelfInvocation ( instance ) && isMock ( instance ) ; }
assertEquals ( STRING_CONSTANT , mock . getFoo () ) ;
{ verify ( mock , after ( NUMBER_CONSTANT ) . atLeast ( NUMBER_CONSTANT ) ) . oneArg ( CHAR_CONS ) ; fail ( STRING_CONSTANT ) ; }
if ( ! threads . awaitTermination ( NUMBER_CONSTANT , TimeUnit.MILLISECONDS ) ) { fail () ; }
if ( ! threads . awaitTermination ( NUMBER_CONSTANT , TimeUnit.MILLISECONDS ) ) { fail () ; }
assertEquals ( STRING_CONSTANT , mock . getValue () ) ;
{ TestedObject mock = mock ( TestedObject . class , CALLS_REAL_METHODS ) ; assertEquals ( STRING_CONSTANT , mock . getValue () ) ; }
assertEquals ( STRING_CONSTANT , mock.value ) ;
{ when ( mock . getValue () ) . thenCallRealMethod () ; assertEquals ( STRING_CONSTANT , mock . getValue () ) ; }
sb . append ( STRING_CONSTANT ) . append ( mock ) . append ( STRING_CONSTANT ) ;
singletonLock || classLoader == null ? BOOTSTRAP_LOCK : classLoader
{ return selfCallInfo . checkSuperCall ( instance ) && isMock ( instance ) ; }
@ Override public boolean isMock ( Object instance ) { return instance != interceptors.target && interceptors . containsKey ( instance ) ; }
@ Override public Throwable getFailure () { return testFailure ; }
assertEquals ( filterLineNo ( STRING_CONSTANT + TEST_NAME + STRING_CONSTANT + STRING_CONSTANT ) , filterLineNo ( logger . getLoggedInfo () ) ) ;
assertEquals ( filterLineNo ( STRING_CONSTANT + TEST_NAME + STRING_CONSTANT + STRING_CONSTANT ) , filterLineNo ( logger . getLoggedInfo () ) ) ;
String getTestName ( ) ;
catch ( org.mockito.creation.instance.InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + type . getSimpleName () + STRING_CONSTANT , e ) ; }
catch ( org.mockito.creation.instance.InstantiationException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Test ( expected = org.mockito.creation.instance.InstantiationException . class )
catch ( org.mockito.creation.instance.InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + mockedProxyType . getSuperclass () . getSimpleName () + STRING_CONSTANT , e ) ; }
if ( explosive . get () != null ) { throw new RuntimeException ( MyMockMaker . class . getName () ) ; }
return pluginType . cast ( new InstantiatorProvider2Adapter ( create ( InstantiatorProvider2 . class , className ) ) ) ;
{ instantiatorProvider = new InstantiatorProviderAdapter ( ( InstantiatorProvider ) impl ) ; }
{ return createInvocation ( target , method , args , superMethod , settings ) ; }
this . mockRef . get () . equals ( other.mockRef . get () )
public String getStuff () { return STRING_CONSTANT ; }
if ( ref == null ) { throw new IllegalStateException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . instanceRef = new MockWeakReference < Object > ( instance ) ;
T ref = this . ref . get () ;
this . instanceRef = new MockWeakReference < Object > ( instance ) ;
{ if ( throwableType == null ) { return abortNullExceptionType () ; } return thenThrow ( newInstance ( throwableType ) ) ; }
{ new ThrowsException ( new IOException () ) . validateFor ( createMethodInvocation () ) ; }
{ new ThrowsException ( new CharacterCodingException () ) . validateFor ( createMethodInvocation () ) ; }
new ThrowsException ( throwableToRaise ) . answer ( createMethodInvocation () ) ;
new ThrowsException ( mock ( Exception . class ) ) . answer ( createMethodInvocation () ) ;
new ThrowsException ( new IllegalStateException ( STRING_CONSTANT ) ) . answer ( createMethodInvocation () ) ;
{ if ( throwableType == null ) { mockingProgress () . reset () ; throw notAnException () ; } return thenThrow ( newInstance ( throwableType ) ) ; }
Set < Object > testInstances
{ if ( field . isAnnotationPresent ( u ) ) { throw unsupportedCombinationOfAnnotations ( annotation . getSimpleName () , u . getSimpleName () ) ; } }
if ( isPrimitiveOrWrapper ( valueClass ) && isPrimitiveOrWrapper ( referenceType ) ) { return Primitives . primitiveTypeOf ( valueClass ) . isAssignableFrom ( Primitives . primitiveTypeOf ( referenceType ) ) ; }
for ( Annotation firstParamAnnotation : firstParamAnnotations ) { if ( annotationClass . isAssignableFrom ( firstParamAnnotation . annotationType () ) ) { return ( T ) firstParamAnnotation ; } }
assertThat ( subList . isEmpty () ) . isTrue () ;
@ SuppressWarnings ( { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } )
assumeTrue ( ClassFileVersion . ofThisVm () . isAtLeast ( ClassFileVersion.JAVA_V7 ) ) ;
if ( isComingFromJDK ( type ) || isComingFromSignedJar ( type ) || isComingFromSealedPackage ( type ) ) { typeName = CODEGEN_PACKAGE + type . getSimpleName () ; }
{ super ( Opcodes.ASM6 , cv ) ; this . typeDescription = typeDescription ; }
@ SuppressWarnings ( STRING_CONSTANT ) public MockitoExtension () { this ( Strictness.STRICT_STUBS ) ; }
if ( rawArguments == matcherCount && isLastMatcherVarargMatcher ( matchers ) ) { return MATCH_EACH_VARARGS_WITH_LAST_MATCHER ; }
