{ if ( ! field . isSupported () ) { throw new UnsupportedOperationException ( STRING_CONSTANT + name + CHAR_CONS ) ; } }
text . length () <= sampleLen + NUMBER_CONSTANT
public DurationPrinter toPrinter () { return toFormatter () ; }
if ( value == NUMBER_CONSTANT && iPrintZeroSetting == PRINT_ZERO_RARELY ) { return - NUMBER_CONSTANT ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
String toString ( ) ;
int getMaximumValue ( ) ;
int getMinimumValue ( ) ;
DurationField getLeapDurationField ( ) ;
boolean isSupported ( ) ;
String getName ( ) ;
String toString ( ) ;
boolean isSupported ( ) ;
String getName ( ) ;
{ if ( chrono == iChronology ) { return this ; } return getAverageYearMonthType ( chrono ) ; }
builder . appendDecimal ( field , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return appendSignedDecimal ( iChronoUTC . centuryOfEra () , minDigits , maxDigits ) ; }
{ return appendDecimal ( iChronoUTC . yearOfCentury () , minDigits , maxDigits ) ; }
{ return appendDecimal ( iChronoUTC . yearOfEra () , minDigits , maxDigits ) ; }
{ return appendSignedDecimal ( iChronoUTC . year () , minDigits , maxDigits ) ; }
{ return appendDecimal ( iChronoUTC . monthOfYear () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . weekyear () , minDigits , maxDigits ) ; }
{ return appendDecimal ( iChronoUTC . weekOfWeekyear () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . dayOfYear () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . dayOfMonth () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . dayOfWeek () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . clockhourOfHalfday () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . hourOfHalfday () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . clockhourOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . hourOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . minuteOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . minuteOfHour () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . secondOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . secondOfMinute () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . millisOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendDecimal ( iChronoUTC . millisOfSecond () , minDigits , NUMBER_CONSTANT ) ; }
ymd = new DateTimeFormatterBuilder ( iChrono ) . append ( yearElement () ) . append ( monthElement () ) . append ( dayOfMonthElement () ) . toFormatter ()
long scaled = fraction * iScalar / iRangeMillis ;
{ saveField ( new SavedField ( field , text , locale ) ) ; }
{ saveField ( new SavedField ( field , value ) ) ; }
sort ( savedFields , count ) ;
( value < NUMBER_CONSTANT ? NUMBER_CONSTANT : ( ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ) )
int digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
int digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . withMillis ( iField . roundHalfEven ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . withMillis ( iField . roundHalfCeiling ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . withMillis ( iField . roundHalfFloor ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . withMillis ( iField . roundCeiling ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . withMillis ( iField . roundFloor ( instant . getMillis () ) ) ; }
return ( DateTime ) instant . withMillis ( iField . set ( instant . getMillis () , value ) ) ;
return ( DateTime ) instant . withMillis ( iField . addWrapped ( instant . getMillis () , value ) ) ;
return ( DateTime ) instant . withMillis ( iField . add ( instant . getMillis () , value ) ) ;
return ( DateTime ) instant . withMillis ( iField . add ( instant . getMillis () , value ) ) ;
{ return instant . withMillis ( addTo ( instant . getMillis () , scalar ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . withMillis ( iField . roundHalfEven ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . withMillis ( iField . roundHalfCeiling ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . withMillis ( iField . roundHalfFloor ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . withMillis ( iField . roundCeiling ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . withMillis ( iField . roundFloor ( instant . getMillis () ) ) ; }
return ( DateOnly ) instant . withMillis ( iField . set ( instant . getMillis () , value ) ) ;
return ( DateOnly ) instant . withMillis ( iField . addWrapped ( instant . getMillis () , value ) ) ;
return ( DateOnly ) instant . withMillis ( iField . add ( instant . getMillis () , value ) ) ;
return ( DateOnly ) instant . withMillis ( iField . add ( instant . getMillis () , value ) ) ;
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . withMillis ( iField . roundHalfEven ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . withMillis ( iField . roundHalfCeiling ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . withMillis ( iField . roundHalfFloor ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . withMillis ( iField . roundCeiling ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . withMillis ( iField . roundFloor ( instant . getMillis () ) ) ; }
return ( TimeOnly ) instant . withMillis ( iField . set ( instant . getMillis () , value ) ) ;
return ( TimeOnly ) instant . withMillis ( iField . addWrapped ( instant . getMillis () , value ) ) ;
return ( TimeOnly ) instant . withMillis ( iField . add ( instant . getMillis () , value ) ) ;
return ( TimeOnly ) instant . withMillis ( iField . add ( instant . getMillis () , value ) ) ;
ImpreciseCutoverField ( DateTimeField julianField , DateTimeField gregorianField ) { this ( julianField , gregorianField , null , false ) ; }
{ this ( julianField , gregorianField , iCutoverInstant , false ) ; }
{ return appendSignedDecimal ( iChronoUTC . weekyear () , minDigits , maxDigits ) ; }
int newYear = year + FieldUtils . safeToInt ( value ) ;
int wrapped = FieldUtils . getWrappedValue ( year , value , getMinimumValue () , getMaximumValue () ) ;
{ return localToUTC ( getBase () . getDateTimeMillis ( year , monthOfYear , dayOfMonth , millisOfDay ) ) ; }
{ return localToUTC ( getBase () . getTimeOnlyMillis ( hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ) ; }
instant = getBase () . getTimeOnlyMillis ( instant ) ;
int newWeekyear = weekyear + FieldUtils . safeToInt ( value ) ;
int wrapped = FieldUtils . getWrappedValue ( weekyear , value , getMinimumValue () , getMaximumValue () ) ;
DateTimeOfYear dtOfYear = getStartOfYear () ;
fields.centuryOfEra = new DividedDateTimeField ( ISOYearOfEraDateTimeField.INSTANCE , STRING_CONSTANT , STRING_CONSTANT , NUMBER_CONSTANT ) ;
{ return DurationType . getMillisType () ; }
{ return DurationType . getAverageYearMonthType () ; }
{ return PRECISE_YEAR_MONTH_TYPE ; }
{ return AVERAGE_YEAR_MONTH_TYPE ; }
{ iChronology = selectChronologyUTC ( chronology ) ; iMillis = resetUnsupportedFields ( toLocalTime ( DateTimeUtils . currentTimeMillis () , chronology , iChronology ) ) ; }
{ super(); iChronology = selectChronology ( chronology ) ; iMillis = DateTimeUtils . currentTimeMillis () ; }
{ super(); iChronology = ISOChronology . getInstance ( zone ) ; iMillis = DateTimeUtils . currentTimeMillis () ; }
{ super(); iChronology = ISOChronology . getInstance () ; iMillis = DateTimeUtils . currentTimeMillis () ; }
getZone () == DateTimeZone.UTC
if ( ! UTC . equals ( provider . getZone ( STRING_CONSTANT ) ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
DateTimeZone zone = cProvider . getZone ( id ) ;
DateTimeZone getZone ( ) ;
DateTimeZone zone = getZone () ;
DateTimeZone zone = getZone () ;
return new MutableDateTime ( getMillis ( base , chronology . getZone () ) , chronology ) ;
return new MutableDateTime ( getMillis ( base , zone ) , getChronology () . withZone ( zone ) ) ;
DateTimeZone zone = getZone () ;
return new DateTime ( getMillis ( base , chronology . getZone () ) , chronology ) ;
return new DateTime ( getMillis ( base , zone ) , getChronology () . withZone ( zone ) ) ;
if ( this instanceof DateTime && getZone () == zone ) { return ( DateTime ) this ; }
private Object readResolve () { return getInstance ( getBase () . getZone () ) ; }
sb . append ( getZone () . getID () ) ;
public Chronology withUTC () { return withZone ( DateTimeZone.UTC ) ; }
getZone () == DateTimeZone.UTC
private Object readResolve () { return getInstance ( getBase () . getZone () ) ; }
private Object readResolve () { return getInstance ( getBase () . getZone () ) ; }
assertSame ( zone , BuddhistChronology . getInstance ( zone ) . getZone () ) ;
assertSame ( zone , BuddhistChronology . getInstance () . getZone () ) ;
public DateTimeZone getZone () { return null ; }
assertEquals ( msg + STRING_CONSTANT , z , dt . getZone () ) ;
private Object writeReplace () { return new Stub ( getZone () ) ; }
getBase () . getZone () == DateTimeZone.UTC
DateTimeZone zone = getZone () ;
if ( chrono != null && chrono . getZone () == zone ) { return chrono ; }
return chrono . withZone ( DateTimeZone . getDefault () ) ;
if ( chrono == null ) { zone = DateTimeZone . getDefault () ; } else { zone = chrono . getZone () ; }
DateTimeZone zone = getZone () ;
DateTimeZone getZone ( ) ;
DateTimeZone zone = getZone () ;
private Object readResolve () { return getInstance ( getBase () . getZone () ) ; }
if ( zone == null ) { zone = getZone () ; }
if ( zone == null ) { zone = getZone () ; }
if ( zone == null ) { zone = getZone () ; }
DateTimeZone zone = chrono . getZone () ;
DateTimeZone baseZone = base . getZone () ;
{ if ( base == null || isMatchingType ( base ) ) { return getMillis () ; } return getMillis ( base , base . getZone () ) ; }
DateTimeZone zone = chronology . getZone () ;
DateTimeZone zone = original . getZone () ;
public Chronology withUTC () { return withZone ( DateTimeZone.UTC ) ; }
DateTimeZone zone = instant . getZone () ;
DateTimeZone zone = chrono . getZone () ;
if ( zone == null ) { zone = getZone () ; }
{ return print ( millisUTC , chrono . getZone () ) ; }
if ( zone == null ) { zone = getZone () ; }
if ( zone == null ) { zone = getZone () ; }
{ printTo ( out , millisUTC , chrono . getZone () ) ; }
{ printTo ( buf , millisUTC , chrono . getZone () ) ; }
getZone ()
ZonedDurationField zonedField = new ZonedDurationField ( field , getZone () ) ;
DateTimeZone zone = getZone () ;
{ return localToUTC ( getBase () . getDateTimeMillis ( instant + getZone () . getOffset ( instant ) , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ) ; }
