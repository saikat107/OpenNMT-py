{ if ( ! field . isSupported () ) { throw new UnsupportedOperationException ( STRING_CONSTANT + name + STRING_CONSTANT ) ; } }
text . length () <= sampleLen
public DurationPrinter toPrinter () { return toPrinter ( iFormatters ) ; }
if ( value == NUMBER_CONSTANT && iPrintZeroSetting == PRINT_ZERO_NEVER ) { return - NUMBER_CONSTANT ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
public String toString ( ) ;
public int getMaximumValue ( ) ;
public int getMinimumValue ( ) ;
public DurationField getLeapDurationField ( ) ;
public boolean isSupported ( ) ;
public String getName ( ) ;
public String toString ( ) ;
public boolean isSupported ( ) ;
public String getName ( ) ;
{ if ( chrono == iChronology ) { return this ; } return new ISOYearMonthType ( iChronology ) ; }
builder . appendNumeric ( field , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return appendSignedNumeric ( iChronoUTC . centuryOfEra () , minDigits , maxDigits ) ; }
{ return appendNumeric ( iChronoUTC . yearOfCentury () , minDigits , maxDigits ) ; }
{ return appendNumeric ( iChronoUTC . yearOfEra () , minDigits , maxDigits ) ; }
{ return appendSignedNumeric ( iChronoUTC . year () , minDigits , maxDigits ) ; }
{ return appendNumeric ( iChronoUTC . monthOfYear () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . weekyear () , minDigits , maxDigits ) ; }
{ return appendNumeric ( iChronoUTC . weekOfWeekyear () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . dayOfYear () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . dayOfMonth () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . dayOfWeek () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . clockhourOfHalfday () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . hourOfHalfday () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . clockhourOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . hourOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . minuteOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . minuteOfHour () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . secondOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . secondOfMinute () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . millisOfDay () , minDigits , NUMBER_CONSTANT ) ; }
{ return appendNumeric ( iChronoUTC . millisOfSecond () , minDigits , NUMBER_CONSTANT ) ; }
ymd = new DateTimeFormatterBuilder ( iChrono ) . append ( yearElement () ) . append ( monthElement () ) . append ( dayElement () ) . toFormatter ()
long scaled = fraction * iScaler / iRangeMillis ;
{ iSavedFields . add ( new SavedField ( field , text , locale ) ) ; }
{ iSavedFields . add ( new SavedField ( field , value ) ) ; }
Arrays . sort ( savedFields , NUMBER_CONSTANT , count ) ;
( value < NUMBER_CONSTANT ? NUMBER_CONSTANT : ( ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ) )
int digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
int digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . toCopy ( iField . roundHalfEven ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . toCopy ( iField . roundHalfCeiling ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . toCopy ( iField . roundHalfFloor ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . toCopy ( iField . roundCeiling ( instant . getMillis () ) ) ; }
{ DateTime instant = iInstant ; return ( DateTime ) instant . toCopy ( iField . roundFloor ( instant . getMillis () ) ) ; }
return ( DateTime ) instant . toCopy ( iField . set ( instant . getMillis () , value ) ) ;
return ( DateTime ) instant . toCopy ( iField . addWrapped ( instant . getMillis () , value ) ) ;
return ( DateTime ) instant . toCopy ( iField . add ( instant . getMillis () , value ) ) ;
return ( DateTime ) instant . toCopy ( iField . add ( instant . getMillis () , value ) ) ;
{ return instant . toCopy ( addTo ( instant . getMillis () , scalar ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . toCopy ( iField . roundHalfEven ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . toCopy ( iField . roundHalfCeiling ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . toCopy ( iField . roundHalfFloor ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . toCopy ( iField . roundCeiling ( instant . getMillis () ) ) ; }
{ DateOnly instant = iInstant ; return ( DateOnly ) instant . toCopy ( iField . roundFloor ( instant . getMillis () ) ) ; }
return ( DateOnly ) instant . toCopy ( iField . set ( instant . getMillis () , value ) ) ;
return ( DateOnly ) instant . toCopy ( iField . addWrapped ( instant . getMillis () , value ) ) ;
return ( DateOnly ) instant . toCopy ( iField . add ( instant . getMillis () , value ) ) ;
return ( DateOnly ) instant . toCopy ( iField . add ( instant . getMillis () , value ) ) ;
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . toCopy ( iField . roundHalfEven ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . toCopy ( iField . roundHalfCeiling ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . toCopy ( iField . roundHalfFloor ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . toCopy ( iField . roundCeiling ( instant . getMillis () ) ) ; }
{ TimeOnly instant = iInstant ; return ( TimeOnly ) instant . toCopy ( iField . roundFloor ( instant . getMillis () ) ) ; }
return ( TimeOnly ) instant . toCopy ( iField . set ( instant . getMillis () , value ) ) ;
return ( TimeOnly ) instant . toCopy ( iField . addWrapped ( instant . getMillis () , value ) ) ;
return ( TimeOnly ) instant . toCopy ( iField . add ( instant . getMillis () , value ) ) ;
return ( TimeOnly ) instant . toCopy ( iField . add ( instant . getMillis () , value ) ) ;
ImpreciseCutoverField ( DateTimeField julianField , DateTimeField gregorianField ) { this ( julianField , gregorianField , null ) ; }
{ this ( julianField , gregorianField , iCutoverInstant ) ; }
{ return appendDecimal ( iChronoUTC . weekyear () , minDigits , maxDigits ) ; }
int newYear = year + Utils . safeToInt ( value ) ;
int wrapped = Utils . getWrappedValue ( year , value , getMinimumValue () , getMaximumValue () ) ;
{ return localToUTC ( iChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , millisOfDay ) ) ; }
{ return localToUTC ( iChronology . getTimeOnlyMillis ( hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ) ; }
instant = iChronology . getTimeOnlyMillis ( instant ) ;
int newWeekyear = weekyear + Utils . safeToInt ( value ) ;
int wrapped = Utils . getWrappedValue ( weekyear , value , getMinimumValue () , getMaximumValue () ) ;
DateTimeOfYear dtOfYear = START_OF_YEAR ;
fields.centuryOfEra = new DividedDateTimeField ( fields.yearOfEra , STRING_CONSTANT , STRING_CONSTANT , NUMBER_CONSTANT ) ;
{ return DurationType . getAverageYearMonthType () ; }
{ return DurationType . getMillisType () ; }
{ return new PreciseYearMonthType ( ISOChronology . getInstanceUTC () ) ; }
{ return new AverageYearMonthType ( ISOChronology . getInstanceUTC () ) ; }
{ iChronology = selectChronologyUTC ( chronology ) ; iMillis = resetUnsupportedFields ( toLocalTime ( System . currentTimeMillis () , chronology , iChronology ) ) ; }
{ super(); iChronology = selectChronology ( chronology ) ; iMillis = System . currentTimeMillis () ; }
{ super(); iChronology = ISOChronology . getInstance ( zone ) ; iMillis = System . currentTimeMillis () ; }
{ super(); iChronology = ISOChronology . getInstance () ; iMillis = System . currentTimeMillis () ; }
getDateTimeZone () == DateTimeZone.UTC
if ( ! UTC . equals ( provider . getDateTimeZone ( STRING_CONSTANT ) ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
DateTimeZone zone = cProvider . getDateTimeZone ( id ) ;
DateTimeZone getDateTimeZone ( ) ;
DateTimeZone zone = getDateTimeZone () ;
DateTimeZone zone = getDateTimeZone () ;
return new MutableDateTime ( getMillis ( base , chronology . getDateTimeZone () ) , chronology ) ;
return new MutableDateTime ( getMillis ( base , zone ) , getChronology () . withDateTimeZone ( zone ) ) ;
DateTimeZone zone = getDateTimeZone () ;
return new DateTime ( getMillis ( base , chronology . getDateTimeZone () ) , chronology ) ;
return new DateTime ( getMillis ( base , zone ) , getChronology () . withDateTimeZone ( zone ) ) ;
if ( this instanceof DateTime && getDateTimeZone () == zone ) { return ( DateTime ) this ; }
private Object readResolve () { return getInstance ( getBase () . getDateTimeZone () ) ; }
sb . append ( getDateTimeZone () . getID () ) ;
public Chronology withUTC () { return withDateTimeZone ( DateTimeZone.UTC ) ; }
getDateTimeZone () == DateTimeZone.UTC
private Object readResolve () { return getInstance ( getBase () . getDateTimeZone () ) ; }
private Object readResolve () { return getInstance ( getBase () . getDateTimeZone () ) ; }
assertSame ( zone , BuddhistChronology . getInstance ( zone ) . getDateTimeZone () ) ;
assertSame ( zone , BuddhistChronology . getInstance () . getDateTimeZone () ) ;
public DateTimeZone getDateTimeZone () { return null ; }
assertEquals ( msg + STRING_CONSTANT , z , dt . getDateTimeZone () ) ;
private Object writeReplace () { return new Stub ( getDateTimeZone () ) ; }
getBase () . getDateTimeZone () == DateTimeZone.UTC
DateTimeZone zone = getDateTimeZone () ;
if ( chrono != null && chrono . getDateTimeZone () == zone ) { return chrono ; }
return chrono . withDateTimeZone ( DateTimeZone . getDefault () ) ;
if ( chrono == null ) { zone = DateTimeZone . getDefault () ; } else { zone = chrono . getDateTimeZone () ; }
DateTimeZone zone = getDateTimeZone () ;
DateTimeZone getDateTimeZone ( ) ;
DateTimeZone zone = getDateTimeZone () ;
private Object readResolve () { return getInstance ( getBase () . getDateTimeZone () ) ; }
if ( zone == null ) { zone = getDateTimeZone () ; }
if ( zone == null ) { zone = getDateTimeZone () ; }
if ( zone == null ) { zone = getDateTimeZone () ; }
DateTimeZone zone = chrono . getDateTimeZone () ;
DateTimeZone baseZone = base . getDateTimeZone () ;
{ if ( base == null || isMatchingType ( base ) ) { return getMillis () ; } return getMillis ( base , base . getDateTimeZone () ) ; }
DateTimeZone zone = chronology . getDateTimeZone () ;
DateTimeZone zone = original . getDateTimeZone () ;
public Chronology withUTC () { return withDateTimeZone ( DateTimeZone.UTC ) ; }
DateTimeZone zone = instant . getDateTimeZone () ;
DateTimeZone zone = chrono . getDateTimeZone () ;
if ( zone == null ) { zone = getDateTimeZone () ; }
{ return print ( millisUTC , chrono . getDateTimeZone () ) ; }
if ( zone == null ) { zone = getDateTimeZone () ; }
if ( zone == null ) { zone = getDateTimeZone () ; }
{ printTo ( out , millisUTC , chrono . getDateTimeZone () ) ; }
{ printTo ( buf , millisUTC , chrono . getDateTimeZone () ) ; }
getDateTimeZone ()
ZonedDurationField zonedField = new ZonedDurationField ( field , getDateTimeZone () ) ;
DateTimeZone zone = getDateTimeZone () ;
{ return localToUTC ( getBase () . getDateTimeMillis ( instant + getDateTimeZone () . getOffset ( instant ) , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ) ; }
