rhs . getToken ()
n . getToken ()
parent . getToken ()
rootNameNode . getToken ()
parent . getToken ()
Node newVar = IR . declaration ( child , n . getToken () ) . srcref ( n ) ;
n . getToken ()
n . getToken ()
notChild . getToken ()
n . getToken ()
node . getToken ()
{ switch ( n . getToken () ) { case CALL : annotateCalls ( n ) ; break; default: break; } }
assertThat ( enumTypeNode . getToken () ) . isEqualTo ( Token.BANG ) ;
n . getToken ()
{ switch ( n . getToken () ) { case CALL : visitCall ( t , n ) ; break; default: break; } }
if ( typeExprNode . getToken () == Token.QMARK && ! typeExprNode . hasChildren () ) { return true ; }
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
assertEquals ( Token.VAR , var . getToken () ) ;
n . getToken () == type
n . getToken ()
n . getToken ()
n . getToken ()
n . getParent () . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
definitionParent . getToken ()
throw new RuntimeException ( STRING_CONSTANT + defSite . getToken () ) ;
n . getToken ()
n . getToken ()
Preconditions . checkState ( nameNode . isGetProp () , STRING_CONSTANT , nameNode . getToken () ) ;
n . getToken ()
Token exprKind = expr . getToken () ;
expr . getToken ()
insideQualifiedName || propAccessNode . getParent () . getToken () != Token.ASSIGN
expr . getToken ()
lvalue . getToken ()
Token tokenType = expr . getToken () ;
{ warnInvalidOperand ( expr , expr . getToken () , STRING_CONSTANT , lhsType + STRING_CONSTANT + rhsType ) ; }
if ( ! commonTypes . isNumberScalarOrObj ( pair.type ) ) { warnInvalidOperand ( child , expr . getToken () , JSType.NUMBER , pair.type ) ; }
Token exprKind = expr . getToken () ;
{ warnings . add ( JSError . make ( expr , UNKNOWN_EXPR_TYPE , expr . getToken () . toString () ) ) ; }
dn . getValue () . getToken ()
assertThat ( cont . getToken () ) . isSameAs ( Token.CONTINUE ) ;
assertThat ( breakStm . getToken () ) . isSameAs ( Token.BREAK ) ;
value . getToken ()
! registerFunc . isValidNodeType ( valueNode . getToken () )
! registerFunc . isValidNodeType ( value . getToken () )
n . getToken ()
changed = changed || finalValue . getToken () != info.initialValue . getToken () || ! finalValue . isEquivalentTo ( info.initialValue ) ;
{ if ( blockNode . getChildCount () == NUMBER_CONSTANT && blockNode . getFirstChild () . getToken () == Token.THROW ) { return true ; } return false ; }
n . getToken ()
arg . getToken () != desiredType
val . getToken ()
n . getToken ()
lhs . getToken ()
Token parentType = parent . getToken () ;
{ switch ( n . getToken () ) { case HOOK : case AND : case OR : return true ; default: return false ; } }
expr . getToken ()
n . getToken ()
Token type = ancestor . getToken () ;
node . getToken ()
node . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
Token actualType = cfgNodes . get ( i ) . getValue () . getToken () ;
if ( source . getToken () == startToken ) { assertFalse ( STRING_CONSTANT + startToken + STRING_CONSTANT + STRING_CONSTANT , cfg . isImplicitReturn ( dest ) ) ; return; }
if ( source . getToken () == startToken && cfg . isImplicitReturn ( dest ) ) { return; }
return enclosingNode != null && enclosingNode . getToken () != Token.FUNCTION ;
n . getToken ()
n . getToken ()
expr . getRoot () . getToken ()
n . getToken ()
refParent . getToken ()
anc . getToken ()
parent . getToken ()
n . getToken ()
grandparent . getToken ()
n . getToken ()
n . getToken ()
{ switch ( n . getToken () ) { case AND : case OR : case HOOK : return true ; default: return false ; } }
assertEquals ( Token.STRING , n . getToken () ) ;
{ assertEquals ( Token.STRING , n . getToken () ) ; visited . append ( n . getString () ) ; }
n . getToken ()
input . getToken ()
parent . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
Token type = n . getToken () ;
next . getToken ()
value . getToken ()
n . getToken ()
return parent != null && parent . getToken () == Token.EXPONENT && parent . getFirstChild () == n ;
{ return NodeUtil . precedence ( n . getToken () ) < minPrecedence ; }
{ switch ( n . getToken () ) { case LET : case CONST : case FUNCTION : case CLASS : case DO : return true ; default: return false ; } }
while ( firstNonOperator . getToken () == op ) { firstNonOperator = firstNonOperator . getFirstChild () ; }
n . getToken ()
n . getToken ()
c . getToken ()
last . getToken ()
n . getToken ()
n . getToken ()
switch ( n . getToken () ) { case FUNCTION : if ( n . isArrowFunction () ) { visitArrowFunction ( t , n ) ; } break; default: break; }
value . getToken ()
{ Token type = n . getToken () ; return ( type == Token.INC || type == Token.DEC ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT + node . getToken () ) ; }
Token declarationType = declarationNode . getToken () ;
{ newNode = IR . declaration ( newLHS , newRHS , parent . getToken () ) ; }
{ newNode = IR . declaration ( newLHS , newRHS , parent . getToken () ) ; }
n . getToken ()
n . getToken ()
int parentPrecedence = NodeUtil . precedence ( n . getToken () ) ;
node . getToken ()
n . getToken ()
if ( isSimpleOp ) { msg = STRING_CONSTANT + n . getToken () . toString () . toLowerCase () + STRING_CONSTANT ; }
assertEquals ( Token.SCRIPT , global . getDeclaration () . getNode () . getToken () ) ;
assertEquals ( Token.GETPROP , refs . get ( NUMBER_CONSTANT ) . getNode () . getToken () ) ;
assertEquals ( Token.GETPROP , refs . get ( NUMBER_CONSTANT ) . getNode () . getToken () ) ;
assertEquals ( Token.NAME , refs . get ( NUMBER_CONSTANT ) . getNode () . getToken () ) ;
if ( ! propName . isString () ) { throw new IllegalStateException ( STRING_CONSTANT + propName . getToken () ) ; }
if ( ! propName . isString () ) { throw new IllegalStateException ( STRING_CONSTANT + propName . getToken () ) ; }
Token parentType = parent . getToken () ;
parent . getToken ()
n . getToken ()
Token type = n . getToken () ;
parent . getToken ()
Token nodeType = input . getToken () ;
Token type = current . getToken () ;
type != null && type . getToken () != Token.ARRAY_TYPE
if ( invalidInitializers . contains ( initializer . getToken () ) ) { errorReporter . error ( STRING_CONSTANT , sourceName , lineno ( loopNode.initializer ) , charno ( loopNode.initializer ) ) ; }
if ( invalidInitializers . contains ( initializer . getToken () ) ) { errorReporter . error ( STRING_CONSTANT , sourceName , lineno ( loopNode.initializer ) , charno ( loopNode.initializer ) ) ; }
Token nType = n . getToken () ;
{ switch ( n . getToken () ) { case FOR : case FOR_OF : case WHILE : case DO : return true ; default: return false ; } }
{ switch ( n . getToken () ) { case FOR : case FOR_OF : case WHILE : case DO : case SWITCH : return true ; default: return false ; } }
n . getToken ()
n . getToken ()
switch ( n . getToken () ) { case GETPROP : return n . getLastChild () . getString () ; case MEMBER_FUNCTION_DEF : return n . getString () ; default: break; }
expr . getToken ()
expr . getToken ()
n . getToken ()
this . getToken ()
this . getToken ()
this . getToken ()
this . getToken ()
Preconditions . checkArgument ( source == null || Token.FUNCTION == source . getToken () ) ;
Preconditions . checkArgument ( source == null || Token.FUNCTION == source . getToken () ) ;
int expectedArity = Token . arity ( n . getToken () ) ;
switch ( n . getToken () ) { case NAME : validateName ( n ) ; break; case GETPROP : validateGetProp ( n ) ; break; default: break; }
catch ( UnsupportedOperationException e ) { violation ( STRING_CONSTANT + n . getToken () , n ) ; }
{ validateChildCount ( n , NUMBER_CONSTANT ) ; validateNameDeclarationHelper ( n . getToken () , n ) ; }
{ if ( NodeUtil . isNameDeclaration ( n ) ) { validateNameDeclarationHelper ( n . getToken () , n ) ; } else { validateOptionalExpression ( n ) ; } }
if ( body . getToken () == Token.BLOCK ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
n . getFirstChild () . getToken () == Token.EXPORT_SPECS
secondChild . getToken ()
n . getToken ()
control . getToken ()
n . getToken ()
switch ( n . getParent () . getToken () ) { case VAR : case CATCH : names . add ( n . getString () ) ; break; default: break; }
Token type = n . getToken () ;
switch ( c . getToken () ) { case FUNCTION : case AND : case OR : case HOOK : return true ; default: break; }
cArg . getToken ()
Token type = parent . getToken () ;
{ @ Override public boolean apply ( Node n ) { return type == n . getToken () ; } }
n . getToken ()
FlowScope rightScope = reverseInterpreter . getPreciserScopeKnowingConditionOutcome ( left , leftOutcome . getOutcomeFlowScope ( left . getToken () , nIsAnd ) , nIsAnd ) ;
left . getToken ()
n . getToken ()
newScope = reverseInterpreter . getPreciserScopeKnowingConditionOutcome ( condition , conditionOutcomes . getOutcomeFlowScope ( condition . getToken () , branch == Branch.ON_TRUE ) , branch == Branch.ON_TRUE ) ;
n . getToken ()
n . getToken ()
n . getToken ()
namedImports . getToken () == Token.IMPORT_SPECS
n . getToken ()
n . getToken ()
{ assertEquals ( Token.FUNCTION , function . getToken () ) ; assertEquals ( name , NodeUtil . getName ( function ) ) ; }
n . getParent () . getToken ()
arg . getToken ()
isASTNormalized () && Token.NAME == constructorNameNode . getToken ()
result . getToken ()
node . getToken ()
Token parentType = parent . getToken () ;
n . getToken ()
export . getFirstChild () . getToken () == Token.EXPORT_SPECS
Token type = nextNode . getToken () ;
n . getToken ()
{ if ( typeNode . getToken () == Token.BANG ) { typeNode = typeNode . getFirstChild () ; } return typeNode ; }
n . getToken ()
n . getToken ()
Node decl = IR . declaration ( cls.name . cloneTree () , cls.constructor.value , exprRoot . getToken () ) . srcref ( exprRoot ) ;
parent . getToken ()
if ( fieldTypeNode . getToken () == Token.COLON ) { fieldNameNode = fieldTypeNode . getFirstChild () ; hasType = true ; }
Token pType = parent . getToken () ;
assertEquals ( Token.NEW , callsiteNode . getToken () ) ;
assertEquals ( Token.CALL , callsiteNode . getToken () ) ;
assertEquals ( Token.CALL , callsiteNode . getToken () ) ;
Token type = n . getToken () ;
parent . getToken () == Token.PARAM_LIST
aliasReference . getToken () == Token.STRING_KEY
n . getToken ()
{ if ( n . getToken () == Token.INSTANCEOF ) { reportIfNonObject ( t , n . getFirstChild () , SUSPICIOUS_INSTANCEOF_LEFT_OPERAND ) ; } }
{ if ( n . getToken () == Token.IN ) { reportIfNonObject ( t , n . getLastChild () , SUSPICIOUS_IN_OPERATOR ) ; } }
n . getToken ()
n . getToken ()
n . getToken ()
Token operatorToken = condition . getToken () ;
builder . append ( n . getToken () . toString () ) ;
decl.node . getParent () . getToken ()
Preconditions . checkArgument ( n . isGetProp () , STRING_CONSTANT , n . getToken () , n ) ;
Token nType = n . getToken () ;
val . getToken () == Token.OR
n . getToken ()
n . getToken ()
if ( typeNode . getToken () != Token.EQUALS ) { report ( typeNode , DEFAULT_PARAM_MUST_BE_MARKED_OPTIONAL ) ; }
n . getToken ()
n . getToken ()
n . getToken ()
typeNode != null && typeNode . getToken () == Token.STRING
c . getToken ()
left . getToken ()
TernaryValue result = evaluateComparison ( n . getToken () , left , right , shouldUseTypes ) ;
Node result = performArithmeticOp ( n . getToken () , left , right ) ;
Token type = n . getToken () ;
n . getToken ()
argumentNode . getToken ()
n . getToken ()
n . getToken ()
subtree . getToken ()
subtree . getToken ()
while ( moveIt . hasNext () ) { actualTokens . add ( moveIt . next () . getToken () ) ; }
node . getToken () == Token.CALL
Token parentType = useParent . getToken () ;
Token nodeType = n . getToken () ;
Token parentNodeType = parent . getToken () ;
key . getToken ()
n . getToken ()
Token type = parent . getToken () ;
n . getToken ()
{ Preconditions . checkState ( sourceName != null ) ; Preconditions . checkState ( n . getToken () == type , n ) ; }
n . getToken ()
n . getToken ()
node . getToken ()
assertEquals ( Token.FUNCTION , fooNode . getToken () ) ;
n . getToken ()
Token type = n . getToken () ;
{ switch ( n . getFirstChild () . getToken () ) { case HOOK : case AND : case OR : return true ; default: break; } }
{ switch ( n . getToken () ) { case BREAK : case CONTINUE : case RETURN : case THROW : return true ; default: return false ; } }
blockChild . getToken ()
n . getToken ()
subtree . getToken ()
parent . getToken ()
ancestor . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
if ( node . getToken () == type ) { matchingNodes . add ( node ) ; }
n . getToken ()
declType = variable . getToken () ;
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getParent () . getToken ()
Preconditions . checkArgument ( node . isNew () , STRING_CONSTANT , node . getToken () ) ;
Preconditions . checkArgument ( node . isCall () , STRING_CONSTANT , node . getToken () ) ;
Preconditions . checkArgument ( node . isHook () , STRING_CONSTANT , node . getToken () ) ;
Preconditions . checkArgument ( ( node . isAnd () ) || ( node . isOr () ) , STRING_CONSTANT , node . getToken () ) ;
Preconditions . checkArgument ( hook . isHook () , STRING_CONSTANT , hook . getToken () ) ;
Preconditions . checkArgument ( ( original . isAnd () ) || ( original . isOr () ) , STRING_CONSTANT , original . getToken () ) ;
parent . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
node . getToken ()
Token secondArgumentType = secondArgument . getToken () ;
n . getToken ()
int offset = provideStringNode == null ? NUMBER_CONSTANT : getSourceInfoOffset () ;
{ return ! type . isUnresolved () ; }
return isKnown ( n ) && ! isTop ( n ) && isClassType ( n ) && ! isNativeObjectType ( n ) && ! isWhitelistedType ( n ) ;
! isTypeVariable ( n )
! isTypeVariable ( n )
if ( type == null || type . isUnknownType () || type . isTop () ) { return new MatchResult ( allowLooseMatches , allowLooseMatches ) ; }
options . setPreserveGoogProvidesAndRequires ( true ) ;
compilerOptions . setPreserveGoogProvidesAndRequires ( true ) ;
importNode . useSourceInfoFrom ( export ) ;
n . detach () ;
Node stringKey = IR . stringKey ( name , memberDef . getFirstChild () . detach () ) ;
if ( parent . isExprResult () ) { parent . detach () ; } else { parent . replaceChild ( n , elemValue ) ; }
{ parent . getParent () . detach () ; compiler . reportCodeChange () ; }
{ if ( n . getParent () != null ) { n . detach () ; compiler . reportCodeChange () ; } }
Node body = IR . block ( IR . returnNode ( returnValue . detach () ) ) ;
parent . replaceChild ( export , declaration . detach () ) ;
newBlock . detach () ;
typeString . detach () ;
if ( rep . isExprResult () ) { rep = rep . getFirstChild () ; rep . detach () ; }
{ changeProxy . replaceWith ( grandparent , parent , parent . getLastChild () . detach () ) ; }
Node replacement = firstArg . detach () ;
{ rhs . detach () ; ancestor . replaceChild ( last , rhs ) ; }
rhs . detach () ;
Node child = n . getLastChild () . detach () ;
argNode . detach () ;
assignmentValue . detach () ;
Node simplified = new Node ( type , condition . detach () , simplifyShortCircuitBranch ( body ) ) . useSourceInfoIfMissingFrom ( hook ) ;
{ if ( original . getParent () != null ) { original . detach () ; } replacements . add ( original ) ; }
Node newGetProp = IR . getprop ( target . detach () , prop . detach () ) ;
if ( i == NUMBER_CONSTANT && first . getString () . isEmpty () ) { add = add . getSecondChild () . detach () ; }
for ( PrototypeMemberDeclaration declar : instance.declarations ) { block . addChildToBack ( declar.node . detach () ) ; }
{ if ( preserveGoogProvidesAndRequires && explicitNode . hasChildren () ) { return; } explicitNode . detach () ; compiler . reportCodeChange () ; }
if ( typeDeclaration != null ) { compiler . forwardDeclareType ( typeDeclaration ) ; parent . detach () ; compiler . reportCodeChange () ; }
Node value = n . getChildAtIndex ( NUMBER_CONSTANT ) . detach () ;
for ( Node closureRequire : requiresToBeRemoved ) { closureRequire . detach () ; compiler . reportCodeChange () ; }
arg . detach () ;
Node method = member . getLastChild () . detach () ;
stringKey = IR . stringKey ( ( member . isGetterDef () || member . getBooleanProp ( Node.COMPUTED_PROP_GETTER ) ) ? STRING_CONSTANT : STRING_CONSTANT , function . detach () )
constructor = member . getFirstChild () . detach () ;
for ( Node child : functionBody . children () ) { newBlock . addChildToBack ( child . detach () ) ; }
Node stringKey = IR . stringKey ( name , n . getFirstChild () . detach () ) ;
if ( subtree . getChildCount () == NUMBER_CONSTANT ) { subtree . getLastChild () . detach () ; }
{ for ( Node c : externs . children () ) { if ( ! c . hasChildren () ) { c . detach () ; } } }
if ( expected != null ) { expectedRoot = parseExpectedJs ( expected ) ; expectedRoot . detach () ; }
{ Node ancParent = ancestor . getParent () ; ancParent . replaceChild ( ancestor , ancestor . getLastChild () . detach () ) ; break; }
node . detach () ;
{ if ( node != null && node . getParent () != null ) { node . detach () ; } return node ; }
{ compiler . report ( JSError . make ( requireNode , MISSING_MODULE_OR_PROVIDE.level , MISSING_MODULE_OR_PROVIDE , legacyNamespace ) ) ; NodeUtil . getEnclosingStatement ( requireNode ) . detach () ; continue; }
moduleBlockNode . detach () ;
returnStatementNode . detach () ;
{ NodeUtil . getEnclosingStatement ( call ) . detach () ; }
private void updateGoogDeclareLegacyNamespace ( Node call ) { NodeUtil . getEnclosingStatement ( call ) . detach () ; }
if ( ! currentScript.declareLegacyNamespace ) { NodeUtil . getEnclosingStatement ( call ) . detach () ; }
if ( secondExpr != firstExpr ) { secondExpr . detach () ; } else { secondExpr = IR . nullNode () ; }
bind.target . detach () ;
declParent . detach () ;
{ if ( value != null ) { value . detach () ; } varNode = parent ; }
callbackFunction . detach () ;
{ objlit . removeChild ( key ) ; value . detach () ; }
Node replacement = value . detach () ;
Node destObj = n . getSecondChild () . detach () ;
Node newNode = new Node ( newType , left . detach () , newRight . detach () ) ;
if ( NodeUtil . isNumericResult ( left ) ) { parent . replaceChild ( n , left . detach () ) ; reportCodeChange () ; return left ; }
if ( root != null ) { root . detach () ; }
callNode . getParent () . replaceChild ( callNode , replacementNode . detach () ) ;
clinitAssignedValue . detach () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detach () ; reportCodeChange () ; return null ; }
{ block . replaceChild ( maybeIf , maybeIf . getLastChild () . detach () ) ; }
colon . addChildToBack ( member . detach () ) ;
n . detach () ;
for ( Node child : stringKeys ) { child . detach () ; }
member . detach () ;
indexSignature . detach () ;
comma . addChildToBack ( leftMostChild . detach () ) ;
Node condStatement = IR . exprResult ( cond . detach () ) . srcref ( cond ) ;
Node statement = IR . exprResult ( cond . detach () ) . useSourceInfoIfMissingFrom ( cond ) ;
n . getParent () . replaceChild ( n , caseBlock . detach () ) ;
{ maybeBreak . detach () ; reportCodeChange () ; }
{ subtree . detach () ; subtree = null ; }
{ subtree . getParent () . replaceChild ( subtree , right . detach () ) ; reportCodeChange () ; return right ; }
{ n . detach () ; }
var . detach () ;
Node newDeclaration = IR . var ( name . detach () ) . useSourceInfoFrom ( declarationList ) ;
inlineValue ( v , ref , value . detach () ) ;
Node opDetached = op . detach () ;
potentialCallee . detach () ;
{ expectedRoot = parseExpectedJs ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , expected ) ) ) ; expectedRoot . detach () ; }
if ( ! t . inGlobalScope () && NodeUtil . isHoistedFunctionDeclaration ( value ) ) { parent . addChildToFront ( value . detach () ) ; }
body . detach () ;
Node decl = IR . declaration ( pattern . detach () , IR . name ( tempVarName ) , declarationType ) ;
List < Node > assignments = new ArrayList <> () ;
List < Node > nodes = new ArrayList <> () ;
public JSType getJSTypeBeforeCast () { return ( JSType ) getTypeIBeforeCast () ; }
String externs = DEFAULT_EXTERNS + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
@ Override public TypeI evaluateTypeExpressionInGlobalScope ( JSTypeExpression expr ) { return createTypeFromCommentNode ( expr . getRoot () ) ; }
@ Override public boolean isInstanceType () { Preconditions . checkState ( this . isSingletonObj () ) ; return this . getNominalTypeIfSingletonObj () . isClassy () ; }
@ Override public boolean isUnresolved () { return isUnknown () ; }
return fn . isLooseSubtypeOf ( other.fn ) ;
UpdateThisAndArgumentsReferences updater = new UpdateThisAndArgumentsReferences ( compiler ) ;
{ this . passUnderTest = new NameBasedDefinitionProvider ( compiler , true ) ; this . compiler = compiler ; }
NameBasedDefinitionProvider defFinder = new NameBasedDefinitionProvider ( compiler , true ) ;
public void testHookOperators4 ( ) throws Exception { checkMarkedCalls ( STRING_CONSTANT + STRING_CONSTANT , ImmutableList . < String > of ( STRING_CONSTANT ) ) ; }
public DefinitionUseSiteFinder ( AbstractCompiler compiler ) { super ( compiler , false ) ; this . nameUseSiteMultimap = LinkedHashMultimap . create () ; }
defFinder = new NameBasedDefinitionProvider ( compiler , false ) ;
NameBasedDefinitionProvider defFinder = new NameBasedDefinitionProvider ( compiler , false ) ;
NameBasedDefinitionProvider defFinder = new NameBasedDefinitionProvider ( compiler , true ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.ADDING_PROPERTY_TO_NON_OBJECT , NewTypeInference.INEXISTENT_PROPERTY ) ;
typeCheck ( STRING_CONSTANT , NewTypeInference.ADDING_PROPERTY_TO_NON_OBJECT ) ;
if ( isInTestMode () ) { return new StringWriter () ; }
if ( isInTestMode () ) { return new StringWriter () ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
phaseopt . process ( externsNode , externAndJsRoot ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
passes . add ( checkVariableReferencesForTranspileOnly ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; }
if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; }
{ testSame ( ImmutableList . of ( NO_J2CL_SOURCE_FILE , NO_J2CL_SOURCE_FILE2 ) ) ; assertThat ( compiler . getAnnotation ( J2clSourceFileChecker.HAS_J2CL_ANNOTATION_KEY ) ) . isEqualTo ( Boolean.FALSE ) ; }
{ testSame ( ImmutableList . of ( NO_J2CL_SOURCE_FILE , J2CL_SOURCE_FILE , NO_J2CL_SOURCE_FILE2 ) ) ; assertThat ( compiler . getAnnotation ( J2clSourceFileChecker.HAS_J2CL_ANNOTATION_KEY ) ) . isEqualTo ( Boolean.TRUE ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } new StaticFieldGetterSetterInliner ( root ) . run () ; }
{ recvType = recvType . withProperty ( pname , JSType.UNKNOWN ) ; inEnv = updateLvalueTypeInEnv ( inEnv , obj , recvLvalue.ptr , recvType ) ; }
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( EXTERNS + STRING_CONSTANT , code + STRING_CONSTANT , null ) ;
RefactoringDriver driver = new RefactoringDriver.Builder ( scanner ) . addExternsFromCode ( STRING_CONSTANT + externs ) . addInputsFromCode ( originalCode ) . build () ;
ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT + externs ) )
isSomeUnknownType ( n )
{ tracker = new PerformanceTracker ( externsRoot , jsRoot , options.tracer , this . outStream ) ; addChangeHandler ( tracker . getCodeChangeHandler () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
phaseopt . process ( externsNode , n ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ process ( null , scriptRoot ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
passes . add ( checkVariableReferences ) ;
public static ResourceBundle getBundle ( String baseName , Locale locale ) { return getBundle ( baseName ) ; }
{ Preconditions . checkState ( ! this . isFinalized ) ; super . addUndeclaredProperty ( pname , defSite , this . commonTypes . UNKNOWN , false ) ; }
if ( type == null && isConstant ) { type = this . commonTypes . UNKNOWN ; }
this . randomProps . with ( pname , Property . make ( type == null ? this . commonTypes . UNKNOWN : type , type ) )
if ( ! t . isUnknown () && ! t . equals ( JSType . fromTypeVar ( getCommonTypes () , typeVar ) ) ) { return false ; }
if ( typeMap . isEmpty () ) { return Property . make ( getCommonTypes () . UNKNOWN , null ) ; }
{ NominalType thisWithoutTypemap = this . rawType . getAsNominalType () ; return thisWithoutTypemap . instantiateGenerics ( getCommonTypes () . MAP_TO_UNKNOWN ) ; }
JSType result = getCommonTypes () . TOP ;
JSType result = getCommonTypes () . BOTTOM ;
if ( ! isGeneric () || this . commonTypes . MAP_TO_UNKNOWN . equals ( concreteTypes ) ) { return substituteNominalGenerics ( concreteTypes ) ; }
FunctionTypeBuilder builder = new FunctionTypeBuilder ( f1.commonTypes ) ;
{ if ( ! f . isGeneric () ) { return f ; } return f . instantiateGenerics ( f.commonTypes.MAP_TO_UNKNOWN ) ; }
if ( ! this . commonTypes . allowMethodsAsFunctions && this . receiverType != null && other.receiverType == null ) { return false ; }
FunctionTypeBuilder builder = new FunctionTypeBuilder ( f1.commonTypes ) ;
optionalFormals . add ( JSType . join ( t , this . commonTypes . UNDEFINED ) ) ;
this == other || other.ns != null || ! other . getNominalType () . equals ( this . commonTypes . getObjectType () )
if ( other == this . commonTypes . TOP_OBJECTTYPE ) { return true ; }
if ( other == this . commonTypes . TOP_OBJECTTYPE ) { return true ; }
if ( newPropType . isBottom () ) { return newPropType . getCommonTypes () . BOTTOM_PROPERTY_MAP ; }
JSType result = commonTypes.BOTTOM ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) { return commonTypes.STRING ; }
recvType = recvType . removeType ( commonTypes.NULL ) ;
if ( propInferredFunType != null ) { rawType . addUndeclaredClassProperty ( pname , propInferredFunType , getProp ) ; } else { rawType . addUndeclaredClassProperty ( pname , commonTypes.UNKNOWN , getProp ) ; }
if ( t == null ) { t = commonTypes.UNKNOWN ; }
FunctionType getInstanceFunType = ( new FunctionTypeBuilder ( commonTypes ) ) . addRetType ( instanceType ) . buildFunction () ;
if ( t == null ) { t = commonTypes.UNKNOWN ; }
{ this . currentScope . addLocal ( varName , commonTypes.UNKNOWN , false , false ) ; }
JSType resultType = commonTypes.TOP ;
for ( String typedefName : localTypedefs . keySet () ) { locals . put ( typedefName , this . commonTypes . UNDEFINED ) ; }
{ isTypeVar = true ; type = JSType . fromTypeVar ( this . commonTypes , declaredType . getTypeVariableDefinedLocally ( name ) ) ; }
{ addNamespace ( qnameNode , new NamespaceLit ( this . commonTypes , qnameNode . getQualifiedName () , qnameNode ) ) ; }
{ this . root . setTypeI ( this . commonTypes . fromFunctionType ( declaredType . toFunctionType () ) ) ; }
{ if ( anyNumOrStr == null ) { return t . isSubtypeOf ( this . NUMBER_OR_STRING ) ; } return t . isSubtypeOf ( anyNumOrStr ) ; }
{ if ( numberOrNumber == null ) { return t . isSubtypeOf ( this . STRING ) ; } return t . isSubtypeOf ( stringOrString ) ; }
{ if ( numberOrNumber == null ) { return t . isSubtypeOf ( this . NUMBER ) ; } return t . isSubtypeOf ( numberOrNumber ) ; }
stringOrString = JSType . join ( this . STRING , stringInstance ) ;
numberOrNumber = JSType . join ( this . NUMBER , numberInstance ) ;
ObjectType getStringInstanceObjType () { return stringInstanceObjtype != null ? stringInstanceObjtype : this . TOP_OBJECTTYPE ; }
ObjectType getBooleanInstanceObjType () { return booleanInstanceObjtype != null ? booleanInstanceObjtype : this . TOP_OBJECTTYPE ; }
ObjectType getNumberInstanceObjType () { return numberInstanceObjtype != null ? numberInstanceObjtype : this . TOP_OBJECTTYPE ; }
public JSType getStringInstance () { return stringInstance != null ? stringInstance : this . STRING ; }
public JSType getBooleanInstance () { return booleanInstance != null ? booleanInstance : this . BOOLEAN ; }
public JSType getNumberInstance () { return numberInstance != null ? numberInstance : this . NUMBER ; }
public JSType getRegexpType () { return regexpInstance != null ? regexpInstance : this . UNKNOWN ; }
if ( this . arguments == null ) { return this . UNKNOWN ; }
if ( arrayType == null ) { return this . UNKNOWN ; }
return this . commonTypes . fromFunctionType ( ctorType ) ;
ObjectType arrayType = this . commonTypes . getArrayInstance () . getObjTypeIfSingletonObj () ;
if ( isTrueOrTruthy () ) { return this . commonTypes . FALSY ; } else if ( isFalseOrFalsy () ) { return TRUTHY ; }
return makeType ( lhs.commonTypes , newtype ) ;
{ JSType maybeScalar = ObjectType . mayTurnLooseObjectToScalar ( t , this . commonTypes ) ; if ( t != maybeScalar ) { return maybeScalar ; } }
JSType result = this . commonTypes . BOTTOM ;
JSType result = this . commonTypes . TOP ;
boolean noCycles = constructorType . addInterfaces ( extendedInterfaces . isEmpty () ? ImmutableSet . of ( this . commonTypes . getObjectType () ) : extendedInterfaces ) ;
NominalType builtinObject = this . commonTypes . getObjectType () ;
{ builder . addRetType ( this . commonTypes . UNDEFINED ) ; }
builder . addRestFormals ( t != null ? t : this . commonTypes . UNKNOWN ) ;
return t . isSingletonObjWithNull () ? t . removeType ( this . commonTypes . NULL ) : t ;
tdType = this . commonTypes . UNKNOWN ;
try { return getTypeFromCommentHelper ( n , registry , typeParameters ) ; } catch ( UnknownTypeException e ) { return this . commonTypes . UNKNOWN ; }
lvalue.type = lvalue.type . mayHaveProp ( pname ) ? lvalue.type . getProp ( pname ) : UNKNOWN ;
if ( doSlicing ) { pair.env = envPutType ( pair.env , name , declType != null ? declType : UNKNOWN ) ; }
! lvalueType . isSubtypeOf ( TOP_OBJECT )
if ( requiredType . mayHaveProp ( pname ) ) { reqPtype = requiredType . getProp ( pname ) ; } else { reqPtype = UNKNOWN ; }
return new EnvTypePair ( env , UNKNOWN ) ;
if ( formalType . isBottom () ) { formalType = UNKNOWN ; }
pair.type = BOOLEAN ;
JSType operandType = requiredType . isNumber () ? NUMBER : UNKNOWN ;
private EnvTypePair analyzeExprBwd ( Node expr , TypeEnv outEnv ) { return analyzeExprBwd ( expr , outEnv , UNKNOWN ) ; }
if ( outerType == null ) { outerType = UNKNOWN ; }
{ JSType tmp = t . getIndexedType () ; return tmp == null ? UNKNOWN : tmp ; }
{ reqPtype = specPtype = UNKNOWN ; }
if ( ! currentScope . hasThis () ) { mayWarnAboutGlobalThis ( expr , currentScope ) ; return new EnvTypePair ( inEnv , UNKNOWN ) ; }
return new EnvTypePair ( env , UNKNOWN ) ;
funType . isOptionalArg ( i ) && pair.type . equals ( UNDEFINED )
rhsPair.type = BOOLEAN ;
{ return analyzeExprFwd ( expr , inEnv , UNKNOWN , UNKNOWN ) ; }
if ( rootNs != null && rootNs . isSubtypeOf ( TOP_OBJECT ) ) { namespaceType = rootNs . getProp ( qname . getAllButLeftmost () ) ; }
return out ;
EnvTypePair lhsPair = analyzeExprBwd ( lhs , outEnv ) ;
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , this ) ; }
passes . add ( checkVariableReferencesForTranspileOnly ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
phaseopt . process ( externsNode , externAndJsRoot ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
this . rawType . isBuiltinWithName ( STRING_CONSTANT ) && NUMERIC_PATTERN . matcher ( pname ) . matches ()
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
public ProcessDefinesTest () { super ( DEFAULT_EXTERNS + STRING_CONSTANT ) ; allowSourcelessWarnings () ; }
assertThat ( jsDocInfoPrinter . print ( info ) ) . isEqualTo ( output ) ;
assertEquals ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , jsDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , jsDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , jsDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , jsDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , jsDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , jsDocInfoPrinter . print ( info ) ) ;
assertEquals ( STRING_CONSTANT , jsDocInfoPrinter . print ( info ) ) ;
phaseopt . process ( externsNode , n ) ;
{ process ( null , scriptRoot ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
passes . add ( checkVariableReferences ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
long stop () { return System . currentTimeMillis () - start ; }
replacement . setTypeI ( getNativeStringType () ) ;
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
phaseopt . process ( externsNode , externAndJsRoot ) ;
{ FindStaticMembers findStaticMembers = new FindStaticMembers () ; TranspilationPasses . processTranspile ( compiler , scriptRoot , findStaticMembers ) ; processInherits ( findStaticMembers.inheritsCalls ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
passes . add ( checkVariableReferencesForTranspileOnly ) ;
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new J2clEqualitySameRewriterPass ( compiler , j2clChangeTracker ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new J2clConstantHoisterPass ( compiler , j2clChangeTracker ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new J2clClinitPrunerPass ( compiler , j2clChangeTracker ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new J2clConstantHoisterPass ( compiler , null ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clClinitPrunerPass ( compiler , null ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clEqualitySameRewriterPass ( compiler , null ) ; }
Node moduleNode = newNode ( Token.MODULE_BODY ) ;
Node lhs = node . getFirstFirstChild () ;
Node clinitFunction = multiExpression . getFirstFirstChild () ;
Node methodName = member . getFirstFirstChild () ;
options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ;
public void disable_testClassMethodUnused2 () { this . mode = TypeInferenceMode.NEITHER ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { this . mode = TypeInferenceMode.NEITHER ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
{ passes . add ( flowSensitiveInlineVariables ) ; if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( lastRemoveUnusedVars () ) ; } }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler , false ) ; }
options . setFoldConstants ( true ) ;
options . setFoldConstants ( true ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler , true ) ; }
options . setRemoveDeadCode ( true ) ;
options . setRemoveDeadCode ( true ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ;
options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ;
public void testInvalidAnnotation5 ( ) throws Exception { testWarning ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
public void testInvalidAnnotation4 ( ) throws Exception { testWarning ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
public String toModuleName () { return ModuleNames . toModuleName ( path ) ; }
public String toJSIdentifier () { return ModuleNames . toJSIdentifier ( path ) ; }
{ requires . add ( file . resolveEs6Module ( arg ) . toModuleName () ) ; }
String globalModuleName = t . getInput () . getPath () . resolveEs6Module ( moduleName ) . toModuleName () ;
String moduleName = t . getInput () . getPath () . toModuleName () ;
String moduleName = t . getInput () . getPath () . resolveEs6Module ( moduleIdentifier . getString () ) . toModuleName () ;
{ moduleName = t . getInput () . getPath () . resolveEs6Module ( importName ) . toModuleName () ; }
ModuleLoader.ModulePath actual
String moduleName = t . getInput () . getPath () . toModuleName () ;
TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , this , true ) ;
{ errorReporter . warning ( STRING_CONSTANT + SimpleErrorReporter . getMessage0 ( messageId ) + BAD_TYPE_WIKI_LINK , getSourceName () , lineno , charno ) ; }
{ errorReporter . warning ( STRING_CONSTANT + SimpleErrorReporter . getMessage1 ( messageId , messageArg ) + BAD_TYPE_WIKI_LINK , getSourceName () , lineno , charno ) ; }
assertWarning ( STRING_CONSTANT , RhinoErrorReporter.JSDOC_MISSING_BRACES_WARNING , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ SourceMapObject sourceMapObject = SourceMapObjectParser . parse ( contents ) ; parse ( sourceMapObject , null ) ; }
SourceMapObject sourceMapObject = SourceMapObjectParser . parse ( contents ) ;
{ for ( MemberDefinition prop : PolymerPassStaticUtils . extractProperties ( objLit , compiler ) ) { prop.name . removeProp ( Node.JSDOC_INFO_PROP ) ; } }
PolymerPassStaticUtils . extractProperties ( objLit , compiler )
overwriteMembersIfPresent ( allProperties , PolymerPassStaticUtils . extractProperties ( descriptor , compiler ) ) ;
{ GwtProperties p = GwtProperties . load ( STRING_CONSTANT ) ; assertThat ( p . propertyNames () ) . isEmpty () ; }
return MODULE_JOINER . join ( Arrays . copyOf ( buffer , position ) ) ;
if ( options.coalesceVariableNames ) { passes . add ( coalesceVariableNames ) ; if ( options.foldConstants ) { passes . add ( peepholeOptimizationsOnce ) ; } }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ Preconditions . checkState ( hasInstanceType () , STRING_CONSTANT , this ) ; return typeOfThis . toObjectType () ; }
{ if ( sideEffectInfo . taintedLocals () . contains ( v ) ) { sideEffectInfo . setTaintsGlobalState () ; sideEffectInfo . resetLocalVars () ; break; } }
if ( defs == null ) { functionInfo . setTaintsGlobalState () ; break; }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
String currentJsSource = getCurrentJsSource () ;
Config config = ParserRunner . createConfig ( mode , Config.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , Config.RunMode.KEEP_GOING , null , true ) ;
return new ParseResult ( root , comments , features , p . getInlineSourceMap () ) ;
{ return createConfig ( languageMode , JsDocParsing.TYPES_ONLY , RunMode.STOP_AFTER_ERROR , extraAnnotationNames , true ) ; }
{ this ( config , errorReporter , source , offset , false , true ) ; }
{ this ( annotationWhitelist , JsDocParsing.TYPES_ONLY , RunMode.STOP_AFTER_ERROR , suppressionNames , languageMode , false ) ; }
Config config = new Config ( extraAnnotations , parseDocumentation , RunMode.STOP_AFTER_ERROR , extraSuppressions , LanguageMode.ECMASCRIPT3 , true ) ;
Config config = new Config ( extraAnnotations , JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , RunMode.KEEP_GOING , extraSuppressions , LanguageMode.ECMASCRIPT3 , true ) ;
n . getToken () == Token.DIV && n . getFirstChild () . isNumber () && n . getFirstChild () . getDouble () == NUMBER_CONSTANT
parent . getToken ()
parent . getToken ()
parent . getToken ()
value . getToken ()
node . getToken ()
parent . getToken ()
n . getToken ()
ancestor . getToken ()
{ switch ( node . getToken () ) { case GETTER_DEF : case SETTER_DEF : return true ; default: break; } return false ; }
switch ( key . getToken () ) { case STRING_KEY : case GETTER_DEF : case SETTER_DEF : case MEMBER_FUNCTION_DEF : return key . getString () ; default: break; }
{ switch ( node . getToken () ) { case STRING_KEY : case GETTER_DEF : case SETTER_DEF : case MEMBER_FUNCTION_DEF : return true ; default: break; } return false ; }
return parent != null && parent . getToken () == Token.ASSIGN && parent . getFirstChild () == n ;
current . getToken ()
{ switch ( parent . getToken () ) { case DECLARE : case EXPORT : return true ; default: return isStatementParent ( parent ) ; } }
switch ( parent . getToken () ) { case SCRIPT : case MODULE_BODY : case BLOCK : case LABEL : case NAMESPACE_ELEMENTS : return true ; default: return false ; }
n . getToken ()
n . getToken ()
n . getToken ()
parent . getToken ()
n . getToken ()
n . getToken ()
{ switch ( n . getToken () ) { case FOR : case FOR_OF : case DO : case WHILE : return true ; default: return false ; } }
n . getParent () . getToken ()
{ @ Override public boolean apply ( Node n ) { return n . getToken () == type ; } }
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
switch ( n . getToken () ) { case VOID : return true ; case NAME : return n . getString () . equals ( STRING_CONSTANT ) ; default: break; }
n . getToken ()
n . getToken ()
Preconditions . checkArgument ( callNode . isNew () , STRING_CONSTANT , callNode . getToken () ) ;
n . getToken ()
val . getToken ()
n . getToken ()
{ switch ( n . getToken () ) { case GT : case GE : case LT : case LE : return true ; default: break; } return false ; }
switch ( n . getToken () ) { case EQ : case NE : case SHEQ : case SHNE : case MUL : return true ; default: break; }
n . getToken ()
parent . getToken ()
parent . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
n . getToken ()
valueNode . getToken ()
node . getToken ()
Token pType = root . getParent () . getToken () ;
Token parentType = parent . getToken () ;
return DECLARATION_PARENTS . contains ( parent . getToken () ) ;
parent . getToken ()
propdef . setToken ( Token.STRING ) ;
op . setToken ( assignOp ) ;
if ( canFoldStandardConstructors ( n ) ) { n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; reportCodeChange () ; }
Token type = n . getToken () ;
{ return include == nodeTypes . contains ( n . getToken () ) ; }
Token type = valueNode . getToken () ;
n . getToken ()
n . getToken ()
parent . setToken ( Token.ASSIGN ) ;
newOperator . setToken ( complementOperator ) ;
shorthand . setToken ( NodeUtil . getOpFromAssignmentOp ( shorthand ) ) ;
n . setToken ( Token.FOR ) ;
node . getToken ()
{ switch ( n . getToken () ) { case FOR : case FOR_OF : case DO : case WHILE : return true ; default: return false ; } }
n . getToken ()
n . getToken ()
{ for ( Token type : types ) { if ( c . getToken () == type ) { return c ; } } }
n . getToken ()
parent . getToken ()
parent . getToken ()
n . getToken ()
{ if ( n . isConst () ) { handleDeclarationList ( n , n . getParent () ) ; } n . setToken ( Token.VAR ) ; }
declarationList . setToken ( Token.VAR ) ;
{ currentProp . setToken ( Token.STRING ) ; newProp = IR . getprop ( objectToExtend . cloneTree () , currentProp ) . srcref ( currentProp ) ; }
n . getToken ()
member . setToken ( Token.STRING_KEY ) ;
c . setToken ( Token.VAR ) ;
{ Node dollarChildProp = n . getGrandparent () ; dollarChildProp . setToken ( Token.GETELEM ) ; compiler . reportCodeChange () ; }
switch ( node . getToken () ) { case NAME : case STRING : case STRING_KEY : return node . getString () ; default: return compiler . toSource ( node ) ; }
{ Token inverseOperator = NodeUtil . getInverseOperator ( subtree . getToken () ) ; subtree . setToken ( inverseOperator ) ; }
jsdoc . getToken ()
return jsdocNode != null && jsdocNode . getToken () == Token.ELLIPSIS ;
Preconditions . checkState ( thisRoot . getToken () == Token.BANG ) ;
boolean isPropDeclared = propNode . getToken () == Token.COLON ;
importedName . setToken ( Token.NAME ) ;
key . setToken ( Token.STRING_KEY ) ;
key . setToken ( Token.SETTER_DEF ) ;
key . setToken ( Token.GETTER_DEF ) ;
{ irNode . setToken ( Token.BLOCK ) ; }
name . getToken ()
parent . getToken ()
n . setToken ( TEMPLATE_LOCAL_NAME ) ;
n . setToken ( TEMPLATE_TYPE_PARAM ) ;
keyNode . setToken ( Token.STRING_KEY ) ;
keyNode . setToken ( Token.STRING_KEY ) ;
( n . isScript () || n . isFunction () ) && comp . hasScopeChanged ( n )
boolean taintsThis () { return getMask ( TAINTS_THIS_MASK ) ; }
boolean taintsGlobalState () { return getMask ( TAINTS_GLOBAL_STATE_MASK ) ; }
boolean pureFunction () { return getMask ( PURE_FUNCTION_MASK ) ; }
{ if ( node . isFunction () ) { functionSideEffectMap . put ( node , createFunctionInfo ( node , parent ) ) ; } return true ; }
Collection < Definition > defs = getFunctionDefinitions ( definitionProvider , callSite ) ;
this . functionSideEffectMap = new LinkedHashMap <> () ;
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new MinimizeExitPoints ( compiler ) . asCompilerPass () ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clClinitPrunerPass ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new J2clConstantHoisterPass ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clEqualitySameRewriterPass ( compiler ) ; }
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
this . compiler = Preconditions . checkNotNull ( compiler ) ;
boolean useTypesForOptimization = compiler . getOptions () . useTypesForLocalOptimization ;
boolean shouldAmbiguateProperties () { return this . ambiguateProperties ; }
boolean shouldDisambiguateProperties () { return this . disambiguateProperties ; }
@ Override protected CompilerOptions getOptions ( CompilerOptions options ) { options.useTypesForLocalOptimization = true ; return super . getOptions ( options ) ; }
CompilerPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeFoldConstants ( late , compiler . getOptions () . useTypesForLocalOptimization ) ) ;
compiler . getOptions () . useTypesForLocalOptimization
final boolean useTypesForOptimization = compiler . getOptions () . useTypesForLocalOptimization ;
if ( ! compiler . getOptions () . useTypesForLocalOptimization ) { return; }
{ CompilerOptions options = super . getOptions () ; options.useTypesForLocalOptimization = useTypesForOptimization ; options . setJ2clPass ( CompilerOptions.J2clPassMode.ON ) ; return options ; }
