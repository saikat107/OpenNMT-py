Null () { ; }
public ObjectUtils () { ; }
public BooleanUtils () { ; }
public CharUtils () { ; }
public ClassUtils () { ; }
public NumberUtils () { ; }
public ArrayUtils () { ; }
public Validate () { ; }
public WordUtils () { ; }
public StringEscapeUtils () { ; }
public CharSetUtils () { ; }
public RandomStringUtils () { ; }
public EnumUtils () { ; }
private Entry () { ; }
public ExceptionUtils () { ; }
private Entry () { ; }
public EnumUtils () { ; }
public NumberUtils () { ; }
public DateFormatUtils () { ; }
public DateUtils () { ; }
public StopWatch () { ; }
public RandomStringUtils () { super(); }
public StringEscapeUtils () { super(); }
public WordUtils () { super(); }
public CharSetUtils () { super(); }
public CharUtils () { super(); }
public NumberUtils () { super(); }
public EnumUtils () { super(); }
public ObjectUtils () { super(); }
public BooleanUtils () { super(); }
public ArrayUtils () { super(); }
public ClassUtils () { super(); }
{ try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { ; } return createBigInteger ( numeric ) ; }
{ try { if ( in != null ) { in . close () ; } } catch ( IOException ex ) { ; } }
{ try { if ( out != null ) { out . close () ; } } catch ( IOException ex ) { ; } }
{ try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { ; } return createBigInteger ( numeric ) ; }
if ( last == CHAR_CONS ) { ; } else { lastIdx ++ ; }
public StringUtils () { super(); }
public SystemUtils () { super(); }
{ try { if ( in != null ) { in . close () ; } } catch ( IOException ex ) {} }
{ try { if ( out != null ) { out . close () ; } } catch ( IOException ex ) {} }
public DateFormatUtils () { super(); }
Null () { super(); }
public DateUtils () { super(); }
TwoDigitMonthField () { super(); }
TwoDigitYearField () { super(); }
UnpaddedMonthField () { super(); }
public ExceptionUtils () { super(); }
public NumberUtils () { super(); }
public EnumUtils () { super(); }
suite . addTestSuite ( VariableFormatterTest . class ) ;
{ Object result = replaceObject ( source ) ; return result == null ? null : result . toString () ; }
sb . appendFixedWidthPadLeft ( null , NUMBER_CONSTANT , CHAR_CONS ) ;
noPrimitives = new Class [] { String . class , ClassUtils . class , Void.TYPE }
assertEquals ( true , tenToTwenty . containsNumber ( nonComparableNumber ) ) ;
Range r = new DoubleRange ( nonComparableNumber ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparableNumber ) ) ;
Range r = new IntRange ( nonComparableNumber ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparableNumber ) ) ;
Range r = new LongRange ( nonComparableNumber ) ;
assertEquals ( true , tenToTwenty . containsFloat ( nonComparableNumber ) ) ;
assertEquals ( true , tenToTwenty . containsDouble ( nonComparableNumber ) ) ;
assertEquals ( true , tenToTwenty . containsInteger ( nonComparableNumber ) ) ;
assertEquals ( true , tenToTwenty . containsLong ( nonComparableNumber ) ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparableNumber ) ) ;
Range r = new FloatRange ( nonComparableNumber ) ;
{ return getTSVClone () ; }
{ return getCSVClone () ; }
int removeLen = endIndex - startIndex ;
{ return lastIndexOf ( str , size - NUMBER_CONSTANT ) ; }
{ return lastIndexOf ( ch , size - NUMBER_CONSTANT ) ; }
{ return new String ( buf , size - length , length ) ; }
{ return new StringBuffer ( size ) . append ( buffer , NUMBER_CONSTANT , size ) ; }
{ return new String ( buffer , NUMBER_CONSTANT , size ) ; }
{ if ( str . charAt ( j ) != buffer [ i + j ] ) { continue outer ; } }
{ if ( buffer [ i ] == ch ) { return i ; } }
char [] thisBuf = buffer ;
char [] thisBuf = buffer ;
char [] thisBuf = buffer ;
{ endIndex = validateRange ( startIndex , endIndex ) ; return new String ( buffer , startIndex , endIndex - startIndex ) ; }
{ if ( buffer [ pos ] != str . charAt ( i ) ) { return false ; } }
{ if ( buffer [ i ] != str . charAt ( i ) ) { return false ; } }
if ( len > NUMBER_CONSTANT ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; size -= len ; }
for ( int i = NUMBER_CONSTANT ; i < length ; i ++ ) { buffer [ size ++ ] = padChar ; }
buffer [ size ++ ] = ch ;
System . arraycopy ( chars , startIndex , buffer , len , length ) ;
System . arraycopy ( chars , NUMBER_CONSTANT , buffer , len , strLen ) ;
System . arraycopy ( str.buffer , NUMBER_CONSTANT , buffer , len , strLen ) ;
str . getChars ( NUMBER_CONSTANT , strLen , buffer , len ) ;
str . getChars ( NUMBER_CONSTANT , strLen , buffer , len ) ;
System . arraycopy ( buffer , startIndex , destination , destinationIndex , endIndex - startIndex ) ;
System . arraycopy ( buffer , NUMBER_CONSTANT , destination , NUMBER_CONSTANT , len ) ;
System . arraycopy ( buffer , startIndex , chars , NUMBER_CONSTANT , len ) ;
System . arraycopy ( buffer , NUMBER_CONSTANT , chars , NUMBER_CONSTANT , size ) ;
buffer [ index ] = ch ;
{ if ( index < NUMBER_CONSTANT || index >= length () ) { throw new StringIndexOutOfBoundsException ( index ) ; } return buffer [ index ] ; }
for ( int i = oldEnd ; i < newEnd ; i ++ ) { buffer [ i ] = CHAR_CONS ; }
{ super(); if ( initialCapacity <= NUMBER_CONSTANT ) { initialCapacity = CAPACITY ; } buffer = new char [ initialCapacity ] ; }
assertEquals ( true , sb.buffer.length >= NUMBER_CONSTANT ) ;
if ( pos + len > textLen ) { return NUMBER_CONSTANT ; }
{ return ( boolean [] ) add ( array , index , BooleanUtils . toBooleanObject ( element ) , Boolean.TYPE ) ; }
try { sb . setLength ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IndexOutOfBoundsException e ) {}
try { sb . setLength ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IndexOutOfBoundsException e ) {}
try { sb . deleteCharAt ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IndexOutOfBoundsException e ) {}
{ if ( startPos < getPos () ) { getTokenList () . addLast ( VariableParser . newTextToken ( startPos , getPos () - startPos ) ) ; } }
if ( last != CharUtils.CR ) { lastIdx ++ ; }
private void setVarStartMatcher ( StrMatcher varStartMatcher ) { this . varStartMatcher = varStartMatcher ; }
private void setVarEndMatcher ( StrMatcher varEndMatcher ) { this . varEndMatcher = varEndMatcher ; }
private void setEscVarMatcher ( StrMatcher escVarMatcher ) { this . escVarMatcher = escVarMatcher ; }
StrMatcher trimmer
{ setIgnoredMatcher ( StrMatcher . charMatcher ( ignored ) ) ; }
StrMatcher ignored
{ setQuoteMatcher ( StrMatcher . charMatcher ( quote ) ) ; }
StrMatcher quote
start == len && delim . isMatch ( chars , start - NUMBER_CONSTANT , NUMBER_CONSTANT , len ) == NUMBER_CONSTANT
StrMatcher delim
StrMatcher delim
tok . setIgnoredMatcher ( StrMatcher . trimMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . trimMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . trimMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . noneMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . noneMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . trimMatcher () ) ;
sb . replaceFirst ( CHAR_CONS , CHAR_CONS ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
if ( cloned.chars != null ) { cloned.chars = cloned.chars ; }
if ( cloned.chars != null ) { cloned.chars = ( char [] ) cloned.chars . clone () ; }
public boolean isEmptyTokenAsNull () { return this . emptyAsNull ; }
{ if ( trimmer != null ) { this . trimmerMatcher = trimmer ; } return this ; }
public StrMatcher getTrimmerMatcher () { return trimmerMatcher ; }
{ if ( ignored != null ) { this . ignoredMatcher = ignored ; } return this ; }
public StrMatcher getIgnoredMatcher () { return ignoredMatcher ; }
{ if ( quote != null ) { this . quoteMatcher = quote ; } return this ; }
public StrMatcher getQuoteMatcher () { return quoteMatcher ; }
public StrMatcher getDelimiterMatcher () { return this . delimMatcher ; }
{ assertTrue ( ! bf_multi . isAllSet ( j ) ) ; assertTrue ( bf_zero . isAllSet ( j ) ) ; }
{ super ( msg == null ? DEFAULT_MESSAGE : msg ) ; this . cause = cause ; }
{ super ( DEFAULT_MESSAGE ) ; this . cause = cause ; }
{ super ( msg == null ? DEFAULT_MESSAGE : msg ) ; }
public NotImplementedException () { super ( DEFAULT_MESSAGE ) ; }
private void tokenize () { if ( tokens == null ) { tokens = readTokens () ; } }
sb . clear () . append ( true ) ;
assertLocaleLookupList ( LOCALE_EN_US_ZZZZ , null , new Locale [] { LOCALE_EN_US_ZZZZ , LOCALE_EN_US , new Locale ( STRING_CONSTANT , STRING_CONSTANT ) } ) ;
assertLocaleLookupList ( LOCALE_EN_US_ZZZZ , null , new Locale [] { LOCALE_EN_US_ZZZZ , LOCALE_EN_US , LOCALE_EN } ) ;
{ return ! StringUtils . isEmpty ( str ) ; }
List list = new ArrayList () ;
List list = new ArrayList () ;
{ StrBuilder . this . append ( str , off , len ) ; }
{ StrBuilder . this . append ( cbuf , off , len ) ; }
public void write ( char [] cbuf ) { StrBuilder . this . append ( cbuf ) ; }
public void write ( int c ) { StrBuilder . this . append ( ( char ) c ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
{ return indexOf ( array , valueToFind , NUMBER_CONSTANT , tolerance ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , objectToFind ) != INDEX_NOT_FOUND ; }
{ return reflectionEquals ( lhs , rhs , testTransients , null , null ) ; }
{ return reflectionEquals ( lhs , rhs , false , null , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null , null ) ; }
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , testTransients , null , null ) ; }
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , false , null , null ) ; }
{ return reflectionCompare ( lhs , rhs , compareTransients , null , null ) ; }
{ return reflectionCompare ( lhs , rhs , false , null , null ) ; }
HashCodeBuilder . reflectionHashCode ( x , ( String [] ) null )
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
public boolean hasPrevious () { checkTokenized () ; return tokenPos > NUMBER_CONSTANT ; }
public boolean hasNext () { checkTokenized () ; return tokenPos < tokens.length ; }
checkTokenized () ;
{ checkTokenized () ; return ( String [] ) tokens . clone () ; }
public int size () { checkTokenized () ; return tokens.length ; }
assertEquals ( input , tok . getContent () ) ;
{ if ( ready () == false ) { return - NUMBER_CONSTANT ; } return StrBuilder . this . charAt ( pos ++ ) ; }
String varValue = resolveVariable ( varName , buf , startPos , endPos ) ;
if ( substitute ( buf , NUMBER_CONSTANT , length ) == false ) { return source . substring ( offset , offset + length ) ; }
StrLookup variableResolver
{ this ( StrLookup . mapLookup ( valueMap ) , prefix , suffix , escape ) ; }
{ this ( StrLookup . mapLookup ( valueMap ) , prefix , suffix , DEFAULT_ESCAPE ) ; }
{ this ( StrLookup . mapLookup ( valueMap ) , DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ESCAPE ) ; }
{ return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; }
return entry.map . get ( getName () ) ;
protected Entry () { super(); }
return entry.map . get ( getName () ) ;
protected Entry () { super(); }
sub . replaceIn ( builder ) ;
assertEquals ( NUMBER_CONSTANT , ExceptionUtils . getThrowableCount ( cyclicCause ) ) ;
cyclicCause = null ;
cyclicCause = new ExceptionWithCause ( a ) ;
protected DefaultToStringStyle () { super(); }
DefaultToStringStyle () { super(); }
public Object getValue () { return Boolean . valueOf ( this . value ) ; }
public Object getValue () { return new Boolean ( this . value ) ; }
public Object getValue () { return BooleanUtils . toBooleanObject ( this . value ) ; }
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
{ StringWriter stringWriter = createStringWriter ( str ) ; this . unescape ( stringWriter , str ) ; return stringWriter . toString () ; }
{ StringWriter stringWriter = createStringWriter ( str ) ; this . escape ( stringWriter , str ) ; return stringWriter . toString () ; }
assertSame ( CharSet.EMPTY , CharSet . getInstance ( ( String ) null ) ) ;
CharSet chars = CharSet . getInstance ( set ) ;
CharSet chars = CharSet . getInstance ( set ) ;
CharSet chars = CharSet . getInstance ( set ) ;
this . stopTime = System . currentTimeMillis () ;
this . stopTime = - NUMBER_CONSTANT ;
this . stopTime = System . currentTimeMillis () ;
if ( this . runningState == STATE_RUNNING ) { this . stopTime = System . currentTimeMillis () ; }
protected void setUp ( ) throws Exception { super . setUp () ; java.util.Locale . setDefault ( java.util.Locale.US ) ; }
if ( StringUtils . containsNone ( str , CSV_SEARCH_CHARS ) ) { return str ; }
MessageFormat f = createMessageFormat ( pattern , locale ) ;
subformats . put ( INTEGER , createIntegerInstance ( getLocale () ) ) ;
getIntegerNumberFormat ( Locale.US )
{ return splitByWholeSeparatorWorker ( str , separator , - NUMBER_CONSTANT , false ) ; }
{ clazz = Class . forName ( toCanonicalName ( className ) , initialize , classLoader ) ; }
if ( StringUtils . containsAny ( quoteless , CSV_SEARCH_CHARS ) ) { str = StringUtils . replace ( quoteless , CSV_QUOTE_STR + CSV_QUOTE_STR , CSV_QUOTE_STR ) ; }
catch ( IllegalStateException e ) {}
if ( replaceChars == null ) { replaceChars = EMPTY ; }
{ if ( isEmpty ( str ) || isEmpty ( remove ) ) { return str ; } return replace ( str , remove , EMPTY , - NUMBER_CONSTANT ) ; }
{ return new ExtendedMessageFormat ( pattern , locale ) ; }
assertPatternsEqual ( null , pattern , emf . toPattern () ) ;
assertPatternsEqual ( STRING_CONSTANT , pattern , emf . toPattern () ) ;
int mid = ( low + high ) > > > NUMBER_CONSTANT ;
osName . toLowerCase ( Locale.ENGLISH ) . startsWith ( STRING_CONSTANT )
{ return Integer . toHexString ( ch ) . toUpperCase ( Locale.ENGLISH ) ; }
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
{ getRegistry () . remove ( new IDKey ( value ) ) ; }
{ getRegistry () . add ( new IDKey ( value ) ) ; }
{ return getRegistry () . contains ( new IDKey ( value ) ) ; }
roundUp = offset >= NUMBER_CONSTANT ;
{ if ( this . runningState == STATE_UNSTARTED ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } return this . startTimeMillis ; }
this . startTime += ( System . nanoTime () - this . stopTime ) ;
this . stopTime = System . nanoTime () ;
this . stopTime = System . nanoTime () ;
if ( this . runningState == STATE_RUNNING ) { this . stopTime = System . nanoTime () ; }
public static Test suite () { return new TestSuite ( NestableErrorTest . class ) ; }
public static Test suite () { return new TestSuite ( NestableExceptionTest . class ) ; }
public static Test suite () { return new TestSuite ( NestableRuntimeExceptionTest . class ) ; }
public ExceptionUtilsTest ( String name ) { super ( name ) ; }
@ Override public String toString () { return STRING_CONSTANT ; }
{ return ( ( Boolean ) IS_SYNTHETIC . invoke ( m , ( Object [] ) null ) ) . booleanValue () ; }
objects [ NUMBER_CONSTANT ] = simple ;
objectsLevel2 [ NUMBER_CONSTANT ] = objects ;
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
if ( cloned.chars != null ) { cloned.chars = cloned.chars . clone () ; }
{ checkTokenized () ; return tokens . clone () ; }
@ Override public Throwable getCause () { return cause ; }
@ Override public String toString () { return toString ; }
sb . appendln ( FOO ) ;
{ super ( msg ) ; this . cause = null ; }
{ super ( msg ) ; this . cause = null ; }
{ super ( msg ) ; this . cause = null ; }
String [] splitOnNullResults = StringUtils . splitByWholeSeparator ( stringToSplitOnNulls , null ) ;
{ ObjectUtils . identityToString ( this . getStringBuffer () , object ) ; return this ; }
{ ObjectUtils . identityToString ( buffer , value ) ; }
String pBaseStr = STRING_CONSTANT ;
{ super ( DEFAULT_MESSAGE , cause ) ; }
final Throwable n = new UnhandledException ( t ) ;
catch ( NumberFormatException nfe ) { throw new UnhandledException ( STRING_CONSTANT + unicode , nfe ) ; }
String entityValue = Entities . getISO8859_1 ( i % Entities.ISO8859_1_ARRAY_LENGTH , NUMBER_CONSTANT ) ;
String entityValue = Entities . getHTML40 ( i % Entities.HTML40_ARRAY_LENGTH , NUMBER_CONSTANT ) ;
Collection < > collection
Collection < > collection
Iterator < > iterator
Iterator < > iterator
Iterator < > it
Iterator < > it
List < String > tokens
List < String > tokens
List < String > list
public Byte toByte () { return Byte . valueOf ( byteValue () ) ; }
public Object getValue () { return Byte . valueOf ( this . value ) ; }
{ mutNum . compareTo ( Byte . valueOf ( ( byte ) NUMBER_CONSTANT ) ) ; fail () ; }
{ return ( byte [] ) add ( array , index , Byte . valueOf ( element ) , Byte.TYPE ) ; }
{ result [ i ] = Byte . valueOf ( array [ i ] ) ; }
Class < > type
Class < > type
Class < > type
Class < > clazz
Class < > clazz
List < String > list = getCauseMethodNameList () ;
List < String > list = getCauseMethodNameList () ;
Class < > clazz
Map < String , FormatFactory > registry
Map < String , FormatFactory > registry
String obj
String obj
Class < > lhsClass = lhs . getClass () ;
Class < > clazz
Class < > reflectUpToClass
Collection < String > excludeFields
Class < > cls = target . getClass () ;
Class < > cls = target . getClass () ;
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls = target . getClass () ;
Class < > cls = target . getClass () ;
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > clazz
Class < > clazz
Class < > reflectUpToClass
Collection < String > collection
Collection < String > excludeFieldNames
Class < > reflectUpToClass
List < String > priorVariables
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > clss
Class < > clss = null ;
Class < > newArrayComponentType
Class < > cls
Class < > expected
Class < > clazz
Class < > reflectUpToClass
Collection < String > excludeFields
Collection < String > excludeFields
Class < > reflectUpToClass
Class < > clazz
Class < > cls
Class < > cls
if ( methodNames == null ) { synchronized ( CAUSE_METHOD_NAMES_LOCK ) { methodNames = CAUSE_METHOD_NAMES ; } }
{ synchronized ( CAUSE_METHOD_NAMES_LOCK ) { return getCause ( throwable , CAUSE_METHOD_NAMES ) ; } }
if ( list . remove ( methodName ) ) { synchronized ( CAUSE_METHOD_NAMES_LOCK ) { CAUSE_METHOD_NAMES = toArray ( list ) ; } }
if ( list . add ( methodName ) ) { synchronized ( CAUSE_METHOD_NAMES_LOCK ) { CAUSE_METHOD_NAMES = toArray ( list ) ; } }
Iterator < > it
Iterator < > it
Iterator < > it
assertNotNull ( ObjectUtils.NULL ) ;
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , obj , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ return ( boolean [] ) add ( array , index , Boolean . valueOf ( element ) , Boolean.TYPE ) ; }
public Object getValue () { return Boolean . valueOf ( this . value ) ; }
{ if ( cls == null ) { return StringUtils.EMPTY ; } return cls . getPackage () . getName () ; }
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = Float . compare ( lhs , rhs ) ; return this ; }
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = Double . compare ( lhs , rhs ) ; return this ; }
return Double . compare ( value , anotherVal ) ;
return Float . compare ( value , anotherVal ) ;
int compare = ( ( Comparable < Number > ) num1 ) . compareTo ( num2 ) ;
Map < , > map
Collection < > collection
Comparator < > comparator
Class < ? super T > clazz
T object
T object
T object
T object
T object
T object
Map < String , V > map
public String [] getExcludeFieldNames () { return this . excludeFieldNames . clone () ; }
{ UnescapeUtils.UNESCAPE_ECMASCRIPT . translate ( str , out ) ; }
{ return UnescapeUtils.UNESCAPE_ECMASCRIPT . translate ( str ) ; }
{ EscapeUtils.ESCAPE_ECMASCRIPT . translate ( str , out ) ; }
{ return EscapeUtils.ESCAPE_ECMASCRIPT . translate ( str ) ; }
{ EscapeUtils.ESCAPE_JAVA . translate ( str , out ) ; }
{ return EscapeUtils.ESCAPE_JAVA . translate ( str ) ; }
{ return UnescapeUtils . unescapeCsv ( str ) ; }
{ return EscapeUtils . escapeCsv ( str ) ; }
{ return UnescapeUtils . unescapeXml ( str ) ; }
{ return EscapeUtils . escapeXml ( str ) ; }
{ return UnescapeUtils . unescapeHtml4 ( str ) ; }
{ return EscapeUtils . escapeHtml4 ( str ) ; }
{ return UnescapeUtils . unescapeEcmaScript ( str ) ; }
{ return UnescapeUtils . unescapeJava ( str ) ; }
{ return EscapeUtils . escapeEcmaScript ( str ) ; }
{ return EscapeUtils . escapeJava ( str ) ; }
void setValue ( T value ) ;
T getValue ( ) ;
T value
T value
CharSequence str
CharSequence str
CharSequence str
CharSequence str
modify ( truncated , field , MODIFY_TRUNCATE ) ;
modify ( gval , field , MODIFY_TRUNCATE ) ;
modify ( rounded , field , MODIFY_ROUND ) ;
modify ( gval , field , MODIFY_ROUND ) ;
{ throw new NullPointerException ( STRING_CONSTANT ) ; }
if ( target == null ) { throw new NullPointerException ( STRING_CONSTANT ) ; }
catch ( NumberFormatException nfe ) { throw new RuntimeException ( STRING_CONSTANT + unicode , nfe ) ; }
assertGetClassThrowsNullPointerException ( null ) ;
catch ( IOException ioe ) { throw new RuntimeException ( ioe ) ; }
buffer = new char [ capacity * NUMBER_CONSTANT ] ;
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ result [ i ] = Float . valueOf ( array [ i ] ) ; }
{ result [ i ] = Double . valueOf ( array [ i ] ) ; }
{ result [ i ] = Short . valueOf ( array [ i ] ) ; }
{ result [ i ] = Integer . valueOf ( array [ i ] ) ; }
{ result [ i ] = Long . valueOf ( array [ i ] ) ; }
{ result [ i ] = Character . valueOf ( array [ i ] ) ; }
double . . . array2
float . . . array2
long . . . array2
int . . . array2
short . . . array2
byte . . . array2
char . . . array2
boolean . . . array2
object instanceof Map.Entry < , >
Iterator < > it = collection . iterator ()
Iterator < > it = collection . iterator ()
Iterator < > it = collection . iterator ()
Iterator < > it = collection . iterator ()
if ( num1 instanceof Comparable < > == false ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( num instanceof Comparable < > == false ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
oos . writeObject ( new ClassNotFoundSerialization () ) ;
{ if ( object == null ) { return valueIfNull ; } return getPackageName ( object . getClass () ) ; }
{ if ( object == null ) { return valueIfNull ; } return getShortClassName ( object . getClass () ) ; }
{ if ( cls == null ) { return StringUtils.EMPTY ; } return getPackageName ( cls . getName () ) ; }
isSet ( PARAM.escapePlus )
uu = new UnicodeUnescaper ( UnicodeUnescaper.PARAM.escapePlus ) ;
uu = new UnicodeUnescaper ( UnicodeUnescaper.OPTION.escapePlus ) ;
isSet ( OPTION.escapePlus )
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder result = new StringBuilder () ;
StringBuilder buffer = new StringBuilder ( strLen ) ;
StringBuilder buffer = new StringBuilder ( strLen ) ;
StringBuilder buffer = new StringBuilder ( strLen ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder canonicalClassNameBuffer = new StringBuilder ( className ) ;
StringBuilder classNameBuffer = new StringBuilder () ;
StringBuilder arrayPrefix = new StringBuilder () ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buffer = new StringBuilder ( strLen ) ;
new StringBuilder ( strLen ) . append ( Character . toLowerCase ( str . charAt ( NUMBER_CONSTANT ) ) ) . append ( str . substring ( NUMBER_CONSTANT ) )
new StringBuilder ( strLen ) . append ( Character . toTitleCase ( str . charAt ( NUMBER_CONSTANT ) ) ) . append ( str . substring ( NUMBER_CONSTANT ) )
StringBuilder buf = new StringBuilder ( outputLength ) ;
StringBuilder buf = new StringBuilder ( strLength ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( bufSize ) ;
StringBuilder buf = new StringBuilder ( bufSize ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buffer = new StringBuilder ( NUMBER_CONSTANT ) ;
toString = new StringBuilder ( NUMBER_CONSTANT ) . append ( getNumerator () ) . append ( CHAR_CONS ) . append ( getDenominator () ) . toString () ;
StringBuilder buffer = new StringBuilder () ;
StringBuilder buf = new StringBuilder () ;
CharRange range = CharRange . is ( CHAR_CONS ) ;
Collection < > collection
Collection < > collection
Class < > cls
Map < , > map
Collection < > coll
Class < > cls
Class < > cls
Class < > [] parameterTypes
Class < > [] parameterTypes
assertEquals ( null , StringUtils . join ( ( Collection < > ) null , null ) ) ;
assertEquals ( null , StringUtils . join ( ( Collection < > ) null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . join ( ( Iterator < > ) null , null ) ) ;
assertEquals ( null , StringUtils . join ( ( Iterator < > ) null , CHAR_CONS ) ) ;
Class < > exceptionType
Class < > c
assertFalse ( ClassUtils . isAssignable ( ( Class < > ) null , null , true ) ) ;
assertFalse ( ClassUtils . isAssignable ( ( Class < > ) null , null ) ) ;
assertEquals ( STRING_CONSTANT , ClassUtils . getPackageName ( ( Class < > ) null ) ) ;
iMap = new HashMap < Object , Object > () ;
Class < > [] c
sb . appendWithSeparators ( ( Iterator < > ) null , STRING_CONSTANT ) ;
sb . appendWithSeparators ( ( Collection < > ) null , STRING_CONSTANT ) ;
sb . appendAll ( ( Iterator < > ) null ) ;
sb . appendAll ( ( Collection < > ) null ) ;
public String getFormattedExceptionMessage ( String baseMessage ) { return exceptionContext . getFormattedExceptionMessage ( baseMessage ) ; }
public String getFormattedExceptionMessage ( String baseMessage ) { return exceptionContext . getFormattedExceptionMessage ( baseMessage ) ; }
Object value
Object value
StringBuffer buffer = new StringBuffer () ;
Class < > [] c
values = new HashMap < String , String > () ;
List < > list = tok . getTokenList () ;
Map < String , > map = null ;
Map < String , ? extends FormatFactory > registry
Map < String , > registry
Map < String , > registry
String toString = ReflectionToStringBuilder . toStringExclude ( new TestFixture () , ( Collection < String > ) null ) ;
String toString = ReflectionToStringBuilder . toStringExclude ( new TestFixture () , new ArrayList < String > () ) ;
Object object
Object object
Object object
Object object
Object object
Object object
{ this ( object , null , null ) ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( getMinimum () , element ) < NUMBER_CONSTANT ; }
StringEscapeUtils.UNESCAPE_CSV . translate ( value , writer ) ;
StringEscapeUtils.ESCAPE_CSV . translate ( value , writer ) ;
StringEscapeUtils.UNESCAPE_JAVA . translate ( original , writer ) ;
StringEscapeUtils.ESCAPE_JAVA . translate ( original , writer ) ;
Comparator < T > c
{ try { return initialize () ; } finally { if ( execFinally != null ) { execFinally . shutdown () ; } } }
{ execFinally = exec ; }
{ this . translators = ArrayUtils . clone ( translators ) ; }
{ return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
Object [] values2 = ArrayUtils . addAll ( values , Integer . valueOf ( i ) ) ;
Object [] values2 = ArrayUtils . add ( values , Integer . valueOf ( i ) ) ;
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , new Double ( value ) ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , Long . valueOf ( value ) ) ) ; } }
{ calendar . getTimeInMillis () ; calendar = ( Calendar ) calendar . clone () ; calendar . setTimeZone ( mTimeZone ) ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( element , this . maximum ) > NUMBER_CONSTANT ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( element , this . minimum ) < NUMBER_CONSTANT ; }
return null ;
{ return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return noNullElements ( iterable , DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE ) ; }
{ return noNullElements ( array , DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE ) ; }
{ return notBlank ( chars , DEFAULT_NOT_BLANK_EX_MESSAGE ) ; }
{ return notEmpty ( chars , DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE ) ; }
{ return notEmpty ( map , DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE ) ; }
{ return notEmpty ( collection , DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE ) ; }
{ return notEmpty ( array , DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE ) ; }
{ return notNull ( object , DEFAULT_IS_NULL_EX_MESSAGE ) ; }
StrLookup < > variableResolver
StrLookup < > resolver = getVariableResolver () ;
StrLookup < > variableResolver
StrLookup < > variableResolver
StrLookup < > variableResolver
public StrSubstitutor () { this ( ( StrLookup < > ) null , DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ESCAPE ) ; }
{ return m != null && Modifier . isPublic ( m . getModifiers () ) && ! m . isSynthetic () ; }
validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
{ return REGISTRY . get () ; }
CharSequence str
if ( str == null || suffix == null ) { return str == null && suffix == null ; }
{ if ( str == null ) { return null ; } return CharSequenceUtils . reverse ( str ) . toString () ; }
if ( str == null || searchStrs == null ) { return - NUMBER_CONSTANT ; }
smallestIndexOfDiff == INDEX_NOT_FOUND
if ( at == INDEX_NOT_FOUND ) { return EMPTY ; }
if ( isEmpty ( str ) || str . indexOf ( remove ) == INDEX_NOT_FOUND ) { return str ; }
if ( pos == INDEX_NOT_FOUND || pos == ( str . length () - separator . length () ) ) { return EMPTY ; }
if ( pos == INDEX_NOT_FOUND ) { return str ; }
if ( pos == INDEX_NOT_FOUND ) { return EMPTY ; }
if ( pos == INDEX_NOT_FOUND ) { return str ; }
return indexOfAnyBut ( cs , valid ) == INDEX_NOT_FOUND ;
{ if ( isEmpty ( cs ) || isEmpty ( searchChars ) ) { return INDEX_NOT_FOUND ; } return indexOfAny ( cs , searchChars . toCharArray () ) ; }
if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; }
{ if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } return str . lastIndexOf ( searchStr , startPos ) ; }
{ if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } return str . lastIndexOf ( searchStr ) ; }
{ if ( isEmpty ( str ) ) { return INDEX_NOT_FOUND ; } return str . lastIndexOf ( searchChar , startPos ) ; }
{ if ( isEmpty ( str ) ) { return INDEX_NOT_FOUND ; } return str . lastIndexOf ( searchChar ) ; }
{ if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } return str . indexOf ( searchStr , startPos ) ; }
{ if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } return str . indexOf ( searchStr ) ; }
( start != strLen ) && ( stripChars . indexOf ( str . charAt ( start ) ) != INDEX_NOT_FOUND )
{ if ( str == null ) { return null ; } return new StringBuilder ( str ) . reverse () . toString () ; }
int searchChar
int searchChar
int searchChar
int searchChar
int searchChar
Class < > . . . parameterTypes
Class < > . . . parameterTypes
Class < > . . . parameterTypes
Class < > . . . parameterTypes
Object . . . args
Object . . . args
Object . . . args
Object . . . args
String . . . parsePatterns
String . . . parsePatterns
String . . . strs
CharSequence . . . css
Boolean . . . array
boolean . . . array
char . . . delimiters
char . . . delimiters
char . . . delimiters
char . . . delimiters
Class < > . . . parameterTypes
Class < > . . . parameterTypes
Object . . . args
Object . . . args
String . . . searchStrings
assertEquals ( NUMBER_CONSTANT , new MutableFloat ( STRING_CONSTANT ) . floatValue () , NUMBER_CONSTANT ) ;
{ return reflectionCompare ( lhs , rhs , compareTransients , reflectUpToClass , null ) ; }
isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass )
listeners . fire () . propertyChange ( new PropertyChangeEvent ( this , STRING_CONSTANT , oldValue , property ) ) ;
{ Validate . notNull ( listener , STRING_CONSTANT ) ; listeners . add ( listener ) ; }
{ final String [] array = ArrayUtilsTest . toArrayPropagatingType () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtils . toArray () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtilsTest . < String > toArrayPropagatingType () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtils . < String > toArray () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( - NUMBER_CONSTANT , StringUtils . indexOfDifference ( ( String [] ) null ) ) ;
String [] results ;
String [] results ;
assertEquals ( null , StringUtils . concatWith ( null , ( String [] ) null ) ) ;
assertEquals ( null , StringUtils . concat ( ( String [] ) null ) ) ;
{ DateUtils . parseDate ( dateStr , ( String [] ) null ) ; fail () ; }
{ if ( expression == false ) { throw new IllegalStateException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } }
return new StringBuilder ( annotationType == null ? STRING_CONSTANT : annotationType . getName () ) . insert ( NUMBER_CONSTANT , CHAR_CONS ) . toString () ;
SystemUtils . isJavaVersionAtLeast ( JAVA_1_4 )
{ return isAssignable ( cls , toClass , SystemUtils . isJavaVersionAtLeast ( JavaVersion.JAVA_1_5 ) ) ; }
{ return isAssignable ( classArray , toClassArray , SystemUtils . isJavaVersionAtLeast ( JavaVersion.JAVA_1_5 ) ) ; }
boolean atLeastJava14 = SystemUtils . isJavaVersionAtLeast ( JAVA_1_4 ) ;
{ return isJavaVersionMatch ( JAVA_SPECIFICATION_VERSION , versionPrefix ) ; }
if ( SystemUtils . isJavaVersionAtLeast ( JAVA_1_3 ) ) { assertEquals ( STRING_CONSTANT , new BigDecimal ( STRING_CONSTANT ) , NumberUtils . createNumber ( STRING_CONSTANT ) ) ; }
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
{ if ( SystemUtils . isJavaVersionAtLeast ( JAVA_1_4 ) ) { assertEquals ( message , expected , actual ) ; } }
static JavaVersion getJavaVersion ( final String nom ) { return get ( nom ) ; }
{ return ( options == null ) ? false : options . contains ( option ) ; }
assertEquals ( false , StringUtils . isNumeric ( STRING_CONSTANT ) ) ;
assertEquals ( false , StringUtils . isAlphanumeric ( STRING_CONSTANT ) ) ;
assertEquals ( false , StringUtils . isAlpha ( STRING_CONSTANT ) ) ;
{ return format ( date , pattern , UTC_TIME_ZONE , locale ) ; }
{ return format ( new Date ( millis ) , pattern , UTC_TIME_ZONE , locale ) ; }
{ return format ( date , pattern , UTC_TIME_ZONE , null ) ; }
{ return format ( new Date ( millis ) , pattern , UTC_TIME_ZONE , null ) ; }
Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeftElement () , pair . getRightElement () ) ;
{ return Boolean . valueOf ( isEquals () ) ; }
public Integer build () { return Integer . valueOf ( toHashCode () ) ; }
{ return Integer . valueOf ( toComparison () ) ; }
EqualsBuilder . class
EqualsBuilder . class
new StringBuilder ( strLen ) . append ( Character . toLowerCase ( cs . charAt ( NUMBER_CONSTANT ) ) ) . append ( StringUtils . subSequence ( cs , NUMBER_CONSTANT ) )
new StringBuilder ( strLen ) . append ( Character . toTitleCase ( cs . charAt ( NUMBER_CONSTANT ) ) ) . append ( StringUtils . subSequence ( cs , NUMBER_CONSTANT ) )
CharSequence cs
return str . subSequence ( start , end ) . toString () ;
return str . subSequence ( start , str . length () ) . toString () ;
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
String . . . set
Object . . . array
Class < > . . . parameterTypes
Class < > . . . classes
Class < > . . . classes
Class < > . . . toClassArray
char . . . chars
char . . . chars
return types . toArray ( new Type [ types . size () ] ) ;
return frames . toArray ( new String [ frames . size () ] ) ;
String cs
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
String . . . searchStrs
String . . . searchStrs
char . . . searchChars
String . . . strs
String input
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
( idx = CharSequenceUtils . indexOf ( str , sub , idx ) ) != INDEX_NOT_FOUND
tmp = CharSequenceUtils . lastIndexOf ( str , search , str . length () ) ;
tmp = CharSequenceUtils . indexOf ( str , search , NUMBER_CONSTANT ) ;
{ if ( searchChars == null ) { return false ; } return containsAny ( cs , CharSequenceUtils . toCharArray ( searchChars ) ) ; }
{ if ( CharSequenceUtils . regionMatches ( str , true , i , searchStr , NUMBER_CONSTANT , len ) ) { return true ; } }
return CharSequenceUtils . indexOf ( seq , searchSeq , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ;
{ if ( isEmpty ( seq ) ) { return false ; } return CharSequenceUtils . indexOf ( seq , searchChar , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . lastIndexOf ( seq , searchSeq , startPos ) ; }
return CharSequenceUtils . lastIndexOf ( seq , searchSeq , seq . length () ) ;
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . lastIndexOf ( seq , searchChar , startPos ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . lastIndexOf ( seq , searchChar , seq . length () ) ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchSeq , startPos ) ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchSeq , NUMBER_CONSTANT ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchChar , startPos ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchChar , NUMBER_CONSTANT ) ; }
{ return value != NUMBER_CONSTANT ; }
{ if ( bool == null ) { return valueIfNull ; } return bool . booleanValue () ; }
{ if ( bool == null ) { return null ; } return bool . booleanValue () ? Boolean.FALSE : Boolean.TRUE ; }
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
if ( lastWasGap ) { buf [ count ++ ] = ch ; lastWasGap = false ; } else { continue; }
String . . . excludeFields
{ return reflectionCompare ( lhs , rhs , compareTransients , null ) ; }
{ return reflectionCompare ( lhs , rhs , false , null ) ; }
String . . . excludeFields
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , testTransients , null ) ; }
String . . . excludeFields
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null ) ; }
String . . . excludeFieldNames
String . . . excludeFields
{ return reflectionEquals ( lhs , rhs , testTransients , null ) ; }
String . . . excludeFields
{ this . excludeFieldNames = toNoNullStringArray ( excludeFieldNamesParam ) ; Arrays . sort ( this . excludeFieldNames ) ; }
StringBuilder builder = new StringBuilder ( this . getClass () . getSimpleName () ) ;
char . . . chars
@ Override public R getRightElement () { return right ; }
@ Override public L getLeftElement () { return left ; }
Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeft () , pair . getRight () ) ;
{ R result = getRight () ; setRightElement ( value ) ; return result ; }
public R getValue () { return getRight () ; }
public final L getKey () { return getLeft () ; }
{ try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } }
{ try { return getAccessibleConstructor ( cls . getConstructor ( parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } }
Calendar c = Calendar . getInstance ( mTimeZone , mLocale ) ;
Calendar c = Calendar . getInstance ( mTimeZone , mLocale ) ;
{ return cache . getDateTimeInstance ( dateStyle , timeStyle , null , locale ) ; }
{ return cache . getDateTimeInstance ( dateStyle , timeStyle , null , null ) ; }
{ return cache . getDateTimeInstance ( null , style , timeZone , null ) ; }
{ return cache . getDateTimeInstance ( null , style , null , locale ) ; }
{ return cache . getDateTimeInstance ( null , style , null , null ) ; }
{ return cache . getDateTimeInstance ( style , null , timeZone , null ) ; }
{ return cache . getDateTimeInstance ( style , null , null , locale ) ; }
{ return cache . getDateTimeInstance ( style , null , null , null ) ; }
{ return cache . getInstance ( pattern , null , locale ) ; }
{ return cache . getInstance ( pattern , timeZone , null ) ; }
{ return cache . getInstance ( pattern , null , null ) ; }
CharSequence _ellipsis = ObjectUtils . defaultIfNull ( ellipsis , StringUtils.EMPTY ) ;
return pad ( pads , padChar ) . concat ( str ) ;
return str . concat ( pad ( pads , padChar ) ) ;
if ( inputLength == NUMBER_CONSTANT && repeat <= PAD_LIMIT ) { return pad ( repeat , str . charAt ( NUMBER_CONSTANT ) ) ; }
return repeat ( padChar , pads ) . concat ( str ) ;
return str . concat ( repeat ( padChar , pads ) ) ;
assertEquals ( Locale.GERMANY , format1 . getLocale () ) ;
{ Integer count = eventCounts . get ( eventName ) ; return count == null ? NUMBER_CONSTANT : count . intValue () ; }
{ R result = getRight () ; setRight ( value ) ; return result ; }
{ if ( isSet ( OPTION.semiColonRequired ) ) { return NUMBER_CONSTANT ; } else if ( isSet ( OPTION.errorIfNoSemiColon ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } }
int delimLen = delimiters == null ? - NUMBER_CONSTANT : delimiters.length ;
@ Before
@ Test ( expected = NullPointerException . class )
@ Test ( expected = NullPointerException . class )
if ( timeToLive < NUMBER_CONSTANT ) { throw new IllegalStateException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ if ( StringUtils . isEmpty ( str ) ) { return null ; } return Character . valueOf ( str . charAt ( NUMBER_CONSTANT ) ) ; }
try { FieldUtils . writeField ( field , publicChild , Integer . valueOf ( Integer.MAX_VALUE ) ) ; } catch ( IllegalAccessException e ) {}
Integer val = Integer . valueOf ( NUMBER_CONSTANT ) ;
Integer val = Integer . valueOf ( NUMBER_CONSTANT ) ;
sb . appendln ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
iInteger = Integer . valueOf ( NUMBER_CONSTANT ) ;
Integer value = Integer . valueOf ( NUMBER_CONSTANT ) ;
map . put ( STRING_CONSTANT , Integer . valueOf ( NUMBER_CONSTANT ) ) ;
map . put ( STRING_CONSTANT , Integer . valueOf ( NUMBER_CONSTANT ) ) ;
coll . add ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
coll . add ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( false , sb1 . equals ( Integer . valueOf ( NUMBER_CONSTANT ) ) ) ;
mutNum . subtract ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == Integer . valueOf ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , numA . equals ( Integer . valueOf ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableInt ( Integer . valueOf ( NUMBER_CONSTANT ) ) . intValue () ) ;
assertEquals ( false , f1 . equals ( Integer . valueOf ( NUMBER_CONSTANT ) ) ) ;
Integer i = Integer . valueOf ( NUMBER_CONSTANT ) ;
Integer i = Integer . valueOf ( NUMBER_CONSTANT ) ;
DurationFormatUtils.Token numToken = new DurationFormatUtils.Token ( Integer . valueOf ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
mutNum . subtract ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
map . put ( STRING_CONSTANT , Integer . valueOf ( NUMBER_CONSTANT ) ) ;
public Integer getValue () { return Integer . valueOf ( this . value ) ; }
mutNum . subtract ( Long . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Long . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == Long . valueOf ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( Long . valueOf ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableLong ( Long . valueOf ( NUMBER_CONSTANT ) ) . longValue () ) ;
public Long getValue () { return Long . valueOf ( this . value ) ; }
public Short getValue () { return Short . valueOf ( this . value ) ; }
mutNum . subtract ( Short . valueOf ( ( short ) NUMBER_CONSTANT ) ) ;
mutNum . add ( Short . valueOf ( ( short ) NUMBER_CONSTANT ) ) ;
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , Double . valueOf ( value ) ) ) ; } }
public Float getValue () { return Float . valueOf ( this . value ) ; }
public Double getValue () { return Double . valueOf ( this . value ) ; }
try { FieldUtils . writeField ( field , publicChild , Double . valueOf ( Double.MAX_VALUE ) ) ; } catch ( IllegalAccessException e ) {}
Object [] args = new Object [] { Double . valueOf ( STRING_CONSTANT ) } ;
args = new Object [] { STRING_CONSTANT , cal . getTime () , Double . valueOf ( STRING_CONSTANT ) }
mutNum . subtract ( Float . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Float . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == Float . valueOf ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( Float . valueOf ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableFloat ( Float . valueOf ( NUMBER_CONSTANT ) ) . floatValue () , NUMBER_CONSTANT ) ;
mutNum . subtract ( Double . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Double . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == Double . valueOf ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( Double . valueOf ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableDouble ( Double . valueOf ( NUMBER_CONSTANT ) ) . doubleValue () , NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , new MutableObject < Double > ( Double . valueOf ( NUMBER_CONSTANT ) ) . toString () ) ;
{ throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT + java6Exception + STRING_CONSTANT + sunException ) ; }
assertArrayEquals ( null , StringUtils . splitPreserveAllTokens ( null , CHAR_CONS ) ) ;
assertArrayEquals ( null , StringUtils . splitPreserveAllTokens ( null ) ) ;
assertArrayEquals ( null , StringUtils . splitByWholeSeparatorPreserveAllTokens ( null , STRING_CONSTANT , - NUMBER_CONSTANT ) ) ;
assertArrayEquals ( null , StringUtils . splitByWholeSeparator ( null , STRING_CONSTANT , NUMBER_CONSTANT ) ) ;
assertArrayEquals ( null , StringUtils . splitByWholeSeparator ( null , STRING_CONSTANT ) ) ;
assertArrayEquals ( null , StringUtils . split ( null , CHAR_CONS ) ) ;
assertArrayEquals ( null , StringUtils . split ( null ) ) ;
public synchronized void delete () { listField . remove ( Integer . valueOf ( random . nextInt ( N ) ) ) ; }
separator = separator == null ? STRING_CONSTANT : separator ;
separator = separator == null ? STRING_CONSTANT : separator ;
separator = separator == null ? STRING_CONSTANT : separator ;
separator = ObjectUtils . toString ( separator ) ;
separator = ObjectUtils . toString ( separator ) ;
separator = ObjectUtils . toString ( separator ) ;
{ long bits = Double . doubleToLongBits ( value ) ; return ( int ) ( bits ^ bits > > > NUMBER_CONSTANT ) ; }
for ( E constant : values ) { total |= NUMBER_CONSTANT < < constant . ordinal () ; }
int remainder = len - pos ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
return super . equals ( o ) && b == rhs.b ;
return a == rhs.a ;
root = root == null ? th : root ;
return super . equals ( o ) && b == rhs.b ;
return a == rhs.a ;
dev = observed [ i ] - expected [ i ] ;
pos + i >= len || chars [ pos + i ] != chars [ quoteStart + i ]
{ return options == null ? false : options . contains ( option ) ; }
return result != null ? result : value ;
{ return initializer != null ? initializer . get () : null ; }
{ return schedFuture != null ? schedFuture : super . startTimer () ; }
int d2 = tmodd1 == NUMBER_CONSTANT ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ;
long m = ( long ) x * ( long ) y ;
long m = ( long ) x * ( long ) y ;
power % NUMBER_CONSTANT == NUMBER_CONSTANT
{ return ( double ) numerator / ( double ) denominator ; }
{ return ( float ) numerator / ( float ) denominator ; }
{ return obj == null ? NUMBER_CONSTANT : obj . hashCode () ; }
if ( object1 == null || object2 == null ) { return false ; }
assertEquals ( bf_zero . setShortValue ( ( short ) NUMBER_CONSTANT , ( short ) j ) , ( short ) NUMBER_CONSTANT ) ;
if ( str == null || prefix == null ) { return str == null && prefix == null ; }
if ( allStringsNull || longestStrLen == NUMBER_CONSTANT && ! anyStringNull ) { return INDEX_NOT_FOUND ; }
if ( length >= str . length () || length < middle . length () + NUMBER_CONSTANT ) { return str ; }
int noOfItems = endIndex - startIndex ;
int noOfItems = endIndex - startIndex ;
if ( match || preserveAllTokens && lastMatch ) { list . add ( str . substring ( start , i ) ) ; }
if ( match || preserveAllTokens && lastMatch ) { list . add ( str . substring ( start , i ) ) ; }
if ( separator == null || EMPTY . equals ( separator ) ) { return splitWorker ( str , null , max , preserveAllTokens ) ; }
pos < strLen - closeLen
if ( pos == INDEX_NOT_FOUND || pos == str . length () - separator . length () ) { return EMPTY ; }
if ( str . length () <= pos + len ) { return str . substring ( pos ) ; }
return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret ;
startPos > str . length () - searchStr . length ()
int endLimit = str . length () - searchStr . length () + NUMBER_CONSTANT ;
int delimLen = delimiters == null ? - NUMBER_CONSTANT : delimiters.length ;
int delimLen = delimiters == null ? - NUMBER_CONSTANT : delimiters.length ;
inputLineLength - offset > wrapLength
return super . equals ( o ) && b == rhs.b ;
return a == rhs.a ;
if ( cls == null ) { return ! toClass . isPrimitive () ; }
{ boolean b = ch >= CHAR_CONS && ch <= CHAR_CONS ; t += b ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
if ( coll == null || coll . isEmpty () ) { return false ; }
assertEquals ( Boolean.TRUE , triple . getRight () ) ;
assertEquals ( Boolean.FALSE , triple . getRight () ) ;
assertTrue ( STRING_CONSTANT , flag == t . isDaemon () ) ;
triple2 = Triple . of ( null , STRING_CONSTANT , Long . valueOf ( NUMBER_CONSTANT ) )
Object [] original = new Object [] { Boolean.TRUE , Boolean.FALSE } ;
fdf = getInstance ( STRING_CONSTANT , NEW_YORK , Locale.US ) ;
public Locale getLocale () { return mLocale ; }
public TimeZone getTimeZone () { return mTimeZone ; }
public String getPattern () { return mPattern ; }
public Locale getLocale () { return locale ; }
public TimeZone getTimeZone () { return timeZone ; }
public String getPattern () { return pattern ; }
DateFormatSymbols symbols = new DateFormatSymbols ( locale ) ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
if ( str . length () == NUMBER_CONSTANT || deepEmpty ( set ) ) { return StringUtils.EMPTY ; }
if ( cls != null ) { return cls ; } else { throw cnfe ; }
@ Override public Locale getLocale () { return locale ; }
@ Override public TimeZone getTimeZone () { return timeZone ; }
@ Override public String getPattern () { return pattern ; }
@ Override public Locale getLocale () { return mLocale ; }
@ Override public TimeZone getTimeZone () { return mTimeZone ; }
@ Override public String getPattern () { return mPattern ; }
new Runnable () { @ Override public void run () { endOfPeriod () ; } }
@ Override public Object getValue () { return null ; }
Locale getLocale ( ) ;
Locale getLocale ( ) ;
@ Before
@ Before public void setUp ( ) throws Exception { exceptionContext = new DefaultExceptionContext () ; super . setUp () ; }
assertTrue ( rangea . isNegated () ) ;
assertTrue ( rangea . isNegated () ) ;
assertTrue ( rangea . isNegated () ) ;
assertFalse ( rangea . isNegated () ) ;
assertFalse ( rangea . isNegated () ) ;
assertFalse ( rangea . isNegated () ) ;
assertTrue ( rangea . isNegated () ) ;
assertFalse ( rangea . isNegated () ) ;
assertFalse ( new BitField ( NUMBER_CONSTANT ) . isSet ( clearedBit ) ) ;
assertTrue ( hc2a != NUMBER_CONSTANT ) ;
assertTrue ( sb.buffer.length >= NUMBER_CONSTANT ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
@ Override public int hashCode () { return b * NUMBER_CONSTANT + super . hashCode () ; }
{ return parseDateStrictly ( str , null , parsePatterns ) ; }
{ return parseDate ( str , null , parsePatterns ) ; }
DateParser parser = getInstance ( STRING_CONSTANT , GMT ) ;
{ return getInstance ( FormatCache . getPatternForStyle ( Integer . valueOf ( dateStyle ) , null , locale ) , TimeZone . getDefault () , Locale . getDefault () ) ; }
DateFormatSymbols symbols = DateFormatSymbols . getInstance ( locale ) ;
if ( eraBC && format . equals ( SHORT_FORMAT ) && locale . equals ( FastDateParser.JAPANESE_IMPERIAL ) ) { continue; }
if ( year < NUMBER_CONSTANT && locale . equals ( FastDateParser.JAPANESE_IMPERIAL ) ) { continue; }
assertEquals ( locale . toString () + STRING_CONSTANT + formattedDate + STRING_CONSTANT , expectedTime , actualTime ) ;
Strategy strategy = cache . get ( Integer . valueOf ( field ) ) ;
{ return getInstance ( FormatCache . getPatternForStyle ( Integer . valueOf ( dateStyle ) , null , locale ) , TimeZone . getDefault () , Locale . getDefault () ) ; }
return Integer . valueOf ( ++ initializeCalls ) ;
return Integer . valueOf ( REPEAT ) ;
return Integer . valueOf ( initializeCalls ) ;
this . value instanceof StringBuilder
StringBuilder buffer = new StringBuilder () ;
StringBuilder expected = new StringBuilder () ;
StringBuilder buffer = new StringBuilder () ;
StringBuilder buffer = new StringBuilder () ;
StringBuilder result = new StringBuilder () ;
StringBuilder sb = new StringBuilder ( dstInit ) ;
StringBuilder sb = new StringBuilder ( dstInit ) ;
StringBuilder sb = new StringBuilder ( dstInit ) ;
StringBuilder sb = new StringBuilder ( dstInit ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + nibble ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + nibble ) ;
HashMap < Boolean , MutableInt > occurrences = new HashMap < Boolean , MutableInt > ( NUMBER_CONSTANT ) ;
{ System.out . println ( STRING_CONSTANT + osName ) ; }
{ System.out . println ( STRING_CONSTANT + javaVersion ) ; }
{ output = ( int [] ) ArrayUtils . removeAll ( array , toRemove ) ; }
return ( boolean [] ) removeAll ( array , toRemove ) ;
return ( double [] ) removeAll ( array , toRemove ) ;
return ( float [] ) removeAll ( array , toRemove ) ;
return ( long [] ) removeAll ( array , toRemove ) ;
return ( char [] ) removeAll ( array , toRemove ) ;
return ( int [] ) removeAll ( array , toRemove ) ;
return ( short [] ) removeAll ( array , toRemove ) ;
return ( byte [] ) removeAll ( array , toRemove ) ;
result = ( T [] ) removeAll ( array , toRemove )
{ return printer . format ( millis ) ; }
Calendar c = newCalendar () ;
{ if ( str == null ) { return null ; } return WHITESPACE_PATTERN . matcher ( trim ( str ) ) . replaceAll ( STRING_CONSTANT ) ; }
{ if ( str == null ) { return null ; } return WHITESPACE_PATTERN . matcher ( trim ( str ) ) . replaceAll ( SPACE ) ; }
if ( isEmpty ( padStr ) ) { padStr = SPACE ; }
if ( isEmpty ( padStr ) ) { padStr = SPACE ; }
if ( isEmpty ( padStr ) ) { padStr = SPACE ; }
{ out . write ( toUtf16Escape ( codepoint ) ) ; }
final MutableDouble other
final Object obj
final Number operand
final double operand
final Number operand
final double operand
final Number value
final double value
final String value
final Number value
final double value
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final T [] array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final Object [] array
final boolean [] array
final Boolean [] array
final float [] array
final Float [] array
final double [] array
final Double [] array
final byte [] array
final Byte [] array
final short [] array
final Short [] array
final int [] array
final Integer [] array
final long [] array
final Long [] array
final char [] array
final Character [] array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final Object [] array
final Object array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final T [] array
final Boolean [] array
final Float [] array
final Double [] array
final Byte [] array
final Character [] array
final Short [] array
final Integer [] array
final Long [] array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final String [] array
final Object [] array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final T [] array
final Object [] array
final Object array
final Object array
final MutableByte other
final Object obj
final Number operand
final byte operand
final Number operand
final byte operand
final Number value
final byte value
final String value
final Number value
final byte value
final Object obj
@ Override public char charAt ( final int index ) { return seq . charAt ( index ) ; }
public CustomCharSequence ( final CharSequence seq ) { this . seq = seq ; }
final int codepoint
final CharSequenceTranslator . . . translators
final CharSequence input
@ Override public char charAt ( final int arg0 ) { return value . charAt ( arg0 ) ; }
final String value
final MutableInt other
final Object obj
final Number operand
final int operand
final Number operand
final int operand
final Number value
final int value
final String value
final Number value
final int value
final String msg
DateParser getInstance ( final String format ) { return getInstance ( format , TimeZone . getDefault () , Locale . getDefault () ) ; }
final boolean flag
final BasicThreadFactory factory
final Callable < T > call
final Callable < T > call
DatePrinter getInstance ( final String format ) { return getInstance ( format , TimeZone . getDefault () , Locale . getDefault () ) ; }
final Formattable formattable
final Collection < > coll
final String language
final char [] str
final StrBuilder str
final StringBuilder str
final StringBuffer str
final String str
final String str
final Throwable cause
final String msg
final Boolean . . . array
final boolean . . . array
final Boolean . . . array
final boolean . . . array
final Boolean . . . array
final boolean . . . array
final boolean bool
final boolean bool
final boolean bool
final Boolean bool
final Boolean bool
final Boolean bool
final String str
final String str
final Boolean bool
final boolean bool
final boolean bool
final Integer value
final int value
final int value
final Boolean bool
final Boolean bool
final Boolean bool
final Boolean bool
final Boolean bool
final Boolean bool
final Object obj2
final Object value
final String format
final long durationMillis
final long durationMillis
final boolean expression
final T iterable
final T [] array
final T chars
final T chars
final T map
final T collection
final T [] array
final T object
final boolean expression
final int nibble
final int nibble
final boolean [] src
final boolean [] src
final boolean [] src
final char hexDigit
final char hexDigit
final char hexDigit
final char hexDigit
final ObjectStreamClass desc
final byte [] objectData
final InputStream inputStream
final Serializable obj
final T object
final char ch
final char ch
final char ch
final char ch
final char ch
final char ch
final char ch
final char ch
final Character ch
final char ch
final Character ch
final char ch
final Character ch
final char ch
final String str
final Character ch
final String str
final char ch
final Class < > clazz
final String . . . excludeFieldNamesParam
final boolean appendTransients
final boolean appendStatics
final Object array
final Field field
final Class < > clazz
final Field field
final Object object
final Object [] array
final Collection < String > collection
final Object object
final R right
final M middle
final L left
final Throwable cause
@ Override public boolean cancel ( final boolean mayInterruptIfRunning ) { return false ; }
final T value
final T value
final ConcurrentInitializer < T > initializer
final ConcurrentInitializer < T > initializer
final ExecutionException ex
final Throwable ex
final ExecutionException ex
final ExecutionException ex
final ExecutionException ex
final ExecutionException ex
final OPTION option
final OPTION . . . options
final JavaVersion requiredVersion
final String property
final String osNamePrefix
final String versionPrefix
CollectionHolder ( final T collection ) { this . collection = collection ; }
final String replaceTemplate
public void testTwo ( final ChildInterface obj ) {}
public void testOne ( final GrandParentObject obj ) {}
public void testOne ( final Object obj ) {}
public void testOne ( final ParentObject obj ) {}
public void testTwo ( final GrandParentObject obj ) {}
public void testTwo ( final Object obj ) {}
final Class < > c
final Class < > [] c
@ Override public void setValue ( final Object value ) {}
public void oneParameter ( final String s ) {}
public String foo ( final Object o ) { return STRING_CONSTANT ; }
public String foo ( final String s ) { return STRING_CONSTANT ; }
public String foo ( final double d ) { return STRING_CONSTANT ; }
public String foo ( final Integer i ) { return STRING_CONSTANT ; }
public String foo ( final int i ) { return STRING_CONSTANT ; }
public static String bar ( final Object o ) { return STRING_CONSTANT ; }
public static String bar ( final String s ) { return STRING_CONSTANT ; }
public static String bar ( final Integer i ) { return STRING_CONSTANT ; }
final String canonicalName
final Class < > cls
final String canonicalName
final Class < > cls
final Object . . . array
final String className
final Class < > cls
final Class < > . . . classes
final Class < > cls
final Class < > . . . classes
final Class < > cls
final Class < > type
final Class < > type
final boolean autoboxing
final List < Class < > > classes
final List < String > classNames
final HashSet < Class < > > interfacesFound
final Class < > cls
final Class < > cls
final Class < > cls
final Class < > cls
final Class < > cls
final int superHashCode
final short [] array
final short value
final Object [] array
final Object object
final long [] array
final long value
final int [] array
final int value
final float [] array
final float value
final double [] array
final double value
final char [] array
final char value
final byte [] array
final byte value
final boolean [] array
final boolean value
final Object value
final Object value
final Object value
final String summaryObjectEndText
final String summaryObjectStartText
final String sizeEndText
final String sizeStartText
final String nullText
final boolean fieldSeparatorAtEnd
final boolean fieldSeparatorAtStart
final String fieldSeparator
final String fieldNameValueSeparator
final String contentEnd
final String contentStart
final String arraySeparator
final String arrayEnd
final String arrayStart
final boolean arrayContentDetail
final boolean defaultFullDetail
final boolean useFieldNames
final boolean useIdentityHashCode
final boolean useShortClassName
final boolean useClassName
final String format
final Object obj
final Pair < L , R > other
void warn ( final String msg ) { System.err . println ( msg ) ; }
final BitSet coll
final HashSet < Integer > coll
final int count
final int count
final int count
final int count
final int count
@ Override public boolean equals ( final Object obj ) { return EqualsBuilder . reflectionEquals ( this , obj ) ; }
public void setObjectReference ( final TestObjectReference reference ) { this . reference = reference ; }
public TestObjectReference ( final int one ) { this . one = new TestObject ( one ) ; }
final Object o
public TestBCanEqualA ( final int b ) { this . b = b ; }
final Object o
public TestACanEqualB ( final int a ) { this . a = a ; }
final boolean testTransients
public void setT ( final int t ) { this . t = t ; }
public void setB ( final int b ) { this . b = b ; }
final Object o
public void setA ( final int a ) { this . a = a ; }
final Object o
public TestObject ( final int a ) { this . a = a ; }
final String name
final boolean enableSubstitutionInVariables
final StrLookup < > variableResolver
final String suffix
final char suffix
final StrMatcher suffixMatcher
final String prefix
final char prefix
final StrMatcher prefixMatcher
final char escapeCharacter
final StrBuilder source
final StringBuffer source
final Object source
final StrBuilder source
final StringBuffer source
final char [] source
final String source
final StrLookup < > variableResolver
final Map < String , V > valueMap
final Object source
final boolean isEquals
final boolean superEquals
final String toString
final String superToString
final Object object
final short [] array
final short value
final Object [] array
final Object obj
final long [] array
final long value
final int [] array
final int value
final float [] array
final float value
final double [] array
final double value
final char [] array
final char value
final byte [] array
final byte value
final boolean [] array
final boolean value
final Object object
final Object object
final Object object
final ToStringStyle style
final MutableFloat other
final Object obj
final Number operand
final float operand
final Number operand
final float operand
final Number value
final float value
final String value
final Number value
final float value
final int limit
final JavaVersion requiredVersion
final Object obj
final char ch
final String str
final String . . . set
final String . . . setStrs
final Object obj
@ Override public Date parse ( final String source ) throws ParseException { return parser . parse ( source ) ; }
final Calendar calendar
final Date date
final long millis
final int style
final int style
final String pattern
final String str
final char [] cbuf
final int c
@ Override public void mark ( final int readAheadLimit ) { mark = pos ; }
final int index
final int startIndex
final Object obj
final StrBuilder other
final StrBuilder other
final StrMatcher matcher
final StrMatcher matcher
final String str
final String str
final char ch
final char ch
final StrMatcher matcher
final StrMatcher matcher
final String str
final String str
final char ch
final char ch
final StrMatcher matcher
final String str
final char ch
final int length
final int length
final int length
final int startIndex
final int start
final String str
final String str
final StrMatcher matcher
final StrMatcher matcher
final String str
final String str
final char ch
final char ch
final int startIndex
final boolean value
final int index
final char separator
final String separator
final Iterator < > it
final Iterable < > iterable
final Object [] array
final Iterator < > it
final Iterable < > iterable
final T . . . array
final double value
final float value
final long value
final int value
final char ch
final boolean value
final char [] chars
final StrBuilder str
final StringBuilder str
final StringBuffer str
final String str
final Object obj
final double value
final float value
final long value
final int value
final char ch
final boolean value
final char [] chars
final StrBuilder str
final StringBuilder str
final StringBuffer str
final String str
final CharSequence seq
final Object obj
final int startIndex
final int index
final int index
final int capacity
final int length
final String newLine
final String str
private void readObject ( final ObjectInputStream in ) throws ClassNotFoundException { throw new ClassNotFoundException ( SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE ) ; }
{ @ Override public void write ( final int arg0 ) throws IOException { throw new IOException ( SERIALIZE_IO_EXCEPTION_MESSAGE ) ; } }
final String baseMessage
final String label
final String label
final Throwable cause
final String message
final MutableShort other
final Object obj
final Number operand
final short operand
final Number operand
final short operand
final Number value
final short value
final String value
final Number value
final short value
final String str
final String str
final Object array
final float [] array
final double [] array
final byte [] array
final short [] array
final int [] array
final long [] array
final float [] array
final double [] array
final byte [] array
final short [] array
final int [] array
final long [] array
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final Field field
final String languageCode
final String countryCode
final Locale locale
final Locale locale
final String baseMessage
final String label
final String label
final Throwable cause
final String message
final ObjectInputStream objectInputStream
final ObjectOutputStream objectOutputStream
final L listener
final L listener
final Class < L > listenerInterface
final Class < T > listenerInterface
protected String toUtf16Escape ( final int codepoint ) { return STRING_CONSTANT + hex ( codepoint ) ; }
final int codepoint
final int codepoint
public NestableException ( final Throwable t ) { super ( t ) ; }
public void setCause ( final Throwable cause ) { this . cause = cause ; }
public ExceptionWithCause ( final Throwable cause ) { super(); setCause ( cause ) ; }
final String [] eventTypes
void warn ( final String msg ) { System.err . println ( msg ) ; }
private void assertSupportedEncoding ( final String name ) { assertTrue ( STRING_CONSTANT + name , CharEncoding . isSupported ( name ) ) ; }
public AClass ( final AAClass < String > enclosingInstance ) { enclosingInstance . super ( ) ; }
public InspectingClient ( final TestFixture testFixture ) { this . testFixture = testFixture ; }
public MutatingClient ( final TestFixture testFixture ) { this . testFixture = testFixture ; }
final String [] strings
final MutableBoolean other
final Object obj
final Boolean value
final boolean value
final Boolean value
final boolean value
final CharRange r
final Object obj
final CharRange range
final char ch
final char ch
final char ch
final boolean negated
final Throwable th
final Throwable th
final Throwable t
final String stackTrace
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final int codepoint
final int codepoint
final int codepoint
final StrTokenizer tokenizer
final StrTokenizer tokenizer
final String data
final StrTokenizer tokenizer
final int loopCount
final int loopCount
final int loopCount
public static void main ( final String [] args ) { new CharUtilsPerfRun () . run () ; }
final MutableLong other
final Object obj
final Number operand
final long operand
final Number operand
final long operand
final Number value
final long value
final String value
final Number value
final long value
final Object obj
final T obj
final Object other
final Object _value
final T . . . items
final T . . . items
final T . . . values
final T . . . values
final Object obj
final Object object
final Object . . . objects
final Object obj
final T . . . values
@ Override int modify ( final int iValue ) { return iValue % NUMBER_CONSTANT ; }
@ Override int modify ( final int iValue ) { return iValue % NUMBER_CONSTANT ; }
@ Override int modify ( final int iValue ) { return iValue - NUMBER_CONSTANT ; }
final Locale locale
int modify ( final int iValue ) { return iValue ; }
NumberStrategy ( final int field ) { this . field = field ; }
CopyQuotedStrategy ( final String formatField ) { this . formatField = formatField ; }
final int field
final Calendar definingCalendar
final int twoDigitYear
final String source
@ Override public Object parseObject ( final String source ) throws ParseException { return parse ( source ) ; }
final ObjectInputStream in
final Object obj
final byte holder
final short holder
final int holder
final byte holder
final short holder
final int holder
final int holder
final int holder
final short holder
final int holder
final short holder
final int holder
final int mask
final Annotation a
final java.lang.Class < > cls
final String formattedDate
final String input
final boolean ignoreEmptyTokens
final boolean emptyAsNull
final StrMatcher trimmer
final char ignored
final StrMatcher ignored
final char quote
final StrMatcher quote
final String delim
final char delim
final StrMatcher delim
final List < String > list
final String obj
final String obj
final char [] input
final String input
final char [] input
final String input
final char [] input
final String input
final char [] input
final String input
final int codepoint
final int codepoint
CollectionHolder ( final T collection ) { this . collection = collection ; }
final Object obj
final T value
final T value
final CharSequence [] . . . lookup
final R value
final int unit
final Date date
final Object o
public void setA ( final int a ) { this . a = a ; }
final Object o
public TestObject ( final int a ) { this . a = a ; }
final R value
final R right
final L left
final String toString
final String toString
final String toString
final Type type
final Type type
final ParameterizedType parameterizedType
final WildcardType wildcardType
final WildcardType wildcardType
final TypeVariable < > typeVariable
final Type [] bounds
final ParameterizedType type
c = new Comparable () { @ Override public int compareTo ( final Object other ) { return NUMBER_CONSTANT ; } }
final Constructor < T > ctor
final Class < T > cls
final Class < T > cls
final Class < T > cls
final Class < T > cls
final String str
final String str
final String str
final char . . . delimiters
final String str
final String str
final CharSequenceTranslator . . . translators
final String [] [] array
final boolean testTransients
final boolean testTransients
final Class < E > enumClass
final Class < E > enumClass
final Class < E > enumClass
final Class < E > enumClass
final Class < E > enumClass
final CharSequence cs
final String val
final String str
final String str
final String str
final String str
final String str
final String str
final float [] array
final double [] array
final float [] array
final double [] array
final String str
CharMatcher ( final char ch ) { super(); this . ch = ch ; }
final char chars []
final String str
final String chars
final char . . . chars
final char ch
final String name
final String name
final String name
final String name
final String name
final ExecutorService exec
final String format
final Object obj
final Range < T > other
final Range < T > otherRange
final Range < T > otherRange
final Range < T > otherRange
final Range < T > otherRange
final T element
final T element
final T element
final T element
final T element
final T element
final T element
final String str
final int threshold
final String . . . strs
final CharSequence . . . css
final String str
final String str
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final String str
final String str
final String str
final String str
final String str
final int size
final CharSequence cs
final String str
final String str
final String str
final String str
final T . . . elements
final String str
final String str
final String str
final String str
final String str
final String str
final CharSequence seq
final String input
final String . . . strs
final String stripChars
final String str
final String str
final String str
final String str
final String str
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final String format
final Object obj
final ExecutorService exec
final ExecutorService execDestroy
final ExecutorService externalExecutor
final ExecutorService exec
final Throwable cause
final Class < > c
final Class < > [] c
public TestBean ( final Object o ) { toString = STRING_CONSTANT ; }
public TestBean ( final String s ) { toString = STRING_CONSTANT ; }
public TestBean ( final double d ) { toString = STRING_CONSTANT ; }
public TestBean ( final Integer i ) { toString = STRING_CONSTANT ; }
public TestBean ( final int i ) { toString = STRING_CONSTANT ; }
public SimpleReflectionTestFixture ( final Object o ) { this . o = o ; }
final Object o
final Collection < > coll
final ParsePosition pos
final String desc
final Object obj
final String pattern
final String pattern
final Object obj
final Object . . . keys
final String pattern
final int count
final int count
final int count
final int count
final int count
final int superCompareTo
final Fraction other
final Object obj
final Fraction fraction
final Fraction fraction
final Fraction fraction
final Fraction fraction
final int power
public BackgroundInitializerTestImpl ( final ExecutorService exec ) { super ( exec ) ; }
final BackgroundInitializerTestImpl init
final boolean fieldSeparatorAtEnd
final boolean fieldSeparatorAtStart
final boolean arrayContentDetail
final boolean defaultFullDetail
final boolean useFieldNames
final boolean useIdentityHashCode
final boolean useShortClassName
final boolean useClassName
final Class < > cls
final Boolean fullDetailRequest
final StringBuffer buffer
final StringBuffer buffer
final StringBuffer buffer
final StringBuffer buffer
final Object value
final Object value
final Object value
final Object o
final TestObject rhs
public void setA ( final int a ) { this . a = a ; }
final Object o
public TestObject ( final int a ) { this . a = a ; }
private void assertGetClassThrowsClassNotFound ( final String className ) throws Exception { assertGetClassThrowsException ( className , ClassNotFoundException . class ) ; }
private void assertGetClassThrowsNullPointerException ( final String className ) throws Exception { assertGetClassThrowsException ( className , NullPointerException . class ) ; }
final Class < > c
public void removePropertyChangeListener ( final PropertyChangeListener listener ) { listeners . removeListener ( listener ) ; }
public void addPropertyChangeListener ( final PropertyChangeListener listener ) { listeners . addListener ( listener ) ; }
protected void addVetoableChangeListener ( final VetoableChangeListener listener ) {}
final String property
public void addPropertyChangeListener ( final PropertyChangeListener listener ) { throw new RuntimeException () ; }
public void addMultipleEventListener ( final MultipleEventListener listener ) { listeners . addListener ( listener ) ; }
final String eventName
final Class < L > listenerType
public void eventOccurred ( final PropertyChangeEvent e ) { count ++ ; }
new PropertyChangeListener () { @ Override public void propertyChange ( final PropertyChangeEvent e ) {} }
final Object obj
final boolean colon
final NumberRule rule
final NumberRule rule
TwoDigitNumberField ( final int field ) { mField = field ; }
UnpaddedNumberField ( final int field ) { mField = field ; }
final String value
CharacterLiteral ( final char value ) { mValue = value ; }
final ObjectInputStream in
final Object obj
final Calendar calendar
final Date date
final Calendar c
final long millis
{ @ Override public void vetoableChange ( final PropertyChangeEvent e ) { calledListeners . add ( this ) ; } }
{ @ Override public void vetoableChange ( final PropertyChangeEvent e ) { listenerSupport . removeListener ( this ) ; } }
listenerSupport . addListener ( new VetoableChangeListener () { @ Override public void vetoableChange ( final PropertyChangeEvent e ) {} } ) ;
final String key
final Map < String , V > map
final Map < String , V > map
final String baseMessage
final String label
final String label
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final boolean [] src
final Class < > destClass
final Member m
final int modifiers
final AccessibleObject o
final Thread.UncaughtExceptionHandler handler
final int prio
final boolean f
final String pattern
final ThreadFactory factory
final Thread t
final Runnable r
final Builder builder
{ for ( final String s : strings ) { if ( StringUtils . isNotEmpty ( s ) ) { return false ; } } }
final long total = System . currentTimeMillis () - start ;
final char c = Character . forDigit ( nibble , NUMBER_CONSTANT ) ;
{ try { return cloneReset () ; } catch ( final CloneNotSupportedException ex ) { return null ; } }
{ final StrTokenizer tok = getTSVClone () ; tok . reset ( input ) ; return tok ; }
{ final StrTokenizer tok = getTSVClone () ; tok . reset ( input ) ; return tok ; }
{ final StrTokenizer tok = getCSVClone () ; tok . reset ( input ) ; return tok ; }
{ final StrTokenizer tok = getCSVClone () ; tok . reset ( input ) ; return tok ; }
final IDKey idKey = ( IDKey ) other ;
catch ( final InterruptedException iex ) { Thread . currentThread () . interrupt () ; }
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final Boolean b = array [ i ] ;
final Float b = array [ i ] ;
final Double b = array [ i ] ;
final Byte b = array [ i ] ;
final Short b = array [ i ] ;
final Integer b = array [ i ] ;
final Long b = array [ i ] ;
final Character b = array [ i ] ;
for ( final CharSequence searchString : searchStrings ) { if ( StringUtils . endsWith ( string , searchString ) ) { return true ; } }
for ( final CharSequence searchString : searchStrings ) { if ( StringUtils . startsWith ( string , searchString ) ) { return true ; } }
final CharSequence tmp = s ;
final int smallestIndexOfDiff = indexOfDifference ( strs ) ;
final int at = indexOfDifference ( str1 , str2 ) ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int pads = size - str . length () ;
final int pads = size - str . length () ;
final char [] chars = str . toCharArray () ;
final int pos = str . lastIndexOf ( separator ) ;
final int pos = str . lastIndexOf ( separator ) ;
final int pos = str . indexOf ( separator ) ;
final int pos = str . indexOf ( separator ) ;
final int strLen = seq . length () ;
{ final String ts = trim ( str ) ; return isEmpty ( ts ) ? null : ts ; }
final short anotherVal = other.value ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder ( NUMBER_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor ( THREAD_POOL_SIZE ) ;
final StringBuilder canonicalClassNameBuffer = new StringBuilder ( className ) ;
final int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ;
for ( final Object name : coll ) { if ( name != null ) { return true ; } }
final char [] buffer = pattern . toCharArray () ;
final ExtendedMessageFormat rhs = ( ExtendedMessageFormat ) obj ;
final String toString = AnnotationUtils . toString ( testAnno ) ;
final byte anotherVal = other.value ;
{ final boolean anotherVal = other.value ; return value == anotherVal ? NUMBER_CONSTANT : ( value ? NUMBER_CONSTANT : - NUMBER_CONSTANT ) ; }
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final OctalUnescaper oue = new OctalUnescaper () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final EqualsBuilder equalsBuilder = new EqualsBuilder () ;
final EqualsBuilder equalsBuilder = new EqualsBuilder () ;
final TestSubObject rhs = ( TestSubObject ) o ;
final TestObject rhs = ( TestObject ) o ;
final String str = f . toProperString () ;
final String str = f . toString () ;
try { f1 . compareTo ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( final NullPointerException ex ) {}
try { f = f . abs () ; fail ( STRING_CONSTANT ) ; } catch ( final ArithmeticException ex ) {}
try { f = f . negate () ; fail ( STRING_CONSTANT ) ; } catch ( final ArithmeticException ex ) {}
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
{ final ExecutorService exec = Executors . newSingleThreadExecutor () ; new CallableBackgroundInitializer < Integer > ( null , exec ) ; }
final StrTokenizer tkn = new StrTokenizer ( STRING_CONSTANT ) ;
final StrTokenizer tok = new StrTokenizer ( STRING_CONSTANT ) ;
final StrTokenizer tok = new StrTokenizer ( STRING_CONSTANT ) ;
final StrTokenizer tok = new StrTokenizer () ;
final String input = STRING_CONSTANT ;
try { tokenizer . next () ; fail () ; } catch ( final NoSuchElementException ex ) {}
{ final float anotherVal = other.value ; return Float . compare ( value , anotherVal ) ; }
final int len = chars.length ;
{ final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . isException ( STRING_CONSTANT ) ; }
{ final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getException ( STRING_CONSTANT ) ; }
{ final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getResultObject ( STRING_CONSTANT ) ; }
{ final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getInitializer ( STRING_CONSTANT ) ; }
catch ( final IllegalStateException istex ) { initializer . get () ; }
final ExecutorService exec = Executors . newCachedThreadPool () ;
final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer . get () ;
final Object item = array [ i ] ;
for ( final char delimiter : delimiters ) { if ( ch == delimiter ) { return true ; } }
for ( final BackgroundInitializer < > bi : childInitializers . values () ) { result += bi . getTaskCount () ; }
final Integer i = Integer . valueOf ( NUMBER_CONSTANT ) ;
final long millisPerUnit = getMillisPerUnit ( unit ) ;
final Calendar calendar = Calendar . getInstance () ;
final Calendar gval = Calendar . getInstance () ;
final Calendar gval = Calendar . getInstance () ;
final Calendar gval = Calendar . getInstance () ;
final Calendar gval = Calendar . getInstance () ;
{ final Calendar c = Calendar . getInstance () ; c . setTime ( date ) ; return c ; }
final Calendar c = Calendar . getInstance () ;
final Calendar c = Calendar . getInstance () ;
try { result = neu . translate ( input ) ; fail ( STRING_CONSTANT ) ; } catch ( final IllegalArgumentException iae ) {}
final NumericEntityUnescaper neu = new NumericEntityUnescaper () ;
{ final DateParser parser = getInstance ( yMdHmsSZ , REYKJAVIK ) ; assertEquals ( REYKJAVIK , parser . getTimeZone () ) ; }
{ final DateParser parser = getInstance ( yMdHmsSZ , SWEDEN ) ; assertEquals ( SWEDEN , parser . getLocale () ) ; }
{ final DateParser parser = getInstance ( yMdHmsSZ ) ; assertEquals ( yMdHmsSZ , parser . getPattern () ) ; }
{ final DateParser parser = getInstance ( YMD_SLASH ) ; assertTrue ( parser . toString () . startsWith ( STRING_CONSTANT ) ) ; }
final Calendar cal = Calendar . getInstance () ;
final int gmt = msg . indexOf ( STRING_CONSTANT ) ;
final Object object = getObject () ;
final int part1 = name . hashCode () * NUMBER_CONSTANT ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
final String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
{ final BasicThreadFactory factory = new BasicThreadFactory ( this ) ; reset () ; return factory ; }
{ try { return getAccessibleConstructor ( cls . getConstructor ( parameterTypes ) ) ; } catch ( final NoSuchMethodException e ) { return null ; } }
final CustomCharSequence other = ( CustomCharSequence ) obj ;
{ final BasicThreadFactory factory = builder . build () ; checkFactoryDefaults ( factory ) ; }
final StrLookup < > resolver = getVariableResolver () ;
final StrBuilder buf = new StrBuilder ( NUMBER_CONSTANT ) ;
final StrBuilder buf = new StrBuilder ( source ) ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final T value
final T value
final StringBuffer buffer = new StringBuffer () ;
{ for ( final Object object : objects ) { hash = hash * NUMBER_CONSTANT + ObjectUtils . hashCode ( object ) ; } }
if ( values != null ) { for ( final T val : values ) { if ( val != null ) { return val ; } } }
final StrBuilder buf = new StrBuilder () ;
final StrSubstitutor sub = new StrSubstitutor () ;
{ final StrSubstitutor sub = new StrSubstitutor () ; assertEquals ( STRING_CONSTANT , sub . replace ( STRING_CONSTANT ) ) ; }
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
{ final StrSubstitutor sub = new StrSubstitutor () ; assertEquals ( STRING_CONSTANT , sub . replace ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final FastDateFormat other = ( FastDateFormat ) obj ;
final Object obj = map . get ( key ) ;
catch ( final NoSuchMethodException e ) {}
final String src = STRING_CONSTANT ;
final String src = STRING_CONSTANT ;
final String src = STRING_CONSTANT ;
final String src = STRING_CONSTANT ;
{ for ( final short element : array ) { append ( element ) ; } }
{ for ( final Object element : array ) { append ( element ) ; } }
{ for ( final long element : array ) { append ( element ) ; } }
{ for ( final int element : array ) { append ( element ) ; } }
{ for ( final float element : array ) { append ( element ) ; } }
{ for ( final double element : array ) { append ( element ) ; } }
{ for ( final char element : array ) { append ( element ) ; } }
{ for ( final byte element : array ) { append ( element ) ; } }
{ for ( final boolean element : array ) { append ( element ) ; } }
final Object key
final CompareToBuilder compareToBuilder = new CompareToBuilder () ;
final Type rawType = parameterizedType . getRawType () ;
final Type replacementType = typeVarAssigns . get ( type ) ;
final Type bound
catch ( final Exception e ) { assertTrue ( exceptionType . isAssignableFrom ( e . getClass () ) ) ; }
final boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
final boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
final StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
{ final R result = getRight () ; setRight ( value ) ; return result ; }
final int properNumerator = getProperNumerator () ;
final Fraction other = ( Fraction ) obj ;
final Fraction f = this . multiplyBy ( this ) ;
final int gcd = greatestCommonDivisor ( numerator , denominator ) ;
final E value
final E constant
try { return Enum . valueOf ( enumClass , enumName ) ; } catch ( final IllegalArgumentException ex ) { return null ; }
try { Enum . valueOf ( enumClass , enumName ) ; return true ; } catch ( final IllegalArgumentException ex ) { return false ; }
final TimeZoneDisplayKey other = ( TimeZoneDisplayKey ) obj ;
final TimeZone zone = calendar . getTimeZone () ;
{ final int len = mValues [ i ] . length () ; if ( len > max ) { max = len ; } }
final FastDatePrinter other = ( FastDatePrinter ) obj ;
{ for ( final Rule rule : mRules ) { rule . appendTo ( buf , calendar ) ; } return buf ; }
{ final Calendar c = newCalendar () ; c . setTime ( date ) ; return applyRules ( c , buf ) ; }
{ final Calendar c = newCalendar () ; c . setTime ( date ) ; return applyRulesToString ( c ) ; }
{ final Calendar c = newCalendar () ; c . setTimeInMillis ( millis ) ; return applyRulesToString ( c ) ; }
final StrMatcher matcher = StrMatcher . stringMatcher ( STRING_CONSTANT ) ;
final StrMatcher matcher = StrMatcher . stringMatcher ( STRING_CONSTANT ) ;
final StrMatcher matcher = StrMatcher . charSetMatcher ( STRING_CONSTANT ) ;
final StrMatcher matcher = StrMatcher . charMatcher ( CHAR_CONS ) ;
final StrMatcher matcher = StrMatcher . noneMatcher () ;
final StrMatcher matcher = StrMatcher . quoteMatcher () ;
final StrMatcher matcher = StrMatcher . doubleQuoteMatcher () ;
final StrMatcher matcher = StrMatcher . singleQuoteMatcher () ;
final StrMatcher matcher = StrMatcher . trimMatcher () ;
final StrMatcher matcher = StrMatcher . splitMatcher () ;
final StrMatcher matcher = StrMatcher . spaceMatcher () ;
final StrMatcher matcher = StrMatcher . tabMatcher () ;
final StrMatcher matcher = StrMatcher . commaMatcher () ;
final String oldValue = this . property ;
{ final Integer count = eventCounts . get ( eventName ) ; return count == null ? NUMBER_CONSTANT : count . intValue () ; }
catch ( final RuntimeException e ) {}
final char pad = CHAR_CONS ;
final Token tok2 = ( Token ) obj2 ;
final int sz = tokens.length ;
final String str = super . getContent () ;
final char buf [] = buffer ;
final int strLen = str . length () ;
final char [] thisBuf = buffer ;
final char [] thisBuf = buffer ;
final int len = str . length () ;
final int len = str . length () ;
final char [] buf = buffer ;
final int newSize = size - removeLen + insertLen ;
final int len = endIndex - startIndex ;
final int len = chars.length ;
{ if ( iterable != null ) { for ( final Object o : iterable ) { append ( o ) ; } } return this ; }
{ for ( final Object element : array ) { append ( element ) ; } }
final int len = length () ;
final int len = length () ;
final int len = length () ;
final int len = length () ;
final int len = length () ;
final int len = length () ;
final int len = length () ;
final char [] old = buffer ;
final char [] old = buffer ;
for ( final String textKeyValue : keyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
final FastDateParser other = ( FastDateParser ) obj ;
final long testResult = DateUtils . getFragmentInHours ( aCalendar , Calendar.YEAR ) ;
final long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.YEAR ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.YEAR ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.YEAR ) ;
final long testResult = DateUtils . getFragmentInHours ( aCalendar , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInHours ( aDate , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInMinutes ( aDate , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.MONTH ) ;
final long expectedValue = hours ;
final long expectedValue = hours ;
{ final long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.HOUR_OF_DAY ) ; assertEquals ( minutes , testResult ) ; }
{ final long testResult = DateUtils . getFragmentInMinutes ( aDate , Calendar.HOUR_OF_DAY ) ; assertEquals ( minutes , testResult ) ; }
final long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.HOUR_OF_DAY ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.HOUR_OF_DAY ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.HOUR_OF_DAY ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.HOUR_OF_DAY ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.MINUTE ) ;
{ final long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.MINUTE ) ; assertEquals ( seconds , testResult ) ; }
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.MINUTE ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.MINUTE ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.SECOND ) ;
{ final long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.SECOND ) ; assertEquals ( millis , testResult ) ; }
final CharRange rangea = CharRange . isNot ( CHAR_CONS ) ;
final CharRange rangea = CharRange . is ( CHAR_CONS ) ;
final boolean element
for ( final boolean element : array ) { if ( element ) { return true ; } }
for ( final boolean element : array ) { if ( ! element ) { return false ; } }
try { intRange . elementCompareTo ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( final NullPointerException npe ) {}
{ final String str = intRange . toString ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , str ) ; }
final String str = intRange . toString () ;
{ final DatePrinter printer = getInstance ( YYYY_MM_DD , NEW_YORK ) ; assertEquals ( NEW_YORK , printer . getTimeZone () ) ; }
{ final DatePrinter printer = getInstance ( YYYY_MM_DD , SWEDEN ) ; assertEquals ( SWEDEN , printer . getLocale () ) ; }
{ final DatePrinter printer = getInstance ( YYYY_MM_DD ) ; assertEquals ( YYYY_MM_DD , printer . getPattern () ) ; }
{ final DatePrinter printer = getInstance ( YYYY_MM_DD ) ; assertTrue ( printer . toString () . startsWith ( STRING_CONSTANT ) ) ; }
try { NumberUtils . createNumber ( STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( final NumberFormatException nfe ) {}
final String osName = System . getProperty ( STRING_CONSTANT ) ;
final String javaVersion = System . getProperty ( STRING_CONSTANT ) ;
final File dir = SystemUtils . getUserHome () ;
final File dir = SystemUtils . getUserDir () ;
final File dir = SystemUtils . getJavaIoTmpDir () ;
final File dir = SystemUtils . getJavaHome () ;
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
{ final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; assertFalse ( STRING_CONSTANT , init . isStarted () ) ; }
{ final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; init . get () ; }
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
{ final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; assertNull ( STRING_CONSTANT , init . getActiveExecutor () ) ; }
{ final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; init . start () ; checkInitialize ( init ) ; }
try { CharUtils . toIntValue ( CHAR_CONS ) ; } catch ( final IllegalArgumentException ex ) {}
try { CharUtils . toChar ( ( Character ) null ) ; } catch ( final IllegalArgumentException ex ) {}
{ final double anotherVal = other.value ; return Double . compare ( value , anotherVal ) ; }
{ final long bits = Double . doubleToLongBits ( value ) ; return ( int ) ( bits ^ bits > > > NUMBER_CONSTANT ) ; }
final String o1 = STRING_CONSTANT ;
final String o1 = STRING_CONSTANT ;
{ final TestObject o1 = new TestObject ( NUMBER_CONSTANT ) ; CompareToBuilder . reflectionCompare ( o1 , null ) ; }
final TestSubObject rhs = ( TestSubObject ) o ;
final TestObject rhs = ( TestObject ) o ;
final long anotherVal = other.value ;
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
{ final Integer [] iArray = null ; assertEquals ( null , ArrayUtils . toPrimitive ( iArray , Integer.MIN_VALUE ) ) ; }
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
final StringBuffer buf = new StringBuffer ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
{ final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , sb . toString () ) ; }
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
catch ( final IndexOutOfBoundsException ex ) {}
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
{ for ( final L listener : listeners ) { method . invoke ( listener , args ) ; } return null ; }
final BitSet toRemove = new BitSet () ;
final Locale dflt = Locale . getDefault () ;
final Locale dflt = Locale . getDefault () ;
final Locale dflt = Locale . getDefault () ;
final Locale dflt = Locale . getDefault () ;
final Locale dflt = Locale . getDefault () ;
final Calendar testCalendar = Calendar . getInstance () ;
try { DateUtils . toCalendar ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( final NullPointerException npe ) {}
final GregorianCalendar cal = new GregorianCalendar () ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
catch ( final IllegalArgumentException ex ) {}
catch ( final IllegalArgumentException ex ) {}
{ try { return parentClass . getMethod ( methodName , parameterTypes ) ; } catch ( final NoSuchMethodException e ) { return null ; } }
{ try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( final NoSuchMethodException e ) { return null ; } }
try { return Charset . isSupported ( name ) ; } catch ( final IllegalCharsetNameException ex ) { return false ; }
catch ( final SerializationException ex ) { return; }
{ final Object test = SerializationUtils . clone ( null ) ; assertNull ( test ) ; }
try { SerializationUtils . deserialize ( new byte [ NUMBER_CONSTANT ] ) ; } catch ( final SerializationException ex ) { return; }
try { SerializationUtils . deserialize ( ( byte [] ) null ) ; } catch ( final IllegalArgumentException ex ) { return; }
catch ( final SerializationException ex ) { return; }
catch ( final SerializationException ex ) { return; }
try { SerializationUtils . deserialize ( ( InputStream ) null ) ; } catch ( final IllegalArgumentException ex ) { return; }
{ try { SerializationUtils . serialize ( null , null ) ; } catch ( final IllegalArgumentException ex ) { return; } fail () ; }
{ try { SerializationUtils . serialize ( iMap , null ) ; } catch ( final IllegalArgumentException ex ) { return; } fail () ; }
final Exception ex = new Exception () ;
catch ( final IllegalStateException e ) {}
final Object obj = new Object () ;
final TestSubObject rhs = ( TestSubObject ) o ;
final TestObject rhs = ( TestObject ) o ;
final MessageFormat result = new MessageFormat ( pattern ) ;
for ( final Locale locale : locales ) { checkBuiltInFormat ( pattern , registry , args , locale ) ; }
final CharSet other = ( CharSet ) obj ;
{ for ( final CharRange range : set ) { if ( range . contains ( ch ) ) { return true ; } } return false ; }
final int sz = set.length ;
{ try { throw new ExceptionWithoutCause () ; } catch ( final Throwable t ) { return t ; } }
try { mutNum . compareTo ( null ) ; fail () ; } catch ( final NullPointerException ex ) {}
try { mutNum . setValue ( null ) ; fail () ; } catch ( final NullPointerException ex ) {}
try { new MutableShort ( ( Number ) null ) ; fail () ; } catch ( final NullPointerException ex ) {}
catch ( final IllegalArgumentException expected ) {}
final char cur = current ;
final StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
final CharRange other = ( CharRange ) obj ;
if ( start > end ) { final char temp = start ; start = end ; end = temp ; }
catch ( final SecurityException ex ) { System.err . println ( STRING_CONSTANT + property + STRING_CONSTANT ) ; return null ; }
catch ( final ConcurrentException cex ) { throw new ConcurrentRuntimeException ( cex . getCause () ) ; }
final V value = map . get ( key ) ;
try { return initialize ( initializer ) ; } catch ( final ConcurrentException cex ) { throw new ConcurrentRuntimeException ( cex . getCause () ) ; }
{ final ConcurrentRuntimeException crex = extractCauseUnchecked ( ex ) ; if ( crex != null ) { throw crex ; } }
{ final ConcurrentException cex = extractCause ( ex ) ; if ( cex != null ) { throw cex ; } }
{ final ByteArrayOutputStream baos = new ByteArrayOutputStream ( NUMBER_CONSTANT ) ; serialize ( obj , baos ) ; return baos . toByteArray () ; }
final String message = exceptionContext . getMessage () ;
final String trace = ExceptionUtils . getStackTrace ( exceptionContext ) ;
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
final Person p = new Person () ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
{ final Object [] array = null ; assertEquals ( NUMBER_CONSTANT , ObjectUtils . hashCodeMulti ( array ) ) ; }
final int anotherVal = other.value ;
final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture () ;
final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture () ;
final SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture () ;
final SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture () ;
final SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture () ;
final SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture () ;
final Outer outer = new Outer () ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final Character c = new Character ( CHAR_CONS ) ;
{ try { coll . add ( null ) ; fail () ; } catch ( final UnsupportedOperationException ex ) {} }
final Locale locale = LocaleUtils . toLocale ( localeString ) ;
final Locale locale = LocaleUtils . toLocale ( localeString ) ;
final Locale locale = LocaleUtils . toLocale ( language ) ;
final IllegalArgumentException ex
final long seed = System . currentTimeMillis () ;
final long seed = System . currentTimeMillis () ;
final String message = exceptionContext . getMessage () ;
final String trace = ExceptionUtils . getStackTrace ( exceptionContext ) ;
try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
final int start = index + NUMBER_CONSTANT ;
try { StrLookup . systemPropertiesLookup () . lookup ( null ) ; fail () ; } catch ( final NullPointerException ex ) {}
{ final BigDecimal value = NumberUtils . createBigDecimal ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final BigInteger value = NumberUtils . createBigInteger ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final Long value = NumberUtils . createLong ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final Integer value = NumberUtils . createInteger ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final Double value = NumberUtils . createDouble ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final Float value = NumberUtils . createFloat ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ return cache . getTimeInstance ( style , timeZone , locale ) ; }
{ return cache . getTimeInstance ( style , timeZone , null ) ; }
{ return cache . getTimeInstance ( style , null , locale ) ; }
{ return cache . getTimeInstance ( style , null , null ) ; }
{ return cache . getDateInstance ( style , timeZone , locale ) ; }
{ return cache . getDateInstance ( style , timeZone , null ) ; }
{ return cache . getDateInstance ( style , null , locale ) ; }
{ return cache . getDateInstance ( style , null , null ) ; }
return SerializationUtils . < T > deserialize ( new ByteArrayInputStream ( objectData ) ) ;
exceptionContext = new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () ) ;
exceptionContext = new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () {} ) ;
Strategy strategy = cache . get ( locale ) ;
if ( nullText != null && nullText . isEmpty () ) { nullText = null ; }
if ( str . isEmpty () ) { return ArrayUtils.EMPTY_STRING_ARRAY ; }
if ( separator . isEmpty () ) { return EMPTY ; }
return str . isEmpty () ? null : str ;
if ( str . isEmpty () || deepEmpty ( set ) ) { return StringUtils.EMPTY ; }
final Integer max = TypeUtilsTest . < Integer > stub () ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () { private static final long serialVersionUID = NUMBER_CONSTANT ; } )
{ if ( this . runningState == State.UNSTARTED ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } return this . startTimeMillis ; }
if ( this . splitState != SplitState.SPLIT ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
{ return new GenericArrayTypeImpl ( Validate . notNull ( componentType , STRING_CONSTANT ) ) ; }
{ FieldUtils . readDeclaredField ( null , STRING_CONSTANT , true ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readDeclaredField ( null , STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readField ( null , publicChild , true ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readField ( null , publicChild ) ; fail ( STRING_CONSTANT ) ; }
assertNull ( LocaleUtils . toLocale ( ( String ) null ) ) ;
final Iterable < ? extends E > values
final Iterable < ? extends E > values
{ return new FastDateParser ( format , timeZone , locale , null ) ; }
assertNull ( StringUtils . normalizeSpace ( null ) ) ;
assertNull ( StringUtils . difference ( null , null ) ) ;
assertNull ( StringUtils . abbreviate ( null , NUMBER_CONSTANT ) ) ;
assertNull ( StringUtils . reverseDelimited ( null , CHAR_CONS ) ) ;
assertNull ( StringUtils . reverse ( null ) ) ;
assertNull ( StringUtils . leftPad ( null , NUMBER_CONSTANT , CHAR_CONS ) ) ;
assertNull ( StringUtils . leftPad ( null , NUMBER_CONSTANT ) ) ;
assertNull ( StringUtils . rightPad ( null , NUMBER_CONSTANT , CHAR_CONS ) ) ;
assertNull ( StringUtils . rightPad ( null , NUMBER_CONSTANT ) ) ;
assertNull ( StringUtils . repeat ( null , NUMBER_CONSTANT ) ) ;
assertNull ( StringUtils . replaceChars ( null , CHAR_CONS , CHAR_CONS ) ) ;
assertNull ( StringUtils . deleteWhitespace ( null ) ) ;
assertNull ( StringUtils . splitPreserveAllTokens ( null , CHAR_CONS ) ) ;
assertNull ( StringUtils . splitPreserveAllTokens ( null ) ) ;
assertNull ( StringUtils . split ( null , CHAR_CONS ) ) ;
assertNull ( StringUtils . split ( null ) ) ;
assertEquals ( minutes + ( ( hours * DateUtils.MILLIS_PER_HOUR ) + ( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_MINUTE , testResult )
assertEquals ( minutes + ( ( hours * DateUtils.MILLIS_PER_HOUR ) + ( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_MINUTE , testResult )
( ( minutes * DateUtils.MILLIS_PER_MINUTE ) + ( hours * DateUtils.MILLIS_PER_HOUR ) + ( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_SECOND
( ( minutes * DateUtils.MILLIS_PER_MINUTE ) + ( hours * DateUtils.MILLIS_PER_HOUR ) + ( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_SECOND
( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY )
( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY )
assertNull ( StringUtils . swapCase ( null ) ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
final Class < > context
final Class < > context
list0 = new ArrayList < Object > ( Arrays . asList ( new Object [ NUMBER_CONSTANT ] ) )
assertEquals ( STRING_CONSTANT , StringUtils . join ( new Object [ NUMBER_CONSTANT ] ) ) ;
return readField ( field , target , false ) ;
return readField ( field , target , false ) ;
writeField ( field , target , value , false ) ;
writeField ( field , target , value , false ) ;
writeField ( field , ( Object ) null , value , false ) ;
writeStaticField ( field , value , false ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toShort ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toDouble ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toFloat ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toLong ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toInt ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toShort ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toDouble ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toFloat ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toLong ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toInt ( null ) == NUMBER_CONSTANT ) ;
{ return new DiffResult ( left , right , diffs , style ) ; }
{ this ( message , cause , null ) ; }
public NotImplementedException ( final Throwable cause ) { this ( cause , null ) ; }
{ this ( message , ( String ) null ) ; }
return Character . codePointCount ( input , NUMBER_CONSTANT , input . length () ) ;
{ pos += Character . charCount ( Character . codePointAt ( input , pos ) ) ; }
final Date centuryStart
{ return getFragment ( calendar , fragment , TimeUnit.DAYS ) ; }
{ return getFragment ( calendar , fragment , TimeUnit.HOURS ) ; }
{ return getFragment ( calendar , fragment , TimeUnit.MINUTES ) ; }
{ return getFragment ( calendar , fragment , TimeUnit.SECONDS ) ; }
{ return getFragment ( calendar , fragment , TimeUnit.MILLISECONDS ) ; }
{ return getFragment ( date , fragment , TimeUnit.DAYS ) ; }
{ return getFragment ( date , fragment , TimeUnit.HOURS ) ; }
{ return getFragment ( date , fragment , TimeUnit.MINUTES ) ; }
{ return getFragment ( date , fragment , TimeUnit.SECONDS ) ; }
{ return getFragment ( date , fragment , TimeUnit.MILLISECONDS ) ; }
return NOT_FOUND ;
final Integer iVal = lKeyValues . get ( value . toLowerCase () ) ;
regex . append ( STRING_CONSTANT ) ;
final Integer iVal = lKeyValues . get ( value . toLowerCase ( locale ) ) ;
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
for ( final String textKeyValue : lKeyValues . keySet () ) { sb . append ( textKeyValue ) . append ( CHAR_CONS ) ; }
for ( final String textKeyValue : lKeyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
shift = i + srcPos ;
shift = i + srcPos ;
shift = i + srcPos ;
shift = i + dstPos ;
shift = i + dstPos ;
shift = i + dstPos ;
shift = i + dstPos ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final Interfaces interfacesBehavior
final String [] zone
{ final int trial = century + twoDigitYear ; return twoDigitYear >= startYear ? trial : trial + NUMBER_CONSTANT ; }
final Calendar definingCalendar
final SimpleClass obj
public SimpleClass ( final boolean booleanField ) { this . booleanField = booleanField ; }
{ final String pattern = STRING_CONSTANT ; FastDateFormat . getInstance ( pattern ) ; }
protected BooleanDiff ( final String fieldName ) { super ( fieldName ) ; }
{ for ( final Token token : tokens ) { if ( token . getValue () == value ) { return true ; } } return false ; }
final Field field
final Class < > cls
final StringBuilder sb = new StringBuilder () ;
final StringBuilder sb = new StringBuilder () ;
{ final int tmpHash = ObjectUtils . hashCode ( object ) ; hash = hash * NUMBER_CONSTANT + tmpHash ; }
final GenericArrayType g
final WildcardType w
final ParameterizedType p
final TypeVariable < > v
final Class < > c
final TypeVariable < > var
final Type type
final Object obj
final Object obj
final Object obj
final Type componentType
final Type . . . bounds
final Type . . . bounds
final double result = RandomUtils . nextDouble ( NUMBER_CONSTANT , Double.MAX_VALUE ) ;
final float result = RandomUtils . nextFloat ( NUMBER_CONSTANT , Float.MAX_VALUE ) ;
final long result = RandomUtils . nextLong ( NUMBER_CONSTANT , Long.MAX_VALUE ) ;
final int result = RandomUtils . nextInt ( NUMBER_CONSTANT , Integer.MAX_VALUE ) ;
final long result = RandomUtils . nextLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final double result = RandomUtils . nextFloat ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final double result = RandomUtils . nextDouble ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final int result = RandomUtils . nextInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
@ Override public void consume ( final String t ) { super . consume ( t ) ; }
@ Override public void consume ( final T t ) {}
final Calendar c = Calendar . getInstance () ;
final Method m
final Method m
final char ch
final char ch
final Object obj
final StringBuilder source
final CharSequence source
final T value
final String fieldName
final TypeTestClass class1 = new TypeTestClass () ;
@ Override public boolean equals ( final Object obj ) { return EqualsBuilder . reflectionEquals ( this , obj , false ) ; }
final TypeTestClass obj
final char firstChar = str . charAt ( NUMBER_CONSTANT ) ;
final char firstChar = str . charAt ( NUMBER_CONSTANT ) ;
final CharSequence . . . css
final CharSequence . . . css
final Locale locale
final Locale locale
final Locale locale
final String [] element
final String [] element
for ( final CharSequence searchString : searchStrings ) { if ( endsWith ( string , searchString ) ) { return true ; } }
for ( final CharSequence searchString : searchStrings ) { if ( startsWith ( string , searchString ) ) { return true ; } }
{ return isEmpty ( str ) ? defaultStr : str ; }
{ return isBlank ( str ) ? defaultStr : str ; }
{ return ! isBlank ( cs ) ; }
{ return ! isEmpty ( cs ) ; }
{ return isDigits ( StringUtils . replaceOnce ( str . substring ( NUMBER_CONSTANT ) , STRING_CONSTANT , StringUtils.EMPTY ) ) ; }
modify ( ceiled , field , ModifyType.CEILING ) ;
modify ( gval , field , ModifyType.CEILING ) ;
modify ( truncated , field , ModifyType.TRUNCATE ) ;
modify ( gval , field , ModifyType.TRUNCATE ) ;
modify ( rounded , field , ModifyType.ROUND ) ;
modify ( gval , field , ModifyType.ROUND ) ;
class Named {}
class Named {}
class Named {}
class Named {}
class Named {}
class Named {}
class Named {}
class Named {}
{ type = array . getClass () . getComponentType () ; }
appendQuotedString ( pattern , pos , sb ) ;
getQuotedString ( pattern , pos ) ;
appendQuotedString ( pattern , pos , stripCustom ) ;
{ regex . append ( pattern ) ; return true ; }
{ if ( value < NUMBER_CONSTANT ) { appendDigits ( buffer , value ) ; } else { buffer . append ( value ) ; } }
exec . awaitTermination ( NUMBER_CONSTANT , TimeUnit.SECONDS ) ;
{ fail ( STRING_CONSTANT + osName ) ; }
return isOSNameMatch ( osName , osNamePrefix ) && osVersion . startsWith ( osVersionPrefix ) ;
return isOSNameMatch ( osName , osNamePrefix ) && isOSVersionMatch ( osVersion , osVersionPrefix ) ;
{ System.out . println ( STRING_CONSTANT + osName ) ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
final int halflength = shorter . length () / NUMBER_CONSTANT + NUMBER_CONSTANT ;
( ! f . getName () . contains ( STRING_CONSTANT ) )
( ! field . getName () . contains ( STRING_CONSTANT ) )
( ! f . getName () . contains ( STRING_CONSTANT ) )
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }
{ if ( ! isEquals ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
if ( ! isEquals ) { return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = superEquals ; return this ; }
modType == ModifyType.CEILING || modType == ModifyType.ROUND && roundUp
{ DateUtils . setMilliseconds ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setSeconds ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setMinutes ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setHours ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setDays ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setMonths ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
try { DateUtils . parseDateStrictly ( dateStr , parsers ) ; fail () ; } catch ( final ParseException ex ) {}
{ regex . append ( VALID_TZ ) ; return true ; }
{ regex . append ( validTimeZoneChars ) ; return true ; }
{ regex . append ( VALID_TZ ) ; return true ; }
cal . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.OCTOBER , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.DECEMBER , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT ) ;
expected . set ( NUMBER_CONSTANT , Calendar.MAY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.OCTOBER , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.DECEMBER , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.JUNE , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ this ( pattern , timeZone , locale , null , true ) ; }
text = DateFormatUtils . format ( cal , DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT . getPattern () , timeZone ) ;
{ return format ( calendar . getTime () , buf ) ; }
final String actualValue = FastDateFormat . getInstance ( PATTERN , this . timeZone ) . format ( cal ) ;
if ( tokenLen == NUMBER_CONSTANT ) { rule = Iso8601_Rule.ISO8601_HOURS_COLON_MINUTES ; } else { rule = TimeZoneNumberRule.INSTANCE_COLON ; }
if ( ! threadGroup . isDestroyed () ) { threadGroup . destroy () ; }
this . typeArguments = typeArguments . clone () ;
@ Override public boolean test ( final Thread thread ) { return true ; }
@ Override public boolean test ( final ThreadGroup threadGroup ) { return true ; }
if ( threadGroups . isEmpty () ) { return Collections . emptyList () ; }
super ( checkNotNull ( object ) , style , buffer ) ;
{ super ( checkNotNull ( object ) , style , buffer ) ; }
{ super ( checkNotNull ( object ) , style ) ; }
{ super ( checkNotNull ( object ) ) ; }
@ Override public boolean test ( final Thread thread ) { return true ; }
@ Override public boolean test ( final ThreadGroup threadGroup ) { return true ; }
if ( threadGroups . isEmpty () ) { return Collections . emptyList () ; }
tz = tzNames . get ( value . toLowerCase ( locale ) ) ;
{ regex . append ( validTimeZoneChars ) ; return true ; }
for ( final String textKeyValue : lKeyValues . keySet () ) { simpleQuote ( regex , textKeyValue ) . append ( CHAR_CONS ) ; }
@ SuppressWarnings ( { STRING_CONSTANT , STRING_CONSTANT } ) final Map < String , String > propertiesMap = ( Map ) properties ;
ISO8601TimeZoneStrategy ( String pattern ) { createPattern ( pattern ) ; }
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( definingCalendar , locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
{ this ( pattern , timeZone , locale , null ) ; }
final String systemNewLine = SystemUtils.LINE_SEPARATOR ;
final String systemNewLine = SystemUtils.LINE_SEPARATOR ;
final DateParser fdp = getInstance ( STRING_CONSTANT , kst , Locale.KOREA ) ;
{ return applyRules ( c , new StringBuilder ( mMaxLengthEstimate ) ) . toString () ; }
assertTrue ( BooleanUtils . toBoolean ( new StringBuilder ( STRING_CONSTANT ) . append ( STRING_CONSTANT ) . toString () ) ) ;
final char newChar = Character . toTitleCase ( firstChar ) ;
{ try { throw new IOException () ; } catch ( Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; } }
if ( count == NUMBER_CONSTANT ) { return StringUtils.EMPTY ; } else if ( count < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + count + STRING_CONSTANT ) ; }
return pattern . matcher ( decomposed ) . replaceAll ( StringUtils.EMPTY ) ;
return new StringBuilder ( annotationType == null ? StringUtils.EMPTY : annotationType . getName () ) . insert ( NUMBER_CONSTANT , CHAR_CONS ) . toString () ;
{ if ( summaryObjectEndText == null ) { summaryObjectEndText = StringUtils.EMPTY ; } this . summaryObjectEndText = summaryObjectEndText ; }
{ if ( summaryObjectStartText == null ) { summaryObjectStartText = StringUtils.EMPTY ; } this . summaryObjectStartText = summaryObjectStartText ; }
{ if ( sizeEndText == null ) { sizeEndText = StringUtils.EMPTY ; } this . sizeEndText = sizeEndText ; }
{ if ( sizeStartText == null ) { sizeStartText = StringUtils.EMPTY ; } this . sizeStartText = sizeStartText ; }
{ if ( nullText == null ) { nullText = StringUtils.EMPTY ; } this . nullText = nullText ; }
{ if ( fieldSeparator == null ) { fieldSeparator = StringUtils.EMPTY ; } this . fieldSeparator = fieldSeparator ; }
{ if ( fieldNameValueSeparator == null ) { fieldNameValueSeparator = StringUtils.EMPTY ; } this . fieldNameValueSeparator = fieldNameValueSeparator ; }
{ if ( contentEnd == null ) { contentEnd = StringUtils.EMPTY ; } this . contentEnd = contentEnd ; }
{ if ( contentStart == null ) { contentStart = StringUtils.EMPTY ; } this . contentStart = contentStart ; }
{ if ( arraySeparator == null ) { arraySeparator = StringUtils.EMPTY ; } this . arraySeparator = arraySeparator ; }
{ if ( arrayEnd == null ) { arrayEnd = StringUtils.EMPTY ; } this . arrayEnd = arrayEnd ; }
{ if ( arrayStart == null ) { arrayStart = StringUtils.EMPTY ; } this . arrayStart = arrayStart ; }
{ return obj == null ? StringUtils.EMPTY : obj . toString () ; }
if ( pos >= count ) { addToken ( tokenList , StringUtils.EMPTY ) ; }
if ( delimiters != null && delimiters.length == NUMBER_CONSTANT ) { return StringUtils.EMPTY ; }
if ( th == null ) { return StringUtils.EMPTY ; }
if ( locale . getCountry () . length () > NUMBER_CONSTANT ) { list . add ( new Locale ( locale . getLanguage () , StringUtils.EMPTY ) ) ; }
if ( length <= NUMBER_CONSTANT || index >= size ) { return StringUtils.EMPTY ; }
{ return StringUtils.EMPTY ; }
{ return StringUtils.EMPTY ; }
if ( str == null ) { str = StringUtils.EMPTY ; }
if ( str == null ) { str = StringUtils.EMPTY ; }
lKeyValues = appendDisplayNames ( definingCalendar , locale , field , regex ) ;
{ return parseDateWithLeniency ( str , locale , parsePatterns , false ) ; }
public TestBean ( final Object o ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean ( final String s ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean ( final double d ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean ( final Integer i ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean ( final int i ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean () { toString = STRING_CONSTANT ; varArgs = null ; }
{ return ( boolean [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( double [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( float [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( long [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( char [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( int [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( short [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( byte [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( T [] ) removeAll ( ( Object ) array , indices ) ; }
{ assertEquals ( str , toString ) ; assertArrayEquals ( args , varArgs ) ; }
{ return getCause ( throwable , null ) ; }
assertEquals ( STRING_CONSTANT , JAVA_9 , get ( STRING_CONSTANT ) ) ;
if ( STRING_CONSTANT . equals ( nom ) ) { return JAVA_1_8 ; } else if ( STRING_CONSTANT . equals ( nom ) ) { return JAVA_9 ; }
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
final boolean isValid = NumberUtils . isCreatable ( val ) ;
if ( srcArgs.length < normalArgsLen ) { return Float.MAX_VALUE ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
final boolean hasSign = firstChar == CHAR_CONS || firstChar == CHAR_CONS ;
final String javaVersion = SystemUtils.JAVA_VERSION ;
if ( ArrayUtils . isEmpty ( css ) ) { return false ; }
if ( ArrayUtils . isEmpty ( css ) ) { return false ; }
if ( ArrayUtils . isEmpty ( css ) ) { return false ; }
if ( ArrayUtils . isEmpty ( css ) ) { return false ; }
{ return new ImmutablePair <> ( left , right ) ; }
final Set < Locale > jdkLocaleSet = new HashSet <> ( jdkLocaleList ) ;
final List < Field > allFieldsInteger = new ArrayList <> ( fieldsInteger ) ;
final CallableBackgroundInitializer < Integer > init = new CallableBackgroundInitializer <> ( call ) ;
{ new CallableBackgroundInitializer <> ( null ) ; }
tasks = new ArrayList <> ()
this . diffs = new ArrayList <> () ;
final HashSet < Integer > toRemove = new HashSet <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > frames = new ArrayList <> () ;
final List < Throwable > list = new ArrayList <> () ;
typeVarAssigns = new HashMap <> ()
final List < Field > annotatedFields = new ArrayList <> () ;
final List < Field > allFields = new ArrayList <> () ;
final Map < String , E > map = new LinkedHashMap <> () ;
final List < String > tokenList = new ArrayList <> () ;
final List < String > list = new ArrayList <> ( tokens.length ) ;
final Set < > set = Collections . unmodifiableSet ( new HashSet <> () ) ;
final Set < > set = Collections . unmodifiableSet ( new HashSet <> () ) ;
final List < Class < > > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
{ return new ConstantFuture <> ( value ) ; }
{ return new MapStrLookup <> ( map ) ; }
final HashMap < Boolean , MutableInt > occurrences = new HashMap <> ( NUMBER_CONSTANT ) ;
final HashMap < Double , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Float , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Long , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Character , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Integer , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Short , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final Map < Byte , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < T , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final AtomicReference < InterruptedException > iex = new AtomicReference <> () ;
{ return new MutablePair <> ( left , right ) ; }
if ( m == null ) { REGISTRY . set ( new WeakHashMap <> () ) ; }
countries = new ArrayList <> () ;
langs = new ArrayList <> () ;
final List < Locale > list = new ArrayList <> ( NUMBER_CONSTANT ) ;
final Set < Type > types = new HashSet <> ( bounds.length ) ;
{ priorVariables = new ArrayList <> () ; priorVariables . add ( new String ( chars , offset , length ) ) ; }
final Map < String , String > valueMap = new HashMap <> () ;
final Map < String , Object > map = new HashMap <> () ;
final Set < String > labels = new HashSet <> () ;
final List < Object > values = new ArrayList <> () ;
{ contextValues . add ( new ImmutablePair <> ( label , value ) ) ; return this ; }
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
iMap = new HashMap <> () ;
this . listeners = new CopyOnWriteArrayList <> ( srcListeners ) ;
final ArrayList < L > serializableListeners = new ArrayList <> () ;
{ return new EventListenerSupport <> ( listenerInterface ) ; }
final List < VetoableChangeListener > calledListeners = new ArrayList <> () ;
final List < Class < > > candidateClasses = new ArrayList <> () ;
final List < String > classNames = new ArrayList <> ( classes . size () ) ;
final List < Class < > > classes = new ArrayList <> () ;
final HashMap < Integer , String > map = new HashMap <> () ;
{ expectedSource = source ; changedValues = new ArrayList <> () ; }
final List < Object > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> ( array.length ) ;
final List < Method > annotatedMethods = new ArrayList <> () ;
final Set < Method > result = new LinkedHashSet <> () ;
this . eventTypes = new HashSet <> ( Arrays . asList ( eventTypes ) ) ;
if ( registry == null ) { registry = new HashSet <> () ; REGISTRY . set ( registry ) ; }
final MutableObject < String > obj = new MutableObject <> ( replaceTemplate ) ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
values = new HashMap <> () ;
final HashMap < T , MutableInt > occurrences = new HashMap <> ( items.length ) ;
final TreeSet < T > sort = new TreeSet <> ( comparator ) ;
final TreeSet < T > sort = new TreeSet <> () ;
final List < ThreadGroup > result = new ArrayList <> ( count ) ;
final List < Thread > result = new ArrayList <> ( count ) ;
final Collection < Thread > result = new ArrayList <> () ;
{ return new ImmutablePair <> ( left , right ) ; }
final Map < DateParser , Integer > map = new HashMap <> () ;
final Set < String > sorted = new TreeSet <> ( LONGER_FIRST_LOWERCASE ) ;
{ caches [ field ] = new ConcurrentHashMap <> ( NUMBER_CONSTANT ) ; }
patterns = new ArrayList <> () ;
final HashSet < Locale > testLocales = new HashSet <> () ;
final String s = new ConstantInitializer <> ( null ) . toString () ;
checkEquals ( new ConstantInitializer <> ( STRING_CONSTANT ) , false ) ;
@ Before public void setUp ( ) throws Exception { init = new ConstantInitializer <> ( VALUE ) ; }
triple = new MutableTriple <> ()
pair = new MutablePair <> ( NUMBER_CONSTANT , STRING_CONSTANT )
final MutablePair < Integer , String > pair = new MutablePair <> () ;
{ return new Range <> ( fromInclusive , toInclusive , comparator ) ; }
tasks = new ArrayList <> ()
List < TimeZone > timeZones = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final ArrayList < String > substrings = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > excludeList = new ArrayList <> () ;
final List < String > excludeList = new ArrayList <> () ;
final List < String > excludeList = new ArrayList <> () ;
final Collection < String > coll = new ArrayList <> () ;
final Collection < String > coll = new ArrayList <> () ;
final List < String > coll = new ArrayList <> () ;
final List < String > coll = new ArrayList <> () ;
final Map < String , Integer > map = new HashMap <> () ;
final Map < String , Integer > map = new HashMap <> () ;
final Collection < Integer > coll = new ArrayList <> () ;
final Collection < Integer > coll = new ArrayList <> () ;
final List < Rule > rules = new ArrayList <> () ;
public CircuitBreakingException ( final Throwable cause ) { super ( cause ) ; }
public CircuitBreakingException ( final String message ) { super ( message ) ; }
public Customer ( final String name ) { this . name = name ; }
public Bank ( final String name ) { this . name = name ; }
final Object object
final Object object
final FastDateParser parser
final FastDateParser parser
final FastDateParser parser
@ Override int modify ( final FastDateParser parser , final int iValue ) { return iValue - NUMBER_CONSTANT ; }
final int tokenLen
ISO8601TimeZoneStrategy ( final String pattern ) { createPattern ( pattern ) ; }
final FastDateParser parser
final FastDateParser parser
void createPattern ( final String regex ) { this . pattern = Pattern . compile ( regex ) ; }
void createPattern ( final StringBuilder regex ) { createPattern ( regex . toString () ) ; }
final char c
final char c
final ListIterator < StrategyAndWidth > lt
public FastDatePrinterTimeZonesTest ( final TimeZone timeZone ) { this . timeZone = timeZone ; }
final int . . . args
final String . . . s
class LANG1261ParentObject { @ Override public boolean equals ( final Object o ) { return true ; } }
final Method method
final SystemDefaults defaults
final SystemDefaults defaults
final int len
final Constructor < > constructor
final Method method
private static Executable of ( final Constructor < > constructor ) { return new Executable ( constructor ) ; }
private static Executable of ( final Method method ) { return new Executable ( method ) ; }
final Number . . . args
final String . . . args
final Number . . . args
final String . . . args
public static String numOverload ( final Number . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Long . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Integer . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Double . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Float . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Short . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Byte . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final String . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Object . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Number . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Long . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Integer . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Double . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Float . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Boolean . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Short . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Character . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Byte . . . args ) { return STRING_CONSTANT ; }
public int [] unboxing ( final int . . . values ) { return values ; }
final PropertyChangeListener listener
final PropertyChangeListener listener
final State newState
final State state
final Boolean . . . values
final PropertyChangeEvent evt
final Object source
final long time
final TimeZone tz
final String valueAsString
final String valueAsString
final int spaces
final Long increment
final long threshold
final boolean [] array
final char [] array
final byte [] array
final short [] array
final long [] array
final int [] array
final int offset
final int offset
final int offset
final int offset
final int offset
final int offset
final int offset
final int offset
final int offset
final TimeZone tz
final int tokenLen
final int value
final Object obj
@ Override protected long fetchCheckInterval ( final EventCountCircuitBreaker breaker ) { return breaker . getClosingInterval () ; }
@ Override protected long fetchCheckInterval ( final EventCountCircuitBreaker breaker ) { return breaker . getOpeningInterval () ; }
final int delta
final State state
final State newState
final int increment
final Integer increment
private NotVisibleException ( final Throwable cause ) { this . cause = cause ; }
final boolean allowDuplicate
final Calendar calendar
final Calendar calendar
final Class < ? extends Throwable > type
final Throwable throwable
final Throwable throwable
final Throwable throwable
final String key
final long nanos
final int max
final StringBuilder decomposed
final int maxWidth
final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
{ final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( zeroThreshold ) ; assertTrue ( STRING_CONSTANT , circuit . incrementAndCheckState ( NUMBER_CONSTANT ) ) ; }
final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
catch ( final UnsupportedOperationException e ) {}
catch ( final UnsupportedOperationException e ) {}
catch ( final UnsupportedOperationException e ) {}
final long randomResult = RandomUtils . nextLong () ;
final float randomResult = RandomUtils . nextFloat () ;
final double randomResult = RandomUtils . nextDouble () ;
final int randomResult = RandomUtils . nextInt () ;
final float result = mutableFloat . addAndGet ( NUMBER_CONSTANT ) ;
final float result = mutableFloat . getAndAdd ( NUMBER_CONSTANT ) ;
final float result = mutNum . getAndDecrement () ;
final float result = mutNum . decrementAndGet () ;
final float result = mutNum . getAndIncrement () ;
final float result = mutNum . incrementAndGet () ;
final Calendar cal = Calendar . getInstance () ;
catch ( final Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , TestThrowable . class ) ) ; }
catch ( final Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , IOException . class ) ) ; }
catch ( final Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , RuntimeException . class ) ) ; }
catch ( final Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , Error . class ) ) ; }
try { throw new IOException () ; } catch ( final Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; }
final byte result = mutNum . getAndDecrement () ;
final byte result = mutNum . decrementAndGet () ;
final byte result = mutNum . getAndIncrement () ;
final byte result = mutNum . incrementAndGet () ;
final short result = mutNum . getAndDecrement () ;
final short result = mutNum . decrementAndGet () ;
final short result = mutNum . getAndIncrement () ;
final short result = mutNum . incrementAndGet () ;
final double result = mutableDouble . addAndGet ( - NUMBER_CONSTANT ) ;
final double result = mutableDouble . getAndAdd ( NUMBER_CONSTANT ) ;
final double result = mutNum . getAndDecrement () ;
final double result = mutNum . decrementAndGet () ;
final double result = mutNum . getAndIncrement () ;
final double result = mutNum . incrementAndGet () ;
final StringBuilder sb = new StringBuilder () ;
final int result = mutNum . getAndDecrement () ;
final int result = mutNum . decrementAndGet () ;
final int result = mutNum . getAndIncrement () ;
final int result = mutNum . incrementAndGet () ;
catch ( final IllegalAccessException e ) { return null ; }
catch ( final Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; }
catch ( final Exception e ) { return ExceptionUtils . < Boolean > rethrow ( e ) ; }
final Format fdf = FastDateFormat . getInstance ( pattern ) ;
{ final StateStrategy strategy = STRATEGY_MAP . get ( state ) ; return strategy ; }
final long time = now () ;
catch ( final InterruptedException iex ) {}
final StringBuilder regex = new StringBuilder () ;
final int sIdx = idx + pos . getIndex () ;
final char c = value . charAt ( i ) ;
final ParsePosition pp = new ParsePosition ( NUMBER_CONSTANT ) ;
final char c = pattern . charAt ( currentIdx ) ;
{ final int last = value ; this . value += operand . intValue () ; return last ; }
{ final int last = value ; this . value += operand ; return last ; }
{ final int last = value ; value -- ; return last ; }
{ final int last = value ; value ++ ; return last ; }
{ final short last = value ; this . value += operand . shortValue () ; return last ; }
{ final short last = value ; this . value += operand ; return last ; }
{ final short last = value ; value -- ; return last ; }
{ final short last = value ; value ++ ; return last ; }
{ final long last = value ; this . value += operand . longValue () ; return last ; }
{ final long last = value ; this . value += operand ; return last ; }
{ final long last = value ; value -- ; return last ; }
{ final long last = value ; value ++ ; return last ; }
final Calendar calendar = Calendar . getInstance () ;
final Calendar cal = Calendar . getInstance ( SWEDEN ) ;
final Calendar cal = Calendar . getInstance ( tz ) ;
{ final float last = value ; this . value += operand . floatValue () ; return last ; }
{ final float last = value ; this . value += operand ; return last ; }
{ final float last = value ; value -- ; return last ; }
{ final float last = value ; value ++ ; return last ; }
final ExecutorService exec = Executors . newSingleThreadExecutor () ;
final Locale save = Locale . getDefault () ;
final TimeZone save = TimeZone . getDefault () ;
{ final String date = STRING_CONSTANT ; DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT . parse ( date ) ; }
final String encoding = STRING_CONSTANT ;
final String methodStr = m . toString () ;
final long result = mutNum . getAndDecrement () ;
final long result = mutNum . decrementAndGet () ;
final long result = mutNum . getAndIncrement () ;
final long result = mutNum . incrementAndGet () ;
final Exception ex
final StringBuilder sb = new StringBuilder ( NUMBER_CONSTANT ) ;
final int lastHold = start ;
final int value = calendar . get ( Calendar.DAY_OF_WEEK ) ;
catch ( final IOException ioe ) { ExceptionUtils . rethrow ( ioe ) ; }
final StringBuilder sb = new StringBuilder () ;
for ( final CharSequence searchCharSequence : searchCharSequences ) { if ( contains ( cs , searchCharSequence ) ) { return true ; } }
{ for ( final CharSequence next : searchStrings ) { if ( equalsIgnoreCase ( string , next ) ) { return true ; } } }
{ for ( final CharSequence next : searchStrings ) { if ( equals ( string , next ) ) { return true ; } } }
{ try { return System . getProperty ( key ) ; } catch ( final SecurityException scex ) {} }
final int [] clonedIndices = clone ( indices ) ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final short aux = array [ offset1 ] ;
final Object aux = array [ offset1 ] ;
final long aux = array [ offset1 ] ;
final int aux = array [ offset1 ] ;
final float aux = array [ offset1 ] ;
final double aux = array [ offset1 ] ;
final char aux = array [ offset1 ] ;
final byte aux = array [ offset1 ] ;
final boolean aux = array [ offset1 ] ;
{ final StopWatch sw = new StopWatch () ; sw . start () ; return sw ; }
final Pattern patternToWrapOn = Pattern . compile ( wrapOn ) ;
final TimeZone utc = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
{ double balance = NUMBER_CONSTANT ; for ( final Transaction tx : transactions ) { balance += tx.amount ; } return balance ; }
final Calendar calendar = Calendar . getInstance () ;
final DateParser parser = getInstance ( YMD_SLASH ) ;
final Calendar cal = Calendar . getInstance ( tz ) ;
{ final byte last = value ; this . value += operand . byteValue () ; return last ; }
{ final byte last = value ; this . value += operand ; return last ; }
{ final byte last = value ; value -- ; return last ; }
{ final byte last = value ; value ++ ; return last ; }
{ final double last = value ; this . value += operand . doubleValue () ; return last ; }
{ final double last = value ; this . value += operand ; return last ; }
{ final double last = value ; value -- ; return last ; }
{ final double last = value ; value ++ ; return last ; }
final Diff < > diff
methodName . equals ( method . getName () ) && Objects . deepEquals ( parameterTypes , method . getParameterTypes () )
Memoizer < Integer , Integer > memoizer = new Memoizer <> ( computable ) ;
Memoizer < Integer , Integer > memoizer = new Memoizer <> ( computable ) ;
Memoizer < Integer , Integer > memoizer = new Memoizer <> ( computable ) ;
if ( ! isEquals ) { return this ; }
final StrategyParser fm = new StrategyParser ( definingCalendar ) ;
public void setCycle ( final TestRecursiveCycleObject cycle ) { this . cycle = cycle ; }
public TestRecursiveCycleObject ( final int n ) { this . n = n ; this . cycle = this ; }
public TestRecursiveInnerObject ( final int n ) { this . n = n ; }
final int offset
final boolean testRecursive
final String . . . excludeFields
final Class < > reflectUpToClass
final boolean testRecursive
final boolean testTransients
final Locale [] availableLocales = NumberFormat . getAvailableLocales () ;
{ mRule . appendTo ( buffer , calendar . getWeekYear () ) ; }
if ( b . compareTo ( BigDecimal . valueOf ( d . doubleValue () ) ) == NUMBER_CONSTANT ) { return d ; }
{ spaceToWrapAt = matcher . start () + offset ; }
@ SuppressWarnings ( { STRING_CONSTANT , STRING_CONSTANT } ) final String [] sa = ArrayUtils . add ( stringArray , NUMBER_CONSTANT , aString ) ;
@ SuppressWarnings ( STRING_CONSTANT ) final T . . . array
assertEquals ( STRING_CONSTANT + locale , expectedPattern , emf . toPattern () ) ;
assertEquals ( STRING_CONSTANT , pattern , emf . toPattern () ) ;
{ assertEquals ( baseStr + STRING_CONSTANT + System . lineSeparator () + STRING_CONSTANT , new ToStringBuilder ( base ) . toString () ) ; }
{ if ( newLine == null ) { append ( System . lineSeparator () ) ; return this ; } return append ( newLine ) ; }
final String linebreak = System . lineSeparator () ;
final String linebreak = System . lineSeparator () ;
final String systemNewLine = System . lineSeparator () ;
final String systemNewLine = System . lineSeparator () ;
if ( newLineStr == null ) { newLineStr = System . lineSeparator () ; }
{ if ( fieldName == null ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; } super . appendFieldStart ( buffer , FIELD_NAME_QUOTE + fieldName + FIELD_NAME_QUOTE ) ; }
assertFalse ( CharUtils . isAsciiPrintable ( CHAR_COPY ) ) ;
final GenericDeclaration d = var . getGenericDeclaration () ;
{ DateUtils . isSameLocalTime ( Calendar . getInstance () , null ) ; }
{ DateUtils . isSameLocalTime ( null , Calendar . getInstance () ) ; }
{ DateUtils . isSameInstant ( Calendar . getInstance () , null ) ; }
{ DateUtils . isSameInstant ( null , Calendar . getInstance () ) ; }
{ DateUtils . isSameInstant ( new Date () , null ) ; }
{ DateUtils . isSameInstant ( null , new Date () ) ; }
{ DateUtils . isSameDay ( Calendar . getInstance () , null ) ; }
{ DateUtils . isSameDay ( null , Calendar . getInstance () ) ; }
{ DateUtils . isSameDay ( new Date () , null ) ; }
{ DateUtils . isSameDay ( null , new Date () ) ; }
assertNull ( LocaleUtils . toLocale ( null ) ) ;
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( NUMBER_CONSTANT ) . toHashCode () ) ;
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( NUMBER_CONSTANT ) . toHashCode () ) ;
assertEquals ( BAR , ObjectUtils . toString ( null , BAR ) ) ;
assertEquals ( STRING_CONSTANT , ObjectUtils . toString ( null ) ) ;
intRange = Range . between ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , BooleanUtils . toString ( null , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEquals ( null , BooleanUtils . toStringYesNo ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringOnOff ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringTrueFalse ( null ) ) ;
assertEquals ( null , BooleanUtils . toIntegerObject ( null ) ) ;
assertTrue ( BooleanUtils . isNotFalse ( null ) ) ;
assertFalse ( BooleanUtils . isFalse ( null ) ) ;
assertTrue ( BooleanUtils . isNotTrue ( null ) ) ;
assertFalse ( BooleanUtils . isTrue ( null ) ) ;
assertEquals ( STRING_CONSTANT , ClassUtils . getSimpleName ( null ) ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
assertSame ( StrMatcher . noneMatcher () , StrMatcher . stringMatcher ( null ) ) ;
array = ArrayUtils . removeElement ( null , true ) ;
array = ArrayUtils . removeElement ( null , STRING_CONSTANT ) ;
sb . replace ( NUMBER_CONSTANT , NUMBER_CONSTANT , null ) ;
sb . setNullText ( null ) ;
sb . setNewLineText ( null ) ;
final StrBuilder sb5 = new StrBuilder ( null ) ;
assertSame ( cyclicCause . getCause () . getCause () , throwables . get ( NUMBER_CONSTANT ) ) ;
assertSame ( cyclicCause . getCause () . getCause () , throwables [ NUMBER_CONSTANT ] ) ;
assertSame ( cyclicCause . getCause () . getCause () , ExceptionUtils . getRootCause ( cyclicCause ) ) ;
{ if ( value <= start || value >= end ) { throw new IllegalArgumentException ( message ) ; } }
{ if ( value <= start || value >= end ) { throw new IllegalArgumentException ( message ) ; } }
{ if ( value < start || value > end ) { throw new IllegalArgumentException ( message ) ; } }
{ if ( value < start || value > end ) { throw new IllegalArgumentException ( message ) ; } }
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
longRange = Range . between ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , NUMBER_CONSTANT ) ) ; }
{ assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , - NUMBER_CONSTANT ) ) ; }
return parseLocale ( str ) ;
classes . add ( NUMBER_CONSTANT , cls ) ;
assertTrue ( trace . contains ( TEST_MESSAGE ) ) ;
assertTrue ( trace . contains ( STRING_CONSTANT ) ) ;
assertTrue ( trace . contains ( TEST_MESSAGE ) ) ;
assertTrue ( trace . contains ( STRING_CONSTANT ) ) ;
assertFalse ( stackTrace . contains ( ExceptionUtils.WRAPPED_MARKER ) ) ;
assertFalse ( stackTrace . contains ( ExceptionUtils.WRAPPED_MARKER ) ) ;
assertFalse ( contextMessage . contains ( TEST_MESSAGE ) ) ;
final HashSet < Integer > toRemove = new HashSet <> () ;
super . reflectionAppendArrayDetail ( buffer , fieldName , array ) ;
final List < Object > list = new ArrayList <> ( NUMBER_CONSTANT ) ;
static String getFieldName () { return STRING_CONSTANT ; }
SelfInstanceTwoVarsReflectionTestFixture () { this . typeIsSelf = this ; }
SelfInstanceVarReflectionTestFixture () { this . typeIsSelf = this ; }
TestSubObject () { super ( NUMBER_CONSTANT ) ; }
assertSame ( StrMatcher . noneMatcher () , StrMatcher . charSetMatcher () ) ;
{ Validate . noNullElements ( values ) ; return generateBitVector ( enumClass , Arrays . asList ( values ) ) ; }
{ return TypeUtils . wrap ( ( Type ) type ) ; }
if ( typeArguments == null ) { typeArguments = Collections . emptyMap () ; }
assertTrue ( StringUtils . containsOnly ( str , CHAR_CONS ) ) ;
assertTrue ( StringUtils . containsOnly ( str , CHAR_CONS ) ) ;
assertTrue ( StringUtils . containsOnly ( str , CHAR_CONS ) ) ;
assertNull ( ObjectUtils . firstNonNull () ) ;
void event2 ( PropertyChangeEvent e ) ;
void event1 ( PropertyChangeEvent e ) ;
TestSubObject () { super ( NUMBER_CONSTANT ) ; }
{ Validate . isTrue ( objectData != null , STRING_CONSTANT ) ; return SerializationUtils . deserialize ( new ByteArrayInputStream ( objectData ) ) ; }
final List < String > strColl = Arrays . asList ( STRING_CONSTANT ) ;
final List < String > strColl = Arrays . asList ( STRING_CONSTANT ) ;
TestEmptySubObject ( final int a ) { super ( a ) ; }
TestSubObject () { super ( NUMBER_CONSTANT ) ; }
BackgroundInitializerTestImpl () { super(); }
@ SuppressWarnings ( STRING_CONSTANT ) NestableException () { super(); }
{ return options != null && options . contains ( option ) ; }
final List < Object > list = new ArrayList <> ( arraylistInitialCapacity ) ;
final List < Object > list = new ArrayList <> ( ARRAYLIST_INITIAL_CAPACITY ) ;
final List < Object > list = new ArrayList <> ( ARRAYLIST_INITIAL_CAPACITY ) ;
if ( isEmpty ( str ) || wrapChar == CharUtils.NUL ) { return str ; }
if ( isEmpty ( str ) || wrapWith == CharUtils.NUL ) { return str ; }
{ if ( isEmpty ( str ) || wrapWith == CharUtils.NUL ) { return str ; } return wrapWith + str + wrapWith ; }
for ( int i = oldEnd ; i < newEnd ; i ++ ) { buffer [ i ] = CharUtils.NUL ; }
assertNull ( StringUtils . unwrap ( null , CharUtils.NUL ) ) ;
{ return ! ObjectUtils . equals ( object1 , object2 ) ; }
if ( ! ( obj instanceof TypeLiteral ) ) { return false ; }
public boolean isFalse () { return ! value ; }
public boolean isTrue () { return value ; }
{ if ( ! expression ) { throw new IllegalStateException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } }
{ if ( ! expression ) { throw new IllegalArgumentException ( DEFAULT_IS_TRUE_EX_MESSAGE ) ; } }
if ( ! ( obj instanceof FastDateFormat ) ) { return false ; }
if ( ! ( obj instanceof Fraction ) ) { return false ; }
if ( ! ( obj instanceof FastDatePrinter ) ) { return false ; }
if ( ! toClass . isPrimitive () ) { return false ; }
{ if ( ! isAsciiNumeric ( ch ) ) { return defaultValue ; } return ch - NUMBER_CONSTANT ; }
if ( ! ( obj instanceof CharSet ) ) { return false ; }
I arg
final Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getRight () , pair . getLeft () ) ;
if ( ! hasNext ) { throw new NoSuchElementException () ; }
if ( ! ( obj instanceof CharRange ) ) { return false ; }
try { CharUtils . toIntValue ( CHAR_CONS ) ; fail ( STRING_CONSTANT ) ; } catch ( final IllegalArgumentException ex ) {}
if ( tzId . equalsIgnoreCase ( TimeZones.GMT_ID ) ) { continue; }
{ cal . setTimeZone ( TimeZone . getTimeZone ( TimeZones.GMT_ID + value ) ) ; }
{ cal . setTimeZone ( TimeZone . getTimeZone ( TimeZones.GMT_ID ) ) ; }
{ return toAppendTo . append ( ( ( String ) obj ) . toUpperCase ( Locale.ROOT ) ) ; }
expected . append ( args [ NUMBER_CONSTANT ] . toString () . toUpperCase ( Locale.ROOT ) ) ;
assertFalse ( StringUtils . equalsAny ( FOO , FOO . toUpperCase ( Locale.ROOT ) ) ) ;
{ return toAppendTo . append ( ( ( String ) obj ) . toLowerCase ( Locale.ROOT ) ) ; }
final Calendar c = Calendar . getInstance ( FastTimeZone . getGmtTimeZone () ) ;
final TimeZone utc = FastTimeZone . getGmtTimeZone () ;
TimeZone . setDefault ( FastTimeZone . getGmtTimeZone () ) ;
final TimeZone utc = FastTimeZone . getGmtTimeZone () ;
timeZone = FastTimeZone . getGmtTimeZone () ;
{ final TimeZone timeZone = FastTimeZone . getGmtTimeZone () ; assertFormats ( expectedValue , pattern , timeZone , createFebruaryTestDate ( timeZone ) ) ; }
final Calendar c = Calendar . getInstance ( FastTimeZone . getGmtTimeZone () ) ;
final Calendar c = Calendar . getInstance ( FastTimeZone . getGmtTimeZone () ) ;
final Calendar c = Calendar . getInstance ( FastTimeZone . getGmtTimeZone () ) ;
assertNull ( StringUtils . substring ( null , NUMBER_CONSTANT ) ) ;
assertNull ( tok . getContent () ) ;
assertNull ( tokenizer . nextToken () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( ObjectUtils . identityToString ( null ) ) ;
assertNull ( StringUtils . strip ( null ) ) ;
assertNull ( StringUtils . trim ( null ) ) ;
assertNull ( BooleanUtils . toStringYesNo ( null ) ) ;
assertNull ( BooleanUtils . toStringOnOff ( null ) ) ;
assertNull ( BooleanUtils . toStringTrueFalse ( null ) ) ;
assertNull ( BooleanUtils . toBooleanObject ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNull ( BooleanUtils . toIntegerObject ( null , six , seven , null ) ) ;
assertNull ( BooleanUtils . toIntegerObject ( null ) ) ;
assertNull ( BooleanUtils . toBooleanObject ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
assertNull ( BooleanUtils . toBooleanObject ( ( Integer ) null ) ) ;
assertNull ( StringEscapeUtils . unescapeJson ( null ) ) ;
assertNull ( StringEscapeUtils . escapeJson ( null ) ) ;
assertNull ( StringEscapeUtils . unescapeCsv ( null ) ) ;
assertNull ( StringEscapeUtils . escapeCsv ( null ) ) ;
assertNull ( StringEscapeUtils . escapeEcmaScript ( null ) ) ;
assertNull ( StringEscapeUtils . escapeEcmaScript ( null ) ) ;
assertNull ( StringEscapeUtils . unescapeJava ( null ) ) ;
assertNull ( StringEscapeUtils . escapeJava ( null ) ) ;
assertNull ( new MutableObject <> () . getValue () ) ;
assertNull ( StringUtils . getDigits ( null ) ) ;
assertNull ( StringUtils . wrap ( null , null ) ) ;
assertNull ( StringUtils . rotate ( null , NUMBER_CONSTANT ) ) ;
assertNull ( ClassUtils . getAllInterfaces ( null ) ) ;
assertNull ( ClassUtils . getAllSuperclasses ( null ) ) ;
assertNull ( WordUtils . swapCase ( null ) ) ;
assertNull ( WordUtils . initials ( null ) ) ;
assertNull ( WordUtils . uncapitalize ( null , null ) ) ;
assertNull ( WordUtils . uncapitalize ( null ) ) ;
assertNull ( WordUtils . capitalizeFully ( null , null ) ) ;
assertNull ( WordUtils . capitalizeFully ( null ) ) ;
assertNull ( WordUtils . capitalize ( null , null ) ) ;
assertNull ( WordUtils . capitalize ( null ) ) ;
{ assertNull ( CharUtils . unicodeEscaped ( null ) ) ; assertEquals ( STRING_CONSTANT , CharUtils . unicodeEscaped ( CHARACTER_A ) ) ; }
assertNull ( CharUtils . toString ( null ) ) ;
assertNull ( ArrayUtils . toPrimitive ( l , Double.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( l , Float.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( l , Long.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
{ final Integer [] iArray = null ; assertNull ( ArrayUtils . toPrimitive ( iArray , Integer.MIN_VALUE ) ) ; }
assertNull ( ArrayUtils . toPrimitive ( l , Integer.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( s , Short.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b , Byte.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b , Character.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( null , false ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( ArrayUtils . toMap ( null ) ) ;
{ assertNull ( CharSequenceUtils . subSequence ( StringUtils.EMPTY , NUMBER_CONSTANT ) ) ; }
{ assertNull ( CharSequenceUtils . subSequence ( StringUtils.EMPTY , - NUMBER_CONSTANT ) ) ; }
{ assertTrue ( toString . indexOf ( SECRET_VALUE ) > NUMBER_CONSTANT ) ; this . validateNonSecretField ( toString ) ; }
{ assertEquals ( ArrayUtils.INDEX_NOT_FOUND , toString . indexOf ( SECRET_VALUE ) ) ; this . validateNonSecretField ( toString ) ; }
assertNotEquals ( summer . getTime () , standard . getTime () ) ;
assertEquals ( cal . getTime () , date ) ;
assertEquals ( value , SerializationUtils . deserialize ( serialized ) ) ;
{ watch . getStartTime () ; assertTrue ( watch . getStartTime () >= beforeStopWatch ) ; }
@ Test public void testUTC () { assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testZ () { assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testBareGmt () { assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testGetGmtTimeZone () { assertEquals ( NUMBER_CONSTANT , FastTimeZone . getGmtTimeZone () . getRawOffset () ) ; }
{ assertEquals ( REPEAT , future . get () . intValue () ) ; }
assertEquals ( STRING_CONSTANT , TypeUtils . toString ( method . getGenericReturnType () ) ) ;
assertTrue ( TypeUtils . isAssignable ( fromType , failingToType ) ) ;
assertArrayEquals ( expectedArray , TypeUtils . normalizeUpperBounds ( typeArray ) ) ;
@ Test public void testInvokeMethodForceAccessNoArgs ( ) throws Exception { assertEquals ( STRING_CONSTANT , MethodUtils . invokeMethod ( testBean , true , STRING_CONSTANT ) ) ; }
assertEquals ( expected , hostName ) ;
assertEquals ( isoForm , printer . format ( vulgar ) ) ;
assertEquals ( vulgar . getTime () , cal . getTime () ) ;
final T object
{ super(); for ( final String s : set ) { add ( s ) ; } }
final boolean excludeNullValues
final StringBuilder builder = new StringBuilder ( count ) ;
catch ( final NoSuchMethodException expected ) {}
final TimeZone tz = FastTimeZone . getGmtTimeZone ( timeZone ) ;
{ final boolean result = RandomUtils . nextBoolean () ; assertTrue ( result == true || result == false ) ; }
final Object other
@ Override public boolean inDaylightTime ( final Date date ) { return false ; }
@ Override public void setRawOffset ( final int offsetMillis ) { throw new UnsupportedOperationException () ; }
final Class < > anInterface
final ReflectionToStringBuilder oldBuilder = new ReflectionToStringBuilder ( BOTH_NULL ) ;
for ( final char chr : chrs ) { if ( chars . contains ( chr ) == expect ) { buffer . append ( chr ) ; } }
final String group
final String group
final double [] array
final float [] array
final long [] array
final int [] array
final short [] array
final char [] array
final byte [] array
final boolean [] array
final Object [] array
final String . . . s
final CharRange a = CharRange . is ( CHAR_CONS ) ;
final CharSequence cs
final String value
{ list . add ( throwable ) ; throwable = throwable . getCause () ; }
assertTrue ( String . format ( STRING_CONSTANT , delta ) , delta < NUMBER_CONSTANT ) ;
{ return performStateCheck ( increment ) ; }
this . typeArguments = Arrays . copyOf ( typeArguments , typeArguments.length , Type [] . class ) ;
daemon = null ;
{ daemon = Boolean . valueOf ( f ) ; return this ; }
daemonFlag = builder.daemon ;
public final Boolean getDaemonFlag () { return daemon ; }
daemon = builder.daemon ;
{ return valueAsString . startsWith ( getArrayStart () ) && valueAsString . endsWith ( getArrayEnd () ) ; }
{ return defaultString ( str , EMPTY ) ; }
final String sanitizedSeparator = defaultString ( separator ) ;
if ( str == null || suffix == null ) { return str == suffix ; }
if ( str == null || prefix == null ) { return str == prefix ; }
{ bypassReflectionClasses = new ArrayList <> () ; bypassReflectionClasses . add ( String . class ) ; }
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
for ( Field field : allFields ) { if ( field . getName () . equals ( JACOCO_DATA_FIELD_NAME ) ) { expected ++ ; } }
for ( Field field : allFields ) { if ( field . getName () . equals ( JACOCO_DATA_FIELD_NAME ) ) { expected ++ ; } }
{ buffer . append ( CHAR_CONS ) . append ( StringEscapeUtils . escapeJson ( value ) ) . append ( CHAR_CONS ) ; }
super . appendFieldStart ( buffer , FIELD_NAME_QUOTE + StringEscapeUtils . escapeJson ( fieldName ) + FIELD_NAME_QUOTE ) ;
if ( ! iterator . hasNext () ) { return Objects . toString ( first , EMPTY ) ; }
final StringBuilder buf = new StringBuilder ( STRING_BUILDER_SIZE ) ;
final StringBuilder buf = new StringBuilder ( STRING_BUILDER_SIZE ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
int [] indexesToRemove = {} ;
return ! str . isEmpty () ;
if ( diffs . isEmpty () ) { return OBJECTS_SAME_STRING ; }
{ return IS_OS_WINDOWS ? System . getenv ( STRING_CONSTANT ) : System . getenv ( STRING_CONSTANT ) ; }
private Object readResolve () { return JSON_STYLE ; }
private Object readResolve () { return NO_CLASS_NAME_STYLE ; }
private Object readResolve () { return MULTI_LINE_STYLE ; }
private Object readResolve () { return SIMPLE_STYLE ; }
private Object readResolve () { return SHORT_PREFIX_STYLE ; }
private Object readResolve () { return NO_FIELD_NAMES_STYLE ; }
private Object readResolve () { return DEFAULT_STYLE ; }
return replace ( source , valueMap ) ;
return getFraction ( numerator / gcd , denominator / gcd ) ;
{ Validate . isTrue ( objectData != null , STRING_CONSTANT ) ; return deserialize ( new ByteArrayInputStream ( objectData ) ) ; }
{ return ( T ) deserialize ( serialize ( msg ) ) ; }
Throwable root = getRootCause ( th ) ;
final Throwable [] throwables = getThrowables ( throwable ) ;
final int srcLength = getLength ( array ) ;
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
private Object readResolve () { return NULL ; }
{ final int tmpHash = hashCode ( object ) ; hash = hash * NUMBER_CONSTANT + tmpHash ; }
{ return ! equals ( object1 , object2 ) ; }
{ return isMatchingExecutable ( Executable . of ( method ) , parameterTypes ) ; }
{ return isMatchingExecutable ( Executable . of ( method ) , parameterTypes ) ; }
{ return getPackageName ( getCanonicalName ( canonicalName ) ) ; }
{ return getShortClassName ( getCanonicalName ( canonicalName ) ) ; }
{ return wrap ( ( Type ) type ) ; }
{ Validate . isTrue ( isAssignable ( owner , raw . getEnclosingClass () ) , STRING_CONSTANT , owner , raw ) ; useOwner = owner ; }
{ parameterizedTypeArguments = new HashMap <> ( typeArguments ) ; parameterizedTypeArguments . putAll ( getTypeArguments ( p ) ) ; }
notNull ( chars ) ;
notNull ( collection ) ;
notNull ( array ) ;
notNull ( iterable ) ;
notNull ( array ) ;
if ( isEmpty ( str ) ) { return str ; }
{ return replaceFirst ( text , regex , EMPTY ) ; }
return pattern . matcher ( decomposed ) . replaceAll ( EMPTY ) ;
{ return iValue == NUMBER_CONSTANT ? Calendar.SUNDAY : iValue + NUMBER_CONSTANT ; }
{ _mask = mask ; _shift_count = mask == NUMBER_CONSTANT ? NUMBER_CONSTANT : Integer . numberOfTrailingZeros ( mask ) ; }
mRule . appendTo ( buffer , value == Calendar.SUNDAY ? NUMBER_CONSTANT : value - NUMBER_CONSTANT ) ;
if ( lhs ) { comparison = NUMBER_CONSTANT ; } else { comparison = - NUMBER_CONSTANT ; }
if ( rhs == null ) { comparison = NUMBER_CONSTANT ; return this ; }
public int getThrowableCount () { return NUMBER_CONSTANT ; }
